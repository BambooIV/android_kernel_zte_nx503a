From db509cccc69e534734861d98b3da5ec279ec7b0e Mon Sep 17 00:00:00 2001
From: BambooIV <ningdisheng@gmail.com>
Date: Wed, 3 Feb 2016 10:00:40 +0800
Subject: [PATCH 41/50] nx503a: msm: camera: Revert back to ztemt

* Base on tag 'LNX.LA.3.5.2.2-01210-8x74.0'

Signed-off-by: BambooIV <ningdisheng@gmail.com>
---
 Documentation/DocBook/media/dvb/dvbstb.pdf         | Bin 1881 -> 0 bytes
 Documentation/DocBook/media/v4l/crop.pdf           | Bin 5846 -> 0 bytes
 Documentation/DocBook/media/v4l/fieldseq_bt.pdf    | Bin 9185 -> 0 bytes
 Documentation/DocBook/media/v4l/fieldseq_tb.pdf    | Bin 9173 -> 0 bytes
 Documentation/DocBook/media/v4l/pipeline.pdf       | Bin 20276 -> 0 bytes
 Documentation/DocBook/media/v4l/vbi_525.pdf        | Bin 3395 -> 0 bytes
 Documentation/DocBook/media/v4l/vbi_625.pdf        | Bin 3683 -> 0 bytes
 Documentation/DocBook/media/v4l/vbi_hsync.pdf      | Bin 7405 -> 0 bytes
 .../devicetree/bindings/media/video/msm-cci.txt    |  26 +-
 arch/arm/boot/dts/msm8974-camera-sensor-cdp.dtsi   | 165 ++++++--
 .../arm/boot/dts/msm8974-camera-sensor-liquid.dtsi | 178 +++++++--
 arch/arm/boot/dts/msm8974-camera-sensor-mtp.dtsi   | 166 ++++++--
 arch/arm/boot/dts/msm8974-v2.dtsi                  |   8 +-
 arch/arm/mach-msm/clock-8226.c                     |  30 +-
 arch/arm/mach-msm/clock-8974.c                     |  16 +-
 drivers/media/platform/msm/camera_v2/Kconfig       | 130 ++++++
 .../media/platform/msm/camera_v2/camera/camera.c   |  10 -
 .../media/platform/msm/camera_v2/isp/msm_buf_mgr.c |   9 +-
 drivers/media/platform/msm/camera_v2/isp/msm_isp.c |  76 ----
 drivers/media/platform/msm/camera_v2/isp/msm_isp.h |  60 +--
 .../media/platform/msm/camera_v2/isp/msm_isp32.c   | 190 ++++-----
 .../media/platform/msm/camera_v2/isp/msm_isp40.c   | 198 +++------
 .../platform/msm/camera_v2/isp/msm_isp_axi_util.c  | 242 ++++-------
 .../platform/msm/camera_v2/isp/msm_isp_axi_util.h  |   5 +-
 .../msm/camera_v2/isp/msm_isp_stats_util.c         |   3 -
 .../platform/msm/camera_v2/isp/msm_isp_util.c      | 445 +++++----------------
 .../media/platform/msm/camera_v2/ispif/msm_ispif.c | 105 +----
 .../media/platform/msm/camera_v2/ispif/msm_ispif.h |   1 -
 .../msm/camera_v2/jpeg_10/msm_jpeg_platform.c      |   6 +-
 .../platform/msm/camera_v2/pproc/cpp/msm_cpp.c     | 421 +++++--------------
 .../platform/msm/camera_v2/pproc/cpp/msm_cpp.h     |  12 +-
 .../platform/msm/camera_v2/pproc/vpe/msm_vpe.c     |   2 -
 .../media/platform/msm/camera_v2/sensor/Makefile   |  12 +
 .../msm/camera_v2/sensor/actuator/msm_actuator.c   | 307 ++++++--------
 .../msm/camera_v2/sensor/actuator/msm_actuator.h   |  22 +-
 .../platform/msm/camera_v2/sensor/cci/msm_cci.c    |  49 +--
 .../platform/msm/camera_v2/sensor/cci/msm_cci.h    |   5 +-
 .../platform/msm/camera_v2/sensor/csid/msm_csid.c  |  17 +-
 .../platform/msm/camera_v2/sensor/csid/msm_csid.h  |   4 +-
 .../msm/camera_v2/sensor/csiphy/msm_csiphy.h       |   4 +-
 .../msm/camera_v2/sensor/eeprom/msm_eeprom.c       |   6 +
 .../media/platform/msm/camera_v2/sensor/gc0339.c   |  14 +-
 .../media/platform/msm/camera_v2/sensor/hi256.c    |  13 -
 .../media/platform/msm/camera_v2/sensor/imx135.c   |  16 +
 .../platform/msm/camera_v2/sensor/imx135_069.c     | 193 +++++++++
 .../platform/msm/camera_v2/sensor/imx135_front.c   | 192 +++++++++
 .../platform/msm/camera_v2/sensor/imx135_gbao.c    | 216 ++++++++++
 .../msm/camera_v2/sensor/imx135_gbao_lc898122.c    | 217 ++++++++++
 .../media/platform/msm/camera_v2/sensor/imx214.c   | 208 ++++++++++
 .../platform/msm/camera_v2/sensor/imx214_app.c     | 205 ++++++++++
 .../msm/camera_v2/sensor/imx214_lc898122.c         | 209 ++++++++++
 .../msm/camera_v2/sensor/imx214_ois_sharp.c        | 212 ++++++++++
 .../media/platform/msm/camera_v2/sensor/imx220.c   | 209 ++++++++++
 .../msm/camera_v2/sensor/io/msm_camera_cci_i2c.c   |  35 +-
 .../msm/camera_v2/sensor/io/msm_camera_dt_util.c   | 123 +++++-
 .../msm/camera_v2/sensor/io/msm_camera_i2c.h       |  19 +-
 .../msm/camera_v2/sensor/io/msm_camera_io_util.c   |  11 -
 .../msm/camera_v2/sensor/io/msm_camera_io_util.h   |   2 -
 .../platform/msm/camera_v2/sensor/msm_sensor.c     | 239 ++++++++++-
 .../platform/msm/camera_v2/sensor/msm_sensor.h     |   1 -
 .../msm/camera_v2/sensor/msm_sensor_driver.c       |  14 +-
 .../msm/camera_v2/sensor/msm_sensor_init.c         |  22 +-
 .../media/platform/msm/camera_v2/sensor/mt9m114.c  |  15 +-
 .../platform/msm/camera_v2/sensor/ov5648_z7mini.c  | 221 ++++++++++
 .../media/platform/msm/camera_v2/sensor/sp1628.c   |  13 -
 .../media/platform/msm/camera_v2/sensor/t4k35.c    | 179 +++++++++
 include/media/msm_cam_sensor.h                     |  18 -
 include/media/msmb_isp.h                           |  28 +-
 include/media/msmb_pproc.h                         |   9 +-
 69 files changed, 3896 insertions(+), 1887 deletions(-)
 delete mode 100644 Documentation/DocBook/media/dvb/dvbstb.pdf
 delete mode 100644 Documentation/DocBook/media/v4l/crop.pdf
 delete mode 100644 Documentation/DocBook/media/v4l/fieldseq_bt.pdf
 delete mode 100644 Documentation/DocBook/media/v4l/fieldseq_tb.pdf
 delete mode 100644 Documentation/DocBook/media/v4l/pipeline.pdf
 delete mode 100644 Documentation/DocBook/media/v4l/vbi_525.pdf
 delete mode 100644 Documentation/DocBook/media/v4l/vbi_625.pdf
 delete mode 100644 Documentation/DocBook/media/v4l/vbi_hsync.pdf
 mode change 100644 => 100755 arch/arm/mach-msm/clock-8974.c
 mode change 100644 => 100755 drivers/media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c
 create mode 100755 drivers/media/platform/msm/camera_v2/sensor/imx135_069.c
 create mode 100755 drivers/media/platform/msm/camera_v2/sensor/imx135_front.c
 create mode 100755 drivers/media/platform/msm/camera_v2/sensor/imx135_gbao.c
 create mode 100755 drivers/media/platform/msm/camera_v2/sensor/imx135_gbao_lc898122.c
 create mode 100755 drivers/media/platform/msm/camera_v2/sensor/imx214.c
 create mode 100755 drivers/media/platform/msm/camera_v2/sensor/imx214_app.c
 create mode 100755 drivers/media/platform/msm/camera_v2/sensor/imx214_lc898122.c
 create mode 100755 drivers/media/platform/msm/camera_v2/sensor/imx214_ois_sharp.c
 create mode 100755 drivers/media/platform/msm/camera_v2/sensor/imx220.c
 create mode 100755 drivers/media/platform/msm/camera_v2/sensor/ov5648_z7mini.c
 create mode 100755 drivers/media/platform/msm/camera_v2/sensor/t4k35.c

diff --git a/Documentation/DocBook/media/dvb/dvbstb.pdf b/Documentation/DocBook/media/dvb/dvbstb.pdf
deleted file mode 100644
index 0fa75d90c3eba1db9d07611ec6d86b4bc22d7a39..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 1881
zcmZuydpJ~S7~f|KIaF3y&#K4C@?fQN&X~cZB}}7n$?S|Snrsbom~oj?bIug0wn8kc
zWK(H-+7OFXF1b{;wC<~xY|>U#(nW~WZi}e>jwUvB&L3ya@BMzi^S<x*e!sC0aCx@a
zVmrv9p?`lS#D-Cr2n>amE=9a?MF=H>?ExZ0c=B)xSHcJ{TteYoJcy9u&dv}?DRD^z
z6nX5_Y9GSHLGQwgHP2*P=;idTXWd6~<h$?aYd^{8$w)A~9e2aEL-T3Npvmddb%Xf|
z-B}EC$(ENFx_(4<4q++#U*3GPbAHFx!KA8@YuN(F;?b%FBThGVjJ^74eX@bj%(pl+
z;g7K9j01;f#-4n=`LX?gP6wYeno+fN(7d<b_giXE5r9Lt@-5qq6RR(<pi|f)i@1(^
zt76^r?sXf-NYAh|(){&vll+-ld3E#B=Id|m-|)?d*3Wx|B}AOtcN#NA!v)K*v&qr%
zR>W$!#yV4l+VuJsHfyS0F>I|H3|KRKl^dOUTN#F#SW3N7%E@zeB}aml^LOx$@x4;l
z$Miga7-b^cvh@tzmec}wr>kxaq-**<QBg>)INv|U{BBB3W8miN)fpqVgt?)(*X-fi
zi(mKh<Fea7FR5nS$FAnEWkWu#nw}ncoEgd248j^r1GM*Mwdw5YGXI^KLbzCl7<xq|
zCAyUyBzZByql^CiA<k@xSFX6e$Ha!0KwVBC{~l?HS&6uCdh|Cs@=J83-D_bFc?f@r
z*DqhS=Na!m<o=|XixodMGCzGK`a#bb8JZLRkQG*BJ!Uz(e5Ubn3;%fgup-j6v$?c9
zT}(#hs}__wv${y<c<u3HEftTv!)i;H$DCk=mh)ECd2=03>=wCr*Ut&{YdvqVqPYEf
zVpGXLbDmwbWtm=<p%~KcWM}v5h4HORrK)osjzLX_KB=)zT?LyQ*2vbKEsV&3qE{M6
z>@ob5vu8L?<BCT7-c;Q^#TSjw@A72IYVGHcwKcu-m<5@gjB)HwE~jU$UR$Qd!gH>k
z=@GMTKQ3FDZnE!So@U}Ut9u%kHYG|IG$yt~!`=eqX6co6Zp9Tr2^Pr>SIX1oG_6aL
z>8!{x5dW4{!d}>&;5FKhnI2?0)T$!GFvB-%8UQ_2YS@@qK6lTHW&ikub+)&Cwmr?t
z(!`h%TvMdkWM--LBJ$z(UtI%bV^wcP9ES%h&gR^|FH?zc5-#V4Mm_Jm+~Bq)fg_D(
zo!x-!+&(t;?8ZRX=<`G~&5pXcm0f)<l?|8gmb-KxjXlnNe!7VJ#g{ciVP{=@Wnbsx
z%TG-Q@>zYCbi>b7z23H?q9Us)w(rixs8{s`?QKWyktZDrE1e8&jE2^H@8wtBJRmb_
zs~LQBDOMTBh;|-msW9zty=|);ZywjNX%zg0E2Qf42!7FLm_E7mlY=rLHN=`a-hNS=
za6}*p!4V%^Dwntsk+2vAVLOx!V{B#s1cFLjLBV#k0YHclCkd4@2q%Fx2$V#S2&cpd
zFb^2<!y_rMe0e10A)<giz?`=X9s$@Gtto_nSs?D<9SD*zZ88&(IxG4MZ%qe?fwbU>
zyhs@Fl1oWg4AEH&p#T^tsAx%AO-;onscNRXgp!04A@3yKCO@^_;r;bfNkfRQzz4>h
zoz=p04QeA4IzTi{IHfXC)Vru7<oJG+epLtEBqUC^0r8VZ;H0gPh>$2I5=CefLPV-S
zirxphYVhrMRWYX&K&z#yAY5s+TqJ-!WCTf(K}z{13U<WUi&3UEXe;nwN=_)ap!HVV
zB}^3MfZLvlvK&wji2D%IkB25}ja1^n5DH@$gic<tJ)3REhJ#@>hA}a)ZS(~zCNUNh
zv}qcKvBBI;!%*}C3`IZGLphG1(bKq0d$5PoFuRXoC>WFJ>+Jr=rIZqRIIaYLZ7?E|
zZ^J>oFd`%fFi`aV!3bXwOu%&O!L;+au-Ix{N2b<Oe&N*vf|mSUTK%5ZA0h$tERvK&
SNli2nW3y1m!eY5E5Bd)oFwcSj

diff --git a/Documentation/DocBook/media/v4l/crop.pdf b/Documentation/DocBook/media/v4l/crop.pdf
deleted file mode 100644
index c9fb81cd32f34d2b08cb601f3a1575af77e14275..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 5846
zcmb_g2{@G9+kY#<pio4%5klgbXErku+4m(&k#(5C*oK+0g%;%%i7ZjlMp4O@P+BCi
zBuf#+M6y*#A)?}Yo(a|a{=e(HzVG_xy3U;Q-21uDdFKAzBX6Z=paQC55c2h7N!bWI
z5{0C>`yezl05eK}7t<T522rd51F9dBLPr7yek3MEkK#ciQ#3UZ3?`jI@<)Vajb|Ds
z39AVlnwZ!-4fea;JC)&k`51<LSwa?#(%mA}baH4SZ;ak!_hsKvK}*G0Z@GD2En3-a
zr+}%T(mMb0A16k}=cYeTPwTTjYMr|gSLQdXQ1K&VQocXGFZ#2H->a6=+EX9OD-<r=
zzzn@r@!GIKgpg74{(IE@x9zLb)7<IDz7%s@S9<W}Lv&;CRLgDh&V0JV&DIUE@zvrJ
z>rD3KpT6I?aPtuVIbW2LRN4)LbtxDn=`?bx#Mk1DjNQeap|gX7=0;NGRf}EoYVGr9
z+btFLtpd(pN-0p{EI)0|f5>L-!?-KWLq}V0@4Q#nT~O#-CS$usypvndYBQ~1RflVx
zS3_x`@hSDtlKGh<rGm<DWjP1Fuca3CaQO3oI{e}Y=f<_)^zUZe`*8P|$$HAf;=;zp
zCnNcre<<HanpBndlrDb9o|RRcAh^!AUO6s#yFaGJRW-i+Wz{RU*Y$?)QIDz~CxI=y
z8w)?b7;uT!i8@ZoB(w%q`0##CSahFgHqK_~7mo*zsIN}AVBTzhNb*vhP@+SLMRCi(
z&A!OTr#ky`XjNZ1-kokU_470B8u>^r=qbxAiRk;Go_<JK*i;9*F;Qo<%^^0ao7d_9
zpR&EIn5n#|u8#6&QTqOREv;9*1t%{0S8of<0(5G6E}e97m<iLAvTZeOUd=BCB4>G=
za;iMRD>YM>GRtJrx`SN0-VK{dHsqO{=JYh>7Lp{Le8+RHwoR~10VU)ahn3_N+CVya
z8X`%3@GB5fCW+W@moZ`<)y`I63f<i$BB|{r_f+VxfZWzcNN~gcxcXp2uibA&3C4WB
z>U_o*hxH|13mxmXN)x`V{K9y<O_YT3#m(}$)V~tttjvW5Zf?~T;!X`ee1N!0w?g7?
z86qKIyF|Uaw`zTffI(cix=MZjE#oaWWJGh71nM<j)R&lf1l?%o5lz`uZXZW}nI&f(
z<HYgtoI@O?Qlb9d@I#cj;UKr~2fhKOYGO^XOZJ6;+Gpmm{oZ-LsG}r%<r1^fz^Cmj
zi3}2PU5!ZG#!p$NjH;i7$H|^Fh?9L6UHi--#i*THoh8fDv3gO*WJ?>Xq$qtVu?Dwm
z%N2!}_h_;HMZI_U6P<81y<5sE^i-ZN@X|Z8j-?Kp@n!M`bvVTxai_)I_cR>C&W?%i
zL#q-6HZ{vdwPYICg><Kwp=UOnbV~sZo8>%aAkx@It`xz&W$r1U9Yom%QPOa!2|U=;
zgz=NgXUN9J40px=pQ%Fhz|EL9#gV&;U0sw;lZ&)5@2_ud&avn)i`r9kX4tA=xWpvh
z(_RxGfDVL_p_=IWeZ`rhlXfl7R4;5COP}DGX`1DTrR=B<noDuB*OWa?Hq)N^B$juE
z?B}W|mzr==cugbs#W0#Uu3ZA@z188N@78nEsYl;{>2?}^8}mIkD~mKImkmjDN^pFW
zKkjx@Nv_!=K>zbGl}4XjqCyd|s0<(!lmVjYH15Qv3=S@lHN*%J3~`4@1kq8XMr<M?
z_JvdDz71Jj-5XhC4fO?l)o5Q+-TMmv+1&ARt~}T6H8pO1b?<I<r%~rCUs~p?M4pkV
zo*B6ABbQj!^}bk=kYoPpp?XER#!I>SmVz{DqHg{T3&wn<)Pw1c(aDBc)Tot4>Hf!<
z#XTD6eMR9<Ur-b8^2M+5Z3@qNdVM&#Cwe$2Iw*difu@Z~-5u!ZPfThzex}h%jURY^
z>P>RJW3z7Ejqoh}oZ+DBLGf$O*>z8zG7D&b&ea(H-YL+5A>x!#NT{DH(<^a&P;nYf
zi*K=_jtdq!8%`c8M-pF^Ihsm2_;qUBOwA4_E9_>FA^T&sR0~YENed>^RMkwR1+xD#
zIYGto)R^aVhDNrQw~NEw!P{g(K8Wv<x3N)nelK+XUos7EaX$X0bVX4rxUzr~BZ+8f
z&yY*<tMl0^R;^U7od3p5bMB7hx&qaZ+af0tv|jdi<E$pveY+^h<CvNw`b6Lv|A}#%
z&(jXh6_u=k!nPsSkYdB3#>9|oFRR{paN`bVZ<uk3_$$dXGWKLaXGmyFp;VOfNj`o5
zo|#VzWs+un!`I*QcoZv!lRVa%edpK17cDg2QBlY9ZZbtjMdgMhzXJG7s^+3I%@=(}
zkmbBaxfHGwha4VhE9UOGG~3D&8`CW76O))r`#2d%7#r%C)*CFVwyVri<1#xl;t}I}
z)|+=MgUhwAT|C6Gr_e`1i*-TMy|XJ^BcQcsy;@!#@CjGudvAO=fTiZ~_HRiK^3}TG
z^gLFUW#13szIoRG>E464qvoo=&o8uw7HLKuoci{@{_OZ%<ISG_#v}=$_*Gpw5k8A&
z-?%sIEt-&W>079-$BuvZuD>`il$?|8+#`Hq4NW7{CBY}4%Z<6WSK7H?^h@%ZwT|Ys
z*>3#je+-9(PDr-^8G+*y(m+x7Bqe~nR4<_wTw~$N3eO+`gF-CPaKGxWZFnFBup)U;
z0CNhNO46Z)AstZ=8w-M}Y6K)mAgba(X9OfdrvxyO7`RR&0BZ_^7EJe`FrW%<MW=b#
zP?(MYRO69=EhUTziR*_k4Q-fE6-R>LPZa|iqz<Cl4^UADbfIU+A_ED70c!+AS_%$!
z@e>?C)}ZK+?C=;!z?4d6ARQ5K@YV=tBxE5NHu;+>>}m;D{M6JXF-d+juVoWIqyOa!
z`=|V`r~wO-KLxPH0=CwGF&PSz$_xiAt;~@iU}KI%siM%ojIcMj<kcFBfNfg;#)Wsh
z%mq;h5KiuIeBv)Q`zYWv=}{OSbZQ`zMhD<Wb}Tyfd+aO?l#M8UArvOngT&_OK*!~%
z0;*w=Drf=@38K&hBoT*kh5?ip1BpQ+0Bwc`d~OgGN;xUeh(h)9W+K(FAOe8hz&uzN
z0T@G>qIzftc==I~C<I``r1<ZFEMgIWIhDbn26*kIk|CgmRwEz)`z13t3=y*GO`=2R
zuLuNE=u{dRV208FPv~|4!2x6no#8>FQved+4tM}$fC6{|et<s^0MLLyfDSMKCJ+pS
zC?VL}f#4qngCzW!Aoy`9e>TDHO!&IOi2`+((Bki4aT!g5?1R?STtSY`w!Bt0dpAFj
z8SL%ZrhUid+L5iFLBxYywSuO`uLQW!tA?CaG@~0=%kwBDDSj2*=P#W2)s5M7+ipv|
z^{8S;bO`4vl}<`ova=aahn3EyTLWVun?e_lE3|y%arEkHVclW099*oQd+;sFP;YMD
zYD=<r?uUY>3H+a%g!l~dFUcK@Z4r0c!V!1$j^-l`a8LiRS6OR{+|<?67yYW{@0c0=
z6$x%goYS4-GubXQeqB@8(OXIRNo%w6ZVs=@o-x}U%fBB?wj1p%uo+Cd|25l6JbsGN
z9RHY1!in;#Y&~*E&P34k=83xRlJQO+XXK0QFSU>I@25HBws<RA)sBcysif=VZz16I
z1f@jEeK^Bo6h_X{O^ypw)fpu^`9`?G^v%Kg0H;!XCZ%`x)e6xAj<!zLKDZBNMCFPY
zL#vLpCg%Q^-(KCg?fi2qs;&AdZHl#nt<aV1lxy}+F2r9V#OH-Q5*#v3v9PjuCZ1iY
z*&Znrbv^2Qob2NrkEM@m&6>~pCvzBy7-!1`3voH6AkH;xy*xeig7e~mApwaXPI^WJ
zr}#t(zcz2pmmi}R6Q7QxOYRd}s4%rceXQMaJV)(}ts|K=BFh)*U~C$rEC1us<N-nY
z@tD<L&uE3^znyHUW8wXC5G7#;6ldfY<@VdI;&mH7w8ryXTG5r+!q<g1vUu$4RTyM(
z6R|U5r(v+Qre0<6gLiAs1%O$b3Ma#izplPf_aT{6V6~~i1s%Q{Nv9t+4aT1Oo)nrE
zhM%#FTjzYHd%Xll<a>#Xh_i%t|L9I0ljtUX$-+Jj#Nd;dAE{f<`yQ_yd3Uen*72ah
zFh)%Yw_!g)O{6-KxOZVw$ASL3DEz{+%W>61FAbg>RwX>bl(?F7d}te_X(OIT^d*KH
zx|Q<VT9B?yafVi~4rk@?o}H8NzF6dSOSngnSG(^BclIF5@}kQcP5VL%6{F`(w-2xS
zo1u6iqn#z1W@+$QEAorF7+PiSOYsY(BX8C(ygnjpLztJTUMF~Tef1!??s!aUagyN?
zX%=hBVIk1gko$0P7$=FawmzXbRvz`5!qsgcsv6hYV!rE)_voERqdT;SpN#Fel%MAA
zEFFt%PQANR_gEAw$H69UTmH78uj_AZR23BS9uw$L&<XrY+1dT8<ZkU+k9m{V?}syG
zuYO1vlPMkbe%w#5-B#guJUO<Wx_{>@Rhb@tugfU2Cw8(`D8UAt=68La5wSr+dq_d@
zkQ6?Pc<|mg)Hlh}ius5Ah_u6WL~o+!o!kqeg`XG6wxfT~#-#{xD!G1HZ>}~YD{zJ8
zol)rftcEX@btgZ9c3)U**su3{qEG&%nHzTH6CGT6nttwk+YL)D?BpC4>~s~cTr6cc
zjy{^2yo$-}JKLI_OH^|NUR6Etu_#JE5!RnR&0{)lW1qv*xtY$w6)Oq>*1ij4yW7s}
zHJ=^*a6QR6?F(8scE)bp!0%&(!r8$?u{_;Mtz&Zb&Ve1m1KfjkoTGl#b%E(dEDPo5
zZ?|-g7Jg~q*!q0KQ$3dDx4Q}A6Ndhqx}|Pz<5JSX+Nnklzbe)*Hr~@lc)8((unyKC
zy3->yA$fy{OwZ*?i=%(n7H2htj5FHXE>oXK-w%q?v9H?ORaRS|cGR-x>#Xwn?Dc}a
zy;0Y-*Ug>|GT$-W*OC5Viu^cz*6ftSn1J(C-mrm!yQE6Y*}*G(Pf9;JR7qD==8d^k
zKN#HNfq!1iDjZsm|30Pd71iY|7AiXxrW>@kt^R8Hybga)&6~#$C$9z`4ByRTj2#{s
z>y=3JzTFXi_x;=1vdQEm3+emzO@(fkQ<GdOEw}e7oV+{v)+F4Fyx2S*F{9-I$~Amq
z&>r5sA8J?CdslcE)beB=t$lw(T&*b~lsSS`T<0Ginx8(jPa0$i%l}ZO?QnN$(~k5S
z-y*S74RpFQ;G5}d{-Bfkk$3egMWbDuPjHqc+h<go4DL&8mK9T!eIT`1)Su#lmnf+|
z%58p3#y{HicA)#C9qaOY;=Y|f#>utr%}z@^k7f6L(xAw`d3~KXSM3RJhj$jWDO76t
z)BENfyL=ChSH6g4y$ks4?_63)9A&QF7bAq27LVr>?%C$?N^riRdEkWfi>`_T&)VW%
zRu@_KnMI8F`xk0pdAW*SpD&h<Z5B-Ucufq?EhcbFZ=0m7yC{cz(ka=Ck?O^}UY>7o
zi&e0@DWraSm8+AUuHdv$;Cfk=Yn%LnPuk`c<ee+3%q1q7U-+mFzD~+sSaa}L@D&*I
z{0Z0Cr3<ciAfC8_*Vv%pKNUehhs2=37y<YfK3G8$OIQX(v1{xvY=MNK2mGH4oxy}_
zI0P2}Gt$x;jROI8!Dl!kppp-leIy2lL*j6F_8<_5NIYH*iAIA+3<mRaKr|cy`%@O8
zE$Jbab^fP$*$-@EW#I4-WCC$)XRt#xG@3o&H6DUqYEWP>4OYgXP;5Ea5djK-Eeqil
zw%(H5iXNl`uZdXfif!25auD#0#X}o{0zgBuE5SoPme*{bO9_Ex*m4jbo?-t>aw`dd
z69vb(q6e+v7-8D-z+j*R;!#jSe<lHvT{!?)@Bc9VU-a3rFYOhC^0u6V<ryUYya@2~
z@`YI16Wjl?96T@Y0f$k8F4fO`t>{2}5CtWK{RK-xr^2?dEb-sXu<SDL_ccU=uFz82
zmtFraXLbN9MlfnW&+vC6@V?-?$QHujaVwi#5@K6`-<sc*{#Zj70lt9j3kgCk*RLMp
zw-y3ww#dOA6uP3Jg&oq+o5o=NY!#4dswkY2rsh%)6-K9cBA^^%5zxk$K1e(chruB|
zkxMi*h=cki_=5~srs1#{2yg#ML!*dL0RNzYMCjM!PZ~&stp9_Cf?wT#(4d?0FB%#T
z{>vU3gMoUbKYd`a|3Mdx|98x2;=gEE3=!(hmhCa=B&ge<Lw`Xd0UPRms87Wr0c#o!
kYAE5KMI>Mx;7LQSw5tpziOyta6^A7d5c2Z+mIjFb0>QBtCjbBd

diff --git a/Documentation/DocBook/media/v4l/fieldseq_bt.pdf b/Documentation/DocBook/media/v4l/fieldseq_bt.pdf
deleted file mode 100644
index 26598b23f80daf8048fdaa9a83a39a0e8ba12f19..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 9185
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
UbNNdS($XYgVM<D-c4n~u2a2_wzyJUM

diff --git a/Documentation/DocBook/media/v4l/fieldseq_tb.pdf b/Documentation/DocBook/media/v4l/fieldseq_tb.pdf
deleted file mode 100644
index 4965b22ddb3a85aa27a4e6f98c931323605dd26e..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 9173
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

diff --git a/Documentation/DocBook/media/v4l/pipeline.pdf b/Documentation/DocBook/media/v4l/pipeline.pdf
deleted file mode 100644
index ee3e37f04b6a788e255ce26d1607e77ba2c119a3..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 20276
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
V%8y_8ZbSy1$UvHzIeI!F{{we5{PX|-

diff --git a/Documentation/DocBook/media/v4l/vbi_525.pdf b/Documentation/DocBook/media/v4l/vbi_525.pdf
deleted file mode 100644
index 9e72c25b208db6c7844ed85fe9742324602c0a5c..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 3395
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

diff --git a/Documentation/DocBook/media/v4l/vbi_625.pdf b/Documentation/DocBook/media/v4l/vbi_625.pdf
deleted file mode 100644
index 765235e33a4de256a0b3fbf64ffe52946190cac4..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 3683
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
O%*+C6V6bby1N2|1C{8y3

diff --git a/Documentation/DocBook/media/v4l/vbi_hsync.pdf b/Documentation/DocBook/media/v4l/vbi_hsync.pdf
deleted file mode 100644
index 200b668189bf1d0761dbcd75f38e43cb4d703a33..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 7405
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
Z)<*{hlj6^0trDJuCm<vxbxd^;{{w1gP%Que

diff --git a/Documentation/devicetree/bindings/media/video/msm-cci.txt b/Documentation/devicetree/bindings/media/video/msm-cci.txt
index da54138..f256d78 100644
--- a/Documentation/devicetree/bindings/media/video/msm-cci.txt
+++ b/Documentation/devicetree/bindings/media/video/msm-cci.txt
@@ -171,22 +171,6 @@ Required properties:
     - 0 -> MASTER 0
     - 1 -> MASTER 1
 
-Optional properties:
-- qcom,cam-vreg-name : should contain names of all regulators needed by this
-    actuator
-    - "cam_vaf"
-- qcom,cam-vreg-type : should contain regulator type for regulators mentioned in
-    qcom,cam-vreg-name property (in the same order)
-    - 0 for LDO and 1 for LVS
-- qcom,cam-vreg-min-voltage : should contain minimum voltage level in mcrovolts
-   for regulators mentioned in qcom,cam-vreg-name property (in the same order)
-- qcom,cam-vreg-max-voltage : should contain maximum voltage level in mcrovolts
-   for regulators mentioned in qcom,cam-vreg-name property (in the same order)
-- qcom,cam-vreg-op-mode : should contain the maximum current in microamps
-   required from the regulators mentioned in the qcom,cam-vreg-name property
-   (in the same order).
-- cam_vaf-supply : should contain regulator from which AF voltage is supplied
-
 Example:
 
    qcom,cci@0xfda0c000 {
@@ -216,14 +200,8 @@ Example:
         actuator0: qcom,actuator@18 {
                 cell-index = <0>;
                 reg = <0x18>;
-		compatible = "qcom,actuator";
-		qcom,cci-master = <0>;
-		cam_vaf-supply = <&pm8941_l23>;
-		qcom,cam-vreg-name = "cam_vaf";
-		qcom,cam-vreg-type = <0>;
-		qcom,cam-vreg-min-voltage = <3000000>;
-		qcom,cam-vreg-max-voltage = <3000000>;
-		qcom,cam-vreg-op-mode = <100000>;
+                compatible = "qcom,actuator";
+                qcom,cci-master = <0>;
         };
 
        qcom,s5k3l1yx@6e {
diff --git a/arch/arm/boot/dts/msm8974-camera-sensor-cdp.dtsi b/arch/arm/boot/dts/msm8974-camera-sensor-cdp.dtsi
index 2e58167..157c136 100644
--- a/arch/arm/boot/dts/msm8974-camera-sensor-cdp.dtsi
+++ b/arch/arm/boot/dts/msm8974-camera-sensor-cdp.dtsi
@@ -27,13 +27,130 @@
 		qcom,cci-master = <0>;
 	};
 
+	qcom,camera@6e {
+		compatible = "qcom,s5k3l1yx";
+		reg = <0x6e>;
+		qcom,slave-id = <0x6e 0x0 0x3121>;
+		qcom,csiphy-sd-index = <0>;
+		qcom,csid-sd-index = <0>;
+		qcom,actuator-src = <&actuator0>;
+		qcom,mount-angle = <90>;
+		qcom,sensor-name = "s5k3l1yx";
+		cam_vdig-supply = <&pm8941_l3>;
+		cam_vana-supply = <&pm8941_l17>;
+		cam_vio-supply = <&pm8941_lvs3>;
+		cam_vaf-supply = <&pm8941_l23>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
+				     "cam_vaf";
+		qcom,cam-vreg-type = <0 1 0 0>;
+		qcom,cam-vreg-min-voltage = <1225000 0 2850000 3000000>;
+		qcom,cam-vreg-max-voltage = <1225000 0 2850000 3000000>;
+		qcom,cam-vreg-op-mode = <105000 0 80000 100000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 15 0>,
+			<&msmgpio 90 0>,
+			<&msmgpio 89 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1",
+					  "CAM_STANDBY";
+		qcom,gpio-set-tbl-num = <1 1>;
+		qcom,gpio-set-tbl-flags = <0 2>;
+		qcom,gpio-set-tbl-delay = <1000 30000>;
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x1F>;
+		qcom,sensor-position = <0>;
+		qcom,sensor-mode = <1>;
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+
+    qcom,camera@20 {
+		compatible = "qcom,imx135";
+		reg = <0x20>;
+		qcom,slave-id = <0x20 0x0016 0x0135>;
+		qcom,csiphy-sd-index = <0>;
+		qcom,csid-sd-index = <0>;
+		qcom,mount-angle = <90>;
+		qcom,sensor-name = "imx135";
+		qcom,actuator-src = <&actuator1>;
+		cam_vdig-supply = <&pm8941_l3>;
+		cam_vana-supply = <&pm8941_l17>;
+		cam_vio-supply = <&pm8941_lvs3>;
+		cam_vaf-supply = <&pm8941_l23>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
+				     "cam_vaf";
+		qcom,cam-vreg-type = <0 1 0 0>;
+		qcom,cam-vreg-min-voltage = <1225000 0 2850000 3000000>;
+		qcom,cam-vreg-max-voltage = <1225000 0 2850000 3000000>;
+		qcom,cam-vreg-op-mode = <105000 0 80000 100000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 15 0>,
+			<&msmgpio 90 0>,
+			<&msmgpio 89 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1",
+					  "CAM_STANDBY";
+		qcom,gpio-set-tbl-num = <1 1>;
+		qcom,gpio-set-tbl-flags = <0 2>;
+		qcom,gpio-set-tbl-delay = <1000 30000>;
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x1F>;
+		qcom,sensor-position = <0>;
+		qcom,sensor-mode = <0>;
+	        qcom,sensor-type = <0>;
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+
+	qcom,camera@6c {
+		compatible = "qcom,ov2720";
+		reg = <0x6c>;
+		qcom,slave-id = <0x6c 0x300A 0x2720>;
+		qcom,csiphy-sd-index = <2>;
+		qcom,csid-sd-index = <2>;
+		qcom,mount-angle = <90>;
+		qcom,sensor-name = "ov2720";
+		cam_vdig-supply = <&pm8941_l3>;
+		cam_vana-supply = <&pm8941_l17>;
+		cam_vio-supply = <&pm8941_lvs3>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vana", "cam_vio";
+		qcom,cam-vreg-type = <0 0 1>;
+		qcom,cam-vreg-min-voltage = <1225000 2850000 0>;
+		qcom,cam-vreg-max-voltage = <1225000 2850000 0>;
+		qcom,cam-vreg-op-mode = <105000 80000 0>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 17 0>,
+			<&msmgpio 18 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-req-tbl-num = <0 1>;
+		qcom,gpio-req-tbl-flags = <1 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1";
+		qcom,gpio-set-tbl-num = <1 1>;
+		qcom,gpio-set-tbl-flags = <0 2>;
+		qcom,gpio-set-tbl-delay = <1000 4000>;
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x7>;
+		qcom,sensor-position = <1>;
+		qcom,sensor-mode = <1>;
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
 
 	qcom,camera@90 {
 		compatible = "qcom,mt9m114";
 		reg = <0x90>;
 		qcom,slave-id = <0x90 0x0 0x2481>;
 		qcom,csiphy-sd-index = <1>;
-		qcom,csid-sd-index = <1>;
+		qcom,csid-sd-index = <0>;
 		qcom,mount-angle = <0>;
 		qcom,sensor-name = "mt9m114";
 		cam_vdig-supply = <&pm8941_l3>;
@@ -61,15 +178,16 @@
 		qcom,sensor-mode = <1>;
 		qcom,cci-master = <0>;
 	};
-
 	qcom,camera@0 {
 		cell-index = <0>;
 		compatible = "qcom,camera";
 		reg = <0x0>;
 		qcom,csiphy-sd-index = <0>;
 		qcom,csid-sd-index = <0>;
-		qcom,mount-angle = <90>;
 		qcom,actuator-src = <&actuator0>;
+		qcom,vdd-cx-supply = <&pm8841_s2>;
+		qcom,mount-angle = <90>;
+		qcom,vdd-cx-name = "qcom,vdd-cx";
 		cam_vdig-supply = <&pm8941_l3>;
 		cam_vana-supply = <&pm8941_l17>;
 		cam_vio-supply = <&pm8941_lvs3>;
@@ -88,9 +206,9 @@
 		qcom,gpio-standby = <2>;
 		qcom,gpio-req-tbl-num = <0 1 2>;
 		qcom,gpio-req-tbl-flags = <1 0 0>;
-		qcom,gpio-req-tbl-label = "CAMIF_MCLK0",
-					  "CAM_RESET0",
-					  "CAM_STANDBY0";
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1",
+					  "CAM_STANDBY";
 		qcom,sensor-position = <0>;
 		qcom,sensor-mode = <0>;
 		qcom,cci-master = <0>;
@@ -103,7 +221,9 @@
 		reg = <0x1>;
 		qcom,csiphy-sd-index = <1>;
 		qcom,csid-sd-index = <0>;
+		qcom,vdd-cx-supply = <&pm8841_s2>;
 		qcom,mount-angle = <90>;
+		qcom,vdd-cx-name = "qcom,vdd-cx";
 		cam_vdig-supply = <&pm8941_l3>;
 		cam_vana-supply = <&pm8941_l17>;
 		cam_vio-supply = <&pm8941_lvs3>;
@@ -121,10 +241,10 @@
 		qcom,gpio-standby = <2>;
 		qcom,gpio-req-tbl-num = <0 1 2>;
 		qcom,gpio-req-tbl-flags = <1 0 0>;
-		qcom,gpio-req-tbl-label = "CAMIF_MCLK1",
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
 					  "CAM_RESET1",
-					  "CAM_STANDBY1";
-		qcom,sensor-position = <0>;
+					  "CAM_STANDBY";
+		qcom,sensor-position = <1>;
 		qcom,sensor-mode = <0>;
 		qcom,cci-master = <0>;
 		status = "ok";
@@ -133,29 +253,28 @@
 	qcom,camera@2 {
 		cell-index = <2>;
 		compatible = "qcom,camera";
-		reg = <0x02>;
+		reg = <0x2>;
 		qcom,csiphy-sd-index = <2>;
 		qcom,csid-sd-index = <2>;
 		qcom,mount-angle = <90>;
+		qcom,vdd-cx-supply = <&pm8841_s2>;
+		qcom,vdd-cx-name = "qcom,vdd-cx";
 		cam_vdig-supply = <&pm8941_l3>;
 		cam_vana-supply = <&pm8941_l17>;
 		cam_vio-supply = <&pm8941_lvs3>;
-		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana";
-		qcom,cam-vreg-type = <0 1 0>;
-		qcom,cam-vreg-min-voltage = <1225000 0 2850000>;
-		qcom,cam-vreg-max-voltage = <1225000 0 2850000>;
-		qcom,cam-vreg-op-mode = <105000 0 80000>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vana", "cam_vio";
+		qcom,cam-vreg-type = <0 0 1>;
+		qcom,cam-vreg-min-voltage = <1225000 2850000 0>;
+		qcom,cam-vreg-max-voltage = <1225000 2850000 0>;
+		qcom,cam-vreg-op-mode = <105000 80000 0>;
 		qcom,gpio-no-mux = <0>;
 		gpios = <&msmgpio 17 0>,
-			<&msmgpio 18 0>,
-			<&msmgpio 28 0>;
+			<&msmgpio 18 0>;
 		qcom,gpio-reset = <1>;
-		qcom,gpio-standby = <2>;
-		qcom,gpio-req-tbl-num = <0 1 2>;
-		qcom,gpio-req-tbl-flags = <1 0 0>;
-		qcom,gpio-req-tbl-label = "CAMIF_MCLK2",
-					  "CAM_RESET2",
-					  "CAM_STANDBY2";
+		qcom,gpio-req-tbl-num = <0 1>;
+		qcom,gpio-req-tbl-flags = <1 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1";
 		qcom,sensor-position = <1>;
 		qcom,sensor-mode = <0>;
 		qcom,cci-master = <0>;
diff --git a/arch/arm/boot/dts/msm8974-camera-sensor-liquid.dtsi b/arch/arm/boot/dts/msm8974-camera-sensor-liquid.dtsi
index 44b7f13..69583753 100644
--- a/arch/arm/boot/dts/msm8974-camera-sensor-liquid.dtsi
+++ b/arch/arm/boot/dts/msm8974-camera-sensor-liquid.dtsi
@@ -28,6 +28,124 @@
 		qcom,cci-master = <0>;
 	};
 
+	qcom,camera@6e {
+		compatible = "qcom,s5k3l1yx";
+		reg = <0x6e>;
+		qcom,slave-id = <0x6e 0x0 0x3121>;
+		qcom,csiphy-sd-index = <0>;
+		qcom,csid-sd-index = <0>;
+		qcom,mount-angle = <0>;
+		qcom,actuator-src = <&actuator0>;
+		qcom,sensor-name = "s5k3l1yx";
+		cam_vdig-supply = <&pm8941_l3>;
+		cam_vana-supply = <&pm8941_l17>;
+		cam_vio-supply = <&pm8941_lvs2>;
+		cam_vaf-supply = <&pm8941_l23>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
+				     "cam_vaf";
+		qcom,cam-vreg-type = <0 1 0 0>;
+		qcom,cam-vreg-min-voltage = <1225000 0 2850000 3000000>;
+		qcom,cam-vreg-max-voltage = <1225000 0 2850000 3000000>;
+		qcom,cam-vreg-op-mode = <105000 0 80000 100000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 15 0>,
+			<&msmgpio 90 0>,
+			<&msmgpio 89 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1",
+					  "CAM_STANDBY";
+		qcom,gpio-set-tbl-num = <1 1>;
+		qcom,gpio-set-tbl-flags = <0 2>;
+		qcom,gpio-set-tbl-delay = <1000 30000>;
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x1F>;
+		qcom,sensor-position = <0>;
+		qcom,sensor-mode = <1>;
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+
+    qcom,camera@20 {
+		compatible = "qcom,imx135";
+		reg = <0x20>;
+		qcom,slave-id = <0x20 0x0016 0x0135>;
+		qcom,csiphy-sd-index = <0>;
+		qcom,csid-sd-index = <0>;
+		qcom,mount-angle = <0>;
+		qcom,sensor-name = "imx135";
+		qcom,actuator-src = <&actuator1>;
+		cam_vdig-supply = <&pm8941_l3>;
+		cam_vana-supply = <&pm8941_l17>;
+		cam_vio-supply = <&pm8941_lvs2>;
+		cam_vaf-supply = <&pm8941_l23>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
+				     "cam_vaf";
+		qcom,cam-vreg-type = <0 1 0 0>;
+		qcom,cam-vreg-min-voltage = <1225000 0 2850000 3000000>;
+		qcom,cam-vreg-max-voltage = <1225000 0 2850000 3000000>;
+		qcom,cam-vreg-op-mode = <105000 0 80000 100000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 15 0>,
+			<&msmgpio 90 0>,
+			<&msmgpio 89 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1",
+					  "CAM_STANDBY";
+		qcom,gpio-set-tbl-num = <1 1>;
+		qcom,gpio-set-tbl-flags = <0 2>;
+		qcom,gpio-set-tbl-delay = <1000 30000>;
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x1F>;
+		qcom,sensor-position = <0>;
+		qcom,sensor-mode = <0>;
+	        qcom,sensor-type = <0>;
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+
+	qcom,camera@6c {
+		compatible = "qcom,ov2720";
+		reg = <0x6c>;
+		qcom,slave-id = <0x6c 0x300A 0x2720>;
+		qcom,csiphy-sd-index = <2>;
+		qcom,csid-sd-index = <0>;
+		qcom,mount-angle = <180>;
+		qcom,sensor-name = "ov2720";
+		cam_vdig-supply = <&pm8941_l3>;
+		cam_vana-supply = <&pm8941_l17>;
+		cam_vio-supply = <&pm8941_lvs2>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vana", "cam_vio";
+		qcom,cam-vreg-type = <0 0 1>;
+		qcom,cam-vreg-min-voltage = <1225000 2850000 0>;
+		qcom,cam-vreg-max-voltage = <1225000 2850000 0>;
+		qcom,cam-vreg-op-mode = <105000 80000 0>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 17 0>,
+			<&msmgpio 18 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-req-tbl-num = <0 1>;
+		qcom,gpio-req-tbl-flags = <1 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1";
+		qcom,gpio-set-tbl-num = <1 1>;
+		qcom,gpio-set-tbl-flags = <0 2>;
+		qcom,gpio-set-tbl-delay = <1000 4000>;
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x7>;
+		qcom,sensor-position = <1>;
+		qcom,sensor-mode = <1>;
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+
 	qcom,camera@90 {
 		compatible = "qcom,mt9m114";
 		reg = <0x90>;
@@ -61,7 +179,6 @@
 		qcom,sensor-mode = <1>;
 		qcom,cci-master = <0>;
 	};
-
 	qcom,camera@0 {
 		cell-index = <0>;
 		compatible = "qcom,camera";
@@ -70,6 +187,8 @@
 		qcom,csid-sd-index = <0>;
 		qcom,mount-angle = <0>;
 		qcom,actuator-src = <&actuator0>;
+		qcom,vdd-cx-supply = <&pm8841_s2>;
+		qcom,vdd-cx-name = "qcom,vdd-cx";
 		cam_vdig-supply = <&pm8941_l3>;
 		cam_vana-supply = <&pm8941_l17>;
 		cam_vio-supply = <&pm8941_lvs2>;
@@ -80,7 +199,6 @@
 		qcom,cam-vreg-min-voltage = <1225000 0 2850000 3000000>;
 		qcom,cam-vreg-max-voltage = <1225000 0 2850000 3000000>;
 		qcom,cam-vreg-op-mode = <105000 0 80000 100000>;
-		qcom,gpio-no-mux = <0>;
 		gpios = <&msmgpio 15 0>,
 			<&msmgpio 90 0>,
 			<&msmgpio 89 0>;
@@ -88,9 +206,9 @@
 		qcom,gpio-standby = <2>;
 		qcom,gpio-req-tbl-num = <0 1 2>;
 		qcom,gpio-req-tbl-flags = <1 0 0>;
-		qcom,gpio-req-tbl-label = "CAMIF_MCLK0",
-					  "CAM_RESET0",
-					  "CAM_STANDBY0";
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1",
+					  "CAM_STANDBY";
 		qcom,sensor-position = <0>;
 		qcom,sensor-mode = <0>;
 		qcom,cci-master = <0>;
@@ -102,8 +220,10 @@
 		compatible = "qcom,camera";
 		reg = <0x1>;
 		qcom,csiphy-sd-index = <1>;
-		qcom,csid-sd-index = <0>;
-		qcom,mount-angle = <90>;
+		qcom,csid-sd-index = <1>;
+		qcom,mount-angle = <180>;
+		qcom,vdd-cx-supply = <&pm8841_s2>;
+		qcom,vdd-cx-name = "qcom,vdd-cx";
 		cam_vdig-supply = <&pm8941_l3>;
 		cam_vana-supply = <&pm8941_l17>;
 		cam_vio-supply = <&pm8941_lvs2>;
@@ -112,17 +232,15 @@
 		qcom,cam-vreg-min-voltage = <1225000 2850000 0>;
 		qcom,cam-vreg-max-voltage = <1225000 2850000 0>;
 		qcom,cam-vreg-op-mode = <105000 80000 0>;
-		gpios = <&msmgpio 16 0>,
-			<&msmgpio 92 0>,
-			<&msmgpio 91 0>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 17 0>,
+			<&msmgpio 18 0>;
 		qcom,gpio-reset = <1>;
-		qcom,gpio-standby = <2>;
-		qcom,gpio-req-tbl-num = <0 1 2>;
-		qcom,gpio-req-tbl-flags = <1 0 0>;
-		qcom,gpio-req-tbl-label = "CAMIF_MCLK1",
-					  "CAM_RESET1",
-					  "CAM_STANDBY1";
-		qcom,sensor-position = <0>;
+		qcom,gpio-req-tbl-num = <0 1>;
+		qcom,gpio-req-tbl-flags = <1 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1";
+		qcom,sensor-position = <1>;
 		qcom,sensor-mode = <0>;
 		qcom,cci-master = <0>;
 		status = "ok";
@@ -131,26 +249,28 @@
 	qcom,camera@2 {
 		cell-index = <2>;
 		compatible = "qcom,camera";
-		reg = <0x02>;
+		reg = <0x2>;
 		qcom,csiphy-sd-index = <2>;
 		qcom,csid-sd-index = <2>;
 		qcom,mount-angle = <180>;
+		qcom,vdd-cx-supply = <&pm8841_s2>;
+		qcom,vdd-cx-name = "qcom,vdd-cx";
 		cam_vdig-supply = <&pm8941_l3>;
 		cam_vana-supply = <&pm8941_l17>;
-		cam_vio-supply = <&pm8941_lvs2>;
-		qcom,cam-vreg-name = "cam_vdig", "cam_vana", "cam_vio";
-		qcom,cam-vreg-type = <0 0 1>;
-		qcom,cam-vreg-min-voltage = <1225000 2850000 0>;
-		qcom,cam-vreg-max-voltage = <1225000 2850000 0>;
-		qcom,cam-vreg-op-mode = <105000 80000 0>;
-		qcom,gpio-no-mux = <0>;
+		cam_vio-supply = <&pm8941_lvs3>;
+		cam_vaf-supply = <&pm8941_l23>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
+				     "cam_vaf";
+		qcom,cam-vreg-type = <0 1 0 0>;
+		qcom,cam-vreg-min-voltage = <1225000 0 2850000 3000000>;
+		qcom,cam-vreg-max-voltage = <1225000 0 2850000 3000000>;
+		qcom,cam-vreg-op-mode = <105000 0 80000 100000>;
 		gpios = <&msmgpio 17 0>,
 			<&msmgpio 18 0>;
 		qcom,gpio-reset = <1>;
-		qcom,gpio-req-tbl-num = <0 1 >;
-		qcom,gpio-req-tbl-flags = <1 0>;
-		qcom,gpio-req-tbl-label = "CAMIF_MCLK1",
-					  "CAM_RESET1";
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1",
+					  "CAM_STANDBY";
 		qcom,sensor-position = <1>;
 		qcom,sensor-mode = <1>;
 		qcom,cci-master = <0>;
diff --git a/arch/arm/boot/dts/msm8974-camera-sensor-mtp.dtsi b/arch/arm/boot/dts/msm8974-camera-sensor-mtp.dtsi
index c3c0d47..f3dff1a 100644
--- a/arch/arm/boot/dts/msm8974-camera-sensor-mtp.dtsi
+++ b/arch/arm/boot/dts/msm8974-camera-sensor-mtp.dtsi
@@ -37,6 +37,127 @@
 		qcom,cci-master = <0>;
 	};
 
+	qcom,camera@6e {
+		compatible = "qcom,s5k3l1yx";
+		reg = <0x6e>;
+		qcom,slave-id = <0x6e 0x0 0x3121>;
+		qcom,csiphy-sd-index = <0>;
+		qcom,csid-sd-index = <0>;
+		qcom,actuator-src = <&actuator0>;
+		qcom,led-flash-src = <&led_flash0>;
+		qcom,mount-angle = <90>;
+		qcom,sensor-name = "s5k3l1yx";
+		cam_vdig-supply = <&pm8941_l3>;
+		cam_vana-supply = <&pm8941_l17>;
+		cam_vio-supply = <&pm8941_lvs3>;
+		cam_vaf-supply = <&pm8941_l23>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
+				     "cam_vaf";
+		qcom,cam-vreg-type = <0 1 0 0>;
+		qcom,cam-vreg-min-voltage = <1225000 0 2850000 3000000>;
+		qcom,cam-vreg-max-voltage = <1225000 0 2850000 3000000>;
+		qcom,cam-vreg-op-mode = <105000 0 80000 100000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 15 0>,
+			<&msmgpio 90 0>,
+			<&msmgpio 89 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1",
+					  "CAM_STANDBY";
+		qcom,gpio-set-tbl-num = <1 1>;
+		qcom,gpio-set-tbl-flags = <0 2>;
+		qcom,gpio-set-tbl-delay = <1000 30000>;
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x1F>;
+		qcom,sensor-position = <0>;
+		qcom,sensor-mode = <1>;
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+
+    qcom,camera@20 {
+		compatible = "qcom,imx135";
+		reg = <0x20>;
+		qcom,slave-id = <0x20 0x0016 0x0135>;
+		qcom,csiphy-sd-index = <0>;
+		qcom,csid-sd-index = <0>;
+		qcom,mount-angle = <90>;
+		qcom,sensor-name = "imx135";
+		qcom,actuator-src = <&actuator1>;
+		qcom,led-flash-src = <&led_flash0>;
+		cam_vdig-supply = <&pm8941_l3>;
+		cam_vana-supply = <&pm8941_l17>;
+		cam_vio-supply = <&pm8941_lvs3>;
+		cam_vaf-supply = <&pm8941_l23>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
+				     "cam_vaf";
+		qcom,cam-vreg-type = <0 1 0 0>;
+		qcom,cam-vreg-min-voltage = <1225000 0 2850000 3000000>;
+		qcom,cam-vreg-max-voltage = <1225000 0 2850000 3000000>;
+		qcom,cam-vreg-op-mode = <105000 0 80000 100000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 15 0>,
+			<&msmgpio 90 0>,
+			<&msmgpio 89 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1",
+					  "CAM_STANDBY";
+		qcom,gpio-set-tbl-num = <1 1>;
+		qcom,gpio-set-tbl-flags = <0 2>;
+		qcom,gpio-set-tbl-delay = <1000 30000>;
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x1F>;
+		qcom,sensor-position = <0>;
+		qcom,sensor-mode = <0>;
+	        qcom,sensor-type = <0>;
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+
+
+	qcom,camera@6c {
+		compatible = "qcom,ov2720";
+		reg = <0x6c>;
+		qcom,slave-id = <0x6c 0x300A 0x2720>;
+		qcom,csiphy-sd-index = <2>;
+		qcom,csid-sd-index = <2>;
+		qcom,mount-angle = <90>;
+		qcom,sensor-name = "ov2720";
+		cam_vdig-supply = <&pm8941_l3>;
+		cam_vana-supply = <&pm8941_l17>;
+		cam_vio-supply = <&pm8941_lvs3>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vana", "cam_vio";
+		qcom,cam-vreg-type = <0 0 1>;
+		qcom,cam-vreg-min-voltage = <1225000 2850000 0>;
+		qcom,cam-vreg-max-voltage = <1225000 2850000 0>;
+		qcom,cam-vreg-op-mode = <105000 80000 0>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 17 0>,
+			<&msmgpio 18 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-req-tbl-num = <0 1>;
+		qcom,gpio-req-tbl-flags = <1 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1";
+		qcom,gpio-set-tbl-num = <1 1>;
+		qcom,gpio-set-tbl-flags = <0 2>;
+		qcom,gpio-set-tbl-delay = <1000 4000>;
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x7>;
+		qcom,sensor-position = <1>;
+		qcom,sensor-mode = <1>;
+		qcom,cci-master = <1>;
+		status = "ok";
+	};
+
 	qcom,camera@90 {
 		compatible = "qcom,mt9m114";
 		reg = <0x90>;
@@ -70,7 +191,6 @@
 		qcom,sensor-mode = <1>;
 		qcom,cci-master = <0>;
 	};
-
 	qcom,camera@0 {
 		cell-index = <0>;
 		compatible = "qcom,camera";
@@ -80,6 +200,8 @@
 		qcom,mount-angle = <90>;
 		qcom,actuator-src = <&actuator0>;
 		qcom,led-flash-src = <&led_flash0>;
+		qcom,vdd-cx-supply = <&pm8841_s2>;
+		qcom,vdd-cx-name = "qcom,vdd-cx";
 		cam_vdig-supply = <&pm8941_l3>;
 		cam_vana-supply = <&pm8941_l17>;
 		cam_vio-supply = <&pm8941_lvs3>;
@@ -90,7 +212,6 @@
 		qcom,cam-vreg-min-voltage = <1225000 0 2850000 3000000>;
 		qcom,cam-vreg-max-voltage = <1225000 0 2850000 3000000>;
 		qcom,cam-vreg-op-mode = <105000 0 80000 100000>;
-		qcom,gpio-no-mux = <0>;
 		gpios = <&msmgpio 15 0>,
 			<&msmgpio 90 0>,
 			<&msmgpio 89 0>;
@@ -98,9 +219,9 @@
 		qcom,gpio-standby = <2>;
 		qcom,gpio-req-tbl-num = <0 1 2>;
 		qcom,gpio-req-tbl-flags = <1 0 0>;
-		qcom,gpio-req-tbl-label = "CAMIF_MCLK0",
-					  "CAM_RESET0",
-					  "CAM_STANDBY0";
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1",
+					  "CAM_STANDBY";
 		qcom,sensor-position = <0>;
 		qcom,sensor-mode = <0>;
 		qcom,cci-master = <0>;
@@ -112,8 +233,10 @@
 		compatible = "qcom,camera";
 		reg = <0x1>;
 		qcom,csiphy-sd-index = <1>;
-		qcom,csid-sd-index = <0>;
+		qcom,csid-sd-index = <1>;
 		qcom,mount-angle = <90>;
+		qcom,vdd-cx-supply = <&pm8841_s2>;
+		qcom,vdd-cx-name = "qcom,vdd-cx";
 		cam_vdig-supply = <&pm8941_l3>;
 		cam_vana-supply = <&pm8941_l17>;
 		cam_vio-supply = <&pm8941_lvs3>;
@@ -123,17 +246,14 @@
 		qcom,cam-vreg-min-voltage = <1225000 0 2850000 3000000>;
 		qcom,cam-vreg-max-voltage = <1225000 0 2850000 3000000>;
 		qcom,cam-vreg-op-mode = <105000 0 80000 100000>;
-		gpios = <&msmgpio 16 0>,
-			<&msmgpio 92 0>,
-			<&msmgpio 91 0>;
+		gpios = <&msmgpio 17 0>,
+			<&msmgpio 18 0>;
 		qcom,gpio-reset = <1>;
-		qcom,gpio-standby = <2>;
-		qcom,gpio-req-tbl-num = <0 1 2>;
-		qcom,gpio-req-tbl-flags = <1 0 0>;
-		qcom,gpio-req-tbl-label = "CAMIF_MCLK1",
-					  "CAM_RESET1",
-					  "CAM_STANDBY1";
-		qcom,sensor-position = <0>;
+		qcom,gpio-req-tbl-num = <0 1>;
+		qcom,gpio-req-tbl-flags = <1 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1";
+		qcom,sensor-position = <1>;
 		qcom,sensor-mode = <0>;
 		qcom,cci-master = <0>;
 		status = "ok";
@@ -156,18 +276,16 @@
 		qcom,cam-vreg-op-mode = <105000 80000 0>;
 		qcom,gpio-no-mux = <0>;
 		gpios = <&msmgpio 17 0>,
-			<&msmgpio 18 0>,
-			<&msmgpio 28 0>;
+			<&msmgpio 18 0>;
 		qcom,gpio-reset = <1>;
-		qcom,gpio-standby = <2>;
-		qcom,gpio-req-tbl-num = <0 1 2>;
-		qcom,gpio-req-tbl-flags = <1 0 0>;
-		qcom,gpio-req-tbl-label = "CAMIF_MCLK2",
-					  "CAM_RESET2",
-					  "CAM_STANDBY2";
+		qcom,gpio-req-tbl-num = <0 1>;
+		qcom,gpio-req-tbl-flags = <1 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1";
 		qcom,sensor-position = <1>;
 		qcom,sensor-mode = <0>;
 		qcom,cci-master = <1>;
 		status = "ok";
 	};
+
 };
diff --git a/arch/arm/boot/dts/msm8974-v2.dtsi b/arch/arm/boot/dts/msm8974-v2.dtsi
index 91844c3..754afb5 100644
--- a/arch/arm/boot/dts/msm8974-v2.dtsi
+++ b/arch/arm/boot/dts/msm8974-v2.dtsi
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -199,17 +199,17 @@
 
 &cci {
 
-	qcom,camera@0 {
+	qcom,camera@6e {
 		qcom,vdd-cx-supply = <&pm8841_s2>;
 		qcom,vdd-cx-name = "qcom,vdd-cx";
 	};
 
-	qcom,camera@1 {
+	qcom,camera@20 {
 		qcom,vdd-cx-supply = <&pm8841_s2>;
 		qcom,vdd-cx-name = "qcom,vdd-cx";
 	};
 
-	qcom,camera@2 {
+	qcom,camera@6c {
 		qcom,vdd-cx-supply = <&pm8841_s2>;
 		qcom,vdd-cx-name = "qcom,vdd-cx";
 	};
diff --git a/arch/arm/mach-msm/clock-8226.c b/arch/arm/mach-msm/clock-8226.c
index e16bcb1..7a7c008 100644
--- a/arch/arm/mach-msm/clock-8226.c
+++ b/arch/arm/mach-msm/clock-8226.c
@@ -3497,36 +3497,8 @@ static struct clk_lookup msm_clocks_8226[] = {
 					"fda08400.qcom,csid"),
 
 	/* ISPIF clocks */
-
 	CLK_LOOKUP("ispif_ahb_clk", camss_ispif_ahb_clk.c,
-					"fda0a000.qcom,ispif"),
-	CLK_LOOKUP("camss_top_ahb_clk", camss_top_ahb_clk.c,
-					"fda0a000.qcom,ispif"),
-	CLK_LOOKUP("csi0_ahb_clk", camss_csi0_ahb_clk.c,
-					"fda0a000.qcom,ispif"),
-	CLK_LOOKUP("csi0_src_clk", csi0_clk_src.c,
-					"fda0a000.qcom,ispif"),
-	CLK_LOOKUP("csi0_phy_clk", camss_csi0phy_clk.c,
-					"fda0a000.qcom,ispif"),
-	CLK_LOOKUP("csi0_clk", camss_csi0_clk.c,
-					"fda0a000.qcom,ispif"),
-	CLK_LOOKUP("csi0_pix_clk", camss_csi0pix_clk.c,
-					"fda0a000.qcom,ispif"),
-	CLK_LOOKUP("csi0_rdi_clk", camss_csi0rdi_clk.c,
-					"fda0a000.qcom,ispif"),
-
-	CLK_LOOKUP("csi1_ahb_clk", camss_csi1_ahb_clk.c,
-					"fda0a000.qcom,ispif"),
-	CLK_LOOKUP("csi1_src_clk", csi1_clk_src.c,
-					"fda0a000.qcom,ispif"),
-	CLK_LOOKUP("csi1_phy_clk", camss_csi1phy_clk.c,
-					"fda0a000.qcom,ispif"),
-	CLK_LOOKUP("csi1_clk", camss_csi1_clk.c,
-					"fda0a000.qcom,ispif"),
-	CLK_LOOKUP("csi1_pix_clk", camss_csi1pix_clk.c,
-					"fda0a000.qcom,ispif"),
-	CLK_LOOKUP("csi1_rdi_clk", camss_csi1rdi_clk.c,
-					"fda0a000.qcom,ispif"),
+		"fda0a000.qcom,ispif"),
 	CLK_LOOKUP("camss_vfe_vfe_clk", camss_vfe_vfe0_clk.c,
 		"fda0a000.qcom,ispif"),
 	CLK_LOOKUP("camss_csi_vfe_clk", camss_csi_vfe0_clk.c,
diff --git a/arch/arm/mach-msm/clock-8974.c b/arch/arm/mach-msm/clock-8974.c
old mode 100644
new mode 100755
index 1847bf4..e3dcced
--- a/arch/arm/mach-msm/clock-8974.c
+++ b/arch/arm/mach-msm/clock-8974.c
@@ -4871,7 +4871,13 @@ static struct clk_lookup msm_clocks_8974pro_only[] __initdata = {
 	CLK_LOOKUP("gpll4", gpll4_clk_src.c, ""),
 	CLK_LOOKUP("sleep_clk", gcc_sdcc1_cdccal_sleep_clk.c, "msm_sdcc.1"),
 	CLK_LOOKUP("cal_clk", gcc_sdcc1_cdccal_ff_clk.c, "msm_sdcc.1"),
+	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "6e.qcom,camera"),
+	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "20.qcom,camera"),
+	CLK_LOOKUP("cam_src_clk", mclk2_clk_src.c, "6c.qcom,camera"),
 	CLK_LOOKUP("cam_src_clk", mclk1_clk_src.c, "90.qcom,camera"),
+	CLK_LOOKUP("cam_clk", camss_mclk0_clk.c, "6e.qcom,camera"),
+	CLK_LOOKUP("cam_clk", camss_mclk0_clk.c, "20.qcom,camera"),
+	CLK_LOOKUP("cam_clk", camss_mclk2_clk.c, "6c.qcom,camera"),
 	CLK_LOOKUP("cam_clk", camss_mclk1_clk.c, "90.qcom,camera"),
 	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "0.qcom,camera"),
 	CLK_LOOKUP("cam_src_clk", mclk1_clk_src.c, "1.qcom,camera"),
@@ -4882,14 +4888,20 @@ static struct clk_lookup msm_clocks_8974pro_only[] __initdata = {
 };
 
 static struct clk_lookup msm_clocks_8974_only[] __initdata = {
+	CLK_LOOKUP("cam_src_clk", mmss_gp0_clk_src.c, "6e.qcom,camera"),
+	CLK_LOOKUP("cam_src_clk", mmss_gp0_clk_src.c, "20.qcom,camera"),
+	CLK_LOOKUP("cam_src_clk", gp1_clk_src.c, "6c.qcom,camera"),
 	CLK_LOOKUP("cam_src_clk", mmss_gp1_clk_src.c, "90.qcom,camera"),
+	CLK_LOOKUP("cam_clk", camss_gp0_clk.c, "6e.qcom,camera"),
+	CLK_LOOKUP("cam_clk", camss_gp0_clk.c, "20.qcom,camera"),
+	CLK_LOOKUP("cam_clk", gcc_gp1_clk.c, "6c.qcom,camera"),
 	CLK_LOOKUP("cam_clk", camss_gp1_clk.c, "90.qcom,camera"),
 	CLK_LOOKUP("cam_src_clk", mmss_gp0_clk_src.c, "0.qcom,camera"),
-	CLK_LOOKUP("cam_src_clk", mmss_gp1_clk_src.c, "1.qcom,camera"),
 	CLK_LOOKUP("cam_src_clk", gp1_clk_src.c, "2.qcom,camera"),
+	CLK_LOOKUP("cam_src_clk", mmss_gp1_clk_src.c, "1.qcom,camera"),
 	CLK_LOOKUP("cam_clk", camss_gp0_clk.c, "0.qcom,camera"),
-	CLK_LOOKUP("cam_clk", camss_gp1_clk.c, "1.qcom,camera"),
 	CLK_LOOKUP("cam_clk", gcc_gp1_clk.c, "2.qcom,camera"),
+	CLK_LOOKUP("cam_clk", camss_gp1_clk.c, "1.qcom,camera"),
 };
 
 static struct clk_lookup msm_clocks_8974_common[] __initdata = {
diff --git a/drivers/media/platform/msm/camera_v2/Kconfig b/drivers/media/platform/msm/camera_v2/Kconfig
index 2e8cbbe..64b6b33 100755
--- a/drivers/media/platform/msm/camera_v2/Kconfig
+++ b/drivers/media/platform/msm/camera_v2/Kconfig
@@ -101,6 +101,14 @@ config MSM_ISPIF_V1
           of any CID of MSM_CSI22_HEADER can be routed to of pixel
           or raw data interface in VFE.
 
+config S5K3L1YX
+	bool "Sensor S5K3L1YX (BAYER 12M)"
+	depends on MSMB_CAMERA
+	---help---
+		Samsung 12 MP Bayer Sensor with auto focus, uses
+		4 mipi lanes, preview config = 1984 * 1508 at 30 fps,
+		snapshot config = 4000 * 3000 at 20 fps,
+		hfr video at 60, 90 and 120 fps.
 config IMX135_Z5S
 	bool "Sensor IMX135_Z5S (BAYER 12M)"
 	depends on MSMB_CAMERA
@@ -117,6 +125,58 @@ config IMX135_Z5S_069
 		4 mipi lanes, preview config = 2104 x 1560 at 49 fps,
 		snapshot config = 4208 x 3120 at 24 fps,
 		Video HDR support.
+config IMX135
+	bool "Sensor IMX135 (BAYER 12M)"
+	depends on MSMB_CAMERA
+	---help---
+		Sony 12 MP Bayer Sensor with auto focus, uses
+		4 mipi lanes, preview config = 2104 x 1560 at 49 fps,
+		snapshot config = 4208 x 3120 at 24 fps,
+		Video HDR support.
+config IMX214
+	bool "Sensor IMX214 (BAYER 12M)"
+	depends on MSMB_CAMERA
+	---help---
+		Sony 12 MP Bayer Sensor with auto focus, uses
+		4 mipi lanes, preview config = 2104 x 1560 at 49 fps,
+		snapshot config = 4208 x 3120 at 24 fps,
+		Video HDR support.
+
+config IMX214_LC898122
+	bool "Sensor IMX214 (BAYER 12M)"
+	depends on MSMB_CAMERA
+	---help---
+		Sony 12 MP Bayer Sensor with auto focus, ois ,uses
+		4 mipi lanes, preview config = 2104 x 1560 at 49 fps,
+		snapshot config = 4208 x 3120 at 24 fps,
+		Video HDR support.
+		
+config IMX214_OIS_SHARP
+	bool "Sensor IMX214 (BAYER 13M)"
+	depends on MSMB_CAMERA
+	---help---
+		Sony 13 MP Bayer Sensor with auto focus, ois ,uses
+		4 mipi lanes, preview config = 2104 x 1560 at 49 fps,
+		snapshot config = 4208 x 3120 at 24 fps,
+		Video HDR support.
+	
+config IMX214_APP
+	bool "Sensor IMX214 (BAYER 13M)"
+	depends on MSMB_CAMERA
+	---help---
+		Sony 13 MP Bayer Sensor with auto focus, ois ,uses
+		4 mipi lanes, preview config = 2104 x 1560 at 49 fps,
+		snapshot config = 4208 x 3120 at 24 fps,
+		Video HDR support.
+
+config IMX220
+	bool "Sensor IMX220 (BAYER 20M)"
+	depends on MSMB_CAMERA
+	---help---
+		Sony 20 MP Bayer Sensor with auto focus, ois ,uses
+		4 mipi lanes, preview config = 2624 x 1968 at 24 fps,
+		snapshot config = 5248 x 3936 at 12 fps,
+		Video HDR support.
 
 config IMX134
 	bool "Sensor IMX134 (BAYER 8M)"
@@ -126,6 +186,53 @@ config IMX134
 		4 mipi lanes full resolution @30fps and
 		HFR @60fps and @120fps
 		Video HDR support.
+config IMX135_GBAO
+	bool "Sensor IMX135_GBAO (BAYER 12M)"
+	depends on MSMB_CAMERA
+	---help---
+		Sony 12 MP Bayer Sensor with auto focus, uses
+		4 mipi lanes, preview config = 2104 x 1560 at 49 fps,
+		snapshot config = 4208 x 3120 at 24 fps,
+		Video HDR support.
+config IMX135_GBAO_LC898122
+	bool "Sensor IMX135_GBAO_LC898122 (BAYER 12M)"
+	depends on MSMB_CAMERA
+	---help---
+		Sony 12 MP Bayer Sensor with auto focus, uses
+		4 mipi lanes, preview config = 2104 x 1560 at 49 fps,
+		snapshot config = 4208 x 3120 at 24 fps,
+		Video HDR support.
+config IMX135_FRONT
+	bool "Sensor IMX135_FRONT (BAYER 12M)"
+	depends on MSMB_CAMERA
+	---help---
+		Sony 12 MP Bayer Sensor with auto focus, uses
+		4 mipi lanes, preview config = 2104 x 1560 at 49 fps,
+		snapshot config = 4208 x 3120 at 24 fps,
+		Video HDR support.
+
+config IMX135_069
+	bool "Sensor IMX135_069 (BAYER 13M)"
+	depends on MSMB_CAMERA
+	---help---
+		Sony 12 MP Bayer Sensor with auto focus, uses
+		4 mipi lanes, preview config = 2104 x 1560 at 49 fps,
+		snapshot config = 4208 x 3120 at 24 fps,
+		Video HDR support.
+config OV5648_Z7MINI
+	bool "Sensor OV5648_Z7MINI (BAYER 5M)"
+	depends on MSMB_CAMERA
+	---help---
+		OmniVision 5 MP Bayer Sensor, only use 2 mipi lane,
+		This sensor driver does not support auto focus.
+config OV2720
+	bool "Sensor OV2720 (BAYER 2M)"
+	depends on MSMB_CAMERA
+	---help---
+		OmniVision 2 MP Bayer Sensor, supports 2 mipi lanes,
+		preview and snapshot config at 1932 * 1092 at 30 fps,
+		hfr video at 60, 90 and 120 fps. This sensor driver does
+		not support auto focus.
 
 config OV9724
 	bool "Sensor OV9724 (BAYER 2M)"
@@ -154,6 +261,15 @@ config OV5648
 		snapshot set to 2592*1944 at 12 fps,
 		This sensor driver does not support auto focus.
 
+config T4K35
+	bool "Sensor T4K35 (BAYER 8M)"
+	depends on MSMB_CAMERA
+	---help---
+		Toshiba 8 MP Bayer Sensor, only use 2 mipi lane,
+		snapshot set to 3280*2464 at 30 fps,
+		This sensor driver does not support auto focus.
+
+
 config OV5648_Z5S
 	bool "Sensor OV5648_Z5S (BAYER 5M)"
 	depends on MSMB_CAMERA
@@ -248,3 +364,17 @@ config MSM_GEMINI
 	depends on MSMB_CAMERA && (ARCH_MSM7X30 || ARCH_MSM8X60 || ARCH_MSM8960)
 	---help---
 	  Enables support for the Gemini JPEG encoder engine for 8x60.
+config ZTE_CAMERA_Z7
+	tristate "z7 camera support"
+config ZTE_CAMERA_Z7MINI
+	tristate "z7mini camera support"
+config ZTE_CAMERA_NX507J
+	tristate "nx507j camera support"
+config ZTE_CAMERA_NX505J
+	tristate "nx505j camera support"
+config ZTE_CAMERA_FLASH_THERMAL
+	tristate "z7 camera flash thermal"
+config ZTE_CAMERA_NX506J
+	tristate "nx506j camera support"
+config ZTE_CAMERA_NX504J
+	tristate "nx504j camera support"
diff --git a/drivers/media/platform/msm/camera_v2/camera/camera.c b/drivers/media/platform/msm/camera_v2/camera/camera.c
index 170efa8..2d32ed3 100644
--- a/drivers/media/platform/msm/camera_v2/camera/camera.c
+++ b/drivers/media/platform/msm/camera_v2/camera/camera.c
@@ -670,22 +670,12 @@ static int camera_v4l2_close(struct file *filep)
 	return rc;
 }
 
-#ifdef CONFIG_COMPAT
-long camera_v4l2_compat_ioctl(struct file *file, unsigned int cmd,
-	unsigned long arg)
-{
-	return -ENOIOCTLCMD;
-}
-#endif
 static struct v4l2_file_operations camera_v4l2_fops = {
 	.owner   = THIS_MODULE,
 	.open	= camera_v4l2_open,
 	.poll	= camera_v4l2_poll,
 	.release = camera_v4l2_close,
 	.ioctl   = video_ioctl2,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl32 = camera_v4l2_compat_ioctl,
-#endif
 };
 
 int camera_init_v4l2(struct device *dev, unsigned int *session)
diff --git a/drivers/media/platform/msm/camera_v2/isp/msm_buf_mgr.c b/drivers/media/platform/msm/camera_v2/isp/msm_buf_mgr.c
index 084590a..f9855c0 100644
--- a/drivers/media/platform/msm/camera_v2/isp/msm_buf_mgr.c
+++ b/drivers/media/platform/msm/camera_v2/isp/msm_buf_mgr.c
@@ -48,11 +48,8 @@ static struct msm_isp_bufq *msm_isp_get_bufq(
 {
 	struct msm_isp_bufq *bufq = NULL;
 	uint32_t bufq_index = bufq_handle & 0xFF;
-
-	/* bufq_handle cannot be 0 */
-	if ((bufq_handle == 0) ||
-		(bufq_index > buf_mgr->num_buf_q))
-		return NULL;
+	if (bufq_index > buf_mgr->num_buf_q)
+		return bufq;
 
 	bufq = &buf_mgr->bufq[bufq_index];
 	if (bufq->bufq_handle == bufq_handle)
@@ -678,7 +675,7 @@ static int msm_isp_request_bufq(struct msm_isp_buf_mgr *buf_mgr,
 	struct msm_isp_bufq *bufq = NULL;
 	CDBG("%s: E\n", __func__);
 
-	if (!buf_request->num_buf || buf_request->num_buf > VIDEO_MAX_FRAME) {
+	if (!buf_request->num_buf) {
 		pr_err("Invalid buffer request\n");
 		return rc;
 	}
diff --git a/drivers/media/platform/msm/camera_v2/isp/msm_isp.c b/drivers/media/platform/msm/camera_v2/isp/msm_isp.c
index d35869c..80a0073 100644
--- a/drivers/media/platform/msm/camera_v2/isp/msm_isp.c
+++ b/drivers/media/platform/msm/camera_v2/isp/msm_isp.c
@@ -52,82 +52,8 @@ static const struct platform_device_id msm_vfe_dev_id[] = {
 	{}
 };
 
-#define MAX_OVERFLOW_COUNTERS  15
-#define OVERFLOW_LENGTH 512
-#define OVERFLOW_BUFFER_LENGTH 32
 static struct msm_isp_buf_mgr vfe_buf_mgr;
-static int msm_isp_enable_debugfs(struct msm_isp_statistics *stats);
-static char *stats_str[MAX_OVERFLOW_COUNTERS] = {
-	"imgmaster0_overflow_cnt",
-	"imgmaster1_overflow_cnt",
-	"imgmaster2_overflow_cnt",
-	"imgmaster3_overflow_cnt",
-	"imgmaster4_overflow_cnt",
-	"imgmaster5_overflow_cnt",
-	"imgmaster6_overflow_cnt",
-	"be_overflow_cnt",
-	"bg_overflow_cnt",
-	"bf_overflow_cnt",
-	"awb_overflow_cnt",
-	"rs_overflow_cnt",
-	"cs_overflow_cnt",
-	"ihist_overflow_cnt",
-	"skinbhist_overflow_cnt",
-};
-static int vfe_debugfs_statistics_open(struct inode *inode, struct file *file)
-{
-	file->private_data = inode->i_private;
-	return 0;
-}
-
-static ssize_t vfe_debugfs_statistics_read(struct file *t_file, char *t_char,
-	size_t t_size_t, loff_t *t_loff_t)
-{
-	int i;
-	char name[OVERFLOW_LENGTH] = {0};
-	int *ptr;
-	char buffer[OVERFLOW_BUFFER_LENGTH] = {0};
-	struct msm_isp_statistics  *stats = (struct msm_isp_statistics *)
-		t_file->private_data;
-	ptr = (int *)(stats);
-	for (i = 0; i < MAX_OVERFLOW_COUNTERS; i++) {
-		strlcat(name, stats_str[i], sizeof(name));
-		strlcat(name, "     ", sizeof(name));
-		snprintf(buffer, sizeof(buffer), "%d", ptr[i]);
-		strlcat(name, buffer, sizeof(name));
-		strlcat(name, "\r\n", sizeof(name));
-	}
-	return simple_read_from_buffer(t_char, t_size_t,
-		t_loff_t, name, strlen(name));
-}
-
-static ssize_t vfe_debugfs_statistics_write(struct file *t_file,
-	const char *t_char, size_t t_size_t, loff_t *t_loff_t)
-{
-	struct msm_isp_statistics *stats = (struct msm_isp_statistics *)
-		t_file->private_data;
-	memset(stats, 0, sizeof(struct msm_isp_statistics));
 
-	return sizeof(struct msm_isp_statistics);
-}
-
-static const struct file_operations vfe_debugfs_error = {
-	.open = vfe_debugfs_statistics_open,
-	.read = vfe_debugfs_statistics_read,
-	.write = vfe_debugfs_statistics_write,
-};
-
-static int msm_isp_enable_debugfs(struct msm_isp_statistics *stats)
-{
-	struct dentry *debugfs_base;
-	debugfs_base = debugfs_create_dir("msm_isp", NULL);
-	if (!debugfs_base)
-		return -ENOMEM;
-	if (!debugfs_create_file("stats", S_IRUGO | S_IWUSR, debugfs_base,
-		stats, &vfe_debugfs_error))
-		return -ENOMEM;
-	return 0;
-}
 static int __devinit vfe_probe(struct platform_device *pdev)
 {
 	struct vfe_device *vfe_dev;
@@ -147,7 +73,6 @@ static int __devinit vfe_probe(struct platform_device *pdev)
 	};
 
 	vfe_dev = kzalloc(sizeof(struct vfe_device), GFP_KERNEL);
-	vfe_dev->stats = kzalloc(sizeof(struct msm_isp_statistics), GFP_KERNEL);
 	if (!vfe_dev) {
 		pr_err("%s: no enough memory\n", __func__);
 		return -ENOMEM;
@@ -219,7 +144,6 @@ static int __devinit vfe_probe(struct platform_device *pdev)
 		kfree(vfe_dev);
 		return -EINVAL;
 	}
-	msm_isp_enable_debugfs(vfe_dev->stats);
 	vfe_dev->buf_mgr->ops->register_ctx(vfe_dev->buf_mgr,
 		&vfe_dev->iommu_ctx[0], vfe_dev->hw_info->num_iommu_ctx);
 	vfe_dev->vfe_open_cnt = 0;
diff --git a/drivers/media/platform/msm/camera_v2/isp/msm_isp.h b/drivers/media/platform/msm/camera_v2/isp/msm_isp.h
index 02e767d7..d33d34b 100644
--- a/drivers/media/platform/msm/camera_v2/isp/msm_isp.h
+++ b/drivers/media/platform/msm/camera_v2/isp/msm_isp.h
@@ -19,11 +19,12 @@
 #include <linux/io.h>
 #include <linux/list.h>
 #include <linux/delay.h>
-#include <linux/avtimer_kernel.h>
+#include <linux/avtimer.h>
 #include <media/v4l2-subdev.h>
 #include <media/msmb_isp.h>
 #include <mach/msm_bus.h>
 #include <mach/msm_bus_board.h>
+
 #include "msm_buf_mgr.h"
 
 #define MAX_IOMMU_CTX 2
@@ -35,6 +36,10 @@
 #define MAX_INIT_FRAME_DROP 31
 #define ISP_Q2 (1 << 2)
 
+#define AVTIMER_MSW_PHY_ADDR 0xFE05300C
+#define AVTIMER_LSW_PHY_ADDR 0xFE053008
+#define AVTIMER_ITERATION_CTR 16
+
 #define VFE_PING_FLAG 0xFFFFFFFF
 #define VFE_PONG_FLAG 0x0
 
@@ -143,13 +148,13 @@ struct msm_vfe_axi_ops {
 	uint32_t (*get_wm_mask) (uint32_t irq_status0, uint32_t irq_status1);
 	uint32_t (*get_comp_mask) (uint32_t irq_status0, uint32_t irq_status1);
 	uint32_t (*get_pingpong_status) (struct vfe_device *vfe_dev);
-	long (*halt) (struct vfe_device *vfe_dev, uint32_t blocking);
+	long (*halt) (struct vfe_device *vfe_dev);
 };
 
 struct msm_vfe_core_ops {
 	void (*reg_update) (struct vfe_device *vfe_dev);
 	long (*reset_hw) (struct vfe_device *vfe_dev,
-		enum msm_isp_reset_type reset_type, uint32_t blocking);
+		enum msm_isp_reset_type reset_type);
 	int (*init_hw) (struct vfe_device *vfe_dev);
 	void (*init_hw_reg) (struct vfe_device *vfe_dev);
 	void (*release_hw) (struct vfe_device *vfe_dev);
@@ -163,12 +168,6 @@ struct msm_vfe_core_ops {
 	int (*get_platform_data) (struct vfe_device *vfe_dev);
 	void (*get_error_mask) (uint32_t *error_mask0, uint32_t *error_mask1);
 	void (*process_error_status) (struct vfe_device *vfe_dev);
-	void (*get_overflow_mask) (uint32_t *overflow_mask);
-	void (*get_irq_mask) (struct vfe_device *vfe_dev,
-		uint32_t *irq0_mask, uint32_t *irq1_mask);
-	void (*restore_irq_mask) (struct vfe_device *vfe_dev);
-	void (*get_halt_restart_mask) (uint32_t *irq0_mask,
-		uint32_t *irq1_mask);
 };
 struct msm_vfe_stats_ops {
 	int (*get_stats_idx) (enum msm_isp_stats_type stats_type);
@@ -278,6 +277,7 @@ struct msm_vfe_axi_stream {
 	uint32_t stream_handle;
 	uint8_t buf_divert;
 	enum msm_vfe_axi_stream_type stream_type;
+	uint32_t vt_enable;
 	uint32_t frame_based;
 	uint32_t framedrop_period;
 	uint32_t framedrop_pattern;
@@ -299,15 +299,6 @@ struct msm_vfe_axi_stream {
 	uint32_t runtime_num_burst_capture;
 	uint8_t runtime_framedrop_update;
 	uint32_t runtime_output_format;
-	enum msm_vfe_frame_skip_pattern frame_skip_pattern;
-
-};
-
-enum msm_vfe_overflow_state {
-	NO_OVERFLOW,
-	OVERFLOW_DETECTED,
-	HALT_REQUESTED,
-	RESTART_REQUESTED,
 };
 
 struct msm_vfe_axi_composite_info {
@@ -324,7 +315,6 @@ struct msm_vfe_src_info {
 	uint32_t width;
 	long pixel_clock;
 	uint32_t input_format;/*V4L2 pix format with bayer pattern*/
-	uint32_t last_updt_frm_id;
 };
 
 enum msm_wm_ub_cfg_type {
@@ -350,7 +340,6 @@ struct msm_vfe_axi_shared_data {
 	struct msm_vfe_src_info src_info[VFE_SRC_MAX];
 	uint16_t stream_handle_cnt;
 	unsigned long event_mask;
-	uint32_t burst_len;
 };
 
 struct msm_vfe_stats_hardware_info {
@@ -392,8 +381,6 @@ struct msm_vfe_stats_shared_data {
 	atomic_t stats_comp_mask;
 	uint16_t stream_handle_cnt;
 	atomic_t stats_update;
-	uint32_t stats_mask;
-	uint32_t stats_burst_len;
 };
 
 struct msm_vfe_tasklet_queue_cmd {
@@ -407,9 +394,6 @@ struct msm_vfe_tasklet_queue_cmd {
 #define MSM_VFE_TASKLETQ_SIZE 200
 
 struct msm_vfe_error_info {
-	atomic_t overflow_state;
-	uint32_t overflow_recover_irq_mask0;
-	uint32_t overflow_recover_irq_mask1;
 	uint32_t error_mask0;
 	uint32_t error_mask1;
 	uint32_t violation_status;
@@ -425,24 +409,6 @@ struct msm_vfe_frame_ts {
 	uint32_t frame_id;
 };
 
-struct msm_isp_statistics {
-	int32_t imagemaster0_overflow;
-	int32_t imagemaster1_overflow;
-	int32_t imagemaster2_overflow;
-	int32_t imagemaster3_overflow;
-	int32_t imagemaster4_overflow;
-	int32_t imagemaster5_overflow;
-	int32_t imagemaster6_overflow;
-	int32_t be_overflow;
-	int32_t bg_overflow;
-	int32_t bf_overflow;
-	int32_t awb_overflow;
-	int32_t rs_overflow;
-	int32_t cs_overflow;
-	int32_t ihist_overflow;
-	int32_t skinbhist_overflow;
-};
-
 struct vfe_device {
 	struct platform_device *pdev;
 	struct msm_sd_subdev subdev;
@@ -477,7 +443,8 @@ struct vfe_device {
 	struct list_head tasklet_q;
 	struct tasklet_struct vfe_tasklet;
 	struct msm_vfe_tasklet_queue_cmd
-	tasklet_queue_cmd[MSM_VFE_TASKLETQ_SIZE];
+		tasklet_queue_cmd[MSM_VFE_TASKLETQ_SIZE];
+
 	uint32_t soc_hw_version;
 	uint32_t vfe_hw_version;
 	struct msm_vfe_hardware_info *hw_info;
@@ -490,9 +457,8 @@ struct vfe_device {
 	int vfe_clk_idx;
 	uint32_t vfe_open_cnt;
 	uint8_t vt_enable;
-	uint8_t ignore_error;
-	struct msm_isp_statistics *stats;
-	uint32_t vfe_ub_size;
+	void __iomem *p_avtimer_msw;
+	void __iomem *p_avtimer_lsw;
 };
 
 #endif
diff --git a/drivers/media/platform/msm/camera_v2/isp/msm_isp32.c b/drivers/media/platform/msm/camera_v2/isp/msm_isp32.c
index 263d54d..00a443b 100644
--- a/drivers/media/platform/msm/camera_v2/isp/msm_isp32.c
+++ b/drivers/media/platform/msm/camera_v2/isp/msm_isp32.c
@@ -22,7 +22,7 @@
 #include "msm.h"
 #include "msm_camera_io_util.h"
 
-#define VFE32_BURST_LEN 2
+#define VFE32_BURST_LEN 3
 #define VFE32_UB_SIZE 1024
 #define VFE32_EQUAL_SLICE_UB 194
 #define VFE32_AXI_SLICE_UB 792
@@ -146,6 +146,7 @@ static void msm_vfe32_release_hardware(struct vfe_device *vfe_dev)
 
 static void msm_vfe32_init_hardware_reg(struct vfe_device *vfe_dev)
 {
+	uint32_t wm_base, i = 0;
 	/* CGC_OVERRIDE */
 	msm_camera_io_w(0x07FFFFFF, vfe_dev->vfe_base + 0xC);
 	/* BUS_CFG */
@@ -159,6 +160,12 @@ static void msm_vfe32_init_hardware_reg(struct vfe_device *vfe_dev)
 	msm_camera_io_w( 0x10000000,vfe_dev->vfe_base + VFE32_RDI_BASE(2));
 	msm_camera_io_w(0x0, vfe_dev->vfe_base + VFE32_XBAR_BASE(0));
 	msm_camera_io_w(0x0, vfe_dev->vfe_base + VFE32_XBAR_BASE(4));
+	for (i = 0; i<=6; i++) {
+		wm_base = VFE32_WM_BASE(i);
+		msm_camera_io_w(0x0, vfe_dev->vfe_base + wm_base);
+		wm_base = VFE32_WM_BASE(i);
+		msm_camera_io_w(0x0, vfe_dev->vfe_base + wm_base);
+	}
 
 }
 
@@ -178,15 +185,15 @@ static void msm_vfe32_process_camif_irq(struct vfe_device *vfe_dev,
 	uint32_t irq_status0, uint32_t irq_status1,
 	struct msm_isp_timestamp *ts)
 {
-	uint32_t cnt;
 	if (!(irq_status0 & 0x1F))
 		return;
 
 	if (irq_status0 & BIT(0)) {
 		ISP_DBG("%s: SOF IRQ\n", __func__);
-		cnt = vfe_dev->axi_data.src_info[VFE_PIX_0].raw_stream_count;
-		if (cnt > 0) {
-			msm_isp_sof_notify(vfe_dev, VFE_RAW_0, ts);
+		if (vfe_dev->axi_data.src_info[VFE_PIX_0].raw_stream_count > 0
+			&& vfe_dev->axi_data.src_info[VFE_PIX_0].
+			pix_stream_count == 0) {
+			msm_isp_sof_notify(vfe_dev, VFE_PIX_0, ts);
 			if (vfe_dev->axi_data.stream_update)
 				msm_isp_axi_stream_update(vfe_dev);
 			msm_isp_update_framedrop_reg(vfe_dev);
@@ -255,6 +262,7 @@ static void msm_vfe32_process_violation_status(struct vfe_device *vfe_dev)
 static void msm_vfe32_process_error_status(struct vfe_device *vfe_dev)
 {
 	uint32_t error_status1 = vfe_dev->error_info.error_mask1;
+
 	if (error_status1 & BIT(0))
 		pr_err("%s: camif error status: 0x%x\n",
 			__func__, vfe_dev->error_info.camif_status);
@@ -274,62 +282,34 @@ static void msm_vfe32_process_error_status(struct vfe_device *vfe_dev)
 		pr_err("%s: violation\n", __func__);
 		msm_vfe32_process_violation_status(vfe_dev);
 	}
-	if (error_status1 & BIT(8)) {
-		vfe_dev->stats->imagemaster0_overflow++;
+	if (error_status1 & BIT(8))
 		pr_err("%s: image master 0 bus overflow\n", __func__);
-	}
-	if (error_status1 & BIT(9)) {
-		vfe_dev->stats->imagemaster1_overflow++;
+	if (error_status1 & BIT(9))
 		pr_err("%s: image master 1 bus overflow\n", __func__);
-	}
-	if (error_status1 & BIT(10)) {
-		vfe_dev->stats->imagemaster2_overflow++;
+	if (error_status1 & BIT(10))
 		pr_err("%s: image master 2 bus overflow\n", __func__);
-	}
-	if (error_status1 & BIT(11)) {
-		vfe_dev->stats->imagemaster3_overflow++;
+	if (error_status1 & BIT(11))
 		pr_err("%s: image master 3 bus overflow\n", __func__);
-	}
-	if (error_status1 & BIT(12)) {
-		vfe_dev->stats->imagemaster4_overflow++;
+	if (error_status1 & BIT(12))
 		pr_err("%s: image master 4 bus overflow\n", __func__);
-	}
-	if (error_status1 & BIT(13)) {
-		vfe_dev->stats->imagemaster5_overflow++;
+	if (error_status1 & BIT(13))
 		pr_err("%s: image master 5 bus overflow\n", __func__);
-	}
-	if (error_status1 & BIT(14)) {
-		vfe_dev->stats->imagemaster6_overflow++;
+	if (error_status1 & BIT(14))
 		pr_err("%s: image master 6 bus overflow\n", __func__);
-	}
-	if (error_status1 & BIT(15)) {
-		vfe_dev->stats->bg_overflow++;
+	if (error_status1 & BIT(15))
 		pr_err("%s: status ae/bg bus overflow\n", __func__);
-	}
-	if (error_status1 & BIT(16)) {
-		vfe_dev->stats->bf_overflow++;
+	if (error_status1 & BIT(16))
 		pr_err("%s: status af/bf bus overflow\n", __func__);
-	}
-	if (error_status1 & BIT(17)) {
-		vfe_dev->stats->awb_overflow++;
+	if (error_status1 & BIT(17))
 		pr_err("%s: status awb bus overflow\n", __func__);
-	}
-	if (error_status1 & BIT(18)) {
-		vfe_dev->stats->rs_overflow++;
+	if (error_status1 & BIT(18))
 		pr_err("%s: status rs bus overflow\n", __func__);
-	}
-	if (error_status1 & BIT(19)) {
-		vfe_dev->stats->cs_overflow++;
+	if (error_status1 & BIT(19))
 		pr_err("%s: status cs bus overflow\n", __func__);
-	}
-	if (error_status1 & BIT(20)) {
-		vfe_dev->stats->ihist_overflow++;
+	if (error_status1 & BIT(20))
 		pr_err("%s: status ihist bus overflow\n", __func__);
-	}
-	if (error_status1 & BIT(21)) {
-		vfe_dev->stats->skinbhist_overflow++;
+	if (error_status1 & BIT(21))
 		pr_err("%s: status skin bhist bus overflow\n", __func__);
-	}
 	if (error_status1 & BIT(22))
 		pr_err("%s: axi error\n", __func__);
 }
@@ -356,23 +336,41 @@ static void msm_vfe32_process_reg_update(struct vfe_device *vfe_dev,
 	uint32_t irq_status0, uint32_t irq_status1,
 	struct msm_isp_timestamp *ts)
 {
+	int flag_rdi = 0;
+	int flag_pix = 0;
+
 	if (!(irq_status0 & 0x20) && !(irq_status1 & 0x1C000000))
 		return;
 
-	if (irq_status0 & BIT(5))
+	if (irq_status0 & BIT(5)) {
+		flag_pix = 1;
 		msm_isp_sof_notify(vfe_dev, VFE_PIX_0, ts);
-	if (irq_status1 & BIT(26))
+	}
+	if (irq_status1 & BIT(26)) {
+		flag_rdi = (1 << VFE_RAW_0) | flag_rdi;
 		msm_isp_sof_notify(vfe_dev, VFE_RAW_0, ts);
-	if (irq_status1 & BIT(27))
+	}
+	if (irq_status1 & BIT(27)) {
+		flag_rdi = (1 << VFE_RAW_1) | flag_rdi;
 		msm_isp_sof_notify(vfe_dev, VFE_RAW_1, ts);
-	if (irq_status1 & BIT(28))
+	}
+	if (irq_status1 & BIT(28)) {
+		flag_rdi = (1 << VFE_RAW_2) | flag_rdi;
 		msm_isp_sof_notify(vfe_dev, VFE_RAW_2, ts);
+	}
 
 	if (vfe_dev->axi_data.stream_update)
 		msm_isp_axi_stream_update(vfe_dev);
+
 	if (atomic_read(&vfe_dev->stats_data.stats_update))
 		msm_isp_stats_stream_update(vfe_dev);
-	msm_isp_update_framedrop_reg(vfe_dev);
+
+	if (flag_rdi)
+		msm_isp_update_framedrop_rdi_reg(vfe_dev, flag_rdi);
+
+	if (flag_pix)
+		msm_isp_update_framedrop_reg(vfe_dev);
+
 	msm_isp_update_error_frame_count(vfe_dev);
 
 	vfe_dev->hw_info->vfe_ops.core_ops.
@@ -393,25 +391,19 @@ static uint32_t msm_vfe32_reset_values[ISP_RST_MAX] =
 };
 
 static long msm_vfe32_reset_hardware(struct vfe_device *vfe_dev ,
-	enum msm_isp_reset_type reset_type, uint32_t blocking)
+				enum msm_isp_reset_type reset_type)
 {
 
 	uint32_t rst_val;
-	long rc = 0;
 	if (reset_type >= ISP_RST_MAX) {
 		pr_err("%s: Error Invalid parameter\n", __func__);
 		reset_type = ISP_RST_HARD;
 	}
 	rst_val = msm_vfe32_reset_values[reset_type];
-	if (blocking) {
-		init_completion(&vfe_dev->reset_complete);
-		msm_camera_io_w_mb(rst_val, vfe_dev->vfe_base + 0x4);
-		rc = wait_for_completion_timeout(
-		   &vfe_dev->reset_complete, msecs_to_jiffies(50));
-	} else {
-		msm_camera_io_w_mb(0x3EF, vfe_dev->vfe_base + 0x4);
-	}
-	return rc;
+	init_completion(&vfe_dev->reset_complete);
+	msm_camera_io_w_mb(rst_val, vfe_dev->vfe_base + 0x4);
+	return wait_for_completion_timeout(
+	   &vfe_dev->reset_complete, msecs_to_jiffies(50));
 }
 
 static void msm_vfe32_axi_reload_wm(
@@ -499,6 +491,8 @@ static void msm_vfe32_cfg_framedrop(struct vfe_device *vfe_dev,
 	struct msm_vfe_axi_stream *stream_info)
 {
 	uint32_t framedrop_pattern = 0, framedrop_period = 0;
+	uint32_t rdi_reg_cfg;
+	int32_t val = 0;
 
 	if (stream_info->runtime_init_frame_drop == 0) {
 		framedrop_pattern = stream_info->framedrop_pattern;
@@ -521,6 +515,32 @@ static void msm_vfe32_cfg_framedrop(struct vfe_device *vfe_dev,
 		msm_camera_io_w(framedrop_period, vfe_dev->vfe_base + 0x518);
 		msm_camera_io_w(framedrop_pattern, vfe_dev->vfe_base + 0x51C);
 		msm_camera_io_w(framedrop_pattern, vfe_dev->vfe_base + 0x520);
+	} else if (stream_info->stream_src == RDI_INTF_0 ||
+			stream_info->stream_src == RDI_INTF_1 ||
+			stream_info->stream_src == RDI_INTF_2) {
+		if (stream_info->runtime_init_frame_drop) {
+			rdi_reg_cfg = msm_camera_io_r(
+			vfe_dev->vfe_base +
+			VFE32_RDI_BASE(stream_info->stream_src - VFE_SRC_MAX));
+			val = ((stream_info->runtime_init_frame_drop + 1) << 20)
+							| 0x1000000;
+			rdi_reg_cfg |= val;
+			msm_camera_io_w(rdi_reg_cfg, vfe_dev->vfe_base +
+			VFE32_RDI_BASE(stream_info->stream_src - VFE_SRC_MAX));
+		} else if (0 == stream_info->runtime_init_frame_drop) {
+			rdi_reg_cfg = msm_camera_io_r(
+			vfe_dev->vfe_base +
+			VFE32_RDI_BASE(stream_info->stream_src - VFE_SRC_MAX));
+			if (stream_info->framedrop_period == 0 ||
+				stream_info->framedrop_period == 1)
+				rdi_reg_cfg = 0xFE0FFFFF & rdi_reg_cfg;
+			else
+				rdi_reg_cfg = 0xFF0FFFFF & rdi_reg_cfg;
+			val = stream_info->framedrop_period << 20;
+			rdi_reg_cfg = rdi_reg_cfg | val;
+			msm_camera_io_w(rdi_reg_cfg, vfe_dev->vfe_base +
+			VFE32_RDI_BASE(stream_info->stream_src - VFE_SRC_MAX));
+		}
 	}
 	msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x260);
 }
@@ -665,7 +685,6 @@ static void msm_vfe32_update_camif_state(
 		val &= 0xFFFFFF3F;
 		val = val | bus_en << 7 | vfe_en << 6;
 		msm_camera_io_w(val, vfe_dev->vfe_base + 0x1E4);
-		msm_camera_io_w_mb(0x4, vfe_dev->vfe_base + 0x1E0);
 		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x1E0);
 		vfe_dev->axi_data.src_info[VFE_PIX_0].active = 1;
 	} else if (update_state == DISABLE_CAMIF) {
@@ -898,15 +917,12 @@ static void msm_vfe32_update_ping_pong_addr(struct vfe_device *vfe_dev,
 		VFE32_PING_PONG_BASE(wm_idx, pingpong_status));
 }
 
-static long msm_vfe32_axi_halt(struct vfe_device *vfe_dev,
-	uint32_t blocking)
+static long msm_vfe32_axi_halt(struct vfe_device *vfe_dev)
 {
 	uint32_t halt_mask;
-	uint32_t axi_busy_flag = false;
+	uint32_t axi_busy_flag = true;
+
 	msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x1D8);
-	if (blocking) {
-		axi_busy_flag = true;
-	}
 	while (axi_busy_flag) {
 		if (msm_camera_io_r(
 			vfe_dev->vfe_base + 0x1DC) & 0x1)
@@ -1077,33 +1093,6 @@ static uint32_t msm_vfe32_stats_get_wm_mask(uint32_t irq_status0,
 	return (irq_status0 >> 13) & 0x7F;
 }
 
-static void msm_vfe32_get_overflow_mask(uint32_t *overflow_mask)
-{
-	*overflow_mask = 0x002FFF7E;
-}
-
-static void msm_vfe32_get_irq_mask(struct vfe_device *vfe_dev,
-	uint32_t *irq0_mask, uint32_t *irq1_mask)
-{
-	*irq0_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x1C);
-	*irq1_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x20);
-}
-
-static void msm_vfe32_restore_irq_mask(struct vfe_device *vfe_dev)
-{
-	msm_camera_io_w(vfe_dev->error_info.overflow_recover_irq_mask0,
-		vfe_dev->vfe_base + 0x1C);
-	msm_camera_io_w(vfe_dev->error_info.overflow_recover_irq_mask1,
-		vfe_dev->vfe_base + 0x20);
-}
-
-static void msm_vfe32_get_halt_restart_mask(uint32_t *irq0_mask,
-	uint32_t *irq1_mask)
-{
-	*irq0_mask = 0x0;
-	*irq1_mask = 0x01800000;
-}
-
 static uint32_t msm_vfe32_stats_get_comp_mask(uint32_t irq_status0,
 	uint32_t irq_status1)
 {
@@ -1177,7 +1166,7 @@ static void msm_vfe32_get_error_mask(uint32_t *error_mask0,
 }
 
 struct msm_vfe_axi_hardware_info msm_vfe32_axi_hw_info = {
-	.num_wm = 5,
+	.num_wm = 6,
 	.num_comp_mask = 3,
 	.num_rdi = 3,
 	.num_rdi_master = 3,
@@ -1257,11 +1246,6 @@ struct msm_vfe_hardware_info vfe32_hw_info = {
 			.release_hw = msm_vfe32_release_hardware,
 			.get_platform_data = msm_vfe32_get_platform_data,
 			.get_error_mask = msm_vfe32_get_error_mask,
-			.get_overflow_mask = msm_vfe32_get_overflow_mask,
-			.get_irq_mask = msm_vfe32_get_irq_mask,
-			.restore_irq_mask = msm_vfe32_restore_irq_mask,
-			.get_halt_restart_mask =
-				msm_vfe32_get_halt_restart_mask,
 			.process_error_status = msm_vfe32_process_error_status,
 		},
 		.stats_ops = {
diff --git a/drivers/media/platform/msm/camera_v2/isp/msm_isp40.c b/drivers/media/platform/msm/camera_v2/isp/msm_isp40.c
index 76d2118..63b81c5 100644
--- a/drivers/media/platform/msm/camera_v2/isp/msm_isp40.c
+++ b/drivers/media/platform/msm/camera_v2/isp/msm_isp40.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -36,10 +36,10 @@
 #define VFE40_8x26_VERSION 0x20000013
 #define VFE40_8x26V2_VERSION 0x20010014
 
-
-/* STATS_SIZE (BE + BG + BF+ RS + CS + IHIST + BHIST ) = 392 */
-#define VFE40_STATS_SIZE 392
-
+#define VFE40_BURST_LEN 1
+#define VFE40_STATS_BURST_LEN 1
+#define VFE40_UB_SIZE 1536
+#define VFE40_EQUAL_SLICE_UB 228
 #define VFE40_WM_BASE(idx) (0x6C + 0x24 * idx)
 #define VFE40_RDI_BASE(idx) (0x2E8 + 0x4 * idx)
 #define VFE40_XBAR_BASE(idx) (0x58 + 0x4 * (idx / 2))
@@ -350,12 +350,6 @@ static void msm_vfe40_init_hardware_reg(struct vfe_device *vfe_dev)
 	msm_camera_io_w_mb(0xFEFFFFFF, vfe_dev->vfe_base + 0x2C);
 	msm_camera_io_w(0xFFFFFFFF, vfe_dev->vfe_base + 0x30);
 	msm_camera_io_w_mb(0xFEFFFFFF, vfe_dev->vfe_base + 0x34);
-	msm_camera_io_w(vfe_dev->stats_data.stats_mask,
-		vfe_dev->vfe_base + 0x44);
-	msm_camera_io_w(1, vfe_dev->vfe_base + 0x24);
-	msm_camera_io_w(0, vfe_dev->vfe_base + 0x30);
-	msm_camera_io_w_mb(0, vfe_dev->vfe_base + 0x34);
-	msm_camera_io_w(1, vfe_dev->vfe_base + 0x24);
 }
 
 static void msm_vfe40_process_reset_irq(struct vfe_device *vfe_dev,
@@ -368,22 +362,23 @@ static void msm_vfe40_process_reset_irq(struct vfe_device *vfe_dev,
 static void msm_vfe40_process_halt_irq(struct vfe_device *vfe_dev,
 	uint32_t irq_status0, uint32_t irq_status1)
 {
+	if (irq_status1 & (1 << 8))
+		complete(&vfe_dev->halt_complete);
 }
 
 static void msm_vfe40_process_camif_irq(struct vfe_device *vfe_dev,
 	uint32_t irq_status0, uint32_t irq_status1,
 	struct msm_isp_timestamp *ts)
 {
-	int cnt;
-
 	if (!(irq_status0 & 0xF))
 		return;
 
 	if (irq_status0 & (1 << 0)) {
 		ISP_DBG("%s: SOF IRQ\n", __func__);
-		cnt = vfe_dev->axi_data.src_info[VFE_PIX_0].raw_stream_count;
-		if (cnt > 0) {
-			msm_isp_sof_notify(vfe_dev, VFE_RAW_0, ts);
+		if (vfe_dev->axi_data.src_info[VFE_PIX_0].raw_stream_count > 0
+			&& vfe_dev->axi_data.src_info[VFE_PIX_0].
+			pix_stream_count == 0) {
+			msm_isp_sof_notify(vfe_dev, VFE_PIX_0, ts);
 			if (vfe_dev->axi_data.stream_update)
 				msm_isp_axi_stream_update(vfe_dev);
 			msm_isp_update_framedrop_reg(vfe_dev);
@@ -484,74 +479,44 @@ static void msm_vfe40_process_error_status(struct vfe_device *vfe_dev)
 		pr_err_ratelimited("%s: violation\n", __func__);
 		msm_vfe40_process_violation_status(vfe_dev);
 	}
-	if (error_status1 & (1 << 9)) {
-		vfe_dev->stats->imagemaster0_overflow++;
+	if (error_status1 & (1 << 9))
 		pr_err_ratelimited("%s: image master 0 bus overflow\n",
 			__func__);
-	}
-	if (error_status1 & (1 << 10)) {
-		vfe_dev->stats->imagemaster1_overflow++;
+	if (error_status1 & (1 << 10))
 		pr_err_ratelimited("%s: image master 1 bus overflow\n",
 			__func__);
-	}
-	if (error_status1 & (1 << 11)) {
-		vfe_dev->stats->imagemaster2_overflow++;
+	if (error_status1 & (1 << 11))
 		pr_err_ratelimited("%s: image master 2 bus overflow\n",
 			__func__);
-	}
-	if (error_status1 & (1 << 12)) {
-		vfe_dev->stats->imagemaster3_overflow++;
+	if (error_status1 & (1 << 12))
 		pr_err_ratelimited("%s: image master 3 bus overflow\n",
 			__func__);
-	}
-	if (error_status1 & (1 << 13)) {
-		vfe_dev->stats->imagemaster4_overflow++;
+	if (error_status1 & (1 << 13))
 		pr_err_ratelimited("%s: image master 4 bus overflow\n",
 			__func__);
-	}
-	if (error_status1 & (1 << 14)) {
-		vfe_dev->stats->imagemaster5_overflow++;
+	if (error_status1 & (1 << 14))
 		pr_err_ratelimited("%s: image master 5 bus overflow\n",
 			__func__);
-	}
-	if (error_status1 & (1 << 15)) {
-		vfe_dev->stats->imagemaster6_overflow++;
+	if (error_status1 & (1 << 15))
 		pr_err_ratelimited("%s: image master 6 bus overflow\n",
 			__func__);
-	}
-	if (error_status1 & (1 << 16)) {
-		vfe_dev->stats->be_overflow++;
+	if (error_status1 & (1 << 16))
 		pr_err_ratelimited("%s: status be bus overflow\n", __func__);
-	}
-	if (error_status1 & (1 << 17)) {
-		vfe_dev->stats->bg_overflow++;
+	if (error_status1 & (1 << 17))
 		pr_err_ratelimited("%s: status bg bus overflow\n", __func__);
-	}
-	if (error_status1 & (1 << 18)) {
-		vfe_dev->stats->bf_overflow++;
+	if (error_status1 & (1 << 18))
 		pr_err_ratelimited("%s: status bf bus overflow\n", __func__);
-	}
-	if (error_status1 & (1 << 19)) {
-		vfe_dev->stats->awb_overflow++;
+	if (error_status1 & (1 << 19))
 		pr_err_ratelimited("%s: status awb bus overflow\n", __func__);
-	}
-	if (error_status1 & (1 << 20)) {
-		vfe_dev->stats->imagemaster0_overflow++;
+	if (error_status1 & (1 << 20))
 		pr_err_ratelimited("%s: status rs bus overflow\n", __func__);
-	}
-	if (error_status1 & (1 << 21)) {
-		vfe_dev->stats->cs_overflow++;
+	if (error_status1 & (1 << 21))
 		pr_err_ratelimited("%s: status cs bus overflow\n", __func__);
-	}
-	if (error_status1 & (1 << 22)) {
-		vfe_dev->stats->ihist_overflow++;
+	if (error_status1 & (1 << 22))
 		pr_err_ratelimited("%s: status ihist bus overflow\n", __func__);
-	}
-	if (error_status1 & (1 << 23)) {
-		vfe_dev->stats->skinbhist_overflow++;
+	if (error_status1 & (1 << 23))
 		pr_err_ratelimited("%s: status skin bhist bus overflow\n",
 			__func__);
-	}
 }
 
 static void msm_vfe40_read_irq_status(struct vfe_device *vfe_dev,
@@ -624,24 +589,18 @@ static uint32_t msm_vfe40_reset_values[ISP_RST_MAX] =
 
 
 static long msm_vfe40_reset_hardware(struct vfe_device *vfe_dev ,
-	enum msm_isp_reset_type reset_type, uint32_t blocking)
+				enum msm_isp_reset_type reset_type)
 {
 	uint32_t rst_val;
-	long rc = 0;
 	if (reset_type >= ISP_RST_MAX) {
 		pr_err("%s: Error Invalid parameter\n", __func__);
 		reset_type = ISP_RST_HARD;
 	}
 	rst_val = msm_vfe40_reset_values[reset_type];
 	init_completion(&vfe_dev->reset_complete);
-	if (blocking) {
-		msm_camera_io_w_mb(rst_val, vfe_dev->vfe_base + 0xC);
-		rc = wait_for_completion_timeout(
-			&vfe_dev->reset_complete, msecs_to_jiffies(50));
-	} else {
-		msm_camera_io_w_mb(0x1EF, vfe_dev->vfe_base + 0xC);
-	}
-	return rc;
+	msm_camera_io_w_mb(rst_val, vfe_dev->vfe_base + 0xC);
+	return wait_for_completion_timeout(
+		&vfe_dev->reset_complete, msecs_to_jiffies(50));
 }
 
 static void msm_vfe40_axi_reload_wm(
@@ -934,7 +893,6 @@ static void msm_vfe40_update_camif_state(struct vfe_device *vfe_dev,
 		val &= 0xFFFFFF3F;
 		val = val | bus_en << 7 | vfe_en << 6;
 		msm_camera_io_w(val, vfe_dev->vfe_base + 0x2F8);
-		msm_camera_io_w_mb(0x4, vfe_dev->vfe_base + 0x2F4);
 		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x2F4);
 		vfe_dev->axi_data.src_info[VFE_PIX_0].active = 1;
 	} else if (update_state == DISABLE_CAMIF) {
@@ -973,11 +931,6 @@ static void msm_vfe40_axi_cfg_wm_reg(
 	uint8_t plane_idx)
 {
 	uint32_t val;
-
-	struct msm_vfe_axi_shared_data *axi_data =
-		&vfe_dev->axi_data;
-	uint32_t burst_len = axi_data->burst_len;
-
 	uint32_t wm_base = VFE40_WM_BASE(stream_info->wm[plane_idx]);
 
 	if (!stream_info->frame_based) {
@@ -999,7 +952,7 @@ static void msm_vfe40_axi_cfg_wm_reg(
 				plane_idx].output_stride) << 16 |
 			(stream_info->plane_cfg[
 				plane_idx].output_height - 1) << 4 |
-			burst_len;
+			VFE40_BURST_LEN;
 		msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x18);
 	} else {
 		msm_camera_io_w(0x2, vfe_dev->vfe_base + wm_base);
@@ -1009,7 +962,7 @@ static void msm_vfe40_axi_cfg_wm_reg(
 				plane_idx].output_width) << 16 |
 			(stream_info->plane_cfg[
 				plane_idx].output_height - 1) << 4 |
-			burst_len;
+			VFE40_BURST_LEN;
 		msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x18);
 	}
 
@@ -1124,7 +1077,6 @@ static void msm_vfe40_cfg_axi_ub_equal_default(
 	uint8_t num_used_wms = 0;
 	uint32_t prop_size = 0;
 	uint32_t wm_ub_size;
-	uint32_t axi_wm_ub;
 
 	for (i = 0; i < axi_data->hw_info->num_wm; i++) {
 		if (axi_data->free_wm[i] > 0) {
@@ -1132,9 +1084,7 @@ static void msm_vfe40_cfg_axi_ub_equal_default(
 			total_image_size += axi_data->wm_image_size[i];
 		}
 	}
-	axi_wm_ub = vfe_dev->vfe_ub_size - VFE40_STATS_SIZE;
-
-	prop_size = axi_wm_ub -
+	prop_size = MSM_ISP40_TOTAL_WM_UB -
 		axi_data->hw_info->min_wm_ub * num_used_wms;
 	for (i = 0; i < axi_data->hw_info->num_wm; i++) {
 		if (axi_data->free_wm[i]) {
@@ -1159,14 +1109,10 @@ static void msm_vfe40_cfg_axi_ub_equal_slicing(
 	int i;
 	uint32_t ub_offset = 0;
 	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
-	uint32_t axi_equal_slice_ub =
-		(vfe_dev->vfe_ub_size - VFE40_STATS_SIZE)/
-			(axi_data->hw_info->num_wm - 1);
-
 	for (i = 0; i < axi_data->hw_info->num_wm; i++) {
-		msm_camera_io_w(ub_offset << 16 | (axi_equal_slice_ub - 1),
+		msm_camera_io_w(ub_offset << 16 | (VFE40_EQUAL_SLICE_UB - 1),
 			vfe_dev->vfe_base + VFE40_WM_BASE(i) + 0x10);
-		ub_offset += axi_equal_slice_ub;
+		ub_offset += VFE40_EQUAL_SLICE_UB;
 	}
 }
 
@@ -1188,31 +1134,16 @@ static void msm_vfe40_update_ping_pong_addr(
 		VFE40_PING_PONG_BASE(wm_idx, pingpong_status));
 }
 
-static long msm_vfe40_axi_halt(struct vfe_device *vfe_dev,
-	uint32_t blocking)
+static long msm_vfe40_axi_halt(struct vfe_device *vfe_dev)
 {
-	long rc = 0;
-	uint32_t axi_busy_flag = true;
-	/* Keep only restart mask and halt mask*/
-	msm_camera_io_w(BIT(31), vfe_dev->vfe_base + 0x28);
-	msm_camera_io_w(BIT(8),  vfe_dev->vfe_base + 0x2C);
-	/* Clear IRQ Status*/
-	msm_camera_io_w(0x7FFFFFFF, vfe_dev->vfe_base + 0x30);
-	msm_camera_io_w(0xFEFFFEFF, vfe_dev->vfe_base + 0x34);
-	msm_camera_io_w(0x1, vfe_dev->vfe_base + 0x24);
-	if (blocking) {
-		init_completion(&vfe_dev->halt_complete);
-		/* Halt AXI Bus Bridge */
-		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x2C0);
-		atomic_set(&vfe_dev->error_info.overflow_state, NO_OVERFLOW);
-		while (axi_busy_flag) {
-			if (msm_camera_io_r(
-				vfe_dev->vfe_base + 0x2E4) & 0x1)
-				axi_busy_flag = false;
-		}
-	}
-	msm_camera_io_w_mb(0x0, vfe_dev->vfe_base + 0x2C0);
-	return rc;
+	uint32_t halt_mask;
+	halt_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x2C);
+	halt_mask |= (1 << 8);
+	msm_camera_io_w_mb(halt_mask, vfe_dev->vfe_base + 0x2C);
+	init_completion(&vfe_dev->halt_complete);
+	msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x2C0);
+	return wait_for_completion_interruptible_timeout(
+		&vfe_dev->halt_complete, msecs_to_jiffies(500));
 }
 
 static uint32_t msm_vfe40_get_wm_mask(
@@ -1221,33 +1152,6 @@ static uint32_t msm_vfe40_get_wm_mask(
 	return (irq_status0 >> 8) & 0x7F;
 }
 
-static void msm_vfe40_get_overflow_mask(uint32_t *overflow_mask)
-{
-	*overflow_mask = 0x00FFFE7E;
-}
-
-static void msm_vfe40_get_irq_mask(struct vfe_device *vfe_dev,
-	uint32_t *irq0_mask, uint32_t *irq1_mask)
-{
-	*irq0_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x28);
-	*irq1_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x2C);
-}
-
-static void msm_vfe40_restore_irq_mask(struct vfe_device *vfe_dev)
-{
-	msm_camera_io_w(vfe_dev->error_info.overflow_recover_irq_mask0,
-		vfe_dev->vfe_base + 0x28);
-	msm_camera_io_w(vfe_dev->error_info.overflow_recover_irq_mask1,
-		vfe_dev->vfe_base + 0x2C);
-}
-
-static void msm_vfe40_get_halt_restart_mask(uint32_t *irq0_mask,
-	uint32_t *irq1_mask)
-{
-	*irq0_mask = BIT(31);
-	*irq1_mask = BIT(8);
-}
-
 static uint32_t msm_vfe40_get_comp_mask(
 	uint32_t irq_status0, uint32_t irq_status1)
 {
@@ -1295,7 +1199,6 @@ static void msm_vfe40_stats_cfg_comp_mask(struct vfe_device *vfe_dev,
 	else
 		comp_mask &= ~stats_mask;
 	msm_camera_io_w(comp_mask << 16, vfe_dev->vfe_base + 0x44);
-	vfe_dev->stats_data.stats_mask = (comp_mask << 16);
 }
 
 static void msm_vfe40_stats_cfg_wm_irq_mask(
@@ -1355,11 +1258,7 @@ static void msm_vfe40_stats_clear_wm_reg(
 static void msm_vfe40_stats_cfg_ub(struct vfe_device *vfe_dev)
 {
 	int i;
-	struct msm_vfe_stats_shared_data *stats_data = &vfe_dev->stats_data;
-	uint32_t ub_offset = vfe_dev->vfe_ub_size;
-	uint32_t stats_burst_len = stats_data->stats_burst_len;
-
-
+	uint32_t ub_offset = VFE40_UB_SIZE;
 	uint32_t ub_size[VFE40_NUM_STATS_TYPE] = {
 		64, /*MSM_ISP_STATS_BE*/
 		128, /*MSM_ISP_STATS_BG*/
@@ -1373,7 +1272,7 @@ static void msm_vfe40_stats_cfg_ub(struct vfe_device *vfe_dev)
 
 	for (i = 0; i < VFE40_NUM_STATS_TYPE; i++) {
 		ub_offset -= ub_size[i];
-		msm_camera_io_w(stats_burst_len << 30 |
+		msm_camera_io_w(VFE40_STATS_BURST_LEN << 30 |
 			ub_offset << 16 | (ub_size[i] - 1),
 			vfe_dev->vfe_base + VFE40_STATS_BASE(i) + 0xC);
 	}
@@ -1589,11 +1488,6 @@ struct msm_vfe_hardware_info vfe40_hw_info = {
 			.release_hw = msm_vfe40_release_hardware,
 			.get_platform_data = msm_vfe40_get_platform_data,
 			.get_error_mask = msm_vfe40_get_error_mask,
-			.get_overflow_mask = msm_vfe40_get_overflow_mask,
-			.get_irq_mask = msm_vfe40_get_irq_mask,
-			.restore_irq_mask = msm_vfe40_restore_irq_mask,
-			.get_halt_restart_mask =
-				msm_vfe40_get_halt_restart_mask,
 			.process_error_status = msm_vfe40_process_error_status,
 		},
 		.stats_ops = {
diff --git a/drivers/media/platform/msm/camera_v2/isp/msm_isp_axi_util.c b/drivers/media/platform/msm/camera_v2/isp/msm_isp_axi_util.c
index 22572aa..3632ea9 100644
--- a/drivers/media/platform/msm/camera_v2/isp/msm_isp_axi_util.c
+++ b/drivers/media/platform/msm/camera_v2/isp/msm_isp_axi_util.c
@@ -11,7 +11,6 @@
  */
 #include <linux/io.h>
 #include <media/v4l2-subdev.h>
-#include <asm/div64.h>
 #include "msm_isp_util.h"
 #include "msm_isp_axi_util.h"
 
@@ -21,9 +20,6 @@
 
 #define HANDLE_TO_IDX(handle) (handle & 0xFF)
 
-#define MSM_ISP_MIN_AB 450000000
-#define MSM_ISP_MIN_IB 900000000
-
 int msm_isp_axi_create_stream(
 	struct msm_vfe_axi_shared_data *axi_data,
 	struct msm_vfe_axi_stream_request_cmd *stream_cfg_cmd)
@@ -85,10 +81,6 @@ int msm_isp_validate_axi_request(struct msm_vfe_axi_shared_data *axi_data,
 		return rc;
 
 	switch (stream_cfg_cmd->output_format) {
-	case V4L2_PIX_FMT_YUYV:
-	case V4L2_PIX_FMT_YVYU:
-	case V4L2_PIX_FMT_UYVY:
-	case V4L2_PIX_FMT_VYUY:
 	case V4L2_PIX_FMT_SBGGR8:
 	case V4L2_PIX_FMT_SGBRG8:
 	case V4L2_PIX_FMT_SGRBG8:
@@ -175,10 +167,6 @@ static uint32_t msm_isp_axi_get_plane_size(
 	uint32_t size = 0;
 	struct msm_vfe_axi_plane_cfg *plane_cfg = stream_info->plane_cfg;
 	switch (stream_info->output_format) {
-	case V4L2_PIX_FMT_YUYV:
-	case V4L2_PIX_FMT_YVYU:
-	case V4L2_PIX_FMT_UYVY:
-	case V4L2_PIX_FMT_VYUY:
 	case V4L2_PIX_FMT_SBGGR8:
 	case V4L2_PIX_FMT_SGBRG8:
 	case V4L2_PIX_FMT_SGRBG8:
@@ -341,8 +329,8 @@ int msm_isp_axi_check_stream_state(
 	}
 
 	for (i = 0; i < stream_cfg_cmd->num_streams; i++) {
-		if (HANDLE_TO_IDX(stream_cfg_cmd->stream_handle[i]) >=
-			MAX_NUM_STREAM) {
+		if (HANDLE_TO_IDX(stream_cfg_cmd->stream_handle[i])
+		> MAX_NUM_STREAM) {
 			return -EINVAL;
 		}
 		stream_info = &axi_data->stream_info[
@@ -383,6 +371,42 @@ int msm_isp_axi_check_stream_state(
 	return rc;
 }
 
+void msm_isp_update_framedrop_rdi_reg(struct vfe_device *vfe_dev, int flag)
+{
+	int i;
+	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
+	struct msm_vfe_axi_stream *stream_info;
+	int stream_src;
+
+	for (i = 0; i < MAX_NUM_STREAM; i++) {
+		stream_info = &axi_data->stream_info[i];
+		if (stream_info->state != ACTIVE)
+			continue;
+
+		stream_src = stream_info->stream_src - VFE_SRC_MAX + 1;
+		if (!((1 << stream_src) & flag))
+			continue;
+
+		if (stream_info->runtime_framedrop_update) {
+			stream_info->runtime_init_frame_drop--;
+			if (stream_info->runtime_init_frame_drop == 0) {
+				stream_info->runtime_framedrop_update = 0;
+				vfe_dev->hw_info->vfe_ops.axi_ops.
+				cfg_framedrop(vfe_dev, stream_info);
+			}
+		}
+		if (stream_info->stream_type == BURST_STREAM) {
+			stream_info->runtime_burst_frame_count--;
+			if (stream_info->runtime_burst_frame_count == 0) {
+				vfe_dev->hw_info->vfe_ops.axi_ops.
+				cfg_framedrop(vfe_dev, stream_info);
+				vfe_dev->hw_info->vfe_ops.core_ops.
+				 reg_update(vfe_dev);
+			}
+		}
+	}
+}
+
 void msm_isp_update_framedrop_reg(struct vfe_device *vfe_dev)
 {
 	int i;
@@ -456,7 +480,7 @@ void msm_isp_sof_notify(struct vfe_device *vfe_dev,
 	sof_event.frame_id = vfe_dev->axi_data.src_info[frame_src].frame_id;
 	sof_event.timestamp = ts->event_time;
 	sof_event.mono_timestamp = ts->buf_time;
-	msm_isp_send_event(vfe_dev, ISP_EVENT_SOF + frame_src, &sof_event);
+	msm_isp_send_event(vfe_dev, ISP_EVENT_SOF, &sof_event);
 }
 
 void msm_isp_calculate_framedrop(
@@ -479,8 +503,7 @@ void msm_isp_calculate_framedrop(
 
 	framedrop_period = msm_isp_get_framedrop_period(
 			stream_cfg_cmd->frame_skip_pattern);
-	stream_info->frame_skip_pattern =
-			stream_cfg_cmd->frame_skip_pattern;
+
 	if (stream_cfg_cmd->frame_skip_pattern == SKIP_ALL)
 		stream_info->framedrop_pattern = 0x0;
 	else
@@ -525,64 +548,16 @@ void msm_isp_calculate_bandwidth(
 			stream_info->format_factor / ISP_Q2;
 	} else {
 		int rdi = SRC_TO_INTF(stream_info->stream_src);
-		if (rdi < VFE_SRC_MAX)
-			stream_info->bandwidth =
-				axi_data->src_info[rdi].pixel_clock;
+		stream_info->bandwidth = axi_data->src_info[rdi].pixel_clock;
 	}
 }
 
-#ifdef CONFIG_MSM_AVTIMER
-void msm_isp_start_avtimer(void)
-{
-    avcs_core_open();
-    avcs_core_disable_power_collapse(1);
-}
-static inline void msm_isp_get_avtimer_ts(
-               struct msm_isp_timestamp *time_stamp)
-{
-       int rc = 0;
-       uint32_t avtimer_usec = 0;
-       uint64_t avtimer_tick = 0;
-
-       rc = avcs_core_query_timer(&avtimer_tick);
-       if (rc < 0) {
-               pr_err("%s: Error: Invalid AVTimer Tick, rc=%d\n",
-                          __func__, rc);
-               /* In case of error return zero AVTimer Tick Value */
-               time_stamp->vt_time.tv_sec = 0;
-               time_stamp->vt_time.tv_usec = 0;
-       } else {
-               avtimer_usec = do_div(avtimer_tick, USEC_PER_SEC);
-               time_stamp->vt_time.tv_sec = (uint32_t)(avtimer_tick);
-               time_stamp->vt_time.tv_usec = avtimer_usec;
-               pr_debug("%s: AVTimer TS = %u:%u\n", __func__,
-                       (uint32_t)(avtimer_tick), avtimer_usec);
-       }
-}
-#else
-void msm_isp_start_avtimer(void)
-{
-    pr_err("AV Timer is not supported\n");
-}
-
-static inline void msm_isp_get_avtimer_ts(
-               struct msm_isp_timestamp *time_stamp)
-{
-       pr_err("%s: Error: AVTimer driver not available\n",__func__);
-       time_stamp->vt_time.tv_sec = 0;
-       time_stamp->vt_time.tv_usec = 0;
-}
-
-#endif
-
-
 int msm_isp_request_axi_stream(struct vfe_device *vfe_dev, void *arg)
 {
 	int rc = 0, i;
 	uint32_t io_format = 0;
 	struct msm_vfe_axi_stream_request_cmd *stream_cfg_cmd = arg;
 	struct msm_vfe_axi_stream *stream_info;
-	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
 
 	rc = msm_isp_axi_create_stream(
 		&vfe_dev->axi_data, stream_cfg_cmd);
@@ -595,11 +570,8 @@ int msm_isp_request_axi_stream(struct vfe_device *vfe_dev, void *arg)
 		&vfe_dev->axi_data, stream_cfg_cmd);
 	if (rc) {
 		pr_err("%s: Request validation failed\n", __func__);
-		if (HANDLE_TO_IDX(stream_cfg_cmd->axi_stream_handle) <
-			MAX_NUM_STREAM) {
-			msm_isp_axi_destroy_stream(&vfe_dev->axi_data,
-				HANDLE_TO_IDX(stream_cfg_cmd->axi_stream_handle));
-		}
+		msm_isp_axi_destroy_stream(&vfe_dev->axi_data,
+			HANDLE_TO_IDX(stream_cfg_cmd->axi_stream_handle));
 		return rc;
 	}
 
@@ -632,12 +604,16 @@ int msm_isp_request_axi_stream(struct vfe_device *vfe_dev, void *arg)
 	}
 
 	msm_isp_calculate_framedrop(&vfe_dev->axi_data, stream_cfg_cmd);
-
-	if (stream_cfg_cmd->vt_enable && !vfe_dev->vt_enable) {
-		vfe_dev->vt_enable = stream_cfg_cmd->vt_enable;
-		msm_isp_start_avtimer();
+	stream_info->vt_enable = stream_cfg_cmd->vt_enable;
+	if (stream_info->vt_enable) {
+		vfe_dev->vt_enable = stream_info->vt_enable;
+	#ifdef CONFIG_MSM_AVTIMER
+		avcs_core_open();
+		avcs_core_disable_power_collapse(1);
+	#endif
+		vfe_dev->p_avtimer_lsw = ioremap(AVTIMER_LSW_PHY_ADDR, 4);
+		vfe_dev->p_avtimer_msw = ioremap(AVTIMER_MSW_PHY_ADDR, 4);
 	}
-	axi_data->burst_len = stream_cfg_cmd->burst_len;
 	if (stream_info->num_planes > 1) {
 		msm_isp_axi_reserve_comp_mask(
 			&vfe_dev->axi_data, stream_info);
@@ -663,17 +639,11 @@ int msm_isp_release_axi_stream(struct vfe_device *vfe_dev, void *arg)
 	int rc = 0, i;
 	struct msm_vfe_axi_stream_release_cmd *stream_release_cmd = arg;
 	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
-	struct msm_vfe_axi_stream *stream_info;
+	struct msm_vfe_axi_stream *stream_info =
+		&axi_data->stream_info[
+		HANDLE_TO_IDX(stream_release_cmd->stream_handle)];
 	struct msm_vfe_axi_stream_cfg_cmd stream_cfg;
 
-	if(HANDLE_TO_IDX(stream_release_cmd->stream_handle) >=
-	        MAX_NUM_STREAM) {
-	        pr_err("%s: Invalid stream handle\n", __func__);
-	        return -EINVAL;
-	}
-
-	stream_info = &axi_data->stream_info[
-		HANDLE_TO_IDX(stream_release_cmd->stream_handle)];
 	if (stream_info->state == AVALIABLE) {
 		pr_err("%s: Stream already released\n", __func__);
 		return -EINVAL;
@@ -868,21 +838,6 @@ static int msm_isp_cfg_ping_pong_address(struct vfe_device *vfe_dev,
 	uint32_t pingpong_bit = 0;
 	uint32_t bufq_handle = stream_info->bufq_handle;
 	uint32_t stream_idx = HANDLE_TO_IDX(stream_info->stream_handle);
-	uint32_t src_intf = SRC_TO_INTF(stream_info->stream_src);
-	uint32_t frame_id = 0;
-	if (stream_idx >= MAX_NUM_STREAM) {
-		pr_err("%s: Invalid stream_idx", __func__);
-		return rc;
-	}
-	if (src_intf < VFE_SRC_MAX)
-		frame_id = vfe_dev->axi_data.src_info[src_intf].frame_id;
-
-	if (frame_id && (stream_info->frame_id >= frame_id)) {
-		pr_err("%s: duplicate frame_id, Session frm id %d cur frm id %d\n",
-		__func__, frame_id, stream_info->frame_id);
-		vfe_dev->error_info.stream_framedrop_count[stream_idx]++;
-		return rc;
-	}
 
 	rc = vfe_dev->buf_mgr->ops->get_buf(vfe_dev->buf_mgr,
 			vfe_dev->pdev->id, bufq_handle, &buf);
@@ -922,22 +877,11 @@ static void msm_isp_process_done_buf(struct vfe_device *vfe_dev,
 	struct msm_isp_event_data buf_event;
 	struct timeval *time_stamp;
 	uint32_t stream_idx = HANDLE_TO_IDX(stream_info->stream_handle);
-	uint32_t src_intf = SRC_TO_INTF(stream_info->stream_src);
-	uint32_t frame_id = 0;
-	memset(&buf_event, 0, sizeof(buf_event) );
-
-	if(stream_idx >= MAX_NUM_STREAM) {
-		pr_err("%s: Invalid stream_idx \n", __func__);
-		return;
-	}
-
-	if (src_intf < VFE_SRC_MAX) {
-		frame_id = vfe_dev->axi_data.src_info[src_intf].frame_id;
-	}
+	uint32_t frame_id = vfe_dev->axi_data.
+		src_info[SRC_TO_INTF(stream_info->stream_src)].frame_id;
 
 	if (buf && ts) {
 		if (vfe_dev->vt_enable) {
-                        msm_isp_get_avtimer_ts(ts);
 			time_stamp = &ts->vt_time;
 		} else {
 			time_stamp = &ts->buf_time;
@@ -1026,7 +970,7 @@ static void msm_isp_update_camif_output_count(
 
 	for (i = 0; i < stream_cfg_cmd->num_streams; i++) {
 		if (HANDLE_TO_IDX(stream_cfg_cmd->stream_handle[i])
-		>= MAX_NUM_STREAM) {
+		> MAX_NUM_STREAM) {
 			return;
 		}
 		stream_info =
@@ -1068,7 +1012,7 @@ static void msm_isp_update_rdi_output_count(
 
 	for (i = 0; i < stream_cfg_cmd->num_streams; i++) {
 		if (HANDLE_TO_IDX(stream_cfg_cmd->stream_handle[i])
-		>= MAX_NUM_STREAM) {
+		> MAX_NUM_STREAM) {
 			return;
 		}
 		stream_info =
@@ -1153,8 +1097,6 @@ static int msm_isp_update_stream_bandwidth(struct vfe_device *vfe_dev)
 	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
 	uint32_t total_pix_bandwidth = 0, total_rdi_bandwidth = 0;
 	uint32_t num_pix_streams = 0;
-	uint32_t num_rdi_streams = 0;
-	uint32_t total_streams   = 0;
 	uint64_t total_bandwidth = 0;
 
 	for (i = 0; i < MAX_NUM_STREAM; i++) {
@@ -1166,7 +1108,6 @@ static int msm_isp_update_stream_bandwidth(struct vfe_device *vfe_dev)
 				num_pix_streams++;
 			} else {
 				total_rdi_bandwidth += stream_info->bandwidth;
-				num_rdi_streams++;
 			}
 		}
 	}
@@ -1176,17 +1117,10 @@ static int msm_isp_update_stream_bandwidth(struct vfe_device *vfe_dev)
 			((unsigned long)axi_data->src_info[VFE_PIX_0].
 			pixel_clock) * ISP_DEFAULT_FORMAT_FACTOR / ISP_Q2;
 	total_bandwidth = total_pix_bandwidth + total_rdi_bandwidth;
-	total_streams = num_pix_streams + num_rdi_streams;
-	if (total_streams == 1) {
-         rc = msm_isp_update_bandwidth(ISP_VFE0 + vfe_dev->pdev->id,
-		(total_bandwidth - MSM_ISP_MIN_AB) , (total_bandwidth *
-		ISP_BUS_UTILIZATION_FACTOR / ISP_Q2 - MSM_ISP_MIN_IB));
-	}
-	else {
+
 	rc = msm_isp_update_bandwidth(ISP_VFE0 + vfe_dev->pdev->id,
 		total_bandwidth, total_bandwidth *
 		ISP_BUS_UTILIZATION_FACTOR / ISP_Q2);
-	}
 	if (rc < 0)
 		pr_err("%s: update failed\n", __func__);
 
@@ -1276,29 +1210,28 @@ static int msm_isp_start_axi_stream(struct vfe_device *vfe_dev,
 			enum msm_isp_camif_update_state camif_update)
 {
 	int i, rc = 0;
-	uint8_t src_state = 0, wait_for_complete = 0;
+	uint8_t src_state, wait_for_complete = 0;
 	uint32_t wm_reload_mask = 0x0;
 	struct msm_vfe_axi_stream *stream_info;
 	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
-
+	uint8_t init_frm_drop = 0;
 	if (stream_cfg_cmd->num_streams > MAX_NUM_STREAM) {
 		return -EINVAL;
 	}
 
 	for (i = 0; i < stream_cfg_cmd->num_streams; i++) {
 		if (HANDLE_TO_IDX(stream_cfg_cmd->stream_handle[i])
-		>= MAX_NUM_STREAM) {
+		> MAX_NUM_STREAM) {
 			return -EINVAL;
 		}
 		stream_info = &axi_data->stream_info[
 			HANDLE_TO_IDX(stream_cfg_cmd->stream_handle[i])];
-		stream_info->frame_id = 0;
-		if (SRC_TO_INTF(stream_info->stream_src) < VFE_SRC_MAX)
-			src_state = axi_data->src_info[
-				SRC_TO_INTF(stream_info->stream_src)].active;
+		src_state = axi_data->src_info[
+			SRC_TO_INTF(stream_info->stream_src)].active;
 
 		msm_isp_calculate_bandwidth(axi_data, stream_info);
 		msm_isp_reset_framedrop(vfe_dev, stream_info);
+                init_frm_drop = stream_info->init_frame_drop;
 		msm_isp_get_stream_wm_mask(stream_info, &wm_reload_mask);
 		rc = msm_isp_init_stream_ping_pong_reg(vfe_dev, stream_info);
 		if (rc < 0) {
@@ -1319,8 +1252,6 @@ static int msm_isp_start_axi_stream(struct vfe_device *vfe_dev,
 			msm_isp_axi_stream_enable_cfg(vfe_dev, stream_info);
 			stream_info->state = ACTIVE;
 		}
-		vfe_dev->axi_data.src_info[
-			SRC_TO_INTF(stream_info->stream_src)].frame_id = 0;
 	}
 	msm_isp_update_stream_bandwidth(vfe_dev);
 	vfe_dev->hw_info->vfe_ops.axi_ops.reload_wm(vfe_dev, wm_reload_mask);
@@ -1334,6 +1265,16 @@ static int msm_isp_start_axi_stream(struct vfe_device *vfe_dev,
 			update_camif_state(vfe_dev, camif_update);
 	}
 
+	if (vfe_dev->axi_data.src_info[VFE_RAW_0].raw_stream_count > 0) {
+		vfe_dev->axi_data.src_info[VFE_RAW_0].frame_id = init_frm_drop;
+	}
+	if (vfe_dev->axi_data.src_info[VFE_RAW_1].raw_stream_count > 0) {
+		vfe_dev->axi_data.src_info[VFE_RAW_1].frame_id = init_frm_drop;
+	}
+	if (vfe_dev->axi_data.src_info[VFE_RAW_2].raw_stream_count > 0) {
+		vfe_dev->axi_data.src_info[VFE_RAW_2].frame_id = init_frm_drop;
+	}
+
 	if (wait_for_complete)
 		rc = msm_isp_axi_wait_for_cfg_done(vfe_dev, camif_update);
 
@@ -1355,7 +1296,7 @@ static int msm_isp_stop_axi_stream(struct vfe_device *vfe_dev,
 
 	for (i = 0; i < stream_cfg_cmd->num_streams; i++) {
 		if (HANDLE_TO_IDX(stream_cfg_cmd->stream_handle[i])
-		>= MAX_NUM_STREAM) {
+		> MAX_NUM_STREAM) {
 			return -EINVAL;
 		}
 		stream_info = &axi_data->stream_info[
@@ -1412,13 +1353,11 @@ static int msm_isp_stop_axi_stream(struct vfe_device *vfe_dev,
 	msm_isp_update_rdi_output_count(vfe_dev, stream_cfg_cmd);
 	cur_stream_cnt = msm_isp_get_curr_stream_cnt(vfe_dev);
 	if (cur_stream_cnt == 0) {
-		vfe_dev->ignore_error = 1;
 		if (camif_update == DISABLE_CAMIF_IMMEDIATELY) {
-			vfe_dev->hw_info->vfe_ops.axi_ops.halt(vfe_dev, 1);
+			vfe_dev->hw_info->vfe_ops.axi_ops.halt(vfe_dev);
 		}
-		vfe_dev->hw_info->vfe_ops.core_ops.reset_hw(vfe_dev, ISP_RST_HARD, 1);
+		vfe_dev->hw_info->vfe_ops.core_ops.reset_hw(vfe_dev, ISP_RST_HARD);
 		vfe_dev->hw_info->vfe_ops.core_ops.init_hw_reg(vfe_dev);
-		vfe_dev->ignore_error = 0;
 	}
 
 	for (i = 0; i < stream_cfg_cmd->num_streams; i++) {
@@ -1484,7 +1423,7 @@ int msm_isp_update_axi_stream(struct vfe_device *vfe_dev, void *arg)
 		update_info = &update_cmd->update_info[i];
 		/*check array reference bounds*/
 		if (HANDLE_TO_IDX(update_info->stream_handle)
-		 >= MAX_NUM_STREAM) {
+		 > MAX_NUM_STREAM) {
 			return -EINVAL;
 		}
 		stream_info = &axi_data->stream_info[
@@ -1589,12 +1528,11 @@ void msm_isp_process_axi_irq(struct vfe_device *vfe_dev,
 		vfe_dev->hw_info->vfe_ops.axi_ops.get_pingpong_status(vfe_dev);
 
 	msm_isp_get_buffer_ts(vfe_dev, ts, &buf_ts);
+
 	for (i = 0; i < axi_data->hw_info->num_comp_mask; i++) {
 		comp_info = &axi_data->composite_info[i];
 		if (comp_mask & (1 << i)) {
-			stream_idx = HANDLE_TO_IDX(comp_info->stream_handle);
-			if ((!comp_info->stream_handle) ||
-				(stream_idx >= MAX_NUM_STREAM)) {
+			if (!comp_info->stream_handle) {
 				pr_err("%s: Invalid handle for composite irq\n",
 					__func__);
 			} else {
@@ -1605,6 +1543,7 @@ void msm_isp_process_axi_irq(struct vfe_device *vfe_dev,
 				ISP_DBG("%s: stream%d frame id: 0x%x\n",
 					__func__,
 					stream_idx, stream_info->frame_id);
+				stream_info->frame_id++;
 
 				if (stream_info->stream_type == BURST_STREAM)
 					stream_info->
@@ -1620,11 +1559,6 @@ void msm_isp_process_axi_irq(struct vfe_device *vfe_dev,
 							vfe_dev, stream_info,
 							pingpong_status);
 				}
-				if ((stream_info->stream_src < RDI_INTF_0) &&
-					SRC_TO_INTF(stream_info->stream_src) < VFE_SRC_MAX) {
-					stream_info->frame_id = vfe_dev->axi_data.
-						src_info[SRC_TO_INTF(stream_info->stream_src)].frame_id;
-				}
 				if (done_buf && !rc)
 					msm_isp_process_done_buf(vfe_dev,
 					stream_info, done_buf, &buf_ts);
@@ -1635,17 +1569,17 @@ void msm_isp_process_axi_irq(struct vfe_device *vfe_dev,
 
 	for (i = 0; i < axi_data->hw_info->num_wm; i++) {
 		if (wm_mask & (1 << i)) {
-			stream_idx = HANDLE_TO_IDX(axi_data->free_wm[i]);
-			if ((!axi_data->free_wm[i]) ||
-				(stream_idx >= MAX_NUM_STREAM)) {
+			if (!axi_data->free_wm[i]) {
 				pr_err("%s: Invalid handle for wm irq\n",
 					__func__);
 				continue;
 			}
+			stream_idx = HANDLE_TO_IDX(axi_data->free_wm[i]);
 			stream_info = &axi_data->stream_info[stream_idx];
 			ISP_DBG("%s: stream%d frame id: 0x%x\n",
 				__func__,
 				stream_idx, stream_info->frame_id);
+			stream_info->frame_id++;
 
 			if (stream_info->stream_type == BURST_STREAM)
 				stream_info->runtime_num_burst_capture--;
@@ -1657,10 +1591,6 @@ void msm_isp_process_axi_irq(struct vfe_device *vfe_dev,
 				rc = msm_isp_cfg_ping_pong_address(vfe_dev,
 					stream_info, pingpong_status);
 			}
-			if ((stream_info->stream_src < RDI_INTF_0) &&
-				SRC_TO_INTF(stream_info->stream_src) < VFE_SRC_MAX)
-				stream_info->frame_id = vfe_dev->axi_data.
-					src_info[SRC_TO_INTF(stream_info->stream_src)].frame_id;
 			if (done_buf && !rc)
 				msm_isp_process_done_buf(vfe_dev,
 				stream_info, done_buf, &buf_ts);
diff --git a/drivers/media/platform/msm/camera_v2/isp/msm_isp_axi_util.h b/drivers/media/platform/msm/camera_v2/isp/msm_isp_axi_util.h
index 2314300..7aa0e18 100644
--- a/drivers/media/platform/msm/camera_v2/isp/msm_isp_axi_util.h
+++ b/drivers/media/platform/msm/camera_v2/isp/msm_isp_axi_util.h
@@ -37,10 +37,6 @@ int msm_isp_axi_check_stream_state(
 	struct vfe_device *vfe_dev,
 	struct msm_vfe_axi_stream_cfg_cmd *stream_cfg_cmd);
 
-void msm_isp_calculate_framedrop(
-		struct msm_vfe_axi_shared_data *axi_data,
-		struct msm_vfe_axi_stream_request_cmd *stream_cfg_cmd);
-
 int msm_isp_request_axi_stream(struct vfe_device *vfe_dev, void *arg);
 int msm_isp_cfg_axi_stream(struct vfe_device *vfe_dev, void *arg);
 int msm_isp_release_axi_stream(struct vfe_device *vfe_dev, void *arg);
@@ -50,6 +46,7 @@ void msm_isp_axi_cfg_update(struct vfe_device *vfe_dev);
 void msm_isp_axi_stream_update(struct vfe_device *vfe_dev);
 
 void msm_isp_update_framedrop_reg(struct vfe_device *vfe_dev);
+void msm_isp_update_framedrop_rdi_reg(struct vfe_device *vfe_dev, int flag);
 void msm_isp_sof_notify(struct vfe_device *vfe_dev,
 	enum msm_vfe_input_src frame_src, struct msm_isp_timestamp *ts);
 void msm_isp_process_axi_irq(struct vfe_device *vfe_dev,
diff --git a/drivers/media/platform/msm/camera_v2/isp/msm_isp_stats_util.c b/drivers/media/platform/msm/camera_v2/isp/msm_isp_stats_util.c
index d4c86a5..6bd7585 100644
--- a/drivers/media/platform/msm/camera_v2/isp/msm_isp_stats_util.c
+++ b/drivers/media/platform/msm/camera_v2/isp/msm_isp_stats_util.c
@@ -490,9 +490,6 @@ int msm_isp_cfg_stats_stream(struct vfe_device *vfe_dev, void *arg)
 {
 	int rc = 0;
 	struct msm_vfe_stats_stream_cfg_cmd *stream_cfg_cmd = arg;
-	struct msm_vfe_stats_shared_data *stats_data = &vfe_dev->stats_data;
-	stats_data->stats_burst_len =  stream_cfg_cmd->stats_burst_len;
-
 	if (vfe_dev->stats_data.num_active_stream == 0)
 		vfe_dev->hw_info->vfe_ops.stats_ops.cfg_ub(vfe_dev);
 
diff --git a/drivers/media/platform/msm/camera_v2/isp/msm_isp_util.c b/drivers/media/platform/msm/camera_v2/isp/msm_isp_util.c
index dbc27ad..2c83efe 100644
--- a/drivers/media/platform/msm/camera_v2/isp/msm_isp_util.c
+++ b/drivers/media/platform/msm/camera_v2/isp/msm_isp_util.c
@@ -13,6 +13,7 @@
 #include <linux/io.h>
 #include <media/v4l2-subdev.h>
 #include <linux/ratelimit.h>
+#include <asm/div64.h>
 
 #include "msm.h"
 #include "msm_isp_util.h"
@@ -24,8 +25,8 @@
 static DEFINE_MUTEX(bandwidth_mgr_mutex);
 static struct msm_isp_bandwidth_mgr isp_bandwidth_mgr;
 
-#define MSM_ISP_MIN_AB 300000000
-#define MSM_ISP_MIN_IB 450000000
+#define MSM_ISP_MIN_AB 450000000
+#define MSM_ISP_MIN_IB 900000000
 
 #define VFE40_8974V2_VERSION 0x1001001A
 static struct msm_bus_vectors msm_isp_init_vectors[] = {
@@ -129,10 +130,7 @@ int msm_isp_update_bandwidth(enum msm_isp_hw_client client,
 	mutex_lock(&bandwidth_mgr_mutex);
 	if (!isp_bandwidth_mgr.use_count ||
 		!isp_bandwidth_mgr.bus_client) {
-		pr_err("%s:error bandwidth manager inactive use_cnt:%d bus_clnt:%d\n",
-			__func__, isp_bandwidth_mgr.use_count,
-			isp_bandwidth_mgr.bus_client);
-		mutex_unlock(&bandwidth_mgr_mutex);
+		pr_err("%s: bandwidth manager inactive\n", __func__);
 		return -EINVAL;
 	}
 
@@ -168,11 +166,8 @@ void msm_isp_deinit_bandwidth_mgr(enum msm_isp_hw_client client)
 		return;
 	}
 
-	if (!isp_bandwidth_mgr.bus_client) {
-		pr_err("%s:%d error: bus client invalid\n", __func__, __LINE__);
-		mutex_unlock(&bandwidth_mgr_mutex);
+	if (!isp_bandwidth_mgr.bus_client)
 		return;
-	}
 
 	msm_bus_scale_client_update_request(
 	   isp_bandwidth_mgr.bus_client, 0);
@@ -217,6 +212,28 @@ static inline void msm_isp_get_timestamp(struct msm_isp_timestamp *time_stamp)
 	do_gettimeofday(&(time_stamp->event_time));
 }
 
+static inline void msm_isp_get_vt_tstamp(struct vfe_device *vfe_dev,
+	struct msm_isp_timestamp *time_stamp)
+{
+	uint32_t avtimer_msw_1st = 0, avtimer_lsw = 0;
+	uint32_t avtimer_msw_2nd = 0;
+	uint64_t av_timer_tick = 0;
+
+	if (!vfe_dev->p_avtimer_msw || !vfe_dev->p_avtimer_lsw) {
+		pr_err("%s: ioremap failed\n", __func__);
+		return;
+	}
+	do {
+		avtimer_msw_1st = msm_camera_io_r(vfe_dev->p_avtimer_msw);
+		avtimer_lsw = msm_camera_io_r(vfe_dev->p_avtimer_lsw);
+		avtimer_msw_2nd = msm_camera_io_r(vfe_dev->p_avtimer_msw);
+	} while (avtimer_msw_1st != avtimer_msw_2nd);
+	av_timer_tick = ((uint64_t)avtimer_msw_1st << 32) | avtimer_lsw;
+	avtimer_lsw = do_div(av_timer_tick, USEC_PER_SEC);
+	time_stamp->vt_time.tv_sec = (uint32_t)(av_timer_tick);
+	time_stamp->vt_time.tv_usec = avtimer_lsw;
+}
+
 int msm_isp_subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
 	struct v4l2_event_subscription *sub)
 {
@@ -471,107 +488,14 @@ static int msm_isp_send_hw_cmd(struct vfe_device *vfe_dev,
 	struct msm_vfe_reg_cfg_cmd *reg_cfg_cmd,
 	uint32_t *cfg_data, uint32_t cmd_len)
 {
-	if (!vfe_dev || !reg_cfg_cmd) {
-		pr_err("%s:%d failed: vfe_dev %p reg_cfg_cmd %p\n", __func__,
-			__LINE__, vfe_dev, reg_cfg_cmd);
-		return -EINVAL;
-	}
-	if ((reg_cfg_cmd->cmd_type != VFE_CFG_MASK) &&
-		(!cfg_data || !cmd_len)) {
-		pr_err("%s:%d failed: cmd type %d cfg_data %p cmd_len %d\n",
-			__func__, __LINE__, reg_cfg_cmd->cmd_type, cfg_data,
-			cmd_len);
-		return -EINVAL;
-	}
-
-	/* Validate input parameters */
 	switch (reg_cfg_cmd->cmd_type) {
-	case VFE_WRITE:
-	case VFE_READ:
-	case VFE_WRITE_MB: {
-		if ((reg_cfg_cmd->u.rw_info.reg_offset >
-			(UINT_MAX - reg_cfg_cmd->u.rw_info.len)) ||
-			((reg_cfg_cmd->u.rw_info.reg_offset +
-			reg_cfg_cmd->u.rw_info.len) >
-			resource_size(vfe_dev->vfe_mem))) {
-			pr_err("%s:%d reg_offset %d len %d res %d\n",
-				__func__, __LINE__,
-				reg_cfg_cmd->u.rw_info.reg_offset,
-				reg_cfg_cmd->u.rw_info.len,
-				(uint32_t)resource_size(vfe_dev->vfe_mem));
-			return -EINVAL;
-		}
-
-		if ((reg_cfg_cmd->u.rw_info.cmd_data_offset >
-			(UINT_MAX - reg_cfg_cmd->u.rw_info.len)) ||
-			((reg_cfg_cmd->u.rw_info.cmd_data_offset +
-			reg_cfg_cmd->u.rw_info.len) > cmd_len)) {
-			pr_err("%s:%d cmd_data_offset %d len %d cmd_len %d\n",
-				__func__, __LINE__,
-				reg_cfg_cmd->u.rw_info.cmd_data_offset,
-				reg_cfg_cmd->u.rw_info.len, cmd_len);
-			return -EINVAL;
-		}
-		break;
-	}
-
-	case VFE_WRITE_DMI_16BIT:
-	case VFE_WRITE_DMI_32BIT:
-	case VFE_WRITE_DMI_64BIT:
-	case VFE_READ_DMI_16BIT:
-	case VFE_READ_DMI_32BIT:
-	case VFE_READ_DMI_64BIT: {
-		if (reg_cfg_cmd->cmd_type == VFE_WRITE_DMI_64BIT) {
-			if ((reg_cfg_cmd->u.dmi_info.hi_tbl_offset <=
-				reg_cfg_cmd->u.dmi_info.lo_tbl_offset) ||
-				(reg_cfg_cmd->u.dmi_info.hi_tbl_offset -
-				reg_cfg_cmd->u.dmi_info.lo_tbl_offset !=
-				(sizeof(uint32_t)))) {
-				pr_err("%s:%d hi %d lo %d\n",
-					__func__, __LINE__,
-					reg_cfg_cmd->u.dmi_info.hi_tbl_offset,
-					reg_cfg_cmd->u.dmi_info.hi_tbl_offset);
-				return -EINVAL;
-			}
-			if (reg_cfg_cmd->u.dmi_info.len <= sizeof(uint32_t)) {
-				pr_err("%s:%d len %d\n",
-					__func__, __LINE__,
-					reg_cfg_cmd->u.dmi_info.len);
-				return -EINVAL;
-			}
-			if (((UINT_MAX -
-				reg_cfg_cmd->u.dmi_info.hi_tbl_offset) <
-				(reg_cfg_cmd->u.dmi_info.len -
-				sizeof(uint32_t))) ||
-				((reg_cfg_cmd->u.dmi_info.hi_tbl_offset +
-				reg_cfg_cmd->u.dmi_info.len -
-				sizeof(uint32_t)) > cmd_len)) {
-				pr_err("%s:%d hi_tbl_offset %d len %d cmd %d\n",
-					__func__, __LINE__,
-					reg_cfg_cmd->u.dmi_info.hi_tbl_offset,
-					reg_cfg_cmd->u.dmi_info.len, cmd_len);
-				return -EINVAL;
-			}
-		}
-		if ((reg_cfg_cmd->u.dmi_info.lo_tbl_offset >
-			(UINT_MAX - reg_cfg_cmd->u.dmi_info.len)) ||
-			((reg_cfg_cmd->u.dmi_info.lo_tbl_offset +
-			reg_cfg_cmd->u.dmi_info.len) > cmd_len)) {
-			pr_err("%s:%d lo_tbl_offset %d len %d cmd_len %d\n",
-				__func__, __LINE__,
-				reg_cfg_cmd->u.dmi_info.lo_tbl_offset,
-				reg_cfg_cmd->u.dmi_info.len, cmd_len);
+	case VFE_WRITE: {
+		if (resource_size(vfe_dev->vfe_mem) <
+			(reg_cfg_cmd->u.rw_info.reg_offset +
+			reg_cfg_cmd->u.rw_info.len)) {
+			pr_err("%s: VFE_WRITE: Invalid length\n", __func__);
 			return -EINVAL;
 		}
-		break;
-	}
-
-	default:
-		break;
-	}
-
-	switch (reg_cfg_cmd->cmd_type) {
-	case VFE_WRITE: {
 		msm_camera_io_memcpy(vfe_dev->vfe_base +
 			reg_cfg_cmd->u.rw_info.reg_offset,
 			cfg_data + reg_cfg_cmd->u.rw_info.cmd_data_offset/4,
@@ -579,27 +503,39 @@ static int msm_isp_send_hw_cmd(struct vfe_device *vfe_dev,
 		break;
 	}
 	case VFE_WRITE_MB: {
-		msm_camera_io_memcpy_mb(vfe_dev->vfe_base +
-			reg_cfg_cmd->u.rw_info.reg_offset,
-			cfg_data + reg_cfg_cmd->u.rw_info.cmd_data_offset/4,
-			reg_cfg_cmd->u.rw_info.len);
+		uint32_t *data_ptr = cfg_data +
+			reg_cfg_cmd->u.rw_info.cmd_data_offset/4;
+
+		if ((UINT_MAX - sizeof(*data_ptr) <
+					reg_cfg_cmd->u.rw_info.reg_offset) ||
+			(resource_size(vfe_dev->vfe_mem) <
+			reg_cfg_cmd->u.rw_info.reg_offset +
+			sizeof(*data_ptr))) {
+			pr_err("%s: VFE_WRITE_MB: Invalid length\n", __func__);
+			return -EINVAL;
+		}
+		msm_camera_io_w_mb(*data_ptr, vfe_dev->vfe_base +
+			reg_cfg_cmd->u.rw_info.reg_offset);
 		break;
 	}
 	case VFE_CFG_MASK: {
 		uint32_t temp;
+		if (resource_size(vfe_dev->vfe_mem) <
+				reg_cfg_cmd->u.mask_info.reg_offset)
+			return -EINVAL;
+		temp = msm_camera_io_r(vfe_dev->vfe_base +
+			reg_cfg_cmd->u.mask_info.reg_offset);
+
+		temp &= ~reg_cfg_cmd->u.mask_info.mask;
+		temp |= reg_cfg_cmd->u.mask_info.val;
 		if ((UINT_MAX - sizeof(temp) <
-			reg_cfg_cmd->u.mask_info.reg_offset) ||
+					reg_cfg_cmd->u.mask_info.reg_offset) ||
 			(resource_size(vfe_dev->vfe_mem) <
 			reg_cfg_cmd->u.mask_info.reg_offset +
 			sizeof(temp))) {
 			pr_err("%s: VFE_CFG_MASK: Invalid length\n", __func__);
 			return -EINVAL;
 		}
-		temp = msm_camera_io_r(vfe_dev->vfe_base +
-			reg_cfg_cmd->u.mask_info.reg_offset);
-
-		temp &= ~reg_cfg_cmd->u.mask_info.mask;
-		temp |= reg_cfg_cmd->u.mask_info.val;
 		msm_camera_io_w(temp, vfe_dev->vfe_base +
 			reg_cfg_cmd->u.mask_info.reg_offset);
 		break;
@@ -611,9 +547,22 @@ static int msm_isp_send_hw_cmd(struct vfe_device *vfe_dev,
 		uint32_t *hi_tbl_ptr = NULL, *lo_tbl_ptr = NULL;
 		uint32_t hi_val, lo_val, lo_val1;
 		if (reg_cfg_cmd->cmd_type == VFE_WRITE_DMI_64BIT) {
+			if ((UINT_MAX - reg_cfg_cmd->u.dmi_info.hi_tbl_offset <
+						reg_cfg_cmd->u.dmi_info.len) ||
+				(reg_cfg_cmd->u.dmi_info.hi_tbl_offset +
+				reg_cfg_cmd->u.dmi_info.len > cmd_len)) {
+				pr_err("Invalid Hi Table out of bounds\n");
+				return -EINVAL;
+			}
 			hi_tbl_ptr = cfg_data +
 				reg_cfg_cmd->u.dmi_info.hi_tbl_offset/4;
 		}
+
+		if (reg_cfg_cmd->u.dmi_info.lo_tbl_offset +
+			reg_cfg_cmd->u.dmi_info.len > cmd_len) {
+			pr_err("Invalid Lo Table out of bounds\n");
+			return -EINVAL;
+		}
 		lo_tbl_ptr = cfg_data +
 			reg_cfg_cmd->u.dmi_info.lo_tbl_offset/4;
 		if (reg_cfg_cmd->cmd_type == VFE_WRITE_DMI_64BIT)
@@ -646,18 +595,30 @@ static int msm_isp_send_hw_cmd(struct vfe_device *vfe_dev,
 		uint32_t *hi_tbl_ptr = NULL, *lo_tbl_ptr = NULL;
 		uint32_t hi_val, lo_val, lo_val1;
 		if (reg_cfg_cmd->cmd_type == VFE_READ_DMI_64BIT) {
+			if (reg_cfg_cmd->u.dmi_info.hi_tbl_offset +
+				reg_cfg_cmd->u.dmi_info.len > cmd_len) {
+				pr_err("Invalid Hi Table out of bounds\n");
+				return -EINVAL;
+			}
 			hi_tbl_ptr = cfg_data +
 				reg_cfg_cmd->u.dmi_info.hi_tbl_offset/4;
 		}
 
+		if (reg_cfg_cmd->u.dmi_info.lo_tbl_offset +
+			reg_cfg_cmd->u.dmi_info.len > cmd_len) {
+			pr_err("Invalid Lo Table out of bounds\n");
+			return -EINVAL;
+		}
 		lo_tbl_ptr = cfg_data +
 			reg_cfg_cmd->u.dmi_info.lo_tbl_offset/4;
 
-		if (reg_cfg_cmd->cmd_type == VFE_READ_DMI_64BIT)
-			reg_cfg_cmd->u.dmi_info.len =
-				reg_cfg_cmd->u.dmi_info.len / 2;
-
 		for (i = 0; i < reg_cfg_cmd->u.dmi_info.len/4; i++) {
+			if (reg_cfg_cmd->cmd_type == VFE_READ_DMI_64BIT) {
+				hi_val = msm_camera_io_r(vfe_dev->vfe_base +
+					vfe_dev->hw_info->dmi_reg_offset);
+				*hi_tbl_ptr++ = hi_val;
+			}
+
 			lo_val = msm_camera_io_r(vfe_dev->vfe_base +
 					vfe_dev->hw_info->dmi_reg_offset + 0x4);
 
@@ -667,43 +628,9 @@ static int msm_isp_send_hw_cmd(struct vfe_device *vfe_dev,
 				lo_val |= lo_val1 << 16;
 			}
 			*lo_tbl_ptr++ = lo_val;
-			if (reg_cfg_cmd->cmd_type == VFE_READ_DMI_64BIT) {
-				hi_val = msm_camera_io_r(vfe_dev->vfe_base +
-					vfe_dev->hw_info->dmi_reg_offset);
-				*hi_tbl_ptr = hi_val;
-				hi_tbl_ptr += 2;
-				lo_tbl_ptr++;
-			}
-		}
-		break;
-	}
-	case VFE_HW_UPDATE_LOCK: {
-		uint32_t update_id =
-			vfe_dev->axi_data.src_info[VFE_PIX_0].last_updt_frm_id;
-		if (vfe_dev->axi_data.src_info[VFE_PIX_0].frame_id != *cfg_data
-			|| update_id == *cfg_data) {
-			ISP_DBG("hw update lock failed,acquire id %u\n",
-				*cfg_data);
-			ISP_DBG("hw update lock failed,current id %lu\n",
-				vfe_dev->axi_data.src_info[VFE_PIX_0].frame_id);
-			ISP_DBG("hw update lock failed,last id %u\n",
-				update_id);
-			return -EINVAL;
 		}
 		break;
 	}
-	case VFE_HW_UPDATE_UNLOCK: {
-		if (vfe_dev->axi_data.src_info[VFE_PIX_0].frame_id
-			!= *cfg_data) {
-			ISP_DBG("hw update across frame boundary,begin id %u\n",
-				*cfg_data);
-			ISP_DBG("hw update across frame boundary,end id %lu\n",
-				vfe_dev->axi_data.src_info[VFE_PIX_0].frame_id);
-		}
-		vfe_dev->axi_data.src_info[VFE_PIX_0].last_updt_frm_id =
-			vfe_dev->axi_data.src_info[VFE_PIX_0].frame_id;
-		break;
-	}
 	case VFE_READ: {
 		int i;
 		uint32_t *data_ptr = cfg_data +
@@ -712,7 +639,7 @@ static int msm_isp_send_hw_cmd(struct vfe_device *vfe_dev,
 			if ((data_ptr < cfg_data) ||
 				(UINT_MAX / sizeof(*data_ptr) <
 				 (data_ptr - cfg_data)) ||
-				(sizeof(*data_ptr) * (data_ptr - cfg_data) >=
+				(sizeof(*data_ptr) * (data_ptr - cfg_data) >
 				 cmd_len))
 				return -EINVAL;
 			*data_ptr++ = msm_camera_io_r(vfe_dev->vfe_base +
@@ -721,16 +648,9 @@ static int msm_isp_send_hw_cmd(struct vfe_device *vfe_dev,
 		}
 		break;
 	}
-	case GET_SOC_HW_VER: {
-	  if (cmd_len < sizeof(uint32_t)) {
-			pr_err("%s:%d failed: invalid cmd len %u exp %zu\n",
-				__func__, __LINE__, cmd_len,
-				sizeof(uint32_t));
-			return -EINVAL;
-		}
-	  *cfg_data = vfe_dev->soc_hw_version;
-	  break;
-	}
+	case GET_SOC_HW_VER:
+		*cfg_data = vfe_dev->soc_hw_version;
+		break;
 	case GET_MAX_CLK_RATE: {
 		int rc = 0;
 
@@ -748,16 +668,6 @@ static int msm_isp_send_hw_cmd(struct vfe_device *vfe_dev,
 		}
 		break;
 	}
-	case SET_WM_UB_SIZE: {
-	  	  if (cmd_len < sizeof(uint32_t)) {
-			pr_err("%s:%d failed: invalid cmd len %u exp %zu\n",
-				__func__, __LINE__, cmd_len,
-				sizeof(uint32_t));
-			return -EINVAL;
-		}
-		vfe_dev->vfe_ub_size = *cfg_data;
-		break;
-	}
 	}
 	return 0;
 }
@@ -810,7 +720,7 @@ int msm_isp_proc_cmd(struct vfe_device *vfe_dev, void *arg)
 	}
 
 	for (i = 0; i < proc_cmd->num_cfg; i++)
-		rc = msm_isp_send_hw_cmd(vfe_dev, &reg_cfg_cmd[i],
+		msm_isp_send_hw_cmd(vfe_dev, &reg_cfg_cmd[i],
 			cfg_data, proc_cmd->cmd_len);
 
 	if (copy_to_user(proc_cmd->cfg_data,
@@ -892,12 +802,6 @@ int msm_isp_cal_word_per_line(uint32_t output_format,
 	case V4L2_PIX_FMT_NV61:
 		val = CAL_WORD(pixel_per_line, 1, 8);
 		break;
-	case V4L2_PIX_FMT_YUYV:
-	case V4L2_PIX_FMT_YVYU:
-	case V4L2_PIX_FMT_UYVY:
-	case V4L2_PIX_FMT_VYUY:
-		val = CAL_WORD(pixel_per_line, 2, 8);
-		break;
 		/*TD: Add more image format*/
 	default:
 		msm_isp_print_fourcc_error(__func__, output_format);
@@ -1071,125 +975,6 @@ static inline void msm_isp_update_error_info(struct vfe_device *vfe_dev,
 	vfe_dev->error_info.error_count++;
 }
 
-static inline void msm_isp_process_overflow_irq(
-	struct vfe_device *vfe_dev,
-	uint32_t *irq_status0, uint32_t *irq_status1)
-{
-	uint32_t overflow_mask;
-	uint32_t halt_restart_mask0, halt_restart_mask1;
-	/*Mask out all other irqs if recovery is started*/
-	if (atomic_read(&vfe_dev->error_info.overflow_state) !=
-		NO_OVERFLOW) {
-		vfe_dev->hw_info->vfe_ops.core_ops.
-			get_halt_restart_mask(&halt_restart_mask0,
-				&halt_restart_mask1);
-		*irq_status0 &= halt_restart_mask0;
-		*irq_status1 &= halt_restart_mask1;
-		return;
-	}
-
-	/*Check if any overflow bit is set*/
-	vfe_dev->hw_info->vfe_ops.core_ops.
-		get_overflow_mask(&overflow_mask);
-	overflow_mask &= *irq_status1;
-	if (overflow_mask) {
-		pr_warning("%s: Bus overflow detected: 0x%x\n",
-			__func__, overflow_mask);
-		atomic_set(&vfe_dev->error_info.overflow_state,
-			OVERFLOW_DETECTED);
-		pr_warning("%s: Start bus overflow recovery\n", __func__);
-		/*Store current IRQ mask*/
-		vfe_dev->hw_info->vfe_ops.core_ops.get_irq_mask(vfe_dev,
-			&vfe_dev->error_info.overflow_recover_irq_mask0,
-			&vfe_dev->error_info.overflow_recover_irq_mask1);
-		/*Stop CAMIF Immediately*/
-		vfe_dev->hw_info->vfe_ops.core_ops.
-			update_camif_state(vfe_dev, DISABLE_CAMIF_IMMEDIATELY);
-		/*Halt the hardware & Clear all other IRQ mask*/
-		vfe_dev->hw_info->vfe_ops.axi_ops.halt(vfe_dev, 0);
-		/*Update overflow state*/
-		atomic_set(&vfe_dev->error_info.overflow_state, HALT_REQUESTED);
-		*irq_status0 = 0;
-		*irq_status1 = 0;
-	}
-}
-
-static inline void msm_isp_reset_burst_count(
-	struct vfe_device *vfe_dev)
-{
-	int i;
-	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
-	struct msm_vfe_axi_stream *stream_info;
-	struct msm_vfe_axi_stream_request_cmd framedrop_info;
-	for (i = 0; i < MAX_NUM_STREAM; i++) {
-		stream_info = &axi_data->stream_info[i];
-		if (stream_info->state != ACTIVE)
-			continue;
-		if (stream_info->stream_type == BURST_STREAM &&
-			stream_info->num_burst_capture != 0) {
-			framedrop_info.burst_count =
-				stream_info->num_burst_capture;
-			framedrop_info.frame_skip_pattern =
-				stream_info->frame_skip_pattern;
-			framedrop_info.init_frame_drop = 0;
-			msm_isp_calculate_framedrop(&vfe_dev->axi_data,
-				&framedrop_info);
-		}
-	}
-}
-
-static void msm_isp_process_overflow_recovery(
-	struct vfe_device *vfe_dev,
-	uint32_t irq_status0, uint32_t irq_status1)
-{
-	uint32_t halt_restart_mask0, halt_restart_mask1;
-	vfe_dev->hw_info->vfe_ops.core_ops.
-		get_halt_restart_mask(&halt_restart_mask0,
-							  &halt_restart_mask1);
-	irq_status0 &= halt_restart_mask0;
-	irq_status1 &= halt_restart_mask1;
-	if (irq_status0 == 0 && irq_status1 == 0)
-		return;
-
-	switch (atomic_read(&vfe_dev->error_info.overflow_state)) {
-	case HALT_REQUESTED: {
-		pr_err("%s: Halt done, Restart Pending\n", __func__);
-		/*Reset the hardware*/
-		vfe_dev->hw_info->vfe_ops.core_ops.reset_hw(vfe_dev,
-			ISP_RST_SOFT, 0);
-		/*Update overflow state*/
-		atomic_set(&vfe_dev->error_info.overflow_state,
-				RESTART_REQUESTED);
-	}
-		break;
-	case RESTART_REQUESTED: {
-		pr_err("%s: Restart done, Resuming\n", __func__);
-		/*Reset the burst stream frame drop pattern, in the
-		 *case where bus overflow happens during the burstshot,
-		 *the framedrop pattern might be updated after reg update
-		 *to skip all the frames after the burst shot. The burst shot
-		 *might not be completed due to the overflow, so the framedrop
-		 *pattern need to change back to the original settings in order
-		 *to recovr from overflow.
-		 */
-		msm_isp_reset_burst_count(vfe_dev);
-		vfe_dev->hw_info->vfe_ops.axi_ops.
-			reload_wm(vfe_dev, 0xFFFFFFFF);
-		vfe_dev->hw_info->vfe_ops.core_ops.restore_irq_mask(vfe_dev);
-		vfe_dev->hw_info->vfe_ops.core_ops.reg_update(vfe_dev);
-		memset(&vfe_dev->error_info, 0, sizeof(vfe_dev->error_info));
-		atomic_set(&vfe_dev->error_info.overflow_state, NO_OVERFLOW);
-		vfe_dev->hw_info->vfe_ops.core_ops.
-			update_camif_state(vfe_dev, ENABLE_CAMIF);
-	}
-		break;
-	case NO_OVERFLOW:
-	case OVERFLOW_DETECTED:
-	default:
-		break;
-	}
-}
-
 irqreturn_t msm_isp_process_irq(int irq_num, void *data)
 {
 	unsigned long flags;
@@ -1200,27 +985,19 @@ irqreturn_t msm_isp_process_irq(int irq_num, void *data)
 
 	vfe_dev->hw_info->vfe_ops.irq_ops.
 		read_irq_status(vfe_dev, &irq_status0, &irq_status1);
-	if ((irq_status0 == 0) && (irq_status1 == 0)) {
-		pr_err_ratelimited("%s: irq_status0 & 1 are both 0\n",
-			__func__);
-		return IRQ_HANDLED;
-	}
-	msm_isp_process_overflow_irq(vfe_dev,
-		&irq_status0, &irq_status1);
 	vfe_dev->hw_info->vfe_ops.core_ops.
 		get_error_mask(&error_mask0, &error_mask1);
 	error_mask0 &= irq_status0;
 	error_mask1 &= irq_status1;
 	irq_status0 &= ~error_mask0;
 	irq_status1 &= ~error_mask1;
-	if (!vfe_dev->ignore_error &&
-		((error_mask0 != 0) || (error_mask1 != 0)))
+	if ((error_mask0 != 0) || (error_mask1 != 0))
 		msm_isp_update_error_info(vfe_dev, error_mask0, error_mask1);
 
 	if ((irq_status0 == 0) && (irq_status1 == 0) &&
 		(!((error_mask0 != 0) || (error_mask1 != 0)) &&
 		 vfe_dev->error_info.error_count == 1)) {
-		ISP_DBG("%s: error_mask0/1 & error_count are set!\n", __func__);
+		ISP_DBG("%s: irq_status0 & 1 are both 0!\n", __func__);
 		return IRQ_HANDLED;
 	}
 
@@ -1236,6 +1013,8 @@ irqreturn_t msm_isp_process_irq(int irq_num, void *data)
 	queue_cmd->vfeInterruptStatus0 = irq_status0;
 	queue_cmd->vfeInterruptStatus1 = irq_status1;
 	msm_isp_get_timestamp(&queue_cmd->ts);
+	if (vfe_dev->vt_enable)
+		msm_isp_get_vt_tstamp(vfe_dev, &queue_cmd->ts);
 	queue_cmd->cmd_used = 1;
 	vfe_dev->taskletq_idx =
 		(vfe_dev->taskletq_idx + 1) % MSM_VFE_TASKLETQ_SIZE;
@@ -1269,13 +1048,6 @@ void msm_isp_do_tasklet(unsigned long data)
 		irq_status1 = queue_cmd->vfeInterruptStatus1;
 		ts = queue_cmd->ts;
 		spin_unlock_irqrestore(&vfe_dev->tasklet_lock, flags);
-		if (atomic_read(&vfe_dev->error_info.overflow_state) !=
-			NO_OVERFLOW) {
-			pr_err_ratelimited("There is Overflow, kicking up recovery !!!!");
-			msm_isp_process_overflow_recovery(vfe_dev,
-				irq_status0, irq_status1);
-			continue;
-		}
 		ISP_DBG("%s: status0: 0x%x status1: 0x%x\n",
 			__func__, irq_status0, irq_status1);
 		irq_ops->process_reset_irq(vfe_dev,
@@ -1326,10 +1098,7 @@ int msm_isp_open_node(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 		return -EBUSY;
 	}
 
-	memset(&vfe_dev->error_info, 0, sizeof(vfe_dev->error_info));
-	atomic_set(&vfe_dev->error_info.overflow_state, NO_OVERFLOW);
-	rc = vfe_dev->hw_info->vfe_ops.core_ops.reset_hw(vfe_dev,
-		ISP_RST_HARD, 1);
+	rc = vfe_dev->hw_info->vfe_ops.core_ops.reset_hw(vfe_dev, ISP_RST_HARD);
 	if (rc <= 0) {
 		pr_err("%s: reset timeout\n", __func__);
 		mutex_unlock(&vfe_dev->core_mutex);
@@ -1360,29 +1129,20 @@ int msm_isp_open_node(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 	vfe_dev->vfe_open_cnt++;
 	vfe_dev->taskletq_idx = 0;
 	vfe_dev->vt_enable = 0;
+	vfe_dev->p_avtimer_lsw = NULL;
+	vfe_dev->p_avtimer_msw = NULL;
 	mutex_unlock(&vfe_dev->core_mutex);
 	mutex_unlock(&vfe_dev->realtime_mutex);
 	return 0;
 }
 
-#ifdef CONFIG_MSM_AVTIMER
-void msm_isp_end_avtimer(void)
-{
-       avcs_core_disable_power_collapse(0);
-}
-#else
-void msm_isp_end_avtimer(void)
-{
-       pr_err("AV Timer is not supported\n");
-}
-#endif
-
 int msm_isp_close_node(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 {
+	long rc;
 	struct vfe_device *vfe_dev = v4l2_get_subdevdata(sd);
+	ISP_DBG("%s\n", __func__);
 	mutex_lock(&vfe_dev->realtime_mutex);
 	mutex_lock(&vfe_dev->core_mutex);
-
 	if (vfe_dev->vfe_open_cnt == 0) {
 		pr_err("%s: Invalid close\n", __func__);
 		mutex_unlock(&vfe_dev->core_mutex);
@@ -1390,12 +1150,19 @@ int msm_isp_close_node(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 		return -ENODEV;
 	}
 
-	vfe_dev->hw_info->vfe_ops.axi_ops.halt(vfe_dev, 1);
+	rc = vfe_dev->hw_info->vfe_ops.axi_ops.halt(vfe_dev);
+	if (rc <= 0)
+		pr_err("%s: halt timeout rc=%ld\n", __func__, rc);
+
 	vfe_dev->buf_mgr->ops->buf_mgr_deinit(vfe_dev->buf_mgr);
 	vfe_dev->hw_info->vfe_ops.core_ops.release_hw(vfe_dev);
 	vfe_dev->vfe_open_cnt--;
 	if (vfe_dev->vt_enable) {
-                msm_isp_end_avtimer();
+		iounmap(vfe_dev->p_avtimer_lsw);
+		iounmap(vfe_dev->p_avtimer_msw);
+	#ifdef CONFIG_MSM_AVTIMER
+		avcs_core_disable_power_collapse(0);
+	#endif
 		vfe_dev->vt_enable = 0;
 	}
 	mutex_unlock(&vfe_dev->core_mutex);
diff --git a/drivers/media/platform/msm/camera_v2/ispif/msm_ispif.c b/drivers/media/platform/msm/camera_v2/ispif/msm_ispif.c
index 5a240a1..c344234 100755
--- a/drivers/media/platform/msm/camera_v2/ispif/msm_ispif.c
+++ b/drivers/media/platform/msm/camera_v2/ispif/msm_ispif.c
@@ -63,29 +63,10 @@ static void msm_ispif_io_dump_reg(struct ispif_device *ispif)
 static inline int msm_ispif_is_intf_valid(uint32_t csid_version,
 	uint8_t intf_type)
 {
-	return ((csid_version <= CSID_VERSION_V22 && intf_type != VFE0) ||
-		(intf_type >= VFE_MAX)) ? false : true;
+	return (csid_version <= CSID_VERSION_V22 && intf_type != VFE0) ?
+		false : true;
 }
 
-static struct msm_cam_clk_info ispif_8626_reset_clk_info[] = {
-	{"ispif_ahb_clk", NO_SET_RATE},
-	{"camss_top_ahb_clk", NO_SET_RATE},
-	{"csi0_ahb_clk", NO_SET_RATE},
-	{"csi0_src_clk", NO_SET_RATE},
-	{"csi0_phy_clk", NO_SET_RATE},
-	{"csi0_clk", NO_SET_RATE},
-	{"csi0_pix_clk", NO_SET_RATE},
-	{"csi0_rdi_clk", NO_SET_RATE},
-	{"csi1_ahb_clk", NO_SET_RATE},
-	{"csi1_src_clk", NO_SET_RATE},
-	{"csi1_phy_clk", NO_SET_RATE},
-	{"csi1_clk", NO_SET_RATE},
-	{"csi1_pix_clk", NO_SET_RATE},
-	{"csi1_rdi_clk", NO_SET_RATE},
-	{"camss_vfe_vfe_clk", NO_SET_RATE},
-	{"camss_csi_vfe_clk", NO_SET_RATE},
-};
-
 static struct msm_cam_clk_info ispif_8974_ahb_clk_info[] = {
 	{"ispif_ahb_clk", -1},
 };
@@ -120,26 +101,13 @@ static int msm_ispif_reset_hw(struct ispif_device *ispif)
 	int rc = 0;
 	long timeout = 0;
 	struct clk *reset_clk[ARRAY_SIZE(ispif_8974_reset_clk_info)];
-	struct clk *reset_clk1[ARRAY_SIZE(ispif_8626_reset_clk_info)];
-	ispif->clk_idx = 0;
 
 	rc = msm_cam_clk_enable(&ispif->pdev->dev,
 		ispif_8974_reset_clk_info, reset_clk,
 		ARRAY_SIZE(ispif_8974_reset_clk_info), 1);
 	if (rc < 0) {
-		rc = msm_cam_clk_enable(&ispif->pdev->dev,
-			ispif_8626_reset_clk_info, reset_clk1,
-			ARRAY_SIZE(ispif_8626_reset_clk_info), 1);
-		if (rc < 0) {
-			pr_err("%s: cannot enable clock, error = %d",
-				__func__, rc);
-		} else {
-			/* This is set if device is 8x26 */
-			ispif->clk_idx = 2;
-		}
-	} else {
-		/* This is set if device is 8974 */
-		ispif->clk_idx = 1;
+		pr_err("%s: cannot enable clock, error = %d",
+			__func__, rc);
 	}
 
 	init_completion(&ispif->reset_complete[VFE0]);
@@ -156,20 +124,11 @@ static int msm_ispif_reset_hw(struct ispif_device *ispif)
 	timeout = wait_for_completion_timeout(
 			&ispif->reset_complete[VFE0], msecs_to_jiffies(500));
 	CDBG("%s: VFE0 done\n", __func__);
-
 	if (timeout <= 0) {
 		pr_err("%s: VFE0 reset wait timeout\n", __func__);
-		rc = msm_cam_clk_enable(&ispif->pdev->dev,
+		msm_cam_clk_enable(&ispif->pdev->dev,
 			ispif_8974_reset_clk_info, reset_clk,
 			ARRAY_SIZE(ispif_8974_reset_clk_info), 0);
-		if (rc < 0) {
-			rc = msm_cam_clk_enable(&ispif->pdev->dev,
-				ispif_8626_reset_clk_info, reset_clk1,
-				ARRAY_SIZE(ispif_8626_reset_clk_info), 0);
-			if (rc < 0)
-				pr_err("%s: VFE0 reset wait timeout\n",
-					 __func__);
-		}
 		return -ETIMEDOUT;
 	}
 
@@ -187,26 +146,13 @@ static int msm_ispif_reset_hw(struct ispif_device *ispif)
 		}
 	}
 
-	if (ispif->clk_idx == 1) {
-		rc = msm_cam_clk_enable(&ispif->pdev->dev,
-			ispif_8974_reset_clk_info, reset_clk,
-			ARRAY_SIZE(ispif_8974_reset_clk_info), 0);
-		if (rc < 0) {
-			pr_err("%s: cannot disable clock, error = %d",
-				__func__, rc);
-		}
-	}
-
-	if (ispif->clk_idx == 2) {
-		rc = msm_cam_clk_enable(&ispif->pdev->dev,
-			ispif_8626_reset_clk_info, reset_clk1,
-			ARRAY_SIZE(ispif_8626_reset_clk_info), 0);
-			if (rc < 0) {
-				pr_err("%s: cannot disable clock, error = %d",
-					__func__, rc);
-		}
+	rc = msm_cam_clk_enable(&ispif->pdev->dev,
+		ispif_8974_reset_clk_info, reset_clk,
+		ARRAY_SIZE(ispif_8974_reset_clk_info), 0);
+	if (rc < 0) {
+		pr_err("%s: cannot disable clock, error = %d",
+			__func__, rc);
 	}
-
 	return rc;
 }
 
@@ -537,11 +483,6 @@ static int msm_ispif_config(struct ispif_device *ispif,
 
 	for (i = 0; i < params->num; i++) {
 		vfe_intf = params->entries[i].vfe_intf;
-		if (vfe_intf >= VFE_MAX) {
-			pr_err("%s: %d invalid i %d vfe_intf %d\n", __func__,
-				__LINE__, i, vfe_intf);
-			return -EINVAL;
-		}
 		if (!msm_ispif_is_intf_valid(ispif->csid_version,
 				vfe_intf)) {
 			pr_err("%s: invalid interface type\n", __func__);
@@ -633,18 +574,8 @@ static void msm_ispif_intf_cmd(struct ispif_device *ispif, uint32_t cmd_bits,
 	BUG_ON(!ispif);
 	BUG_ON(!params);
 
-	if (params->num > MAX_PARAM_ENTRIES) {
-		pr_err("%s: invalid param entries %d\n", __func__,
-			params->num);
-		return;
-	}
 	for (i = 0; i < params->num; i++) {
 		vfe_intf = params->entries[i].vfe_intf;
-		if (vfe_intf >= VFE_MAX) {
-			pr_err("%s: %d invalid i %d vfe_intf %d\n", __func__,
-				__LINE__, i, vfe_intf);
-			return;
-		}
 		if (!msm_ispif_is_intf_valid(ispif->csid_version, vfe_intf)) {
 			pr_err("%s: invalid interface type\n", __func__);
 			return;
@@ -950,8 +881,7 @@ static int msm_ispif_set_vfe_info(struct ispif_device *ispif,
 	struct msm_ispif_vfe_info *vfe_info)
 {
 	memcpy(&ispif->vfe_info, vfe_info, sizeof(struct msm_ispif_vfe_info));
-	if (ispif->vfe_info.num_vfe > ispif->hw_num_isps)
-		return -EINVAL;
+
 	return 0;
 }
 
@@ -1014,7 +944,11 @@ static int msm_ispif_init(struct ispif_device *ispif,
 		goto error_ahb;
 	}
 
-	msm_ispif_reset_hw(ispif);
+	if (of_device_is_compatible(ispif->pdev->dev.of_node,
+				    "qcom,ispif-v3.0")) {
+		/* currently HW reset is implemented for 8974 only */
+		msm_ispif_reset_hw(ispif);
+	}
 
 	rc = msm_ispif_reset(ispif);
 	if (rc == 0) {
@@ -1036,6 +970,11 @@ static void msm_ispif_release(struct ispif_device *ispif)
 {
 	BUG_ON(!ispif);
 
+	if (!ispif->base) {
+		pr_err("%s: ispif base is NULL\n", __func__);
+		return;
+	}
+
 	if (ispif->ispif_state != ISPIF_POWER_UP) {
 		pr_err("%s: ispif invalid state %d\n", __func__,
 			ispif->ispif_state);
diff --git a/drivers/media/platform/msm/camera_v2/ispif/msm_ispif.h b/drivers/media/platform/msm/camera_v2/ispif/msm_ispif.h
index 10dbfb6..45e7354 100644
--- a/drivers/media/platform/msm/camera_v2/ispif/msm_ispif.h
+++ b/drivers/media/platform/msm/camera_v2/ispif/msm_ispif.h
@@ -60,6 +60,5 @@ struct ispif_device {
 	struct clk *ahb_clk;
 	struct completion reset_complete[VFE_MAX];
 	uint32_t hw_num_isps;
-	uint32_t clk_idx;
 };
 #endif
diff --git a/drivers/media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c b/drivers/media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c
index 2f943a4..407b81f 100644
--- a/drivers/media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c
+++ b/drivers/media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c
@@ -347,12 +347,8 @@ int msm_jpeg_platform_release(struct resource *mem, void *base, int irq,
 		JPEG_DBG("%s:%d]", __func__, __LINE__);
 	}
 #endif
-	if (pgmn_dev->jpeg_bus_client) {
-		msm_bus_scale_client_update_request(
-			pgmn_dev->jpeg_bus_client, 0);
-		msm_bus_scale_unregister_client(pgmn_dev->jpeg_bus_client);
-	}
 
+	msm_bus_scale_unregister_client(pgmn_dev->jpeg_bus_client);
 	msm_cam_clk_enable(&pgmn_dev->pdev->dev, jpeg_8x_clk_info,
 	pgmn_dev->jpeg_clk, ARRAY_SIZE(jpeg_8x_clk_info), 0);
 	JPEG_DBG("%s:%d] clock disbale done", __func__, __LINE__);
diff --git a/drivers/media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c b/drivers/media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c
old mode 100644
new mode 100755
index a2f3c34..84e5538
--- a/drivers/media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c
+++ b/drivers/media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c
@@ -37,7 +37,6 @@
 #include <media/msmb_camera.h>
 #include <media/msmb_generic_buf_mgr.h>
 #include <media/msmb_pproc.h>
-#include <mach/clk-provider.h>
 #include "msm_cpp.h"
 #include "msm_isp_util.h"
 #include "msm_camera_io_util.h"
@@ -50,22 +49,8 @@
 #define CONFIG_MSM_CPP_DBG 0
 
 #define CPP_CMD_TIMEOUT_MS 300
-#define MSM_CPP_CORE_CLK_IDX 4
 #define MSM_MICRO_IFACE_CLK_IDX 7
 
-#define MSM_CPP_NOMINAL_CLOCK 266670000
-#define MSM_CPP_TURBO_CLOCK 320000000
-
-#define CPP_FW_VERSION_1_2_0	0x10020000
-#define CPP_FW_VERSION_1_4_0	0x10040000
-#define CPP_FW_VERSION_1_6_0	0x10060000
-#define CPP_FW_VERSION_1_8_0	0x10080000
-
-/* stripe information offsets in frame command */
-#define STRIPE_BASE_FW_1_2_0	130
-#define STRIPE_BASE_FW_1_4_0	140
-#define STRIPE_BASE_FW_1_6_0	464
-
 struct msm_cpp_timer_data_t {
 	struct cpp_device *cpp_dev;
 	struct msm_cpp_frame_info_t *processed_frame;
@@ -110,8 +95,6 @@ static int msm_cpp_buffer_ops(struct cpp_device *cpp_dev,
 	qcmd;			 \
 })
 
-#define MSM_CPP_MAX_TIMEOUT_TRIAL 3
-
 static void msm_queue_init(struct msm_device_queue *queue, const char *name)
 {
 	CPP_DBG("E\n");
@@ -149,25 +132,7 @@ static struct msm_cam_clk_info cpp_clk_info[] = {
 	{"cpp_bus_clk", -1},
 	{"micro_iface_clk", -1},
 };
-
-#define msm_cpp_empty_list(queue, member) { \
-	unsigned long flags; \
-	struct msm_queue_cmd *qcmd = NULL; \
-	if (queue) { \
-		spin_lock_irqsave(&queue->lock, flags); \
-		while (!list_empty(&queue->list)) { \
-			queue->len--; \
-			qcmd = list_first_entry(&queue->list, \
-				struct msm_queue_cmd, member); \
-			list_del_init(&qcmd->member); \
-			kfree(qcmd); \
-		} \
-		spin_unlock_irqrestore(&queue->lock, flags); \
-	} \
-}
-
-static int msm_cpp_notify_frame_done(struct cpp_device *cpp_dev,
-	uint32_t buff_mgr_ops, uint8_t put_buf);
+static int msm_cpp_notify_frame_done(struct cpp_device *cpp_dev);
 static void cpp_load_fw(struct cpp_device *cpp_dev, char *fw_name_bin);
 static void cpp_timer_callback(unsigned long data);
 
@@ -179,14 +144,6 @@ static void msm_cpp_write(u32 data, void __iomem *cpp_base)
 	writel_relaxed((data), cpp_base + MSM_CPP_MICRO_FIFO_RX_DATA);
 }
 
-static void msm_cpp_clear_timer(struct cpp_device *cpp_dev)
-{
-	atomic_set(&cpp_timer.used, 0);
-	del_timer(&cpp_timer.cpp_timer);
-	cpp_timer.data.processed_frame = NULL;
-	cpp_dev->timeout_trial_cnt = 0;
-}
-
 static uint32_t msm_cpp_read(void __iomem *cpp_base)
 {
 	uint32_t tmp, retry = 0;
@@ -299,8 +256,10 @@ static unsigned long msm_cpp_queue_buffer_info(struct cpp_device *cpp_dev,
 	return buff->map_info.phy_addr;
 
 QUEUE_BUFF_ERROR2:
-	ion_free(cpp_dev->client, buff->map_info.ion_handle);
+	ion_unmap_iommu(cpp_dev->client, buff->map_info.ion_handle,
+		cpp_dev->domain_num, 0);
 QUEUE_BUFF_ERROR1:
+	ion_free(cpp_dev->client, buff->map_info.ion_handle);
 	buff->map_info.ion_handle = NULL;
 	kzfree(buff);
 
@@ -610,6 +569,7 @@ void msm_cpp_do_tasklet(unsigned long data)
 	uint32_t tx_fifo[MSM_CPP_TX_FIFO_LEVEL];
 	struct cpp_device *cpp_dev = (struct cpp_device *) data;
 	struct msm_cpp_tasklet_queue_cmd *queue_cmd;
+	struct msm_cpp_timer_t *timer = NULL;
 
 	while (atomic_read(&cpp_dev->irq_cnt)) {
 		spin_lock_irqsave(&cpp_dev->tasklet_lock, flags);
@@ -634,22 +594,24 @@ void msm_cpp_do_tasklet(unsigned long data)
 			if (tx_fifo[i] == MSM_CPP_MSG_ID_CMD) {
 				cmd_len = tx_fifo[i+1];
 				msg_id = tx_fifo[i+2];
-				if ((msg_id == MSM_CPP_MSG_ID_FRAME_ACK)
-					&& (atomic_read(&cpp_timer.used))) {
+				if (msg_id == MSM_CPP_MSG_ID_FRAME_ACK) {
 					CPP_DBG("Frame done!!\n");
 					/* delete CPP timer */
 					CPP_DBG("delete timer.\n");
-					msm_cpp_clear_timer(cpp_dev);
-					msm_cpp_notify_frame_done(cpp_dev,
-						VIDIOC_MSM_BUF_MNGR_BUF_DONE, 0);
-				} else if ((msg_id ==
-					MSM_CPP_MSG_ID_FRAME_NACK)
-					&& (atomic_read(&cpp_timer.used))) {
+					timer = &cpp_timer;
+					atomic_set(&timer->used, 0);
+					del_timer(&timer->cpp_timer);
+					timer->data.processed_frame = NULL;
+					msm_cpp_notify_frame_done(cpp_dev);
+				} else if (msg_id ==
+					MSM_CPP_MSG_ID_FRAME_NACK) {
 					pr_err("NACK error from hw!!\n");
 					CPP_DBG("delete timer.\n");
-					msm_cpp_clear_timer(cpp_dev);
-					msm_cpp_notify_frame_done(cpp_dev,
-						VIDIOC_MSM_BUF_MNGR_PUT_BUF, 0);
+					timer = &cpp_timer;
+					atomic_set(&timer->used, 0);
+					del_timer(&timer->cpp_timer);
+					timer->data.processed_frame = NULL;
+					msm_cpp_notify_frame_done(cpp_dev);
 				}
 				i += cmd_len + 2;
 			}
@@ -657,27 +619,6 @@ void msm_cpp_do_tasklet(unsigned long data)
 	}
 }
 
-static void cpp_get_clk_freq_tbl(struct clk *clk, struct cpp_hw_info *hw_info)
-{
-	uint32_t count;
-	signed long freq_tbl_entry = 0;
-
-	if ((clk == NULL) || (hw_info == NULL) || (clk->ops == NULL) ||
-		(clk->ops->list_rate == NULL)) {
-		pr_err("Bad parameter\n");
-		return;
-	}
-
-	for (count = 0; count < MAX_FREQ_TBL; count++) {
-		freq_tbl_entry = clk->ops->list_rate(clk, count);
-		if (freq_tbl_entry >= 0)
-			hw_info->freq_tbl[count] = freq_tbl_entry;
-		else
-			break;
-	}
-
-	hw_info->freq_tbl_count = count;
-}
 static int cpp_init_hardware(struct cpp_device *cpp_dev)
 {
 	int rc = 0;
@@ -686,6 +627,7 @@ static int cpp_init_hardware(struct cpp_device *cpp_dev)
 		pr_err("%s: Bandwidth registration Failed!\n", __func__);
 		goto bus_scale_register_failed;
 	}
+	msm_isp_update_bandwidth(ISP_CPP, 981345600, 1066680000);
 
 	if (cpp_dev->fs_cpp == NULL) {
 		cpp_dev->fs_cpp =
@@ -790,15 +732,11 @@ static int cpp_init_hardware(struct cpp_device *cpp_dev)
 	pr_debug("CPP HW Version: 0x%x\n", cpp_dev->hw_info.cpp_hw_version);
 	cpp_dev->hw_info.cpp_hw_caps =
 		msm_camera_io_r(cpp_dev->cpp_hw_base + 0x4);
-	cpp_get_clk_freq_tbl(cpp_dev->cpp_clk[MSM_CPP_CORE_CLK_IDX],
-		&cpp_dev->hw_info);
 	pr_debug("CPP HW Caps: 0x%x\n", cpp_dev->hw_info.cpp_hw_caps);
 	msm_camera_io_w(0x1, cpp_dev->vbif_base + 0x4);
 	cpp_dev->taskletq_idx = 0;
 	atomic_set(&cpp_dev->irq_cnt, 0);
 	msm_cpp_create_buff_queue(cpp_dev, MSM_CPP_MAX_BUFF_QUEUE);
-	pr_debug("stream_cnt:%d\n", cpp_dev->stream_cnt);
-	cpp_dev->stream_cnt = 0;
 	if (cpp_dev->is_firmware_loaded == 1) {
 		disable_irq(cpp_dev->irq->start);
 		cpp_load_fw(cpp_dev, cpp_dev->fw_name_bin);
@@ -822,6 +760,7 @@ clk_failed:
 	regulator_disable(cpp_dev->fs_cpp);
 	regulator_put(cpp_dev->fs_cpp);
 fs_failed:
+	msm_isp_update_bandwidth(ISP_CPP, 0, 0);
 	msm_isp_deinit_bandwidth_mgr(ISP_CPP);
 bus_scale_register_failed:
 	return rc;
@@ -848,11 +787,7 @@ static void cpp_release_hardware(struct cpp_device *cpp_dev)
 	regulator_disable(cpp_dev->fs_cpp);
 	regulator_put(cpp_dev->fs_cpp);
 	cpp_dev->fs_cpp = NULL;
-	if (cpp_dev->stream_cnt > 0) {
-		pr_debug("error: stream count active\n");
-		msm_isp_update_bandwidth(ISP_CPP, 0, 0);
-	}
-	cpp_dev->stream_cnt = 0;
+	msm_isp_update_bandwidth(ISP_CPP, 0, 0);
 	msm_isp_deinit_bandwidth_mgr(ISP_CPP);
 }
 
@@ -931,8 +866,7 @@ static void cpp_load_fw(struct cpp_device *cpp_dev, char *fw_name_bin)
 	msm_cpp_poll(cpp_dev->base, MSM_CPP_MSG_ID_CMD);
 	msm_cpp_poll(cpp_dev->base, 0x2);
 	msm_cpp_poll(cpp_dev->base, MSM_CPP_MSG_ID_FW_VER);
-	cpp_dev->fw_version = msm_cpp_read(cpp_dev->base);
-	pr_info("CPP FW Version: 0x%08x\n", cpp_dev->fw_version);
+	pr_info("CPP FW Version: 0x%x\n", msm_cpp_read(cpp_dev->base));
 	msm_cpp_poll(cpp_dev->base, MSM_CPP_MSG_ID_TRAILER);
 
 	/*Disable MC clock*/
@@ -982,19 +916,9 @@ static int cpp_close_node(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 {
 	uint32_t i;
 	struct cpp_device *cpp_dev = v4l2_get_subdevdata(sd);
-	struct msm_device_queue *processing_q = NULL;
-	struct msm_device_queue *eventData_q = NULL;
-
-	if (!cpp_dev) {
-		pr_err("failed: cpp_dev %p\n", cpp_dev);
-		return -EINVAL;
-	}
 
 	mutex_lock(&cpp_dev->mutex);
 
-	processing_q = &cpp_dev->processing_q;
-	eventData_q = &cpp_dev->eventData_q;
-
 	if (cpp_dev->cpp_open_cnt == 0) {
 		mutex_unlock(&cpp_dev->mutex);
 		return 0;
@@ -1046,12 +970,9 @@ static int cpp_close_node(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 		pr_debug("DEBUG_R1: 0x%x\n",
 			msm_camera_io_r(cpp_dev->cpp_hw_base + 0x8C));
 		msm_camera_io_w(0x0, cpp_dev->base + MSM_CPP_MICRO_CLKEN_CTL);
-		msm_cpp_clear_timer(cpp_dev);
 		cpp_deinit_mem(cpp_dev);
 		iommu_detach_device(cpp_dev->domain, cpp_dev->iommu_ctx);
 		cpp_release_hardware(cpp_dev);
-		msm_cpp_empty_list(processing_q, list_frame);
-		msm_cpp_empty_list(eventData_q, list_eventdata);
 		cpp_dev->state = CPP_STATE_OFF;
 	}
 
@@ -1076,13 +997,12 @@ static int msm_cpp_buffer_ops(struct cpp_device *cpp_dev,
 	return rc;
 }
 
-static int msm_cpp_notify_frame_done(struct cpp_device *cpp_dev,
-	uint32_t buff_mgr_ops, uint8_t put_buf)
+static int msm_cpp_notify_frame_done(struct cpp_device *cpp_dev)
 {
 	struct v4l2_event v4l2_evt;
 	struct msm_queue_cmd *frame_qcmd = NULL;
 	struct msm_queue_cmd *event_qcmd = NULL;
-	struct msm_cpp_frame_info_t *processed_frame = NULL;
+	struct msm_cpp_frame_info_t *processed_frame;
 	struct msm_device_queue *queue = &cpp_dev->processing_q;
 	struct msm_buf_mngr_info buff_mgr_info;
 	int rc = 0;
@@ -1112,22 +1032,12 @@ static int msm_cpp_notify_frame_done(struct cpp_device *cpp_dev,
 			buff_mgr_info.timestamp = processed_frame->timestamp;
 			buff_mgr_info.index =
 				processed_frame->output_buffer_info[0].index;
-			if (put_buf) {
-				rc = msm_cpp_buffer_ops(cpp_dev,
-					buff_mgr_ops,
-					&buff_mgr_info);
-				if (rc < 0) {
-					pr_err("error putting buffer\n");
-					rc = -EINVAL;
-				}
-			} else {
-				rc = msm_cpp_buffer_ops(cpp_dev,
-					buff_mgr_ops,
-					&buff_mgr_info);
-				if (rc < 0) {
-					pr_err("error putting buffer\n");
-					rc = -EINVAL;
-				}
+			rc = msm_cpp_buffer_ops(cpp_dev,
+				VIDIOC_MSM_BUF_MNGR_BUF_DONE,
+				&buff_mgr_info);
+			if (rc < 0) {
+				pr_err("error putting buffer\n");
+				rc = -EINVAL;
 			}
 		}
 
@@ -1144,22 +1054,12 @@ static int msm_cpp_notify_frame_done(struct cpp_device *cpp_dev,
 			buff_mgr_info.timestamp = processed_frame->timestamp;
 			buff_mgr_info.index =
 				processed_frame->output_buffer_info[1].index;
-			if (put_buf) {
-				rc = msm_cpp_buffer_ops(cpp_dev,
-					buff_mgr_ops,
-					&buff_mgr_info);
-				if (rc < 0) {
-					pr_err("error putting buffer\n");
-					rc = -EINVAL;
-				}
-			} else {
-				rc = msm_cpp_buffer_ops(cpp_dev,
-					buff_mgr_ops,
+			rc = msm_cpp_buffer_ops(cpp_dev,
+				VIDIOC_MSM_BUF_MNGR_BUF_DONE,
 					&buff_mgr_info);
-				if (rc < 0) {
-					pr_err("error putting buffer\n");
-					rc = -EINVAL;
-				}
+			if (rc < 0) {
+				pr_err("error putting buffer\n");
+				rc = -EINVAL;
 			}
 		}
 		v4l2_evt.id = processed_frame->inst_id;
@@ -1188,12 +1088,14 @@ static int msm_cpp_dump_frame_cmd(uint32_t *cmd, int32_t len)
 
 static void msm_cpp_do_timeout_work(struct work_struct *work)
 {
+	int ret;
+	uint32_t i = 0;
+	struct msm_cpp_frame_info_t *this_frame = NULL;
 
 	pr_err("cpp_timer_callback called. (jiffies=%lu)\n",
 		jiffies);
-	if (!work || cpp_timer.data.cpp_dev->state != CPP_STATE_ACTIVE) {
-		pr_err("Invalid work:%p or state:%d\n", work,
-			cpp_timer.data.cpp_dev->state);
+	if (!work) {
+		pr_err("Invalid work:%p\n", work);
 		return;
 	}
 	if (!atomic_read(&cpp_timer.used)) {
@@ -1203,13 +1105,7 @@ static void msm_cpp_do_timeout_work(struct work_struct *work)
 
 	disable_irq(cpp_timer.data.cpp_dev->irq->start);
 	pr_err("Reloading firmware\n");
-	if (!atomic_read(&cpp_timer.used)) {
-		pr_err("Delayed trigger, IRQ serviced\n");
-		return;
-	}
-	atomic_set(&cpp_timer.used, 0);
-	cpp_load_fw(cpp_timer.data.cpp_dev,
-		cpp_timer.data.cpp_dev->fw_name_bin);
+	cpp_load_fw(cpp_timer.data.cpp_dev, NULL);
 	pr_err("Firmware loading done\n");
 	enable_irq(cpp_timer.data.cpp_dev->irq->start);
 	msm_camera_io_w_mb(0x8, cpp_timer.data.cpp_dev->base +
@@ -1217,16 +1113,29 @@ static void msm_cpp_do_timeout_work(struct work_struct *work)
 	msm_camera_io_w_mb(0xFFFF,
 		cpp_timer.data.cpp_dev->base +
 		MSM_CPP_MICRO_IRQGEN_CLR);
-	mutex_lock(&cpp_timer.data.cpp_dev->mutex);
-	msm_cpp_dump_frame_cmd(cpp_timer.data.processed_frame->cpp_cmd_msg,
-		cpp_timer.data.processed_frame->msg_len);
-	msm_cpp_notify_frame_done(cpp_timer.data.cpp_dev,
-		VIDIOC_MSM_BUF_MNGR_PUT_BUF, 1);
-	atomic_set(&cpp_timer.used, 0);
-	cpp_timer.data.processed_frame = NULL;
-	cpp_timer.data.cpp_dev->timeout_trial_cnt = 0;
-	mutex_unlock(&cpp_timer.data.cpp_dev->mutex);
-	pr_info("exit\n");
+
+	if (!atomic_read(&cpp_timer.used)) {
+		pr_err("Delayed trigger, IRQ serviced\n");
+		return;
+	}
+
+	this_frame = cpp_timer.data.processed_frame;
+	pr_err("Starting timer to fire in %d ms. (jiffies=%lu)\n",
+		CPP_CMD_TIMEOUT_MS, jiffies);
+	ret = mod_timer(&cpp_timer.cpp_timer,
+		jiffies + msecs_to_jiffies(CPP_CMD_TIMEOUT_MS));
+	if (ret)
+		pr_err("error in mod_timer\n");
+
+	pr_err("Rescheduling for identity=0x%x, frame_id=%03d\n",
+		this_frame->identity, this_frame->frame_id);
+	msm_cpp_write(0x6, cpp_timer.data.cpp_dev->base);
+	msm_cpp_dump_frame_cmd(this_frame->cpp_cmd_msg,
+		this_frame->msg_len);
+	for (i = 0; i < this_frame->msg_len; i++)
+		msm_cpp_write(this_frame->cpp_cmd_msg[i],
+			cpp_timer.data.cpp_dev->base);
+	return;
 }
 
 void cpp_timer_callback(unsigned long data)
@@ -1300,9 +1209,12 @@ static int msm_cpp_cfg(struct cpp_device *cpp_dev,
 	unsigned long in_phyaddr, out_phyaddr0, out_phyaddr1;
 	uint16_t num_stripes = 0;
 	struct msm_buf_mngr_info buff_mgr_info, dup_buff_mgr_info;
+	struct msm_cpp_frame_info_t *u_frame_info =
+		(struct msm_cpp_frame_info_t *)ioctl_ptr->ioctl_ptr;
 	int32_t status = 0;
+	uint8_t fw_version_1_2_x = 0;
 	int in_fd;
-	int32_t stripe_base = 0;
+
 	int i = 0;
 	if (!new_frame) {
 		pr_err("Insufficient memory. return\n");
@@ -1343,16 +1255,7 @@ static int msm_cpp_cfg(struct cpp_device *cpp_dev,
 	}
 
 	new_frame->cpp_cmd_msg = cpp_frame_msg;
-	if (cpp_frame_msg == NULL ||
-		(new_frame->msg_len < MSM_CPP_MIN_FRAME_LENGTH)) {
-		pr_err("%s %d Length is not correct or frame message is missing\n",
-			__func__, __LINE__);
-		return -EINVAL;
-	}
-	if (cpp_frame_msg[new_frame->msg_len - 1] != MSM_CPP_MSG_ID_TRAILER) {
-		pr_err("%s %d Invalid frame message\n", __func__, __LINE__);
-		return -EINVAL;
-	}
+
 	in_phyaddr = msm_cpp_fetch_buffer_info(cpp_dev,
 		&new_frame->input_buffer_info,
 		((new_frame->input_buffer_info.identity >> 16) & 0xFFFF),
@@ -1426,36 +1329,22 @@ static int msm_cpp_cfg(struct cpp_device *cpp_dev,
 		((cpp_frame_msg[12] >> 10) & 0x3FF) +
 		(cpp_frame_msg[12] & 0x3FF);
 
-	if ((cpp_dev->fw_version & 0xffff0000) ==
-		CPP_FW_VERSION_1_2_0) {
-		stripe_base = STRIPE_BASE_FW_1_2_0;
-	} else if ((cpp_dev->fw_version & 0xffff0000) ==
-		CPP_FW_VERSION_1_4_0) {
-		stripe_base = STRIPE_BASE_FW_1_4_0;
-	} else if ((cpp_dev->fw_version & 0xffff0000) ==
-		CPP_FW_VERSION_1_6_0) {
-		stripe_base = STRIPE_BASE_FW_1_6_0;
-	} else {
-		pr_err("invalid fw version %08x", cpp_dev->fw_version);
-	}
-
-	if ((stripe_base + num_stripes*27 + 1) != new_frame->msg_len) {
-		pr_err("Invalid frame message\n");
-		rc = -EINVAL;
-		goto ERROR3;
-	}
-
+	fw_version_1_2_x = 0;
+	if ((cpp_dev->hw_info.cpp_hw_version == CPP_HW_VERSION_1_1_0) ||
+		(cpp_dev->hw_info.cpp_hw_version == CPP_HW_VERSION_1_1_1) ||
+		(cpp_dev->hw_info.cpp_hw_version == CPP_HW_VERSION_2_0_0))
+		fw_version_1_2_x = 2;
 
 	for (i = 0; i < num_stripes; i++) {
-		cpp_frame_msg[stripe_base + 5 + i*27] +=
+		cpp_frame_msg[(133 + fw_version_1_2_x) + i * 27] +=
 			(uint32_t) in_phyaddr;
-		cpp_frame_msg[stripe_base + 11 + i * 27] +=
+		cpp_frame_msg[(139 + fw_version_1_2_x) + i * 27] +=
 			(uint32_t) out_phyaddr0;
-		cpp_frame_msg[stripe_base + 12 + i * 27] +=
+		cpp_frame_msg[(140 + fw_version_1_2_x) + i * 27] +=
 			(uint32_t) out_phyaddr1;
-		cpp_frame_msg[stripe_base + 13 + i * 27] +=
+		cpp_frame_msg[(141 + fw_version_1_2_x) + i * 27] +=
 			(uint32_t) out_phyaddr0;
-		cpp_frame_msg[stripe_base + 14 + i * 27] +=
+		cpp_frame_msg[(142 + fw_version_1_2_x) + i * 27] +=
 			(uint32_t) out_phyaddr1;
 	}
 
@@ -1477,7 +1366,7 @@ static int msm_cpp_cfg(struct cpp_device *cpp_dev,
 
 	ioctl_ptr->trans_code = rc;
 	status = rc;
-	rc = (copy_to_user((void __user *)new_frame->status, &status,
+	rc = (copy_to_user((void __user *)u_frame_info->status, &status,
 		sizeof(int32_t)) ? -EFAULT : 0);
 	if (rc) {
 		ERR_COPY_FROM_USER();
@@ -1493,35 +1382,15 @@ ERROR3:
 ERROR2:
 	kfree(cpp_frame_msg);
 ERROR1:
+	kfree(new_frame);
 	ioctl_ptr->trans_code = rc;
 	status = rc;
-	if (copy_to_user((void __user *)new_frame->status, &status,
+	if (copy_to_user((void __user *)u_frame_info->status, &status,
 		sizeof(int32_t)))
 		pr_err("error cannot copy error\n");
-	kfree(new_frame);
 	return rc;
 }
 
-void msm_cpp_clean_queue(struct cpp_device *cpp_dev)
-{
-	struct msm_queue_cmd *frame_qcmd = NULL;
-	struct msm_cpp_frame_info_t *processed_frame = NULL;
-	struct msm_device_queue *queue = NULL;
-
-	while (cpp_dev->processing_q.len) {
-		pr_info("queue len:%d\n", cpp_dev->processing_q.len);
-		queue = &cpp_dev->processing_q;
-		frame_qcmd = msm_dequeue(queue, list_frame);
-		if (frame_qcmd) {
-			processed_frame = frame_qcmd->command;
-			kfree(frame_qcmd);
-			if (processed_frame)
-				kfree(processed_frame->cpp_cmd_msg);
-			kfree(processed_frame);
-		}
-	}
-}
-
 long msm_cpp_subdev_ioctl(struct v4l2_subdev *sd,
 			unsigned int cmd, void *arg)
 {
@@ -1537,13 +1406,6 @@ long msm_cpp_subdev_ioctl(struct v4l2_subdev *sd,
 		pr_err("cpp_dev is null\n");
 		return -EINVAL;
 	}
-
-	if ((ioctl_ptr->ioctl_ptr == NULL) || (ioctl_ptr->len == 0)) {
-		pr_err("ioctl_ptr OR ioctl_ptr->len is NULL  %p %d\n",
-			ioctl_ptr, ioctl_ptr->len);
-		return -EINVAL;
-	}
-
 	mutex_lock(&cpp_dev->mutex);
 	CPP_DBG("E cmd: %d\n", cmd);
 	switch (cmd) {
@@ -1563,9 +1425,9 @@ long msm_cpp_subdev_ioctl(struct v4l2_subdev *sd,
 				kfree(cpp_dev->fw_name_bin);
 				cpp_dev->fw_name_bin = NULL;
 			}
-			if (ioctl_ptr->len >= MSM_CPP_MAX_FW_NAME_LEN) {
-				pr_err("Error: ioctl_ptr->len = %d\n",
-					 ioctl_ptr->len);
+			if ((ioctl_ptr->len == 0) ||
+				(ioctl_ptr->len > MSM_CPP_MAX_FW_NAME_LEN)) {
+				pr_err("ioctl_ptr->len is 0\n");
 				mutex_unlock(&cpp_dev->mutex);
 				return -EINVAL;
 			}
@@ -1578,9 +1440,7 @@ long msm_cpp_subdev_ioctl(struct v4l2_subdev *sd,
 				return -EINVAL;
 			}
 			if (ioctl_ptr->ioctl_ptr == NULL) {
-				pr_err("ioctl_ptr->ioctl_ptr is NULL\n");
-				kfree(cpp_dev->fw_name_bin);
-				cpp_dev->fw_name_bin = NULL;
+				pr_err("ioctl_ptr->ioctl_ptr=NULL\n");
 				mutex_unlock(&cpp_dev->mutex);
 				return -EINVAL;
 			}
@@ -1688,15 +1548,6 @@ long msm_cpp_subdev_ioctl(struct v4l2_subdev *sd,
 
 		kfree(k_stream_buff_info.buffer_info);
 		kfree(u_stream_buff_info);
-		if (cpp_dev->stream_cnt == 0) {
-			cpp_dev->state = CPP_STATE_ACTIVE;
-			msm_cpp_clear_timer(cpp_dev);
-			msm_cpp_clean_queue(cpp_dev);
-		}
-		if (cmd != VIDIOC_MSM_CPP_APPEND_STREAM_BUFF_INFO) {
-			cpp_dev->stream_cnt++;
-			pr_debug("stream_cnt:%d\n", cpp_dev->stream_cnt);
-		}
 		break;
 	}
 	case VIDIOC_MSM_CPP_DEQUEUE_STREAM_BUFF_INFO: {
@@ -1704,7 +1555,7 @@ long msm_cpp_subdev_ioctl(struct v4l2_subdev *sd,
 		struct msm_cpp_buff_queue_info_t *buff_queue_info;
 
 		if ((ioctl_ptr->len == 0) ||
-			(ioctl_ptr->len > sizeof(uint32_t)))
+		    (ioctl_ptr->len > sizeof(uint32_t)))
 			return -EINVAL;
 
 		rc = (copy_from_user(&identity,
@@ -1729,120 +1580,36 @@ long msm_cpp_subdev_ioctl(struct v4l2_subdev *sd,
 		rc = msm_cpp_free_buff_queue_entry(cpp_dev,
 			buff_queue_info->session_id,
 			buff_queue_info->stream_id);
-		if (cpp_dev->stream_cnt > 0) {
-			cpp_dev->stream_cnt--;
-			pr_debug("stream_cnt:%d\n", cpp_dev->stream_cnt);
-			if (cpp_dev->stream_cnt == 0) {
-				rc = msm_isp_update_bandwidth(ISP_CPP, 0, 0);
-				if (rc < 0)
-					pr_err("Bandwidth Reset Failed!\n");
-				cpp_dev->state = CPP_STATE_IDLE;
-				msm_cpp_clear_timer(cpp_dev);
-				msm_cpp_clean_queue(cpp_dev);
-			}
-		} else {
-			pr_err("error: stream count underflow %d\n",
-				cpp_dev->stream_cnt);
-		}
 		break;
 	}
 	case VIDIOC_MSM_CPP_GET_EVENTPAYLOAD: {
 		struct msm_device_queue *queue = &cpp_dev->eventData_q;
 		struct msm_queue_cmd *event_qcmd;
 		struct msm_cpp_frame_info_t *process_frame;
-
-		CPP_DBG("VIDIOC_MSM_CPP_GET_EVENTPAYLOAD\n");
 		event_qcmd = msm_dequeue(queue, list_eventdata);
-		if (!event_qcmd) {
-			pr_err("no queue cmd available");
-			mutex_unlock(&cpp_dev->mutex);
-			return -EINVAL;
-		}
-		process_frame = event_qcmd->command;
-		CPP_DBG("fid %d\n", process_frame->frame_id);
-		if (copy_to_user((void __user *)ioctl_ptr->ioctl_ptr,
+		if(event_qcmd) {
+			process_frame = event_qcmd->command;
+			CPP_DBG("fid %d\n", process_frame->frame_id);
+			if (copy_to_user((void __user *)ioctl_ptr->ioctl_ptr,
 					process_frame,
 					sizeof(struct msm_cpp_frame_info_t))) {
 						mutex_unlock(&cpp_dev->mutex);
-						kfree(process_frame->cpp_cmd_msg);
-						process_frame->cpp_cmd_msg = NULL;
-						kfree(process_frame);
-						process_frame = NULL;
-						kfree(event_qcmd);
-						event_qcmd = NULL;
 						return -EINVAL;
 			}
 
 			kfree(process_frame->cpp_cmd_msg);
-			process_frame->cpp_cmd_msg = NULL;
 			kfree(process_frame);
-			process_frame = NULL;
 			kfree(event_qcmd);
-			event_qcmd = NULL;
-			break;
-	}
-	case VIDIOC_MSM_CPP_SET_CLOCK: {
-		struct msm_cpp_clock_settings_t clock_settings;
-		unsigned long clock_rate = 0;
-		CPP_DBG("VIDIOC_MSM_CPP_SET_CLOCK\n");
-		if (ioctl_ptr->len == 0) {
-			pr_err("ioctl_ptr->len is 0\n");
-			mutex_unlock(&cpp_dev->mutex);
-			return -EINVAL;
-		}
-
-		if (ioctl_ptr->ioctl_ptr == NULL) {
-			pr_err("ioctl_ptr->ioctl_ptr is NULL\n");
-			mutex_unlock(&cpp_dev->mutex);
-			return -EINVAL;
-		}
-
-		if (ioctl_ptr->len != sizeof(struct msm_cpp_clock_settings_t)) {
-			pr_err("Not valid ioctl_ptr->len\n");
-			mutex_unlock(&cpp_dev->mutex);
-			return -EINVAL;
-		}
-
-		rc = (copy_from_user(&clock_settings,
-			(void __user *)ioctl_ptr->ioctl_ptr,
-			ioctl_ptr->len) ? -EFAULT : 0);
-		if (rc) {
-			ERR_COPY_FROM_USER();
-			mutex_unlock(&cpp_dev->mutex);
-			return -EINVAL;
-		}
-
-		if (clock_settings.clock_rate > 0) {
-			rc = msm_isp_update_bandwidth(ISP_CPP,
-				clock_settings.avg,
-				clock_settings.inst);
-			if (rc < 0) {
-				pr_err("Bandwidth Set Failed!\n");
-				msm_isp_update_bandwidth(ISP_CPP, 0, 0);
-				mutex_unlock(&cpp_dev->mutex);
-				return -EINVAL;
-			}
-			clock_rate = clk_round_rate(
-				cpp_dev->cpp_clk[MSM_CPP_CORE_CLK_IDX],
-				clock_settings.clock_rate);
-			if (clock_rate != clock_settings.clock_rate)
-				pr_err("clock rate differ from settings\n");
-			clk_set_rate(cpp_dev->cpp_clk[MSM_CPP_CORE_CLK_IDX],
-				clock_rate);
+		} else {
+			pr_err("Empty command list\n");
+			return -EFAULT;
 		}
 		break;
 	}
 	case MSM_SD_SHUTDOWN: {
 		mutex_unlock(&cpp_dev->mutex);
-		pr_info("shutdown cpp node. open cnt:%d\n",
-			cpp_dev->cpp_open_cnt);
-
-		if (atomic_read(&cpp_timer.used))
-			pr_info("Timer state not cleared\n");
-
 		while (cpp_dev->cpp_open_cnt != 0)
 			cpp_close_node(sd, NULL);
-		mutex_lock(&cpp_dev->mutex);
 		rc = 0;
 		break;
 	}
diff --git a/drivers/media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h b/drivers/media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h
index 3556879..cf22e6c 100644
--- a/drivers/media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h
+++ b/drivers/media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h
@@ -79,7 +79,7 @@
 #define MSM_CPP_START_ADDRESS		0x0
 #define MSM_CPP_END_ADDRESS			0x3F00
 
-#define MSM_CPP_POLL_RETRIES		200
+#define MSM_CPP_POLL_RETRIES		20
 #define MSM_CPP_TASKLETQ_SIZE		16
 #define MSM_CPP_TX_FIFO_LEVEL		16
 
@@ -161,13 +161,6 @@ struct msm_cpp_work_t {
 	struct cpp_device *cpp_dev;
 };
 
-struct msm_cpp_clock_settings_t {
-	long clock_rate;
-	uint64_t avg;
-	uint64_t inst;
-};
-
-
 struct cpp_device {
 	struct platform_device *pdev;
 	struct msm_sd_subdev msm_sd;
@@ -189,9 +182,6 @@ struct cpp_device {
 	char *fw_name_bin;
 	struct workqueue_struct *timer_wq;
 	struct msm_cpp_work_t *work;
-	uint32_t fw_version;
-	uint8_t stream_cnt;
-	uint8_t timeout_trial_cnt;
 
 	int domain_num;
 	struct iommu_domain *domain;
diff --git a/drivers/media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c b/drivers/media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c
index 717771d..8d14363 100644
--- a/drivers/media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c
+++ b/drivers/media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c
@@ -1380,8 +1380,6 @@ static long msm_vpe_subdev_ioctl(struct v4l2_subdev *sd,
 				process_frame,
 				sizeof(struct msm_vpe_frame_info_t))) {
 					mutex_unlock(&vpe_dev->mutex);
-					kfree(process_frame);
-					kfree(event_qcmd);
 					return -EINVAL;
 		}
 
diff --git a/drivers/media/platform/msm/camera_v2/sensor/Makefile b/drivers/media/platform/msm/camera_v2/sensor/Makefile
index 6365592..9a5341c 100755
--- a/drivers/media/platform/msm/camera_v2/sensor/Makefile
+++ b/drivers/media/platform/msm/camera_v2/sensor/Makefile
@@ -5,13 +5,25 @@ ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
 ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/cci
 obj-$(CONFIG_MSMB_CAMERA) += cci/ io/ csiphy/ csid/ actuator/ flash/ eeprom/
 obj-$(CONFIG_MSM_CAMERA_SENSOR) += msm_sensor_init.o msm_sensor_driver.o msm_sensor.o
+obj-$(CONFIG_S5K3L1YX) += s5k3l1yx.o
 obj-$(CONFIG_IMX135_Z5S) += imx135_z5s.o 
 obj-$(CONFIG_IMX135_Z5S_069) += imx135_z5s_069.o 
+obj-$(CONFIG_IMX214_APP) += imx214_app.o imx214_app_otp.o
+obj-$(CONFIG_IMX135_GBAO) += imx135_gbao.o
 obj-$(CONFIG_IMX134) += imx134.o
+obj-$(CONFIG_IMX135_069) += imx135_069.o
+obj-$(CONFIG_IMX135_GBAO_LC898122) += imx135_gbao_lc898122.o
+obj-$(CONFIG_IMX214) += imx214.o
+obj-$(CONFIG_IMX214_LC898122) += imx214_lc898122.o
+obj-$(CONFIG_IMX214_OIS_SHARP) += imx214_ois_sharp.o
+obj-$(CONFIG_OV5648_Z7MINI) += ov5648_z7mini.o
+obj-$(CONFIG_T4K35) += t4k35.o  t4k35_otp.o
+obj-$(CONFIG_IMX135_FRONT) += imx135_front.o
 obj-$(CONFIG_OV8825) += ov8825.o
 obj-$(CONFIG_OV8865) += ov8865.o
 obj-$(CONFIG_s5k4e1) += s5k4e1.o
 obj-$(CONFIG_OV12830) += ov12830.o
+obj-$(CONFIG_OV2720) += ov2720.o
 obj-$(CONFIG_OV9724) += ov9724.o
 obj-$(CONFIG_HI256) += hi256.o
 obj-$(CONFIG_OV5648) += ov5648.o
diff --git a/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c b/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c
index ee27e21..188d2df 100755
--- a/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -28,16 +28,18 @@ DEFINE_MSM_MUTEX(msm_actuator_mutex);
 #endif
 
 /*ZTEMT: Jinghongliang Add for Read AF OTP  ---Start*/
-#ifdef CONFIG_IMX135_Z5S
+#if defined(CONFIG_IMX135_GBAO) || defined(CONFIG_IMX135_Z5S)
 extern unsigned short af_start_value;
 extern unsigned short af_infinity_value;
 extern unsigned short af_macro_value;
 #endif
 /*ZTEMT: Jinghongliang Add for Read AF OTP  ---End*/
 
-static int32_t msm_actuator_power_up(struct msm_actuator_ctrl_t *a_ctrl);
-static int32_t msm_actuator_power_down(struct msm_actuator_ctrl_t *a_ctrl);
-
+#ifdef CONFIG_IMX214_APP
+void RegRead8byte(uint16_t reg_addr, struct msm_actuator_ctrl_t *a_ctrl);
+int32_t Regwrite8byte(uint16_t reg_addr, unsigned long write_data1_32, \
+	unsigned long write_data2_32, struct msm_actuator_ctrl_t *a_ctrl);
+#endif
 static struct msm_actuator msm_vcm_actuator_table;
 static struct msm_actuator msm_piezo_actuator_table;
 
@@ -78,7 +80,6 @@ static int32_t msm_actuator_piezo_set_default_focus(
 	CDBG("Exit\n");
 	return rc;
 }
-
 static void msm_actuator_parse_i2c_params(struct msm_actuator_ctrl_t *a_ctrl,
 	int16_t next_lens_position, uint32_t hw_params, uint16_t delay)
 {
@@ -105,7 +106,7 @@ static void msm_actuator_parse_i2c_params(struct msm_actuator_ctrl_t *a_ctrl,
 				i2c_byte1 = write_arr[i].reg_addr;
 				i2c_byte2 = value;
 				if (size != (i+1)) {
-#ifdef CONFIG_IMX135_Z5S
+#if defined(CONFIG_IMX135_GBAO) || defined(CONFIG_IMX135_Z5S)
 					if (a_ctrl->i2c_client.cci_client->sid == 0x1c >> 1) {
 						i2c_byte2 = (value & 0x0300) >> 8;
 					} else {
@@ -125,7 +126,7 @@ static void msm_actuator_parse_i2c_params(struct msm_actuator_ctrl_t *a_ctrl,
 					a_ctrl->i2c_tbl_index++;
 					i++;
 					i2c_byte1 = write_arr[i].reg_addr;
-#ifdef CONFIG_IMX135_Z5S
+#if defined(CONFIG_IMX135_GBAO) || defined(CONFIG_IMX135_Z5S)
 					if (a_ctrl->i2c_client.cci_client->sid == 0x1c >> 1) {
 						i2c_byte2 = value & 0xFF;
 					} else {
@@ -136,9 +137,33 @@ static void msm_actuator_parse_i2c_params(struct msm_actuator_ctrl_t *a_ctrl,
 #endif
 				}
 			} else {
+#ifdef CONFIG_IMX135_GBAO_LC898122
+			if (a_ctrl->i2c_client.cci_client->sid == 0x48 >> 1) 
+			{
+                            i2c_byte1 = ((value & 0x0700) >> 8)|0x04;
+				i2c_byte2 = value & 0xFF;
+				//printk("af i2c_byte1 = 0x%x\n",i2c_byte1);
+			       //printk("af i2c_byte2 = 0x%x\n",i2c_byte2);
+			}else{
+				i2c_byte1 = (value & 0xFF00) >> 8;
+				i2c_byte2 = value & 0xFF;
+			}
+#elif defined(CONFIG_IMX214_LC898122) || defined(CONFIG_IMX214_OIS_SHARP)
+                     if (a_ctrl->i2c_client.cci_client->sid == 0x48 >> 1) 
+			{
+                            i2c_byte1 = ((value & 0x0700) >> 8)|0x04;
+				i2c_byte2 = value & 0xFF;
+				//printk("  af i2c_byte1 = 0x%x\n",i2c_byte1);
+			       //printk("  af i2c_byte2 = 0x%x\n",i2c_byte2);
+			}else{
 				i2c_byte1 = (value & 0xFF00) >> 8;
 				i2c_byte2 = value & 0xFF;
 			}
+#else
+                            i2c_byte1 = (value & 0xFF00) >> 8;
+				i2c_byte2 = value & 0xFF;
+#endif
+			}
 		} else {
 			i2c_byte1 = write_arr[i].reg_addr;
 			i2c_byte2 = (hw_dword & write_arr[i].hw_mask) >>
@@ -154,61 +179,60 @@ static void msm_actuator_parse_i2c_params(struct msm_actuator_ctrl_t *a_ctrl,
 }
 
 static int32_t msm_actuator_init_focus(struct msm_actuator_ctrl_t *a_ctrl,
-	uint16_t size, struct reg_settings_t *settings)
+	uint16_t size, enum msm_actuator_data_type type,
+	struct reg_settings_t *settings)
 {
 	int32_t rc = -EFAULT;
 	int32_t i = 0;
-	enum msm_camera_i2c_reg_addr_type save_addr_type;
 	CDBG("Enter\n");
-
-	save_addr_type = a_ctrl->i2c_client.addr_type;
-	for (i = 0; i < size; i++) {
-
-		switch (settings[i].addr_type) {
-		case MSM_ACTUATOR_BYTE_ADDR:
-			a_ctrl->i2c_client.addr_type = MSM_CAMERA_I2C_BYTE_ADDR;
-			break;
-		case MSM_ACTUATOR_WORD_ADDR:
-			a_ctrl->i2c_client.addr_type = MSM_CAMERA_I2C_WORD_ADDR;
-			break;
-		default:
-			pr_err("Unsupport addr type: %d\n",
-				settings[i].addr_type);
-			break;
+#if defined(CONFIG_IMX214_APP) || defined(CONFIG_IMX135_GBAO_LC898122)|| defined(CONFIG_IMX214_OIS_SHARP)|| defined(CONFIG_IMX214_LC898122)
+	if ((a_ctrl->i2c_client.cci_client->sid != 0x32 >> 1) && (a_ctrl->i2c_client.cci_client->sid != 0x48 >> 1)) {
+		for (i = 0; i < size; i++) {
+			switch (type) {
+			case MSM_ACTUATOR_BYTE_DATA:
+				rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_write(
+					&a_ctrl->i2c_client,
+					settings[i].reg_addr,
+					settings[i].reg_data, MSM_CAMERA_I2C_BYTE_DATA);
+				break;
+			case MSM_ACTUATOR_WORD_DATA:
+				rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_write(
+					&a_ctrl->i2c_client,
+					settings[i].reg_addr,
+					settings[i].reg_data, MSM_CAMERA_I2C_WORD_DATA);
+				break;
+			default:
+				pr_err("Unsupport data type: %d\n", type);
+				break;
+			}
+			if (rc < 0)
+				break;
 		}
-
-		switch (settings[i].i2c_operation) {
-		case MSM_ACT_WRITE:
+	}
+#else
+	for (i = 0; i < size; i++) {
+		switch (type) {
+		case MSM_ACTUATOR_BYTE_DATA:
 			rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_write(
 				&a_ctrl->i2c_client,
 				settings[i].reg_addr,
-				settings[i].reg_data,
-				settings[i].data_type);
+				settings[i].reg_data, MSM_CAMERA_I2C_BYTE_DATA);
 			break;
-		case MSM_ACT_POLL:
-			rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_poll(
+		case MSM_ACTUATOR_WORD_DATA:
+			rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_write(
 				&a_ctrl->i2c_client,
 				settings[i].reg_addr,
-				settings[i].reg_data,
-				settings[i].data_type);
+				settings[i].reg_data, MSM_CAMERA_I2C_WORD_DATA);
 			break;
 		default:
-			pr_err("Unsupport i2c_operation: %d\n",
-				settings[i].i2c_operation);
+			pr_err("Unsupport data type: %d\n", type);
 			break;
-
-		if (0 != settings[i].delay)
-			msleep(settings[i].delay);
-
+		}
 		if (rc < 0)
 			break;
-		}
 	}
-
+#endif
 	a_ctrl->curr_step_pos = 0;
-	/* recover register addr_type after the init
-	settings are written  */
-	a_ctrl->i2c_client.addr_type = save_addr_type;
 	CDBG("Exit\n");
 	return rc;
 }
@@ -242,6 +266,7 @@ static void msm_actuator_write_focus(
 	}
 
 	if (curr_lens_pos != code_boundary) {
+		//pr_err("%s[jun] positon=%d,\n",__func__,code_boundary);
 		a_ctrl->func_tbl->actuator_parse_i2c_params(a_ctrl,
 			code_boundary, damping_params->hw_params, wait_time);
 	}
@@ -266,11 +291,8 @@ static int32_t msm_actuator_piezo_move_focus(
 		return -EFAULT;
 	}
 
-	if (num_steps <= 0 || num_steps > MAX_NUMBER_OF_STEPS) {
-		pr_err("num_steps out of range = %d\n",
-			num_steps);
-		return -EFAULT;
-	}
+	if (num_steps == 0)
+		return rc;
 
 	a_ctrl->i2c_tbl_index = 0;
 	a_ctrl->func_tbl->actuator_parse_i2c_params(a_ctrl,
@@ -308,11 +330,7 @@ static int32_t msm_actuator_move_focus(
 	int dir = move_params->dir;
 	int32_t num_steps = move_params->num_steps;
 	struct msm_camera_i2c_reg_setting reg_setting;
-
-	if (a_ctrl->step_position_table == NULL) {
-		pr_err("Step Position Table is NULL");
-		return -EFAULT;
-	}
+       
 	curr_lens_pos = a_ctrl->step_position_table[a_ctrl->curr_step_pos];
 	move_params->curr_lens_pos = curr_lens_pos;
 
@@ -329,21 +347,6 @@ static int32_t msm_actuator_move_focus(
 	if (dest_step_pos == a_ctrl->curr_step_pos)
 		return rc;
 
-	if ((sign_dir > MSM_ACTUATOR_MOVE_SIGNED_NEAR) ||
-		(sign_dir < MSM_ACTUATOR_MOVE_SIGNED_FAR)) {
-		pr_err("Invalid sign_dir = %d\n", sign_dir);
-		return -EFAULT;
-	}
-	if ((dir > MOVE_FAR) || (dir < MOVE_NEAR)) {
-		pr_err("Invalid direction = %d\n", dir);
-		return -EFAULT;
-	}
-	if (dest_step_pos > a_ctrl->total_steps) {
-		pr_err("Step pos greater than total steps = %d\n",
-		dest_step_pos);
-		return -EFAULT;
-	}
-	curr_lens_pos = a_ctrl->step_position_table[a_ctrl->curr_step_pos];
 	a_ctrl->i2c_tbl_index = 0;
 	CDBG("curr_step_pos =%d dest_step_pos =%d curr_lens_pos=%d\n",
 		a_ctrl->curr_step_pos, dest_step_pos, curr_lens_pos);
@@ -385,12 +388,24 @@ static int32_t msm_actuator_move_focus(
 	reg_setting.reg_setting = a_ctrl->i2c_reg_tbl;
 	reg_setting.data_type = a_ctrl->i2c_data_type;
 	reg_setting.size = a_ctrl->i2c_tbl_index;
+#if defined(CONFIG_IMX135_GBAO_LC898122) || defined(CONFIG_IMX214_APP)|| defined(CONFIG_IMX214_OIS_SHARP)|| defined(CONFIG_IMX214_LC898122)
+	if ((a_ctrl->i2c_client.cci_client->sid != 0x48 >> 1) && (a_ctrl->i2c_client.cci_client->sid != 0x32 >> 1)) {
+		rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_write_table_w_microdelay(
+			&a_ctrl->i2c_client, &reg_setting);
+
+		if (rc < 0) {
+			pr_err("i2c write error:%d\n", rc);
+			return rc;
+		}
+	}
+#else
 	rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_write_table_w_microdelay(
 		&a_ctrl->i2c_client, &reg_setting);
 	if (rc < 0) {
 		pr_err("i2c write error:%d\n", rc);
 		return rc;
 	}
+#endif
 	a_ctrl->i2c_tbl_index = 0;
 	CDBG("Exit\n");
 
@@ -406,31 +421,23 @@ static int32_t msm_actuator_init_step_table(struct msm_actuator_ctrl_t *a_ctrl,
 	uint16_t step_boundary = 0;
 	uint32_t max_code_size = 1;
 	uint16_t data_size = set_info->actuator_params.data_size;
+	//int16_t i;
 	CDBG("Enter\n");
 
 	for (; data_size > 0; data_size--)
 		max_code_size *= 2;
 
-	if ((a_ctrl->actuator_state == ACTUATOR_POWER_UP) &&
-		(a_ctrl->step_position_table != NULL))
-		kfree(a_ctrl->step_position_table);
-
+	kfree(a_ctrl->step_position_table);
 	a_ctrl->step_position_table = NULL;
 
-	if (set_info->af_tuning_params.total_steps
-		>  MAX_ACTUATOR_AF_TOTAL_STEPS) {
-		pr_err("Max actuator totalsteps exceeded = %d\n",
-		set_info->af_tuning_params.total_steps);
-		return -EFAULT;
-	}
 	/* Fill step position table */
 	a_ctrl->step_position_table =
-		kzalloc(sizeof(uint16_t) *
+		kmalloc(sizeof(uint16_t) *
 		(set_info->af_tuning_params.total_steps + 1), GFP_KERNEL);
 
 	if (a_ctrl->step_position_table == NULL)
 		return -ENOMEM;
-#ifdef CONFIG_IMX135_Z5S
+#if defined(CONFIG_IMX135_GBAO) || defined(CONFIG_IMX135_GBAO_LC898122) || defined(CONFIG_IMX135_Z5S)|| defined(CONFIG_IMX214_OIS_SHARP) 
 	if ((set_info->actuator_params.i2c_addr != 0x1c) && (set_info->actuator_params.i2c_addr != 0x48)) {
 		cur_code = set_info->af_tuning_params.initial_code;
 		a_ctrl->step_position_table[step_index++] = cur_code;
@@ -526,55 +533,14 @@ static int32_t msm_actuator_set_default_focus(
 	return rc;
 }
 
-static int32_t msm_actuator_vreg_control(struct msm_actuator_ctrl_t *a_ctrl,
-							int config)
-{
-	int rc = 0, i, cnt;
-	struct msm_actuator_vreg *vreg_cfg;
-
-	vreg_cfg = &a_ctrl->vreg_cfg;
-	cnt = vreg_cfg->num_vreg;
-	if (!cnt)
-		return 0;
-
-	if (cnt >= MSM_ACTUATOT_MAX_VREGS) {
-		pr_err("%s failed %d cnt %d\n", __func__, __LINE__, cnt);
-		return -EINVAL;
-	}
-
-	for (i = 0; i < cnt; i++) {
-		rc = msm_camera_config_single_vreg(&(a_ctrl->pdev->dev),
-			&vreg_cfg->cam_vreg[i],
-			(struct regulator **)&vreg_cfg->data[i],
-			config);
-	}
-	return rc;
-}
-
 static int32_t msm_actuator_power_down(struct msm_actuator_ctrl_t *a_ctrl)
 {
 	int32_t rc = 0;
 	CDBG("Enter\n");
-	if (a_ctrl->actuator_state != ACTUATOR_POWER_DOWN) {
-		if (a_ctrl->vcm_enable) {
-			rc = gpio_direction_output(a_ctrl->vcm_pwd, 0);
-			if (!rc)
-				gpio_free(a_ctrl->vcm_pwd);
-		}
-
-		if (a_ctrl->step_position_table != NULL)
-			kfree(a_ctrl->step_position_table);
-		a_ctrl->step_position_table = NULL;
-		if (a_ctrl->i2c_reg_tbl != NULL)
-			kfree(a_ctrl->i2c_reg_tbl);
-		a_ctrl->i2c_reg_tbl = NULL;
-		a_ctrl->i2c_tbl_index = 0;
-		a_ctrl->actuator_state = ACTUATOR_POWER_DOWN;
-	}
-	rc = msm_actuator_vreg_control(a_ctrl, 0);
-	if (rc < 0) {
-		pr_err("%s failed %d\n", __func__, __LINE__);
-		return rc;
+	if (a_ctrl->vcm_enable) {
+		rc = gpio_direction_output(a_ctrl->vcm_pwd, 0);
+		if (!rc)
+			gpio_free(a_ctrl->vcm_pwd);
 	}
 
 	kfree(a_ctrl->step_position_table);
@@ -597,12 +563,8 @@ static int32_t msm_actuator_set_position(
 	uint32_t hw_params = 0;
 	struct msm_camera_i2c_reg_setting reg_setting;
 	CDBG("%s Enter %d\n", __func__, __LINE__);
-	if (set_pos->number_of_steps <= 0 ||
-		set_pos->number_of_steps > MAX_NUMBER_OF_STEPS) {
-		pr_err("num_steps out of range = %d\n",
-			set_pos->number_of_steps);
-		return -EFAULT;
-	}
+	if (set_pos->number_of_steps  == 0)
+		return rc;
 
 	a_ctrl->i2c_tbl_index = 0;
 	for (index = 0; index < set_pos->number_of_steps; index++) {
@@ -647,19 +609,12 @@ static int32_t msm_actuator_init(struct msm_actuator_ctrl_t *a_ctrl,
 		pr_err("Actuator function table not found\n");
 		return rc;
 	}
-	if (set_info->af_tuning_params.total_steps
-		>  MAX_ACTUATOR_AF_TOTAL_STEPS) {
-		pr_err("Max actuator totalsteps exceeded = %d\n",
-		set_info->af_tuning_params.total_steps);
-		return -EFAULT;
-	}
-	if (set_info->af_tuning_params.region_size
-		> MAX_ACTUATOR_REGION) {
+
+	a_ctrl->region_size = set_info->af_tuning_params.region_size;
+	if (a_ctrl->region_size > MAX_ACTUATOR_REGION) {
 		pr_err("MAX_ACTUATOR_REGION is exceeded.\n");
 		return -EFAULT;
 	}
-
-	a_ctrl->region_size = set_info->af_tuning_params.region_size;
 	a_ctrl->pwd_step = set_info->af_tuning_params.pwd_step;
 	a_ctrl->total_steps = set_info->af_tuning_params.total_steps;
 
@@ -691,16 +646,13 @@ static int32_t msm_actuator_init(struct msm_actuator_ctrl_t *a_ctrl,
 		return -EFAULT;
 	}
 
-	if ((a_ctrl->actuator_state == ACTUATOR_POWER_UP) &&
-		(a_ctrl->i2c_reg_tbl != NULL))
-		kfree(a_ctrl->i2c_reg_tbl);
+	kfree(a_ctrl->i2c_reg_tbl);
 
-	a_ctrl->i2c_reg_tbl = NULL;
 	a_ctrl->i2c_reg_tbl =
-		kzalloc(sizeof(struct msm_camera_i2c_reg_array) *
+		kmalloc(sizeof(struct msm_camera_i2c_reg_array) *
 		(set_info->af_tuning_params.total_steps + 1), GFP_KERNEL);
 	if (!a_ctrl->i2c_reg_tbl) {
-		pr_err("kzalloc fail\n");
+		pr_err("kmalloc fail\n");
 		return -ENOMEM;
 	}
 
@@ -712,11 +664,9 @@ static int32_t msm_actuator_init(struct msm_actuator_ctrl_t *a_ctrl,
 		return -EFAULT;
 	}
 
-	if (set_info->actuator_params.init_setting_size &&
-		set_info->actuator_params.init_setting_size
-		<= MAX_ACTUATOR_REG_TBL_SIZE) {
+	if (set_info->actuator_params.init_setting_size) {
 		if (a_ctrl->func_tbl->actuator_init_focus) {
-			init_settings = kzalloc(sizeof(struct reg_settings_t) *
+			init_settings = kmalloc(sizeof(struct reg_settings_t) *
 				(set_info->actuator_params.init_setting_size),
 				GFP_KERNEL);
 			if (init_settings == NULL) {
@@ -735,9 +685,9 @@ static int32_t msm_actuator_init(struct msm_actuator_ctrl_t *a_ctrl,
 			}
 			rc = a_ctrl->func_tbl->actuator_init_focus(a_ctrl,
 				set_info->actuator_params.init_setting_size,
+				a_ctrl->i2c_data_type,
 				init_settings);
 			kfree(init_settings);
-			init_settings = NULL;
 			if (rc < 0) {
 				kfree(a_ctrl->i2c_reg_tbl);
 				pr_err("Error actuator_init_focus\n");
@@ -799,13 +749,6 @@ static int32_t msm_actuator_config(struct msm_actuator_ctrl_t *a_ctrl,
 		if (rc < 0)
 			pr_err("actuator_set_position failed %d\n", rc);
 		break;
-
-	case CFG_ACTUATOR_POWERUP:
-		rc = msm_actuator_power_up(a_ctrl);
-		if (rc < 0)
-			pr_err("Failed actuator power up%d\n", rc);
-		break;
-
 	default:
 		break;
 	}
@@ -842,7 +785,6 @@ static struct msm_camera_i2c_fn_t msm_sensor_cci_func_tbl = {
 	.i2c_write_table_w_microdelay =
 		msm_camera_cci_i2c_write_table_w_microdelay,
 	.i2c_util = msm_sensor_cci_i2c_util,
-	.i2c_poll =  msm_camera_cci_i2c_poll,
 };
 
 static struct msm_camera_i2c_fn_t msm_sensor_qup_func_tbl = {
@@ -853,7 +795,6 @@ static struct msm_camera_i2c_fn_t msm_sensor_qup_func_tbl = {
 	.i2c_write_seq_table = msm_camera_qup_i2c_write_seq_table,
 	.i2c_write_table_w_microdelay =
 		msm_camera_qup_i2c_write_table_w_microdelay,
-	.i2c_poll = msm_camera_qup_i2c_poll,
 };
 
 static int msm_actuator_open(struct v4l2_subdev *sd,
@@ -929,13 +870,6 @@ static int32_t msm_actuator_power_up(struct msm_actuator_ctrl_t *a_ctrl)
 
 	CDBG("vcm info: %x %x\n", a_ctrl->vcm_pwd,
 		a_ctrl->vcm_enable);
-
-	rc = msm_actuator_vreg_control(a_ctrl, 1);
-	if (rc < 0) {
-		pr_err("%s failed %d\n", __func__, __LINE__);
-		return rc;
-	}
-
 	if (a_ctrl->vcm_enable) {
 		rc = gpio_request(a_ctrl->vcm_pwd, "msm_actuator");
 		if (!rc) {
@@ -943,6 +877,19 @@ static int32_t msm_actuator_power_up(struct msm_actuator_ctrl_t *a_ctrl)
 			gpio_direction_output(a_ctrl->vcm_pwd, 1);
 		}
 	}
+	#ifdef CONFIG_IMX135_GBAO_LC898122
+	
+	if (a_ctrl->i2c_client.cci_client->sid == 0x48 >> 1) {	
+		msm_ois_init_cci_lc898122();
+	}
+	#endif
+	
+	#ifdef CONFIG_IMX214_OIS_SHARP
+	if (a_ctrl->i2c_client.cci_client->sid == 0x48 >> 1) {	
+		msm_ois_init_cci_lc898122_sharp();
+	}
+	#endif
+
 	CDBG("Exit\n");
 	return rc;
 }
@@ -975,7 +922,6 @@ static const struct i2c_device_id msm_actuator_i2c_id[] = {
 	{"qcom,actuator", (kernel_ulong_t)NULL},
 	{ }
 };
-
 static int32_t msm_actuator_i2c_probe(struct i2c_client *client,
 	const struct i2c_device_id *id)
 {
@@ -1039,7 +985,6 @@ static int32_t msm_actuator_i2c_probe(struct i2c_client *client,
 	act_ctrl_t->msm_sd.sd.entity.group_id = MSM_CAMERA_SUBDEV_ACTUATOR;
 	act_ctrl_t->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x2;
 	msm_sd_register(&act_ctrl_t->msm_sd);
-	act_ctrl_t->actuator_state = ACTUATOR_POWER_DOWN;
 	pr_info("msm_actuator_i2c_probe: succeeded\n");
 	CDBG("Exit\n");
 
@@ -1052,7 +997,6 @@ static int32_t msm_actuator_platform_probe(struct platform_device *pdev)
 	int32_t rc = 0;
 	struct msm_camera_cci_client *cci_client = NULL;
 	struct msm_actuator_ctrl_t *msm_actuator_t = NULL;
-	struct msm_actuator_vreg *vreg_cfg;
 	CDBG("Enter\n");
 
 	if (!pdev->dev.of_node) {
@@ -1070,7 +1014,6 @@ static int32_t msm_actuator_platform_probe(struct platform_device *pdev)
 		&pdev->id);
 	CDBG("cell-index %d, rc %d\n", pdev->id, rc);
 	if (rc < 0) {
-		kfree(msm_actuator_t);
 		pr_err("failed rc %d\n", rc);
 		return rc;
 	}
@@ -1079,23 +1022,10 @@ static int32_t msm_actuator_platform_probe(struct platform_device *pdev)
 		&msm_actuator_t->cci_master);
 	CDBG("qcom,cci-master %d, rc %d\n", msm_actuator_t->cci_master, rc);
 	if (rc < 0) {
-		kfree(msm_actuator_t);
 		pr_err("failed rc %d\n", rc);
 		return rc;
 	}
 
-	if (of_find_property((&pdev->dev)->of_node,
-			"qcom,cam-vreg-name", NULL)) {
-		vreg_cfg = &msm_actuator_t->vreg_cfg;
-		rc = msm_camera_get_dt_vreg_data((&pdev->dev)->of_node,
-			&vreg_cfg->cam_vreg, &vreg_cfg->num_vreg);
-		if (rc < 0) {
-			kfree(msm_actuator_t);
-			pr_err("failed rc %d\n", rc);
-			return rc;
-		}
-	}
-
 	msm_actuator_t->act_v4l2_subdev_ops = &msm_actuator_subdev_ops;
 	msm_actuator_t->actuator_mutex = &msm_actuator_mutex;
 	msm_actuator_t->cam_name = pdev->id;
@@ -1108,8 +1038,6 @@ static int32_t msm_actuator_platform_probe(struct platform_device *pdev)
 	msm_actuator_t->i2c_client.cci_client = kzalloc(sizeof(
 		struct msm_camera_cci_client), GFP_KERNEL);
 	if (!msm_actuator_t->i2c_client.cci_client) {
-		kfree(msm_actuator_t->vreg_cfg.cam_vreg);
-		kfree(msm_actuator_t);
 		pr_err("failed no memory\n");
 		return -ENOMEM;
 	}
@@ -1129,7 +1057,6 @@ static int32_t msm_actuator_platform_probe(struct platform_device *pdev)
 	msm_actuator_t->msm_sd.sd.entity.group_id = MSM_CAMERA_SUBDEV_ACTUATOR;
 	msm_actuator_t->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x2;
 	msm_sd_register(&msm_actuator_t->msm_sd);
-	msm_actuator_t->actuator_state = ACTUATOR_POWER_DOWN;
 	CDBG("Exit\n");
 	return rc;
 }
diff --git a/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h b/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h
index 2ae1900..7ec9a49 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h
+++ b/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -18,22 +18,12 @@
 #include <media/v4l2-subdev.h>
 #include <media/msmb_camera.h>
 #include "msm_camera_i2c.h"
-#include "msm_camera_dt_util.h"
-#include "msm_camera_io_util.h"
-
 
 #define DEFINE_MSM_MUTEX(mutexname) \
 	static struct mutex mutexname = __MUTEX_INITIALIZER(mutexname)
 
-#define	MSM_ACTUATOT_MAX_VREGS (10)
-
 struct msm_actuator_ctrl_t;
 
-enum msm_actuator_state_t {
-	ACTUATOR_POWER_DOWN,
-	ACTUATOR_POWER_UP,
-};
-
 struct msm_actuator_func_tbl {
 	int32_t (*actuator_i2c_write_b_af)(struct msm_actuator_ctrl_t *,
 			uint8_t,
@@ -41,7 +31,7 @@ struct msm_actuator_func_tbl {
 	int32_t (*actuator_init_step_table)(struct msm_actuator_ctrl_t *,
 		struct msm_actuator_set_info_t *);
 	int32_t (*actuator_init_focus)(struct msm_actuator_ctrl_t *,
-		uint16_t, struct reg_settings_t *);
+		uint16_t, enum msm_actuator_data_type, struct reg_settings_t *);
 	int32_t (*actuator_set_default_focus) (struct msm_actuator_ctrl_t *,
 			struct msm_actuator_move_params_t *);
 	int32_t (*actuator_move_focus) (struct msm_actuator_ctrl_t *,
@@ -62,12 +52,6 @@ struct msm_actuator {
 	struct msm_actuator_func_tbl func_tbl;
 };
 
-struct msm_actuator_vreg {
-	struct camera_vreg_t *cam_vreg;
-	void *data[MSM_ACTUATOT_MAX_VREGS];
-	int num_vreg;
-};
-
 struct msm_actuator_ctrl_t {
 	struct i2c_driver *i2c_driver;
 	struct platform_driver *pdriver;
@@ -99,8 +83,6 @@ struct msm_actuator_ctrl_t {
 	uint16_t i2c_tbl_index;
 	enum cci_i2c_master_t cci_master;
 	uint32_t subdev_id;
-	struct msm_actuator_vreg vreg_cfg;
-	enum msm_actuator_state_t actuator_state;
 };
 
 #endif
diff --git a/drivers/media/platform/msm/camera_v2/sensor/cci/msm_cci.c b/drivers/media/platform/msm/camera_v2/sensor/cci/msm_cci.c
index e5d82fd..26b7200 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/cci/msm_cci.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/cci/msm_cci.c
@@ -98,7 +98,7 @@ static void msm_cci_flush_queue(struct cci_device *cci_dev,
 	int32_t rc = 0;
 
 	msm_camera_io_w(1 << master, cci_dev->base + CCI_HALT_REQ_ADDR);
-	rc = wait_for_completion_timeout(
+	rc = wait_for_completion_interruptible_timeout(
 		&cci_dev->cci_master_info[master].reset_complete, CCI_TIMEOUT);
 	if (rc < 0) {
 		pr_err("%s:%d wait failed\n", __func__, __LINE__);
@@ -117,7 +117,7 @@ static void msm_cci_flush_queue(struct cci_device *cci_dev,
 				cci_dev->base + CCI_RESET_CMD_ADDR);
 
 		/* wait for reset done irq */
-		rc = wait_for_completion_timeout(
+		rc = wait_for_completion_interruptible_timeout(
 			&cci_dev->cci_master_info[master].reset_complete,
 			CCI_TIMEOUT);
 		if (rc <= 0)
@@ -158,10 +158,10 @@ static int32_t msm_cci_validate_queue(struct cci_device *cci_dev,
 		msm_camera_io_w(reg_val, cci_dev->base + CCI_QUEUE_START_ADDR);
 		CDBG("%s line %d wait_for_completion_interruptible\n",
 			__func__, __LINE__);
-		rc = wait_for_completion_timeout(&cci_dev->
+		rc = wait_for_completion_interruptible_timeout(&cci_dev->
 			cci_master_info[master].reset_complete, CCI_TIMEOUT);
 		if (rc <= 0) {
-			pr_err("%s: wait_for_completion_timeout %d\n",
+			pr_err("%s: wait_for_completion_interruptible_timeout %d\n",
 				 __func__, __LINE__);
 			if (rc == 0)
 				rc = -ETIMEDOUT;
@@ -211,23 +211,14 @@ static int32_t msm_cci_data_queue(struct cci_device *cci_dev,
 		pr_err("%s failed line %d\n", __func__, __LINE__);
 		return -EINVAL;
 	}
-
-	reg_addr = i2c_cmd->reg_addr;
+	/* assume total size within the max queue */
 	while (cmd_size) {
-		CDBG("%s cmd_size %d addr 0x%x data 0x%x\n", __func__,
+		CDBG("%s cmd_size %d addr 0x%x data 0x%x", __func__,
 			cmd_size, i2c_cmd->reg_addr, i2c_cmd->reg_data);
 		delay = i2c_cmd->delay;
 		data[i++] = CCI_I2C_WRITE_CMD;
-
-		/* in case of multiple command
-		* MSM_CCI_I2C_WRITE : address is not continuous, so update
-		*			address for a new packet.
-		* MSM_CCI_I2C_WRITE_SEQ : address is continuous, need to keep
-		*			the incremented address for a
-		*			new packet */
-		if (c_ctrl->cmd == MSM_CCI_I2C_WRITE)
+		if (i2c_cmd->reg_addr)
 			reg_addr = i2c_cmd->reg_addr;
-
 		/* either byte or word addr */
 		if (i2c_msg->addr_type == MSM_CAMERA_I2C_BYTE_ADDR)
 			data[i++] = reg_addr;
@@ -251,10 +242,7 @@ static int32_t msm_cci_data_queue(struct cci_device *cci_dev,
 					break;
 			}
 			i2c_cmd++;
-			--cmd_size;
-		} while ((c_ctrl->cmd == MSM_CCI_I2C_WRITE_SEQ) &&
-				(cmd_size > 0) && (i <= 10));
-
+		} while (--cmd_size && !i2c_cmd->reg_addr && (i <= 10));
 		data[0] |= ((i-1) << 4);
 		len = ((i-1)/4) + 1;
 		rc = msm_cci_validate_queue(cci_dev, len, master, queue);
@@ -413,12 +401,12 @@ static int32_t msm_cci_i2c_read(struct v4l2_subdev *sd,
 
 	val = 1 << ((master * 2) + queue);
 	msm_camera_io_w(val, cci_dev->base + CCI_QUEUE_START_ADDR);
-	CDBG("%s:%d E wait_for_completion_timeout\n", __func__,
+	CDBG("%s:%d E wait_for_completion_interruptible_timeout\n", __func__,
 		__LINE__);
-	rc = wait_for_completion_timeout(&cci_dev->
+	rc = wait_for_completion_interruptible_timeout(&cci_dev->
 		cci_master_info[master].reset_complete, CCI_TIMEOUT);
 	if (rc <= 0) {
-		pr_err("%s: wait_for_completion_timeout %d\n",
+		pr_err("%s: wait_for_completion_interruptible_timeout %d\n",
 			 __func__, __LINE__);
 		if (rc == 0)
 			rc = -ETIMEDOUT;
@@ -427,7 +415,7 @@ static int32_t msm_cci_i2c_read(struct v4l2_subdev *sd,
 	} else {
 		rc = 0;
 	}
-	CDBG("%s:%d E wait_for_completion_timeout\n", __func__,
+	CDBG("%s:%d E wait_for_completion_interruptible_timeout\n", __func__,
 		__LINE__);
 
 	read_words = msm_camera_io_r(cci_dev->base +
@@ -620,10 +608,10 @@ static int32_t msm_cci_i2c_write(struct v4l2_subdev *sd,
 
 	CDBG("%s:%d E wait_for_completion_interruptible\n",
 		__func__, __LINE__);
-	rc = wait_for_completion_timeout(&cci_dev->
+	rc = wait_for_completion_interruptible_timeout(&cci_dev->
 		cci_master_info[master].reset_complete, CCI_TIMEOUT);
 	if (rc <= 0) {
-		pr_err("%s: wait_for_completion_timeout %d\n",
+		pr_err("%s: wait_for_completion_interruptible_timeout %d\n",
 			 __func__, __LINE__);
 		if (rc == 0)
 			rc = -ETIMEDOUT;
@@ -691,7 +679,7 @@ static int32_t msm_cci_init(struct v4l2_subdev *sd,
 				msm_camera_io_w(CCI_M1_RESET_RMSK,
 					cci_dev->base + CCI_RESET_CMD_ADDR);
 			/* wait for reset done irq */
-			rc = wait_for_completion_timeout(
+			rc = wait_for_completion_interruptible_timeout(
 				&cci_dev->cci_master_info[master].
 				reset_complete,
 				CCI_TIMEOUT);
@@ -725,11 +713,11 @@ static int32_t msm_cci_init(struct v4l2_subdev *sd,
 	cci_dev->cci_master_info[MASTER_0].reset_pending = TRUE;
 	msm_camera_io_w(CCI_RESET_CMD_RMSK, cci_dev->base + CCI_RESET_CMD_ADDR);
 	msm_camera_io_w(0x1, cci_dev->base + CCI_RESET_CMD_ADDR);
-	rc = wait_for_completion_timeout(
+	rc = wait_for_completion_interruptible_timeout(
 		&cci_dev->cci_master_info[MASTER_0].reset_complete,
 		CCI_TIMEOUT);
 	if (rc <= 0) {
-		pr_err("%s: wait_for_completion_timeout %d\n",
+		pr_err("%s: wait_for_completion_interruptible_timeout %d\n",
 			 __func__, __LINE__);
 		if (rc == 0)
 			rc = -ETIMEDOUT;
@@ -803,7 +791,6 @@ static int32_t msm_cci_config(struct v4l2_subdev *sd,
 		rc = msm_cci_i2c_read_bytes(sd, cci_ctrl);
 		break;
 	case MSM_CCI_I2C_WRITE:
-	case MSM_CCI_I2C_WRITE_SEQ:
 		rc = msm_cci_i2c_write(sd, cci_ctrl);
 		break;
 	case MSM_CCI_GPIO_WRITE:
@@ -1115,7 +1102,7 @@ static int __devinit msm_cci_probe(struct platform_device *pdev)
 {
 	struct cci_device *new_cci_dev;
 	int rc = 0;
-	CDBG("%s: pdev %p device id = %d\n", __func__, pdev, pdev->id);
+	pr_err("%s: pdev %p device id = %d\n", __func__, pdev, pdev->id);
 	new_cci_dev = kzalloc(sizeof(struct cci_device), GFP_KERNEL);
 	if (!new_cci_dev) {
 		CDBG("%s: no enough memory\n", __func__);
diff --git a/drivers/media/platform/msm/camera_v2/sensor/cci/msm_cci.h b/drivers/media/platform/msm/camera_v2/sensor/cci/msm_cci.h
index 283bd28..6067f26 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/cci/msm_cci.h
+++ b/drivers/media/platform/msm/camera_v2/sensor/cci/msm_cci.h
@@ -27,8 +27,6 @@
 #define TRUE  1
 #define FALSE 0
 
-#define CCI_NUM_CLK_MAX	16
-
 enum cci_i2c_queue_t {
 	QUEUE_0,
 	QUEUE_1,
@@ -53,7 +51,6 @@ enum msm_cci_cmd_type {
 	MSM_CCI_SET_SYNC_CID,
 	MSM_CCI_I2C_READ,
 	MSM_CCI_I2C_WRITE,
-	MSM_CCI_I2C_WRITE_SEQ,
 	MSM_CCI_GPIO_WRITE,
 };
 
@@ -131,7 +128,7 @@ struct cci_device {
 	uint8_t ref_count;
 	enum msm_cci_state_t cci_state;
 
-	struct clk *cci_clk[CCI_NUM_CLK_MAX];
+	struct clk *cci_clk[5];
 	struct msm_camera_cci_i2c_queue_info
 		cci_i2c_queue_info[NUM_MASTERS][NUM_QUEUES];
 	struct msm_camera_cci_master_info cci_master_info[NUM_MASTERS];
diff --git a/drivers/media/platform/msm/camera_v2/sensor/csid/msm_csid.c b/drivers/media/platform/msm/camera_v2/sensor/csid/msm_csid.c
index 53a5ed3..981c210 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/csid/msm_csid.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/csid/msm_csid.c
@@ -50,13 +50,6 @@ static int msm_csid_cid_lut(
 		return -EINVAL;
 	}
 	for (i = 0; i < csid_lut_params->num_cid && i < 16; i++) {
-		if (csid_lut_params->vc_cfg[i]->cid >=
-			csid_lut_params->num_cid ||
-			csid_lut_params->vc_cfg[i]->cid < 0) {
-				pr_err("%s: cid outside range %d\n",
-					__func__, csid_lut_params->vc_cfg[i]->cid);
-				return -EINVAL;
-		}
 		CDBG("%s lut params num_cid = %d, cid = %d, dt = %x, df = %d\n",
 			__func__,
 			csid_lut_params->num_cid,
@@ -102,7 +95,7 @@ static void msm_csid_set_debug_reg(void __iomem *csidbase,
 static void msm_csid_reset(struct csid_device *csid_dev)
 {
 	msm_camera_io_w(CSID_RST_STB_ALL, csid_dev->base + CSID_RST_CMD_ADDR);
-	wait_for_completion(&csid_dev->reset_complete);
+	wait_for_completion_interruptible(&csid_dev->reset_complete);
 	return;
 }
 
@@ -464,8 +457,9 @@ static long msm_csid_cmd(struct csid_device *csid_dev, void *arg)
 			break;
 		}
 		for (i = 0; i < csid_params.lut_params.num_cid; i++) {
-			vc_cfg = kzalloc(sizeof(struct msm_camera_csid_vc_cfg),
-			    GFP_KERNEL);
+			vc_cfg = kzalloc(csid_params.lut_params.num_cid *
+				sizeof(struct msm_camera_csid_vc_cfg),
+				GFP_KERNEL);
 			if (!vc_cfg) {
 				pr_err("%s: %d failed\n", __func__, __LINE__);
 				for (i--; i >= 0; i--)
@@ -475,7 +469,8 @@ static long msm_csid_cmd(struct csid_device *csid_dev, void *arg)
 			}
 			if (copy_from_user(vc_cfg,
 				(void *)csid_params.lut_params.vc_cfg[i],
-				sizeof(struct msm_camera_csid_vc_cfg))) {
+				(csid_params.lut_params.num_cid *
+				sizeof(struct msm_camera_csid_vc_cfg)))) {
 				pr_err("%s: %d failed\n", __func__, __LINE__);
 				kfree(vc_cfg);
 				for (i--; i >= 0; i--)
diff --git a/drivers/media/platform/msm/camera_v2/sensor/csid/msm_csid.h b/drivers/media/platform/msm/camera_v2/sensor/csid/msm_csid.h
index 0a17d93..fd4db79 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/csid/msm_csid.h
+++ b/drivers/media/platform/msm/camera_v2/sensor/csid/msm_csid.h
@@ -20,8 +20,6 @@
 #include <media/msm_cam_sensor.h>
 #include "msm_sd.h"
 
-#define CSID_NUM_CLK_MAX  16
-
 enum msm_csid_state_t {
 	CSID_POWER_UP,
 	CSID_POWER_DOWN,
@@ -40,7 +38,7 @@ struct csid_device {
 	uint32_t hw_version;
 	enum msm_csid_state_t csid_state;
 
-	struct clk *csid_clk[CSID_NUM_CLK_MAX];
+	struct clk *csid_clk[11];
 };
 
 #define VIDIOC_MSM_CSID_RELEASE \
diff --git a/drivers/media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.h b/drivers/media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.h
index 35b9ca1..a11b958 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.h
+++ b/drivers/media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.h
@@ -21,7 +21,6 @@
 #include "msm_sd.h"
 
 #define MAX_CSIPHY 3
-#define CSIPHY_NUM_CLK_MAX  16
 
 enum msm_csiphy_state_t {
 	CSIPHY_POWER_UP,
@@ -42,7 +41,8 @@ struct csiphy_device {
 	struct mutex mutex;
 	uint32_t hw_version;
 	enum msm_csiphy_state_t csiphy_state;
-	struct clk *csiphy_clk[CSIPHY_NUM_CLK_MAX];
+
+	struct clk *csiphy_clk[4];
 	uint8_t ref_count;
 	uint16_t lane_mask[MAX_CSIPHY];
 };
diff --git a/drivers/media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c b/drivers/media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c
index 059780d..7649a40 100755
--- a/drivers/media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c
@@ -131,6 +131,12 @@ static int eeprom_config_read_cal_data(struct msm_eeprom_ctrl_t *e_ctrl,
 		e_ctrl->cal_data.mapdata,
 		cdata->cfg.read_data.num_bytes);
 
+	/* should only be called once.  free kernel resource */
+	if (!rc) {
+		kfree(e_ctrl->cal_data.mapdata);
+		kfree(e_ctrl->cal_data.map);
+		memset(&e_ctrl->cal_data, 0, sizeof(e_ctrl->cal_data));
+	}
 	return rc;
 }
 
diff --git a/drivers/media/platform/msm/camera_v2/sensor/gc0339.c b/drivers/media/platform/msm/camera_v2/sensor/gc0339.c
index f275d1e..36f3b61 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/gc0339.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/gc0339.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013-2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -518,12 +518,6 @@ int32_t gc0339_config(struct msm_sensor_ctrl_t *s_ctrl,
 			|| !conf_array.size)
 			break;
 
-		if (conf_array.size > I2C_USER_REG_DATA_MAX) {
-			pr_err("%s:%d failed\n", __func__, __LINE__);
-			rc = -EFAULT;
-			break;
-		}
-
 		reg_setting = kzalloc(conf_array.size *
 			(sizeof(struct msm_camera_i2c_reg_array)), GFP_KERNEL);
 		if (!reg_setting) {
@@ -558,12 +552,6 @@ int32_t gc0339_config(struct msm_sensor_ctrl_t *s_ctrl,
 			break;
 		}
 
-		if (conf_array.size > I2C_USER_REG_DATA_MAX) {
-			pr_err("%s:%d failed\n", __func__, __LINE__);
-			rc = -EFAULT;
-			break;
-		}
-
 		reg_setting = kzalloc(conf_array.size *
 			(sizeof(struct msm_camera_i2c_seq_reg_array)),
 			GFP_KERNEL);
diff --git a/drivers/media/platform/msm/camera_v2/sensor/hi256.c b/drivers/media/platform/msm/camera_v2/sensor/hi256.c
index 1cec087..c7e0cb5 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/hi256.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/hi256.c
@@ -1922,13 +1922,6 @@ int32_t hi256_sensor_config(struct msm_sensor_ctrl_t *s_ctrl,
 			break;
 		}
 
-		if ((!conf_array.size) ||
-			(conf_array.size > I2C_SEQ_REG_DATA_MAX)) {
-			pr_err("%s:%d failed\n", __func__, __LINE__);
-			rc = -EFAULT;
-			break;
-		}
-
 		reg_setting = kzalloc(conf_array.size *
 			(sizeof(struct msm_camera_i2c_reg_array)), GFP_KERNEL);
 		if (!reg_setting) {
@@ -1963,12 +1956,6 @@ int32_t hi256_sensor_config(struct msm_sensor_ctrl_t *s_ctrl,
 			break;
 		}
 
-		if ((!conf_array.size) ||
-			(conf_array.size > I2C_SEQ_REG_DATA_MAX)) {
-			pr_err("%s:%d failed\n", __func__, __LINE__);
-			rc = -EFAULT;
-			break;
-		}
 		reg_setting = kzalloc(conf_array.size *
 			(sizeof(struct msm_camera_i2c_seq_reg_array)),
 			GFP_KERNEL);
diff --git a/drivers/media/platform/msm/camera_v2/sensor/imx135.c b/drivers/media/platform/msm/camera_v2/sensor/imx135.c
index 649575e..931c50e 100755
--- a/drivers/media/platform/msm/camera_v2/sensor/imx135.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/imx135.c
@@ -17,6 +17,22 @@ DEFINE_MSM_MUTEX(imx135_mut);
 static struct msm_sensor_ctrl_t imx135_s_ctrl;
 
 static struct msm_sensor_power_setting imx135_power_setting[] = {
+#if defined(CONFIG_ZTE_CAMERA_Z7)
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 1,
+	},
+	
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VAF,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 1,
+	},
+#endif
+
 	{
 		.seq_type = SENSOR_VREG,
 		.seq_val = 0,
diff --git a/drivers/media/platform/msm/camera_v2/sensor/imx135_069.c b/drivers/media/platform/msm/camera_v2/sensor/imx135_069.c
new file mode 100755
index 0000000..5aa050b
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/imx135_069.c
@@ -0,0 +1,193 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include "msm_sensor.h"
+#define IMX135_SENSOR_NAME "imx135_069"
+DEFINE_MSM_MUTEX(imx135_mut);
+static struct msm_sensor_ctrl_t imx135_s_ctrl;
+
+static struct msm_sensor_power_setting imx135_power_setting[] = {
+#if defined(CONFIG_ZTE_CAMERA_Z7MINI)
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 1,
+	},
+#endif
+
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = 1,
+		.config_val = 0,
+		.delay = 0,
+	},
+
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = 2,
+		.config_val = 0,
+		.delay = 0,
+	},
+#if 0
+
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VAF,
+		.config_val = 0,
+		.delay = 0,
+	},
+#endif
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 30,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 30,
+	},
+
+	{
+		.seq_type = SENSOR_CLK,
+		.seq_val = SENSOR_CAM_MCLK,
+		.config_val = 24000000,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_I2C_MUX,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+};
+
+static struct v4l2_subdev_info imx135_subdev_info[] = {
+	{
+		.code = V4L2_MBUS_FMT_SBGGR10_1X10,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.fmt = 1,
+		.order = 0,
+	},
+};
+
+static const struct i2c_device_id imx135_i2c_id[] = {
+	{IMX135_SENSOR_NAME, (kernel_ulong_t)&imx135_s_ctrl},
+	{ }
+};
+
+static int32_t msm_imx135_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	return msm_sensor_i2c_probe(client, id, &imx135_s_ctrl);
+}
+
+static struct i2c_driver imx135_i2c_driver = {
+	.id_table = imx135_i2c_id,
+	.probe  = msm_imx135_i2c_probe,
+	.driver = {
+		.name = IMX135_SENSOR_NAME,
+	},
+};
+
+static struct msm_camera_i2c_client imx135_sensor_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+};
+
+static const struct of_device_id imx135_dt_match[] = {
+	{.compatible = "qcom,imx135_069", .data = &imx135_s_ctrl},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, imx135_dt_match);
+
+static struct platform_driver imx135_platform_driver = {
+	.driver = {
+		.name = "qcom,imx135_069",
+		.owner = THIS_MODULE,
+		.of_match_table = imx135_dt_match,
+	},
+};
+
+static int32_t imx135_platform_probe(struct platform_device *pdev)
+{
+	int32_t rc = 0;
+	const struct of_device_id *match;
+	match = of_match_device(imx135_dt_match, &pdev->dev);
+	rc = msm_sensor_platform_probe(pdev, match->data);
+	return rc;
+}
+
+static int __init imx135_069_init_module(void)
+{
+	int32_t rc = 0;
+	pr_info("%s:%d\n", __func__, __LINE__);
+	rc = platform_driver_probe(&imx135_platform_driver,
+		imx135_platform_probe);
+	if (!rc)
+		return rc;
+	pr_err("%s:%d rc %d\n", __func__, __LINE__, rc);
+	return i2c_add_driver(&imx135_i2c_driver);
+}
+
+static void __exit imx135_069_exit_module(void)
+{
+	pr_info("%s:%d\n", __func__, __LINE__);
+	if (imx135_s_ctrl.pdev) {
+		msm_sensor_free_sensor_data(&imx135_s_ctrl);
+		platform_driver_unregister(&imx135_platform_driver);
+	} else
+		i2c_del_driver(&imx135_i2c_driver);
+	return;
+}
+
+static struct msm_sensor_ctrl_t imx135_s_ctrl = {
+	.sensor_i2c_client = &imx135_sensor_i2c_client,
+	.power_setting_array.power_setting = imx135_power_setting,
+	.power_setting_array.size = ARRAY_SIZE(imx135_power_setting),
+	.msm_sensor_mutex = &imx135_mut,
+	.sensor_v4l2_subdev_info = imx135_subdev_info,
+	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(imx135_subdev_info),
+};
+
+module_init(imx135_069_init_module);
+module_exit(imx135_069_exit_module);
+MODULE_DESCRIPTION("imx135");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/msm/camera_v2/sensor/imx135_front.c b/drivers/media/platform/msm/camera_v2/sensor/imx135_front.c
new file mode 100755
index 0000000..6ea744f
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/imx135_front.c
@@ -0,0 +1,192 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include "msm_sensor.h"
+#define IMX135_SENSOR_NAME "imx135_front"
+DEFINE_MSM_MUTEX(imx135_front_mut);
+static struct msm_sensor_ctrl_t imx135_s_ctrl;
+
+static struct msm_sensor_power_setting imx135_power_setting[] = {
+
+#if defined(CONFIG_ZTE_CAMERA_Z7)
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 1,
+	},
+#endif
+
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = 1,
+		.config_val = 0,
+		.delay = 0,
+	},
+
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = 2,
+		.config_val = 0,
+		.delay = 0,
+	},
+#if 0
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VAF,
+		.config_val = 0,
+		.delay = 0,
+	},
+#endif
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 30,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 30,
+	},
+	{
+		.seq_type = SENSOR_CLK,
+		.seq_val = SENSOR_CAM_MCLK,
+		.config_val = 24000000,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_I2C_MUX,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+};
+
+static struct v4l2_subdev_info imx135_subdev_info[] = {
+	{
+		.code = V4L2_MBUS_FMT_SBGGR10_1X10,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.fmt = 1,
+		.order = 0,
+	},
+};
+
+static const struct i2c_device_id imx135_i2c_id[] = {
+	{IMX135_SENSOR_NAME, (kernel_ulong_t)&imx135_s_ctrl},
+	{ }
+};
+
+static int32_t msm_imx135_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	return msm_sensor_i2c_probe(client, id, &imx135_s_ctrl);
+}
+
+static struct i2c_driver imx135_i2c_driver = {
+	.id_table = imx135_i2c_id,
+	.probe  = msm_imx135_i2c_probe,
+	.driver = {
+		.name = IMX135_SENSOR_NAME,
+	},
+};
+
+static struct msm_camera_i2c_client imx135_sensor_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+};
+
+static const struct of_device_id imx135_dt_match[] = {
+	{.compatible = "qcom,imx135_front", .data = &imx135_s_ctrl},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, imx135_dt_match);
+
+static struct platform_driver imx135_platform_driver = {
+	.driver = {
+		.name = "qcom,imx135_front",
+		.owner = THIS_MODULE,
+		.of_match_table = imx135_dt_match,
+	},
+};
+
+static int32_t imx135_platform_probe(struct platform_device *pdev)
+{
+	int32_t rc = 0;
+	const struct of_device_id *match;
+	match = of_match_device(imx135_dt_match, &pdev->dev);
+	rc = msm_sensor_platform_probe(pdev, match->data);
+	return rc;
+}
+
+static int __init imx135_front_init_module(void)
+{
+	int32_t rc = 0;
+	pr_info("%s:%d\n", __func__, __LINE__);
+	rc = platform_driver_probe(&imx135_platform_driver,
+		imx135_platform_probe);
+	if (!rc)
+		return rc;
+	pr_err("%s:%d rc %d\n", __func__, __LINE__, rc);
+	return i2c_add_driver(&imx135_i2c_driver);
+}
+
+static void __exit imx135_front_exit_module(void)
+{
+	pr_info("%s:%d\n", __func__, __LINE__);
+	if (imx135_s_ctrl.pdev) {
+		msm_sensor_free_sensor_data(&imx135_s_ctrl);
+		platform_driver_unregister(&imx135_platform_driver);
+	} else
+		i2c_del_driver(&imx135_i2c_driver);
+	return;
+}
+
+static struct msm_sensor_ctrl_t imx135_s_ctrl = {
+	.sensor_i2c_client = &imx135_sensor_i2c_client,
+	.power_setting_array.power_setting = imx135_power_setting,
+	.power_setting_array.size = ARRAY_SIZE(imx135_power_setting),
+	.msm_sensor_mutex = &imx135_front_mut,
+	.sensor_v4l2_subdev_info = imx135_subdev_info,
+	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(imx135_subdev_info),
+};
+
+module_init(imx135_front_init_module);
+module_exit(imx135_front_exit_module);
+MODULE_DESCRIPTION("imx135_front");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/msm/camera_v2/sensor/imx135_gbao.c b/drivers/media/platform/msm/camera_v2/sensor/imx135_gbao.c
new file mode 100755
index 0000000..300e742
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/imx135_gbao.c
@@ -0,0 +1,216 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include "msm_sensor.h"
+#define IMX135_SENSOR_NAME "imx135_gbao"
+DEFINE_MSM_MUTEX(imx135_mut);
+
+static struct msm_sensor_ctrl_t imx135_s_ctrl;
+
+static struct msm_sensor_power_setting imx135_power_setting[] = {
+
+#if defined(CONFIG_ZTE_CAMERA_Z7)
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VAF,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 1,
+	},
+	
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VAF,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 1,
+	},
+#endif
+
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = 1,
+		.config_val = 0,
+		.delay = 0,
+	},
+#if 0
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VIO,
+		.config_val = 0,
+		.delay = 0,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VAF,
+		.config_val = 0,
+		.delay = 0,
+	},
+#endif
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 30,
+	},
+
+	{
+ 		.seq_type = SENSOR_GPIO,
+ 		.seq_val = SENSOR_GPIO_STANDBY,
+ 		.config_val = GPIO_OUT_HIGH,
+ 		.delay = 5,
+ 	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_LOW,
+ 		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_HIGH,
+ 		.delay = 5,
+	},
+
+	{
+		.seq_type = SENSOR_CLK,
+		.seq_val = SENSOR_CAM_MCLK,
+		.config_val = 24000000,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_I2C_MUX,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+};
+
+static struct v4l2_subdev_info imx135_subdev_info[] = {
+	{
+		.code = V4L2_MBUS_FMT_SBGGR10_1X10,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.fmt = 1,
+		.order = 0,
+	},
+};
+
+static const struct i2c_device_id imx135_i2c_id[] = {
+	{IMX135_SENSOR_NAME, (kernel_ulong_t)&imx135_s_ctrl},
+	{ }
+};
+
+static int32_t msm_imx135_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	return msm_sensor_i2c_probe(client, id, &imx135_s_ctrl);
+}
+
+static struct i2c_driver imx135_i2c_driver = {
+	.id_table = imx135_i2c_id,
+	.probe  = msm_imx135_i2c_probe,
+	.driver = {
+		.name = IMX135_SENSOR_NAME,
+	},
+};
+
+static struct msm_camera_i2c_client imx135_sensor_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+};
+
+static const struct of_device_id imx135_dt_match[] = {
+	{.compatible = "qcom,imx135_gbao", .data = &imx135_s_ctrl},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, imx135_dt_match);
+
+static struct platform_driver imx135_platform_driver = {
+	.driver = {
+		.name = "qcom,imx135_gbao",
+		.owner = THIS_MODULE,
+		.of_match_table = imx135_dt_match,
+	},
+};
+
+static int32_t imx135_platform_probe(struct platform_device *pdev)
+{
+	int32_t rc = 0;
+	const struct of_device_id *match;
+	match = of_match_device(imx135_dt_match, &pdev->dev);
+	rc = msm_sensor_platform_probe(pdev, match->data);
+	return rc;
+}
+
+static int __init imx135_gbao_init_module(void)
+{
+	int32_t rc = 0;
+	pr_info("%s:%d\n", __func__, __LINE__);
+	rc = platform_driver_probe(&imx135_platform_driver,
+		imx135_platform_probe);
+	if (!rc)
+		return rc;
+	pr_err("%s:%d rc %d\n", __func__, __LINE__, rc);
+	return i2c_add_driver(&imx135_i2c_driver);
+}
+
+static void __exit imx135_gbao_exit_module(void)
+{
+	pr_info("%s:%d\n", __func__, __LINE__);
+	if (imx135_s_ctrl.pdev) {
+		msm_sensor_free_sensor_data(&imx135_s_ctrl);
+		platform_driver_unregister(&imx135_platform_driver);
+	} else
+		i2c_del_driver(&imx135_i2c_driver);
+	return;
+}
+
+static struct msm_sensor_ctrl_t imx135_s_ctrl = {
+	.sensor_i2c_client = &imx135_sensor_i2c_client,
+	.power_setting_array.power_setting = imx135_power_setting,
+	.power_setting_array.size = ARRAY_SIZE(imx135_power_setting),
+	.zte_otp_enable = true,
+
+	.msm_sensor_mutex = &imx135_mut,
+	.sensor_v4l2_subdev_info = imx135_subdev_info,
+	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(imx135_subdev_info),
+};
+
+module_init(imx135_gbao_init_module);
+module_exit(imx135_gbao_exit_module);
+MODULE_DESCRIPTION("imx135");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/msm/camera_v2/sensor/imx135_gbao_lc898122.c b/drivers/media/platform/msm/camera_v2/sensor/imx135_gbao_lc898122.c
new file mode 100755
index 0000000..cbe884a
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/imx135_gbao_lc898122.c
@@ -0,0 +1,217 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include "msm_sensor.h"
+#define IMX135_SENSOR_NAME "imx135_gbao_lc898122"
+DEFINE_MSM_MUTEX(imx135_mut);
+
+static struct msm_sensor_ctrl_t imx135_s_ctrl;
+
+static struct msm_sensor_power_setting imx135_power_setting[] = {
+
+#if defined(CONFIG_ZTE_CAMERA_Z7)
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VAF,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 1,
+	},
+	
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VAF,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 1,
+	},
+#endif
+
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = 1,
+		.config_val = 0,
+		.delay = 0,
+	},
+#if 0
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VIO,
+		.config_val = 0,
+		.delay = 0,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VAF,
+		.config_val = 0,
+		.delay = 0,
+	},
+#endif
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 30,
+	},
+	{
+ 		.seq_type = SENSOR_GPIO,
+ 		.seq_val = SENSOR_GPIO_STANDBY,
+ 		.config_val = GPIO_OUT_HIGH,
+ 		.delay = 5,
+ 	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_LOW,
+ 		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_HIGH,
+ 		.delay = 5,
+	},
+
+	{
+		.seq_type = SENSOR_CLK,
+		.seq_val = SENSOR_CAM_MCLK,
+		.config_val = 24000000,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_I2C_MUX,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+};
+
+static struct v4l2_subdev_info imx135_subdev_info[] = {
+	{
+		.code = V4L2_MBUS_FMT_SBGGR10_1X10,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.fmt = 1,
+		.order = 0,
+	},
+};
+
+static const struct i2c_device_id imx135_i2c_id[] = {
+	{IMX135_SENSOR_NAME, (kernel_ulong_t)&imx135_s_ctrl},
+	{ }
+};
+
+static int32_t msm_imx135_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	return msm_sensor_i2c_probe(client, id, &imx135_s_ctrl);
+}
+
+static struct i2c_driver imx135_i2c_driver = {
+	.id_table = imx135_i2c_id,
+	.probe  = msm_imx135_i2c_probe,
+	.driver = {
+		.name = IMX135_SENSOR_NAME,
+	},
+};
+
+static struct msm_camera_i2c_client imx135_sensor_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+};
+
+static const struct of_device_id imx135_dt_match[] = {
+	{.compatible = "qcom,imx135_gbao_lc898122", .data = &imx135_s_ctrl},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, imx135_dt_match);
+
+static struct platform_driver imx135_platform_driver = {
+	.driver = {
+		.name = "qcom,imx135_gbao_lc898122",
+		.owner = THIS_MODULE,
+		.of_match_table = imx135_dt_match,
+	},
+};
+
+static int32_t imx135_platform_probe(struct platform_device *pdev)
+{
+	int32_t rc = 0;
+	const struct of_device_id *match;
+	match = of_match_device(imx135_dt_match, &pdev->dev);
+	rc = msm_sensor_platform_probe(pdev, match->data);
+	return rc;
+}
+
+static int __init imx135_gbao_lc898122_init_module(void)
+{
+	int32_t rc = 0;
+	pr_info("%s:%d\n", __func__, __LINE__);
+	
+	rc = platform_driver_probe(&imx135_platform_driver,
+		imx135_platform_probe);
+	
+	if (!rc)
+		return rc;
+	pr_err("%s:%d rc %d\n", __func__, __LINE__, rc);
+	return i2c_add_driver(&imx135_i2c_driver);
+}
+
+static void __exit imx135_gbao_lc898122_exit_module(void)
+{
+	pr_info("%s:%d\n", __func__, __LINE__);
+	if (imx135_s_ctrl.pdev) {
+		msm_sensor_free_sensor_data(&imx135_s_ctrl);
+		platform_driver_unregister(&imx135_platform_driver);
+	} else
+		i2c_del_driver(&imx135_i2c_driver);
+	return;
+}
+
+static struct msm_sensor_ctrl_t imx135_s_ctrl = {
+	.sensor_i2c_client = &imx135_sensor_i2c_client,
+	.power_setting_array.power_setting = imx135_power_setting,
+	.power_setting_array.size = ARRAY_SIZE(imx135_power_setting),
+	.zte_otp_enable = true,
+
+	.msm_sensor_mutex = &imx135_mut,
+	.sensor_v4l2_subdev_info = imx135_subdev_info,
+	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(imx135_subdev_info),
+};
+
+module_init(imx135_gbao_lc898122_init_module);
+module_exit(imx135_gbao_lc898122_exit_module);
+MODULE_DESCRIPTION("imx135");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/msm/camera_v2/sensor/imx214.c b/drivers/media/platform/msm/camera_v2/sensor/imx214.c
new file mode 100755
index 0000000..9aa19d5
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/imx214.c
@@ -0,0 +1,208 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include "msm_sensor.h"
+#define IMX214_SENSOR_NAME "imx214"
+DEFINE_MSM_MUTEX(imx214_mut);
+
+static struct msm_sensor_ctrl_t imx214_s_ctrl;
+
+static struct msm_sensor_power_setting imx214_power_setting[] = {
+#if defined(CONFIG_ZTE_CAMERA_Z7) || defined(CONFIG_ZTE_CAMERA_Z7MINI) || defined(CONFIG_ZTE_CAMERA_NX507J) \
+					|| defined(CONFIG_ZTE_CAMERA_NX505J) || defined(CONFIG_ZTE_CAMERA_NX506J) 
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 1,
+	},
+#endif
+#ifdef CONFIG_ZTE_CAMERA_NX506J
+#else
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VDIG,
+		.config_val = 0,
+		.delay = 0,
+	},
+#endif
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VANA,
+		.config_val = 0,
+		.delay = 0,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VIO,
+		.config_val = 0,
+		.delay = 0,
+	},
+	
+#ifdef CONFIG_ZTE_CAMERA_NX506J
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VIO,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VIO,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 1,
+	},
+#endif
+	#if 0
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VAF,
+		.config_val = 0,
+		.delay = 0,
+	},
+	#endif
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 30,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 30,
+	},
+	{
+		.seq_type = SENSOR_CLK,
+		.seq_val = SENSOR_CAM_MCLK,
+		.config_val = 24000000,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_I2C_MUX,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+};
+
+static struct v4l2_subdev_info imx214_subdev_info[] = {
+	{
+		.code = V4L2_MBUS_FMT_SBGGR10_1X10,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.fmt = 1,
+		.order = 0,
+	},
+};
+
+static const struct i2c_device_id imx214_i2c_id[] = {
+	{IMX214_SENSOR_NAME, (kernel_ulong_t)&imx214_s_ctrl},
+	{ }
+};
+
+static int32_t msm_imx214_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	return msm_sensor_i2c_probe(client, id, &imx214_s_ctrl);
+}
+
+static struct i2c_driver imx214_i2c_driver = {
+	.id_table = imx214_i2c_id,
+	.probe  = msm_imx214_i2c_probe,
+	.driver = {
+		.name = IMX214_SENSOR_NAME,
+	},
+};
+
+static struct msm_camera_i2c_client imx214_sensor_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+};
+
+static const struct of_device_id imx214_dt_match[] = {
+	{.compatible = "qcom,imx214", .data = &imx214_s_ctrl},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, imx214_dt_match);
+
+static struct platform_driver imx214_platform_driver = {
+	.driver = {
+		.name = "qcom,imx214",
+		.owner = THIS_MODULE,
+		.of_match_table = imx214_dt_match,
+	},
+};
+
+static int32_t imx214_platform_probe(struct platform_device *pdev)
+{
+	int32_t rc = 0;
+	const struct of_device_id *match;
+	match = of_match_device(imx214_dt_match, &pdev->dev);
+	rc = msm_sensor_platform_probe(pdev, match->data);
+	return rc;
+}
+
+static int __init imx214_init_module(void)
+{
+	int32_t rc = 0;
+	pr_info("%s:%d\n", __func__, __LINE__);
+	rc = platform_driver_probe(&imx214_platform_driver,
+		imx214_platform_probe);
+	if (!rc)
+		return rc;
+	pr_err("%s:%d rc %d\n", __func__, __LINE__, rc);
+	return i2c_add_driver(&imx214_i2c_driver);
+}
+
+static void __exit imx214_exit_module(void)
+{
+	pr_info("%s:%d\n", __func__, __LINE__);
+	if (imx214_s_ctrl.pdev) {
+		msm_sensor_free_sensor_data(&imx214_s_ctrl);
+		platform_driver_unregister(&imx214_platform_driver);
+	} else
+		i2c_del_driver(&imx214_i2c_driver);
+	return;
+}
+
+static struct msm_sensor_ctrl_t imx214_s_ctrl = {
+	.sensor_i2c_client = &imx214_sensor_i2c_client,
+	.power_setting_array.power_setting = imx214_power_setting,
+	.power_setting_array.size = ARRAY_SIZE(imx214_power_setting),
+	.msm_sensor_mutex = &imx214_mut,
+	.sensor_v4l2_subdev_info = imx214_subdev_info,
+	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(imx214_subdev_info),
+};
+
+module_init(imx214_init_module);
+module_exit(imx214_exit_module);
+MODULE_DESCRIPTION("imx214");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/msm/camera_v2/sensor/imx214_app.c b/drivers/media/platform/msm/camera_v2/sensor/imx214_app.c
new file mode 100755
index 0000000..48df002
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/imx214_app.c
@@ -0,0 +1,205 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include "msm_sensor.h"
+#define IMX214_APP_SENSOR_NAME "imx214_app"
+DEFINE_MSM_MUTEX(imx214_app_mut);
+
+static struct msm_sensor_ctrl_t imx214_app_s_ctrl;
+
+static struct msm_sensor_power_setting imx214_app_power_setting[] = {
+
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = 1,
+		.config_val = 0,
+		.delay = 0,
+	},
+#if 1 
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VANA,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VANA,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VAF,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VAF,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 1,
+	},
+#endif
+
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 30,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 30,
+	},
+	{
+		.seq_type = SENSOR_CLK,
+		.seq_val = SENSOR_CAM_MCLK,
+		.config_val = 24000000,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_I2C_MUX,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+};
+
+static struct v4l2_subdev_info imx214_app_subdev_info[] = {
+	{
+		.code = V4L2_MBUS_FMT_SBGGR10_1X10,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.fmt = 1,
+		.order = 0,
+	},
+};
+
+static const struct i2c_device_id imx214_app_i2c_id[] = {
+	{IMX214_APP_SENSOR_NAME, (kernel_ulong_t)&imx214_app_s_ctrl},
+	{ }
+};
+
+static int32_t msm_imx214_app_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	return msm_sensor_i2c_probe(client, id, &imx214_app_s_ctrl);
+}
+
+static struct i2c_driver imx214_app_i2c_driver = {
+	.id_table = imx214_app_i2c_id,
+	.probe  = msm_imx214_app_i2c_probe,
+	.driver = {
+		.name = IMX214_APP_SENSOR_NAME,
+	},
+};
+
+static struct msm_camera_i2c_client imx214_app_sensor_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+};
+
+static const struct of_device_id imx214_app_dt_match[] = {
+	{.compatible = "qcom,imx214_app", .data = &imx214_app_s_ctrl},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, imx214_app_dt_match);
+
+static struct platform_driver imx214_app_platform_driver = {
+	.driver = {
+		.name = "qcom,imx214_app",
+		.owner = THIS_MODULE,
+		.of_match_table = imx214_app_dt_match,
+	},
+};
+
+static int32_t imx214_app_platform_probe(struct platform_device *pdev)
+{
+	int32_t rc = 0;
+	const struct of_device_id *match;
+	match = of_match_device(imx214_app_dt_match, &pdev->dev);
+	rc = msm_sensor_platform_probe(pdev, match->data);
+	return rc;
+}
+
+static int __init imx214_app_init_module(void)
+{
+	int32_t rc = 0;
+	pr_info("%s:%d\n", __func__, __LINE__);
+	
+	rc = platform_driver_probe(&imx214_app_platform_driver,
+		imx214_app_platform_probe);
+	
+	if (!rc)
+		return rc;
+	pr_err("%s:%d rc %d\n", __func__, __LINE__, rc);
+	
+	return i2c_add_driver(&imx214_app_i2c_driver);
+}
+
+static void __exit imx214_app_exit_module(void)
+{
+	pr_info("%s:%d\n", __func__, __LINE__);
+	if (imx214_app_s_ctrl.pdev) {
+		msm_sensor_free_sensor_data(&imx214_app_s_ctrl);
+		platform_driver_unregister(&imx214_app_platform_driver);
+	} else
+		i2c_del_driver(&imx214_app_i2c_driver);
+	return;
+}
+
+static struct msm_sensor_ctrl_t imx214_app_s_ctrl = {
+	.sensor_i2c_client = &imx214_app_sensor_i2c_client,
+	.power_setting_array.power_setting = imx214_app_power_setting,
+	.power_setting_array.size = ARRAY_SIZE(imx214_app_power_setting),
+	//.zte_otp_enable = true,
+	.msm_sensor_mutex = &imx214_app_mut,
+	.sensor_v4l2_subdev_info = imx214_app_subdev_info,
+	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(imx214_app_subdev_info),
+};
+
+module_init(imx214_app_init_module);
+module_exit(imx214_app_exit_module);
+MODULE_DESCRIPTION("imx214_app");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/msm/camera_v2/sensor/imx214_lc898122.c b/drivers/media/platform/msm/camera_v2/sensor/imx214_lc898122.c
new file mode 100755
index 0000000..02a9269
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/imx214_lc898122.c
@@ -0,0 +1,209 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include "msm_sensor.h"
+#define IMX214_LC898122_SENSOR_NAME "imx214_lc898122"
+DEFINE_MSM_MUTEX(imx214_lc898122_mut);
+
+static struct msm_sensor_ctrl_t imx214_lc898122_s_ctrl;
+
+static struct msm_sensor_power_setting imx214_lc898122_power_setting[] = {
+#if defined(CONFIG_ZTE_CAMERA_Z7) || defined(CONFIG_ZTE_CAMERA_Z7MINI) || defined(CONFIG_ZTE_CAMERA_NX507J) \
+					|| defined(CONFIG_ZTE_CAMERA_NX505J) || defined(CONFIG_ZTE_CAMERA_NX506J) 
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 1,
+	},
+#endif
+#ifdef CONFIG_ZTE_CAMERA_NX506J
+#else
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VDIG,
+		.config_val = 0,
+		.delay = 0,
+	},
+#endif
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VANA,
+		.config_val = 0,
+		.delay = 0,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VIO,
+		.config_val = 0,
+		.delay = 0,
+	},
+	
+#ifdef CONFIG_ZTE_CAMERA_NX506J
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VIO,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VIO,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 1,
+	},
+#endif
+	#if 0
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VAF,
+		.config_val = 0,
+		.delay = 0,
+	},
+	#endif
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 30,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 30,
+	},
+	{
+		.seq_type = SENSOR_CLK,
+		.seq_val = SENSOR_CAM_MCLK,
+		.config_val = 24000000,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_I2C_MUX,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+};
+
+static struct v4l2_subdev_info imx214_lc898122_subdev_info[] = {
+	{
+		.code = V4L2_MBUS_FMT_SBGGR10_1X10,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.fmt = 1,
+		.order = 0,
+	},
+};
+
+static const struct i2c_device_id imx214_lc898122_i2c_id[] = {
+	{IMX214_LC898122_SENSOR_NAME, (kernel_ulong_t)&imx214_lc898122_s_ctrl},
+	{ }
+};
+
+static int32_t msm_imx214_lc898122_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	return msm_sensor_i2c_probe(client, id, &imx214_lc898122_s_ctrl);
+}
+
+static struct i2c_driver imx214_lc898122_i2c_driver = {
+	.id_table = imx214_lc898122_i2c_id,
+	.probe  = msm_imx214_lc898122_i2c_probe,
+	.driver = {
+		.name = IMX214_LC898122_SENSOR_NAME,
+	},
+};
+
+static struct msm_camera_i2c_client imx214_lc898122_sensor_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+};
+
+static const struct of_device_id imx214_lc898122_dt_match[] = {
+	{.compatible = "qcom,imx214_lc898122", .data = &imx214_lc898122_s_ctrl},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, imx214_lc898122_dt_match);
+
+static struct platform_driver imx214_lc898122_platform_driver = {
+	.driver = {
+		.name = "qcom,imx214_lc898122",
+		.owner = THIS_MODULE,
+		.of_match_table = imx214_lc898122_dt_match,
+	},
+};
+
+static int32_t imx214_lc898122_platform_probe(struct platform_device *pdev)
+{
+	int32_t rc = 0;
+	const struct of_device_id *match;
+	match = of_match_device(imx214_lc898122_dt_match, &pdev->dev);
+	rc = msm_sensor_platform_probe(pdev, match->data);
+	return rc;
+}
+
+static int __init imx214_lc898122_init_module(void)
+{
+	int32_t rc = 0;
+	pr_info("%s:%d\n", __func__, __LINE__);
+	rc = platform_driver_probe(&imx214_lc898122_platform_driver,
+		imx214_lc898122_platform_probe);
+	if (!rc)
+		return rc;
+	pr_err("%s:%d rc %d\n", __func__, __LINE__, rc);
+	return i2c_add_driver(&imx214_lc898122_i2c_driver);
+}
+
+static void __exit imx214_lc898122_exit_module(void)
+{
+	pr_info("%s:%d\n", __func__, __LINE__);
+	if (imx214_lc898122_s_ctrl.pdev) {
+		msm_sensor_free_sensor_data(&imx214_lc898122_s_ctrl);
+		platform_driver_unregister(&imx214_lc898122_platform_driver);
+	} else
+		i2c_del_driver(&imx214_lc898122_i2c_driver);
+	return;
+}
+
+static struct msm_sensor_ctrl_t imx214_lc898122_s_ctrl = {
+	.sensor_i2c_client = &imx214_lc898122_sensor_i2c_client,
+	.power_setting_array.power_setting = imx214_lc898122_power_setting,
+	.power_setting_array.size = ARRAY_SIZE(imx214_lc898122_power_setting),
+	.zte_otp_enable = true,
+	.msm_sensor_mutex = &imx214_lc898122_mut,
+	.sensor_v4l2_subdev_info = imx214_lc898122_subdev_info,
+	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(imx214_lc898122_subdev_info),
+};
+
+module_init(imx214_lc898122_init_module);
+module_exit(imx214_lc898122_exit_module);
+MODULE_DESCRIPTION("imx214_lc898122");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/msm/camera_v2/sensor/imx214_ois_sharp.c b/drivers/media/platform/msm/camera_v2/sensor/imx214_ois_sharp.c
new file mode 100755
index 0000000..48f8447
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/imx214_ois_sharp.c
@@ -0,0 +1,212 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include "msm_sensor.h"
+#define IMX214_OIS_SHARP_SENSOR_NAME "imx214_ois_sharp"
+DEFINE_MSM_MUTEX(imx214_ois_sharp_mut);
+
+static struct msm_sensor_ctrl_t imx214_ois_sharp_s_ctrl;
+
+static struct msm_sensor_power_setting imx214_ois_sharp_power_setting[] = {
+#if defined(CONFIG_ZTE_CAMERA_Z7) || defined(CONFIG_ZTE_CAMERA_Z7MINI) || defined(CONFIG_ZTE_CAMERA_NX507J) \
+					|| defined(CONFIG_ZTE_CAMERA_NX505J) || defined(CONFIG_ZTE_CAMERA_NX506J) 
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 1,
+	},
+#endif
+#ifdef CONFIG_ZTE_CAMERA_NX506J
+#else
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VDIG,
+		.config_val = 0,
+		.delay = 0,
+	},
+#endif
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VANA,
+		.config_val = 0,
+		.delay = 0,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VIO,
+		.config_val = 0,
+		.delay = 0,
+	},
+	
+#ifdef CONFIG_ZTE_CAMERA_NX506J
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VIO,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VIO,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 1,
+	},
+#endif
+	#if 0
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VAF,
+		.config_val = 0,
+		.delay = 0,
+	},
+	#endif
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 30,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 30,
+	},
+	{
+		.seq_type = SENSOR_CLK,
+		.seq_val = SENSOR_CAM_MCLK,
+		.config_val = 24000000,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_I2C_MUX,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+};
+
+static struct v4l2_subdev_info imx214_ois_sharp_subdev_info[] = {
+	{
+		.code = V4L2_MBUS_FMT_SBGGR10_1X10,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.fmt = 1,
+		.order = 0,
+	},
+};
+
+static const struct i2c_device_id imx214_ois_sharp_i2c_id[] = {
+	{IMX214_OIS_SHARP_SENSOR_NAME, (kernel_ulong_t)&imx214_ois_sharp_s_ctrl},
+	{ }
+};
+
+static int32_t msm_imx214_ois_sharp_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	return msm_sensor_i2c_probe(client, id, &imx214_ois_sharp_s_ctrl);
+}
+
+static struct i2c_driver imx214_ois_sharp_i2c_driver = {
+	.id_table = imx214_ois_sharp_i2c_id,
+	.probe  = msm_imx214_ois_sharp_i2c_probe,
+	.driver = {
+		.name = IMX214_OIS_SHARP_SENSOR_NAME,
+	},
+};
+
+static struct msm_camera_i2c_client imx214_ois_sharp_sensor_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+};
+
+static const struct of_device_id imx214_ois_sharp_dt_match[] = {
+	{.compatible = "qcom,imx214_ois_sharp", .data = &imx214_ois_sharp_s_ctrl},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, imx214_ois_sharp_dt_match);
+
+static struct platform_driver imx214_ois_sharp_platform_driver = {
+	.driver = {
+		.name = "qcom,imx214_ois_sharp",
+		.owner = THIS_MODULE,
+		.of_match_table = imx214_ois_sharp_dt_match,
+	},
+};
+
+static int32_t imx214_ois_sharp_platform_probe(struct platform_device *pdev)
+{
+	int32_t rc = 0;
+	const struct of_device_id *match;
+	match = of_match_device(imx214_ois_sharp_dt_match, &pdev->dev);
+	rc = msm_sensor_platform_probe(pdev, match->data);
+	return rc;
+}
+
+static int __init imx214_ois_sharp_init_module(void)
+{
+	int32_t rc = 0;
+	pr_info("%s:%d\n", __func__, __LINE__);
+	printk("kwang imx214_ois_sharp_init_module\n");
+	rc = platform_driver_probe(&imx214_ois_sharp_platform_driver,
+		imx214_ois_sharp_platform_probe);
+	printk("kwang imx214_ois_sharp_init_module 000 rc =%d\n",rc);
+	if (!rc)
+		return rc;
+	printk("kwang imx214_ois_sharp_init_module 111 rc =%d\n",rc);
+	pr_err("%s:%d rc %d\n", __func__, __LINE__, rc);
+	return i2c_add_driver(&imx214_ois_sharp_i2c_driver);
+}
+
+static void __exit imx214_ois_sharp_exit_module(void)
+{
+	pr_info("%s:%d\n", __func__, __LINE__);
+	if (imx214_ois_sharp_s_ctrl.pdev) {
+		msm_sensor_free_sensor_data(&imx214_ois_sharp_s_ctrl);
+		platform_driver_unregister(&imx214_ois_sharp_platform_driver);
+	} else
+		i2c_del_driver(&imx214_ois_sharp_i2c_driver);
+	return;
+}
+
+static struct msm_sensor_ctrl_t imx214_ois_sharp_s_ctrl = {
+	.sensor_i2c_client = &imx214_ois_sharp_sensor_i2c_client,
+	.power_setting_array.power_setting = imx214_ois_sharp_power_setting,
+	.power_setting_array.size = ARRAY_SIZE(imx214_ois_sharp_power_setting),
+	.zte_otp_enable = true,
+	.msm_sensor_mutex = &imx214_ois_sharp_mut,
+	.sensor_v4l2_subdev_info = imx214_ois_sharp_subdev_info,
+	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(imx214_ois_sharp_subdev_info),
+};
+
+module_init(imx214_ois_sharp_init_module);
+module_exit(imx214_ois_sharp_exit_module);
+MODULE_DESCRIPTION("imx214_ois_sharp");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/msm/camera_v2/sensor/imx220.c b/drivers/media/platform/msm/camera_v2/sensor/imx220.c
new file mode 100755
index 0000000..d0b31a2
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/imx220.c
@@ -0,0 +1,209 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include "msm_sensor.h"
+#define IMX220_SENSOR_NAME "imx220"
+DEFINE_MSM_MUTEX(imx220_mut);
+
+static struct msm_sensor_ctrl_t imx220_s_ctrl;
+
+static struct msm_sensor_power_setting imx220_power_setting[] = {
+#if defined(CONFIG_ZTE_CAMERA_Z7) || defined(CONFIG_ZTE_CAMERA_Z7MINI) || defined(CONFIG_ZTE_CAMERA_NX507J) \
+					|| defined(CONFIG_ZTE_CAMERA_NX505J) || defined(CONFIG_ZTE_CAMERA_NX506J) 
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 1,
+	},
+#endif
+#ifdef CONFIG_ZTE_CAMERA_NX506J
+#else
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VDIG,
+		.config_val = 0,
+		.delay = 0,
+	},
+#endif
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VANA,
+		.config_val = 0,
+		.delay = 0,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VIO,
+		.config_val = 0,
+		.delay = 0,
+	},
+	
+#ifdef CONFIG_ZTE_CAMERA_NX506J
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VIO,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VIO,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 1,
+	},
+#endif
+	#if 0
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VAF,
+		.config_val = 0,
+		.delay = 0,
+	},
+	#endif
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 30,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 30,
+	},
+	{
+		.seq_type = SENSOR_CLK,
+		.seq_val = SENSOR_CAM_MCLK,
+		.config_val = 24000000,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_I2C_MUX,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+};
+
+static struct v4l2_subdev_info imx220_subdev_info[] = {
+	{
+		.code = V4L2_MBUS_FMT_SBGGR10_1X10,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.fmt = 1,
+		.order = 0,
+	},
+};
+
+static const struct i2c_device_id imx220_i2c_id[] = {
+	{IMX220_SENSOR_NAME, (kernel_ulong_t)&imx220_s_ctrl},
+	{ }
+};
+
+static int32_t msm_imx220_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	return msm_sensor_i2c_probe(client, id, &imx220_s_ctrl);
+}
+
+static struct i2c_driver imx220_i2c_driver = {
+	.id_table = imx220_i2c_id,
+	.probe  = msm_imx220_i2c_probe,
+	.driver = {
+		.name = IMX220_SENSOR_NAME,
+	},
+};
+
+static struct msm_camera_i2c_client imx220_sensor_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+};
+
+static const struct of_device_id imx220_dt_match[] = {
+	{.compatible = "qcom,imx220", .data = &imx220_s_ctrl},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, imx220_dt_match);
+
+static struct platform_driver imx220_platform_driver = {
+	.driver = {
+		.name = "qcom,imx220",
+		.owner = THIS_MODULE,
+		.of_match_table = imx220_dt_match,
+	},
+};
+
+static int32_t imx220_platform_probe(struct platform_device *pdev)
+{
+	int32_t rc = 0;
+	const struct of_device_id *match;
+	match = of_match_device(imx220_dt_match, &pdev->dev);
+	rc = msm_sensor_platform_probe(pdev, match->data);
+	return rc;
+}
+
+static int __init imx220_init_module(void)
+{
+	int32_t rc = 0;
+	pr_info("%s:%d\n", __func__, __LINE__);
+	rc = platform_driver_probe(&imx220_platform_driver,
+		imx220_platform_probe);
+	if (!rc)
+		return rc;
+	pr_err("%s:%d rc %d\n", __func__, __LINE__, rc);
+	return i2c_add_driver(&imx220_i2c_driver);
+}
+
+static void __exit imx220_exit_module(void)
+{
+	pr_info("%s:%d\n", __func__, __LINE__);
+	if (imx220_s_ctrl.pdev) {
+		msm_sensor_free_sensor_data(&imx220_s_ctrl);
+		platform_driver_unregister(&imx220_platform_driver);
+	} else
+		i2c_del_driver(&imx220_i2c_driver);
+	return;
+}
+
+static struct msm_sensor_ctrl_t imx220_s_ctrl = {
+	.sensor_i2c_client = &imx220_sensor_i2c_client,
+	.power_setting_array.power_setting = imx220_power_setting,
+	.power_setting_array.size = ARRAY_SIZE(imx220_power_setting),
+	.zte_otp_enable = true,
+	.msm_sensor_mutex = &imx220_mut,
+	.sensor_v4l2_subdev_info = imx220_subdev_info,
+	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(imx220_subdev_info),
+};
+
+module_init(imx220_init_module);
+module_exit(imx220_exit_module);
+MODULE_DESCRIPTION("imx220");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c b/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c
index 6af0cea..94ce23d 100755
--- a/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c
@@ -158,7 +158,7 @@ int32_t msm_camera_cci_i2c_write_seq(struct msm_camera_i2c_client *client,
 		reg_conf_tbl[i].reg_data = data[i];
 		reg_conf_tbl[i].delay = 0;
 	}
-	cci_ctrl.cmd = MSM_CCI_I2C_WRITE_SEQ;
+	cci_ctrl.cmd = MSM_CCI_I2C_WRITE;
 	cci_ctrl.cci_info = client->cci_client;
 	cci_ctrl.cfg.cci_i2c_write_cfg.reg_setting = reg_conf_tbl;
 	cci_ctrl.cfg.cci_i2c_write_cfg.data_type = MSM_CAMERA_I2C_BYTE_DATA;
@@ -282,6 +282,39 @@ int32_t msm_camera_cci_i2c_write_table_w_microdelay(
 	rc = cci_ctrl.status;
 	return rc;
 }
+#ifdef CONFIG_IMX214_APP
+int32_t z7_msm_camera_cci_i2c_write_seq_microdelay(
+	struct msm_camera_i2c_client *client,
+	struct msm_camera_i2c_reg_array *reg_tbl, uint16_t size,
+	enum msm_camera_i2c_data_type data_type)
+{
+	int i;
+	int32_t rc = -EFAULT;
+	uint8_t data[8];
+	memset(data, 0x00, 8);
+	if (!client || !reg_tbl)
+		return rc;
+
+	if ((client->addr_type != MSM_CAMERA_I2C_BYTE_ADDR
+		&& client->addr_type != MSM_CAMERA_I2C_WORD_ADDR)
+		|| (data_type != MSM_CAMERA_I2C_BYTE_DATA
+		&& data_type != MSM_CAMERA_I2C_WORD_DATA))
+		return rc;
+
+	for (i = 0; i < size; i++) {
+		data[0] = (reg_tbl->reg_data & 0xFF00) >> 8;
+		data[1] = reg_tbl->reg_data & 0xFF;
+		rc = msm_camera_cci_i2c_write_seq(client, reg_tbl->reg_addr,
+			data, 8);
+		if (rc < 0)
+			return rc;
+		if (reg_tbl->delay)
+			usleep_range(reg_tbl->delay, reg_tbl->delay + 1000);
+		reg_tbl++;
+	}
+	return rc;
+}
+#endif
 
 static int32_t msm_camera_cci_i2c_compare(struct msm_camera_i2c_client *client,
 	uint32_t addr, uint16_t data,
diff --git a/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c b/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c
index 284dd23..09dbc01 100755
--- a/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c
@@ -752,6 +752,68 @@ int msm_camera_init_gpio_pin_tbl(struct device_node *of_node,
 			gconf->gpio_num_info->gpio_num[SENSOR_GPIO_VDIG]);
 	}
 
+#ifdef CONFIG_ZTE_CAMERA_NX506J
+	if (of_property_read_bool(of_node, "qcom,gpio-dvdd") == true) {
+		rc = of_property_read_u32(of_node, "qcom,gpio-dvdd", &val);
+		if (rc < 0) {
+			pr_err("%s:%d read qcom,gpio-dvdd failed rc %d\n",
+				__func__, __LINE__, rc);
+			goto ERROR;
+		} else if (val >= gpio_array_size) {
+			pr_err("%s:%d qcom,gpio-dvdd invalid %d\n",
+				__func__, __LINE__, val);
+			goto ERROR;
+		}
+		gconf->gpio_num_info->gpio_num[SENSOR_GPIO_VIO] =
+			gpio_array[val];
+		gconf->gpio_num_info->valid[SENSOR_GPIO_VIO] = 1;
+		CDBG("%s qcom,gpio-dvdd %d\n", __func__,
+			gconf->gpio_num_info->gpio_num[SENSOR_GPIO_VIO]);
+	}
+
+#endif
+
+#if defined(CONFIG_ZTE_CAMERA_Z7)||defined(CONFIG_ZTE_CAMERA_NX504J)
+	if (of_property_read_bool(of_node, "qcom,gpio-vaf") == true) {
+		rc = of_property_read_u32(of_node, "qcom,gpio-vaf", &val);
+		if (rc < 0) {
+			pr_err("%s:%d read qcom,gpio-vaf failed rc %d\n",
+				__func__, __LINE__, rc);
+			goto ERROR;
+		} else if (val >= gpio_array_size) {
+			pr_err("%s:%d qcom,gpio-vaf invalid %d\n",
+				__func__, __LINE__, val);
+			goto ERROR;
+		}
+		gconf->gpio_num_info->gpio_num[SENSOR_GPIO_VAF] =
+			gpio_array[val];
+		gconf->gpio_num_info->valid[SENSOR_GPIO_VAF] = 1;
+
+		CDBG("%s qcom,gpio-vaf %d\n", __func__,
+			gconf->gpio_num_info->gpio_num[SENSOR_GPIO_VAF]);
+	}
+
+#endif
+#ifdef CONFIG_ZTE_CAMERA_NX504J
+if (of_property_read_bool(of_node, "qcom,gpio-vana") == true) {
+		rc = of_property_read_u32(of_node, "qcom,gpio-vana", &val);
+		if (rc < 0) {
+			pr_err("%s:%d read qcom,gpio-vana failed rc %d\n",
+				__func__, __LINE__, rc);
+			goto ERROR;
+		} else if (val >= gpio_array_size) {
+			pr_err("%s:%d qcom,gpio-vana invalid %d\n",
+				__func__, __LINE__, val);
+			goto ERROR;
+		}
+		gconf->gpio_num_info->gpio_num[SENSOR_GPIO_VANA] =
+			gpio_array[val];
+		gconf->gpio_num_info->valid[SENSOR_GPIO_VANA] = 1;
+
+		CDBG("%s qcom,gpio-vana %d\n", __func__,
+			gconf->gpio_num_info->gpio_num[SENSOR_GPIO_VANA]);
+	}
+#endif
 	if (of_property_read_bool(of_node, "qcom,gpio-reset") == true) {
 		rc = of_property_read_u32(of_node, "qcom,gpio-reset", &val);
 		if (rc < 0) {
@@ -949,14 +1011,13 @@ static int msm_camera_disable_i2c_mux(struct msm_camera_i2c_conf *i2c_conf)
 		VIDIOC_MSM_I2C_MUX_RELEASE, NULL);
 	return 0;
 }
-
+	
 int msm_camera_power_up(struct msm_camera_power_ctrl_t *ctrl,
 	enum msm_camera_device_type_t device_type,
 	struct msm_camera_i2c_client *sensor_i2c_client)
 {
 	int rc = 0, index = 0, no_gpio = 0;
 	struct msm_sensor_power_setting *power_setting = NULL;
-
 	CDBG("%s:%d\n", __func__, __LINE__);
 	if (!ctrl || !sensor_i2c_client) {
 		pr_err("failed ctrl %p sensor_i2c_client %p\n", ctrl,
@@ -1055,7 +1116,7 @@ int msm_camera_power_up(struct msm_camera_power_ctrl_t *ctrl,
 				(power_setting->delay * 1000) + 1000);
 		}
 	}
-#if defined(CONFIG_IMX135_Z5S_069) || defined(CONFIG_IMX135_Z5S)
+#if defined(CONFIG_IMX135_Z5S_069) || defined(CONFIG_IMX135_Z5S) || defined(CONFIG_IMX214_APP) || defined(CONFIG_IMX135_GBAO) || defined(CONFIG_IMX135_GBAO_LC898122)
 #else
 	if (device_type == MSM_CAMERA_PLATFORM_DEVICE) {
 		rc = sensor_i2c_client->i2c_func_tbl->i2c_util(
@@ -1070,12 +1131,12 @@ int msm_camera_power_up(struct msm_camera_power_ctrl_t *ctrl,
 	return 0;
 power_up_failed:
 	pr_err("%s:%d failed\n", __func__, __LINE__);
-#if defined(CONFIG_IMX135_Z5S_069) || defined(CONFIG_IMX135_Z5S)
+#if defined(CONFIG_IMX135_Z5S_069) || defined(CONFIG_IMX135_Z5S) || defined(CONFIG_IMX214_APP) || defined(CONFIG_IMX135_GBAO) || defined(CONFIG_IMX135_GBAO_LC898122)
 #else
-	/*if (device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+	if (device_type == MSM_CAMERA_PLATFORM_DEVICE) {
 		sensor_i2c_client->i2c_func_tbl->i2c_util(
 			sensor_i2c_client, MSM_CCI_RELEASE);
-	}*/
+	}
 #endif
 	for (index--; index >= 0; index--) {
 		CDBG("%s index %d\n", __func__, index);
@@ -1145,6 +1206,55 @@ msm_camera_get_power_settings(struct msm_camera_power_ctrl_t *ctrl,
 	}
 	return ps;
 }
+#ifdef CONFIG_IMX135_GBAO
+extern int ois_init_flag_down;
+extern void	SetH1cMod( unsigned char	UcSetNum );
+extern void RegReadA(unsigned short reg_addr, unsigned char *read_data_8);
+extern void RegWriteA(unsigned short reg_addr, unsigned char write_data_8);
+extern void RamReadA(unsigned short ram_addr, void *read_data_16);
+extern void RamWriteA(unsigned short ram_addr, unsigned short write_data_16);
+extern void RamRead32A(unsigned short ram_addr, void *read_data_32);
+extern void RamWrite32A(unsigned short ram_addr, unsigned long write_data_32);
+
+extern unsigned char RtnCen(unsigned char	UcCmdPar);
+extern void SetPanTiltMode(unsigned char UcPnTmod);
+
+extern void OisEna(void);
+extern void	IniSet( void );
+extern void	SrvCon( unsigned char	UcDirSel, unsigned char	UcSwcCon );
+extern void	S2cPro( unsigned char uc_mode );
+extern void msm_ois_init_cci(void);
+extern void msm_ois_release_cci(void);
+
+#endif
+#ifdef CONFIG_IMX135_GBAO_LC898122
+extern int ois_init_flag_down_lc898122;
+extern void read_ois_byte_data_lc898122(unsigned short reg_addr, unsigned char *read_data_8);
+extern void read_ois_word_data_lc898122(unsigned short reg_addr, uint16_t *read_data_16);
+
+extern void	SetH1cMod_lc898122( unsigned char	UcSetNum );
+extern void RegReadA_lc898122(unsigned short reg_addr, unsigned char *read_data_8);
+extern void RegWriteA_lc898122(unsigned short reg_addr, unsigned char write_data_8);
+extern void RamReadA_lc898122(unsigned short ram_addr, void *read_data_16);
+extern void RamWriteA_lc898122(unsigned short ram_addr, unsigned short write_data_16);
+extern void RamRead32A_lc898122(unsigned short ram_addr, void *read_data_32);
+extern void RamWrite32A_lc898122(unsigned short ram_addr, unsigned long write_data_32);
+
+extern unsigned char RtnCen_lc898122(unsigned char	UcCmdPar);
+extern void SetPanTiltMode_lc898122(unsigned char UcPnTmod);
+
+extern void OisEna_lc898122(void);
+extern void	IniSet_lc898122( void );
+extern void	SrvCon_lc898122( unsigned char	UcDirSel, unsigned char	UcSwcCon );
+extern void	S2cPro_lc898122( unsigned char uc_mode );
+extern void msm_ois_init_cci_lc898122(void);
+extern void msm_ois_release_cci_lc898122(void);
+
+extern void RamAccFixMod_lc898122( unsigned char UcAccMod );
+extern void IniSetAf_lc898122( void );
+extern void	SetH1cMod_lc898122( unsigned char	UcSetNum );
+
+#endif
 
 int msm_camera_power_down(struct msm_camera_power_ctrl_t *ctrl,
 	enum msm_camera_device_type_t device_type,
@@ -1154,7 +1264,6 @@ int msm_camera_power_down(struct msm_camera_power_ctrl_t *ctrl,
 	struct msm_sensor_power_setting *pd = NULL;
 	struct msm_sensor_power_setting *ps;
 
-
 	CDBG("%s:%d\n", __func__, __LINE__);
 	if (!ctrl || !sensor_i2c_client) {
 		pr_err("failed ctrl %p sensor_i2c_client %p\n", ctrl,
diff --git a/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h b/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h
index 1bceb51..b9101ee 100755
--- a/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h
+++ b/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -41,6 +41,13 @@ struct msm_camera_i2c_fn_t {
 	int32_t (*i2c_write_table_w_microdelay)
 		(struct msm_camera_i2c_client *,
 		struct msm_camera_i2c_reg_setting *);
+	
+#ifdef CONFIG_IMX214_APP
+	int32_t (*z7_i2c_write_seq_microdelay)
+		(struct msm_camera_i2c_client *,
+		struct msm_camera_i2c_reg_array *, uint16_t,
+		enum msm_camera_i2c_data_type);
+#endif	
 	int32_t (*i2c_util)(struct msm_camera_i2c_client *, uint16_t);
 	int32_t (*i2c_write_conf_tbl)(struct msm_camera_i2c_client *client,
 		struct msm_camera_i2c_reg_conf *reg_conf_tbl, uint16_t size,
@@ -111,14 +118,16 @@ int32_t msm_camera_qup_i2c_write_seq_table(struct msm_camera_i2c_client *client,
 int32_t msm_camera_qup_i2c_write_table_w_microdelay(
 	struct msm_camera_i2c_client *client,
 	struct msm_camera_i2c_reg_setting *write_setting);
+#ifdef CONFIG_IMX214_APP
+int32_t z7_msm_camera_cci_i2c_write_seq_microdelay(
+	struct msm_camera_i2c_client *client,
+	struct msm_camera_i2c_reg_array *reg_tbl, uint16_t size,
+	enum msm_camera_i2c_data_type data_type);
+#endif
 
 int32_t msm_camera_qup_i2c_write_conf_tbl(
 	struct msm_camera_i2c_client *client,
 	struct msm_camera_i2c_reg_conf *reg_conf_tbl, uint16_t size,
 	enum msm_camera_i2c_data_type data_type);
 
-int32_t msm_camera_qup_i2c_poll(struct msm_camera_i2c_client *client,
-	uint32_t addr, uint16_t data,
-	enum msm_camera_i2c_data_type data_type);
-
 #endif
diff --git a/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_io_util.c b/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_io_util.c
index 7d369ff..46a0542 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_io_util.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_io_util.c
@@ -107,17 +107,6 @@ void msm_camera_io_memcpy(void __iomem *dest_addr,
 	msm_camera_io_dump(dest_addr, len);
 }
 
-void msm_camera_io_memcpy_mb(void __iomem *dest_addr,
-	void __iomem *src_addr, u32 len)
-{
-	int i;
-	u32 *d = (u32 *) dest_addr;
-	u32 *s = (u32 *) src_addr;
-
-	for (i = 0; i < (len / 4); i++)
-		msm_camera_io_w_mb(*s++, d++);
-}
-
 int msm_cam_clk_sel_src(struct device *dev, struct msm_cam_clk_info *clk_info,
 		struct msm_cam_clk_info *clk_src_info, int num_clk)
 {
diff --git a/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_io_util.h b/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_io_util.h
index 90925a9..2e6f809 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_io_util.h
+++ b/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_io_util.h
@@ -28,8 +28,6 @@ u32 msm_camera_io_r_mb(void __iomem *addr);
 void msm_camera_io_dump(void __iomem *addr, int size);
 void msm_camera_io_memcpy(void __iomem *dest_addr,
 		void __iomem *src_addr, u32 len);
-void msm_camera_io_memcpy_mb(void __iomem *dest_addr,
-	void __iomem *src_addr, u32 len);
 int msm_cam_clk_sel_src(struct device *dev, struct msm_cam_clk_info *clk_info,
 		struct msm_cam_clk_info *clk_src_info, int num_clk);
 int msm_cam_clk_enable(struct device *dev, struct msm_cam_clk_info *clk_info,
diff --git a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.c b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.c
index 6cd66a3..24401d55 100755
--- a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.c
@@ -396,7 +396,7 @@ static struct msm_cam_clk_info cam_8974_clk_info[] = {
 	[SENSOR_CAM_CLK] = {"cam_clk", 0},
 };
 
-#if defined(CONFIG_IMX135_Z5S_069) ||defined(CONFIG_IMX135_Z5S)
+#if defined(CONFIG_IMX135_Z5S_069) ||defined(CONFIG_IMX135_Z5S) || defined(CONFIG_IMX214_APP) || defined(CONFIG_IMX135_GBAO) || defined(CONFIG_IMX135_GBAO_LC898122)
 int temp_i2c_data_type = 0 ;
 static int RegRead8byte_adaptive(uint16_t reg_addr, struct msm_sensor_ctrl_t *s_ctrl)
 {
@@ -444,7 +444,9 @@ int msm_sensor_power_down(struct msm_sensor_ctrl_t *s_ctrl)
 	return msm_camera_power_down(power_info, sensor_device_type,
 		sensor_i2c_client);
 }
-
+#ifdef CONFIG_T4K35
+extern int32_t t4k35_otp_init_setting(struct msm_sensor_ctrl_t *s_ctrl);
+#endif
 int msm_sensor_power_up(struct msm_sensor_ctrl_t *s_ctrl)
 {
 	int rc;
@@ -452,7 +454,6 @@ int msm_sensor_power_up(struct msm_sensor_ctrl_t *s_ctrl)
 	struct msm_camera_i2c_client *sensor_i2c_client;
 	struct msm_camera_slave_info *slave_info;
 	const char *sensor_name;
-
 	if (!s_ctrl) {
 		pr_err("%s:%d failed: %p\n",
 			__func__, __LINE__, s_ctrl);
@@ -477,7 +478,7 @@ int msm_sensor_power_up(struct msm_sensor_ctrl_t *s_ctrl)
 	if (rc < 0)
 		return rc;
 	
-#if defined(CONFIG_IMX135_Z5S_069) ||defined(CONFIG_IMX135_Z5S)
+#if defined(CONFIG_IMX135_Z5S_069) ||defined(CONFIG_IMX135_Z5S) || defined(CONFIG_IMX214_APP) || defined(CONFIG_IMX135_GBAO) || defined(CONFIG_IMX135_GBAO_LC898122) 
       if (!strncmp(s_ctrl->sensordata->sensor_name, "imx135_z5s", 32)) {
 		s_ctrl->sensor_i2c_client->cci_client->sid = 0x1c >> 1;
 		if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
@@ -520,16 +521,135 @@ int msm_sensor_power_up(struct msm_sensor_ctrl_t *s_ctrl)
 		}
 		s_ctrl->sensor_i2c_client->cci_client->sid = s_ctrl->sensordata->slave_info->sensor_slave_addr >> 1;
 	}
+	if (!strncmp(s_ctrl->sensordata->sensor_name, "imx214_app", 32)) {
+		s_ctrl->sensor_i2c_client->cci_client->sid = 0x32 >> 1;
+		if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+			rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+				s_ctrl->sensor_i2c_client, MSM_CCI_INIT);
+			if (rc < 0) {
+				pr_err("%s cci_init failed\n", __func__);
+				goto power_up_failed;
+			}
+		}
+		//rc = RegRead8byte_adaptive(0x91, s_ctrl);
+		//printk("app after RegRead8byte_adaptive rc =%d\n",rc);
+		if (rc < 0) {
+				pr_err("%s cci_init failed\n", __func__);
+				goto power_up_failed;
+		}
+		if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+			s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+				s_ctrl->sensor_i2c_client, MSM_CCI_RELEASE);
+		}
+		s_ctrl->sensor_i2c_client->cci_client->sid = s_ctrl->sensordata->slave_info->sensor_slave_addr >> 1;
+	}
+	if (!strncmp(s_ctrl->sensordata->sensor_name, "imx135_gbao", 32)) {
+		s_ctrl->sensor_i2c_client->cci_client->sid = 0x1c >> 1;
+		if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+			rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+				s_ctrl->sensor_i2c_client, MSM_CCI_INIT);
+			if (rc < 0) {
+				pr_err("%s cci_init failed\n", __func__);
+				goto power_up_failed;
+			}
+		}
+		rc = RegRead8byte_adaptive(0x91, s_ctrl);
+		if (rc < 0) {
+				pr_err("%s cci_init failed\n", __func__);
+				goto power_up_failed;
+		}
+		if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+			s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+				s_ctrl->sensor_i2c_client, MSM_CCI_RELEASE);
+		}
+		s_ctrl->sensor_i2c_client->cci_client->sid = s_ctrl->sensordata->slave_info->sensor_slave_addr >> 1;
+	}
+
+	if (!strncmp(s_ctrl->sensordata->sensor_name, "imx135_gbao_lc898122", 32)) {
+	
+			  s_ctrl->sensor_i2c_client->cci_client->sid = 0x48 >> 1;
+		temp_i2c_data_type = s_ctrl->sensor_i2c_client->addr_type;
+		s_ctrl->sensor_i2c_client->addr_type = MSM_CAMERA_I2C_WORD_ADDR;
+
+		if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+			
+			rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+				s_ctrl->sensor_i2c_client, MSM_CCI_INIT);
+			if (rc < 0) {
+				pr_err("%s cci_init failed\n", __func__);
+				goto power_up_failed;
+			}
+		}
+		if (rc < 0) {
+				pr_err("%s cci_init failed\n", __func__);
+				goto power_up_failed;
+		}
+		if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+			s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+				s_ctrl->sensor_i2c_client, MSM_CCI_RELEASE);
+		}
+		
+		s_ctrl->sensor_i2c_client->cci_client->sid = s_ctrl->sensordata->slave_info->sensor_slave_addr >> 1;
+		s_ctrl->sensor_i2c_client->addr_type = temp_i2c_data_type;
+
+	}
+	if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+			rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+				s_ctrl->sensor_i2c_client, MSM_CCI_INIT);
+			if (rc < 0) {
+				pr_err("%s cci_init failed\n", __func__);
+				goto power_up_failed;
+			}
+	}
 		
 #endif
+#ifdef CONFIG_IMX214_LC898122
+ if (!strncmp(s_ctrl->sensordata->sensor_name, "imx214_lc898122", 32)) {
+		s_ctrl->sensor_i2c_client->cci_client->sid = 0xA8 >> 1;
+		gbao_temp_i2c_data_type = s_ctrl->sensor_i2c_client->addr_type;
+		s_ctrl->sensor_i2c_client->addr_type = MSM_CAMERA_I2C_BYTE_ADDR;
+		
+		if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+			rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+				s_ctrl->sensor_i2c_client, MSM_CCI_INIT);
+			if (rc < 0) {
+				pr_err("%s cci_init failed\n", __func__);
+				goto power_up_failed;
+			}
+		}
 
+		//check if it is gbao module
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_read(
+			                     s_ctrl->sensor_i2c_client,0x06,
+						(uint16_t *)&gbao_module_id, MSM_CAMERA_I2C_BYTE_DATA);
+
+		printk(" gbao_module_id = 0x%x\n",gbao_module_id);
+		
+		if (gbao_module_id != 0x15) {
+				pr_err("%s cci_init failed\n", __func__);
+				goto power_up_failed;
+		}
+		if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+			s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+				s_ctrl->sensor_i2c_client, MSM_CCI_RELEASE);
+		}
+		s_ctrl->sensor_i2c_client->cci_client->sid = s_ctrl->sensordata->slave_info->sensor_slave_addr >> 1;
+		s_ctrl->sensor_i2c_client->addr_type = gbao_temp_i2c_data_type;
+	}
+ #endif
 	rc = msm_sensor_check_id(s_ctrl);
+#ifdef CONFIG_T4K35
+       if ((strcmp(sensor_name,"t4k35") == 0) && rc == 0){
+	    
+           t4k35_otp_init_setting(s_ctrl);
+	    printk("after t4k35_otp_init_setting\n");
+       }
+#endif
 	if (rc < 0)
 		msm_camera_power_down(power_info, s_ctrl->sensor_device_type,
 					sensor_i2c_client);
-
 	return rc;
-#if defined(CONFIG_IMX135_Z5S_069) ||defined(CONFIG_IMX135_Z5S)
+#if defined(CONFIG_IMX135_Z5S_069) ||defined(CONFIG_IMX135_Z5S) || defined(CONFIG_IMX214_APP) || defined(CONFIG_IMX135_GBAO) || defined(CONFIG_IMX135_GBAO_LC898122) || defined(CONFIG_IMX214_LC898122)|| defined(CONFIG_IMX214_OIS_SHARP)  
 	power_up_failed:	
 		msm_camera_power_down(power_info, s_ctrl->sensor_device_type,
 			sensor_i2c_client);
@@ -815,8 +935,7 @@ int msm_sensor_config(struct msm_sensor_ctrl_t *s_ctrl, void __user *argp)
 			break;
 		}
 
-		if ((!conf_array.size) ||
-			(conf_array.size > I2C_USER_REG_DATA_MAX )) {
+		if (!conf_array.size) {
 			pr_err("%s:%d failed\n", __func__, __LINE__);
 			rc = -EFAULT;
 			break;
@@ -837,7 +956,6 @@ int msm_sensor_config(struct msm_sensor_ctrl_t *s_ctrl, void __user *argp)
 			rc = -EFAULT;
 			break;
 		}
-
 		conf_array.reg_setting = reg_setting;
 		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write_table(
 			s_ctrl->sensor_i2c_client, &conf_array);
@@ -990,8 +1108,7 @@ int msm_sensor_config(struct msm_sensor_ctrl_t *s_ctrl, void __user *argp)
 			break;
 		}
 
-		if ((!conf_array.size) ||
-			(conf_array.size > I2C_USER_REG_DATA_MAX )) {
+		if (!conf_array.size) {
 			pr_err("%s:%d failed\n", __func__, __LINE__);
 			rc = -EFAULT;
 			break;
@@ -1139,25 +1256,89 @@ int msm_sensor_config(struct msm_sensor_ctrl_t *s_ctrl, void __user *argp)
 				if(value == 79)
 					lens_position = 900;   /* push the VCM to Macro position*/
 
+	#if defined (CONFIG_IMX214) || defined(CONFIG_IMX135_GBAO) || defined(CONFIG_IMX135_GBAO_LC898122)
+                if(!strncmp(s_ctrl->sensordata->sensor_name, "imx214", 32)){
+					MSB = ( lens_position & 0x0300 ) >> 8;
+					LSB = lens_position & 0xFF;
+					lens_position = lens_position | 0xF400;
+					addr = (lens_position & 0xFF00) >> 8;
+					data = lens_position & 0xFF;
+					printk("<<<ZTEMT_JHL>>> addr = 0x%x, data = 0x%x\n",addr,data);
+				    ZtemtMoveFocus(addr,data);
+                }
+				if(!strncmp(s_ctrl->sensordata->sensor_name, "imx135_gbao", 32)){
+					enum msm_camera_i2c_reg_addr_type temp_addr_type;
+					MSB = ( lens_position & 0x0300 ) >> 8;
+					LSB = lens_position & 0xFF;
+		            s_ctrl->sensor_i2c_client->cci_client->sid = 0x1C >> 1;
+		            temp_addr_type = s_ctrl->sensor_i2c_client->addr_type;
+		            s_ctrl->sensor_i2c_client->addr_type = MSM_CAMERA_I2C_BYTE_ADDR;
+	                s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(
+				      s_ctrl->sensor_i2c_client, 0x03,
+				      MSB, MSM_CAMERA_I2C_BYTE_DATA);
+				    s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(
+				      s_ctrl->sensor_i2c_client, 0x04,
+				      LSB, MSM_CAMERA_I2C_BYTE_DATA);
+		            s_ctrl->sensor_i2c_client->cci_client->sid =
+			           s_ctrl->sensordata->slave_info->sensor_slave_addr >> 1;
+		            s_ctrl->sensor_i2c_client->addr_type = temp_addr_type;
+				}
+				if(!strncmp(s_ctrl->sensordata->sensor_name, "imx135_gbao_lc898122", 32)){
+					enum msm_camera_i2c_reg_addr_type temp_addr_type;
+					MSB = ((lens_position & 0x0700) >> 8)|0x04;
+					LSB = lens_position & 0xFF;
+		            s_ctrl->sensor_i2c_client->cci_client->sid = 0x48 >> 1;
+		            temp_addr_type = s_ctrl->sensor_i2c_client->addr_type;
+		            s_ctrl->sensor_i2c_client->addr_type = MSM_CAMERA_I2C_WORD_ADDR;
+	                s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(
+				      s_ctrl->sensor_i2c_client, 0x0304,
+				      MSB, MSM_CAMERA_I2C_BYTE_DATA);
+					s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write(
+				      s_ctrl->sensor_i2c_client, 0x0305,
+				      LSB, MSM_CAMERA_I2C_BYTE_DATA);
+		            s_ctrl->sensor_i2c_client->cci_client->sid =
+			           s_ctrl->sensordata->slave_info->sensor_slave_addr >> 1;
+		            s_ctrl->sensor_i2c_client->addr_type = temp_addr_type;
+				}
+	#else
 				MSB = ( lens_position & 0x0300 ) >> 8;
 				LSB = lens_position & 0xFF;
 				lens_position = lens_position | 0xF400;
 				addr = (lens_position & 0xFF00) >> 8;
 				data = lens_position & 0xFF;
 				printk("<<<ZTEMT_JHL>>> This sensor not support Manual AF\n");
+	#endif
 			}
 		break;
 	  }
 	/* ZTEMT: Jinghongliang Add for Manual AF Mode ----End */
 	//	#ifdef CONFIG_ZTEMT_CAMERA_OIS   //ZTEMT CAMERA FOR OIS MENU ----START
     case CFG_ENABLE_OIS: {
+		#if defined(CONFIG_IMX135_GBAO_LC898122) || defined(CONFIG_IMX135_GBAO)
+		//printk("csh enable\n");
+		if(!strncmp(s_ctrl->sensordata->sensor_name, "imx135_gbao_lc898122", 32))
+			OisEna_lc898122();
+		if(!strncmp(s_ctrl->sensordata->sensor_name, "imx135_gbao", 32)){
+			OisEna();		
+		    SetH1cMod(0xff);
+		}
+		#endif
 		break;
 	}
 
     case CFG_DISABLE_OIS: {
+		
+     #if defined(CONFIG_IMX135_GBAO_LC898122) || defined(CONFIG_IMX135_GBAO)
+		//printk("csh disable\n");
+		if(!strncmp(s_ctrl->sensordata->sensor_name, "imx135_gbao_lc898122", 32))
+			RtnCen_lc898122(0x00);
+		if(!strncmp(s_ctrl->sensordata->sensor_name, "imx135_gbao", 32))
+			RtnCen(0x00);
+	 #endif
 		break;
 	}
 
+//	#endif                           //ZTEMT CAMERA FOR OIS MENU ----END
 	default:
 		rc = -EFAULT;
 		break;
@@ -1237,7 +1418,7 @@ static struct msm_camera_i2c_fn_t msm_sensor_cci_func_tbl = {
 		msm_camera_cci_i2c_write_table_w_microdelay,
 	.i2c_util = msm_sensor_cci_i2c_util,
 	.i2c_write_conf_tbl = msm_camera_cci_i2c_write_conf_tbl,
-#ifdef CONFIG_IMX135_Z5S
+#if defined(CONFIG_IMX214_APP) || defined(CONFIG_IMX135_GBAO) || defined(CONFIG_IMX135_GBAO_LC898122) || defined(CONFIG_IMX135_Z5S) || defined(CONFIG_IMX214_OIS_SHARP)|| defined(CONFIG_IMX214_LC898122)
 	.i2c_write_seq = msm_camera_cci_i2c_write_seq,
 #endif
 
@@ -1262,7 +1443,6 @@ int32_t msm_sensor_platform_probe(struct platform_device *pdev, void *data)
 	struct msm_camera_cci_client *cci_client = NULL;
 	uint32_t session_id;
 	unsigned long mount_pos;
-
 	s_ctrl->pdev = pdev;
 	CDBG("%s called data %p\n", __func__, data);
 	CDBG("%s pdev name %s\n", __func__, pdev->id_entry->name);
@@ -1315,7 +1495,33 @@ int32_t msm_sensor_platform_probe(struct platform_device *pdev, void *data)
 		kfree(cci_client);
 		return rc;
 	}
-
+	#ifdef CONFIG_IMX214 //added for eeprom judge
+	if (!strncmp(s_ctrl->sensordata->sensor_name, "imx214", 32)) {
+		uint16_t temp_eeprom = 0;
+		enum msm_camera_i2c_reg_addr_type temp_addr_type;
+		cci_client->sid = 0xA0 >> 1;
+		temp_addr_type = s_ctrl->sensor_i2c_client->addr_type;
+		s_ctrl->sensor_i2c_client->addr_type = MSM_CAMERA_I2C_BYTE_ADDR;
+	    s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_read(
+				s_ctrl->sensor_i2c_client, 0x13,
+				&temp_eeprom, MSM_CAMERA_I2C_BYTE_DATA);
+		cci_client->sid =
+			s_ctrl->sensordata->slave_info->sensor_slave_addr >> 1;
+		s_ctrl->sensor_i2c_client->addr_type = temp_addr_type;
+		if (temp_eeprom == 0xFF) {
+			s_ctrl->sensordata->sensor_info->subdev_id[SUB_MODULE_EEPROM] = -1;
+		}
+		
+		printk("csh temp=%x\n", temp_eeprom);
+		#if 0
+		s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_read(
+				s_ctrl->sensor_i2c_client, 0x0018,
+				&temp_eeprom, MSM_CAMERA_I2C_WORD_DATA);
+		
+		printk("csh temp=%x\n", temp_eeprom);
+		#endif
+	}
+	#endif
 	CDBG("%s %s probe succeeded\n", __func__,
 		s_ctrl->sensordata->sensor_name);
 	v4l2_subdev_init(&s_ctrl->msm_sd.sd,
@@ -1341,6 +1547,11 @@ int32_t msm_sensor_platform_probe(struct platform_device *pdev, void *data)
 	s_ctrl->sensordata->sensor_info->session_id = session_id;
 	s_ctrl->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x3;
 	msm_sd_register(&s_ctrl->msm_sd);
+#if defined(CONFIG_IMX214_APP)
+	if (!strncmp(s_ctrl->sensordata->sensor_name, "imx214_app", 32)) {
+		imx214_app_update_wb_register_from_otp(s_ctrl);
+	}
+#endif
 	CDBG("%s:%d\n", __func__, __LINE__);
 
 	s_ctrl->func_tbl->sensor_power_down(s_ctrl);
diff --git a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.h b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.h
index 0f77567..852004b 100755
--- a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.h
+++ b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.h
@@ -54,7 +54,6 @@ struct msm_sensor_fn_t {
 struct msm_sensor_ctrl_t {
 	struct platform_device *pdev;
 	struct mutex *msm_sensor_mutex;
-
 	enum msm_camera_device_type_t sensor_device_type;
 	struct msm_camera_sensor_board_info *sensordata;
 	struct msm_sensor_power_setting_array power_setting_array;
diff --git a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor_driver.c b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor_driver.c
index 06c1adc..772ed0e 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor_driver.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor_driver.c
@@ -397,13 +397,6 @@ int32_t msm_sensor_driver_probe(void *setting)
 	}
 
 	size = slave_info->power_setting_array.size;
-	/* Validate size */
-	if (size > MAX_POWER_CONFIG) {
-		pr_err("failed: invalid number of power_up_setting %d\n", size);
-		rc = -EINVAL;
-		goto FREE_SLAVE_INFO;
-	}
-
 	/* Allocate memory for power up setting */
 	power_setting = kzalloc(sizeof(*power_setting) * size, GFP_KERNEL);
 	if (!power_setting) {
@@ -430,12 +423,6 @@ int32_t msm_sensor_driver_probe(void *setting)
 	size_down = slave_info->power_setting_array.size_down;
 	if (!size_down)
 		size_down = size;
-	/* Validate size_down */
-	if (size_down > MAX_POWER_CONFIG) {
-		pr_err("failed: invalid size_down %d", size_down);
-		rc = -EINVAL;
-		goto FREE_POWER_SETTING;
-	}
 	/* Allocate memory for power down setting */
 	power_down_setting =
 		kzalloc(sizeof(*power_setting) * size_down, GFP_KERNEL);
@@ -806,6 +793,7 @@ static int32_t msm_sensor_driver_get_dt_data(struct msm_sensor_ctrl_t *s_ctrl)
 	if (rc < 0) {
 		pr_err("%s:%d Invalid sensor position\n", __func__, __LINE__);
 		sensordata->sensor_info->position = INVALID_CAMERA_B;
+		rc = 0;
 	}
 
 	rc = of_property_read_u32(of_node, "qcom,sensor-mode",
diff --git a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor_init.c b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor_init.c
index c848287..bc96eb8 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor_init.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor_init.c
@@ -48,19 +48,21 @@ static const struct v4l2_subdev_internal_ops msm_sensor_init_internal_ops;
 static int msm_sensor_wait_for_probe_done(struct msm_sensor_init_t *s_init)
 {
 	int rc;
-	int tm = 10000;
+
 	if (s_init->module_init_status == 1) {
-		CDBG("msm_cam_get_module_init_status -2\n");
+		pr_err("msm_cam_get_module_init_status -2\n");
 		return 0;
 	}
-	rc = wait_event_interruptible_timeout(s_init->state_wait,
-		(s_init->module_init_status == 1), msecs_to_jiffies(tm));
-	if (rc < 0)
-		pr_err("%s:%d wait failed\n", __func__, __LINE__);
-	else if (rc == 0)
-		pr_err("%s:%d wait timeout\n", __func__, __LINE__);
 
-	return rc;
+	while (1) {
+		rc = wait_event_interruptible(s_init->state_wait,
+			(s_init->module_init_status == 1));
+		if (rc == -ETIMEDOUT)
+			continue;
+		else if (rc == 0)
+			break;
+	}
+	return 0;
 }
 
 /* Static function definition */
@@ -137,7 +139,7 @@ static int __init msm_sensor_init_module(void)
 		return -ENOMEM;
 	}
 
-	CDBG("MSM_SENSOR_INIT_MODULE %p", NULL);
+	pr_err("MSM_SENSOR_INIT_MODULE %p", NULL);
 
 	/* Initialize mutex */
 	mutex_init(&s_init->imutex);
diff --git a/drivers/media/platform/msm/camera_v2/sensor/mt9m114.c b/drivers/media/platform/msm/camera_v2/sensor/mt9m114.c
index d0049db..1d58490 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/mt9m114.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/mt9m114.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -1330,13 +1330,6 @@ int32_t mt9m114_sensor_config(struct msm_sensor_ctrl_t *s_ctrl,
 			break;
 		}
 
-		if ((!conf_array.size) ||
-			(conf_array.size > I2C_SEQ_REG_DATA_MAX)) {
-			pr_err("%s:%d failed\n", __func__, __LINE__);
-			rc = -EFAULT;
-			break;
-		}
-
 		reg_setting = kzalloc(conf_array.size *
 			(sizeof(struct msm_camera_i2c_reg_array)), GFP_KERNEL);
 		if (!reg_setting) {
@@ -1371,12 +1364,6 @@ int32_t mt9m114_sensor_config(struct msm_sensor_ctrl_t *s_ctrl,
 			break;
 		}
 
-		if ((!conf_array.size) ||
-			(conf_array.size > I2C_SEQ_REG_DATA_MAX)) {
-			pr_err("%s:%d failed\n", __func__, __LINE__);
-			rc = -EFAULT;
-			break;
-		}
 		reg_setting = kzalloc(conf_array.size *
 			(sizeof(struct msm_camera_i2c_seq_reg_array)),
 			GFP_KERNEL);
diff --git a/drivers/media/platform/msm/camera_v2/sensor/ov5648_z7mini.c b/drivers/media/platform/msm/camera_v2/sensor/ov5648_z7mini.c
new file mode 100755
index 0000000..74a8cb5
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/ov5648_z7mini.c
@@ -0,0 +1,221 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include "msm_sensor.h"
+
+#define OV5648_SENSOR_NAME "ov5648"
+DEFINE_MSM_MUTEX(ov5648_mut);
+static struct msm_sensor_ctrl_t ov5648_s_ctrl;
+
+static struct msm_sensor_power_setting ov5648_power_setting[] = {
+#if 0
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VIO,
+		.config_val = 0,
+		.delay = 0,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VANA,
+		.config_val = 0,
+		.delay = 5,
+	},
+#endif
+
+#if defined(CONFIG_ZTE_CAMERA_NX507J) || defined(CONFIG_ZTE_CAMERA_NX505J)   
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = 1,
+		.config_val = 0,
+		.delay = 5,
+	},
+
+
+#else
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+#endif
+
+#if defined(CONFIG_ZTE_CAMERA_NX505J) || defined(CONFIG_ZTE_CAMERA_Z7MINI)|| defined(CONFIG_ZTE_CAMERA_NX506J)
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 1,
+	},
+#endif
+
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 10,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 10,
+	},
+	{
+		.seq_type = SENSOR_CLK,
+		.seq_val = SENSOR_CAM_MCLK,
+		.config_val = 24000000,
+		.delay = 10,
+	},
+	{
+		.seq_type = SENSOR_I2C_MUX,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+};
+
+static struct v4l2_subdev_info ov5648_subdev_info[] = {
+	{
+		.code   = V4L2_MBUS_FMT_SBGGR10_1X10,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.fmt    = 1,
+		.order    = 0,
+	},
+};
+
+static const struct i2c_device_id ov5648_i2c_id[] = {
+	{OV5648_SENSOR_NAME,
+		(kernel_ulong_t)&ov5648_s_ctrl},
+	{ }
+};
+
+static int32_t msm_ov5648_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	return msm_sensor_i2c_probe(client, id, &ov5648_s_ctrl);
+}
+
+static struct i2c_driver ov5648_i2c_driver = {
+	.id_table = ov5648_i2c_id,
+	.probe  = msm_ov5648_i2c_probe,
+	.driver = {
+		.name = OV5648_SENSOR_NAME,
+	},
+};
+
+static struct msm_camera_i2c_client ov5648_sensor_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+};
+
+static struct msm_sensor_ctrl_t ov5648_s_ctrl = {
+	.sensor_i2c_client = &ov5648_sensor_i2c_client,
+	.power_setting_array.power_setting = ov5648_power_setting,
+	.power_setting_array.size =
+			ARRAY_SIZE(ov5648_power_setting),
+	.msm_sensor_mutex = &ov5648_mut,
+	.sensor_v4l2_subdev_info = ov5648_subdev_info,
+	.sensor_v4l2_subdev_info_size =
+			ARRAY_SIZE(ov5648_subdev_info),
+};
+
+static const struct of_device_id ov5648_dt_match[] = {
+	{
+		.compatible = "qcom,ov5648",
+		.data = &ov5648_s_ctrl
+	},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, ov5648_dt_match);
+
+static struct platform_driver ov5648_platform_driver = {
+	.driver = {
+		.name = "qcom,ov5648",
+		.owner = THIS_MODULE,
+		.of_match_table = ov5648_dt_match,
+	},
+};
+
+static int32_t ov5648_platform_probe(struct platform_device *pdev)
+{
+	int32_t rc = 0;
+	const struct of_device_id *match;
+
+	match = of_match_device(ov5648_dt_match, &pdev->dev);
+	rc = msm_sensor_platform_probe(pdev, match->data);
+	return rc;
+}
+
+static int __init ov5648_z7mini_init_module(void)
+{
+	int32_t rc = 0;
+	printk("%s \n", __func__);
+	rc = platform_driver_probe(&ov5648_platform_driver,
+		ov5648_platform_probe);
+	if (!rc)
+		return rc;
+	return i2c_add_driver(&ov5648_i2c_driver);
+}
+
+static void __exit ov5648_z7mini_exit_module(void)
+{
+	if (ov5648_s_ctrl.pdev) {
+		msm_sensor_free_sensor_data(&ov5648_s_ctrl);
+		platform_driver_unregister(&ov5648_platform_driver);
+	} else
+		i2c_del_driver(&ov5648_i2c_driver);
+	return;
+}
+
+module_init(ov5648_z7mini_init_module);
+module_exit(ov5648_z7mini_exit_module);
+MODULE_DESCRIPTION("ov5648");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/msm/camera_v2/sensor/sp1628.c b/drivers/media/platform/msm/camera_v2/sensor/sp1628.c
index 69440d2..d4e4cdf 100755
--- a/drivers/media/platform/msm/camera_v2/sensor/sp1628.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/sp1628.c
@@ -771,13 +771,6 @@ int32_t sp1628_sensor_config(struct msm_sensor_ctrl_t *s_ctrl,
 			break;
 		}
 
-		if ((!conf_array.size) ||
-			(conf_array.size > I2C_SEQ_REG_DATA_MAX)) {
-			pr_err("%s:%d failed\n", __func__, __LINE__);
-			rc = -EFAULT;
-			break;
-		}
-
 		reg_setting = kzalloc(conf_array.size *
 			(sizeof(struct msm_camera_i2c_reg_array)), GFP_KERNEL);
 		if (!reg_setting) {
@@ -812,12 +805,6 @@ int32_t sp1628_sensor_config(struct msm_sensor_ctrl_t *s_ctrl,
 			break;
 		}
 
-		if ((!conf_array.size) ||
-			(conf_array.size > I2C_SEQ_REG_DATA_MAX)) {
-			pr_err("%s:%d failed\n", __func__, __LINE__);
-			rc = -EFAULT;
-			break;
-		}
 		reg_setting = kzalloc(conf_array.size *
 			(sizeof(struct msm_camera_i2c_seq_reg_array)),
 			GFP_KERNEL);
diff --git a/drivers/media/platform/msm/camera_v2/sensor/t4k35.c b/drivers/media/platform/msm/camera_v2/sensor/t4k35.c
new file mode 100755
index 0000000..f3525df
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/t4k35.c
@@ -0,0 +1,179 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include "msm_sensor.h"
+#define T4K35_SENSOR_NAME "t4k35"
+DEFINE_MSM_MUTEX(t4k35_mut);
+
+static struct msm_sensor_ctrl_t t4k35_s_ctrl;
+
+static struct msm_sensor_power_setting t4k35_power_setting[] = {
+
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VDIG,
+		.config_val = 0,
+		.delay = 0,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VIO,
+		.config_val = 0,
+		.delay = 0,
+	},
+#if 1 
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VANA,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VANA,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 5,
+	},
+#endif
+#if 1
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 30,
+	},
+#endif
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 30,
+	},
+	{
+		.seq_type = SENSOR_CLK,
+		.seq_val = SENSOR_CAM_MCLK,
+		.config_val = 24000000,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_I2C_MUX,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+};
+
+static struct v4l2_subdev_info t4k35_subdev_info[] = {
+	{
+		.code = V4L2_MBUS_FMT_SBGGR10_1X10,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.fmt = 1,
+		.order = 0,
+	},
+};
+
+static const struct i2c_device_id t4k35_i2c_id[] = {
+	{T4K35_SENSOR_NAME, (kernel_ulong_t)&t4k35_s_ctrl},
+	{ }
+};
+
+static int32_t msm_t4k35_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	return msm_sensor_i2c_probe(client, id, &t4k35_s_ctrl);
+}
+
+static struct i2c_driver t4k35_i2c_driver = {
+	.id_table = t4k35_i2c_id,
+	.probe  = msm_t4k35_i2c_probe,
+	.driver = {
+		.name = T4K35_SENSOR_NAME,
+	},
+};
+
+static struct msm_camera_i2c_client t4k35_sensor_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+};
+
+static const struct of_device_id t4k35_dt_match[] = {
+	{.compatible = "qcom,t4k35", .data = &t4k35_s_ctrl},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, t4k35_dt_match);
+
+static struct platform_driver t4k35_platform_driver = {
+	.driver = {
+		.name = "qcom,t4k35",
+		.owner = THIS_MODULE,
+		.of_match_table = t4k35_dt_match,
+	},
+};
+
+static int32_t t4k35_platform_probe(struct platform_device *pdev)
+{
+	int32_t rc = 0;
+	const struct of_device_id *match;
+	match = of_match_device(t4k35_dt_match, &pdev->dev);
+	rc = msm_sensor_platform_probe(pdev, match->data);
+	return rc;
+}
+
+static int __init t4k35_init_module(void)
+{
+	int32_t rc = 0;
+	pr_info("%s:%d\n", __func__, __LINE__);
+	rc = platform_driver_probe(&t4k35_platform_driver,
+		t4k35_platform_probe);
+	if (!rc)
+		return rc;
+	pr_err("%s:%d rc %d\n", __func__, __LINE__, rc);
+	return i2c_add_driver(&t4k35_i2c_driver);
+}
+
+static void __exit t4k35_exit_module(void)
+{
+	pr_info("%s:%d\n", __func__, __LINE__);
+	if (t4k35_s_ctrl.pdev) {
+		msm_sensor_free_sensor_data(&t4k35_s_ctrl);
+		platform_driver_unregister(&t4k35_platform_driver);
+	} else
+		i2c_del_driver(&t4k35_i2c_driver);
+	return;
+}
+
+static struct msm_sensor_ctrl_t t4k35_s_ctrl = {
+	.sensor_i2c_client = &t4k35_sensor_i2c_client,
+	.power_setting_array.power_setting = t4k35_power_setting,
+	.power_setting_array.size = ARRAY_SIZE(t4k35_power_setting),
+	//.zte_otp_enable = true,
+	.msm_sensor_mutex = &t4k35_mut,
+	.sensor_v4l2_subdev_info = t4k35_subdev_info,
+	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(t4k35_subdev_info),
+};
+
+module_init(t4k35_init_module);
+module_exit(t4k35_exit_module);
+MODULE_DESCRIPTION("t4k35");
+MODULE_LICENSE("GPL v2");
diff --git a/include/media/msm_cam_sensor.h b/include/media/msm_cam_sensor.h
index 845c7b6..e1bf782 100755
--- a/include/media/msm_cam_sensor.h
+++ b/include/media/msm_cam_sensor.h
@@ -12,8 +12,6 @@
 #define I2C_SEQ_REG_DATA_MAX      20
 #define MAX_CID                   16
 
-#define I2C_USER_REG_DATA_MAX 1024
-
 #define MSM_SENSOR_MCLK_8HZ   8000000
 #define MSM_SENSOR_MCLK_16HZ  16000000
 #define MSM_SENSOR_MCLK_24HZ  24000000
@@ -42,19 +40,14 @@
 #define MAX_ACTUATOR_REGION 5
 #define MAX_ACTUATOR_INIT_SET 12
 #define MAX_ACTUATOR_REG_TBL_SIZE 8
-#define MAX_ACTUATOR_AF_TOTAL_STEPS 1024
 
 #define MOVE_NEAR 0
 #define MOVE_FAR  1
 
-#define MSM_ACTUATOR_MOVE_SIGNED_FAR -1
-#define MSM_ACTUATOR_MOVE_SIGNED_NEAR  1
-
 #define MAX_EEPROM_NAME 32
 
 #define MAX_AF_ITERATIONS 3
 #define MAX_NUMBER_OF_STEPS 47
-#define MAX_POWER_CONFIG 12
 
 typedef enum sensor_stats_type {
 	YRGB,
@@ -502,8 +495,6 @@ enum msm_actuator_cfg_type_t {
 	CFG_SET_DEFAULT_FOCUS,
 	CFG_MOVE_FOCUS,
 	CFG_SET_POSITION,
-	CFG_ACTUATOR_POWERDOWN,
-	CFG_ACTUATOR_POWERUP,
 };
 
 enum actuator_type {
@@ -521,18 +512,9 @@ enum msm_actuator_addr_type {
 	MSM_ACTUATOR_WORD_ADDR,
 };
 
-enum msm_actuator_i2c_operation {
-	MSM_ACT_WRITE = 0,
-	MSM_ACT_POLL,
-};
-
 struct reg_settings_t {
 	uint16_t reg_addr;
-	enum msm_actuator_addr_type addr_type;
 	uint16_t reg_data;
-	enum msm_actuator_data_type data_type;
-	enum msm_actuator_i2c_operation i2c_operation;
-	uint32_t delay;
 };
 
 struct region_params_t {
diff --git a/include/media/msmb_isp.h b/include/media/msmb_isp.h
index e627977..3ba0abe 100644
--- a/include/media/msmb_isp.h
+++ b/include/media/msmb_isp.h
@@ -1,14 +1,3 @@
-/* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
 #ifndef __MSMB_ISP__
 #define __MSMB_ISP__
 
@@ -154,7 +143,6 @@ struct msm_vfe_axi_stream_request_cmd {
 	uint8_t buf_divert; /* if TRUE no vb2 buf done. */
 	/*Return values*/
 	uint32_t axi_stream_handle;
-	uint32_t burst_len;
 };
 
 struct msm_vfe_axi_stream_release_cmd {
@@ -226,7 +214,6 @@ struct msm_vfe_stats_stream_cfg_cmd {
 	uint8_t num_streams;
 	uint32_t stream_handle[MSM_ISP_STATS_MAX];
 	uint8_t enable;
-	uint32_t stats_burst_len;
 };
 
 enum msm_vfe_reg_cfg_type {
@@ -242,9 +229,6 @@ enum msm_vfe_reg_cfg_type {
 	VFE_READ_DMI_64BIT,
 	GET_SOC_HW_VER,
 	GET_MAX_CLK_RATE,
-	VFE_HW_UPDATE_LOCK,
-	VFE_HW_UPDATE_UNLOCK,
-	SET_WM_UB_SIZE,
 };
 
 struct msm_vfe_cfg_cmd2 {
@@ -318,16 +302,15 @@ enum msm_isp_event_idx {
 	ISP_WM_BUS_OVERFLOW = 4,
 	ISP_STATS_OVERFLOW  = 5,
 	ISP_CAMIF_ERROR     = 6,
-	ISP_BUF_DONE        = 9,
-	ISP_EVENT_MAX       = 10
+	ISP_SOF             = 7,
+	ISP_EOF             = 8,
+	ISP_EVENT_MAX       = 9
 };
 
 #define ISP_EVENT_OFFSET          8
 #define ISP_EVENT_BASE            (V4L2_EVENT_PRIVATE_START)
 #define ISP_BUF_EVENT_BASE        (ISP_EVENT_BASE + (1 << ISP_EVENT_OFFSET))
 #define ISP_STATS_EVENT_BASE      (ISP_EVENT_BASE + (2 << ISP_EVENT_OFFSET))
-#define ISP_SOF_EVENT_BASE        (ISP_EVENT_BASE + (3 << ISP_EVENT_OFFSET))
-#define ISP_EOF_EVENT_BASE        (ISP_EVENT_BASE + (4 << ISP_EVENT_OFFSET))
 #define ISP_EVENT_REG_UPDATE      (ISP_EVENT_BASE + ISP_REG_UPDATE)
 #define ISP_EVENT_START_ACK       (ISP_EVENT_BASE + ISP_START_ACK)
 #define ISP_EVENT_STOP_ACK        (ISP_EVENT_BASE + ISP_STOP_ACK)
@@ -335,9 +318,8 @@ enum msm_isp_event_idx {
 #define ISP_EVENT_WM_BUS_OVERFLOW (ISP_EVENT_BASE + ISP_WM_BUS_OVERFLOW)
 #define ISP_EVENT_STATS_OVERFLOW  (ISP_EVENT_BASE + ISP_STATS_OVERFLOW)
 #define ISP_EVENT_CAMIF_ERROR     (ISP_EVENT_BASE + ISP_CAMIF_ERROR)
-#define ISP_EVENT_SOF             (ISP_SOF_EVENT_BASE)
-#define ISP_EVENT_EOF             (ISP_EOF_EVENT_BASE)
-#define ISP_EVENT_BUF_DONE        (ISP_EVENT_BASE + ISP_BUF_DONE)
+#define ISP_EVENT_SOF             (ISP_EVENT_BASE + ISP_SOF)
+#define ISP_EVENT_EOF             (ISP_EVENT_BASE + ISP_EOF)
 #define ISP_EVENT_BUF_DIVERT      (ISP_BUF_EVENT_BASE)
 #define ISP_EVENT_STATS_NOTIFY    (ISP_STATS_EVENT_BASE)
 #define ISP_EVENT_COMP_STATS_NOTIFY (ISP_EVENT_STATS_NOTIFY + MSM_ISP_STATS_MAX)
diff --git a/include/media/msmb_pproc.h b/include/media/msmb_pproc.h
index f5a53a8..26c1048 100644
--- a/include/media/msmb_pproc.h
+++ b/include/media/msmb_pproc.h
@@ -13,10 +13,8 @@
 
 #define MAX_NUM_CPP_STRIPS 8
 #define MSM_CPP_MAX_NUM_PLANES 3
-#define MSM_CPP_MIN_FRAME_LENGTH 13
-#define MSM_CPP_MAX_FRAME_LENGTH 2048
+#define MSM_CPP_MAX_FRAME_LENGTH 1024
 #define MSM_CPP_MAX_FW_NAME_LEN 32
-#define MAX_FREQ_TBL 10
 
 enum msm_cpp_frame_type {
 	MSM_CPP_OFFLINE_FRAME,
@@ -128,8 +126,6 @@ struct msm_cpp_frame_info_t {
 struct cpp_hw_info {
 	uint32_t cpp_hw_version;
 	uint32_t cpp_hw_caps;
-	unsigned long freq_tbl[MAX_FREQ_TBL];
-	uint32_t freq_tbl_count;
 };
 
 struct msm_vpe_frame_strip_info {
@@ -236,9 +232,6 @@ struct msm_pproc_queue_buf_info {
 #define VIDIOC_MSM_CPP_APPEND_STREAM_BUFF_INFO \
 	_IOWR('V', BASE_VIDIOC_PRIVATE + 15, struct msm_camera_v4l2_ioctl_t)
 
-#define VIDIOC_MSM_CPP_SET_CLOCK \
-	_IOWR('V', BASE_VIDIOC_PRIVATE + 16, struct msm_camera_v4l2_ioctl_t)
-
 #define V4L2_EVENT_CPP_FRAME_DONE  (V4L2_EVENT_PRIVATE_START + 0)
 #define V4L2_EVENT_VPE_FRAME_DONE  (V4L2_EVENT_PRIVATE_START + 1)
 
-- 
1.9.1

