From dd950368c90df58a171a43c28edb8a4498dc4a54 Mon Sep 17 00:00:00 2001
From: BambooIV <ningdisheng@gmail.com>
Date: Tue, 2 Feb 2016 00:41:10 +0800
Subject: [PATCH 01/50] Init for NX503A

* NX503A KitKat firmware information(NX503A_CNCOMMON_V2.13):
OpenGL ES Shader Compiler Version: E031.24.00.15
Build Date: 05/26/14 Mon
Local Branch:
Remote Branch: quic/LNX.LA.3.5.2.2_rb1
Local Patches: NONE
Reconstruct Branch: AU_LINUX_ANDROID_LNX.LA.3.5.2.2_RB1.04.04.02.087.013

* This branch is based on tag 'LA.BF.1.1.1-04310-8x74.0',merge ztemt
released nubia Z5s KitKat(4.4.2) kernel(3.4.x) source code and cleanup
some codes

* Use msm8974-NX503A_defconfig as defconfig

Signed-off-by: BambooIV <ningdisheng@gmail.com>
---
 AndroidKernel.mk                                   |     5 +-
 arch/arm/boot/Makefile                             |     3 +
 .../NX503A/batterydata-ztemt-NX503A-2300mAh.dtsi   |   110 +
 arch/arm/boot/dts/NX503A/msm-pm8941.dtsi           |  1523 +++
 .../boot/dts/NX503A/msm8974-camera-sensor-mtp.dtsi |   377 +
 arch/arm/boot/dts/NX503A/msm8974-leds.dtsi         |   183 +
 arch/arm/boot/dts/NX503A/msm8974-mdss-panels.dtsi  |    13 +
 arch/arm/boot/dts/NX503A/msm8974-mdss.dtsi         |   268 +
 arch/arm/boot/dts/NX503A/msm8974-mtp.dtsi          |   899 ++
 arch/arm/boot/dts/NX503A/msm8974-regulator.dtsi    |   569 ++
 arch/arm/boot/dts/NX503A/msm8974-v2.0-1.dtsi       |    36 +
 arch/arm/boot/dts/NX503A/msm8974-v2.2.dtsi         |    99 +
 arch/arm/boot/dts/NX503A/msm8974-v2.dtsi           |   221 +
 arch/arm/boot/dts/NX503A/msm8974.dtsi              |  2621 +++++
 .../zte-dsi-panel-sharp-1080p-5p0-video.dtsi       |    88 +
 arch/arm/boot/dts/msm8974-clock.dtsi               |     1 +
 arch/arm/boot/dts/msm8974-v2.0-1-mtp-NX503A.dts    |    28 +
 arch/arm/boot/dts/msm8974-v2.2-mtp-NX503A.dts      |    28 +
 arch/arm/boot/dts/msm8974pro-pma8084-mtp.dtsi      |     0
 arch/arm/configs/msm8974-NX503A_defconfig          |   554 +
 arch/arm/mach-msm/Kconfig                          |     3 +-
 arch/arm/mach-msm/Makefile                         |    12 +-
 arch/arm/mach-msm/Makefile.boot                    |     0
 .../bms_ztemt_NX503A_batterydata_2300mAh.c         |   101 +
 arch/arm/mach-msm/board-8974-brcm-wifi.c           |   326 +
 arch/arm/mach-msm/board/Kconfig                    |    39 +
 arch/arm/mach-msm/board/Makefile                   |     1 +
 arch/arm/mach-msm/board/board-8974-NX503A.c        |   203 +
 .../arm/mach-msm/board/board-8974-gpiomux-NX503A.c |  1764 ++++
 arch/arm/mach-msm/board/clock-8974-NX503A.c        |  5928 +++++++++++
 arch/arm/mach-msm/clock-debug.c                    |     4 +
 arch/arm/mach-msm/include/mach/restart.h           |     3 +
 arch/arm/mach-msm/restart.c                        |    25 +-
 arch/sh/boot/compressed/vmlinux.scr                |    10 -
 arch/sh/boot/romimage/vmlinux.scr                  |     8 -
 drivers/base/power/wakeup.c                        |    36 +-
 drivers/bluetooth/bluesleep.c                      |   651 +-
 drivers/bluetooth/bluetooth-power.c                |   533 +-
 drivers/char/diag/diagfwd.c                        |    16 +
 drivers/hwmon/Kconfig                              |   104 +
 drivers/hwmon/Makefile                             |    25 +
 drivers/hwmon/als_prox.c                           |    65 +
 drivers/hwmon/aw_9106b.c                           |  1247 +++
 drivers/hwmon/aw_9106b.h                           |    57 +
 drivers/hwmon/maxq616.c                            |   296 +
 drivers/hwmon/qpnp-adc-common.c                    |    30 +-
 drivers/hwmon/qpnp-device-info.c                   |   497 +
 drivers/hwmon/sensor_common.c                      |   547 +
 drivers/hwmon/tmd2772.c                            |  3540 +++++++
 drivers/hwmon/tmg399x.c                            |  5666 +++++++++++
 drivers/i2c/busses/i2c-qup.c                       |     0
 drivers/input/touchscreen/Kconfig                  |     3 +
 drivers/input/touchscreen/Makefile                 |     4 +
 drivers/input/touchscreen/cyttsp4/Kconfig          |   224 +
 drivers/input/touchscreen/cyttsp4/Makefile         |    57 +
 drivers/input/touchscreen/cyttsp4/cyttsp4_btn.c    |   527 +
 drivers/input/touchscreen/cyttsp4/cyttsp4_btn.h    |    39 +
 drivers/input/touchscreen/cyttsp4/cyttsp4_bus.c    |   761 ++
 drivers/input/touchscreen/cyttsp4/cyttsp4_bus.h    |   346 +
 drivers/input/touchscreen/cyttsp4/cyttsp4_core.c   |  4187 ++++++++
 drivers/input/touchscreen/cyttsp4/cyttsp4_core.h   |   150 +
 drivers/input/touchscreen/cyttsp4/cyttsp4_debug.c  |   608 ++
 .../cyttsp4/cyttsp4_device_access-api.h            |    56 +
 .../touchscreen/cyttsp4/cyttsp4_device_access.c    |  2335 +++++
 .../touchscreen/cyttsp4/cyttsp4_device_access.h    |    67 +
 drivers/input/touchscreen/cyttsp4/cyttsp4_i2c.c    |   392 +
 drivers/input/touchscreen/cyttsp4/cyttsp4_i2c.h    |    35 +
 drivers/input/touchscreen/cyttsp4/cyttsp4_loader.c |  1996 ++++
 drivers/input/touchscreen/cyttsp4/cyttsp4_mt.h     |    84 +
 .../input/touchscreen/cyttsp4/cyttsp4_mt_common.c  |   824 ++
 .../input/touchscreen/cyttsp4/cyttsp4_mt_common.h  |    90 +
 drivers/input/touchscreen/cyttsp4/cyttsp4_mta.c    |   108 +
 drivers/input/touchscreen/cyttsp4/cyttsp4_mtb.c    |   125 +
 .../input/touchscreen/cyttsp4/cyttsp4_proximity.c  |   585 ++
 .../input/touchscreen/cyttsp4/cyttsp4_proximity.h  |    42 +
 drivers/input/touchscreen/cyttsp4/cyttsp4_regs.h   |   594 ++
 drivers/input/touchscreen/cyttsp4/cyttsp4_spi.c    |   443 +
 drivers/input/touchscreen/cyttsp4/cyttsp4_spi.h    |    37 +
 .../cyttsp4/cyttsp4_test_device_access_api.c       |   196 +
 drivers/input/touchscreen/cyttsp4/zte_ctp.c        |   561 +
 drivers/input/touchscreen/synaptics_dsx/Kconfig    |   108 +
 drivers/input/touchscreen/synaptics_dsx/Makefile   |    22 +
 .../touchscreen/synaptics_dsx/synaptics_dsx.h      |    80 +
 .../touchscreen/synaptics_dsx/synaptics_dsx_core.c |  3657 +++++++
 .../touchscreen/synaptics_dsx/synaptics_dsx_core.h |   357 +
 .../synaptics_dsx/synaptics_dsx_fw_update.c        |  1865 ++++
 .../touchscreen/synaptics_dsx/synaptics_dsx_i2c.c  |   425 +
 .../synaptics_dsx/synaptics_dsx_proximity.c        |   671 ++
 .../synaptics_dsx/synaptics_dsx_rmi_dev.c          |   781 ++
 .../touchscreen/synaptics_dsx/synaptics_dsx_spi.c  |   335 +
 .../synaptics_dsx/synaptics_dsx_test_reporting.c   |  3530 +++++++
 drivers/leds/Kconfig                               |     0
 drivers/leds/Makefile                              |     0
 drivers/media/platform/msm/camera_v2/Kconfig       |    26 +
 .../media/platform/msm/camera_v2/ispif/msm_ispif.c |     5 +-
 .../media/platform/msm/camera_v2/sensor/Makefile   |     3 +
 .../msm/camera_v2/sensor/actuator/msm_actuator.c   |    80 +-
 .../msm/camera_v2/sensor/eeprom/msm_eeprom.c       |     0
 .../msm/camera_v2/sensor/flash/msm_led_torch.c     |     2 +-
 .../media/platform/msm/camera_v2/sensor/imx135.c   |     6 +-
 .../platform/msm/camera_v2/sensor/imx135_z5s.c     |   181 +
 .../platform/msm/camera_v2/sensor/imx135_z5s_069.c |   181 +
 .../msm/camera_v2/sensor/io/msm_camera_cci_i2c.c   |     0
 .../msm/camera_v2/sensor/io/msm_camera_dt_util.c   |    19 +-
 .../msm/camera_v2/sensor/io/msm_camera_dt_util.h   |     0
 .../msm/camera_v2/sensor/io/msm_camera_i2c.h       |     0
 .../platform/msm/camera_v2/sensor/msm_sensor.c     |   127 +
 .../platform/msm/camera_v2/sensor/msm_sensor.h     |     0
 .../platform/msm/camera_v2/sensor/ov5648_z5s.c     |   175 +
 drivers/misc/Kconfig                               |    22 +
 drivers/misc/Makefile                              |     1 +
 drivers/misc/drv2605.c                             |  1547 +++
 drivers/mmc/Kconfig                                |     0
 drivers/mmc/Makefile                               |     0
 drivers/mmc/card/Kconfig                           |     0
 drivers/mmc/card/Makefile                          |     0
 drivers/mmc/card/block.c                           |    10 +
 drivers/mmc/card/mmc_block_test.c                  |     0
 drivers/mmc/card/mmc_test.c                        |     0
 drivers/mmc/card/queue.c                           |     0
 drivers/mmc/card/queue.h                           |     0
 drivers/mmc/card/sdio_uart.c                       |     0
 drivers/mmc/core/Kconfig                           |     0
 drivers/mmc/core/Makefile                          |     0
 drivers/mmc/core/bus.c                             |     0
 drivers/mmc/core/bus.h                             |     0
 drivers/mmc/core/cd-gpio.c                         |     0
 drivers/mmc/core/core.c                            |    11 +
 drivers/mmc/core/core.h                            |     0
 drivers/mmc/core/debugfs.c                         |     0
 drivers/mmc/core/host.c                            |     0
 drivers/mmc/core/host.h                            |     0
 drivers/mmc/core/mmc.c                             |     0
 drivers/mmc/core/mmc_ops.c                         |     0
 drivers/mmc/core/mmc_ops.h                         |     0
 drivers/mmc/core/quirks.c                          |     0
 drivers/mmc/core/sd.c                              |     2 +-
 drivers/mmc/core/sd.h                              |     0
 drivers/mmc/core/sd_ops.c                          |     0
 drivers/mmc/core/sd_ops.h                          |     0
 drivers/mmc/core/sdio.c                            |     0
 drivers/mmc/core/sdio_bus.c                        |     0
 drivers/mmc/core/sdio_bus.h                        |     0
 drivers/mmc/core/sdio_cis.c                        |     0
 drivers/mmc/core/sdio_cis.h                        |     0
 drivers/mmc/core/sdio_irq.c                        |     0
 drivers/mmc/core/sdio_ops.c                        |     0
 drivers/mmc/core/sdio_ops.h                        |     0
 drivers/mmc/host/Kconfig                           |     0
 drivers/mmc/host/Makefile                          |     0
 drivers/mmc/host/at91_mci.c                        |     0
 drivers/mmc/host/at91_mci.h                        |     0
 drivers/mmc/host/atmel-mci-regs.h                  |     0
 drivers/mmc/host/atmel-mci.c                       |     0
 drivers/mmc/host/au1xmmc.c                         |     0
 drivers/mmc/host/bfin_sdh.c                        |     0
 drivers/mmc/host/cb710-mmc.c                       |     0
 drivers/mmc/host/cb710-mmc.h                       |     0
 drivers/mmc/host/davinci_mmc.c                     |     0
 drivers/mmc/host/dw_mmc-pci.c                      |     0
 drivers/mmc/host/dw_mmc-pltfm.c                    |     0
 drivers/mmc/host/dw_mmc.c                          |     0
 drivers/mmc/host/dw_mmc.h                          |     0
 drivers/mmc/host/imxmmc.c                          |     0
 drivers/mmc/host/imxmmc.h                          |     0
 drivers/mmc/host/jz4740_mmc.c                      |     0
 drivers/mmc/host/mmc_spi.c                         |     0
 drivers/mmc/host/mmci.c                            |     0
 drivers/mmc/host/mmci.h                            |     0
 drivers/mmc/host/msm_sdcc.c                        |     0
 drivers/mmc/host/msm_sdcc.h                        |     0
 drivers/mmc/host/msm_sdcc_dml.c                    |     0
 drivers/mmc/host/msm_sdcc_dml.h                    |     0
 drivers/mmc/host/mvsdio.c                          |     0
 drivers/mmc/host/mvsdio.h                          |     0
 drivers/mmc/host/mxcmmc.c                          |     0
 drivers/mmc/host/mxs-mmc.c                         |     0
 drivers/mmc/host/of_mmc_spi.c                      |     0
 drivers/mmc/host/omap.c                            |     0
 drivers/mmc/host/omap_hsmmc.c                      |     0
 drivers/mmc/host/pxamci.c                          |     0
 drivers/mmc/host/pxamci.h                          |     0
 drivers/mmc/host/s3cmci.c                          |     0
 drivers/mmc/host/s3cmci.h                          |     0
 drivers/mmc/host/sdhci-cns3xxx.c                   |     0
 drivers/mmc/host/sdhci-dove.c                      |     0
 drivers/mmc/host/sdhci-esdhc-imx.c                 |     0
 drivers/mmc/host/sdhci-esdhc.h                     |     0
 drivers/mmc/host/sdhci-msm.c                       |    29 +
 drivers/mmc/host/sdhci-of-esdhc.c                  |     0
 drivers/mmc/host/sdhci-of-hlwd.c                   |     0
 drivers/mmc/host/sdhci-pci-data.c                  |     0
 drivers/mmc/host/sdhci-pci.c                       |     0
 drivers/mmc/host/sdhci-pltfm.c                     |     0
 drivers/mmc/host/sdhci-pltfm.h                     |     0
 drivers/mmc/host/sdhci-pxav2.c                     |     0
 drivers/mmc/host/sdhci-pxav3.c                     |     0
 drivers/mmc/host/sdhci-s3c.c                       |     0
 drivers/mmc/host/sdhci-spear.c                     |     0
 drivers/mmc/host/sdhci-tegra.c                     |     0
 drivers/mmc/host/sdhci.c                           |     7 +-
 drivers/mmc/host/sdhci.h                           |     0
 drivers/mmc/host/sdricoh_cs.c                      |     0
 drivers/mmc/host/sh_mmcif.c                        |     0
 drivers/mmc/host/sh_mobile_sdhi.c                  |     0
 drivers/mmc/host/tifm_sd.c                         |     0
 drivers/mmc/host/tmio_mmc.c                        |     0
 drivers/mmc/host/tmio_mmc.h                        |     0
 drivers/mmc/host/tmio_mmc_dma.c                    |     0
 drivers/mmc/host/tmio_mmc_pio.c                    |     0
 drivers/mmc/host/ushc.c                            |     0
 drivers/mmc/host/via-sdmmc.c                       |     0
 drivers/mmc/host/vub300.c                          |     0
 drivers/mmc/host/wbsd.c                            |     0
 drivers/mmc/host/wbsd.h                            |     0
 drivers/net/wireless/bcmdhd/Kconfig                |     0
 drivers/net/wireless/bcmdhd/Makefile               |    70 +-
 drivers/net/wireless/bcmdhd/aiutils.c              |   102 +-
 drivers/net/wireless/bcmdhd/bcmevent.c             |    49 +-
 drivers/net/wireless/bcmdhd/bcmsdh.c               |    56 +-
 drivers/net/wireless/bcmdhd/bcmsdh_linux.c         |   115 +-
 drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c         |   427 +-
 drivers/net/wireless/bcmdhd/bcmsdh_sdmmc_linux.c   |   114 +-
 drivers/net/wireless/bcmdhd/bcmutils.c             |   246 +-
 drivers/net/wireless/bcmdhd/bcmwifi_channels.c     |   174 +-
 drivers/net/wireless/bcmdhd/bcmwifi_channels.h     |   345 -
 drivers/net/wireless/bcmdhd/bcmwifi_rates.h        |   306 -
 drivers/net/wireless/bcmdhd/dhd.h                  |   294 +-
 drivers/net/wireless/bcmdhd/dhd_bta.c              |    25 +-
 drivers/net/wireless/bcmdhd/dhd_bta.h              |    20 +-
 drivers/net/wireless/bcmdhd/dhd_bus.h              |    24 +-
 drivers/net/wireless/bcmdhd/dhd_cdc.c              |  2435 +----
 drivers/net/wireless/bcmdhd/dhd_cfg80211.c         |   195 +-
 drivers/net/wireless/bcmdhd/dhd_cfg80211.h         |    29 +-
 drivers/net/wireless/bcmdhd/dhd_common.c           |   687 +-
 drivers/net/wireless/bcmdhd/dhd_custom_gpio.c      |   141 +-
 drivers/net/wireless/bcmdhd/dhd_dbg.h              |    35 +-
 drivers/net/wireless/bcmdhd/dhd_ip.c               |    93 +
 drivers/net/wireless/bcmdhd/dhd_ip.h               |    24 +
 drivers/net/wireless/bcmdhd/dhd_linux.c            |  2323 +++--
 drivers/net/wireless/bcmdhd/dhd_linux_sched.c      |    20 +-
 drivers/net/wireless/bcmdhd/dhd_proto.h            |    32 +-
 drivers/net/wireless/bcmdhd/dhd_sdio.c             |  2045 +++-
 drivers/net/wireless/bcmdhd/dhd_wlfc.c             |  2446 +++++
 drivers/net/wireless/bcmdhd/dhd_wlfc.h             |    78 +-
 drivers/net/wireless/bcmdhd/dngl_stats.h           |    20 +-
 drivers/net/wireless/bcmdhd/dngl_wlhdr.h           |    20 +-
 drivers/net/wireless/bcmdhd/hndpmu.c               |   107 +-
 drivers/net/wireless/bcmdhd/include/Makefile       |    53 -
 drivers/net/wireless/bcmdhd/include/aidmp.h        |    33 +-
 .../wireless/bcmdhd/include/bcm_android_types.h    |    44 -
 drivers/net/wireless/bcmdhd/include/bcm_cfg.h      |    22 +-
 .../net/wireless/bcmdhd/include/bcm_mpool_pub.h    |    20 +-
 drivers/net/wireless/bcmdhd/include/bcmcdc.h       |    20 +-
 drivers/net/wireless/bcmdhd/include/bcmdefs.h      |    40 +-
 drivers/net/wireless/bcmdhd/include/bcmdevs.h      |   150 +-
 drivers/net/wireless/bcmdhd/include/bcmendian.h    |    20 +-
 drivers/net/wireless/bcmdhd/include/bcmnvram.h     |   179 -
 drivers/net/wireless/bcmdhd/include/bcmpcispi.h    |    20 +-
 drivers/net/wireless/bcmdhd/include/bcmperf.h      |    20 +-
 drivers/net/wireless/bcmdhd/include/bcmsdbus.h     |    58 +-
 drivers/net/wireless/bcmdhd/include/bcmsdh.h       |    36 +-
 drivers/net/wireless/bcmdhd/include/bcmsdh_sdmmc.h |    30 +-
 drivers/net/wireless/bcmdhd/include/bcmsdpcm.h     |    49 +-
 drivers/net/wireless/bcmdhd/include/bcmsdspi.h     |    20 +-
 drivers/net/wireless/bcmdhd/include/bcmsdstd.h     |    38 +-
 drivers/net/wireless/bcmdhd/include/bcmspi.h       |    20 +-
 drivers/net/wireless/bcmdhd/include/bcmspibrcm.h   |   139 -
 drivers/net/wireless/bcmdhd/include/bcmsrom_fmt.h  |   607 --
 drivers/net/wireless/bcmdhd/include/bcmsrom_tbl.h  |   900 --
 drivers/net/wireless/bcmdhd/include/bcmutils.h     |   109 +-
 .../net/wireless/bcmdhd/include/bcmwifi_channels.h |   340 +
 .../net/wireless/bcmdhd/include/bcmwifi_rates.h    |   417 +
 drivers/net/wireless/bcmdhd/include/dbus.h         |   571 --
 drivers/net/wireless/bcmdhd/include/dhdioctl.h     |    28 +-
 drivers/net/wireless/bcmdhd/include/epivers.h      |    32 +-
 drivers/net/wireless/bcmdhd/include/hndpmu.h       |    22 +-
 .../net/wireless/bcmdhd/include/hndrte_armtrap.h   |    20 +-
 drivers/net/wireless/bcmdhd/include/hndrte_cons.h  |    24 +-
 drivers/net/wireless/bcmdhd/include/hndsoc.h       |    72 +-
 drivers/net/wireless/bcmdhd/include/linux_osl.h    |   210 +-
 drivers/net/wireless/bcmdhd/include/linuxver.h     |    59 +-
 drivers/net/wireless/bcmdhd/include/miniopt.h      |    20 +-
 drivers/net/wireless/bcmdhd/include/msgtrace.h     |    29 +-
 drivers/net/wireless/bcmdhd/include/osl.h          |    47 +-
 .../wireless/bcmdhd/include/packed_section_end.h   |    20 +-
 .../wireless/bcmdhd/include/packed_section_start.h |    20 +-
 drivers/net/wireless/bcmdhd/include/pcicfg.h       |    23 +-
 drivers/net/wireless/bcmdhd/include/proto/802.11.h |  1583 ++-
 .../net/wireless/bcmdhd/include/proto/802.11_bta.h |    22 +-
 .../net/wireless/bcmdhd/include/proto/802.11e.h    |    31 +-
 drivers/net/wireless/bcmdhd/include/proto/802.1d.h |    22 +-
 drivers/net/wireless/bcmdhd/include/proto/802.3.h  |    40 +
 drivers/net/wireless/bcmdhd/include/proto/bcmeth.h |    22 +-
 .../net/wireless/bcmdhd/include/proto/bcmevent.h   |   178 +-
 drivers/net/wireless/bcmdhd/include/proto/bcmip.h  |    43 +-
 .../net/wireless/bcmdhd/include/proto/bcmipv6.h    |   104 -
 .../net/wireless/bcmdhd/include/proto/bt_amp_hci.h |    22 +-
 drivers/net/wireless/bcmdhd/include/proto/eapol.h  |     2 +-
 .../net/wireless/bcmdhd/include/proto/ethernet.h   |    96 +-
 drivers/net/wireless/bcmdhd/include/proto/p2p.h    |    25 +-
 drivers/net/wireless/bcmdhd/include/proto/sdspi.h  |    22 +-
 drivers/net/wireless/bcmdhd/include/proto/vlan.h   |    46 +-
 drivers/net/wireless/bcmdhd/include/proto/wpa.h    |    35 +-
 drivers/net/wireless/bcmdhd/include/proto/wps.h    |   379 -
 drivers/net/wireless/bcmdhd/include/rwl_wifi.h     |    96 -
 drivers/net/wireless/bcmdhd/include/sbchipc.h      |   652 +-
 drivers/net/wireless/bcmdhd/include/sbconfig.h     |    20 +-
 drivers/net/wireless/bcmdhd/include/sbhnddma.h     |    49 +-
 drivers/net/wireless/bcmdhd/include/sbpcmcia.h     |    22 +-
 drivers/net/wireless/bcmdhd/include/sbsdio.h       |    31 +-
 drivers/net/wireless/bcmdhd/include/sbsdpcmdev.h   |    24 +-
 drivers/net/wireless/bcmdhd/include/sbsocram.h     |    20 +-
 drivers/net/wireless/bcmdhd/include/sdio.h         |    20 +-
 drivers/net/wireless/bcmdhd/include/sdioh.h        |    26 +-
 drivers/net/wireless/bcmdhd/include/sdiovar.h      |    20 +-
 drivers/net/wireless/bcmdhd/include/siutils.h      |    76 +-
 drivers/net/wireless/bcmdhd/include/spid.h         |   153 -
 drivers/net/wireless/bcmdhd/include/trxhdr.h       |    65 +-
 drivers/net/wireless/bcmdhd/include/typedefs.h     |    20 +-
 drivers/net/wireless/bcmdhd/include/usbrdl.h       |   203 -
 .../net/wireless/bcmdhd/include/wlc_extlog_idstr.h |   117 -
 drivers/net/wireless/bcmdhd/include/wlfc_proto.h   |    49 +-
 drivers/net/wireless/bcmdhd/include/wlioctl.h      |  1071 +-
 drivers/net/wireless/bcmdhd/linux_osl.c            |   466 +-
 drivers/net/wireless/bcmdhd/sbutils.c              |    27 +-
 drivers/net/wireless/bcmdhd/siutils.c              |   245 +-
 drivers/net/wireless/bcmdhd/siutils_priv.h         |    24 +-
 drivers/net/wireless/bcmdhd/uamp_api.h             |    20 +-
 drivers/net/wireless/bcmdhd/wl_android.c           |   733 +-
 drivers/net/wireless/bcmdhd/wl_android.h           |    28 +-
 drivers/net/wireless/bcmdhd/wl_cfg80211.c          | 10155 +++++++++++++------
 drivers/net/wireless/bcmdhd/wl_cfg80211.h          |   297 +-
 drivers/net/wireless/bcmdhd/wl_cfgp2p.c            |  1202 ++-
 drivers/net/wireless/bcmdhd/wl_cfgp2p.h            |   140 +-
 drivers/net/wireless/bcmdhd/wl_dbg.h               |    22 +-
 drivers/net/wireless/bcmdhd/wl_iw.c                |   146 +-
 drivers/net/wireless/bcmdhd/wl_iw.h                |    20 +-
 drivers/net/wireless/bcmdhd/wl_linux_mon.c         |    20 +-
 drivers/net/wireless/bcmdhd/wldev_common.c         |    87 +-
 drivers/net/wireless/bcmdhd/wldev_common.h         |    28 +-
 drivers/nfc/Kconfig                                |    12 +
 drivers/nfc/Makefile                               |     1 +
 drivers/nfc/nxp_pn544.c                            |   618 ++
 drivers/of/of_batterydata.c                        |     0
 drivers/platform/msm/qpnp-power-on.c               |    77 +
 drivers/platform/msm/qpnp-pwm.c                    |     0
 drivers/platform/msm/qpnp-vibrator.c               |     0
 drivers/power/Kconfig                              |    31 +-
 drivers/power/Makefile                             |     0
 drivers/power/power_supply_sysfs.c                 |     3 +
 drivers/power/qpnp-bms.c                           |    67 +-
 drivers/power/qpnp-charger.c                       |   691 +-
 drivers/rtc/Kconfig                                |     5 +
 drivers/rtc/alarm.c                                |    25 +-
 drivers/rtc/qpnp-rtc.c                             |    55 +
 drivers/spmi/spmi.c                                |    10 +
 drivers/switch/switch_gpio.c                       |    50 +-
 drivers/tty/serial/msm_serial_hs_lite.c            |     4 +
 drivers/usb/Kconfig                                |    14 +
 drivers/usb/dwc3/dwc3-msm.c                        |    37 +
 drivers/usb/dwc3/dwc3_otg.c                        |    31 +
 drivers/usb/dwc3/dwc3_otg.h                        |     4 +
 drivers/usb/gadget/android.c                       |    21 +
 drivers/usb/gadget/composite.c                     |     4 +
 drivers/video/msm/mdss/Kconfig                     |    53 +
 drivers/video/msm/mdss/Makefile                    |    17 +
 drivers/video/msm/mdss/mdss_dsi.c                  |    28 +
 drivers/video/msm/mdss/mdss_dsi.h                  |    12 +
 drivers/video/msm/mdss/mdss_dsi_panel.c            |   182 +-
 drivers/video/msm/mdss/mdss_fb.c                   |    50 +-
 drivers/video/msm/mdss/mdss_hdmi_edid.c            |     0
 drivers/video/msm/mdss/mdss_hdmi_tx.c              |     4 +-
 drivers/video/msm/mdss/mdss_io_util.c              |     0
 drivers/video/msm/mdss/mdss_mdp.c                  |     0
 drivers/video/msm/mdss/mdss_mdp.h                  |     4 +
 drivers/video/msm/mdss/mdss_mdp_ctl.c              |     0
 drivers/video/msm/mdss/mdss_mdp_overlay.c          |     0
 drivers/video/msm/mdss/mdss_mdp_pipe.c             |     0
 drivers/video/msm/mdss/mdss_mdp_pp.c               |    45 +
 drivers/video/msm/mdss/mdss_panel.h                |     6 +
 drivers/video/msm/mdss/zte_backlight.c             |   250 +
 drivers/video/msm/mdss/zte_backlight.h             |    30 +
 drivers/video/msm/mdss/zte_backlight_data.h        |   169 +
 drivers/video/msm/mdss/zte_disp_enhance.c          |   593 ++
 drivers/video/msm/mdss/zte_disp_enhance.h          |    27 +
 drivers/video/msm/mdss/zte_tps65132.c              |   254 +
 drivers/video/msm/mdss/zte_tps65132.h              |    10 +
 fs/Kconfig                                         |     0
 fs/Makefile                                        |     0
 include/linux/batterydata-lib.h                    |     4 +
 include/linux/fs.h                                 |     2 +-
 include/linux/i2c/drv2605.h                        |   543 +
 include/linux/i2c/maxq616.h                        |    64 +
 include/linux/i2c/sensor_common.h                  |    37 +
 include/linux/i2c/taos_common.h                    |    85 +
 include/linux/i2c/tmg399x.h                        |   524 +
 include/linux/pn544.h                              |    34 +
 include/linux/power_supply.h                       |     3 +
 include/linux/qpnp/qpnp-adc.h                      |     7 +
 include/linux/qpnp/qpnp-device-info.h              |    91 +
 include/linux/usb/android.h                        |     4 +
 include/linux/usb/composite.h                      |     4 +
 include/media/msm_cam_sensor.h                     |    14 +
 include/media/msm_camera.h                         |     3 +
 kernel/power/suspend.c                             |     7 +-
 mm/page_alloc.c                                    |     1 +
 net/wireless/nl80211.c                             |     2 +
 net/wireless/util.c                                |     1 +
 security/selinux/avc.c                             |     0
 sound/Kconfig                                      |    13 +
 sound/soc/codecs/wcd9xxx-mbhc.c                    |    41 +-
 sound/soc/codecs/wcd9xxx-mbhc.h                    |     4 +
 sound/soc/msm/msm8974.c                            |    65 +-
 sound/soc/msm/qdsp6v2/msm-dolby-dap-config.c       |   199 +-
 sound/soc/msm/qdsp6v2/msm-dolby-dap-config.h       |    10 +-
 416 files changed, 86154 insertions(+), 14950 deletions(-)
 mode change 100644 => 100755 AndroidKernel.mk
 mode change 100644 => 100755 arch/arm/boot/Makefile
 create mode 100755 arch/arm/boot/dts/NX503A/batterydata-ztemt-NX503A-2300mAh.dtsi
 create mode 100755 arch/arm/boot/dts/NX503A/msm-pm8941.dtsi
 create mode 100755 arch/arm/boot/dts/NX503A/msm8974-camera-sensor-mtp.dtsi
 create mode 100755 arch/arm/boot/dts/NX503A/msm8974-leds.dtsi
 create mode 100755 arch/arm/boot/dts/NX503A/msm8974-mdss-panels.dtsi
 create mode 100755 arch/arm/boot/dts/NX503A/msm8974-mdss.dtsi
 create mode 100755 arch/arm/boot/dts/NX503A/msm8974-mtp.dtsi
 create mode 100755 arch/arm/boot/dts/NX503A/msm8974-regulator.dtsi
 create mode 100755 arch/arm/boot/dts/NX503A/msm8974-v2.0-1.dtsi
 create mode 100755 arch/arm/boot/dts/NX503A/msm8974-v2.2.dtsi
 create mode 100755 arch/arm/boot/dts/NX503A/msm8974-v2.dtsi
 create mode 100755 arch/arm/boot/dts/NX503A/msm8974.dtsi
 create mode 100755 arch/arm/boot/dts/NX503A/zte-dsi-panel-sharp-1080p-5p0-video.dtsi
 create mode 100755 arch/arm/boot/dts/msm8974-v2.0-1-mtp-NX503A.dts
 create mode 100755 arch/arm/boot/dts/msm8974-v2.2-mtp-NX503A.dts
 mode change 100644 => 100755 arch/arm/boot/dts/msm8974pro-pma8084-mtp.dtsi
 create mode 100755 arch/arm/configs/msm8974-NX503A_defconfig
 mode change 100644 => 100755 arch/arm/mach-msm/Kconfig
 mode change 100644 => 100755 arch/arm/mach-msm/Makefile
 mode change 100644 => 100755 arch/arm/mach-msm/Makefile.boot
 create mode 100755 arch/arm/mach-msm/bms_ztemt_NX503A_batterydata_2300mAh.c
 create mode 100755 arch/arm/mach-msm/board-8974-brcm-wifi.c
 create mode 100755 arch/arm/mach-msm/board/Kconfig
 create mode 100755 arch/arm/mach-msm/board/Makefile
 create mode 100755 arch/arm/mach-msm/board/board-8974-NX503A.c
 create mode 100644 arch/arm/mach-msm/board/board-8974-gpiomux-NX503A.c
 create mode 100755 arch/arm/mach-msm/board/clock-8974-NX503A.c
 mode change 100644 => 100755 arch/arm/mach-msm/clock-debug.c
 mode change 100644 => 100755 arch/arm/mach-msm/include/mach/restart.h
 mode change 100644 => 100755 arch/arm/mach-msm/restart.c
 delete mode 100644 arch/sh/boot/compressed/vmlinux.scr
 delete mode 100644 arch/sh/boot/romimage/vmlinux.scr
 mode change 100644 => 100755 drivers/bluetooth/bluesleep.c
 mode change 100644 => 100755 drivers/bluetooth/bluetooth-power.c
 mode change 100644 => 100755 drivers/char/diag/diagfwd.c
 mode change 100644 => 100755 drivers/hwmon/Kconfig
 mode change 100644 => 100755 drivers/hwmon/Makefile
 create mode 100755 drivers/hwmon/als_prox.c
 create mode 100755 drivers/hwmon/aw_9106b.c
 create mode 100755 drivers/hwmon/aw_9106b.h
 create mode 100755 drivers/hwmon/maxq616.c
 mode change 100644 => 100755 drivers/hwmon/qpnp-adc-common.c
 create mode 100755 drivers/hwmon/qpnp-device-info.c
 create mode 100755 drivers/hwmon/sensor_common.c
 create mode 100755 drivers/hwmon/tmd2772.c
 create mode 100755 drivers/hwmon/tmg399x.c
 mode change 100644 => 100755 drivers/i2c/busses/i2c-qup.c
 mode change 100644 => 100755 drivers/input/touchscreen/Kconfig
 mode change 100644 => 100755 drivers/input/touchscreen/Makefile
 create mode 100755 drivers/input/touchscreen/cyttsp4/Kconfig
 create mode 100755 drivers/input/touchscreen/cyttsp4/Makefile
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_btn.c
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_btn.h
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_bus.c
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_bus.h
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_core.c
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_core.h
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_debug.c
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_device_access-api.h
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_device_access.c
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_device_access.h
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_i2c.c
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_i2c.h
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_loader.c
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_mt.h
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_mt_common.c
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_mt_common.h
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_mta.c
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_mtb.c
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_proximity.c
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_proximity.h
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_regs.h
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_spi.c
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_spi.h
 create mode 100755 drivers/input/touchscreen/cyttsp4/cyttsp4_test_device_access_api.c
 create mode 100755 drivers/input/touchscreen/cyttsp4/zte_ctp.c
 create mode 100755 drivers/input/touchscreen/synaptics_dsx/Kconfig
 create mode 100755 drivers/input/touchscreen/synaptics_dsx/Makefile
 create mode 100755 drivers/input/touchscreen/synaptics_dsx/synaptics_dsx.h
 create mode 100755 drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_core.c
 create mode 100755 drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_core.h
 create mode 100755 drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_fw_update.c
 create mode 100755 drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_i2c.c
 create mode 100755 drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_proximity.c
 create mode 100755 drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_rmi_dev.c
 create mode 100755 drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_spi.c
 create mode 100755 drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_test_reporting.c
 mode change 100644 => 100755 drivers/leds/Kconfig
 mode change 100644 => 100755 drivers/leds/Makefile
 mode change 100644 => 100755 drivers/media/platform/msm/camera_v2/Kconfig
 mode change 100644 => 100755 drivers/media/platform/msm/camera_v2/sensor/Makefile
 mode change 100644 => 100755 drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c
 mode change 100644 => 100755 drivers/media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c
 mode change 100644 => 100755 drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_torch.c
 mode change 100644 => 100755 drivers/media/platform/msm/camera_v2/sensor/imx135.c
 create mode 100755 drivers/media/platform/msm/camera_v2/sensor/imx135_z5s.c
 create mode 100755 drivers/media/platform/msm/camera_v2/sensor/imx135_z5s_069.c
 mode change 100644 => 100755 drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c
 mode change 100644 => 100755 drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c
 mode change 100644 => 100755 drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h
 mode change 100644 => 100755 drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h
 mode change 100644 => 100755 drivers/media/platform/msm/camera_v2/sensor/msm_sensor.h
 create mode 100755 drivers/media/platform/msm/camera_v2/sensor/ov5648_z5s.c
 mode change 100644 => 100755 drivers/misc/Kconfig
 mode change 100644 => 100755 drivers/misc/Makefile
 create mode 100755 drivers/misc/drv2605.c
 mode change 100644 => 100755 drivers/mmc/Kconfig
 mode change 100644 => 100755 drivers/mmc/Makefile
 mode change 100644 => 100755 drivers/mmc/card/Kconfig
 mode change 100644 => 100755 drivers/mmc/card/Makefile
 mode change 100644 => 100755 drivers/mmc/card/block.c
 mode change 100644 => 100755 drivers/mmc/card/mmc_block_test.c
 mode change 100644 => 100755 drivers/mmc/card/mmc_test.c
 mode change 100644 => 100755 drivers/mmc/card/queue.c
 mode change 100644 => 100755 drivers/mmc/card/queue.h
 mode change 100644 => 100755 drivers/mmc/card/sdio_uart.c
 mode change 100644 => 100755 drivers/mmc/core/Kconfig
 mode change 100644 => 100755 drivers/mmc/core/Makefile
 mode change 100644 => 100755 drivers/mmc/core/bus.c
 mode change 100644 => 100755 drivers/mmc/core/bus.h
 mode change 100644 => 100755 drivers/mmc/core/cd-gpio.c
 mode change 100644 => 100755 drivers/mmc/core/core.c
 mode change 100644 => 100755 drivers/mmc/core/core.h
 mode change 100644 => 100755 drivers/mmc/core/debugfs.c
 mode change 100644 => 100755 drivers/mmc/core/host.c
 mode change 100644 => 100755 drivers/mmc/core/host.h
 mode change 100644 => 100755 drivers/mmc/core/mmc.c
 mode change 100644 => 100755 drivers/mmc/core/mmc_ops.c
 mode change 100644 => 100755 drivers/mmc/core/mmc_ops.h
 mode change 100644 => 100755 drivers/mmc/core/quirks.c
 mode change 100644 => 100755 drivers/mmc/core/sd.c
 mode change 100644 => 100755 drivers/mmc/core/sd.h
 mode change 100644 => 100755 drivers/mmc/core/sd_ops.c
 mode change 100644 => 100755 drivers/mmc/core/sd_ops.h
 mode change 100644 => 100755 drivers/mmc/core/sdio.c
 mode change 100644 => 100755 drivers/mmc/core/sdio_bus.c
 mode change 100644 => 100755 drivers/mmc/core/sdio_bus.h
 mode change 100644 => 100755 drivers/mmc/core/sdio_cis.c
 mode change 100644 => 100755 drivers/mmc/core/sdio_cis.h
 mode change 100644 => 100755 drivers/mmc/core/sdio_irq.c
 mode change 100644 => 100755 drivers/mmc/core/sdio_ops.c
 mode change 100644 => 100755 drivers/mmc/core/sdio_ops.h
 mode change 100644 => 100755 drivers/mmc/host/Kconfig
 mode change 100644 => 100755 drivers/mmc/host/Makefile
 mode change 100644 => 100755 drivers/mmc/host/at91_mci.c
 mode change 100644 => 100755 drivers/mmc/host/at91_mci.h
 mode change 100644 => 100755 drivers/mmc/host/atmel-mci-regs.h
 mode change 100644 => 100755 drivers/mmc/host/atmel-mci.c
 mode change 100644 => 100755 drivers/mmc/host/au1xmmc.c
 mode change 100644 => 100755 drivers/mmc/host/bfin_sdh.c
 mode change 100644 => 100755 drivers/mmc/host/cb710-mmc.c
 mode change 100644 => 100755 drivers/mmc/host/cb710-mmc.h
 mode change 100644 => 100755 drivers/mmc/host/davinci_mmc.c
 mode change 100644 => 100755 drivers/mmc/host/dw_mmc-pci.c
 mode change 100644 => 100755 drivers/mmc/host/dw_mmc-pltfm.c
 mode change 100644 => 100755 drivers/mmc/host/dw_mmc.c
 mode change 100644 => 100755 drivers/mmc/host/dw_mmc.h
 mode change 100644 => 100755 drivers/mmc/host/imxmmc.c
 mode change 100644 => 100755 drivers/mmc/host/imxmmc.h
 mode change 100644 => 100755 drivers/mmc/host/jz4740_mmc.c
 mode change 100644 => 100755 drivers/mmc/host/mmc_spi.c
 mode change 100644 => 100755 drivers/mmc/host/mmci.c
 mode change 100644 => 100755 drivers/mmc/host/mmci.h
 mode change 100644 => 100755 drivers/mmc/host/msm_sdcc.c
 mode change 100644 => 100755 drivers/mmc/host/msm_sdcc.h
 mode change 100644 => 100755 drivers/mmc/host/msm_sdcc_dml.c
 mode change 100644 => 100755 drivers/mmc/host/msm_sdcc_dml.h
 mode change 100644 => 100755 drivers/mmc/host/mvsdio.c
 mode change 100644 => 100755 drivers/mmc/host/mvsdio.h
 mode change 100644 => 100755 drivers/mmc/host/mxcmmc.c
 mode change 100644 => 100755 drivers/mmc/host/mxs-mmc.c
 mode change 100644 => 100755 drivers/mmc/host/of_mmc_spi.c
 mode change 100644 => 100755 drivers/mmc/host/omap.c
 mode change 100644 => 100755 drivers/mmc/host/omap_hsmmc.c
 mode change 100644 => 100755 drivers/mmc/host/pxamci.c
 mode change 100644 => 100755 drivers/mmc/host/pxamci.h
 mode change 100644 => 100755 drivers/mmc/host/s3cmci.c
 mode change 100644 => 100755 drivers/mmc/host/s3cmci.h
 mode change 100644 => 100755 drivers/mmc/host/sdhci-cns3xxx.c
 mode change 100644 => 100755 drivers/mmc/host/sdhci-dove.c
 mode change 100644 => 100755 drivers/mmc/host/sdhci-esdhc-imx.c
 mode change 100644 => 100755 drivers/mmc/host/sdhci-esdhc.h
 mode change 100644 => 100755 drivers/mmc/host/sdhci-msm.c
 mode change 100644 => 100755 drivers/mmc/host/sdhci-of-esdhc.c
 mode change 100644 => 100755 drivers/mmc/host/sdhci-of-hlwd.c
 mode change 100644 => 100755 drivers/mmc/host/sdhci-pci-data.c
 mode change 100644 => 100755 drivers/mmc/host/sdhci-pci.c
 mode change 100644 => 100755 drivers/mmc/host/sdhci-pltfm.c
 mode change 100644 => 100755 drivers/mmc/host/sdhci-pltfm.h
 mode change 100644 => 100755 drivers/mmc/host/sdhci-pxav2.c
 mode change 100644 => 100755 drivers/mmc/host/sdhci-pxav3.c
 mode change 100644 => 100755 drivers/mmc/host/sdhci-s3c.c
 mode change 100644 => 100755 drivers/mmc/host/sdhci-spear.c
 mode change 100644 => 100755 drivers/mmc/host/sdhci-tegra.c
 mode change 100644 => 100755 drivers/mmc/host/sdhci.c
 mode change 100644 => 100755 drivers/mmc/host/sdhci.h
 mode change 100644 => 100755 drivers/mmc/host/sdricoh_cs.c
 mode change 100644 => 100755 drivers/mmc/host/sh_mmcif.c
 mode change 100644 => 100755 drivers/mmc/host/sh_mobile_sdhi.c
 mode change 100644 => 100755 drivers/mmc/host/tifm_sd.c
 mode change 100644 => 100755 drivers/mmc/host/tmio_mmc.c
 mode change 100644 => 100755 drivers/mmc/host/tmio_mmc.h
 mode change 100644 => 100755 drivers/mmc/host/tmio_mmc_dma.c
 mode change 100644 => 100755 drivers/mmc/host/tmio_mmc_pio.c
 mode change 100644 => 100755 drivers/mmc/host/ushc.c
 mode change 100644 => 100755 drivers/mmc/host/via-sdmmc.c
 mode change 100644 => 100755 drivers/mmc/host/vub300.c
 mode change 100644 => 100755 drivers/mmc/host/wbsd.c
 mode change 100644 => 100755 drivers/mmc/host/wbsd.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/Kconfig
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/Makefile
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/aiutils.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/bcmevent.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/bcmsdh.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/bcmsdh_linux.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/bcmsdh_sdmmc_linux.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/bcmutils.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/bcmwifi_channels.c
 delete mode 100644 drivers/net/wireless/bcmdhd/bcmwifi_channels.h
 delete mode 100644 drivers/net/wireless/bcmdhd/bcmwifi_rates.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/dhd.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/dhd_bta.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/dhd_bta.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/dhd_bus.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/dhd_cdc.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/dhd_cfg80211.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/dhd_cfg80211.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/dhd_common.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/dhd_custom_gpio.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/dhd_dbg.h
 create mode 100755 drivers/net/wireless/bcmdhd/dhd_ip.c
 create mode 100755 drivers/net/wireless/bcmdhd/dhd_ip.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/dhd_linux.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/dhd_linux_sched.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/dhd_proto.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/dhd_sdio.c
 create mode 100755 drivers/net/wireless/bcmdhd/dhd_wlfc.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/dhd_wlfc.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/dngl_stats.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/dngl_wlhdr.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/hndpmu.c
 delete mode 100644 drivers/net/wireless/bcmdhd/include/Makefile
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/aidmp.h
 delete mode 100644 drivers/net/wireless/bcmdhd/include/bcm_android_types.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/bcm_cfg.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/bcm_mpool_pub.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/bcmcdc.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/bcmdefs.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/bcmdevs.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/bcmendian.h
 delete mode 100644 drivers/net/wireless/bcmdhd/include/bcmnvram.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/bcmpcispi.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/bcmperf.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/bcmsdbus.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/bcmsdh.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/bcmsdh_sdmmc.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/bcmsdpcm.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/bcmsdspi.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/bcmsdstd.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/bcmspi.h
 delete mode 100644 drivers/net/wireless/bcmdhd/include/bcmspibrcm.h
 delete mode 100644 drivers/net/wireless/bcmdhd/include/bcmsrom_fmt.h
 delete mode 100644 drivers/net/wireless/bcmdhd/include/bcmsrom_tbl.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/bcmutils.h
 create mode 100755 drivers/net/wireless/bcmdhd/include/bcmwifi_channels.h
 create mode 100755 drivers/net/wireless/bcmdhd/include/bcmwifi_rates.h
 delete mode 100644 drivers/net/wireless/bcmdhd/include/dbus.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/dhdioctl.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/epivers.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/hndpmu.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/hndrte_armtrap.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/hndrte_cons.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/hndsoc.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/linux_osl.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/linuxver.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/miniopt.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/msgtrace.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/osl.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/packed_section_end.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/packed_section_start.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/pcicfg.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/proto/802.11.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/proto/802.11_bta.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/proto/802.11e.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/proto/802.1d.h
 create mode 100755 drivers/net/wireless/bcmdhd/include/proto/802.3.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/proto/bcmeth.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/proto/bcmevent.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/proto/bcmip.h
 delete mode 100644 drivers/net/wireless/bcmdhd/include/proto/bcmipv6.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/proto/bt_amp_hci.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/proto/eapol.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/proto/ethernet.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/proto/p2p.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/proto/sdspi.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/proto/vlan.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/proto/wpa.h
 delete mode 100644 drivers/net/wireless/bcmdhd/include/proto/wps.h
 delete mode 100644 drivers/net/wireless/bcmdhd/include/rwl_wifi.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/sbchipc.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/sbconfig.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/sbhnddma.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/sbpcmcia.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/sbsdio.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/sbsdpcmdev.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/sbsocram.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/sdio.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/sdioh.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/sdiovar.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/siutils.h
 delete mode 100644 drivers/net/wireless/bcmdhd/include/spid.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/trxhdr.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/typedefs.h
 delete mode 100644 drivers/net/wireless/bcmdhd/include/usbrdl.h
 delete mode 100644 drivers/net/wireless/bcmdhd/include/wlc_extlog_idstr.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/wlfc_proto.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/include/wlioctl.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/linux_osl.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/sbutils.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/siutils.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/siutils_priv.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/uamp_api.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/wl_android.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/wl_android.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/wl_cfg80211.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/wl_cfg80211.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/wl_cfgp2p.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/wl_cfgp2p.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/wl_dbg.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/wl_iw.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/wl_iw.h
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/wl_linux_mon.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/wldev_common.c
 mode change 100644 => 100755 drivers/net/wireless/bcmdhd/wldev_common.h
 mode change 100644 => 100755 drivers/nfc/Kconfig
 mode change 100644 => 100755 drivers/nfc/Makefile
 create mode 100755 drivers/nfc/nxp_pn544.c
 mode change 100644 => 100755 drivers/of/of_batterydata.c
 mode change 100644 => 100755 drivers/platform/msm/qpnp-power-on.c
 mode change 100644 => 100755 drivers/platform/msm/qpnp-pwm.c
 mode change 100644 => 100755 drivers/platform/msm/qpnp-vibrator.c
 mode change 100644 => 100755 drivers/power/Kconfig
 mode change 100644 => 100755 drivers/power/Makefile
 mode change 100644 => 100755 drivers/power/power_supply_sysfs.c
 mode change 100644 => 100755 drivers/power/qpnp-bms.c
 mode change 100644 => 100755 drivers/power/qpnp-charger.c
 mode change 100644 => 100755 drivers/rtc/Kconfig
 mode change 100644 => 100755 drivers/rtc/alarm.c
 mode change 100644 => 100755 drivers/spmi/spmi.c
 mode change 100644 => 100755 drivers/switch/switch_gpio.c
 mode change 100644 => 100755 drivers/tty/serial/msm_serial_hs_lite.c
 mode change 100644 => 100755 drivers/usb/Kconfig
 mode change 100644 => 100755 drivers/usb/dwc3/dwc3-msm.c
 mode change 100644 => 100755 drivers/usb/dwc3/dwc3_otg.c
 mode change 100644 => 100755 drivers/usb/dwc3/dwc3_otg.h
 mode change 100644 => 100755 drivers/usb/gadget/android.c
 mode change 100644 => 100755 drivers/usb/gadget/composite.c
 mode change 100644 => 100755 drivers/video/msm/mdss/Kconfig
 mode change 100644 => 100755 drivers/video/msm/mdss/Makefile
 mode change 100644 => 100755 drivers/video/msm/mdss/mdss_dsi.c
 mode change 100644 => 100755 drivers/video/msm/mdss/mdss_dsi.h
 mode change 100644 => 100755 drivers/video/msm/mdss/mdss_dsi_panel.c
 mode change 100644 => 100755 drivers/video/msm/mdss/mdss_fb.c
 mode change 100644 => 100755 drivers/video/msm/mdss/mdss_hdmi_edid.c
 mode change 100644 => 100755 drivers/video/msm/mdss/mdss_hdmi_tx.c
 mode change 100644 => 100755 drivers/video/msm/mdss/mdss_io_util.c
 mode change 100644 => 100755 drivers/video/msm/mdss/mdss_mdp.c
 mode change 100644 => 100755 drivers/video/msm/mdss/mdss_mdp.h
 mode change 100644 => 100755 drivers/video/msm/mdss/mdss_mdp_ctl.c
 mode change 100644 => 100755 drivers/video/msm/mdss/mdss_mdp_overlay.c
 mode change 100644 => 100755 drivers/video/msm/mdss/mdss_mdp_pipe.c
 mode change 100644 => 100755 drivers/video/msm/mdss/mdss_mdp_pp.c
 mode change 100644 => 100755 drivers/video/msm/mdss/mdss_panel.h
 create mode 100755 drivers/video/msm/mdss/zte_backlight.c
 create mode 100755 drivers/video/msm/mdss/zte_backlight.h
 create mode 100755 drivers/video/msm/mdss/zte_backlight_data.h
 create mode 100755 drivers/video/msm/mdss/zte_disp_enhance.c
 create mode 100755 drivers/video/msm/mdss/zte_disp_enhance.h
 create mode 100755 drivers/video/msm/mdss/zte_tps65132.c
 create mode 100755 drivers/video/msm/mdss/zte_tps65132.h
 mode change 100644 => 100755 fs/Kconfig
 mode change 100644 => 100755 fs/Makefile
 mode change 100644 => 100755 include/linux/batterydata-lib.h
 mode change 100644 => 100755 include/linux/fs.h
 create mode 100755 include/linux/i2c/drv2605.h
 create mode 100755 include/linux/i2c/maxq616.h
 create mode 100755 include/linux/i2c/sensor_common.h
 create mode 100755 include/linux/i2c/taos_common.h
 create mode 100755 include/linux/i2c/tmg399x.h
 create mode 100755 include/linux/pn544.h
 mode change 100644 => 100755 include/linux/power_supply.h
 mode change 100644 => 100755 include/linux/qpnp/qpnp-adc.h
 create mode 100755 include/linux/qpnp/qpnp-device-info.h
 mode change 100644 => 100755 include/linux/usb/android.h
 mode change 100644 => 100755 include/linux/usb/composite.h
 mode change 100644 => 100755 include/media/msm_cam_sensor.h
 mode change 100644 => 100755 include/media/msm_camera.h
 mode change 100644 => 100755 mm/page_alloc.c
 mode change 100644 => 100755 security/selinux/avc.c
 mode change 100644 => 100755 sound/soc/codecs/wcd9xxx-mbhc.c
 mode change 100644 => 100755 sound/soc/msm/msm8974.c
 mode change 100644 => 100755 sound/soc/msm/qdsp6v2/msm-dolby-dap-config.c
 mode change 100644 => 100755 sound/soc/msm/qdsp6v2/msm-dolby-dap-config.h

diff --git a/AndroidKernel.mk b/AndroidKernel.mk
old mode 100644
new mode 100755
index 588688c..073e21e
--- a/AndroidKernel.mk
+++ b/AndroidKernel.mk
@@ -67,6 +67,9 @@ mpath=`dirname $$mdpath`; rm -rf $$mpath;\
 fi
 endef
 
+ZTEMT_DTS_NAME:=$(DTS_NAME)
+export ZTEMT_DTS_NAME
+
 $(KERNEL_OUT):
 	mkdir -p $(KERNEL_OUT)
 
@@ -82,7 +85,7 @@ $(TARGET_PREBUILT_INT_KERNEL): $(KERNEL_OUT) $(KERNEL_CONFIG) $(KERNEL_HEADERS_I
 	$(MAKE) -C kernel O=../$(KERNEL_OUT) INSTALL_MOD_PATH=../../$(KERNEL_MODULES_INSTALL) INSTALL_MOD_STRIP=1 ARCH=arm CROSS_COMPILE=arm-eabi- modules_install
 	$(mv-modules)
 	$(clean-module-folder)
-	$(append-dtb)
+#	$(append-dtb)
 
 $(KERNEL_HEADERS_INSTALL): $(KERNEL_OUT) $(KERNEL_CONFIG)
 	$(MAKE) -C kernel O=../$(KERNEL_OUT) ARCH=arm CROSS_COMPILE=arm-eabi- headers_install
diff --git a/arch/arm/boot/Makefile b/arch/arm/boot/Makefile
old mode 100644
new mode 100755
index bc8ee6c..49d9413
--- a/arch/arm/boot/Makefile
+++ b/arch/arm/boot/Makefile
@@ -27,6 +27,9 @@ export ZRELADDR INITRD_PHYS PARAMS_PHYS
 
 targets := Image zImage xipImage bootpImage uImage
 
+CONFIG_BUILD_ARM_APPENDED_DTB_IMAGE_NAMES=$(ZTEMT_DTS_NAME)
+$(warning mhx$(CONFIG_BUILD_ARM_APPENDED_DTB_IMAGE_NAMES))
+
 DTB_NAMES := $(subst $\",,$(CONFIG_BUILD_ARM_APPENDED_DTB_IMAGE_NAMES))
 ifneq ($(DTB_NAMES),)
 DTB_LIST := $(addsuffix .dtb,$(DTB_NAMES))
diff --git a/arch/arm/boot/dts/NX503A/batterydata-ztemt-NX503A-2300mAh.dtsi b/arch/arm/boot/dts/NX503A/batterydata-ztemt-NX503A-2300mAh.dtsi
new file mode 100755
index 0000000..bb500e6
--- /dev/null
+++ b/arch/arm/boot/dts/NX503A/batterydata-ztemt-NX503A-2300mAh.dtsi
@@ -0,0 +1,110 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+/*
+CONFIG_ZTEMT_NX503A_CHARGE
+*/
+qcom,ztemt-2300mah {
+	/* Data Can not be delete*/
+  qcom,fcc-mah = <2300>;
+	qcom,default-rbatt-mohm = <146>;
+	qcom,max-voltage-uv = <4350000>; 
+	/**/
+	qcom,rbatt-capacitive-mohm = <0>;
+	qcom,v-cutoff-uv = <3400000>;
+	qcom,chg-term-ua = <100000>;
+	qcom,batt-id-kohm = <300>;
+
+	qcom,fcc-temp-lut {
+		qcom,lut-col-legend = <(-20) (-5) 0 25 40 45 50 60>;
+		qcom,lut-data = <2288  2300  2313  2278  2265 2253 2231 2186> ;
+	};
+
+	qcom,pc-temp-ocv-lut {
+		qcom,lut-col-legend = <(-20) (-5) 0 25 40 45 50 60>;
+		qcom,lut-row-legend = <100 95 90 85 80>,
+				<75 70 65 60 55>,
+				<50 45 40 35 30>,
+				<25 20 15 10 9>,
+				<8 7 6 5 4 >,
+				<3 2 1 0>;
+		qcom,lut-data =
+        <4332 4329 4330 4323 4317 4314 4311 4305>,
+        <4232 4249 4256 4255 4252 4249 4247 4241>,
+        <4163 4188 4197 4198 4196 4192 4191 4185>,
+        <4103 4132 4142 4144 4141 4138 4137 4131>,
+        <4047 4077 4090 4092 4090 4086 4086 4080>,
+        <3980 4020 4041 4044 4042 4038 4038 4033>,
+        <3930 3960 3981 3999 3998 3995 3994 3990>,
+        <3886 3920 3935 3957 3957 3954 3954 3950>,
+        <3851 3882 3891 3907 3911 3909 3911 3908>,
+        <3824 3849 3857 3865 3865 3864 3864 3861>,
+        <3805 3821 3830 3836 3836 3834 3835 3834>,
+        <3790 3797 3807 3813 3814 3813 3813 3811>,
+        <3776 3780 3789 3795 3794 3794 3794 3793>,
+        <3761 3767 3776 3780 3778 3777 3778 3776>,
+        <3744 3751 3765 3767 3762 3760 3759 3754>,
+        <3725 3731 3747 3752 3744 3740 3738 3731>,
+        <3702 3711 3716 3728 3719 3715 3715 3705>,
+        <3673 3693 3693 3696 3687 3681 3678 3672>,
+        <3621 3666 3678 3678 3666 3664 3666 3653>,
+        <3605 3657 3674 3676 3661 3654 3656 3645>,
+        <3584 3643 3666 3673 3656 3643 3641 3636>,
+        <3561 3624 3651 3668 3649 3631 3625 3626>,
+        <3536 3600 3628 3651 3632 3612 3606 3612>,
+        <3507 3570 3597 3614 3592 3578 3579 3573>,
+        <3473 3528 3555 3562 3537 3523 3537 3517>,
+        <3431 3466 3494 3495 3468 3454 3475 3455>,
+        <3370 3368 3403 3406 3378 3363 3395 3384>,
+        <3249 3218 3250 3278 3260 3236 3288 3297>,
+        <3000 3000 3000 3000 3000 3000 3000 3000>;
+	};
+
+	qcom,rbatt-sf-lut {
+		qcom,lut-col-legend = <(-20) (-5) 0 25 40 45 50 60>;
+		qcom,lut-row-legend =<100 95 90 85 80>,
+				<75 70 65 60 55>,
+				<50 45 40 35 30>,
+				<25 20 15 10 9>,
+				<8 7 6 5 4 >,
+				<3 2 1 0>;
+		qcom,lut-data =
+			<957 280 210 100 87 85 83 81>,
+			<981 290 217 103 89 86 84 82>,
+			<1006 298 225 107 91 89 87 84>,
+			<1082 300 231 112 94 91 89 85>,
+			<1035 302 239 116 97 93 91 88>,
+			<986 285 221 122 101 97 93 90>,
+			<979 286 216 127 106 101 97 93>,
+			<984 284 213 115 107 103 101 96>,
+			<1006 284 212 103 90 88 86 84>,
+			<1058 289 214 102 89 87 85 84>,
+			<1122 294 218 105 92 89 87 85>,
+			<1194 302 223 108 94 92 90 87>,
+			<1280 316 232 112 95 94 93 90>,
+			<1387 334 247 114 95 92 91 87>,
+			<1512 350 261 112 92 89 86 85>,
+			<1676 377 265 111 91 88 86 84>,
+			<1893 440 293 109 91 88 86 83>,
+			<2261 557 378 114 93 90 88 86>,
+			<2204 470 340 112 93 90 88 86>,
+			<2310 485 350 116 95 91 89 87>,
+			<2430 501 361 118 97 92 90 88>,
+			<2585 523 372 122 97 94 91 87>,
+			<2806 551 387 122 94 91 89 84>,
+			<3071 585 408 117 93 89 87 85>,
+			<3408 628 435 118 96 91 88 87>,
+			<3885 683 467 123 101 94 90 90>,
+			<4839 759 511 132 125 100 93 105>,
+			<10405 893 581 158 538 131 102 205>,
+			<100430 1304 724 1696 221 1381 141 193>;
+		};
+};
diff --git a/arch/arm/boot/dts/NX503A/msm-pm8941.dtsi b/arch/arm/boot/dts/NX503A/msm-pm8941.dtsi
new file mode 100755
index 0000000..1328620
--- /dev/null
+++ b/arch/arm/boot/dts/NX503A/msm-pm8941.dtsi
@@ -0,0 +1,1523 @@
+/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+&spmi_bus {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	interrupt-controller;
+	#interrupt-cells = <3>;
+};
+
+&pm8941_lsid0 {
+	spmi-slave-container;
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	pm8941_misc: qcom,misc@900 {
+		compatible = "qcom,qpnp-misc";
+		reg = <0x900 0x100>;
+	};
+
+	pm8941_revid: qcom,revid@100 {
+		compatible = "qcom,qpnp-revid";
+		reg = <0x100 0x100>;
+	};
+
+	qcom,temp-alarm@2400 {
+		compatible = "qcom,qpnp-temp-alarm";
+		reg = <0x2400 0x100>;
+		interrupts = <0x0 0x24 0x0>;
+		label = "pm8941_tz";
+		qcom,channel-num = <8>;
+		qcom,threshold-set = <0>;
+		qcom,temp_alarm-vadc = <&pm8941_vadc>;
+	};
+
+	qcom,power-on@800 {
+		compatible = "qcom,qpnp-power-on";
+		reg = <0x800 0x100>;
+		interrupts = <0x0 0x8 0x0>,
+			     <0x0 0x8 0x1>,
+			     <0x0 0x8 0x4>,
+			     <0x0 0x8 0x5>;
+		interrupt-names = "kpdpwr", "resin",
+				"resin-bark", "kpdpwr-resin-bark";
+		qcom,pon-dbc-delay = <15625>;
+		qcom,system-reset;
+		qcom,s3-debounce = <32>;
+
+		qcom,pon_1 {
+			qcom,pon-type = <0>;
+			qcom,pull-up = <1>;
+			linux,code = <116>;
+		};
+/* Removed by yfliu, for PWK
+		qcom,pon_2 {
+			qcom,pon-type = <1>;
+			qcom,support-reset = <1>;
+			qcom,pull-up = <1>;
+			qcom,s1-timer = <0>;
+			qcom,s2-timer = <2000>;
+			qcom,s2-type = <1>;
+			linux,code = <114>;
+			qcom,use-bark;
+		};*/
+
+		qcom,pon_3 {
+			qcom,pon-type = <3>;
+			qcom,support-reset = <1>;
+			qcom,s1-timer = <6720>;
+			qcom,s2-timer = <2000>;
+			qcom,s2-type = <7>;
+			qcom,pull-up = <1>;
+			qcom,use-bark;
+		};
+	};
+
+	bif_ctrl: qcom,bsi@1b00 {
+		compatible = "qcom,qpnp-bsi";
+		reg = <0x1b00 0x100>,
+		      <0x1208 0x1>;
+		reg-names = "bsi-base", "batt-id-status";
+		label = "pm8941-bsi";
+		interrupts = <0x0 0x1b 0x0>,
+			     <0x0 0x1b 0x1>,
+			     <0x0 0x1b 0x2>,
+			     <0x0 0x12 0x0>;
+		interrupt-names = "err",
+				  "rx",
+				  "tx",
+				  "batt-present";
+		qcom,channel-num = <0x31>;
+		qcom,pullup-ohms = <100000>;
+		qcom,vref-microvolts = <1800000>;
+		qcom,min-clock-period = <1000>;
+		qcom,max-clock-period = <160000>;
+		qcom,sample-rate = <4>;
+		qcom,bsi-vadc = <&pm8941_vadc>;
+	};
+
+	pm8941_coincell: qcom,coincell@2800 {
+		compatible = "qcom,qpnp-coincell";
+		reg = <0x2800 0x100>;
+	};
+
+/*
+*BMS
+*          CONFIG_ZTEMT_NX503A_CHARGE
+*/
+	pm8941_bms: qcom,bms {
+		spmi-dev-container;
+		compatible = "qcom,qpnp-bms";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		status = "disabled";
+
+		qcom,r-sense-uohm = <10000>;
+		qcom,v-cutoff-uv = <3400000>;
+			/* qcom,max-voltage-uv = <4200000>; */
+			qcom,max-voltage-uv = <4350000>;		
+		qcom,r-conn-mohm = <0>;
+		qcom,shutdown-soc-valid-limit = <100>;
+		qcom,adjust-soc-low-threshold = <15>;
+		qcom,ocv-voltage-high-threshold-uv = <3750000>;
+		qcom,ocv-voltage-low-threshold-uv = <3650000>;
+		qcom,low-soc-calculate-soc-threshold = <15>;
+		qcom,low-voltage-calculate-soc-ms = <1000>;
+		qcom,low-soc-calculate-soc-ms = <5000>;
+		qcom,calculate-soc-ms = <20000>;
+		qcom,chg-term-ua = <100000>;
+			/* qcom,batt-type = <0>; */
+	  qcom,batt-type = <1>;
+		qcom,low-voltage-threshold = <3420000>;
+		qcom,tm-temp-margin = <5000>;
+		qcom,low-ocv-correction-limit-uv = <100>;
+		qcom,high-ocv-correction-limit-uv = <250>;
+		qcom,hold-soc-est = <3>;
+		qcom,bms-vadc = <&pm8941_vadc>;
+		qcom,bms-iadc = <&pm8941_iadc>;
+		qcom,bms-adc_tm = <&pm8941_adc_tm>;
+    /*ZTEMT Add*/
+    qcom,use-external-rsense = <1>;
+    
+		qcom,batt-pres-status@1208 {
+			reg = <0x1208 0x1>;
+		};
+
+		qcom,bms-iadc@3800 {
+			reg = <0x3800 0x100>;
+		};
+
+		qcom,bms-bms@4000 {
+			reg = <0x4000 0x100>;
+			interrupts =	<0x0 0x40 0x0>,
+					<0x0 0x40 0x1>,
+					<0x0 0x40 0x2>,
+					<0x0 0x40 0x3>,
+					<0x0 0x40 0x4>,
+					<0x0 0x40 0x5>,
+					<0x0 0x40 0x6>,
+					<0x0 0x40 0x7>;
+
+			interrupt-names = "cc_thr",
+					  "ocv_for_r",
+					  "good_ocv",
+					  "charge_begin",
+					  "ocv_thr",
+					  "sw_cc_thr",
+					  "vsense_avg",
+					  "vsense_for_r";
+		};
+	};
+
+	clkdiv@5b00 {
+		reg = <0x5b00 0x100>;
+		compatible = "qcom,qpnp-clkdiv";
+		qcom,cxo-freq = <19200000>;
+	};
+
+	clkdiv@5c00 {
+		reg = <0x5c00 0x100>;
+		compatible = "qcom,qpnp-clkdiv";
+		qcom,cxo-freq = <19200000>;
+	};
+
+	clkdiv@5d00 {
+		reg = <0x5d00 0x1000>;
+		compatible = "qcom,qpnp-clkdiv";
+		qcom,cxo-freq = <19200000>;
+	};
+
+
+/*
+*Charger
+*             CONFIG_ZTEMT_NX503A_CHARGE
+*/
+	pm8941_chg: qcom,charger {
+		spmi-dev-container;
+		compatible = "qcom,qpnp-charger";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		status = "disabled";
+
+	/*	qcom,vddmax-mv = <4200>;*/
+	/*	qcom,vddsafe-mv = <4230>;*/
+			qcom,vddmax-mv = <4350>;
+			qcom,vddsafe-mv = <4360>;
+
+	/*	qcom,vinmin-mv = <4300>;*/
+   qcom,vinmin-mv = <4400>;  
+
+	/* */
+		qcom,ibatmax-ma = <1500>;
+		qcom,ibatterm-ma = <100>;
+/* */
+		qcom,ibatsafe-ma = <1500>;
+
+		qcom,thermal-mitigation = <1500 700 600 325>;
+	/*	qcom,cool-bat-decidegc = <100>;*/
+		qcom,cool-bat-decidegc = <0>;
+	qcom,cool-bat-mv = <4100>;
+		qcom,ibatmax-warm-ma = <350>;
+	/*	qcom,warm-bat-decidegc = <450>;*/
+	qcom,warm-bat-decidegc = <999>;
+		qcom,warm-bat-mv = <4100>;
+		qcom,ibatmax-cool-ma = <350>;
+		qcom,vbatdet-delta-mv = <100>;
+
+       /*Add By ZTEMT -begin -Use Extended Battery Temperature Range*/
+			qcom,batt-hot-percentage = <25>;
+			qcom,batt-cold-percentage = <80>;
+           /*Add By ZTEMT -end*/
+
+		qcom,resume-soc = <99>;
+		qcom,tchg-mins = <150>;
+		qcom,chg-vadc = <&pm8941_vadc>;
+		qcom,chg-iadc = <&pm8941_iadc>;
+		qcom,chg-adc_tm = <&pm8941_adc_tm>;
+		qcom,ibat-calibration-enabled;
+
+ 					 
+		qcom,chgr@1000 {
+			status = "disabled";
+			reg = <0x1000 0x100>;
+			interrupts =	<0x0 0x10 0x0>,
+					<0x0 0x10 0x1>,
+					<0x0 0x10 0x2>,
+					<0x0 0x10 0x3>,
+					<0x0 0x10 0x4>,
+					<0x0 0x10 0x5>,
+					<0x0 0x10 0x6>,
+					<0x0 0x10 0x7>;
+
+			interrupt-names =	"vbat-det-lo",
+						"vbat-det-hi",
+						"chgwdog",
+						"state-change",
+						"trkl-chg-on",
+						"fast-chg-on",
+						"chg-failed",
+						"chg-done";
+		};
+
+		qcom,buck@1100 {
+			status = "disabled";
+			reg = <0x1100 0x100>;
+			interrupts =	<0x0 0x11 0x0>,
+					<0x0 0x11 0x1>,
+					<0x0 0x11 0x2>,
+					<0x0 0x11 0x3>,
+					<0x0 0x11 0x4>,
+					<0x0 0x11 0x5>,
+					<0x0 0x11 0x6>;
+
+			interrupt-names =	"vbat-ov",
+						"vreg-ov",
+						"overtemp",
+						"vchg-loop",
+						"ichg-loop",
+						"ibat-loop",
+						"vdd-loop";
+		};
+
+		pm8941_chg_batif: qcom,bat-if@1200 {
+			status = "disabled";
+			reg = <0x1200 0x100>;
+			interrupts =	<0x0 0x12 0x0>,
+					<0x0 0x12 0x1>,
+					<0x0 0x12 0x2>,
+					<0x0 0x12 0x3>,
+					<0x0 0x12 0x4>;
+
+			interrupt-names =	"batt-pres",
+						"bat-temp-ok",
+						"bat-fet-on",
+						"vcp-on",
+						"psi";
+
+		};
+
+		pm8941_chg_otg: qcom,usb-chgpth@1300 {
+			status = "disabled";
+			reg = <0x1300 0x100>;
+			interrupts =	<0 0x13 0x0>,
+					<0 0x13 0x1>,
+					<0x0 0x13 0x2>;
+
+			interrupt-names =	"coarse-det-usb",
+						"usbin-valid",
+						"chg-gone";
+		};
+
+		qcom,dc-chgpth@1400 {
+			status = "disabled";
+			reg = <0x1400 0x100>;
+			interrupts =	<0x0 0x14 0x0>,
+					<0x0 0x14 0x1>;
+
+			interrupt-names =	"coarse-det-dc",
+						"dcin-valid";
+		};
+
+		pm8941_chg_boost: qcom,boost@1500 {
+			status = "disabled";
+			reg = <0x1500 0x100>;
+			interrupts =	<0x0 0x15 0x0>,
+					<0x0 0x15 0x1>;
+
+			interrupt-names =	"boost-pwr-ok",
+						"limit-error";
+		};
+
+		qcom,chg-misc@1600 {
+			status = "disabled";
+			reg = <0x1600 0x100>;
+		};
+	};
+
+    ztemt_hw_version{
+		spmi-dev-container;
+		compatible = "qcom,qpnp-ztemt_hw_version";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		status = "ok";	
+	};
+	pm8941_gpios: gpios {
+		spmi-dev-container;
+		compatible = "qcom,qpnp-pin";
+		gpio-controller;
+		#gpio-cells = <2>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		label = "pm8941-gpio";
+
+		gpio@c000 {
+			reg = <0xc000 0x100>;
+			qcom,pin-num = <1>;
+		};
+
+		gpio@c100 {
+			reg = <0xc100 0x100>;
+			qcom,pin-num = <2>;
+		};
+
+		gpio@c200 {
+			reg = <0xc200 0x100>;
+			qcom,pin-num = <3>;
+		};
+
+		gpio@c300 {
+			reg = <0xc300 0x100>;
+			qcom,pin-num = <4>;
+		};
+
+		gpio@c400 {
+			reg = <0xc400 0x100>;
+			qcom,pin-num = <5>;
+		};
+
+		gpio@c500 {
+			reg = <0xc500 0x100>;
+			qcom,pin-num = <6>;
+		};
+
+		gpio@c600 {
+			reg = <0xc600 0x100>;
+			qcom,pin-num = <7>;
+		};
+
+		gpio@c700 {
+			reg = <0xc700 0x100>;
+			qcom,pin-num = <8>;
+		};
+
+		gpio@c800 {
+			reg = <0xc800 0x100>;
+			qcom,pin-num = <9>;
+		};
+
+		gpio@c900 {
+			reg = <0xc900 0x100>;
+			qcom,pin-num = <10>;
+		};
+
+		gpio@ca00 {
+			reg = <0xca00 0x100>;
+			qcom,pin-num = <11>;
+		};
+
+		gpio@cb00 {
+			reg = <0xcb00 0x100>;
+			qcom,pin-num = <12>;
+		};
+
+		gpio@cc00 {
+			reg = <0xcc00 0x100>;
+			qcom,pin-num = <13>;
+		};
+
+		gpio@cd00 {
+			reg = <0xcd00 0x100>;
+			qcom,pin-num = <14>;
+		};
+
+		gpio@ce00 {
+			reg = <0xce00 0x100>;
+			qcom,pin-num = <15>;
+		};
+
+		gpio@cf00 {
+			reg = <0xcf00 0x100>;
+			qcom,pin-num = <16>;
+		};
+
+		gpio@d000 {
+			reg = <0xd000 0x100>;
+			qcom,pin-num = <17>;
+		};
+
+		gpio@d100 {
+			reg = <0xd100 0x100>;
+			qcom,pin-num = <18>;
+		};
+
+		gpio@d200 {
+			reg = <0xd200 0x100>;
+			qcom,pin-num = <19>;
+		};
+
+		gpio@d300 {
+			reg = <0xd300 0x100>;
+			qcom,pin-num = <20>;
+		};
+
+		gpio@d400 {
+			reg = <0xd400 0x100>;
+			qcom,pin-num = <21>;
+		};
+
+		gpio@d500 {
+			reg = <0xd500 0x100>;
+			qcom,pin-num = <22>;
+		};
+
+		gpio@d600 {
+			reg = <0xd600 0x100>;
+			qcom,pin-num = <23>;
+		};
+
+		gpio@d700 {
+			reg = <0xd700 0x100>;
+			qcom,pin-num = <24>;
+		};
+
+		gpio@d800 {
+			reg = <0xd800 0x100>;
+			qcom,pin-num = <25>;
+		};
+
+		gpio@d900 {
+			reg = <0xd900 0x100>;
+			qcom,pin-num = <26>;
+		};
+
+		gpio@da00 {
+			reg = <0xda00 0x100>;
+			qcom,pin-num = <27>;
+		};
+
+		gpio@db00 {
+			reg = <0xdb00 0x100>;
+			qcom,pin-num = <28>;
+		};
+
+		gpio@dc00 {
+			reg = <0xdc00 0x100>;
+			qcom,pin-num = <29>;
+		};
+
+		gpio@dd00 {
+			reg = <0xdd00 0x100>;
+			qcom,pin-num = <30>;
+		};
+
+		gpio@de00 {
+			reg = <0xde00 0x100>;
+			qcom,pin-num = <31>;
+		};
+
+		gpio@df00 {
+			reg = <0xdf00 0x100>;
+			qcom,pin-num = <32>;
+		};
+
+		gpio@e000 {
+			reg = <0xe000 0x100>;
+			qcom,pin-num = <33>;
+		};
+
+		gpio@e100 {
+			reg = <0xe100 0x100>;
+			qcom,pin-num = <34>;
+		};
+
+		gpio@e200 {
+			reg = <0xe200 0x100>;
+			qcom,pin-num = <35>;
+		};
+
+		gpio@e300 {
+			reg = <0xe300 0x100>;
+			qcom,pin-num = <36>;
+		};
+	};
+
+	pm8941_mpps: mpps {
+		spmi-dev-container;
+		compatible = "qcom,qpnp-pin";
+		gpio-controller;
+		#gpio-cells = <2>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		label = "pm8941-mpp";
+
+		mpp@a000 {
+			reg = <0xa000 0x100>;
+			qcom,pin-num = <1>;
+		};
+
+		mpp@a100 {
+			reg = <0xa100 0x100>;
+			qcom,pin-num = <2>;
+		};
+
+		mpp@a200 {
+			reg = <0xa200 0x100>;
+			qcom,pin-num = <3>;
+		};
+
+		mpp@a300 {
+			reg = <0xa300 0x100>;
+			qcom,pin-num = <4>;
+		};
+
+		mpp@a400 {
+			reg = <0xa400 0x100>;
+			qcom,pin-num = <5>;
+		};
+
+		mpp@a500 {
+			reg = <0xa500 0x100>;
+			qcom,pin-num = <6>;
+		};
+
+		mpp@a600 {
+			reg = <0xa600 0x100>;
+			qcom,pin-num = <7>;
+		};
+
+		mpp@a700 {
+			reg = <0xa700 0x100>;
+			qcom,pin-num = <8>;
+		};
+	};
+
+	qcom,pm8941_rtc {
+		spmi-dev-container;
+		compatible = "qcom,qpnp-rtc";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		qcom,qpnp-rtc-write = <0>;
+		qcom,qpnp-rtc-alarm-pwrup = <0>;
+
+		qcom,pm8941_rtc_rw@6000 {
+			reg = <0x6000 0x100>;
+		};
+		qcom,pm8941_rtc_alarm@6100 {
+			reg = <0x6100 0x100>;
+			interrupts = <0x0 0x61 0x1>;
+		};
+	};
+
+	pm8941_vadc: vadc@3100 {
+		compatible = "qcom,qpnp-vadc";
+		reg = <0x3100 0x100>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		interrupts = <0x0 0x31 0x0>;
+		interrupt-names = "eoc-int-en-set";
+		qcom,adc-bit-resolution = <15>;
+		qcom,adc-vdd-reference = <1800>;
+		qcom,vadc-poll-eoc;
+		qcom,pmic-revid = <&pm8941_revid>;
+
+		chan@0 {
+			label = "usb_in";
+			reg = <0>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <4>;
+			qcom,calibration-type = "absolute";
+			qcom,scale-function = <0>;
+			qcom,hw-settle-time = <0>;
+			qcom,fast-avg-setup = <0>;
+		};
+
+		chan@1 {
+			label = "dc_in";
+			reg = <1>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <4>;
+			qcom,calibration-type = "absolute";
+			qcom,scale-function = <0>;
+			qcom,hw-settle-time = <0>;
+			qcom,fast-avg-setup = <0>;
+		};
+
+		chan@2 {
+			label = "vchg_sns";
+			reg = <2>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <3>;
+			qcom,calibration-type = "absolute";
+			qcom,scale-function = <0>;
+			qcom,hw-settle-time = <0>;
+			qcom,fast-avg-setup = <0>;
+		};
+
+		chan@3 {
+			label = "spare1_div3";
+			reg = <3>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <1>;
+			qcom,calibration-type = "absolute";
+			qcom,scale-function = <0>;
+			qcom,hw-settle-time = <0>;
+			qcom,fast-avg-setup = <0>;
+		};
+
+		chan@4 {
+			label = "usb_id_mv";
+			reg = <4>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <1>;
+			qcom,calibration-type = "absolute";
+			qcom,scale-function = <0>;
+			qcom,hw-settle-time = <0>;
+			qcom,fast-avg-setup = <0>;
+		};
+
+		chan@5 {
+			label = "vcoin";
+			reg = <5>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <1>;
+			qcom,calibration-type = "absolute";
+			qcom,scale-function = <0>;
+			qcom,hw-settle-time = <0>;
+			qcom,fast-avg-setup = <0>;
+		};
+
+		chan@6 {
+			label = "vbat_sns";
+			reg = <6>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <1>;
+			qcom,calibration-type = "absolute";
+			qcom,scale-function = <0>;
+			qcom,hw-settle-time = <0>;
+			qcom,fast-avg-setup = <0>;
+		};
+
+		chan@7 {
+			label = "vph_pwr";
+			reg = <7>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <1>;
+			qcom,calibration-type = "absolute";
+			qcom,scale-function = <0>;
+			qcom,hw-settle-time = <0>;
+			qcom,fast-avg-setup = <0>;
+		};
+
+		chan@8 {
+			label = "die_temp";
+			reg = <8>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <0>;
+			qcom,calibration-type = "absolute";
+			qcom,scale-function = <3>;
+			qcom,hw-settle-time = <0>;
+			qcom,fast-avg-setup = <0>;
+		};
+
+		chan@9 {
+			label = "ref_625mv";
+			reg = <9>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <0>;
+			qcom,calibration-type = "absolute";
+			qcom,scale-function = <0>;
+			qcom,hw-settle-time = <0>;
+			qcom,fast-avg-setup = <0>;
+		};
+
+		chan@a {
+			label = "ref_1250v";
+			reg = <0xa>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <0>;
+			qcom,calibration-type = "absolute";
+			qcom,scale-function = <0>;
+			qcom,hw-settle-time = <0>;
+			qcom,fast-avg-setup = <0>;
+		};
+
+		chan@30 {
+			label = "batt_therm";
+			reg = <0x30>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <0>;
+			qcom,calibration-type = "ratiometric";
+			qcom,scale-function = <1>;
+			qcom,hw-settle-time = <2>;
+			qcom,fast-avg-setup = <0>;
+		};
+
+		chan@31 {
+			label = "batt_id";
+			reg = <0x31>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <0>;
+			qcom,calibration-type = "ratiometric";
+			qcom,scale-function = <0>;
+			qcom,hw-settle-time = <2>;
+			qcom,fast-avg-setup = <0>;
+		};
+
+		chan@b2 {
+			label = "xo_therm_pu2";
+			reg = <0xb2>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <0>;
+			qcom,calibration-type = "ratiometric";
+			qcom,scale-function = <4>;
+			qcom,hw-settle-time = <2>;
+			qcom,fast-avg-setup = <0>;
+		};
+
+		chan@b3 {
+			label = "msm_therm";
+			reg = <0xb3>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <0>;
+			qcom,calibration-type = "ratiometric";
+			qcom,scale-function = <2>;
+			qcom,hw-settle-time = <2>;
+			qcom,fast-avg-setup = <0>;
+		};
+
+		chan@b4 {
+			label = "emmc_therm";
+			reg = <0xb4>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <0>;
+			qcom,calibration-type = "ratiometric";
+			qcom,scale-function = <2>;
+			qcom,hw-settle-time = <2>;
+			qcom,fast-avg-setup = <0>;
+		};
+
+		chan@b5 {
+			label = "pa_therm0";
+			reg = <0xb5>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <0>;
+			qcom,calibration-type = "ratiometric";
+			qcom,scale-function = <2>;
+			qcom,hw-settle-time = <2>;
+			qcom,fast-avg-setup = <0>;
+		};
+
+		chan@b7 {
+			label = "pa_therm1";
+			reg = <0xb7>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <0>;
+			qcom,calibration-type = "ratiometric";
+			qcom,scale-function = <2>;
+			qcom,hw-settle-time = <2>;
+			qcom,fast-avg-setup = <0>;
+		};
+
+		chan@b8 {
+			label = "quiet_therm";
+			reg = <0xb8>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <0>;
+			qcom,calibration-type = "ratiometric";
+			qcom,scale-function = <2>;
+			qcom,hw-settle-time = <2>;
+			qcom,fast-avg-setup = <0>;
+		};
+
+		chan@b9 {
+			label = "usb_id";
+			reg = <0xb9>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <0>;
+			qcom,calibration-type = "ratiometric";
+			qcom,scale-function = <0>;
+			qcom,hw-settle-time = <2>;
+			qcom,fast-avg-setup = <0>;
+		};
+
+/**
+CONFIG_ZTEMT_NX503A_CHARGE
+*/
+/*Device Info*/
+			chan@33 {
+				label = "AMUX1";
+				reg = <0x33>;
+				qcom,decimation = <0>;
+				qcom,pre-div-channel-scaling = <0>;
+				qcom,calibration-type = "ratiometric";
+				qcom,scale-function = <0>;
+				qcom,hw-settle-time = <2>;
+				qcom,fast-avg-setup = <0>;
+			};
+
+			chan@34 {
+				label = "AMUX2";
+				reg = <0x34>;
+				qcom,decimation = <0>;
+				qcom,pre-div-channel-scaling = <0>;
+				qcom,calibration-type = "ratiometric";
+				qcom,scale-function = <0>;
+				qcom,hw-settle-time = <2>;
+				qcom,fast-avg-setup = <0>;
+			};
+			
+		chan@39 {
+			label = "usb_id_nopull";
+			reg = <0x39>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <0>;
+			qcom,calibration-type = "ratiometric";
+			qcom,scale-function = <0>;
+			qcom,hw-settle-time = <2>;
+			qcom,fast-avg-setup = <0>;
+		};
+	};
+
+	pm8941_iadc: iadc@3600 {
+		compatible = "qcom,qpnp-iadc";
+		reg = <0x3600 0x100>,
+		      <0x12f1 0x1>;
+		reg-names = "iadc-base", "batt-id-trim-cnst-rds";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		interrupts = <0x0 0x36 0x0>;
+		interrupt-names = "eoc-int-en-set";
+		qcom,adc-bit-resolution = <16>;
+		qcom,adc-vdd-reference = <1800>;
+		qcom,iadc-vadc = <&pm8941_vadc>;
+		qcom,iadc-poll-eoc;
+		qcom,use-default-rds-trim = <0>;
+		qcom,pmic-revid = <&pm8941_revid>;
+
+		chan@0 {
+			label = "internal_rsense";
+			reg = <0>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <1>;
+			qcom,calibration-type = "absolute";
+			qcom,scale-function = <0>;
+			qcom,hw-settle-time = <0>;
+			qcom,fast-avg-setup = <0>;
+		};
+	};
+
+	pm8941_adc_tm: qcom,vadc@3400 {
+		compatible = "qcom,qpnp-adc-tm";
+		reg = <0x3400 0x100>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		interrupts =	<0x0 0x34 0x0>,
+				<0x0 0x34 0x3>,
+			     <0x0 0x34 0x4>;
+		interrupt-names =	"eoc-int-en-set",
+					"high-thr-en-set",
+					"low-thr-en-set";
+		qcom,adc-bit-resolution = <15>;
+		qcom,adc-vdd-reference = <1800>;
+		qcom,adc_tm-vadc = <&pm8941_vadc>;
+
+		/* Channel Node */
+		chan@b9 {
+			label = "usb_id";
+			reg = <0xb9>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <0>;
+			qcom,calibration-type = "ratiometric";
+			qcom,scale-function = <2>;
+			qcom,hw-settle-time = <2>;
+			qcom,fast-avg-setup = <3>;
+			qcom,btm-channel-number = <0x48>;
+		};
+
+		chan@30 {
+			label = "batt_therm";
+			reg = <0x30>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <0>;
+			qcom,calibration-type = "ratiometric";
+			qcom,scale-function = <1>;
+			qcom,hw-settle-time = <2>;
+			qcom,fast-avg-setup = <3>;
+			qcom,btm-channel-number = <0x68>;
+			qcom,meas-interval-timer-idx = <2>;
+		};
+
+		chan@8 {
+			label = "die_temp";
+			reg = <8>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <0>;
+			qcom,calibration-type = "absolute";
+			qcom,scale-function = <3>;
+			qcom,hw-settle-time = <0>;
+			qcom,fast-avg-setup = <3>;
+			qcom,btm-channel-number = <0x70>;
+		};
+
+		chan@6 {
+			label = "vbat_sns";
+			reg = <6>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <1>;
+			qcom,calibration-type = "absolute";
+			qcom,scale-function = <0>;
+			qcom,hw-settle-time = <0>;
+			qcom,fast-avg-setup = <3>;
+			qcom,btm-channel-number = <0x78>;
+		};
+
+		chan@b5 {
+			label = "pa_therm0";
+			reg = <0xb5>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <0>;
+			qcom,calibration-type = "ratiometric";
+			qcom,scale-function = <2>;
+			qcom,hw-settle-time = <2>;
+			qcom,fast-avg-setup = <3>;
+			qcom,btm-channel-number = <0x80>;
+			qcom,thermal-node;
+		};
+
+		chan@b7 {
+			label = "pa_therm1";
+			reg = <0xb7>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <0>;
+			qcom,calibration-type = "ratiometric";
+			qcom,scale-function = <2>;
+			qcom,hw-settle-time = <2>;
+			qcom,fast-avg-setup = <3>;
+			qcom,btm-channel-number = <0x88>;
+			qcom,thermal-node;
+		};
+
+		chan@b4 {
+			label = "emmc_therm";
+			reg = <0xb4>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <0>;
+			qcom,calibration-type = "ratiometric";
+			qcom,scale-function = <2>;
+			qcom,hw-settle-time = <2>;
+			qcom,fast-avg-setup = <3>;
+			qcom,btm-channel-number = <0x90>;
+			qcom,thermal-node;
+		};
+
+		chan@b3 {
+			label = "msm_therm";
+			reg = <0xb3>;
+			qcom,decimation = <0>;
+			qcom,pre-div-channel-scaling = <0>;
+			qcom,calibration-type = "ratiometric";
+			qcom,scale-function = <2>;
+			qcom,hw-settle-time = <2>;
+			qcom,fast-avg-setup = <3>;
+			qcom,btm-channel-number = <0x98>;
+			qcom,thermal-node;
+		};
+	};
+};
+
+&pm8941_lsid1 {
+	spmi-slave-container;
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	regulator@1400 {
+		regulator-name = "8941_s1";
+		spmi-dev-container;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "qcom,qpnp-regulator";
+		reg = <0x1400 0x300>;
+		status = "disabled";
+
+		qcom,ctl@1400 {
+			reg = <0x1400 0x100>;
+		};
+		qcom,ps@1500 {
+			reg = <0x1500 0x100>;
+		};
+		qcom,freq@1600 {
+			reg = <0x1600 0x100>;
+		};
+	};
+
+	regulator@1700 {
+		regulator-name = "8941_s2";
+		spmi-dev-container;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "qcom,qpnp-regulator";
+		reg = <0x1700 0x300>;
+		status = "disabled";
+
+		qcom,ctl@1700 {
+			reg = <0x1700 0x100>;
+		};
+		qcom,ps@1800 {
+			reg = <0x1800 0x100>;
+		};
+		qcom,freq@1900 {
+			reg = <0x1900 0x100>;
+		};
+	};
+
+	regulator@1a00 {
+		regulator-name = "8941_s3";
+		spmi-dev-container;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "qcom,qpnp-regulator";
+		reg = <0x1a00 0x300>;
+		status = "disabled";
+
+		qcom,ctl@1a00 {
+			reg = <0x1a00 0x100>;
+		};
+		qcom,ps@1b00 {
+			reg = <0x1b00 0x100>;
+		};
+		qcom,freq@1c00 {
+			reg = <0x1c00 0x100>;
+		};
+	};
+
+	regulator@a000 {
+		regulator-name = "8941_boost";
+		reg = <0xa000 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@4000 {
+		regulator-name = "8941_l1";
+		reg = <0x4000 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@4100 {
+		regulator-name = "8941_l2";
+		reg = <0x4100 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@4200 {
+		regulator-name = "8941_l3";
+		reg = <0x4200 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@4300 {
+		regulator-name = "8941_l4";
+		reg = <0x4300 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@4400 {
+		regulator-name = "8941_l5";
+		reg = <0x4400 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		qcom,force-type = <0x04 0x10>;
+		status = "disabled";
+	};
+
+	regulator@4500 {
+		regulator-name = "8941_l6";
+		reg = <0x4500 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@4600 {
+		regulator-name = "8941_l7";
+		reg = <0x4600 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		qcom,force-type = <0x04 0x10>;
+		status = "disabled";
+	};
+
+	regulator@4700 {
+		regulator-name = "8941_l8";
+		reg = <0x4700 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@4800 {
+		regulator-name = "8941_l9";
+		reg = <0x4800 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@4900 {
+		regulator-name = "8941_l10";
+		reg = <0x4900 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@4a00 {
+		regulator-name = "8941_l11";
+		reg = <0x4a00 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@4b00 {
+		regulator-name = "8941_l12";
+		reg = <0x4b00 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@4c00 {
+		regulator-name = "8941_l13";
+		reg = <0x4c00 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@4d00 {
+		regulator-name = "8941_l14";
+		reg = <0x4d00 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@4e00 {
+		regulator-name = "8941_l15";
+		reg = <0x4e00 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@4f00 {
+		regulator-name = "8941_l16";
+		reg = <0x4f00 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@5000 {
+		regulator-name = "8941_l17";
+		reg = <0x5000 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@5100 {
+		regulator-name = "8941_l18";
+		reg = <0x5100 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@5200 {
+		regulator-name = "8941_l19";
+		reg = <0x5200 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@5300 {
+		regulator-name = "8941_l20";
+		reg = <0x5300 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@5400 {
+		regulator-name = "8941_l21";
+		reg = <0x5400 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@5500 {
+		regulator-name = "8941_l22";
+		reg = <0x5500 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@5600 {
+		regulator-name = "8941_l23";
+		reg = <0x5600 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@5700 {
+		regulator-name = "8941_l24";
+		reg = <0x5700 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@8000 {
+		regulator-name = "8941_lvs1";
+		reg = <0x8000 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@8100 {
+		regulator-name = "8941_lvs2";
+		reg = <0x8100 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@8200 {
+		regulator-name = "8941_lvs3";
+		reg = <0x8200 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@8300 {
+		regulator-name = "8941_mvs1";
+		reg = <0x8300 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	regulator@8400 {
+		regulator-name = "8941_mvs2";
+		reg = <0x8400 0x100>;
+		compatible = "qcom,qpnp-regulator";
+		status = "disabled";
+	};
+
+	qcom,vibrator@c000 {
+		compatible = "qcom,qpnp-vibrator";
+		reg = <0xc000 0x100>;
+		label = "vibrator";
+		status = "disabled";
+	};
+
+	qcom,leds@d000 {
+		compatible = "qcom,leds-qpnp";
+		reg = <0xd000 0x100>;
+		label = "rgb";
+	};
+
+	qcom,leds@d100 {
+		compatible = "qcom,leds-qpnp";
+		reg = <0xd100 0x100>;
+		label = "rgb";
+	};
+
+	qcom,leds@d200 {
+		compatible = "qcom,leds-qpnp";
+		reg = <0xd200 0x100>;
+		label = "rgb";
+	};
+
+	qcom,leds@d300 {
+		compatible = "qcom,leds-qpnp";
+		reg = <0xd300 0x100>;
+		label = "flash";
+		flash-boost-supply = <&pm8941_chg_boost>;
+		torch-boost-supply = <&pm8941_boost>;
+	};
+
+	qcom,leds@d400 {
+		compatible = "qcom,leds-qpnp";
+		reg = <0xd400 0x100>;
+		label = "flash";
+	};
+
+	qcom,leds@d500 {
+		compatible = "qcom,leds-qpnp";
+		reg = <0xd500 0x100>;
+		label = "flash";
+	};
+
+	qcom,leds@d600 {
+		compatible = "qcom,leds-qpnp";
+		reg = <0xd600 0x100>;
+		label = "flash";
+	};
+
+	qcom,leds@d700 {
+		compatible = "qcom,leds-qpnp";
+		reg = <0xd700 0x100>;
+		label = "flash";
+	};
+
+	qcom,leds@d800 {
+		compatible = "qcom,leds-qpnp";
+		reg = <0xd800 0x100>;
+		label = "wled";
+	};
+
+	qcom,leds@d900 {
+		compatible = "qcom,leds-qpnp";
+		reg = <0xd900 0x100>;
+		label = "wled";
+	};
+
+	qcom,leds@da00 {
+		compatible = "qcom,leds-qpnp";
+		reg = <0xda00 0x100>;
+		label = "wled";
+	};
+
+	qcom,leds@db00 {
+		compatible = "qcom,leds-qpnp";
+		reg = <0xdb00 0x100>;
+		label = "wled";
+	};
+
+	qcom,leds@dc00 {
+		compatible = "qcom,leds-qpnp";
+		reg = <0xdc00 0x100>;
+		label = "wled";
+	};
+
+	qcom,leds@dd00 {
+		compatible = "qcom,leds-qpnp";
+		reg = <0xdd00 0x100>;
+		label = "wled";
+	};
+
+	qcom,leds@de00 {
+		compatible = "qcom,leds-qpnp";
+		reg = <0xde00 0x100>;
+		label = "wled";
+	};
+
+	qcom,leds@df00 {
+		compatible = "qcom,leds-qpnp";
+		reg = <0xdf00 0x100>;
+		label = "wled";
+	};
+
+	qcom,leds@e000 {
+		compatible = "qcom,leds-qpnp";
+		reg = <0xe000 0x100>;
+		label = "wled";
+	};
+
+	qcom,leds@e100 {
+		compatible = "qcom,leds-qpnp";
+		reg = <0xe100 0x100>;
+		label = "wled";
+	};
+
+	qcom,leds@e200 {
+		compatible = "qcom,leds-qpnp";
+		reg = <0xe200 0x100>;
+		label = "kpdbl";
+	};
+
+	pwm@b100 {
+		compatible = "qcom,qpnp-pwm";
+		reg = <0xb100 0x100>,
+		      <0xb042 0x7e>;
+		reg-names = "qpnp-lpg-channel-base", "qpnp-lpg-lut-base";
+		qcom,channel-id = <0>;
+	};
+
+	pwm@b200 {
+		compatible = "qcom,qpnp-pwm";
+		reg = <0xb200 0x100>,
+		      <0xb042 0x7e>;
+		reg-names = "qpnp-lpg-channel-base", "qpnp-lpg-lut-base";
+		qcom,channel-id = <1>;
+	};
+
+	pwm@b300 {
+		compatible = "qcom,qpnp-pwm";
+		reg = <0xb300 0x100>,
+		      <0xb042 0x7e>;
+		reg-names = "qpnp-lpg-channel-base", "qpnp-lpg-lut-base";
+		qcom,channel-id = <2>;
+	};
+
+	pwm@b400 {
+		compatible = "qcom,qpnp-pwm";
+		reg = <0xb400 0x100>,
+		      <0xb042 0x7e>;
+		reg-names = "qpnp-lpg-channel-base", "qpnp-lpg-lut-base";
+		qcom,channel-id = <3>;
+	};
+
+	pwm@b500 {
+		compatible = "qcom,qpnp-pwm";
+		reg = <0xb500 0x100>,
+		      <0xb042 0x7e>;
+		reg-names = "qpnp-lpg-channel-base", "qpnp-lpg-lut-base";
+		qcom,channel-id = <4>;
+	};
+
+	pwm@b600 {
+		compatible = "qcom,qpnp-pwm";
+		reg = <0xb600 0x100>,
+		      <0xb042 0x7e>;
+		reg-names = "qpnp-lpg-channel-base", "qpnp-lpg-lut-base";
+		qcom,channel-id = <5>;
+	};
+
+	pwm@b700 {
+		compatible = "qcom,qpnp-pwm";
+		reg = <0xb700 0x100>,
+		      <0xb042 0x7e>;
+		reg-names = "qpnp-lpg-channel-base", "qpnp-lpg-lut-base";
+		qcom,channel-id = <6>;
+	};
+
+	pwm@b800 {
+		compatible = "qcom,qpnp-pwm";
+		reg = <0xb800 0x100>,
+		      <0xb042 0x7e>;
+		reg-names = "qpnp-lpg-channel-base", "qpnp-lpg-lut-base";
+		qcom,channel-id = <7>;
+	};
+
+	pwm@e400 {
+		compatible = "qcom,qpnp-pwm";
+		reg = <0xe400 0x100>,
+		      <0xe342 0x1e>;
+		reg-names = "qpnp-lpg-channel-base", "qpnp-lpg-lut-base";
+		qcom,channel-id = <8>;
+	};
+
+	pwm@e500 {
+		compatible = "qcom,qpnp-pwm";
+		reg = <0xe500 0x100>,
+		      <0xe342 0x1e>;
+		reg-names = "qpnp-lpg-channel-base", "qpnp-lpg-lut-base";
+		qcom,channel-id = <9>;
+	};
+
+	pwm@e600 {
+		compatible = "qcom,qpnp-pwm";
+		reg = <0xe600 0x100>,
+		      <0xe342 0x1e>;
+		reg-names = "qpnp-lpg-channel-base", "qpnp-lpg-lut-base";
+		qcom,channel-id = <10>;
+	};
+
+	pwm@e700 {
+		compatible = "qcom,qpnp-pwm";
+		reg = <0xe700 0x100>,
+		      <0xe342 0x1e>;
+		reg-names = "qpnp-lpg-channel-base", "qpnp-lpg-lut-base";
+		qcom,channel-id = <11>;
+	};
+};
diff --git a/arch/arm/boot/dts/NX503A/msm8974-camera-sensor-mtp.dtsi b/arch/arm/boot/dts/NX503A/msm8974-camera-sensor-mtp.dtsi
new file mode 100755
index 0000000..a4759ff
--- /dev/null
+++ b/arch/arm/boot/dts/NX503A/msm8974-camera-sensor-mtp.dtsi
@@ -0,0 +1,377 @@
+/*
+ * Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+&soc {
+	led_flash0: qcom,camera-led-flash {
+		cell-index = <0>;
+		compatible = "qcom,camera-led-flash";
+		qcom,flash-type = <1>;
+		qcom,torch-source = <&pm8941_torch>;
+		qcom,flash-source = <&pm8941_flash0 &pm8941_flash1>;
+	};
+};
+
+&cci {
+
+	actuator0: qcom,actuator@1c {
+		cell-index = <0>;
+		reg = <0x1c>;
+		compatible = "qcom,actuator";
+		qcom,cci-master = <0>;
+	};
+
+	actuator1: qcom,actuator@36 {
+		cell-index = <1>;
+		reg = <0x36>;
+		compatible = "qcom,actuator";
+		qcom,cci-master = <0>;
+	};
+	/* add liteon 06913ma*/
+	actuator8: qcom,actuator@18 {
+		cell-index = <8>;
+		reg = <0x18>;
+		compatible = "qcom,actuator";
+		qcom,cci-master = <0>;
+	};
+	qcom,camera@6e {
+		compatible = "qcom,s5k3l1yx";
+		reg = <0x6e>;
+		qcom,slave-id = <0x6e 0x0 0x3121>;
+		qcom,csiphy-sd-index = <0>;
+		qcom,csid-sd-index = <0>;
+		qcom,actuator-src = <&actuator0>;
+		qcom,led-flash-src = <&led_flash0>;
+		qcom,mount-angle = <90>;
+		qcom,sensor-name = "s5k3l1yx";
+		cam_vdig-supply = <&pm8941_l3>;
+		cam_vana-supply = <&pm8941_l17>;
+		cam_vio-supply = <&pm8941_lvs3>;
+		cam_vaf-supply = <&pm8941_l23>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
+				     "cam_vaf";
+		qcom,cam-vreg-type = <0 1 0 0>;
+		qcom,cam-vreg-min-voltage = <1225000 0 2850000 3000000>;
+		qcom,cam-vreg-max-voltage = <1225000 0 2850000 3000000>;
+		qcom,cam-vreg-op-mode = <105000 0 80000 100000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 15 0>,
+			<&msmgpio 90 0>,
+			<&msmgpio 89 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1",
+					  "CAM_STANDBY";
+		qcom,gpio-set-tbl-num = <1 1>;
+		qcom,gpio-set-tbl-flags = <0 2>;
+		qcom,gpio-set-tbl-delay = <1000 30000>;
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x1F>;
+		qcom,sensor-position = <0>;
+		qcom,sensor-mode = <1>;
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+
+    qcom,camera@20 {
+		compatible = "qcom,imx135_z5s";
+		reg = <0x20>;
+		qcom,slave-id = <0x20 0x0016 0x0135>;
+		qcom,csiphy-sd-index = <0>;
+		qcom,csid-sd-index = <0>;
+		qcom,mount-angle = <90>;
+		qcom,sensor-name = "imx135_z5s";
+		qcom,actuator-src = <&actuator0>;
+		qcom,led-flash-src = <&led_flash0>;
+		cam_vdig-supply = <&pm8941_l3>;
+		cam_vana-supply = <&pm8941_l23>;
+		cam_vio-supply = <&pm8941_lvs2>;
+		cam_vaf-supply = <&pm8941_l19>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
+				     "cam_vaf";
+		qcom,cam-vreg-type = <0 1 0 0>;
+		qcom,cam-vreg-min-voltage = <1050000 0 2800000 2800000>;
+		qcom,cam-vreg-max-voltage = <1050000 0 2800000 2800000>;
+		qcom,cam-vreg-op-mode = <105000 0 80000 400000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 15 0>,
+			<&msmgpio 90 0>,
+			<&msmgpio 89 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1",
+					  "CAM_STANDBY";
+		qcom,gpio-set-tbl-num = <1 1>;
+		qcom,gpio-set-tbl-flags = <0 2>;
+		qcom,gpio-set-tbl-delay = <1000 30000>;
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x1F>;
+		qcom,sensor-position = <0>;
+		qcom,sensor-mode = <0>;
+	        qcom,sensor-type = <0>;
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+
+       qcom,camera@200 {
+		compatible = "qcom,imx135_z5s_069";
+		reg = <0x200>;
+		qcom,slave-id = <0x20 0x0016 0x0135>;
+		qcom,csiphy-sd-index = <0>;
+		qcom,csid-sd-index = <0>;
+		qcom,led-flash-src = <&led_flash0>;
+		qcom,mount-angle = <90>;
+		qcom,sensor-name = "imx135_z5s_069";
+		qcom,vdd-cx-supply = <&pm8841_s2>;
+		qcom,vdd-cx-name = "qcom,vdd-cx";
+		qcom,actuator-src = <&actuator8>;
+		cam_vdig-supply = <&pm8941_l3>;
+		cam_vana-supply = <&pm8941_l23>;
+		cam_vio-supply = <&pm8941_lvs2>;
+		cam_vaf-supply = <&pm8941_l19>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
+				     "cam_vaf";
+		qcom,cam-vreg-type = <0 1 0 0>;
+		qcom,cam-vreg-min-voltage = <1050000 0 2800000 2800000>;
+		qcom,cam-vreg-max-voltage = <1050000 0 2800000 2800000>;
+		qcom,cam-vreg-op-mode = <105000 0 80000 400000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 15 0>,
+			<&msmgpio 90 0>,
+			<&msmgpio 89 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1",
+					  "CAM_STANDBY";
+		qcom,gpio-set-tbl-num = <1 1>;
+		qcom,gpio-set-tbl-flags = <0 2>;
+		qcom,gpio-set-tbl-delay = <1000 30000>;
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x1F>;
+		qcom,sensor-position = <0>;
+		qcom,sensor-mode = <0>;
+	        qcom,sensor-type = <0>;
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+
+	qcom,camera@6c {
+		compatible = "qcom,ov2720";
+		reg = <0x6c>;
+		qcom,slave-id = <0x6c 0x300A 0x2720>;
+		qcom,csiphy-sd-index = <2>;
+		qcom,csid-sd-index = <2>;
+		qcom,mount-angle = <90>;
+		qcom,sensor-name = "ov2720";
+		cam_vdig-supply = <&pm8941_l3>;
+		cam_vana-supply = <&pm8941_l17>;
+		cam_vio-supply = <&pm8941_lvs3>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vana", "cam_vio";
+		qcom,cam-vreg-type = <0 0 1>;
+		qcom,cam-vreg-min-voltage = <1225000 2850000 0>;
+		qcom,cam-vreg-max-voltage = <1225000 2850000 0>;
+		qcom,cam-vreg-op-mode = <105000 80000 0>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 17 0>,
+			<&msmgpio 18 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-req-tbl-num = <0 1>;
+		qcom,gpio-req-tbl-flags = <1 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1";
+		qcom,gpio-set-tbl-num = <1 1>;
+		qcom,gpio-set-tbl-flags = <0 2>;
+		qcom,gpio-set-tbl-delay = <1000 4000>;
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x7>;
+		qcom,sensor-position = <1>;
+		qcom,sensor-mode = <1>;
+		qcom,cci-master = <1>;
+		status = "ok";
+	};
+
+	qcom,camera@90 {
+		compatible = "qcom,mt9m114";
+		reg = <0x90>;
+		qcom,slave-id = <0x90 0x0 0x2481>;
+		qcom,csiphy-sd-index = <1>;
+		qcom,csid-sd-index = <0>;
+		qcom,mount-angle = <0>;
+		qcom,sensor-name = "mt9m114";
+		cam_vdig-supply = <&pm8941_l3>;
+		cam_vana-supply = <&pm8941_l17>;
+		cam_vio-supply = <&pm8941_lvs3>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vana", "cam_vio";
+		qcom,cam-vreg-type = <0 0 1>;
+		qcom,cam-vreg-min-voltage = <1225000 2850000 0>;
+		qcom,cam-vreg-max-voltage = <1225000 2850000 0>;
+		qcom,cam-vreg-op-mode = <105000 80000 0>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 16 0>,
+			<&msmgpio 92 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-req-tbl-num = <0 1>;
+		qcom,gpio-req-tbl-flags = <1 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1";
+		qcom,gpio-set-tbl-num = <1 1>;
+		qcom,gpio-set-tbl-flags = <0 2>;
+		qcom,gpio-set-tbl-delay = <1000 4000>;
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x3>;
+		qcom,sensor-position = <1>;
+		qcom,sensor-mode = <1>;
+		qcom,cci-master = <0>;
+	};
+	qcom,camera@0 {
+		cell-index = <0>;
+		compatible = "qcom,camera";
+		reg = <0x0>;
+		qcom,csiphy-sd-index = <0>;
+		qcom,csid-sd-index = <0>;
+		qcom,mount-angle = <90>;
+		qcom,actuator-src = <&actuator0>;
+		qcom,led-flash-src = <&led_flash0>;
+		qcom,vdd-cx-supply = <&pm8841_s2>;
+		qcom,vdd-cx-name = "qcom,vdd-cx";
+		cam_vdig-supply = <&pm8941_l3>;
+		cam_vana-supply = <&pm8941_l17>;
+		cam_vio-supply = <&pm8941_lvs3>;
+		cam_vaf-supply = <&pm8941_l23>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
+				     "cam_vaf";
+		qcom,cam-vreg-type = <0 1 0 0>;
+		qcom,cam-vreg-min-voltage = <1225000 0 2850000 3000000>;
+		qcom,cam-vreg-max-voltage = <1225000 0 2850000 3000000>;
+		qcom,cam-vreg-op-mode = <105000 0 80000 100000>;
+		gpios = <&msmgpio 15 0>,
+			<&msmgpio 90 0>,
+			<&msmgpio 89 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1",
+					  "CAM_STANDBY";
+		qcom,sensor-position = <0>;
+		qcom,sensor-mode = <0>;
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+
+	qcom,camera@1 {
+		cell-index = <1>;
+		compatible = "qcom,camera";
+		reg = <0x1>;
+		qcom,csiphy-sd-index = <1>;
+		qcom,csid-sd-index = <1>;
+		qcom,mount-angle = <90>;
+		qcom,vdd-cx-supply = <&pm8841_s2>;
+		qcom,vdd-cx-name = "qcom,vdd-cx";
+		cam_vdig-supply = <&pm8941_l3>;
+		cam_vana-supply = <&pm8941_l17>;
+		cam_vio-supply = <&pm8941_lvs3>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
+				     "cam_vaf";
+		qcom,cam-vreg-type = <0 1 0 0>;
+		qcom,cam-vreg-min-voltage = <1225000 0 2850000 3000000>;
+		qcom,cam-vreg-max-voltage = <1225000 0 2850000 3000000>;
+		qcom,cam-vreg-op-mode = <105000 0 80000 100000>;
+		gpios = <&msmgpio 17 0>,
+			<&msmgpio 18 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-req-tbl-num = <0 1>;
+		qcom,gpio-req-tbl-flags = <1 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1";
+		qcom,sensor-position = <1>;
+		qcom,sensor-mode = <0>;
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+
+	qcom,camera@2 {
+		cell-index = <2>;
+		compatible = "qcom,camera";
+		reg = <0x02>;
+		qcom,csiphy-sd-index = <2>;
+		qcom,csid-sd-index = <2>;
+		qcom,mount-angle = <90>;
+		cam_vdig-supply = <&pm8941_l3>;
+		cam_vana-supply = <&pm8941_l17>;
+		cam_vio-supply = <&pm8941_lvs3>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vana", "cam_vio";
+		qcom,cam-vreg-type = <0 0 1>;
+		qcom,cam-vreg-min-voltage = <1225000 2850000 0>;
+		qcom,cam-vreg-max-voltage = <1225000 2850000 0>;
+		qcom,cam-vreg-op-mode = <105000 80000 0>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 17 0>,
+			<&msmgpio 18 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-req-tbl-num = <0 1>;
+		qcom,gpio-req-tbl-flags = <1 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+					  "CAM_RESET1";
+		qcom,sensor-position = <1>;
+		qcom,sensor-mode = <0>;
+		qcom,cci-master = <1>;
+		status = "ok";
+	};
+
+       qcom,camera@6c {
+		compatible = "qcom,ov5648_z5s";
+		reg = <0x6c 0x0>;
+		qcom,slave-id = <0x6c 0x300a 0x5648>;
+		/*qcom,slave-id = <0x6c 0x0000 0x0132>;*/
+		qcom,csiphy-sd-index = <2>;
+		qcom,csid-sd-index = <2>;
+		qcom,mount-angle = <270>;
+		qcom,sensor-name = "ov5648_z5s";
+		cam_vdig-supply = <&pm8941_l3>;
+		cam_vana-supply = <&pm8941_l17>;
+		cam_vio-supply = <&pm8941_lvs2>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana";
+		qcom,cam-vreg-type = <0 1 0>;
+		qcom,cam-vreg-min-voltage = <1500000 0 2800000 >;
+		qcom,cam-vreg-max-voltage = <1500000 0 2800000 >;
+		qcom,cam-vreg-op-mode = <105000 0 80000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 17 0>,
+			<&msmgpio 18 0>,
+			<&msmgpio 95 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK", "CAM_RESET1", "CAM_STANDBY";
+		qcom,gpio-set-tbl-num = <1 1 2>;
+		qcom,gpio-set-tbl-flags = <0 2 2>;
+		qcom,gpio-set-tbl-delay = <1000 30000 1000>;
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x7>;
+		qcom,sensor-position = <1>;
+		qcom,sensor-mode = <1>;
+		qcom,cci-master = <1>;
+		status = "ok";
+	};
+};
diff --git a/arch/arm/boot/dts/NX503A/msm8974-leds.dtsi b/arch/arm/boot/dts/NX503A/msm8974-leds.dtsi
new file mode 100755
index 0000000..db58de6
--- /dev/null
+++ b/arch/arm/boot/dts/NX503A/msm8974-leds.dtsi
@@ -0,0 +1,183 @@
+/*
+ * Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+&pm8941_lsid1 {
+	qcom,leds@d000 {
+		status = "okay";
+		qcom,rgb_0 {
+			label = "rgb";
+			linux,name = "led:rgb_red";
+			qcom,mode = "pwm";
+			qcom,pwm-channel = <6>;
+			qcom,pwm-us = <1000>;
+			qcom,max-current = <12>;
+			qcom,default-state = "off";
+			qcom,id = <3>;
+			linux,default-trigger =
+				"battery-charging";
+		};
+
+		qcom,rgb_1 {
+			label = "rgb";
+			linux,name = "led:rgb_green";
+			qcom,mode = "pwm";
+			qcom,pwm-channel = <5>;
+			qcom,pwm-us = <1000>;
+			qcom,max-current = <12>;
+			qcom,default-state = "off";
+			qcom,id = <4>;
+			linux,default-trigger = "battery-full";
+		};
+
+		qcom,rgb_2 {
+			label = "rgb";
+			linux,name = "led:rgb_blue";
+			qcom,mode = "pwm";
+			qcom,pwm-channel = <4>;
+			qcom,pwm-us = <1000>;
+			qcom,max-current = <12>;
+			qcom,id = <5>;
+			status = "disabled";
+		};
+	};
+
+	qcom,leds@d100 {
+		status = "disabled";
+	};
+
+	qcom,leds@d200 {
+		status = "disabled";
+	};
+
+	qcom,leds@d300 {
+		status = "okay";
+		pm8941_flash0: qcom,flash_0 {
+			qcom,max-current = <1000>;
+			qcom,default-state = "off";
+			qcom,headroom = <3>;
+			qcom,duration = <1280>;
+			qcom,clamp-curr = <200>;
+			qcom,startup-dly = <3>;
+			qcom,safety-timer;
+			label = "flash";
+			linux,default-trigger =
+				"flash0_trigger";
+			qcom,id = <1>;
+			linux,name = "led:flash_0";
+			qcom,current = <625>;
+		};
+
+		pm8941_flash1: qcom,flash_1 {
+			qcom,max-current = <1000>;
+			qcom,default-state = "off";
+			qcom,headroom = <3>;
+			qcom,duration = <1280>;
+			qcom,clamp-curr = <200>;
+			qcom,startup-dly = <3>;
+			qcom,safety-timer;
+			linux,default-trigger =
+				"flash1_trigger";
+			label = "flash";
+			qcom,id = <2>;
+			linux,name = "led:flash_1";
+			qcom,current = <625>;
+		};
+
+		pm8941_torch: qcom,flash_torch {
+			qcom,max-current = <200>;
+			qcom,default-state = "off";
+			qcom,headroom = <0>;
+			qcom,startup-dly = <1>;
+			linux,default-trigger =
+				"torch_trigger";
+			label = "flash";
+			qcom,id = <2>;
+			linux,name = "led:flash_torch";
+			qcom,current = <100>;
+			qcom,torch-enable;
+		};
+	};
+
+	qcom,leds@d400 {
+		status = "disabled";
+	};
+
+	qcom,leds@d500 {
+		status = "disabled";
+	};
+
+	qcom,leds@d600 {
+		status = "disabled";
+	};
+
+	qcom,leds@d700 {
+		status = "disabled";
+	};
+
+	qcom,leds@e200 {
+		status = "okay";
+
+		qcom,kpdbl1 {
+			label = "kpdbl";
+			linux,name = "kpdbl-pwm-1";
+			qcom,mode = "pwm";
+			qcom,pwm-channel = <8>;
+			qcom,pwm-us = <1000>;
+			qcom,id = <7>;
+			qcom,max-current = <20>;
+			qcom,row-id = <0>;
+			qcom,row-src-en;
+			qcom,always-on;
+		};
+
+		qcom,kpdbl2 {
+			label = "kpdbl";
+			linux,name = "kpdbl-lut-2";
+			qcom,mode = "lpg";
+			qcom,pwm-channel = <9>;
+			qcom,pwm-us = <1000>;
+			qcom,start-idx = <1>;
+			qcom,duty-pcts = [00 00 00 00 64
+					64 00 00 00 00];
+			qcom,id = <7>;
+			qcom,max-current = <20>;
+			qcom,row-id = <1>;
+			qcom,row-src-en;
+		};
+
+		qcom,kpdbl3 {
+			label = "kpdbl";
+			linux,name = "kpdbl-pwm-3";
+			qcom,mode = "pwm";
+			qcom,pwm-channel = <10>;
+			qcom,pwm-us = <1000>;
+			qcom,id = <7>;
+			qcom,max-current = <20>;
+			qcom,row-id = <2>;
+			qcom,row-src-en;
+		};
+
+		qcom,kpdbl4 {
+			label = "kpdbl";
+		    linux,name = "button-backlight";
+			qcom,mode = "pwm";
+			qcom,pwm-channel = <11>;
+			qcom,pwm-us = <1000>;
+			qcom,id = <7>;
+			qcom,max-current = <20>;
+			qcom,row-id = <3>;
+			qcom,row-src-en;
+			qcom,always-on;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/NX503A/msm8974-mdss-panels.dtsi b/arch/arm/boot/dts/NX503A/msm8974-mdss-panels.dtsi
new file mode 100755
index 0000000..ccd107bc
--- /dev/null
+++ b/arch/arm/boot/dts/NX503A/msm8974-mdss-panels.dtsi
@@ -0,0 +1,13 @@
+/* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/include/ "zte-dsi-panel-sharp-1080p-5p0-video.dtsi"
diff --git a/arch/arm/boot/dts/NX503A/msm8974-mdss.dtsi b/arch/arm/boot/dts/NX503A/msm8974-mdss.dtsi
new file mode 100755
index 0000000..42328e4
--- /dev/null
+++ b/arch/arm/boot/dts/NX503A/msm8974-mdss.dtsi
@@ -0,0 +1,268 @@
+/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+&soc {
+	mdss_mdp: qcom,mdss_mdp@fd900000 {
+		compatible = "qcom,mdss_mdp";
+		reg = <0xfd900000 0x22100>,
+			<0xfd924000 0x1000>;
+		reg-names = "mdp_phys", "vbif_phys";
+		interrupts = <0 72 0>;
+		vdd-supply = <&gdsc_mdss>;
+
+		qcom,max-bandwidth-low-kbps = <2300000>;
+		qcom,max-bandwidth-high-kbps = <3000000>;
+
+		/* Bus Scale Settings */
+		qcom,msm-bus,name = "mdss_mdp";
+		qcom,msm-bus,num-cases = <3>;
+		qcom,msm-bus,num-paths = <1>;
+		qcom,msm-bus,vectors-KBps =
+			<22 512 0 0>,
+			<22 512 0 6400000>,
+			<22 512 0 6400000>;
+
+		/* Fudge factors *//*luochangyang 2014/05/15  add fudge factor FOR blue screen.*/
+		qcom,mdss-ab-factor = <5 2>;		/* 2 times    */
+		qcom,mdss-ib-factor = <3 2>;		/* 1.2 times  */
+		qcom,mdss-clk-factor = <5 3>;		/* 1.25 times */
+
+		qcom,max-clk-rate = <320000000>;
+		qcom,mdss-pipe-vig-off = <0x00001200 0x00001600
+					       0x00001A00>;
+		qcom,mdss-pipe-rgb-off = <0x00001E00 0x00002200
+					       0x00002600>;
+		qcom,mdss-pipe-dma-off = <0x00002A00 0x00002E00>;
+		qcom,mdss-pipe-vig-fetch-id = <1 4 7>;
+		qcom,mdss-pipe-rgb-fetch-id = <16 17 18>;
+		qcom,mdss-pipe-dma-fetch-id = <10 13>;
+
+		qcom,mdss-pipe-vig-xin-id = <0 4 8>;
+		qcom,mdss-pipe-rgb-xin-id = <1 5 9>;
+		qcom,mdss-pipe-dma-xin-id = <2 10>;
+
+		qcom,mdss-smp-data = <22 4096>;
+
+		qcom,mdss-ctl-off = <0x00000600 0x00000700 0x00000800
+				     0x00000900 0x0000A00>;
+		qcom,mdss-mixer-intf-off = <0x00003200 0x00003600
+					    0x00003A00>;
+		qcom,mdss-mixer-wb-off = <0x00003E00 0x00004200>;
+		qcom,mdss-dspp-off = <0x00004600 0x00004A00 0x00004E00>;
+		qcom,mdss-wb-off = <0x00011100 0x00013100 0x00015100
+				    0x00017100 0x00019100>;
+		qcom,mdss-intf-off = <0x00021100 0x00021300
+					   0x00021500 0x00021700>;
+
+		qcom,mdss-has-wfd-blk;
+		qcom,vbif-settings = <0x0004 0x00000001>,
+				     <0x00D8 0x00000707>,
+				     <0x00F0 0x00000030>,
+				     <0x0124 0x00000001>,
+				     <0x0178 0x00000FFF>,
+				     <0x017C 0x0FFF0FFF>,
+				     <0x0160 0x22222222>,
+				     <0x0164 0x00002222>;
+		qcom,mdp-settings = <0x02E0 0x000000E9>,
+				    <0x02E4 0x00000055>,
+				    <0x03AC 0xC0000CCC>,
+				    <0x03B4 0xC0000CCC>,
+				    <0x03BC 0x00CCCCCC>,
+				    <0x04A8 0x0CCCC0C0>,
+				    <0x04B0 0xCCCCC0C0>,
+				    <0x04B8 0xCCCCC000>;
+
+		/* buffer parameters to calculate prefill bandwidth */
+		qcom,mdss-prefill-outstanding-buffer-bytes = <1024>;
+		qcom,mdss-prefill-y-buffer-bytes = <4096>;
+		qcom,mdss-prefill-scaler-buffer-lines-bilinear = <2>;
+		qcom,mdss-prefill-scaler-buffer-lines-caf = <4>;
+		qcom,mdss-prefill-post-scaler-buffer-pixels = <0>;
+		qcom,mdss-prefill-pingpong-buffer-pixels = <4096>;
+		qcom,mdss-prefill-fbc-lines = <2>;
+
+		mdss_fb0: qcom,mdss_fb_primary {
+			cell-index = <0>;
+			compatible = "qcom,mdss-fb";
+			qcom,memory-reservation-type = "EBI1";
+			qcom,memory-reservation-size = <0xFF0000>;
+			qcom,memblock-reserve = <0x03200000 0x01E00000>;
+		};
+
+		mdss_fb1: qcom,mdss_fb_external {
+			cell-index = <1>;
+			compatible = "qcom,mdss-fb";
+		};
+
+		mdss_fb2: qcom,mdss_fb_wfd {
+			cell-index = <2>;
+			compatible = "qcom,mdss-fb";
+		};
+	};
+
+	mdss_dsi0: qcom,mdss_dsi@fd922800 {
+		compatible = "qcom,mdss-dsi-ctrl";
+		label = "MDSS DSI CTRL->0";
+		cell-index = <0>;
+		reg = <0xfd922800 0x600>;
+		vdd-supply = <&pm8941_l22>;
+		vddio-supply = <&pm8941_l12>;
+		vdda-supply = <&pm8941_l2>;
+		qcom,mdss-fb-map = <&mdss_fb0>;
+		qcom,mdss-mdp = <&mdss_mdp>;
+		qcom,platform-reset-gpio = <&pm8941_gpios 19 0>;
+		qcom,platform-enable-gpio = <&msmgpio 58 0>;
+		qcom,platform-te-gpio = <&msmgpio 12 0>;
+		qcom,platform-avddn-enable-gpio = <&msmgpio 8 1>;   /*luochangyang For LCD 2014/03/07*/
+		qcom,platform-strength-ctrl = [ff 06];
+		qcom,platform-bist-ctrl = [00 00 b1 ff 00 00];
+		qcom,platform-regulator-settings = [07 09 03 00 20 00 01];
+		qcom,platform-lane-config = [00 00 00 00 00 00 00 01 97
+			00 00 00 00 05 00 00 01 97
+			00 00 00 00 0a 00 00 01 97
+			00 00 00 00 0f 00 00 01 97
+			00 c0 00 00 00 00 00 01 bb];
+		qcom,platform-supply-entry1 {
+				qcom,supply-name = "vdd";
+				qcom,supply-min-voltage = <1800000>;
+				qcom,supply-max-voltage = <1800000>;
+				qcom,supply-enable-load = <100000>;
+				qcom,supply-disable-load = <100>;
+				qcom,supply-pre-on-sleep = <0>;
+				qcom,supply-post-on-sleep = <20>;
+				qcom,supply-pre-off-sleep = <0>;
+				qcom,supply-post-off-sleep = <0>;
+		};
+		qcom,platform-supply-entry2 {
+				qcom,supply-name = "vddio";
+				qcom,supply-min-voltage = <1800000>;
+				qcom,supply-max-voltage = <1800000>;
+				qcom,supply-enable-load = <100000>;
+				qcom,supply-disable-load = <100>;
+				qcom,supply-pre-on-sleep = <0>;
+				qcom,supply-post-on-sleep = <20>;
+				qcom,supply-pre-off-sleep = <0>;
+				qcom,supply-post-off-sleep = <0>;
+		};
+		qcom,platform-supply-entry3 {
+				qcom,supply-name = "vdda";
+				qcom,supply-min-voltage = <1200000>;
+				qcom,supply-max-voltage = <1200000>;
+				qcom,supply-enable-load = <100000>;
+				qcom,supply-disable-load = <100>;
+				qcom,supply-pre-on-sleep = <0>;
+				qcom,supply-post-on-sleep = <0>;
+				qcom,supply-pre-off-sleep = <0>;
+				qcom,supply-post-off-sleep = <0>;
+		};
+	};
+
+	mdss_dsi1: qcom,mdss_dsi@fd922e00 {
+		compatible = "qcom,mdss-dsi-ctrl";
+		label = "MDSS DSI CTRL->1";
+		cell-index = <1>;
+		reg = <0xfd922e00 0x600>;
+		vdd-supply = <&pm8941_l22>;
+		vddio-supply = <&pm8941_l12>;
+		vdda-supply = <&pm8941_l2>;
+		qcom,mdss-fb-map = <&mdss_fb0>;
+		qcom,mdss-mdp = <&mdss_mdp>;
+		qcom,platform-strength-ctrl = [ff 06];
+		qcom,platform-bist-ctrl = [00 00 b1 ff 00 00];
+		qcom,platform-regulator-settings = [07 09 03 00 20 00 01];
+		qcom,platform-lane-config = [00 00 00 00 00 00 00 01 97
+			00 00 00 00 05 00 00 01 97
+			00 00 00 00 0a 00 00 01 97
+			00 00 00 00 0f 00 00 01 97
+			00 c0 00 00 00 00 00 01 bb];
+		qcom,platform-supply-entry1 {
+				qcom,supply-name = "vdd";
+				qcom,supply-min-voltage = <3000000>;
+				qcom,supply-max-voltage = <3000000>;
+				qcom,supply-enable-load = <100000>;
+				qcom,supply-disable-load = <100>;
+				qcom,supply-pre-on-sleep = <0>;
+				qcom,supply-post-on-sleep = <20>;
+				qcom,supply-pre-off-sleep = <0>;
+				qcom,supply-post-off-sleep = <0>;
+		};
+		qcom,platform-supply-entry2 {
+				qcom,supply-name = "vddio";
+				qcom,supply-min-voltage = <1800000>;
+				qcom,supply-max-voltage = <1800000>;
+				qcom,supply-enable-load = <100000>;
+				qcom,supply-disable-load = <100>;
+				qcom,supply-pre-on-sleep = <0>;
+				qcom,supply-post-on-sleep = <20>;
+				qcom,supply-pre-off-sleep = <0>;
+				qcom,supply-post-off-sleep = <0>;
+		};
+		qcom,platform-supply-entry3 {
+				qcom,supply-name = "vdda";
+				qcom,supply-min-voltage = <1200000>;
+				qcom,supply-max-voltage = <1200000>;
+				qcom,supply-enable-load = <100000>;
+				qcom,supply-disable-load = <100>;
+				qcom,supply-pre-on-sleep = <0>;
+				qcom,supply-post-on-sleep = <0>;
+				qcom,supply-pre-off-sleep = <0>;
+				qcom,supply-post-off-sleep = <0>;
+		};
+	};
+
+	mdss_hdmi_tx: qcom,hdmi_tx@fd922100 {
+		cell-index = <0>;
+		compatible = "qcom,hdmi-tx";
+		reg =	<0xfd922100 0x35C>,
+			<0xfd922500 0x7C>,
+			<0xfc4b8000 0x60F0>;
+		reg-names = "core_physical", "phy_physical", "qfprom_physical";
+
+		hpd-gdsc-supply = <&gdsc_mdss>;
+		hpd-5v-supply = <&pm8941_mvs2>;
+		core-vdda-supply = <&pm8941_l12>;
+		core-vcc-supply = <&pm8941_s3>;
+		qcom,hdmi-tx-supply-names = "hpd-gdsc", "hpd-5v", "core-vdda", "core-vcc";
+		qcom,hdmi-tx-min-voltage-level = <0 0 1800000 1800000>;
+		qcom,hdmi-tx-max-voltage-level = <0 0 1800000 1800000>;
+		qcom,hdmi-tx-peak-current = <0 0 300000 0>;
+
+		qcom,hdmi-tx-cec = <&msmgpio 31 0>;
+		qcom,hdmi-tx-ddc-clk = <&msmgpio 32 0>;
+		qcom,hdmi-tx-ddc-data = <&msmgpio 33 0>;
+		qcom,hdmi-tx-hpd = <&msmgpio 34 0>;
+		qcom,mdss-fb-map = <&mdss_fb1>;
+		qcom,msm-hdmi-audio-rx {
+			compatible = "qcom,msm-hdmi-audio-codec-rx";
+		};
+	};
+
+	qcom,mdss_wb_panel {
+		compatible = "qcom,mdss_wb";
+		qcom,mdss_pan_res = <1920 1080>;
+		qcom,mdss_pan_bpp = <24>;
+		qcom,mdss-fb-map = <&mdss_fb2>;
+	};
+
+	mdss_edp: qcom,mdss_edp@fd923400 {
+		compatible = "qcom,mdss-edp";
+		reg = <0xfd923400 0x700>,
+			<0xfd8c2000 0x1000>;
+		reg-names = "edp_base", "mmss_cc_base";
+		vdda-supply = <&pm8941_l12>;
+		gpio-panel-en = <&msmgpio 58 0>;
+		qcom,mdss-fb-map = <&mdss_fb0>;
+		gpio-panel-hpd = <&msmgpio 102 0>;
+	};
+};
+
+/include/ "msm8974-mdss-panels.dtsi"
diff --git a/arch/arm/boot/dts/NX503A/msm8974-mtp.dtsi b/arch/arm/boot/dts/NX503A/msm8974-mtp.dtsi
new file mode 100755
index 0000000..29a2212
--- /dev/null
+++ b/arch/arm/boot/dts/NX503A/msm8974-mtp.dtsi
@@ -0,0 +1,899 @@
+/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/include/ "msm8974-camera-sensor-mtp.dtsi"
+/include/ "msm8974-leds.dtsi"
+
+/ {
+	aliases {
+		#serial0 = &blsp1_uart1;
+		uart1 = &uart8;
+	};
+};
+
+&soc {
+	serial@f991e000 {
+		status = "ok";
+	};
+
+	qcom,mdss_dsi@fd922800 {
+		qcom,dsi-pref-prim-pan = <&dsi_sp_1080_5p0_vid>;
+	};
+	qcom,mdss_dsi@fd922e00 {
+		status = "no";
+	};
+
+	qcom,mdss_mdp@fd900000 {
+		qcom,mdss-pref-prim-intf = "dsi";
+		batfet-supply = <&pm8941_chg_batif>;
+	};
+
+	qcom,hdmi_tx@fd922100 {
+		status = "disabled";
+	};
+
+	i2c@f9924000 {
+		/*ZTEMT Added by luochangyang, 2013/12/19*/
+		cyttsp4_i2c_adapter@24 {
+			compatible = "cypress,cyttsp4_i2c_adapter";
+			reg = <0x24>;
+			interrupt-parent = <&msmgpio>;
+			interrupts = <61 0x2>;
+			vdd_ana-supply = <&pm8941_l18>;
+			vcc_i2c-supply = <&pm8941_lvs1>;
+			cypress,reset-gpio = <&msmgpio 60 0x00>;
+			cypress,irq-gpio = <&msmgpio 61 0x00>;
+		};
+		
+		synaptics_dsx_i2c@22 {
+			compatible = "synaptics_dsx_i2c,rmi4";
+			reg = <0x22>;
+			interrupt-parent = <&msmgpio>;
+			interrupts = <61 0x2>;
+			vdd_ana-supply = <&pm8941_l18>;
+			vcc_i2c-supply = <&pm8941_lvs1>;
+			synaptics,reset-gpio = <&msmgpio 60 0x00>;
+			synaptics,irq-gpio = <&msmgpio 61 0x00>;
+			synaptics,reset_on_state = <0>;
+			synaptics,reset_delay_ms = <100>;
+			synaptics,reset_active_ms = <20>;
+			//synaptics,power_gpio = <-1>;
+			synaptics,power_on_state = <1>;
+			synaptics,power_delay_ms = <160>;
+		};
+        /*ZTEMT END*/
+/*
+		synaptics@20 {
+			compatible = "synaptics,rmi4";
+			reg = <0x20>;
+			interrupt-parent = <&msmgpio>;
+			interrupts = <61 0x2008>;
+			vdd-supply = <&pm8941_l18>;
+			vcc_i2c-supply = <&pm8941_lvs1>;
+			synaptics,reset-gpio = <&msmgpio 60 0x00>;
+			synaptics,irq-gpio = <&msmgpio 61 0x2008>;
+			synaptics,display-coords = <0 0 1079 1919>;
+			synaptics,i2c-pull-up;
+			synaptics,power-down;
+			synaptics,disable-gpios;
+			synaptics,do-lockdown;
+		};
+*/
+		atmel_mxt_ts@4a {
+			compatible = "atmel,mxt-ts";
+			reg = <0x4a>;
+			interrupt-parent = <&msmgpio>;
+			interrupts = <61 0x2>;
+			vdd_ana-supply = <&pm8941_l18>;
+			vcc_i2c-supply = <&pm8941_lvs1>;
+			atmel,reset-gpio = <&msmgpio 60 0x00>;
+			atmel,irq-gpio = <&msmgpio 61 0x00>;
+			atmel,panel-coords = <0  0 760 1424>;
+			atmel,display-coords = <0 0 720 1280>;
+			atmel,i2c-pull-up;
+			atmel,no-force-update;
+			atmel,cfg_1 {
+				atmel,fw-name = "atmel_8974_fluid_v1_0_AA.hex";
+				atmel,family-id = <0x82>;
+				atmel,variant-id = <0x19>;
+				atmel,version = <0x10>;
+				atmel,build = <0xaa>;
+				atmel,config = [
+					/* Object 6, Instance = 0 */
+					00 00 00 00 00 00
+					/* Object 38, Instance = 0 */
+					15 01 00 03 0A 0C 00 00
+					/* Object 7, Instance = 0 */
+					20 08 32 03
+					/* Object 8, Instance = 0 */
+					0F 00 0A 0A 00 00 0A 0A 00 00
+					/* Object 9, Instance = 0 */
+					83 00 00 18 0E 00 70 46 02 01
+					00 0A 03 31 04 05 0A 0A 90 05
+					F8 02 05 F1 F1 0F 00 00 08 2D
+					12 06 00 00 00 01
+					/* Object 15, Instance = 0 */
+					00 00 00 00 00 00 00 00 00 00
+					00
+					/* Object 18, Instance = 0 */
+					00 00
+					/* Object 19, Instance = 0 */
+					00 00 00 00 00 00
+					/* Object 23, Instance = 0 */
+					00 00 00 00 00 00 00 00 00 00
+					00 00 00 00 00
+					/* Object 25, Instance = 0 */
+					00 00 00 00 00 00 00 00 00 00
+					00 00 00 00 00
+					/* Object 40, Instance = 0 */
+					00 00 00 00 00
+					/* Object 42, Instance = 0 */
+					33 1E 19 10 80 00 00 00 FF 00
+					/* Object 46, Instance = 0 */
+					00 00 10 10 00 00 03 00 00 01
+					/* Object 47, Instance = 0 */
+					08 0A 28 0A 02 0A 00 8C 00 20
+					00 00 00
+					/* Object 55, Instance = 0 */
+					00 00 00 00 00 00
+					/* Object 56, Instance = 0 */
+					00 00 00 18 05 05 05 05 05 05
+					05 05 05 05 05 05 05 05 05 05
+					05 05 05 05 05 05 05 05 00 00
+					00 00 00 00 00 00 00 00 00 00
+					00 00
+					/* Object 57, Instance = 0 */
+					00 00 00
+					/* Object 61, Instance = 0 */
+					00 00 00 00 00
+					/* Object 62, Instance = 0 */
+					01 2A 00 16 00 00 00 00 0B 01
+					02 03 04 08 00 00 08 10 18 05
+					00 0A 05 05 50 14 19 34 1A 7F
+					00 00 00 00 00 00 00 00 00 30
+					05 02 00 01 00 05 00 00 00 00
+					00 00 00 00
+					];
+			};
+		};
+	};
+	i2c@f9928000 {
+		tps65132@3e {
+			compatible = "tps,tps65132_i2c_adapter";
+			reg = <0x3e>;
+			interrupt-parent = <&msmgpio>;
+			vdd_ana-supply = <&pm8941_lvs1>;
+			vcc_i2c-supply = <&pm8941_lvs1>;
+		};
+		nxp_i2c_adapter@28 {
+			compatible = "nxp,i2c_adapter";
+			reg = <0x28>;
+			interrupt-parent = <&msmgpio>;
+			//changed by chengdongsheng 20130904 for NFC_IQR chaned to GPIO80
+			interrupts = <80 0x2>;
+			//interrupts = <68 0x2>;
+			nxp,updata-gpio = <&msmgpio 13 0x00>;
+			nxp,ven-gpio = <&msmgpio 85 0x00>;
+			//changed by chengdongsheng 20130904 for NFC_IQR chaned to GPIO80
+			nxp,irq-gpio = <&msmgpio 80 0x00>;
+			//nxp,irq-gpio = <&msmgpio 68 0x00>;
+		};
+
+	};
+	gen-vkeys {
+		compatible = "qcom,gen-vkeys";
+		label = "atmel_mxt_ts";
+		qcom,disp-maxx = <720>;
+		qcom,disp-maxy = <1280>;
+		qcom,panel-maxx = <760>;
+		qcom,panel-maxy = <1424>;
+		qcom,key-codes = <158 139 102 217>;
+	};
+
+	i2c@f9967000 {
+		isa1200@48 {
+			status = "okay";
+			reg = <0x48>;
+			vcc_i2c-supply = <&pm8941_s3>;
+			compatible = "imagis,isa1200";
+			label = "vibrator";
+			imagis,chip-en;
+			imagis,need-pwm-clk;
+			imagis,ext-clk-en;
+			imagis,hap-en-gpio = <&msmgpio 86 0x00>;
+			imagis,max-timeout = <15000>;
+			imagis,pwm-div = <256>;
+			imagis,mode-ctrl = <2>;
+			imagis,regulator {
+				regulator-name = "vcc_i2c";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-max-microamp = <9360>;
+			};
+		};
+		drv2605@5a {
+			reg = <0x5a>;
+			compatible = "immersion,drv2605";
+			immersion,gpio-enable = <&msmgpio 86 0x00>;
+			immersion,actuator {
+				actuator,type = <0x01>;	/* 0:ERM 1:LRA */
+				actuator,effect-bank = <0x06>; /* LIBRARY_F */
+				actuator,loop = <0x01>; /* 0:OPEN_LOOP 1:CLOSE_LOOP */
+				actuator,rated-vol = <0x38>;
+				actuator,over-drive-vol = <0x72>;
+			};
+			immersion,audio2haptics {
+				a2h,min-input = <0x19>;
+				a2h,max-input = <0xff>;
+				a2h,min-output = <0x19>;
+				a2h,max-output = <0xff>;
+			};
+		};
+		aw9106b_i2c_adapter@5b {
+			compatible = "aw,9106b";
+			reg = <0x5b>;
+			interrupt-parent = <&msmgpio>;
+		};		
+		// ADDED BY ZTEMT ZhuBing
+		// add the als/prox/gesture sensor and IR-remote control
+	    	ams-sensor_i2c_adapter@39 {
+	                status = "okay";
+	                reg = <0x39>;
+	                compatible = "ams,ams-sensor";
+	                interrupt-parent = <&msmgpio>;
+	                ams,irq-gpio = <&msmgpio 9 0x00>;
+	        };
+	        
+	        maxq616_i2c_adapter@11 {
+	                status = "okay";
+	                reg = <0x11>;
+	                compatible = "uei,maxq616";
+					vdd-chip-supply = <&pm8941_l21>;
+					vdd-led-supply  = <&pm8941_lvs2>;
+	        };
+	        
+	        sensor_common_i2c_adapter@22 {
+	                status = "okay";
+	                reg = <0x22>;
+	                compatible = "zte,sensor_common";
+	                compass,irq-gpio = <&msmgpio 64 0x00>;
+	        };
+		// ADDED BY ZTEMT ZhuBing END
+	};
+
+	gpio_keys {
+		compatible = "gpio-keys";
+		input-name = "gpio-keys";
+
+		camera_snapshot {
+			label = "camera_snapshot";
+			gpios = <&pm8941_gpios 3 0x1>;
+			linux,input-type = <1>;
+			linux,code = <0x2fe>;
+			gpio-key,wakeup;
+			debounce-interval = <15>;
+		};
+
+		camera_focus {
+			label = "camera_focus";
+			gpios = <&pm8941_gpios 4 0x1>;
+			linux,input-type = <1>;
+			linux,code = <0x210>;
+			gpio-key,wakeup;
+			debounce-interval = <15>;
+		};
+
+		vol_up {
+			label = "volume_up";
+			gpios = <&pm8941_gpios 2 0x1>;
+			linux,input-type = <1>;
+			linux,code = <115>;
+			gpio-key,wakeup;
+			debounce-interval = <15>;
+		};
+/*add by yfliu, for volume down key*/
+		vol_down {
+			label = "volume_down";
+			gpios = <&pm8941_gpios 5 0x1>;
+			linux,input-type = <1>;
+			linux,code = <114>;
+			gpio-key,wakeup;
+			debounce-interval = <15>;
+		};
+	};
+
+	spi@f9923000 {
+		ethernet-switch@2 {
+			compatible = "micrel,ks8851";
+			reg = <2>;
+			interrupt-parent = <&msmgpio>;
+			interrupts = <94 0>;
+			spi-max-frequency = <4800000>;
+			rst-gpio = <&pm8941_mpps 6 0>;
+			vdd-io-supply = <&spi_eth_vreg>;
+			vdd-phy-supply = <&spi_eth_vreg>;
+		};
+	};
+
+	sound {
+		qcom,model = "msm8974-taiko-mtp-snd-card";
+		qcom,audio-routing =
+			"RX_BIAS", "MCLK",
+			"LDO_H", "MCLK",
+			"AIF4 MAD", "MCLK",
+			"AMIC1", "MIC BIAS1 Internal1",
+			"MIC BIAS1 Internal1", "Handset Mic",
+			"AMIC2", "MIC BIAS2 External",
+			"MIC BIAS2 External", "Headset Mic",
+			"AMIC3", "MIC BIAS2 External",
+			"MIC BIAS2 External", "ANCRight Headset Mic",
+			"AMIC4", "MIC BIAS2 External",
+			"MIC BIAS2 External", "ANCLeft Headset Mic",
+			"DMIC1", "MIC BIAS1 External",
+			"MIC BIAS1 External", "Digital Mic1",
+			"DMIC2", "MIC BIAS1 External",
+			"MIC BIAS1 External", "Digital Mic2",
+			"DMIC3", "MIC BIAS3 External",
+			"MIC BIAS3 External", "Digital Mic3",
+			"DMIC4", "MIC BIAS3 External",
+			"MIC BIAS3 External", "Digital Mic4",
+			"DMIC5", "MIC BIAS4 External",
+			"MIC BIAS4 External", "Digital Mic5",
+			"DMIC6", "MIC BIAS4 External",
+			"MIC BIAS4 External", "Digital Mic6",
+			"Lineout_1 amp", "LINEOUT1";
+
+		qcom,ext-ult-lo-amp-gpio = <&pm8941_gpios 6 0>;
+		qcom,mbhc-switch-enable-gpio = <&msmgpio 96 0>;
+		qcom,cdc-micbias2-headset-only;
+		qcom,mbhc-audio-jack-type = "4-pole-jack";
+	};
+};
+
+&pm8941_lsid1 {
+	qcom,leds@d800 {
+		status = "okay";
+		qcom,wled_0 {
+			label = "wled";
+			linux,name = "wled:backlight";
+			linux,default-trigger = "bkl-trigger";
+			qcom,cs-out-en;
+			qcom,op-fdbck = <1>;
+			qcom,default-state = "off";
+			qcom,max-current = <25>;
+			qcom,ctrl-delay-us = <0>;
+			qcom,boost-curr-lim = <5>;
+			qcom,cp-sel = <0>;
+			qcom,switch-freq = <11>;
+			qcom,ovp-val = <2>;
+			qcom,num-strings = <3>;
+			qcom,id = <0>;
+		};
+	};
+
+	qcom,leds@d900 {
+		status = "disabled";
+	};
+
+	qcom,leds@da00 {
+		status = "disabled";
+	};
+
+	qcom,leds@db00 {
+		status = "disabled";
+	};
+
+	qcom,leds@dc00 {
+		status = "disabled";
+	};
+
+	qcom,leds@dd00 {
+		status = "disabled";
+	};
+
+	qcom,leds@de00 {
+		status = "disabled";
+	};
+
+	qcom,leds@df00 {
+		status = "disabled";
+	};
+
+	qcom,leds@e000 {
+		status = "disabled";
+	};
+
+	qcom,leds@e100 {
+		status = "disabled";
+	};
+};
+
+&sdcc1 {
+       status = "disabled";
+};
+
+&sdcc2 {
+	#address-cells = <0>;
+	interrupt-parent = <&sdcc2>;
+	interrupts = <0 1 2>;
+	#interrupt-cells = <1>;
+	interrupt-map-mask = <0xffffffff>;
+	interrupt-map = <0 &intc 0 125 0
+			1 &intc 0 220 0
+			2 &msmgpio 62 0x3>;
+	interrupt-names = "core_irq", "bam_irq", "status_irq";
+	cd-gpios = <&msmgpio 62 0x1>;
+	status = "disabled";
+};
+
+&sdhc_1 {
+	vdd-supply = <&pm8941_l20>;
+	vdd-io-supply = <&pm8941_s3>;
+
+	qcom,vdd-always-on;
+	qcom,vdd-lpm-sup;
+	qcom,vdd-voltage-level = <2950000 2950000>;
+	qcom,vdd-current-level = <800 500000>;
+
+	qcom,vdd-io-always-on;
+	qcom,vdd-io-voltage-level = <1800000 1800000>;
+	qcom,vdd-io-current-level = <250 154000>;
+
+	qcom,pad-pull-on = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-pull-off = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-drv-on = <0x4 0x4 0x4>; /* 10mA, 10mA, 10mA */
+	qcom,pad-drv-off = <0x0 0x0 0x0>; /* 2mA, 2mA, 2mA */
+
+	qcom,nonremovable;
+	status = "ok";
+};
+
+&sdhc_2 {
+	#address-cells = <0>;
+	interrupt-parent = <&sdhc_2>;
+	interrupts = <0 1 2>;
+	#interrupt-cells = <1>;
+	interrupt-map-mask = <0xffffffff>;
+	interrupt-map = <0 &intc 0 125 0
+			1 &intc 0 221 0
+			2 &msmgpio 62 0x3>;
+	interrupt-names = "hc_irq", "pwr_irq", "status_irq";
+	cd-gpios = <&msmgpio 62 0x1>;
+
+       vdd-supply = <&pm8941_l13>;
+	vdd-io-supply = <&pm8941_l13>;
+
+       qcom,vdd-voltage-level = <1800000 1800000>;
+	qcom,vdd-current-level = <9000 800000>;
+
+       qcom,vdd-io-voltage-level = <1800000 1800000>;
+	qcom,vdd-io-current-level = <6 22000>;
+
+	qcom,pad-pull-on = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-pull-off = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-drv-on = <0x4 0x4 0x4>; /* 10mA, 10mA, 10mA */
+	qcom,pad-drv-off = <0x0 0x0 0x0>; /* 2mA, 2mA, 2mA */
+       status = "ok";
+};
+
+/* Drive strength recommendations for clock line from hardware team is 10 mA.
+ * But since the driver has been been using the below values from the start
+ * without any problems, continue to use those.
+ */
+&sdcc1 {
+	qcom,pad-drv-on = <0x7 0x4 0x4>; /* 16mA, 10mA, 10mA */
+};
+
+&sdcc2 {
+	qcom,pad-drv-on = <0x7 0x4 0x4>; /* 16mA, 10mA, 10mA */
+};
+
+&sdhc_1 {
+	qcom,pad-drv-on = <0x7 0x4 0x4>; /* 16mA, 10mA, 10mA */
+};
+
+&sdhc_2 {
+	qcom,pad-drv-on = <0x7 0x4 0x4>; /* 16mA, 10mA, 10mA */
+};
+
+&usb_otg {
+	qcom,hsusb-otg-otg-control = <2>;
+};
+
+/*
+&uart7 {
+	status = "ok";
+};
+*/
+
+&usb3 {
+	qcom,otg-capability;
+};
+
+/*
+  *                 CONFIG_ZTEMT_NX503A_CHARGE
+*/
+
+/ {
+	mtp_batterydata: qcom,battery-data {
+		qcom,rpull-up-kohm = <100>;
+		qcom,vref-batt-therm = <1800000>;
+               /include/ "batterydata-ztemt-NX503A-2300mAh.dtsi"
+            /*		/include/ "../batterydata-palladium.dtsi"*/
+           /*		/include/ "../batterydata-mtp-3000mah.dtsi"*/
+	};
+};
+
+/* ztemt BMS 
+  *                 CONFIG_ZTEMT_NX503A_CHARGE
+*/
+&pm8941_bms {
+	qcom,enable-fcc-learning;
+	qcom,min-fcc-learning-soc = <20>;
+	qcom,min-fcc-ocv-pc = <30>;
+	qcom,min-fcc-learning-samples = <5>;
+	qcom,fcc-resolution = <10>;
+	status = "ok";
+	qcom,battery-data = <&mtp_batterydata>;
+};
+
+/*  ztemt Charger
+  *                 CONFIG_ZTEMT_NX503A_CHARGE
+*/
+&pm8941_chg {
+	status = "ok";
+/*	qcom,charging-disabled;*/
+	qcom,battery-data = <&mtp_batterydata>;
+
+	qcom,chgr@1000 {
+		status = "ok";
+	};
+
+	qcom,buck@1100 {
+		status = "ok";
+	};
+
+	qcom,bat-if@1200 {
+		status = "ok";
+	};
+
+	qcom,usb-chgpth@1300 {
+		status = "ok";
+	};
+
+	qcom,dc-chgpth@1400 {
+		status = "ok";
+	};
+
+	qcom,boost@1500 {
+		status = "ok";
+	};
+
+	qcom,chg-misc@1600 {
+		status = "ok";
+	};
+};
+
+&pm8941_gpios {
+	gpio@c000 { /* GPIO 1 */
+		qcom,mode = <0>;        /* QPNP_PIN_MODE_DIG_IN */
+		qcom,pull = <0>;        /* QPNP_PIN_PULL_UP_30  */
+		qcom,master-en = <1>;
+	};
+
+	gpio@c100 { /* GPIO 2 */
+		qcom,mode = <0>;        /* QPNP_PIN_MODE_DIG_IN */
+		qcom,pull = <0>;        /* QPNP_PIN_PULL_UP_30  */
+		qcom,master-en = <1>;
+	};
+
+	gpio@c200 { /* GPIO 3 */
+		qcom,mode = <0>;        /* QPNP_PIN_MODE_DIG_IN */
+		qcom,pull = <0>;        /* QPNP_PIN_PULL_UP_30  */
+		qcom,vin-sel = <2>;
+		qcom,src-sel = <0>;	/* QPNP_PIN_SEL_FUNC_CONSTANT */
+		qcom,master-en = <1>;
+	};
+
+	gpio@c300 { /* GPIO 4 */
+		qcom,mode = <0>;        /* QPNP_PIN_MODE_DIG_IN */
+		qcom,pull = <0>;        /* QPNP_PIN_PULL_UP_30  */
+		qcom,vin-sel = <2>;     /* QPNP_PIN_VIN2  */
+		qcom,src-sel = <0>;	/* QPNP_PIN_SEL_FUNC_CONSTANT */
+		qcom,master-en = <1>;
+	};
+
+	gpio@c400 { /* GPIO 5 */
+		qcom,mode = <0>;        /* QPNP_PIN_MODE_DIG_IN */
+		qcom,pull = <0>;        /* QPNP_PIN_PULL_UP_30  */
+		qcom,vin-sel = <2>;     /* QPNP_PIN_VIN2  */
+		qcom,src-sel = <0>;	/* QPNP_PIN_SEL_FUNC_CONSTANT */
+		qcom,master-en = <1>;
+	};
+
+	gpio@c500 { /* GPIO 6 */
+		qcom,mode = <0>;        /* QPNP_PIN_MODE_DIG_IN */
+		qcom,pull = <0>;        /* QPNP_PIN_PULL_UP_30  */
+		qcom,master-en = <1>;
+	};
+
+	gpio@c600 { /* GPIO 7 */
+		qcom,mode = <0>;        /* QPNP_PIN_MODE_DIG_IN */
+		qcom,pull = <0>;        /* QPNP_PIN_PULL_UP_30  */
+		qcom,master-en = <1>;
+	};
+
+	gpio@c700 { /* GPIO 8 */
+		qcom,mode = <0>;        /* QPNP_PIN_MODE_DIG_IN */
+		qcom,pull = <0>;        /* QPNP_PIN_PULL_UP_30  */
+		qcom,master-en = <1>;
+	};
+
+	gpio@c800 { /* GPIO 9 */
+		qcom,mode = <1>;          /* QPNP_PIN_MODE_DIG_OUT */
+		qcom,out-strength = <1>;  /* QPNP_PIN_OUT_STRENGTH_LOW */
+		qcom,src-sel = <2>;       /* QPNP_PIN_SEL_FUNC_1  */
+		qcom,master-en = <1>;
+	};
+
+	gpio@c900 { /* GPIO 10 */
+		qcom,mode = <1>;          /* QPNP_PIN_MODE_DIG_OUT */
+		qcom,out-strength = <1>;  /* QPNP_PIN_OUT_STRENGTH_LOW */
+		qcom,src-sel = <2>;       /* QPNP_PIN_SEL_FUNC_1  */
+		qcom,master-en = <1>;
+	};
+
+	gpio@ca00 { /* GPIO 11 */
+		qcom,mode = <1>;          /* QPNP_PIN_MODE_DIG_OUT */
+		qcom,out-strength = <1>;  /* QPNP_PIN_OUT_STRENGTH_LOW */
+		qcom,src-sel = <2>;       /* QPNP_PIN_SEL_FUNC_1  */
+		qcom,master-en = <1>;
+	};
+
+	gpio@cb00 { /* GPIO 12 */
+		qcom,mode = <1>;          /* QPNP_PIN_MODE_DIG_OUT */
+		qcom,out-strength = <1>;  /* QPNP_PIN_OUT_STRENGTH_LOW */
+		qcom,src-sel = <2>;       /* QPNP_PIN_SEL_FUNC_1  */
+		qcom,master-en = <1>;
+	};
+
+	gpio@cc00 { /* GPIO 13 */
+		qcom,mode = <1>;          /* QPNP_PIN_MODE_DIG_OUT */
+		qcom,out-strength = <1>;  /* QPNP_PIN_OUT_STRENGTH_LOW */
+		qcom,src-sel = <2>;       /* QPNP_PIN_SEL_FUNC_1  */
+		qcom,master-en = <1>;
+	};
+
+	gpio@cd00 { /* GPIO 14 */
+		qcom,mode = <1>;          /* QPNP_PIN_MODE_DIG_OUT */
+		qcom,out-strength = <1>;  /* QPNP_PIN_OUT_STRENGTH_LOW */
+		qcom,src-sel = <2>;       /* QPNP_PIN_SEL_FUNC_1  */
+		qcom,master-en = <1>;
+	};
+
+	gpio@ce00 { /* GPIO 15 */
+		qcom,mode = <1>;
+		qcom,output-type = <0>;
+		qcom,pull = <5>;
+		qcom,vin-sel = <2>;
+		qcom,out-strength = <1>;
+		qcom,src-sel = <2>;
+		qcom,master-en = <1>;
+	};
+
+	gpio@cf00 { /* GPIO 16 */
+		qcom,mode = <1>;
+		qcom,output-type = <0>;
+		qcom,pull = <5>;
+		qcom,vin-sel = <2>;
+		qcom,out-strength = <3>;
+		qcom,src-sel = <3>;       /* QPNP_PIN_SEL_FUNC_2  */
+		qcom,master-en = <1>;
+	};
+
+	gpio@d000 { /* GPIO 17 */
+	};
+
+	gpio@d100 { /* GPIO 18 */
+		qcom,mode = <1>;
+		qcom,output-type = <0>;
+		qcom,pull = <5>;
+		qcom,vin-sel = <2>;
+		qcom,out-strength = <3>;
+		qcom,src-sel = <3>;
+		qcom,master-en = <1>;
+	};	
+
+	gpio@d200 { /* GPIO 19 */
+		qcom,mode = <1>;		/* QPNP_PIN_MODE_DIG_OUT */
+		qcom,output-type = <0>;		/* QPNP_PIN_OUT_BUF_CMOS */
+		qcom,pull = <5>;		/* QPNP_PIN_PULL_NO */
+		qcom,vin-sel = <2>;		/* QPNP_PIN_VIN2 */
+		qcom,out-strength = <1>;	/* QPNP_PIN_OUT_STRENGTH_LOW */
+		qcom,src-sel = <0>;		/* QPNP_PIN_SEL_FUNC_CONSTANT */
+		qcom,master-en = <1>;
+	};
+
+	gpio@d300 { /* GPIO 20 */
+		qcom,mode = <1>;          /* QPNP_PIN_MODE_DIG_OUT */
+		qcom,out-strength = <1>;  /* QPNP_PIN_OUT_STRENGTH_LOW */
+		qcom,src-sel = <2>;       /* QPNP_PIN_SEL_FUNC_1  */
+		qcom,master-en = <1>;
+	};
+
+	gpio@d400 { /* GPIO 21 */
+	};
+
+	gpio@d500 { /* GPIO 22 */
+		qcom,mode = <0>;        /* QPNP_PIN_MODE_DIG_IN */
+		qcom,pull = <4>;	/* QPNP_PIN_PULL_DN */
+		qcom,master-en = <1>;
+	};
+
+	gpio@d600 { /* GPIO 23 */
+		qcom,mode = <1>;          /* QPNP_PIN_MODE_DIG_OUT */
+		qcom,out-strength = <1>;  /* QPNP_PIN_OUT_STRENGTH_LOW */
+		qcom,src-sel = <2>;       /* QPNP_PIN_SEL_FUNC_1  */
+		qcom,master-en = <1>;
+	};
+
+	gpio@d700 { /* GPIO 24 */
+		qcom,mode = <1>;          /* QPNP_PIN_MODE_DIG_OUT */
+		qcom,out-strength = <1>;  /* QPNP_PIN_OUT_STRENGTH_LOW */
+		qcom,src-sel = <2>;       /* QPNP_PIN_SEL_FUNC_1  */
+		qcom,master-en = <1>;
+	};
+
+	gpio@d800 { /* GPIO 25 */
+		qcom,mode = <1>;          /* QPNP_PIN_MODE_DIG_OUT */
+		qcom,out-strength = <1>;  /* QPNP_PIN_OUT_STRENGTH_LOW */
+		qcom,src-sel = <2>;       /* QPNP_PIN_SEL_FUNC_1  */
+		qcom,master-en = <1>;
+	};
+
+	gpio@d900 { /* GPIO 26 */
+		qcom,mode = <1>;          /* QPNP_PIN_MODE_DIG_OUT */
+		qcom,out-strength = <1>;  /* QPNP_PIN_OUT_STRENGTH_LOW */
+		qcom,src-sel = <2>;       /* QPNP_PIN_SEL_FUNC_1  */
+		qcom,master-en = <1>;
+	};
+
+	gpio@da00 { /* GPIO 27 */
+		qcom,mode = <0>;        /* QPNP_PIN_MODE_DIG_IN */
+		qcom,pull = <4>;	/* QPNP_PIN_PULL_DN */
+		qcom,master-en = <1>;
+	};
+
+	gpio@db00 { /* GPIO 28 */
+	};
+
+	gpio@dc00 { /* GPIO 29 */
+		qcom,mode = <1>;          /* QPNP_PIN_MODE_DIG_OUT */
+		qcom,out-strength = <1>;  /* QPNP_PIN_OUT_STRENGTH_LOW */
+		qcom,src-sel = <2>;       /* QPNP_PIN_SEL_FUNC_1  */
+		qcom,master-en = <1>;
+	};
+
+	gpio@dd00 { /* GPIO 30 */
+		qcom,mode = <0>;        /* QPNP_PIN_MODE_DIG_IN */
+		qcom,pull = <4>;	/* QPNP_PIN_PULL_DN */
+		qcom,master-en = <1>;
+	};
+
+	gpio@de00 { /* GPIO 31 */
+	};
+
+	gpio@df00 { /* GPIO 32 */
+		qcom,mode = <0>;        /* QPNP_PIN_MODE_DIG_IN */
+		qcom,pull = <4>;	/* QPNP_PIN_PULL_DN */
+		qcom,vin-sel = <2>; /*add PM8941 s3 = 1.8V */
+		qcom,master-en = <1>;
+	};
+
+	gpio@e000 { /* GPIO 33 */
+		qcom,mode = <0>;        /* QPNP_PIN_MODE_DIG_IN */
+		qcom,pull = <4>;	/* QPNP_PIN_PULL_DN */
+		qcom,master-en = <1>;
+	};
+
+	gpio@e100 { /* GPIO 34 */
+		qcom,mode = <0>;        /* QPNP_PIN_MODE_DIG_IN */
+		qcom,pull = <4>;	/* QPNP_PIN_PULL_DN */
+		qcom,master-en = <1>;
+	};
+
+	gpio@e200 { /* GPIO 35 */
+		qcom,mode = <0>;        /* QPNP_PIN_MODE_DIG_IN */
+		qcom,pull = <4>;	/* QPNP_PIN_PULL_DN */
+		qcom,master-en = <1>;
+	};
+
+	gpio@e300 { /* GPIO 36 */
+	};
+};
+
+&pm8941_mpps {
+
+	mpp@a000 { /* MPP 1 */
+		status = "disabled";
+	};
+
+	mpp@a100 { /* MPP 2 */
+		qcom,mode = <1>;          /* QPNP_PIN_MODE_DIG_OUT */
+		qcom,out-strength = <1>;  /* QPNP_PIN_OUT_STRENGTH_LOW */
+		qcom,master-en = <1>;
+	};
+
+	mpp@a200 { /* MPP 3 */
+	};
+
+	mpp@a300 { /* MPP 4 */
+	};
+
+	mpp@a400 { /* MPP 5 */
+	};
+
+	mpp@a500 { /* MPP 6 */
+		/* SPI_ETH_RST config */
+		qcom,mode = <1>; /* DIG_OUT */
+		qcom,output-type = <0>; /* CMOS */
+		qcom,vin-sel = <2>; /* PM8941_S3 1.8V > 1.6V */
+		qcom,src-sel = <0>; /* CONSTANT */
+		qcom,out-strength = <1>;  /* QPNP_PIN_OUT_STRENGTH_LOW */
+		qcom,master-en = <1>; /* ENABLE MPP */
+	};
+
+	mpp@a600 { /* MPP 7 */
+		qcom,mode = <1>;          /* QPNP_PIN_MODE_DIG_OUT */
+		qcom,out-strength = <1>;  /* QPNP_PIN_OUT_STRENGTH_LOW */
+		qcom,master-en = <1>;
+	};
+
+	mpp@a700 { /* MPP 8 */
+		qcom,mode = <1>;          /* QPNP_PIN_MODE_DIG_OUT */
+		qcom,out-strength = <1>;  /* QPNP_PIN_OUT_STRENGTH_LOW */
+		qcom,master-en = <1>;
+	};
+};
+
+&slim_msm {
+	taiko_codec {
+		/* If boot isn't available, vph_pwr_vreg can be used instead */
+		cdc-vdd-spkdrv-supply = <&pm8941_boost>;
+		qcom,cdc-vdd-spkdrv-voltage = <5000000 5000000>;
+		qcom,cdc-vdd-spkdrv-current = <1250000>;
+		qcom,cdc-on-demand-supplies = "cdc-vdd-spkdrv";
+	};
+};
+
+&spi_epm {
+	epm-adc@0 {
+		compatible = "cy,epm-adc-cy8c5568lti-114";
+		reg = <0>;
+		interrupt-parent = <&msmgpio>;
+		spi-max-frequency = <960000>;
+		qcom,channels = <31>;
+		qcom,gain = <100 100 100 50 100 100 1 100 1 50
+				1 100 1 100 50 50 50 50 50 50
+				100 50 100 50 50 50 50 50 50 50
+				50>;
+		qcom,rsense = <2 2 2 200 20 2 1 2 1 30
+				1 10 1 30 50 30 500 30 100 30
+				100 500 20 200 1000 20 1000 1000 70 200
+				50>;
+		qcom,channel-type = <0x1540>;
+	};
+};
+
+&dsi_sp_1080_5p0_vid {
+       qcom,cont-splash-enabled;
+};
diff --git a/arch/arm/boot/dts/NX503A/msm8974-regulator.dtsi b/arch/arm/boot/dts/NX503A/msm8974-regulator.dtsi
new file mode 100755
index 0000000..962c956
--- /dev/null
+++ b/arch/arm/boot/dts/NX503A/msm8974-regulator.dtsi
@@ -0,0 +1,569 @@
+/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+/* QPNP controlled regulators: */
+
+&pm8941_lsid1 {
+	pm8941_boost: regulator@a000 {
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		qcom,enable-time = <500>;
+		status = "okay";
+	};
+
+	pm8941_mvs1: regulator@8300 {
+		parent-supply = <&pm8941_chg_otg>;
+		qcom,enable-time = <1000>;
+		qcom,pull-down-enable = <1>;
+		interrupts = <0x1 0x83 0x2>;
+		interrupt-names = "ocp";
+		qcom,ocp-enable = <1>;
+		qcom,ocp-max-retries = <10>;
+		qcom,ocp-retry-delay = <30>;
+		qcom,soft-start-enable = <1>;
+		qcom,vs-soft-start-strength = <0>;
+		qcom,hpm-enable = <1>;
+		qcom,auto-mode-enable = <0>;
+		status = "okay";
+	};
+
+	pm8941_mvs2: regulator@8400 {
+		parent-supply = <&pm8941_boost>;
+		qcom,enable-time = <1000>;
+		qcom,pull-down-enable = <1>;
+		interrupts = <0x1 0x84 0x2>;
+		interrupt-names = "ocp";
+		qcom,ocp-enable = <1>;
+		qcom,ocp-max-retries = <10>;
+		qcom,ocp-retry-delay = <30>;
+		qcom,soft-start-enable = <1>;
+		qcom,vs-soft-start-strength = <0>;
+		qcom,hpm-enable = <1>;
+		qcom,auto-mode-enable = <0>;
+		status = "okay";
+	};
+};
+
+/* RPM controlled regulators: */
+
+&rpm_bus {
+	rpm-regulator-smpb1 {
+		status = "okay";
+		pm8841_s1: regulator-s1 {
+			regulator-min-microvolt = <675000>;
+			regulator-max-microvolt = <1050000>;
+			status = "okay";
+		};
+		pm8841_s1_ao: regulator-s1-ao {
+			regulator-name = "8841_s1_ao";
+			qcom,set = <1>;
+			regulator-min-microvolt = <675000>;
+			regulator-max-microvolt = <1050000>;
+			status = "okay";
+			compatible = "qcom,rpm-regulator-smd";
+		};
+		pm8841_s1_so: regulator-s1-so {
+			regulator-name = "8841_s1_so";
+			qcom,set = <2>;
+			regulator-min-microvolt = <675000>;
+			regulator-max-microvolt = <1050000>;
+			qcom,init-voltage = <675000>;
+			status = "okay";
+			compatible = "qcom,rpm-regulator-smd";
+		};
+	};
+
+	rpm-regulator-smpb2 {
+		status = "okay";
+		pm8841_s2: regulator-s2 {
+			regulator-min-microvolt = <500000>;
+			regulator-max-microvolt = <1050000>;
+			status = "okay";
+		};
+		pm8841_s2_corner: regulator-s2-corner {
+			regulator-name = "8841_s2_corner";
+			qcom,set = <3>;
+			regulator-min-microvolt = <1>;
+			regulator-max-microvolt = <7>;
+			qcom,use-voltage-corner;
+			compatible = "qcom,rpm-regulator-smd";
+			qcom,consumer-supplies = "vdd_dig", "";
+		};
+		pm8841_s2_corner_ao: regulator-s2-corner-ao {
+			regulator-name = "8841_s2_corner_ao";
+			qcom,set = <1>;
+			regulator-min-microvolt = <1>;
+			regulator-max-microvolt = <7>;
+			qcom,use-voltage-corner;
+			compatible = "qcom,rpm-regulator-smd";
+		};
+		pm8841_s2_floor_corner: regulator-s2-floor-corner {
+			compatible = "qcom,rpm-regulator-smd";
+			regulator-name = "8841_s2_floor_corner";
+			qcom,set = <3>;
+			regulator-min-microvolt = <1>;
+			regulator-max-microvolt = <7>;
+			qcom,use-voltage-floor-corner;
+			qcom,always-send-voltage;
+		};
+	};
+
+	rpm-regulator-smpb3 {
+		status = "okay";
+		pm8841_s3: regulator-s3 {
+			regulator-min-microvolt = <1050000>;
+			regulator-max-microvolt = <1050000>;
+			qcom,init-voltage = <1050000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-smpb4 {
+		status = "okay";
+		pm8841_s4: regulator-s4 {
+			regulator-min-microvolt = <815000>;
+			regulator-max-microvolt = <900000>;
+			status = "okay";
+		};
+		pm8841_s4_corner: regulator-s4-corner {
+			compatible = "qcom,rpm-regulator-smd";
+			regulator-name = "8841_s4_corner";
+			qcom,set = <3>;
+			qcom,use-voltage-corner;
+			regulator-min-microvolt = <1>;
+			regulator-max-microvolt = <7>;
+			qcom,init-voltage-corner = <3>; /* SVS SOC */
+		};
+		pm8841_s4_floor_corner: regulator-s4-floor-corner {
+			compatible = "qcom,rpm-regulator-smd";
+			regulator-name = "8841_s4_floor_corner";
+			qcom,set = <3>;
+			regulator-min-microvolt = <1>;
+			regulator-max-microvolt = <7>;
+			qcom,use-voltage-floor-corner;
+			qcom,always-send-voltage;
+		};
+	};
+
+	rpm-regulator-smpa1 {
+		status = "okay";
+		pm8941_s1: regulator-s1 {
+			regulator-min-microvolt = <1300000>;
+			regulator-max-microvolt = <1300000>;
+			qcom,init-voltage = <1300000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-smpa2 {
+		status = "okay";
+		pm8941_s2: regulator-s2 {
+			regulator-min-microvolt = <2150000>;
+			regulator-max-microvolt = <2150000>;
+			qcom,init-voltage = <2150000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-smpa3 {
+		status = "okay";
+		pm8941_s3: regulator-s3 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			qcom,init-voltage = <1800000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa1 {
+		status = "okay";
+		pm8941_l1: regulator-l1 {
+			regulator-min-microvolt = <1225000>;
+			regulator-max-microvolt = <1225000>;
+			qcom,init-voltage = <1225000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa2 {
+		status = "okay";
+		pm8941_l2: regulator-l2 {
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			qcom,init-voltage = <1200000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa3 {
+		status = "okay";
+		pm8941_l3: regulator-l3 {
+			regulator-min-microvolt = <1050000>;
+			regulator-max-microvolt = <1500000>;
+			qcom,init-voltage = <1225000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa4 {
+		status = "okay";
+		pm8941_l4: regulator-l4 {
+			regulator-min-microvolt = <1225000>;
+			regulator-max-microvolt = <1225000>;
+			qcom,init-voltage = <1225000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa5 {
+		status = "okay";
+		pm8941_l5: regulator-l5 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			qcom,init-voltage = <1800000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa6 {
+		status = "okay";
+		pm8941_l6: regulator-l6 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			qcom,init-voltage = <1800000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa7 {
+		status = "okay";
+		pm8941_l7: regulator-l7 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			qcom,init-voltage = <1800000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa8 {
+		status = "okay";
+		pm8941_l8: regulator-l8 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			qcom,init-voltage = <1800000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa9 {
+		status = "okay";
+		pm8941_l9: regulator-l9 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <2950000>;
+			qcom,init-voltage = <2950000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa10 {
+		status = "okay";
+		pm8941_l10: regulator-l10 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <2950000>;
+			qcom,init-voltage = <2950000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa11 {
+		status = "okay";
+		pm8941_l11: regulator-l11 {
+			regulator-min-microvolt = <1225000>;
+			regulator-max-microvolt = <1350000>;
+			qcom,init-voltage = <1300000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa12 {
+		status = "okay";
+		pm8941_l12: regulator-l12 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			status = "okay";
+		};
+		pm8941_l12_ao: regulator-l12-ao {
+			regulator-name = "8941_l12_ao";
+			qcom,set = <1>;
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			status = "okay";
+			compatible = "qcom,rpm-regulator-smd";
+		};
+	};
+
+	rpm-regulator-ldoa13 {
+		status = "okay";
+		pm8941_l13: regulator-l13 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <2950000>;
+			qcom,init-voltage = <2950000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa14 {
+		status = "okay";
+		pm8941_l14: regulator-l14 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			qcom,init-voltage = <1800000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa15 {
+		status = "okay";
+		pm8941_l15: regulator-l15 {
+			regulator-min-microvolt = <2050000>;
+			regulator-max-microvolt = <2050000>;
+			qcom,init-voltage = <2050000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa16 {
+		status = "okay";
+		pm8941_l16: regulator-l16 {
+			regulator-min-microvolt = <2700000>;
+			regulator-max-microvolt = <2700000>;
+			qcom,init-voltage = <2700000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa17 {
+		status = "okay";
+		pm8941_l17: regulator-l17 {
+			regulator-min-microvolt = <2800000>;
+			regulator-max-microvolt = <2850000>;
+			qcom,init-voltage = <2850000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa18 {
+		status = "okay";
+		pm8941_l18: regulator-l18 {
+			regulator-min-microvolt = <2850000>;
+			regulator-max-microvolt = <2850000>;
+			qcom,init-voltage = <2850000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa19 {
+		status = "okay";
+		pm8941_l19: regulator-l19 {
+			regulator-min-microvolt = <2800000>;
+			regulator-max-microvolt = <3350000>;
+			qcom,init-voltage = <2900000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa20 {
+		status = "okay";
+		pm8941_l20: regulator-l20 {
+			regulator-min-microvolt = <2950000>;
+			regulator-max-microvolt = <2950000>;
+			qcom,init-voltage = <2950000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa21 {
+		status = "okay";
+		pm8941_l21: regulator-l21 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <2950000>;
+			qcom,init-voltage = <2950000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa22 {
+		status = "okay";
+		pm8941_l22: regulator-l22 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			qcom,init-voltage = <1800000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa23 {
+		status = "okay";
+		pm8941_l23: regulator-l23 {
+			regulator-min-microvolt = <2800000>;
+			regulator-max-microvolt = <3000000>;
+			qcom,init-voltage = <3000000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-ldoa24 {
+		status = "okay";
+		pm8941_l24: regulator-l24 {
+			regulator-min-microvolt = <3075000>;
+			regulator-max-microvolt = <3075000>;
+			qcom,init-voltage = <3075000>;
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-vsa1 {
+		status = "okay";
+		pm8941_lvs1: regulator-lvs1 {
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-vsa2 {
+		status = "okay";
+		pm8941_lvs2: regulator-lvs2 {
+			status = "okay";
+		};
+	};
+
+	rpm-regulator-vsa3 {
+		status = "okay";
+		pm8941_lvs3: regulator-lvs3 {
+			status = "okay";
+		};
+	};
+};
+
+&soc {
+	krait_pdn: krait-pdn@f9011000 {
+		reg = <0xf9011000 0x1000>,
+		      <0xfc4b80b0 8>;
+		reg-names = "apcs_gcc", "phase-scaling-efuse";
+		compatible = "qcom,krait-pdn";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		qcom,pfm-threshold = <76>;
+		qcom,use-phase-scaling-factor;
+
+		krait0_vreg: regulator@f9088000 {
+			compatible = "qcom,krait-regulator";
+			regulator-name = "krait0";
+			reg = <0xf9088000 0x1000>, /* APCS_ALIAS0_KPSS_ACS */
+				<0xf908a800 0x1000>; /* APCS_ALIAS0_KPSS_MDD */
+			reg-names = "acs", "mdd";
+			regulator-min-microvolt = <500000>;
+			regulator-max-microvolt = <1100000>;
+			qcom,headroom-voltage = <150000>;
+			qcom,retention-voltage = <675000>;
+			qcom,ldo-default-voltage = <750000>;
+			qcom,ldo-threshold-voltage = <850000>;
+			qcom,ldo-delta-voltage = <50000>;
+			qcom,cpu-num = <0>;
+		};
+
+		krait1_vreg: regulator@f9098000 {
+			compatible = "qcom,krait-regulator";
+			regulator-name = "krait1";
+			reg = <0xf9098000 0x1000>, /* APCS_ALIAS1_KPSS_ACS */
+				<0xf909a800 0x1000>; /* APCS_ALIAS1_KPSS_MDD */
+			reg-names = "acs", "mdd";
+			regulator-min-microvolt = <500000>;
+			regulator-max-microvolt = <1100000>;
+			qcom,headroom-voltage = <150000>;
+			qcom,retention-voltage = <675000>;
+			qcom,ldo-default-voltage = <750000>;
+			qcom,ldo-threshold-voltage = <850000>;
+			qcom,ldo-delta-voltage = <50000>;
+			qcom,cpu-num = <1>;
+		};
+
+		krait2_vreg: regulator@f90a8000 {
+			compatible = "qcom,krait-regulator";
+			regulator-name = "krait2";
+			reg = <0xf90a8000 0x1000>, /* APCS_ALIAS2_KPSS_ACS */
+				<0xf90aa800 0x1000>; /* APCS_ALIAS2_KPSS_MDD */
+			reg-names = "acs", "mdd";
+			regulator-min-microvolt = <500000>;
+			regulator-max-microvolt = <1100000>;
+			qcom,headroom-voltage = <150000>;
+			qcom,retention-voltage = <675000>;
+			qcom,ldo-default-voltage = <750000>;
+			qcom,ldo-threshold-voltage = <850000>;
+			qcom,ldo-delta-voltage = <50000>;
+			qcom,cpu-num = <2>;
+		};
+
+		krait3_vreg: regulator@f90b8000 {
+			compatible = "qcom,krait-regulator";
+			regulator-name = "krait3";
+			reg = <0xf90b8000 0x1000>, /* APCS_ALIAS3_KPSS_ACS */
+				<0xf90ba800 0x1000>; /* APCS_ALIAS3_KPSS_MDD */
+			reg-names = "acs", "mdd";
+			regulator-min-microvolt = <500000>;
+			regulator-max-microvolt = <1100000>;
+			qcom,headroom-voltage = <150000>;
+			qcom,retention-voltage = <675000>;
+			qcom,ldo-default-voltage = <750000>;
+			qcom,ldo-threshold-voltage = <850000>;
+			qcom,ldo-delta-voltage = <50000>;
+			qcom,cpu-num = <3>;
+		};
+	};
+
+	spi_eth_vreg: spi_eth_phy_vreg {
+		compatible = "regulator-fixed";
+		regulator-name = "ethernet_phy";
+		gpio = <&pm8941_mpps 5 0>;
+		enable-active-high;
+	};
+
+	/*
+	 * vph_pwr_vreg represents the unregulated battery voltage supply
+	 * VPH_PWR that is present whenever the device is powered on.
+	 */
+	vph_pwr_vreg: vph_pwr_vreg {
+		compatible = "regulator-fixed";
+		status = "disabled";
+		regulator-name = "vph_pwr";
+		regulator-always-on;
+	};
+};
+
+&pm8941_chg {
+	otg-parent-supply = <&pm8941_boost>;
+};
+
+&pm8941_chg_boost {
+	regulator-min-microvolt = <5000000>;
+	regulator-max-microvolt = <5000000>;
+	regulator-name = "8941_smbb_boost";
+};
+
+&pm8941_chg_batif  {
+	regulator-name = "batfet";
+};
+
+&pm8941_chg_otg {
+	regulator-name = "8941_smbb_otg";
+};
diff --git a/arch/arm/boot/dts/NX503A/msm8974-v2.0-1.dtsi b/arch/arm/boot/dts/NX503A/msm8974-v2.0-1.dtsi
new file mode 100755
index 0000000..1fad868
--- /dev/null
+++ b/arch/arm/boot/dts/NX503A/msm8974-v2.0-1.dtsi
@@ -0,0 +1,36 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * As a general rule, only version-specific property overrides should be placed
+ * inside this file. However, device definitions should be placed inside the
+ * msm8974.dtsi file.
+ */
+
+/include/ "msm8974-v2.dtsi"
+
+&gdsc_venus {
+	qcom,skip-logic-collapse;
+	qcom,retain-periph;
+	qcom,retain-mem;
+};
+
+&gdsc_mdss {
+	qcom,skip-logic-collapse;
+	qcom,retain-periph;
+	qcom,retain-mem;
+};
+
+&gdsc_oxili_gx {
+	qcom,retain-mem;
+	qcom,retain-periph;
+};
diff --git a/arch/arm/boot/dts/NX503A/msm8974-v2.2.dtsi b/arch/arm/boot/dts/NX503A/msm8974-v2.2.dtsi
new file mode 100755
index 0000000..14897ba
--- /dev/null
+++ b/arch/arm/boot/dts/NX503A/msm8974-v2.2.dtsi
@@ -0,0 +1,99 @@
+/* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * As a general rule, only version-specific property overrides should be placed
+ * inside this file. However, device definitions should be placed inside the
+ * msm8974.dtsi file.
+ */
+
+/include/ "msm8974-v2.dtsi"
+
+/* GPU overrides */
+&msm_gpu {
+	/* Updated chip ID */
+	qcom,chipid = <0x03030001>;
+
+	qcom,initial-pwrlevel = <2>;
+
+	/* Updated bus bandwidth requirements */
+	qcom,msm-bus,vectors-KBps =
+		/* Off */
+		<26 512 0 0>, <89 604 0 0>,
+		/* Sub-SVS / SVS */
+		<26 512 0 1600000>, <89 604 0 3000000>,
+		/* SVS */
+		<26 512 0 2400000>, <89 604 0 3000000>,
+		/* Nominal / SVS */
+		<26 512 0 4656000>, <89 604 0 3000000>,
+		/* SVS / Nominal */
+		<26 512 0 2400000>, <89 604 0 5120000>,
+		/* Nominal */
+		<26 512 0 4656000>, <89 604 0 5120000>,
+		/* Turbo / Nominal */
+		<26 512 0 7464000>, <89 604 0 5120000>,
+		/* Nominal / Turbo */
+		<26 512 0 4656000>, <89 604 0 6400000>,
+		/* Turbo */
+		<26 512 0 7464000>, <89 604 0 6400000>;
+
+	qcom,gpu-pwrlevels {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		compatible = "qcom,gpu-pwrlevels";
+
+		qcom,gpu-pwrlevel@0 {
+			reg = <0>;
+			qcom,gpu-freq = <450000000>;
+			qcom,bus-freq = <8>;
+			qcom,io-fraction = <33>;
+		};
+
+		qcom,gpu-pwrlevel@1 {
+			reg = <1>;
+			qcom,gpu-freq = <389000000>;
+			qcom,bus-freq = <5>;
+			qcom,io-fraction = <33>;
+		};
+
+		qcom,gpu-pwrlevel@2 {
+			reg = <2>;
+			qcom,gpu-freq = <320000000>;
+			qcom,bus-freq = <5>;
+			qcom,io-fraction = <66>;
+		};
+
+		qcom,gpu-pwrlevel@3 {
+			reg = <3>;
+			qcom,gpu-freq = <200000000>;
+			qcom,bus-freq = <2>;
+			qcom,io-fraction = <100>;
+		};
+
+		qcom,gpu-pwrlevel@4 {
+			reg = <4>;
+			qcom,gpu-freq = <27000000>;
+			qcom,bus-freq = <0>;
+			qcom,io-fraction = <0>;
+		};
+	};
+};
+
+&gdsc_mdss {
+	qcom,retain-periph;
+	qcom,retain-mem;
+};
+
+&gdsc_venus {
+	qcom,skip-logic-collapse;
+};
diff --git a/arch/arm/boot/dts/NX503A/msm8974-v2.dtsi b/arch/arm/boot/dts/NX503A/msm8974-v2.dtsi
new file mode 100755
index 0000000..cc0f5c7
--- /dev/null
+++ b/arch/arm/boot/dts/NX503A/msm8974-v2.dtsi
@@ -0,0 +1,221 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * As a general rule, only version-specific property overrides should be placed
+ * inside this file. However, device definitions should be placed inside the
+ * msm8974.dtsi file.
+ */
+
+/include/ "msm8974.dtsi"
+
+/include/ "../msm-pm8x41-rpm-regulator.dtsi"
+/include/ "../msm-pm8841.dtsi"
+&spmi_bus {
+	pm8941_lsid0: qcom,pm8941@0 {
+		reg = <0x0>;
+	};
+	pm8941_lsid1: qcom,pm8941@1 {
+		reg = <0x1>;
+	};
+};
+/include/ "msm-pm8941.dtsi"
+/include/ "msm8974-regulator.dtsi"
+/include/ "../msm8974-clock.dtsi"
+
+/include/ "../msm8974-v2-iommu.dtsi"
+/include/ "../msm8974-v2-iommu-domains.dtsi"
+/include/ "../msm8974-v2-pm.dtsi"
+
+&soc {
+	android_usb@fe8050c8 {
+		compatible = "qcom,android-usb";
+		reg = <0xfe8050c8 0xc8>;
+		qcom,android-usb-swfi-latency = <1>;
+		qcom,android-usb-cdrom;
+	};
+
+	qcom,msm-imem@fe805000 {
+		compatible = "qcom,msm-imem";
+		reg = <0xfe805000 0x1000>; /* Address and size of IMEM */
+	};
+};
+
+&usb3 {
+	qcom,usbin-vadc = <&pm8941_vadc>;
+};
+
+/* GPU overrides */
+&msm_gpu {
+	/* Updated chip ID */
+	qcom,chipid = <0x03030001>;
+
+	/* Updated bus bandwidth requirements */
+	qcom,msm-bus,vectors-KBps =
+		/* Off */
+		<26 512 0 0>, <89 604 0 0>,
+		/* Sub-SVS / SVS */
+		<26 512 0 1600000>, <89 604 0 3000000>,
+		/* SVS */
+		<26 512 0 2400000>, <89 604 0 3000000>,
+		/* Nominal / SVS */
+		<26 512 0 4912000>, <89 604 0 3000000>,
+		/* SVS / Nominal */
+		<26 512 0 2400000>, <89 604 0 5120000>,
+		/* Nominal */
+		<26 512 0 4912000>, <89 604 0 5120000>,
+		/* Turbo / Nominal */
+		<26 512 0 7464000>, <89 604 0 5120000>,
+		/* Nominal / Turbo */
+		<26 512 0 4912000>, <89 604 0 6400000>,
+		/* Turbo */
+		<26 512 0 7464000>, <89 604 0 6400000>;
+};
+
+&mdss_mdp {
+	qcom,vbif-settings = <0x0004 0x00000001>;
+
+	qcom,mdss-wb-off = <0x00011100 0x00011500
+			    0x00011900 0x00011D00 0x00012100>;
+	qcom,mdss-intf-off = <0x00012500 0x00012700
+			      0x00012900 0x00012b00>;
+	qcom,mdss-pingpong-off = <0x00012D00 0x00012E00 0x00012F00>;
+	qcom,mdss-has-bwc;
+	qcom,mdss-has-decimation;
+	qcom,mdss-ad-off = <0x0013100 0x00013300>;
+	vdd-cx-supply = <&pm8841_s2_corner>;
+};
+
+&mdss_hdmi_tx {
+	reg =	<0xfd922100 0x370>,
+		<0xfd922500 0x7C>,
+		<0xfc4b8000 0x60F0>;
+	reg-names = "core_physical", "phy_physical", "qfprom_physical";
+};
+
+&msm_vidc {
+	qcom,vidc-ns-map = <0x40000000 0x40000000>;
+	qcom,load-freq-tbl = <979200 465000000>,
+		<783360 465000000>,
+		<489600 266670000>,
+		<244800 133330000>;
+	qcom,reg-presets = <0x80004 0x1>,
+		<0x80070 0x11FFF>,
+		<0x80074 0xA4>,
+		<0x800A8 0x1FFF>,
+		<0x80124 0x3>,
+		<0xE0020 0x5555556>,
+		<0xE0024 0x0>;
+	qcom,bus-ports = <1>;
+	qcom,enc-ocmem-ab-ib = <0 0>,
+		<138000 1034000>,
+		<414000 1034000>,
+		<940000 1034000>,
+		<1880000 2068000>,
+		<3008000 3309000>,
+		<3760000 4136000>,
+		<4468000 2457000>;
+	qcom,dec-ocmem-ab-ib = <0 0>,
+		<176000 519000>,
+		<456000 519000>,
+		<864000 629000>,
+		<1728000 1038000>,
+		<2766000 1661000>,
+		<3456000 2076000>,
+		<3662000 2198000>;
+	qcom,enc-ddr-ab-ib = <0 0>,
+		<120000 302000>,
+		<364000 302000>,
+		<804000 302000>,
+		<1608000 604000>,
+		<2576000 967000>,
+		<4680000 1404000>,
+		<49880000 1496000>;
+	qcom,dec-ddr-ab-ib = <0 0>,
+		<208000 303000>,
+		<536000 1600000>,
+		<1012000 1600000>,
+		<2024000 1600000>,
+		<3240000 1600000>,
+		<4048000 1600000>,
+		<4264000 1600000>;
+	qcom,buffer-type-tz-usage-table = <0x241 0x1>,
+					<0x106 0x2>,
+					<0x480 0x3>;
+	qcom,vidc-iommu-domains {
+		qcom,domain-ns {
+			qcom,vidc-domain-phandle = <&venus_domain_ns>;
+			qcom,vidc-partition-buffer-types = <0x7ff>,
+							<0x800>;
+		};
+		qcom,domain-sec-bs {
+			qcom,vidc-domain-phandle = <&venus_domain_sec_bitstream>;
+			qcom,vidc-partition-buffer-types = <0x241>;
+		};
+		qcom,domain-sec-px {
+			qcom,vidc-domain-phandle = <&venus_domain_sec_pixel>;
+			qcom,vidc-partition-buffer-types = <0x106>;
+		};
+		qcom,domain-sec-np {
+			qcom,vidc-domain-phandle = <&venus_domain_sec_non_pixel>;
+			qcom,vidc-partition-buffer-types = <0x480>;
+		};
+	};
+
+};
+
+&krait_pdn {
+	qcom,use-phase-switching;
+};
+
+&tspp {
+	vdd_cx-supply = <&pm8841_s2_corner>;
+};
+
+&krait_regulator_pmic {
+	status = "ok";
+
+	qcom,ctl@2000 {
+		status = "ok";
+	};
+
+	qcom,ps@2100 {
+		status = "ok";
+	};
+
+	qcom,freq@2200 {
+		status = "ok";
+	};
+};
+
+&cci {
+
+	qcom,camera@6e {
+		qcom,vdd-cx-supply = <&pm8841_s2>;
+		qcom,vdd-cx-name = "qcom,vdd-cx";
+	};
+
+	qcom,camera@20 {
+		qcom,vdd-cx-supply = <&pm8841_s2>;
+		qcom,vdd-cx-name = "qcom,vdd-cx";
+	};
+
+	qcom,camera@6c {
+		qcom,vdd-cx-supply = <&pm8841_s2>;
+		qcom,vdd-cx-name = "qcom,vdd-cx";
+	};
+
+	qcom,camera@90 {
+		qcom,vdd-cx-supply = <&pm8841_s2>;
+		qcom,vdd-cx-name = "qcom,vdd-cx";
+	};
+};
diff --git a/arch/arm/boot/dts/NX503A/msm8974.dtsi b/arch/arm/boot/dts/NX503A/msm8974.dtsi
new file mode 100755
index 0000000..382f6bd
--- /dev/null
+++ b/arch/arm/boot/dts/NX503A/msm8974.dtsi
@@ -0,0 +1,2621 @@
+/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/include/ "../skeleton.dtsi"
+
+/ {
+	model = "Qualcomm MSM 8974";
+	compatible = "qcom,msm8974";
+	interrupt-parent = <&intc>;
+
+	aliases {
+		spi0 = &spi_0;
+		spi7 = &spi_7;
+		sdhc1 = &sdhc_1; /* SDC1 eMMC slot */
+		sdhc2 = &sdhc_2; /* SDC2 SD card slot */
+		sdhc3 = &sdhc_3; /* SDC3 SDIO slot */
+		sdhc4 = &sdhc_4; /* SDC4 SDIO slot */
+
+		/* smdtty devices */
+		smd1 = &smdtty_apps_fm;
+		smd2 = &smdtty_apps_riva_bt_acl;
+		smd3 = &smdtty_apps_riva_bt_cmd;
+		smd4 = &smdtty_mbalbridge;
+		smd5 = &smdtty_apps_riva_ant_cmd;
+		smd6 = &smdtty_apps_riva_ant_data;
+		smd7 = &smdtty_data1;
+		smd11 = &smdtty_data11;
+		smd21 = &smdtty_data21;
+		smd27 = &smdtty_gps_nmea;
+		smd36 = &smdtty_loopback;
+	};
+
+	cpus {
+		#size-cells = <0>;
+		#address-cells = <1>;
+
+		CPU0: cpu@0 {
+			device_type = "cpu";
+			compatible = "qcom,krait";
+			reg = <0x0>;
+		};
+
+		CPU1: cpu@1 {
+			device_type = "cpu";
+			compatible = "qcom,krait";
+			reg = <0x1>;
+		};
+
+		CPU2: cpu@2 {
+			device_type = "cpu";
+			compatible = "qcom,krait";
+			reg = <0x2>;
+		};
+
+		CPU3: cpu@3 {
+			device_type = "cpu";
+			compatible = "qcom,krait";
+			reg = <0x3>;
+		};
+	};
+
+	memory {
+		secure_mem: secure_region {
+			linux,contiguous-region;
+			reg = <0 0xFC00000>;
+			label = "secure_mem";
+		};
+
+		adsp_mem: adsp_region {
+			linux,contiguous-region;
+			reg = <0 0x3F00000>;
+			label = "adsp_mem";
+		};
+
+		qsecom_mem: qsecom_region {
+			linux,contiguous-region;
+			reg = <0 0x1100000>;
+			label = "qseecom_mem";
+		};
+
+	};
+
+	soc: soc { };
+};
+
+/include/ "../msm8974-camera.dtsi"
+/include/ "../msm8974-coresight.dtsi"
+/include/ "../msm-gdsc.dtsi"
+/include/ "../msm8974-ion.dtsi"
+/include/ "../msm8974-gpu.dtsi"
+/include/ "msm8974-mdss.dtsi"
+/include/ "../msm8974-smp2p.dtsi"
+/include/ "../msm8974-bus.dtsi"
+/include/ "../msm-rdbg.dtsi"
+
+&soc {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	ranges;
+
+	intc: interrupt-controller@F9000000 {
+		compatible = "qcom,msm-qgic2";
+		interrupt-controller;
+		#interrupt-cells = <3>;
+		reg = <0xF9000000 0x1000>,
+		      <0xF9002000 0x1000>;
+	};
+
+	msmgpio: gpio@fd510000 {
+		compatible = "qcom,msm-gpio";
+		gpio-controller;
+		#gpio-cells = <2>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		reg = <0xfd510000 0x4000>;
+		ngpio = <146>;
+		interrupts = <0 208 0>;
+		qcom,direct-connect-irqs = <8>;
+	};
+
+	wcd9xxx_intc: wcd9xxx-irq {
+		compatible = "qcom,wcd9xxx-irq";
+		interrupt-controller;
+		#interrupt-cells = <1>;
+		interrupt-parent = <&msmgpio>;
+		interrupts = <72 0>;
+		interrupt-names = "cdc-int";
+	};
+
+	timer {
+		compatible = "arm,armv7-timer";
+		interrupts = <1 2 0 1 3 0>;
+		clock-frequency = <19200000>;
+	};
+
+	timer@f9020000 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		compatible = "arm,armv7-timer-mem";
+		reg = <0xf9020000 0x1000>;
+		clock-frequency = <19200000>;
+
+		frame@f9021000 {
+			frame-number = <0>;
+			interrupts = <0 8 0x4>,
+				     <0 7 0x4>;
+			reg = <0xf9021000 0x1000>,
+			      <0xf9022000 0x1000>;
+		};
+
+		frame@f9023000 {
+			frame-number = <1>;
+			interrupts = <0 9 0x4>;
+			reg = <0xf9023000 0x1000>;
+			status = "disabled";
+		};
+
+		frame@f9024000 {
+			frame-number = <2>;
+			interrupts = <0 10 0x4>;
+			reg = <0xf9024000 0x1000>;
+			status = "disabled";
+		};
+
+		frame@f9025000 {
+			frame-number = <3>;
+			interrupts = <0 11 0x4>;
+			reg = <0xf9025000 0x1000>;
+			status = "disabled";
+		};
+
+		frame@f9026000 {
+			frame-number = <4>;
+			interrupts = <0 12 0x4>;
+			reg = <0xf9026000 0x1000>;
+			status = "disabled";
+		};
+
+		frame@f9027000 {
+			frame-number = <5>;
+			interrupts = <0 13 0x4>;
+			reg = <0xf9027000 0x1000>;
+			status = "disabled";
+		};
+
+		frame@f9028000 {
+			frame-number = <6>;
+			interrupts = <0 14 0x4>;
+			reg = <0xf9028000 0x1000>;
+			status = "disabled";
+		};
+	};
+
+
+	qcom,mpm2-sleep-counter@fc4a3000 {
+		compatible = "qcom,mpm2-sleep-counter";
+		reg = <0xfc4a3000 0x1000>;
+		clock-frequency = <32768>;
+	};
+
+	msm_vidc: qcom,vidc@fdc00000 {
+		compatible = "qcom,msm-vidc";
+		reg = <0xfdc00000 0xff000>;
+		interrupts = <0 44 0>;
+		vdd-supply = <&gdsc_venus>;
+		qcom,hfi = "venus";
+		qcom,has-ocmem;
+		qcom,max-hw-load = <1216800>; /* 3840 x 2160 @ 30 + 1080p @ 30*/
+	};
+
+	qcom,vidc {
+		compatible = "qcom,msm-vidc";
+		qcom,hfi = "q6";
+		qcom,max-hw-load = <243000>; /* 1080p @ 30 */
+	};
+
+	qcom,wfd {
+		compatible = "qcom,msm-wfd";
+	};
+
+	serial@f991f000 {
+		compatible = "qcom,msm-lsuart-v14";
+		reg = <0xf991f000 0x1000>;
+		interrupts = <0 109 0>;
+		status = "disabled";
+	};
+
+	/*
+	serial@f995e000 {
+		compatible = "qcom,msm-lsuart-v14";
+		reg = <0xf995e000 0x1000>;
+		interrupts = <0 114 0>;
+		status = "disabled";
+	};
+    */
+	/*add by yfliu, Enable the serial_uart1 for debug*/
+	blsp1_uart0: serial@f991d000 {
+		compatible = "qcom,msm-lsuart-v14";
+		reg = <0xf991d000 0x1000>;
+		interrupts = <0 107 0>;
+		status = "ok";
+
+		qcom,msm-bus,name = "serial_uart1";
+		qcom,msm-bus,num-cases = <2>;
+		qcom,msm-bus,num-paths = <1>;
+		qcom,msm-bus,vectors-KBps =
+				<86 512 0 0>,
+				<86 512 500 800>;
+	};
+	/*end*/
+	blsp1_uart1: serial@f991e000 {
+		compatible = "qcom,msm-lsuart-v14";
+		reg = <0xf991e000 0x1000>;
+		interrupts = <0 108 0>;
+		status = "disabled";
+
+		qcom,msm-bus,name = "serial_uart2";
+		qcom,msm-bus,num-cases = <2>;
+		qcom,msm-bus,num-paths = <1>;
+		qcom,msm-bus,vectors-KBps =
+				<86 512 0 0>,
+				<86 512 500 800>;
+	};
+
+	usb_otg: usb@f9a55000 {
+		compatible = "qcom,hsusb-otg";
+		status = "disabled";
+
+		reg = <0xf9a55000 0x400>;
+		interrupts = <0 134 0 0 140 0>;
+		interrupt-names = "core_irq", "async_irq";
+		HSUSB_VDDCX-supply = <&pm8841_s2_corner>;
+		HSUSB_1p8-supply = <&pm8941_l6>;
+		HSUSB_3p3-supply = <&pm8941_l24>;
+		qcom,vdd-voltage-level = <1 5 7>;
+
+		qcom,hsusb-otg-phy-type = <2>;
+		qcom,hsusb-otg-phy-init-seq = <0x63 0x81 0xffffffff>;
+		qcom,hsusb-otg-mode = <1>;
+		qcom,hsusb-otg-otg-control = <1>;
+		qcom,hsusb-otg-disable-reset;
+		qcom,hsusb-otg-mpm-dpsehv-int = <49>;
+		qcom,hsusb-otg-mpm-dmsehv-int = <58>;
+
+		qcom,msm-bus,name = "usb2";
+		qcom,msm-bus,num-cases = <2>;
+		qcom,msm-bus,num-paths = <1>;
+		qcom,msm-bus,vectors-KBps =
+				<87 512 0 0>,
+				<87 512 60000 960000>;
+	};
+
+	rmtfs_sharedmem {
+		compatible = "qcom,sharedmem-uio";
+		reg = <0x0fd80000 0x00180000>;
+		reg-names = "rmtfs";
+	};
+
+	dsp_sharedmem {
+		compatible = "qcom,sharedmem-uio";
+		reg = <0x0fd60000 0x00020000>;
+		reg-names = "rfsa_dsp";
+	};
+
+	mdm_sharedmem {
+		compatible = "qcom,sharedmem-uio";
+		reg = <0x0fd60000 0x00020000>;
+		reg-names = "rfsa_mdm";
+	};
+
+	sdcc1: qcom,sdcc@f9824000 {
+		cell-index = <1>; /* SDC1 eMMC slot */
+		compatible = "qcom,msm-sdcc";
+		reg = <0xf9824000 0x800>,
+			<0xf9824800 0x100>,
+			<0xf9804000 0x7000>;
+		reg-names = "core_mem", "dml_mem", "bam_mem";
+		interrupts = <0 123 0>, <0 137 0>;
+		interrupt-names = "core_irq", "bam_irq";
+		vdd-supply = <&pm8941_l20>;
+		vdd-io-supply = <&pm8941_s3>;
+
+		qcom,vdd-always-on;
+		qcom,vdd-lpm-sup;
+		qcom,vdd-voltage-level = <2950000 2950000>;
+		qcom,vdd-current-level = <800 500000>;
+
+		qcom,vdd-io-always-on;
+		qcom,vdd-io-voltage-level = <1800000 1800000>;
+		qcom,vdd-io-current-level = <250 154000>;
+
+		qcom,pad-pull-on = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+		qcom,pad-pull-off = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+		qcom,pad-drv-on = <0x4 0x4 0x4>; /* 10mA, 10mA, 10mA */
+		qcom,pad-drv-off = <0x0 0x0 0x0>; /* 2mA, 2mA, 2mA */
+
+		qcom,clk-rates = <400000 20000000 25000000 50000000 100000000 200000000>;
+		qcom,sup-voltages = <2950 2950>;
+		qcom,bus-width = <8>;
+		qcom,nonremovable;
+		qcom,bus-speed-mode = "HS200_1p8v", "DDR_1p8v";
+
+		qcom,msm-bus,name = "sdcc1";
+		qcom,msm-bus,num-cases = <8>;
+		qcom,msm-bus,num-paths = <1>;
+		qcom,msm-bus,vectors-KBps = <78 512 0 0>, /* No vote */
+				<78 512 1600 3200>,    /* 400 KB/s*/
+				<78 512 80000 160000>, /* 20 MB/s */
+				<78 512 100000 200000>, /* 25 MB/s */
+				<78 512 200000 400000>, /* 50 MB/s */
+				<78 512 400000 800000>, /* 100 MB/s */
+				<78 512 800000 1600000>, /* 200 MB/s */
+				<78 512 2048000 4096000>; /* Max. bandwidth */
+		qcom,bus-bw-vectors-bps = <0 400000 20000000 25000000 50000000 100000000 200000000 4294967295>;
+		qcom,dat1-mpm-int = <42>;
+		status = "disable";
+	};
+
+	sdcc2: qcom,sdcc@f98a4000 {
+		cell-index = <2>; /* SDC2 SD card slot */
+		compatible = "qcom,msm-sdcc";
+		reg = <0xf98a4000 0x800>,
+			<0xf98a4800 0x100>,
+			<0xf9884000 0x7000>;
+		reg-names = "core_mem", "dml_mem", "bam_mem";
+		interrupts = <0 125 0>, <0 220 0>;
+		interrupt-names = "core_irq", "bam_irq";
+		vdd-supply = <&pm8941_l21>;
+		vdd-io-supply = <&pm8941_l13>;
+
+		qcom,vdd-voltage-level = <2950000 2950000>;
+		qcom,vdd-current-level = <9000 800000>;
+
+		qcom,vdd-io-voltage-level = <1800000 2950000>;
+		qcom,vdd-io-current-level = <6 22000>;
+
+		qcom,pad-pull-on = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+		qcom,pad-pull-off = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+		qcom,pad-drv-on = <0x4 0x4 0x4>; /* 10mA, 10mA, 10mA */
+		qcom,pad-drv-off = <0x0 0x0 0x0>; /* 2mA, 2mA, 2mA */
+
+		qcom,clk-rates = <400000 20000000 25000000 50000000 100000000 200000000>;
+		qcom,sup-voltages = <2950 2950>;
+		qcom,bus-width = <4>;
+		qcom,xpc;
+		qcom,bus-speed-mode = "SDR12", "SDR25", "SDR50", "DDR50", "SDR104";
+		qcom,current-limit = <800>;
+
+		qcom,msm-bus,name = "sdcc2";
+		qcom,msm-bus,num-cases = <8>;
+		qcom,msm-bus,num-paths = <1>;
+		qcom,msm-bus,vectors-KBps = <81 512 0 0>, /* No vote */
+				<81 512 1600 3200>,    /* 400 KB/s*/
+				<81 512 80000 160000>, /* 20 MB/s */
+				<81 512 100000 200000>, /* 25 MB/s */
+				<81 512 200000 400000>, /* 50 MB/s */
+				<81 512 400000 800000>, /* 100 MB/s */
+				<81 512 800000 1600000>, /* 200 MB/s */
+				<81 512 2048000 4096000>; /* Max. bandwidth */
+		qcom,bus-bw-vectors-bps = <0 400000 20000000 25000000 50000000 100000000 200000000 4294967295>;
+		qcom,dat1-mpm-int = <44>;
+		status = "disable";
+	};
+
+	sdcc3: qcom,sdcc@f9864000 {
+		cell-index = <3>; /* SDC3 SDIO slot */
+		compatible = "qcom,msm-sdcc";
+		reg = <0xf9864000 0x800>,
+			<0xf9864800 0x100>,
+			<0xf9844000 0x7000>;
+		reg-names = "core_mem", "dml_mem", "bam_mem";
+		#address-cells = <0>;
+		interrupt-parent = <&sdcc3>;
+		interrupts = <0 1 2>;
+		#interrupt-cells = <1>;
+		interrupt-map-mask = <0xffffffff>;
+		interrupt-map = <0 &intc 0 127 0
+				1 &intc 0 223 0
+				2 &msmgpio 37 0x8>;
+		interrupt-names = "core_irq", "bam_irq", "sdiowakeup_irq";
+
+		gpios = <&msmgpio 40 0>, /* CLK */
+			<&msmgpio 39 0>, /* CMD */
+			<&msmgpio 38 0>, /* DATA0 */
+			<&msmgpio 37 0>, /* DATA1 */
+			<&msmgpio 36 0>, /* DATA2 */
+			<&msmgpio 35 0>; /* DATA3 */
+		qcom,gpio-names = "CLK", "CMD", "DAT0", "DAT1", "DAT2", "DAT3";
+
+		qcom,clk-rates = <400000 20000000 25000000 50000000 100000000>;
+		qcom,sup-voltages = <1800 1800>;
+		qcom,bus-width = <4>;
+		qcom,bus-speed-mode = "SDR12", "SDR25", "SDR50", "DDR50";
+
+		qcom,msm-bus,name = "sdcc3";
+		qcom,msm-bus,num-cases = <8>;
+		qcom,msm-bus,num-paths = <1>;
+		qcom,msm-bus,vectors-KBps = <79 512 0 0>, /* No vote */
+				<79 512 1600 3200>,    /* 400 KB/s*/
+				<79 512 80000 160000>, /* 20 MB/s */
+				<79 512 100000 200000>, /* 25 MB/s */
+				<79 512 200000 400000>, /* 50 MB/s */
+				<79 512 400000 800000>, /* 100 MB/s */
+				<79 512 800000 1600000>, /* 200 MB/s */
+				<79 512 2048000 4096000>; /* Max. bandwidth */
+		qcom,bus-bw-vectors-bps = <0 400000 20000000 25000000 50000000 100000000 200000000 4294967295>;
+		status = "disable";
+	};
+
+	sdcc4: qcom,sdcc@f98e4000 {
+		cell-index = <4>; /* SDC4 SDIO slot */
+		compatible = "qcom,msm-sdcc";
+		reg = <0xf98e4000 0x800>,
+			<0xf98e4800 0x100>,
+			<0xf98c4000 0x7000>;
+		reg-names = "core_mem", "dml_mem", "bam_mem";
+		#address-cells = <0>;
+		interrupt-parent = <&sdcc4>;
+		interrupts = <0 1 2>;
+		#interrupt-cells = <1>;
+		interrupt-map-mask = <0xffffffff>;
+		interrupt-map = <0 &intc 0 129 0
+				1 &intc 0 226 0
+				2 &msmgpio 95 0x8>;
+		interrupt-names = "core_irq", "bam_irq", "sdiowakeup_irq";
+
+		gpios = <&msmgpio 93 0>, /* CLK */
+			<&msmgpio 91 0>, /* CMD */
+			<&msmgpio 96 0>, /* DATA0 */
+			<&msmgpio 95 0>, /* DATA1 */
+			<&msmgpio 94 0>, /* DATA2 */
+			<&msmgpio 92 0>; /* DATA3 */
+		qcom,gpio-names = "CLK", "CMD", "DAT0", "DAT1", "DAT2", "DAT3";
+
+		qcom,clk-rates = <400000 20000000 25000000 50000000 100000000>;
+		qcom,sup-voltages = <1800 1800>;
+		qcom,bus-width = <4>;
+		qcom,bus-speed-mode = "SDR12", "SDR25", "SDR50", "DDR50";
+
+		qcom,msm-bus,name = "sdcc4";
+		qcom,msm-bus,num-cases = <8>;
+		qcom,msm-bus,num-paths = <1>;
+		qcom,msm-bus,vectors-KBps = <80 512 0 0>, /* No vote */
+				<80 512 1600 3200>,    /* 400 KB/s*/
+				<80 512 80000 160000>, /* 20 MB/s */
+				<80 512 100000 200000>, /* 25 MB/s */
+				<80 512 200000 400000>, /* 50 MB/s */
+				<80 512 400000 800000>, /* 100 MB/s */
+				<80 512 800000 1600000>, /* 200 MB/s */
+				<80 512 2048000 4096000>; /* Max. bandwidth */
+		qcom,bus-bw-vectors-bps = <0 400000 20000000 25000000 50000000 100000000 200000000 4294967295>;
+		status = "disable";
+	};
+
+	sdhc_1: sdhci@f9824900 {
+		qcom,bus-width = <8>;
+		compatible = "qcom,sdhci-msm";
+		reg = <0xf9824900 0x11c>, <0xf9824000 0x800>;
+		reg-names = "hc_mem", "core_mem";
+		interrupts = <0 123 0>, <0 138 0>;
+		interrupt-names = "hc_irq", "pwr_irq";
+		qcom,clk-rates = <400000 20000000 25000000 50000000 100000000 200000000>;
+		qcom,bus-speed-mode = "HS200_1p8v", "DDR_1p8v";
+		qcom,cpu-dma-latency-us = <200>;
+
+		qcom,msm-bus,name = "sdhc1";
+		qcom,msm-bus,num-cases = <8>;
+		qcom,msm-bus,num-paths = <1>;
+		qcom,msm-bus,vectors-KBps = <78 512 0 0>, /* No vote */
+				<78 512 1600 3200>,    /* 400 KB/s*/
+				<78 512 80000 160000>, /* 20 MB/s */
+				<78 512 100000 200000>, /* 25 MB/s */
+				<78 512 200000 400000>, /* 50 MB/s */
+				<78 512 400000 800000>, /* 100 MB/s */
+				<78 512 800000 1600000>, /* 200 MB/s */
+				<78 512 2048000 4096000>; /* Max. bandwidth */
+		qcom,bus-bw-vectors-bps = <0 400000 20000000 25000000 50000000 100000000 200000000 4294967295>;
+		qcom,dat1-mpm-int = <42>;
+		status = "disable";
+	};
+
+	sdhc_2: sdhci@f98a4900 {
+		compatible = "qcom,sdhci-msm";
+		reg = <0xf98a4900 0x11c>, <0xf98a4000 0x800>;
+		reg-names = "hc_mem", "core_mem";
+		interrupts = <0 125 0>, <0 221 0>;
+		interrupt-names = "hc_irq", "pwr_irq";
+
+		qcom,clk-rates = <400000 20000000 25000000 50000000 100000000 200000000>;
+		qcom,bus-width = <4>;
+		qcom,cpu-dma-latency-us = <200>;
+
+		qcom,msm-bus,name = "sdhc2";
+		qcom,msm-bus,num-cases = <8>;
+		qcom,msm-bus,num-paths = <1>;
+		qcom,msm-bus,vectors-KBps = <81 512 0 0>, /* No vote */
+				<81 512 1600 3200>,    /* 400 KB/s*/
+				<81 512 80000 160000>, /* 20 MB/s */
+				<81 512 100000 200000>, /* 25 MB/s */
+				<81 512 200000 400000>, /* 50 MB/s */
+				<81 512 400000 800000>, /* 100 MB/s */
+				<81 512 800000 1600000>, /* 200 MB/s */
+				<81 512 2048000 4096000>; /* Max. bandwidth */
+		qcom,bus-bw-vectors-bps = <0 400000 20000000 25000000 50000000 100000000 200000000 4294967295>;
+		qcom,dat1-mpm-int = <44>;
+		status = "disable";
+	};
+
+	sdhc_3: sdhci@f9864900 {
+		compatible = "qcom,sdhci-msm";
+		reg = <0xf9864900 0x11c>, <0xf9864000 0x800>;
+		reg-names = "hc_mem", "core_mem";
+
+		#address-cells = <0>;
+		interrupt-parent = <&sdhc_3>;
+		interrupts = <0 1 2>;
+		#interrupt-cells = <1>;
+		interrupt-map-mask = <0xffffffff>;
+		interrupt-map = <0 &intc 0 127 0
+				1 &intc 0 224 0
+				2 &msmgpio 37 0x8>;
+		interrupt-names = "hc_irq", "pwr_irq", "sdiowakeup_irq";
+
+		gpios = <&msmgpio 40 0>, /* CLK */
+			<&msmgpio 39 0>, /* CMD */
+			<&msmgpio 38 0>, /* DATA0 */
+			<&msmgpio 37 0>, /* DATA1 */
+			<&msmgpio 36 0>, /* DATA2 */
+			<&msmgpio 35 0>; /* DATA3 */
+		qcom,gpio-names = "CLK", "CMD", "DAT0", "DAT1", "DAT2", "DAT3";
+
+		qcom,clk-rates = <400000 20000000 25000000 50000000 100000000>;
+		qcom,bus-width = <4>;
+		qcom,cpu-dma-latency-us = <200>;
+
+		qcom,msm-bus,name = "sdhc3";
+		qcom,msm-bus,num-cases = <8>;
+		qcom,msm-bus,num-paths = <1>;
+		qcom,msm-bus,vectors-KBps = <79 512 0 0>, /* No vote */
+				<79 512 1600 3200>,    /* 400 KB/s*/
+				<79 512 80000 160000>, /* 20 MB/s */
+				<79 512 100000 200000>, /* 25 MB/s */
+				<79 512 200000 400000>, /* 50 MB/s */
+				<79 512 400000 800000>, /* 100 MB/s */
+				<79 512 800000 1600000>, /* 200 MB/s */
+				<79 512 2048000 4096000>; /* Max. bandwidth */
+		qcom,bus-bw-vectors-bps = <0 400000 20000000 25000000 50000000 100000000 200000000 4294967295>;
+		status = "disable";
+	};
+
+	sdhc_4: sdhci@f98e4900 {
+		compatible = "qcom,sdhci-msm";
+		reg = <0xf98e4900 0x11c>, <0xf98e4000 0x800>;
+		reg-names = "hc_mem", "core_mem";
+
+		#address-cells = <0>;
+		interrupt-parent = <&sdhc_4>;
+		interrupts = <0 1 2>;
+		#interrupt-cells = <1>;
+		interrupt-map-mask = <0xffffffff>;
+		interrupt-map = <0 &intc 0 129 0
+				1 &intc 0 227 0
+				2 &msmgpio 95 0x8>;
+		interrupt-names = "hc_irq", "pwr_irq", "sdiowakeup_irq";
+
+		gpios = <&msmgpio 93 0>, /* CLK */
+			<&msmgpio 91 0>, /* CMD */
+			<&msmgpio 96 0>, /* DATA0 */
+			<&msmgpio 95 0>, /* DATA1 */
+			<&msmgpio 94 0>, /* DATA2 */
+			<&msmgpio 92 0>; /* DATA3 */
+		qcom,gpio-names = "CLK", "CMD", "DAT0", "DAT1", "DAT2", "DAT3";
+
+		qcom,clk-rates = <400000 20000000 25000000 50000000 100000000>;
+		qcom,bus-width = <4>;
+		qcom,cpu-dma-latency-us = <200>;
+
+		qcom,msm-bus,name = "sdhc4";
+		qcom,msm-bus,num-cases = <8>;
+		qcom,msm-bus,num-paths = <1>;
+		qcom,msm-bus,vectors-KBps = <80 512 0 0>, /* No vote */
+				<80 512 1600 3200>,    /* 400 KB/s*/
+				<80 512 80000 160000>, /* 20 MB/s */
+				<80 512 100000 200000>, /* 25 MB/s */
+				<80 512 200000 400000>, /* 50 MB/s */
+				<80 512 400000 800000>, /* 100 MB/s */
+				<80 512 800000 1600000>, /* 200 MB/s */
+				<80 512 2048000 4096000>; /* Max. bandwidth */
+		qcom,bus-bw-vectors-bps = <0 400000 20000000 25000000 50000000 100000000 200000000 4294967295>;
+		status = "disable";
+	};
+
+	qcom,sps@f9980000 {
+		compatible = "qcom,msm_sps";
+		reg = <0xf9984000 0x15000>,
+		      <0xf9999000 0xb000>;
+		interrupts = <0 94 0>;
+
+		qcom,bam-dma-res-pipes = <6>;
+	};
+
+	spi_7: spi_epm: spi@f9966000 { /* BLSP2 QUP4 */
+		compatible = "qcom,spi-qup-v2";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg-names = "spi_physical", "spi_bam_physical";
+		reg = <0xf9966000 0x1000>,
+		      <0xf9944000 0x19000>;
+		interrupt-names = "spi_irq", "spi_bam_irq";
+		interrupts = <0 104 0>, <0 239 0>;
+		spi-max-frequency = <19200000>;
+
+		qcom,gpio-mosi = <&msmgpio 53 0>;
+		qcom,gpio-miso = <&msmgpio 54 0>;
+		qcom,gpio-clk  = <&msmgpio 56 0>;
+		qcom,gpio-cs0  = <&msmgpio 55 0>;
+
+		qcom,infinite-mode = <0>;
+		qcom,use-bam;
+		qcom,ver-reg-exists;
+		qcom,bam-consumer-pipe-index = <18>;
+		qcom,bam-producer-pipe-index = <19>;
+		qcom,master-id = <84>;
+	};
+
+	tspp: msm_tspp@f99d8000 {
+		compatible = "qcom,msm_tspp";
+		cell-index = <0>;
+		reg = <0xf99d8000 0x1000>, /* MSM_TSIF0_PHYS */
+		      <0xf99d9000 0x1000>, /* MSM_TSIF1_PHYS */
+		      <0xf99da000 0x1000>, /* MSM_TSPP_PHYS  */
+		      <0xf99c4000 0x14000>; /* MSM_TSPP_BAM_PHYS */
+		reg-names = "MSM_TSIF0_PHYS",
+			"MSM_TSIF1_PHYS",
+			"MSM_TSPP_PHYS",
+			"MSM_TSPP_BAM_PHYS";
+		interrupts = <0 121 0>, /* TSIF_TSPP_IRQ */
+			<0 119 0>, /* TSIF0_IRQ */
+			<0 120 0>, /* TSIF1_IRQ */
+			<0 122 0>; /* TSIF_BAM_IRQ */
+		interrupt-names = "TSIF_TSPP_IRQ",
+			"TSIF0_IRQ",
+			"TSIF1_IRQ",
+			"TSIF_BAM_IRQ";
+		qcom,tsif-pclk = "iface_clk";
+		qcom,tsif-ref-clk = "ref_clk";
+		gpios = <&msmgpio 89 0>, /* TSIF0 CLK  */
+			<&msmgpio 90 0>, /* TSIF0 EN   */
+			<&msmgpio 91 0>, /* TSIF0 DATA */
+			<&msmgpio 92 0>, /* TSIF0 SYNC */
+			<&msmgpio 93 0>, /* TSIF1 CLK  */
+			<&msmgpio 94 0>, /* TSIF1 EN   */
+			<&msmgpio 95 0>, /* TSIF1 DATA */
+			<&msmgpio 96 0>; /* TSIF1 SYNC */
+		qcom,gpio-names = "tsif_clk",
+				"tsif_en",
+				"tsif_data",
+				"tsif_sync",
+				"tsif_clk",
+				"tsif_en",
+				"tsif_data",
+				"tsif_sync";
+		qcom,gpios-func = <1>;
+
+		qcom,msm-bus,name = "tsif";
+		qcom,msm-bus,num-cases = <2>;
+		qcom,msm-bus,num-paths = <1>;
+		qcom,msm-bus,vectors-KBps =
+				<82 512 0 0>, /* No vote */
+				<82 512 12288 24576>; /* Max. bandwidth, 2xTSIF, each max of 96Mbps */
+	};
+
+	slim_msm: slim@fe12f000 {
+		cell-index = <1>;
+		compatible = "qcom,slim-ngd";
+		reg = <0xfe12f000 0x35000>,
+		      <0xfe104000 0x20000>;
+		reg-names = "slimbus_physical", "slimbus_bam_physical";
+		interrupts = <0 163 0 0 164 0>;
+		interrupt-names = "slimbus_irq", "slimbus_bam_irq";
+		qcom,apps-ch-pipes = <0x60000000>;
+		qcom,ea-pc = <0x30>;
+
+		taiko_codec {
+			compatible = "qcom,taiko-slim-pgd";
+			elemental-addr = [00 01 A0 00 17 02];
+
+			interrupt-parent = <&wcd9xxx_intc>;
+			interrupts = <0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
+				      17 18 19 20 21 22 23 24 25 26 27 28 29
+				      30>;
+
+			qcom,cdc-reset-gpio = <&msmgpio 63 0>;
+
+			cdc-vdd-buck-supply = <&pm8941_s2>;
+			qcom,cdc-vdd-buck-voltage = <2150000 2150000>;
+			qcom,cdc-vdd-buck-current = <650000>;
+
+			cdc-vdd-tx-h-supply = <&pm8941_s3>;
+			qcom,cdc-vdd-tx-h-voltage = <1800000 1800000>;
+			qcom,cdc-vdd-tx-h-current = <25000>;
+
+			cdc-vdd-rx-h-supply = <&pm8941_s3>;
+			qcom,cdc-vdd-rx-h-voltage = <1800000 1800000>;
+			qcom,cdc-vdd-rx-h-current = <25000>;
+
+			cdc-vddpx-1-supply = <&pm8941_s3>;
+			qcom,cdc-vddpx-1-voltage = <1800000 1800000>;
+			qcom,cdc-vddpx-1-current = <10000>;
+
+			cdc-vdd-a-1p2v-supply = <&pm8941_l1>;
+			qcom,cdc-vdd-a-1p2v-voltage = <1225000 1225000>;
+			qcom,cdc-vdd-a-1p2v-current = <10000>;
+
+			cdc-vddcx-1-supply = <&pm8941_l1>;
+			qcom,cdc-vddcx-1-voltage = <1225000 1225000>;
+			qcom,cdc-vddcx-1-current = <10000>;
+
+			cdc-vddcx-2-supply = <&pm8941_l1>;
+			qcom,cdc-vddcx-2-voltage = <1225000 1225000>;
+			qcom,cdc-vddcx-2-current = <10000>;
+
+			qcom,cdc-static-supplies = "cdc-vdd-buck",
+						   "cdc-vdd-tx-h",
+						   "cdc-vdd-rx-h",
+						   "cdc-vddpx-1",
+						   "cdc-vdd-a-1p2v",
+						   "cdc-vddcx-1",
+						   "cdc-vddcx-2";
+
+			qcom,cdc-micbias-ldoh-v = <0x3>;
+			qcom,cdc-micbias-cfilt1-mv = <1800>;
+			qcom,cdc-micbias-cfilt2-mv = <2700>;
+			qcom,cdc-micbias-cfilt3-mv = <1800>;
+			qcom,cdc-micbias1-cfilt-sel = <0x0>;
+			qcom,cdc-micbias2-cfilt-sel = <0x1>;
+			qcom,cdc-micbias3-cfilt-sel = <0x2>;
+			qcom,cdc-micbias4-cfilt-sel = <0x2>;
+			qcom,cdc-mclk-clk-rate = <9600000>;
+			qcom,cdc-slim-ifd = "taiko-slim-ifd";
+			qcom,cdc-slim-ifd-elemental-addr = [00 00 A0 00 17 02];
+			qcom,cdc-dmic-sample-rate = <2400000>;
+		};
+		es325_codec_gen0{
+			compatible = "adnc,es325-codec-gen0";
+			elemental-addr = [00 01 02 00 BE 02];
+
+			adnc,es325-codec-gen0 = "es325-codec-gen0";
+			adnc,es325-codec-gen0-eaddr = [00 01 02 00 BE 02];
+
+			adnc,reset-gpio  = <&msmgpio 56 0>; /* DEFINED BY CUSTOMER */
+			adnc,wakeup-gpio = <&msmgpio 55 0>; /* DEFINED BY CUSTOMER */
+			adnc,power-gpio  = <&msmgpio 92 0>;
+
+			adnc,es325-mclk-gpios = <&pm8941_gpios 16 0>;	/* DEFINED BY audience */
+			es325-mclk-clk = <&pm8941_clkdiv2>;
+			adnc,es325-mclk-clk-freq = <19200000>;
+
+			es325_vdig-supply = <&pm8941_s3>;
+			adnc,es325-vreg-name = "es325_vdig";
+			adnc,es325-vreg-type = <0>;
+			adnc,es325-vreg-min-voltage = <1800000>;
+			adnc,es325-vreg-max-voltage = <1800000>;
+			adnc,es325-vreg-op-mode = <105000>;
+		};
+		es325_codec_intf{
+			compatible = "adnc,es325-codec-intf";
+			elemental-addr = [00 00 02 00 BE 02];
+
+			adnc,es325-codec-intf = "es325-codec-intf";
+			adnc,es325-codec-intf-eaddr = [00 01 02 00 BE 02];
+
+			adnc,reset-gpio  = <&msmgpio 56 0>; /* DEFINED BY CUSTOMER */
+			adnc,wakeup-gpio = <&msmgpio 55 0>; /* DEFINED BY CUSTOMER */
+			adnc,power-gpio  = <&msmgpio 92 0>;
+
+			adnc,es325-mclk-gpios = <&pm8941_gpios 16 0>;	/* DEFINED BY audience */
+			es325-mclk-clk = <&pm8941_clkdiv2>;
+			adnc,es325-mclk-clk-freq = <19200000>;
+
+			es325_vdig-supply = <&pm8941_s3>;
+			adnc,es325-vreg-name = "es325_vdig";
+			adnc,es325-vreg-type = <0>;
+			adnc,es325-vreg-min-voltage = <1800000>;
+			adnc,es325-vreg-max-voltage = <1800000>;
+			adnc,es325-vreg-op-mode = <105000>;
+		};
+	};
+
+	sound {
+		compatible = "qcom,msm8974-audio-taiko";
+		qcom,model = "msm8974-taiko-snd-card";
+		reg = <0xfe02b000 0x4>,
+		      <0xfe02c000 0x4>,
+		      <0xfe02d000 0x4>,
+		      <0xfe02e000 0x4>;
+		reg-names = "lpaif_pri_mode_muxsel",
+			    "lpaif_sec_mode_muxsel",
+			    "lpaif_tert_mode_muxsel",
+			    "lpaif_quat_mode_muxsel";
+
+		qcom,audio-routing =
+			"RX_BIAS", "MCLK",
+			"LDO_H", "MCLK",
+			"AIF4 MAD", "MCLK",
+			"AMIC1", "MIC BIAS1 Internal1",
+			"MIC BIAS1 Internal1", "Handset Mic",
+			"AMIC2", "MIC BIAS2 External",
+			"MIC BIAS2 External", "Headset Mic",
+			"AMIC3", "MIC BIAS2 External",
+			"MIC BIAS2 External", "ANCRight Headset Mic",
+			"AMIC4", "MIC BIAS2 External",
+			"MIC BIAS2 External", "ANCLeft Headset Mic",
+			"DMIC1", "MIC BIAS1 External",
+			"MIC BIAS1 External", "Digital Mic1",
+			"DMIC2", "MIC BIAS1 External",
+			"MIC BIAS1 External", "Digital Mic2",
+			"DMIC3", "MIC BIAS3 External",
+			"MIC BIAS3 External", "Digital Mic3",
+			"DMIC4", "MIC BIAS3 External",
+			"MIC BIAS3 External", "Digital Mic4",
+			"DMIC5", "MIC BIAS4 External",
+			"MIC BIAS4 External", "Digital Mic5",
+			"DMIC6", "MIC BIAS4 External",
+			"MIC BIAS4 External", "Digital Mic6";
+
+		qcom,cdc-mclk-gpios = <&pm8941_gpios 15 0>;
+		qcom,taiko-mclk-clk-freq = <9600000>;
+		qcom,prim-auxpcm-gpio-clk  = <&msmgpio 65 0>;
+		qcom,prim-auxpcm-gpio-sync = <&msmgpio 66 0>;
+		qcom,prim-auxpcm-gpio-din  = <&msmgpio 67 0>;
+		qcom,prim-auxpcm-gpio-dout = <&msmgpio 68 0>;
+		qcom,prim-auxpcm-gpio-set = "prim-gpio-prim";
+		qcom,sec-auxpcm-gpio-clk  = <&msmgpio 79 0>;
+		qcom,sec-auxpcm-gpio-sync = <&msmgpio 80 0>;
+		qcom,sec-auxpcm-gpio-din  = <&msmgpio 81 0>;
+		qcom,sec-auxpcm-gpio-dout = <&msmgpio 82 0>;
+	};
+
+	spmi_bus: qcom,spmi@fc4c0000 {
+		cell-index = <0>;
+		compatible = "qcom,spmi-pmic-arb";
+		reg-names = "core", "intr", "cnfg";
+		reg = <0xfc4cf000 0x1000>,
+		      <0Xfc4cb000 0x1000>,
+		      <0Xfc4ca000 0x1000>;
+		/* 190,ee0_krait_hlos_spmi_periph_irq */
+		/* 187,channel_0_krait_hlos_trans_done_irq */
+		interrupts = <0 190 0 0 187 0>;
+		qcom,pmic-arb-ee = <0>;
+		qcom,pmic-arb-channel = <0>;
+	};
+
+	i2c_0: i2c@f9967000 { /* BLSP#11 */
+		cell-index = <0>;
+		compatible = "qcom,i2c-qup";
+		reg = <0Xf9967000 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg-names = "qup_phys_addr";
+		interrupts = <0 105 0>;
+		interrupt-names = "qup_err_intr";
+		qcom,i2c-bus-freq = <100000>;
+		qcom,i2c-src-freq = <19200000>;
+		qcom,master-id = <84>;
+	};
+
+	i2c_1: i2c@f9923000 {
+		cell-index = <1>;
+		compatible = "qcom,i2c-qup";
+		reg = <0xf9923000 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg-names = "qup_phys_addr";
+		interrupts = <0 95 0>;
+		interrupt-names = "qup_err_intr";
+		qcom,i2c-bus-freq = <100000>;
+		qcom,i2c-src-freq = <19200000>;
+		qcom,scl-gpio = <&msmgpio 3 0>;
+		qcom,sda-gpio = <&msmgpio 2 0>;
+		qcom,master-id = <86>;
+		status = "disabled";
+	};
+
+	i2c_2: i2c@f9924000 {
+		cell-index = <2>;
+		compatible = "qcom,i2c-qup";
+		reg = <0xf9924000 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg-names = "qup_phys_addr";
+		interrupts = <0 96 0>;
+		interrupt-names = "qup_err_intr";
+		qcom,i2c-bus-freq = <384000>;
+		qcom,i2c-src-freq = <19200000>;
+		qcom,master-id = <86>;
+		qcom,scl-gpio = <&msmgpio 7 0>;
+		qcom,sda-gpio = <&msmgpio 6 0>;
+	};
+
+	spi_0: spi@f9923000 { /* BLSP1 QUP1 */
+		compatible = "qcom,spi-qup-v2";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg-names = "spi_physical", "spi_bam_physical";
+		reg = <0xf9923000 0x1000>,
+		      <0xf9904000 0x19000>;
+		interrupt-names = "spi_irq", "spi_bam_irq";
+		interrupts = <0 95 0>, <0 238 0>;
+		spi-max-frequency = <19200000>;
+
+		qcom,gpio-mosi = <&msmgpio 0 0>;
+		qcom,gpio-miso = <&msmgpio 1 0>;
+		qcom,gpio-clk  = <&msmgpio 3 0>;
+		qcom,gpio-cs0  = <&msmgpio 9 0>;
+
+		qcom,infinite-mode = <0>;
+		qcom,use-bam;
+		qcom,ver-reg-exists;
+		qcom,bam-consumer-pipe-index = <12>;
+		qcom,bam-producer-pipe-index = <13>;
+		qcom,master-id = <86>;
+	};
+
+	qcom,clock-krait@f9016000 {
+		compatible = "qcom,clock-krait-8974";
+		reg = <0xf9016000 0x20>,
+			<0xf908a000 0x20>,
+			<0xf909a000 0x20>,
+			<0xf90aa000 0x20>,
+			<0xf90ba000 0x20>,
+			<0xfc4b80b0 0x08>;
+		reg-names = "hfpll_l2_clk", "hfpll0_clk",
+				"hfpll1_clk", "hfpll2_clk",
+				"hfpll3_clk", "efuse";
+		cpu0-supply = <&krait0_vreg>;
+		cpu1-supply = <&krait1_vreg>;
+		cpu2-supply = <&krait2_vreg>;
+		cpu3-supply = <&krait3_vreg>;
+		l2-dig-supply = <&pm8841_s2_corner_ao>;
+		hfpll-dig-supply = <&pm8841_s2_corner_ao>;
+		hfpll-analog-supply = <&pm8941_l12_ao>;
+		qcom,hfpll-config-val = <0x04D0405D>;
+		qcom,hfpll-user-vco-mask = <0x00100000>;
+		qcom,pvs-config-ver = <1>;
+
+		qcom,l2-fmax =
+			<          0 0			 >,
+			<  576000000 4 /* SVS_SOC */	 >,
+			< 1036800000 5 /* NORMAL */	 >,
+			< 1728000000 7 /* SUPER_TURBO */ >;
+
+		qcom,speed0-pvs0-bin-v0 =
+			<          0       0   0 >,
+			<  300000000  815000  73 >,
+			<  345600000  825000  85 >,
+			<  422400000  835000 104 >,
+			<  499200000  845000 124 >,
+			<  576000000  855000 144 >,
+			<  652800000  865000 165 >,
+			<  729600000  875000 186 >,
+			<  806400000  890000 208 >,
+			<  883200000  900000 229 >,
+			<  960000000  915000 252 >,
+			< 1036800000  925000 275 >,
+			< 1113600000  940000 298 >,
+			< 1190400000  950000 321 >,
+			< 1267200000  965000 346 >,
+			< 1344000000  980000 371 >,
+			< 1420800000  995000 397 >,
+			< 1497600000 1010000 423 >,
+			< 1574400000 1025000 450 >,
+			< 1651200000 1040000 477 >,
+			< 1728000000 1055000 506 >,
+			< 1804800000 1070000 536 >,
+			< 1881600000 1085000 567 >,
+			< 1958400000 1100000 598 >;
+
+		qcom,speed0-pvs1-bin-v0 =
+			<          0       0   0 >,
+			<  300000000  800000  73 >,
+			<  345600000  810000  85 >,
+			<  422400000  820000 104 >,
+			<  499200000  830000 124 >,
+			<  576000000  840000 144 >,
+			<  652800000  850000 165 >,
+			<  729600000  860000 186 >,
+			<  806400000  875000 208 >,
+			<  883200000  885000 229 >,
+			<  960000000  895000 252 >,
+			< 1036800000  910000 275 >,
+			< 1113600000  920000 298 >,
+			< 1190400000  930000 321 >,
+			< 1267200000  945000 346 >,
+			< 1344000000  960000 371 >,
+			< 1420800000  975000 397 >,
+			< 1497600000  990000 423 >,
+			< 1574400000 1005000 450 >,
+			< 1651200000 1020000 477 >,
+			< 1728000000 1030000 506 >,
+			< 1804800000 1045000 536 >,
+			< 1881600000 1060000 567 >,
+			< 1958400000 1075000 598 >;
+
+		qcom,speed0-pvs2-bin-v0 =
+			<          0       0   0 >,
+			<  300000000  785000  73 >,
+			<  345600000  795000  85 >,
+			<  422400000  805000 104 >,
+			<  499200000  815000 124 >,
+			<  576000000  825000 144 >,
+			<  652800000  835000 165 >,
+			<  729600000  845000 186 >,
+			<  806400000  855000 208 >,
+			<  883200000  865000 229 >,
+			<  960000000  875000 252 >,
+			< 1036800000  890000 275 >,
+			< 1113600000  900000 298 >,
+			< 1190400000  910000 321 >,
+			< 1267200000  925000 346 >,
+			< 1344000000  940000 371 >,
+			< 1420800000  955000 397 >,
+			< 1497600000  970000 423 >,
+			< 1574400000  980000 450 >,
+			< 1651200000  995000 477 >,
+			< 1728000000 1005000 506 >,
+			< 1804800000 1020000 536 >,
+			< 1881600000 1035000 567 >,
+			< 1958400000 1050000 598 >;
+
+		qcom,speed0-pvs3-bin-v0 =
+			<          0       0   0 >,
+			<  300000000  775000  73 >,
+			<  345600000  780000  85 >,
+			<  422400000  790000 104 >,
+			<  499200000  800000 124 >,
+			<  576000000  810000 144 >,
+			<  652800000  820000 165 >,
+			<  729600000  830000 186 >,
+			<  806400000  840000 208 >,
+			<  883200000  850000 229 >,
+			<  960000000  860000 252 >,
+			< 1036800000  875000 275 >,
+			< 1113600000  885000 298 >,
+			< 1190400000  895000 321 >,
+			< 1267200000  910000 346 >,
+			< 1344000000  925000 371 >,
+			< 1420800000  935000 397 >,
+			< 1497600000  950000 423 >,
+			< 1574400000  960000 450 >,
+			< 1651200000  970000 477 >,
+			< 1728000000  985000 506 >,
+			< 1804800000  995000 536 >,
+			< 1881600000 1010000 567 >,
+			< 1958400000 1025000 598 >;
+
+		qcom,speed0-pvs4-bin-v0 =
+			<          0       0   0 >,
+			<  300000000  775000  73 >,
+			<  345600000  775000  85 >,
+			<  422400000  780000 104 >,
+			<  499200000  790000 124 >,
+			<  576000000  800000 144 >,
+			<  652800000  810000 165 >,
+			<  729600000  820000 186 >,
+			<  806400000  830000 208 >,
+			<  883200000  840000 229 >,
+			<  960000000  850000 252 >,
+			< 1036800000  860000 275 >,
+			< 1113600000  870000 298 >,
+			< 1190400000  880000 321 >,
+			< 1267200000  895000 346 >,
+			< 1344000000  910000 371 >,
+			< 1420800000  920000 397 >,
+			< 1497600000  930000 423 >,
+			< 1574400000  940000 450 >,
+			< 1651200000  950000 477 >,
+			< 1728000000  960000 506 >,
+			< 1804800000  975000 536 >,
+			< 1881600000  985000 567 >,
+			< 1958400000 1000000 598 >;
+
+		qcom,speed0-pvs5-bin-v0 =
+			<          0       0   0 >,
+			<  300000000  750000  73 >,
+			<  345600000  760000  85 >,
+			<  422400000  770000 104 >,
+			<  499200000  780000 124 >,
+			<  576000000  790000 144 >,
+			<  652800000  800000 165 >,
+			<  729600000  810000 186 >,
+			<  806400000  820000 208 >,
+			<  883200000  830000 229 >,
+			<  960000000  840000 252 >,
+			< 1036800000  850000 275 >,
+			< 1113600000  860000 298 >,
+			< 1190400000  870000 321 >,
+			< 1267200000  880000 346 >,
+			< 1344000000  890000 371 >,
+			< 1420800000  900000 397 >,
+			< 1497600000  910000 423 >,
+			< 1574400000  920000 450 >,
+			< 1651200000  930000 477 >,
+			< 1728000000  940000 506 >,
+			< 1804800000  955000 536 >,
+			< 1881600000  965000 567 >,
+			< 1958400000  975000 598 >;
+
+		qcom,speed0-pvs6-bin-v0 =
+			<          0       0   0 >,
+			<  300000000  750000  73 >,
+			<  345600000  750000  85 >,
+			<  422400000  760000 104 >,
+			<  499200000  770000 124 >,
+			<  576000000  780000 144 >,
+			<  652800000  790000 165 >,
+			<  729600000  800000 186 >,
+			<  806400000  810000 208 >,
+			<  883200000  820000 229 >,
+			<  960000000  830000 252 >,
+			< 1036800000  840000 275 >,
+			< 1113600000  850000 298 >,
+			< 1190400000  860000 321 >,
+			< 1267200000  870000 346 >,
+			< 1344000000  875000 371 >,
+			< 1420800000  885000 397 >,
+			< 1497600000  895000 423 >,
+			< 1574400000  905000 450 >,
+			< 1651200000  915000 477 >,
+			< 1728000000  920000 506 >,
+			< 1804800000  930000 536 >,
+			< 1881600000  940000 567 >,
+			< 1958400000  950000 598 >;
+
+		qcom,speed2-pvs0-bin-v0 =
+			<          0       0   0 >,
+			<  300000000  800000  72 >,
+			<  345600000  800000  83 >,
+			<  422400000  805000 102 >,
+			<  499200000  815000 121 >,
+			<  576000000  825000 141 >,
+			<  652800000  835000 161 >,
+			<  729600000  845000 181 >,
+			<  806400000  855000 202 >,
+			<  883200000  865000 223 >,
+			<  960000000  875000 245 >,
+			< 1036800000  890000 267 >,
+			< 1113600000  900000 289 >,
+			< 1190400000  915000 313 >,
+			< 1267200000  925000 336 >,
+			< 1344000000  940000 360 >,
+			< 1420800000  950000 383 >,
+			< 1497600000  965000 409 >,
+			< 1574400000  980000 435 >,
+			< 1651200000  995000 461 >,
+			< 1728000000 1010000 488 >,
+			< 1804800000 1025000 516 >,
+			< 1881600000 1040000 543 >,
+			< 1958400000 1055000 573 >,
+			< 2035200000 1070000 604 >,
+			< 2112000000 1085000 636 >,
+			< 2150400000 1100000 656 >;
+
+		qcom,speed2-pvs1-bin-v0 =
+			<          0       0   0 >,
+			<  300000000  800000  72 >,
+			<  345600000  800000  83 >,
+			<  422400000  800000 102 >,
+			<  499200000  800000 121 >,
+			<  576000000  810000 141 >,
+			<  652800000  820000 161 >,
+			<  729600000  830000 181 >,
+			<  806400000  840000 202 >,
+			<  883200000  850000 223 >,
+			<  960000000  860000 245 >,
+			< 1036800000  875000 267 >,
+			< 1113600000  885000 289 >,
+			< 1190400000  895000 313 >,
+			< 1267200000  910000 336 >,
+			< 1344000000  920000 360 >,
+			< 1420800000  930000 383 >,
+			< 1497600000  945000 409 >,
+			< 1574400000  960000 435 >,
+			< 1651200000  975000 461 >,
+			< 1728000000  990000 488 >,
+			< 1804800000 1005000 516 >,
+			< 1881600000 1020000 543 >,
+			< 1958400000 1030000 573 >,
+			< 2035200000 1045000 604 >,
+			< 2112000000 1060000 636 >,
+			< 2150400000 1075000 656 >;
+
+		qcom,speed2-pvs2-bin-v0 =
+			<          0       0   0 >,
+			<  300000000  775000  72 >,
+			<  345600000  775000  83 >,
+			<  422400000  775000 102 >,
+			<  499200000  785000 121 >,
+			<  576000000  795000 141 >,
+			<  652800000  805000 161 >,
+			<  729600000  815000 181 >,
+			<  806400000  825000 202 >,
+			<  883200000  835000 223 >,
+			<  960000000  845000 245 >,
+			< 1036800000  855000 267 >,
+			< 1113600000  865000 289 >,
+			< 1190400000  875000 313 >,
+			< 1267200000  890000 336 >,
+			< 1344000000  900000 360 >,
+			< 1420800000  910000 383 >,
+			< 1497600000  925000 409 >,
+			< 1574400000  940000 435 >,
+			< 1651200000  955000 461 >,
+			< 1728000000  970000 488 >,
+			< 1804800000  980000 516 >,
+			< 1881600000  995000 543 >,
+			< 1958400000 1005000 573 >,
+			< 2035200000 1020000 604 >,
+			< 2112000000 1035000 636 >,
+			< 2150400000 1050000 656 >;
+
+		qcom,speed2-pvs3-bin-v0 =
+			<          0       0   0 >,
+			<  300000000  775000  72 >,
+			<  345600000  775000  83 >,
+			<  422400000  775000 102 >,
+			<  499200000  775000 121 >,
+			<  576000000  780000 141 >,
+			<  652800000  790000 161 >,
+			<  729600000  800000 181 >,
+			<  806400000  810000 202 >,
+			<  883200000  820000 223 >,
+			<  960000000  830000 245 >,
+			< 1036800000  840000 267 >,
+			< 1113600000  850000 289 >,
+			< 1190400000  860000 313 >,
+			< 1267200000  875000 336 >,
+			< 1344000000  885000 360 >,
+			< 1420800000  895000 383 >,
+			< 1497600000  910000 409 >,
+			< 1574400000  925000 435 >,
+			< 1651200000  935000 461 >,
+			< 1728000000  950000 488 >,
+			< 1804800000  960000 516 >,
+			< 1881600000  970000 543 >,
+			< 1958400000  985000 573 >,
+			< 2035200000  995000 604 >,
+			< 2112000000 1010000 636 >,
+			< 2150400000 1025000 656 >;
+
+		qcom,speed2-pvs4-bin-v0 =
+			<          0       0   0 >,
+			<  300000000  775000  72 >,
+			<  345600000  775000  83 >,
+			<  422400000  775000 102 >,
+			<  499200000  775000 121 >,
+			<  576000000  775000 141 >,
+			<  652800000  780000 161 >,
+			<  729600000  790000 181 >,
+			<  806400000  800000 202 >,
+			<  883200000  810000 223 >,
+			<  960000000  820000 245 >,
+			< 1036800000  830000 267 >,
+			< 1113600000  840000 289 >,
+			< 1190400000  850000 313 >,
+			< 1267200000  860000 336 >,
+			< 1344000000  870000 360 >,
+			< 1420800000  880000 383 >,
+			< 1497600000  895000 409 >,
+			< 1574400000  910000 435 >,
+			< 1651200000  920000 461 >,
+			< 1728000000  930000 488 >,
+			< 1804800000  940000 516 >,
+			< 1881600000  950000 543 >,
+			< 1958400000  960000 573 >,
+			< 2035200000  975000 604 >,
+			< 2112000000  985000 636 >,
+			< 2150400000 1000000 656 >;
+
+		qcom,speed2-pvs5-bin-v0 =
+			<          0       0   0 >,
+			<  300000000  750000  72 >,
+			<  345600000  750000  83 >,
+			<  422400000  750000 102 >,
+			<  499200000  750000 121 >,
+			<  576000000  760000 141 >,
+			<  652800000  770000 161 >,
+			<  729600000  780000 181 >,
+			<  806400000  790000 202 >,
+			<  883200000  800000 223 >,
+			<  960000000  810000 245 >,
+			< 1036800000  820000 267 >,
+			< 1113600000  830000 289 >,
+			< 1190400000  840000 313 >,
+			< 1267200000  850000 336 >,
+			< 1344000000  860000 360 >,
+			< 1420800000  870000 383 >,
+			< 1497600000  880000 409 >,
+			< 1574400000  890000 435 >,
+			< 1651200000  900000 461 >,
+			< 1728000000  910000 488 >,
+			< 1804800000  920000 516 >,
+			< 1881600000  930000 543 >,
+			< 1958400000  940000 573 >,
+			< 2035200000  955000 604 >,
+			< 2112000000  965000 636 >,
+			< 2150400000  975000 656 >;
+
+		qcom,speed2-pvs6-bin-v0 =
+			<          0       0   0 >,
+			<  300000000  750000  72 >,
+			<  345600000  750000  83 >,
+			<  422400000  750000 102 >,
+			<  499200000  750000 121 >,
+			<  576000000  750000 141 >,
+			<  652800000  760000 161 >,
+			<  729600000  770000 181 >,
+			<  806400000  780000 202 >,
+			<  883200000  790000 223 >,
+			<  960000000  800000 245 >,
+			< 1036800000  810000 267 >,
+			< 1113600000  820000 289 >,
+			< 1190400000  830000 313 >,
+			< 1267200000  840000 336 >,
+			< 1344000000  850000 360 >,
+			< 1420800000  860000 383 >,
+			< 1497600000  870000 409 >,
+			< 1574400000  875000 435 >,
+			< 1651200000  885000 461 >,
+			< 1728000000  895000 488 >,
+			< 1804800000  905000 516 >,
+			< 1881600000  915000 543 >,
+			< 1958400000  920000 573 >,
+			< 2035200000  930000 604 >,
+			< 2112000000  940000 636 >,
+			< 2150400000  950000 656 >;
+
+		qcom,speed1-pvs0-bin-v0 =
+			<          0       0   0 >,
+			<  300000000  775000  72 >,
+			<  345600000  775000  83 >,
+			<  422400000  775000 101 >,
+			<  499200000  780000 120 >,
+			<  576000000  790000 139 >,
+			<  652800000  800000 159 >,
+			<  729600000  810000 180 >,
+			<  806400000  820000 200 >,
+			<  883200000  830000 221 >,
+			<  960000000  840000 242 >,
+			< 1036800000  850000 264 >,
+			< 1113600000  865000 287 >,
+			< 1190400000  875000 308 >,
+			< 1267200000  890000 333 >,
+			< 1344000000  900000 356 >,
+			< 1420800000  915000 380 >,
+			< 1497600000  925000 404 >,
+			< 1574400000  940000 430 >,
+			< 1651200000  955000 456 >,
+			< 1728000000  970000 482 >,
+			< 1804800000  985000 510 >,
+			< 1881600000 1000000 538 >,
+			< 1958400000 1015000 565 >,
+			< 2035200000 1030000 596 >,
+			< 2112000000 1045000 627 >,
+			< 2188800000 1060000 659 >,
+			< 2265600000 1075000 691 >;
+
+		qcom,speed1-pvs1-bin-v0 =
+			<          0       0   0 >,
+			<  300000000  775000  72 >,
+			<  345600000  775000  83 >,
+			<  422400000  775000 101 >,
+			<  499200000  775000 120 >,
+			<  576000000  775000 139 >,
+			<  652800000  785000 159 >,
+			<  729600000  795000 180 >,
+			<  806400000  805000 200 >,
+			<  883200000  815000 221 >,
+			<  960000000  825000 242 >,
+			< 1036800000  835000 264 >,
+			< 1113600000  850000 287 >,
+			< 1190400000  860000 308 >,
+			< 1267200000  870000 333 >,
+			< 1344000000  885000 356 >,
+			< 1420800000  895000 380 >,
+			< 1497600000  905000 404 >,
+			< 1574400000  920000 430 >,
+			< 1651200000  935000 456 >,
+			< 1728000000  950000 482 >,
+			< 1804800000  965000 510 >,
+			< 1881600000  980000 538 >,
+			< 1958400000  995000 565 >,
+			< 2035200000 1005000 596 >,
+			< 2112000000 1020000 627 >,
+			< 2188800000 1035000 659 >,
+			< 2265600000 1050000 691 >;
+
+		qcom,speed1-pvs2-bin-v0 =
+			<          0       0   0 >,
+			<  300000000  750000  72 >,
+			<  345600000  750000  83 >,
+			<  422400000  750000 101 >,
+			<  499200000  750000 120 >,
+			<  576000000  760000 139 >,
+			<  652800000  770000 159 >,
+			<  729600000  780000 180 >,
+			<  806400000  790000 200 >,
+			<  883200000  800000 221 >,
+			<  960000000  810000 242 >,
+			< 1036800000  820000 264 >,
+			< 1113600000  830000 287 >,
+			< 1190400000  840000 308 >,
+			< 1267200000  850000 333 >,
+			< 1344000000  865000 356 >,
+			< 1420800000  875000 380 >,
+			< 1497600000  885000 404 >,
+			< 1574400000  900000 430 >,
+			< 1651200000  915000 456 >,
+			< 1728000000  930000 482 >,
+			< 1804800000  945000 510 >,
+			< 1881600000  955000 538 >,
+			< 1958400000  970000 565 >,
+			< 2035200000  980000 596 >,
+			< 2112000000  995000 627 >,
+			< 2188800000 1010000 659 >,
+			< 2265600000 1025000 691 >;
+
+		qcom,speed1-pvs3-bin-v0 =
+			<          0       0   0 >,
+			<  300000000  750000  72 >,
+			<  345600000  750000  83 >,
+			<  422400000  750000 101 >,
+			<  499200000  750000 120 >,
+			<  576000000  750000 139 >,
+			<  652800000  755000 159 >,
+			<  729600000  765000 180 >,
+			<  806400000  775000 200 >,
+			<  883200000  785000 221 >,
+			<  960000000  795000 242 >,
+			< 1036800000  805000 264 >,
+			< 1113600000  815000 287 >,
+			< 1190400000  825000 308 >,
+			< 1267200000  835000 333 >,
+			< 1344000000  850000 356 >,
+			< 1420800000  860000 380 >,
+			< 1497600000  870000 404 >,
+			< 1574400000  885000 430 >,
+			< 1651200000  900000 456 >,
+			< 1728000000  910000 482 >,
+			< 1804800000  925000 510 >,
+			< 1881600000  935000 538 >,
+			< 1958400000  945000 565 >,
+			< 2035200000  960000 596 >,
+			< 2112000000  970000 627 >,
+			< 2188800000  985000 659 >,
+			< 2265600000 1000000 691 >;
+
+		qcom,speed1-pvs4-bin-v0 =
+			<          0       0   0 >,
+			<  300000000  750000  72 >,
+			<  345600000  750000  83 >,
+			<  422400000  750000 101 >,
+			<  499200000  750000 120 >,
+			<  576000000  750000 139 >,
+			<  652800000  750000 159 >,
+			<  729600000  755000 180 >,
+			<  806400000  765000 200 >,
+			<  883200000  775000 221 >,
+			<  960000000  785000 242 >,
+			< 1036800000  795000 264 >,
+			< 1113600000  805000 287 >,
+			< 1190400000  815000 308 >,
+			< 1267200000  825000 333 >,
+			< 1344000000  835000 356 >,
+			< 1420800000  845000 380 >,
+			< 1497600000  855000 404 >,
+			< 1574400000  870000 430 >,
+			< 1651200000  885000 456 >,
+			< 1728000000  895000 482 >,
+			< 1804800000  905000 510 >,
+			< 1881600000  915000 538 >,
+			< 1958400000  925000 565 >,
+			< 2035200000  935000 596 >,
+			< 2112000000  950000 627 >,
+			< 2188800000  960000 659 >,
+			< 2265600000  975000 691 >;
+
+		qcom,speed1-pvs5-bin-v0 =
+			<          0       0   0 >,
+			<  300000000  725000  72 >,
+			<  345600000  725000  83 >,
+			<  422400000  725000 101 >,
+			<  499200000  725000 120 >,
+			<  576000000  725000 139 >,
+			<  652800000  735000 159 >,
+			<  729600000  745000 180 >,
+			<  806400000  755000 200 >,
+			<  883200000  765000 221 >,
+			<  960000000  775000 242 >,
+			< 1036800000  785000 264 >,
+			< 1113600000  795000 287 >,
+			< 1190400000  805000 308 >,
+			< 1267200000  815000 333 >,
+			< 1344000000  825000 356 >,
+			< 1420800000  835000 380 >,
+			< 1497600000  845000 404 >,
+			< 1574400000  855000 430 >,
+			< 1651200000  865000 456 >,
+			< 1728000000  875000 482 >,
+			< 1804800000  885000 510 >,
+			< 1881600000  895000 538 >,
+			< 1958400000  905000 565 >,
+			< 2035200000  915000 596 >,
+			< 2112000000  930000 627 >,
+			< 2188800000  940000 659 >,
+			< 2265600000  950000 691 >;
+
+		qcom,speed1-pvs6-bin-v0 =
+			<          0       0   0 >,
+			<  300000000  725000  72 >,
+			<  345600000  725000  83 >,
+			<  422400000  725000 101 >,
+			<  499200000  725000 120 >,
+			<  576000000  725000 139 >,
+			<  652800000  725000 159 >,
+			<  729600000  735000 180 >,
+			<  806400000  745000 200 >,
+			<  883200000  755000 221 >,
+			<  960000000  765000 242 >,
+			< 1036800000  775000 264 >,
+			< 1113600000  785000 287 >,
+			< 1190400000  795000 308 >,
+			< 1267200000  805000 333 >,
+			< 1344000000  815000 356 >,
+			< 1420800000  825000 380 >,
+			< 1497600000  835000 404 >,
+			< 1574400000  845000 430 >,
+			< 1651200000  850000 456 >,
+			< 1728000000  860000 482 >,
+			< 1804800000  870000 510 >,
+			< 1881600000  880000 538 >,
+			< 1958400000  890000 565 >,
+			< 2035200000  895000 596 >,
+			< 2112000000  905000 627 >,
+			< 2188800000  915000 659 >,
+			< 2265600000  925000 691 >;
+	};
+
+	qcom,cpubw {
+		compatible = "qcom,cpubw";
+		qcom,cpu-mem-ports = <1 512>, <2 512>;
+		qcom,bw-tbl =
+			<  381 /*  50 MHz */ >,
+			<  572 /*  75 MHz */ >,
+			<  762 /* 100 MHz */ >,
+			< 1144 /* 150 MHz */ >,
+			< 1525 /* 200 MHz */ >,
+			< 2342 /* 307 MHz */ >,
+			< 3509 /* 460 MHz */ >,
+			< 4684 /* 614 MHz */ >,
+			< 6103 /* 800 MHz */ >,
+			< 7102 /* 931 MHz */ >;
+	};
+
+	qcom,kraitbw-l2pm {
+		compatible = "qcom,kraitbw-l2pm";
+		interrupts = <0 1 1>;
+		qcom,bytes-per-beat = <8>;
+	};
+
+	qcom,msm-cpufreq@0 {
+		reg = <0 4>;
+		compatible = "qcom,msm-cpufreq";
+		qcom,cpufreq-table =
+			<  300000  300000  572 >,
+			<  422400  422400 1144 >,
+			<  652800  499200 1525 >,
+			<  729600  576000 2342 >,
+			<  883200  576000 2342 >,
+			<  960000  960000 3509 >,
+			< 1036800 1036800 3509 >,
+			< 1190400 1036800 3509 >,
+			< 1267200 1267200 4684 >,
+			< 1497600 1497600 4684 >,
+			< 1574400 1574400 6103 >,
+			< 1728000 1651200 6103 >,
+			< 1958400 1728000 7102 >,
+			< 2265600 1728000 7102 >,
+			< 2457600 1728000 7102 >;
+	};
+
+	usb3: qcom,ssusb@f9200000 {
+		compatible = "qcom,dwc-usb3-msm";
+		reg = <0xf9200000 0xfc000>,
+			  <0xfd4ab000 0x4>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		interrupt-parent = <&usb3>;
+		interrupts = <0 1>;
+		#interrupt-cells = <1>;
+		interrupt-map-mask = <0x0 0xffffffff>;
+		interrupt-map = <0x0 0 &intc 0 133 0
+				 0x0 1 &spmi_bus 0x0 0x0 0x9 0x0>;
+		interrupt-names = "hs_phy_irq", "pmic_id_irq";
+
+		ssusb_vdd_dig-supply = <&pm8841_s2_corner>;
+		SSUSB_1p8-supply = <&pm8941_l6>;
+		hsusb_vdd_dig-supply = <&pm8841_s2_corner>;
+		HSUSB_1p8-supply = <&pm8941_l6>;
+		HSUSB_3p3-supply = <&pm8941_l24>;
+		vbus_dwc3-supply = <&pm8941_mvs1>;
+		qcom,dwc-usb3-msm-dbm-eps = <4>;
+		qcom,vdd-voltage-level = <1 5 7>;
+		qcom,dwc-hsphy-init = <0x00D191A4>;
+		qcom,misc-ref = <&pm8941_misc>;
+		dwc_usb3-adc_tm = <&pm8941_adc_tm>;
+		qcom,dwc-usb3-msm-tx-fifo-size = <29696>;
+		qcom,dwc-usb3-msm-qdss-tx-fifo-size = <8192>;
+
+		qcom,msm-bus,name = "usb3";
+		qcom,msm-bus,num-cases = <2>;
+		qcom,msm-bus,num-paths = <1>;
+		qcom,msm-bus,vectors-KBps =
+				<61 512 0 0>,
+				<61 512 240000 960000>;
+		dwc3@f9200000 {
+			compatible = "synopsys,dwc3";
+			reg = <0xf9200000 0xfc000>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 131 0>, <0 179 0>;
+			interrupt-names = "irq", "otg_irq";
+			tx-fifo-resize;
+		};
+	};
+
+	ehci: qcom,ehci-host@f9a55000 {
+		compatible = "qcom,ehci-host";
+		status = "disabled";
+		reg = <0xf9a55000 0x400>;
+		interrupts = <0 134 0>, <0 140 0>;
+		interrupt-names = "core_irq", "async_irq";
+		HSUSB_VDDCX-supply = <&pm8841_s2>;
+		HSUSB_1p8-supply = <&pm8941_l6>;
+		HSUSB_3p3-supply = <&pm8941_l24>;
+		qcom,usb2-enable-hsphy2;
+		qcom,usb2-power-budget = <500>;
+	};
+
+	gdsc_oxili_gx: qcom,gdsc@fd8c4024 {
+		parent-supply = <&pm8841_s4_corner>;
+	};
+
+	qcom,lpass@fe200000 {
+		compatible = "qcom,pil-q6v5-lpass";
+		reg = <0xfe200000 0x00100>,
+		      <0xfd485100 0x00010>,
+		      <0xfc4016c0 0x00004>;
+		reg-names = "qdsp6_base", "halt_base", "restart_reg";
+		vdd_cx-supply = <&pm8841_s2_corner>;
+		interrupts = <0 162 1>;
+
+		qcom,firmware-name = "adsp";
+
+		/* GPIO inputs from lpass */
+		qcom,gpio-err-fatal = <&smp2pgpio_ssr_smp2p_2_in 0 0>;
+		qcom,gpio-proxy-unvote = <&smp2pgpio_ssr_smp2p_2_in 2 0>;
+		qcom,gpio-err-ready = <&smp2pgpio_ssr_smp2p_2_in 1 0>;
+
+		/* GPIO output to lpass */
+		qcom,gpio-force-stop = <&smp2pgpio_ssr_smp2p_2_out 0 0>;
+	};
+
+	qcom,msm-adsp-loader {
+		compatible = "qcom,adsp-loader";
+		qcom,adsp-state = <0>;
+	};
+
+	qcom,msm-audio-ion {
+		compatible = "qcom,msm-audio-ion";
+	};
+
+	qcom,msm-pcm {
+		compatible = "qcom,msm-pcm-dsp";
+		qcom,msm-pcm-dsp-id = <0>;
+	};
+
+	qcom,msm-pcm-low-latency {
+		compatible = "qcom,msm-pcm-dsp";
+		qcom,msm-pcm-dsp-id = <1>;
+		qcom,msm-pcm-low-latency;
+		qcom,latency-level = "regular";
+	};
+
+	qcom,msm-pcm-routing {
+		compatible = "qcom,msm-pcm-routing";
+	};
+
+	qcom,msm-pcm-lpa {
+		compatible = "qcom,msm-pcm-lpa";
+	};
+
+	qcom,msm-compr-dsp {
+		compatible = "qcom,msm-compr-dsp";
+	};
+
+	qcom,msm-compress-dsp {
+		compatible = "qcom,msm-compress-dsp";
+	};
+
+	qcom,msm-voip-dsp {
+		compatible = "qcom,msm-voip-dsp";
+	};
+
+	qcom,msm-pcm-voice {
+		compatible = "qcom,msm-pcm-voice";
+	};
+
+	qcom,msm-stub-codec {
+		compatible = "qcom,msm-stub-codec";
+	};
+
+	qcom,msm-dai-fe {
+		compatible = "qcom,msm-dai-fe";
+	};
+
+	qcom,msm-pcm-afe {
+		compatible = "qcom,msm-pcm-afe";
+	};
+
+	qcom,msm-dai-q6-hdmi {
+		compatible = "qcom,msm-dai-q6-hdmi";
+		qcom,msm-dai-q6-dev-id = <8>;
+	};
+
+	qcom,msm-lsm-client {
+		compatible = "qcom,msm-lsm-client";
+	};
+
+	qcom,msm-pcm-loopback {
+		compatible = "qcom,msm-pcm-loopback";
+	};
+
+	qcom,msm-dai-q6 {
+		compatible = "qcom,msm-dai-q6";
+		qcom,msm-dai-q6-sb-0-rx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <16384>;
+		};
+
+		qcom,msm-dai-q6-sb-0-tx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <16385>;
+		};
+
+		qcom,msm-dai-q6-sb-1-rx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <16386>;
+		};
+
+		qcom,msm-dai-q6-sb-1-tx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <16387>;
+		};
+
+		qcom,msm-dai-q6-sb-2-rx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <16388>;
+		};
+
+		qcom,msm-dai-q6-sb-2-tx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <16389>;
+		};
+
+		qcom,msm-dai-q6-sb-3-rx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <16390>;
+		};
+
+		qcom,msm-dai-q6-sb-3-tx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <16391>;
+		};
+
+		qcom,msm-dai-q6-sb-4-rx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <16392>;
+		};
+
+		qcom,msm-dai-q6-sb-4-tx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <16393>;
+		};
+
+		qcom,msm-dai-q6-sb-5-tx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <16395>;
+		};
+
+		qcom,msm-dai-q6-bt-sco-rx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <12288>;
+		};
+
+		qcom,msm-dai-q6-bt-sco-tx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <12289>;
+		};
+
+		qcom,msm-dai-q6-int-fm-rx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <12292>;
+		};
+
+		qcom,msm-dai-q6-int-fm-tx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <12293>;
+		};
+
+		qcom,msm-dai-q6-be-afe-pcm-rx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <224>;
+		};
+
+		qcom,msm-dai-q6-be-afe-pcm-tx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <225>;
+		};
+
+		qcom,msm-dai-q6-afe-proxy-rx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <241>;
+		};
+
+		qcom,msm-dai-q6-afe-proxy-tx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <240>;
+		};
+
+		qcom,msm-dai-q6-incall-record-rx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <32771>;
+		};
+
+		qcom,msm-dai-q6-incall-record-tx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <32772>;
+		};
+
+		qcom,msm-dai-q6-incall-music-rx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <32773>;
+		};
+
+		qcom,msm-dai-q6-incall-music-2-rx {
+			compatible = "qcom,msm-dai-q6-dev";
+			qcom,msm-dai-q6-dev-id = <32770>;
+		};
+	};
+
+	qcom,msm-pri-auxpcm {
+		compatible = "qcom,msm-auxpcm-dev";
+		qcom,msm-cpudai-auxpcm-mode = <0>, <0>;
+		qcom,msm-cpudai-auxpcm-sync = <1>, <1>;
+		qcom,msm-cpudai-auxpcm-frame = <5>, <4>;
+		qcom,msm-cpudai-auxpcm-quant = <2>, <2>;
+		qcom,msm-cpudai-auxpcm-slot = <1>, <1>;
+		qcom,msm-cpudai-auxpcm-data = <0>, <0>;
+		qcom,msm-cpudai-auxpcm-pcm-clk-rate = <2048000>, <2048000>;
+		qcom,msm-auxpcm-interface = "primary";
+	};
+
+	qcom,msm-sec-auxpcm {
+		compatible = "qcom,msm-auxpcm-dev";
+		qcom,msm-cpudai-auxpcm-mode = <0>, <0>;
+		qcom,msm-cpudai-auxpcm-sync = <1>, <1>;
+		qcom,msm-cpudai-auxpcm-frame = <5>, <4>;
+		qcom,msm-cpudai-auxpcm-quant = <2>, <2>;
+		qcom,msm-cpudai-auxpcm-slot = <1>, <1>;
+		qcom,msm-cpudai-auxpcm-data = <0>, <0>;
+		qcom,msm-cpudai-auxpcm-pcm-clk-rate = <2048000>, <2048000>;
+		qcom,msm-auxpcm-interface = "secondary";
+	};
+
+	qcom,msm-dai-mi2s {
+		compatible = "qcom,msm-dai-mi2s";
+		qcom,msm-dai-q6-mi2s-quat {
+			compatible = "qcom,msm-dai-q6-mi2s";
+			qcom,msm-dai-q6-mi2s-dev-id = <3>;
+			qcom,msm-mi2s-rx-lines = <1>;
+			qcom,msm-mi2s-tx-lines = <2>;
+		};
+	};
+
+	qcom,msm-pcm-hostless {
+		compatible = "qcom,msm-pcm-hostless";
+	};
+
+	qcom,msm-ocmem-audio {
+		compatible = "qcom,msm-ocmem-audio";
+		qcom,msm-bus,name = "audio-ocmem";
+		qcom,msm-bus,num-cases = <2>;
+		qcom,msm-bus,num-paths = <1>;
+		qcom,msm-bus,vectors-KBps =
+			<11 604 0 0>,
+			<11 604 32506 32506>;
+	};
+
+	qcom,msm-adsp-sensors {
+		compatible = "qcom,msm-adsp-sensors";
+		qcom,src-id = <11>;
+		qcom,dst-id = <604>;
+		qcom,ab = <32505856>;
+		qcom,ib = <32505856>;
+	};
+
+	qcom,mss@fc880000 {
+		compatible = "qcom,pil-q6v5-mss";
+		reg = <0xfc880000 0x100>,
+		      <0xfd485000 0x400>,
+		      <0xfc820000 0x020>,
+		      <0xfc401680 0x004>;
+		reg-names = "qdsp6_base", "halt_base", "rmb_base",
+			    "restart_reg";
+
+		interrupts = <0 24 1>;
+		vdd_mss-supply = <&pm8841_s3>;
+		vdd_cx-supply = <&pm8841_s2_corner>;
+		vdd_mx-supply = <&pm8841_s1>;
+		vdd_pll-supply = <&pm8941_l12>;
+		qcom,vdd_pll = <1800000>;
+		qcom,firmware-name = "mba";
+		qcom,pil-self-auth;
+
+		/* GPIO inputs from mss */
+		qcom,gpio-err-fatal = <&smp2pgpio_ssr_smp2p_1_in 0 0>;
+		qcom,gpio-err-ready = <&smp2pgpio_ssr_smp2p_1_in 1 0>;
+		qcom,gpio-proxy-unvote = <&smp2pgpio_ssr_smp2p_1_in 2 0>;
+		qcom,gpio-stop-ack = <&smp2pgpio_ssr_smp2p_1_in 3 0>;
+
+		/* GPIO output to mss */
+		qcom,gpio-force-stop = <&smp2pgpio_ssr_smp2p_1_out 0 0>;
+	};
+
+	qcom,pronto@fb21b000 {
+		compatible = "qcom,pil-pronto";
+		reg = <0xfb21b000 0x3000>,
+		      <0xfc401700 0x4>,
+		      <0xfd485300 0xc>;
+		reg-names = "pmu_base", "clk_base", "halt_base";
+		interrupts = <0 149 1>;
+		vdd_pronto_pll-supply = <&pm8941_l12>;
+
+		qcom,firmware-name = "wcnss";
+
+		/* GPIO inputs from wcnss */
+		qcom,gpio-err-fatal = <&smp2pgpio_ssr_smp2p_4_in 0 0>;
+		qcom,gpio-err-ready = <&smp2pgpio_ssr_smp2p_4_in 1 0>;
+		qcom,gpio-proxy-unvote = <&smp2pgpio_ssr_smp2p_4_in 2 0>;
+
+		/* GPIO output to wcnss */
+		qcom,gpio-force-stop = <&smp2pgpio_ssr_smp2p_4_out 0 0>;
+	};
+
+	qcom,iris-fm {
+		compatible = "qcom,iris_fm";
+	};
+
+	qcom,wcnss-wlan@fb000000 {
+		compatible = "qcom,wcnss_wlan";
+		reg = <0xfb000000 0x280000>,
+			<0xf9011008 0x04>;
+		reg-names = "wcnss_mmio", "wcnss_fiq";
+		interrupts = <0 145 0 0 146 0>;
+		interrupt-names = "wcnss_wlantx_irq", "wcnss_wlanrx_irq";
+
+		qcom,pronto-vddmx-supply = <&pm8841_s1>;
+		qcom,pronto-vddcx-supply = <&pm8841_s2>;
+		qcom,pronto-vddpx-supply = <&pm8941_s3>;
+		qcom,iris-vddxo-supply = <&pm8941_l6>;
+		qcom,iris-vddrfa-supply = <&pm8941_l11>;
+		qcom,iris-vddpa-supply = <&pm8941_l19>;
+		qcom,iris-vdddig-supply = <&pm8941_s3>;
+
+		gpios = <&msmgpio 36 0>, <&msmgpio 37 0>, <&msmgpio 38 0>, <&msmgpio 39 0>, <&msmgpio 40 0>;
+		qcom,has-48mhz-xo;
+		qcom,has-pronto-hw;
+	};
+
+	qcom,ocmem@fdd00000 {
+		compatible = "qcom,msm-ocmem";
+		reg = <0xfdd00000 0x2000>,
+		      <0xfdd02000 0x2000>,
+		      <0xfe039000 0x400>,
+		      <0xfec00000 0x180000>;
+		reg-names = "ocmem_ctrl_physical", "dm_ctrl_physical", "br_ctrl_physical", "ocmem_physical";
+		interrupts = <0 76 0 0 77 0>;
+		interrupt-names = "ocmem_irq", "dm_irq";
+		qcom,ocmem-num-regions = <0x3>;
+		qcom,ocmem-num-macros = <0x18>;
+		qcom,resource-type = <0x706d636f>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0xfec00000 0x180000>;
+
+		partition@0 {
+			reg = <0x0 0x100000>;
+			qcom,ocmem-part-name = "graphics";
+			qcom,ocmem-part-min = <0x80000>;
+		};
+
+		partition@80000 {
+			reg = <0x100000 0x80000>;
+			qcom,ocmem-part-name = "lp_audio";
+			qcom,ocmem-part-min = <0x80000>;
+		};
+
+		partition@100000 {
+			reg = <0x100000 0x80000>;
+			qcom,ocmem-part-name = "video";
+			qcom,ocmem-part-min = <0x55000>;
+		};
+
+	};
+
+	rpm_bus: qcom,rpm-smd {
+		compatible = "qcom,rpm-smd";
+		rpm-channel-name = "rpm_requests";
+		rpm-channel-type = <15>; /* SMD_APPS_RPM */
+	};
+
+        qcom,msm-rng@f9bff000 {
+		compatible = "qcom,msm-rng";
+		reg = <0xf9bff000 0x200>;
+		qcom,msm-bus,name = "msm-rng-noc";
+		qcom,msm-bus,num-cases = <2>;
+		qcom,msm-bus,num-paths = <1>;
+		qcom,msm-bus,vectors-KBps =
+				<88 618 0 0>,
+				<88 618 0 800>;
+        };
+
+	qseecom: qcom,qseecom@7b00000 {
+		compatible = "qcom,qseecom";
+		reg = <0x7b00000 0x500000>;
+		reg-names = "secapp-region";
+		qcom,disk-encrypt-pipe-pair = <2>;
+		qcom,hlos-ce-hw-instance = <1>;
+		qcom,qsee-ce-hw-instance = <0>;
+		qcom,support-bus-scaling;
+		qcom,msm-bus,name = "qseecom-noc";
+		qcom,msm-bus,num-cases = <4>;
+		qcom,msm-bus,num-paths = <1>;
+		qcom,msm-bus,vectors-KBps =
+				<55 512 0 0>,
+				<55 512 0 0>,
+				<55 512 120000 1200000>,
+				<55 512 393600 3936000>;
+	};
+
+	qcom,wdt@f9017000 {
+		compatible = "qcom,msm-watchdog";
+		reg = <0xf9017000 0x1000>;
+		interrupts = <0 3 0>, <0 4 0>;
+		qcom,bark-time = <11000>;
+		qcom,pet-time = <10000>;
+		qcom,ipi-ping;
+	};
+
+	qcom,tz-log@fe805720 {
+		compatible = "qcom,tz-log";
+		reg = <0xfe805720 0x1000>;
+	};
+
+	qcom,venus@fdce0000 {
+		compatible = "qcom,pil-venus";
+		reg = <0xfdce0000 0x4000>,
+		      <0xfdc80000 0x400>;
+		reg-names = "wrapper_base", "vbif_base";
+		vdd-supply = <&gdsc_venus>;
+
+		qcom,firmware-name = "venus";
+	};
+
+	qcom,cache_erp@f9012000 {
+		reg = <0xf9012000 0x80>,
+		      <0xf9089000 0x80>,
+		      <0xf9099000 0x80>,
+		      <0xf90a9000 0x80>,
+		      <0xf90b9000 0x80>,
+		      <0xf9088000 0x40>,
+		      <0xf9098000 0x40>,
+		      <0xf90a8000 0x40>,
+		      <0xf90b8000 0x40>;
+
+		reg-names = "l2_saw",
+			    "krait0_saw",
+			    "krait1_saw",
+			    "krait2_saw",
+			    "krait3_saw",
+			    "krait0_acs",
+			    "krait1_acs",
+			    "krait2_acs",
+			    "krait3_acs";
+
+		compatible = "qcom,cache_erp";
+		interrupts = <1 9 0>, <0 2 0>;
+		interrupt-names = "l1_irq", "l2_irq";
+	};
+
+	qcom,cache_dump {
+		compatible = "qcom,cache_dump";
+		qcom,l1-dump-size = <0x100000>;
+		qcom,l2-dump-size = <0x500000>;
+	};
+
+	tsens: tsens@fc4a8000 {
+		compatible = "qcom,msm-tsens";
+		reg = <0xfc4a8000 0x2000>,
+		      <0xfc4bc000 0x1000>;
+		reg-names = "tsens_physical", "tsens_eeprom_physical";
+		interrupts = <0 184 0>;
+		qcom,sensors = <11>;
+		qcom,slope = <3200 3200 3200 3200 3200 3200 3200 3200 3200
+				3200 3200>;
+		qcom,calib-mode = "fuse_map1";
+	};
+
+	jtag_fuse: jtagfuse@fc4be024 {
+		compatible = "qcom,jtag-fuse";
+		reg = <0xfc4be024 0x8>;
+		reg-names = "fuse-base";
+	};
+
+	qcom,msm-rtb {
+		compatible = "qcom,msm-rtb";
+		qcom,memory-reservation-type = "EBI1";
+		qcom,memory-reservation-size = <0x100000>; /* 1M EBI1 buffer */
+	};
+
+	qcom,msm-contig-mem {
+		compatible = "qcom,msm-contig-mem";
+		qcom,memory-reservation-type = "EBI1";
+		qcom,memory-reservation-size = <0x280000>; /* 2.5M EBI1 buffer */
+	};
+
+        qcom,qcedev@fd440000 {
+		compatible = "qcom,qcedev";
+		reg = <0xfd440000 0x20000>,
+		      <0xfd444000 0x8000>;
+		reg-names = "crypto-base","crypto-bam-base";
+		interrupts = <0 236 0>;
+		qcom,bam-pipe-pair = <1>;
+		qcom,ce-hw-instance = <1>;
+                qcom,msm-bus,name = "qcedev-noc";
+		qcom,msm-bus,num-cases = <2>;
+		qcom,msm-bus,num-paths = <1>;
+		qcom,msm-bus,vectors-KBps =
+				<56 512 0 0>,
+				<56 512 3936000 393600>;
+	};
+
+        qcom,qcrypto@fd444000 {
+		compatible = "qcom,qcrypto";
+		reg = <0xfd440000 0x20000>,
+		      <0xfd444000 0x8000>;
+		reg-names = "crypto-base","crypto-bam-base";
+		interrupts = <0 236 0>;
+		qcom,bam-pipe-pair = <2>;
+		qcom,ce-hw-instance = <1>;
+		qcom,clk-mgmt-sus-res;
+                qcom,msm-bus,name = "qcrypto-noc";
+		qcom,msm-bus,num-cases = <2>;
+		qcom,msm-bus,num-paths = <1>;
+                qcom,use-sw-aes-cbc-ecb-ctr-algo;
+                qcom,use-sw-aes-xts-algo;
+                qcom,use-sw-ahash-algo;
+		qcom,msm-bus,vectors-KBps =
+				<56 512 0 0>,
+				<56 512 3936000 393600>;
+	};
+
+	qcom,usbbam@f9304000 {
+		compatible = "qcom,usb-bam-msm";
+		reg = <0xf9304000 0x5000>,
+		      <0xf9a44000 0x11000>,
+		      <0xf92f880c 0x4>;
+		reg-names = "ssusb", "hsusb", "qscratch_ram1_reg";
+		interrupts = <0 132 0 0 135 0>;
+		interrupt-names = "ssusb", "hsusb";
+		qcom,usb-bam-num-pipes = <16>;
+		qcom,usb-bam-fifo-baseaddr = <0xf9200000>;
+		qcom,ignore-core-reset-ack;
+		qcom,disable-clk-gating;
+
+		qcom,pipe0 {
+			label = "ssusb-qdss-in-0";
+			qcom,usb-bam-mem-type = <1>;
+			qcom,bam-type = <0>;
+			qcom,dir = <1>;
+			qcom,pipe-num = <0>;
+			qcom,peer-bam = <1>;
+			qcom,src-bam-physical-address = <0xfc37C000>;
+			qcom,src-bam-pipe-index = <0>;
+			qcom,dst-bam-physical-address = <0xf9304000>;
+			qcom,dst-bam-pipe-index = <2>;
+			qcom,data-fifo-offset = <0xf0000>;
+			qcom,data-fifo-size = <0x1800>;
+			qcom,descriptor-fifo-offset = <0xf4000>;
+			qcom,descriptor-fifo-size = <0x1400>;
+			qcom,reset-bam-on-connect;
+		};
+
+		qcom,pipe1 {
+			label = "hsusb-qdss-in-0";
+			qcom,usb-bam-mem-type = <1>;
+			qcom,bam-type = <1>;
+			qcom,dir = <1>;
+			qcom,pipe-num = <0>;
+			qcom,peer-bam = <1>;
+			qcom,src-bam-physical-address = <0xfc37c000>;
+			qcom,src-bam-pipe-index = <0>;
+			qcom,dst-bam-physical-address = <0xf9a44000>;
+			qcom,dst-bam-pipe-index = <2>;
+			qcom,data-fifo-offset = <0xf4000>;
+			qcom,data-fifo-size = <0x1000>;
+			qcom,descriptor-fifo-offset = <0xf5000>;
+			qcom,descriptor-fifo-size = <0x400>;
+		};
+	};
+
+	qcom,msm-thermal {
+		compatible = "qcom,msm-thermal";
+		qcom,sensor-id = <5>;
+		qcom,poll-ms = <250>;
+		qcom,limit-temp = <60>;
+		qcom,temp-hysteresis = <10>;
+		qcom,freq-step = <2>;
+		qcom,freq-control-mask = <0xf>;
+		qcom,core-limit-temp = <80>;
+		qcom,core-temp-hysteresis = <10>;
+		qcom,core-control-mask = <0xe>;
+		qcom,hotplug-temp = <110>;
+		qcom,hotplug-temp-hysteresis = <20>;
+		qcom,cpu-sensors = "tsens_tz_sensor5", "tsens_tz_sensor6",
+				"tsens_tz_sensor7", "tsens_tz_sensor8";
+		qcom,freq-mitigation-temp = <110>;
+		qcom,freq-mitigation-temp-hysteresis = <20>;
+		qcom,freq-mitigation-value = <960000>;
+		qcom,freq-mitigation-control-mask = <0x01>;
+		qcom,vdd-restriction-temp = <5>;
+		qcom,vdd-restriction-temp-hysteresis = <10>;
+		qcom,pmic-sw-mode-temp = <85>;
+		qcom,pmic-sw-mode-temp-hysteresis = <75>;
+		qcom,pmic-sw-mode-regs = "vdd-dig";
+		vdd-dig-supply = <&pm8841_s2_floor_corner>;
+		vdd-gfx-supply = <&pm8841_s4_floor_corner>;
+
+		qcom,vdd-dig-rstr{
+			qcom,vdd-rstr-reg = "vdd-dig";
+			qcom,levels = <5 7 7>; /* Nominal, Super Turbo, Super Turbo */
+			qcom,min-level = <1>; /* No Request */
+		};
+
+		qcom,vdd-gfx-rstr{
+			qcom,vdd-rstr-reg = "vdd-gfx";
+			qcom,levels = <5 7 7>; /* Nominal, Super Turbo, Super Turbo */
+			qcom,min-level = <1>; /* No Request */
+		};
+
+		qcom,vdd-apps-rstr{
+			qcom,vdd-rstr-reg = "vdd-apps";
+			qcom,levels = <1881600 1958400 2265600>;
+			qcom,freq-req;
+		};
+	};
+
+	qcom,bam_dmux@fc834000 {
+		compatible = "qcom,bam_dmux";
+		reg = <0xfc834000 0x7000>;
+		interrupts = <0 29 1>;
+		qcom,rx-ring-size = <64>;
+	};
+
+        memory_hole: qcom,msm-mem-hole {
+                compatible = "qcom,msm-mem-hole";
+                qcom,memblock-remove = <0x5d00000 0x7d00000
+					0xfa00000 0x500000>; /* Address and Size of Hole */
+        };
+
+/*
+	uart7: uart@f995d000 { 
+		compatible = "qcom,msm-hsuart-v14";
+		status = "disabled";
+		reg = <0xf995d000 0x1000>,
+			<0xf9944000 0x19000>;
+		reg-names = "core_mem", "bam_mem";
+		interrupt-names = "core_irq", "bam_irq", "wakeup_irq";
+		#address-cells = <0>;
+		interrupt-parent = <&uart7>;
+		interrupts = <0 1 2>;
+		#interrupt-cells = <1>;
+		interrupt-map-mask = <0xffffffff>;
+		interrupt-map = <0 &intc 0 113 0
+				1 &intc 0 239 0
+				2 &msmgpio 42 0>;
+
+		qcom,bam-tx-ep-pipe-index = <0>;
+		qcom,bam-rx-ep-pipe-index = <1>;
+		qcom,msm-bus,name = "uart7";
+		qcom,msm-bus,num-cases = <2>;
+		qcom,msm-bus,num-paths = <1>;
+		qcom,msm-bus,vectors-KBps =
+				<84 512 0 0>,
+				<84 512 500 800>;
+	};
+*/
+  uart8: uart@f995e000 {
+    compatible = "qcom,msm-hsuart-v14";
+    status = "ok";
+    reg = <0xf995e000 0x1000>,
+          <0xf9944000 0x19000>;    
+    reg-names = "core_mem", "bam_mem";  
+    interrupt-names = "core_irq", "bam_irq", "wakeup_irq";  
+    #address-cells = <0>;    
+		interrupt-parent = <&uart8>;
+		interrupts = <0 1 2>;	 
+		#interrupt-cells = <1>;
+		interrupt-map-mask = <0xffffffff>;
+		interrupt-map = <0 &intc 0 114 0
+				1 &intc 0 239 0
+				2 &msmgpio 46 0>; 
+				           
+    
+    qcom,tx-gpio = <&msmgpio 45 0x00>;
+    qcom,rx-gpio = <&msmgpio 46 0x00>;
+    qcom,cts-gpio = <&msmgpio 47 0x00>;
+    qcom,rfr-gpio = <&msmgpio 48 0x00>;
+    qcom,bam-tx-ep-pipe-index = <2>;
+    qcom,bam-rx-ep-pipe-index = <3>;
+    qcom,msm-bus,name = "uart8";
+    qcom,msm-bus,num-cases = <2>;
+    /*qcom,msm-bus,active-only = <0>;*/
+    qcom,msm-bus,num-paths = <1>;
+    qcom,msm-bus,vectors-KBps =
+                     <84 512 0 0>,
+                     <84 512 500 800>;
+	};
+
+   bt_bcm4339_sleep {
+        compatible = "qca,bcm4339_bluesleep";
+        host-wake-gpio = <&msmgpio 44 0>;
+        ext-wake-gpio = <&msmgpio 43 0>;
+        interrupt-parent = <&msmgpio>;
+        interrupts = <44 1>;
+        interrupt-names = "host_wake";
+   };
+   /* broadcom 4339 end */
+
+	qcom,smem@fa00000 {
+		compatible = "qcom,smem";
+		reg = <0xfa00000 0x200000>,
+			<0xf9011000 0x1000>,
+			<0xfc428000 0x4000>;
+		reg-names = "smem", "irq-reg-base", "aux-mem1";
+
+		qcom,smd-modem {
+			compatible = "qcom,smd";
+			qcom,smd-edge = <0>;
+			qcom,smd-irq-offset = <0x8>;
+			qcom,smd-irq-bitmask = <0x1000>;
+			qcom,pil-string = "modem";
+			interrupts = <0 25 1>;
+		};
+
+		qcom,smsm-modem {
+			compatible = "qcom,smsm";
+			qcom,smsm-edge = <0>;
+			qcom,smsm-irq-offset = <0x8>;
+			qcom,smsm-irq-bitmask = <0x2000>;
+			interrupts = <0 26 1>;
+		};
+
+		qcom,smd-adsp {
+			compatible = "qcom,smd";
+			qcom,smd-edge = <1>;
+			qcom,smd-irq-offset = <0x8>;
+			qcom,smd-irq-bitmask = <0x100>;
+			qcom,pil-string = "adsp";
+			interrupts = <0 156 1>;
+		};
+
+		qcom,smsm-adsp {
+			compatible = "qcom,smsm";
+			qcom,smsm-edge = <1>;
+			qcom,smsm-irq-offset = <0x8>;
+			qcom,smsm-irq-bitmask = <0x200>;
+			interrupts = <0 157 1>;
+		};
+
+		qcom,smd-wcnss {
+			compatible = "qcom,smd";
+			qcom,smd-edge = <6>;
+			qcom,smd-irq-offset = <0x8>;
+			qcom,smd-irq-bitmask = <0x20000>;
+			qcom,pil-string = "wcnss";
+			interrupts = <0 142 1>;
+		};
+
+		qcom,smsm-wcnss {
+			compatible = "qcom,smsm";
+			qcom,smsm-edge = <6>;
+			qcom,smsm-irq-offset = <0x8>;
+			qcom,smsm-irq-bitmask = <0x80000>;
+			interrupts = <0 144 1>;
+		};
+
+		qcom,smd-rpm {
+			compatible = "qcom,smd";
+			qcom,smd-edge = <15>;
+			qcom,smd-irq-offset = <0x8>;
+			qcom,smd-irq-bitmask = <0x1>;
+			interrupts = <0 168 1>;
+			qcom,irq-no-suspend;
+		};
+	};
+
+	qcom,bcl {
+		compatible = "qcom,bcl";
+	};
+
+	i2c@f9928000 { /* BLSP-1 QUP-6 */
+		cell-index = <3>;
+		compatible = "qcom,i2c-qup";
+		reg = <0xf9928000 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg-names = "qup_phys_addr";
+		interrupts = <0 100 0>;
+		interrupt-names = "qup_err_intr";
+		qcom,i2c-bus-freq = <400000>;
+		qcom,i2c-src-freq = <19200000>;
+		qcom,scl-gpio = <&msmgpio 30 0>;
+		qcom,sda-gpio = <&msmgpio 29 0>;
+		qcom,master-id = <86>;
+	};
+
+	qcom,ssm {
+		compatible = "qcom,ssm";
+		qcom,channel-name = "SSM_RTR";
+	};
+
+	sfpb_spinlock: qcom,ipc-spinlock@fd484000 {
+		compatible = "qcom,ipc-spinlock-sfpb";
+		reg = <0xfd484000 0x400>;
+		qcom,num-locks = <8>;
+	};
+
+	ldrex_spinlock: qcom,ipc-spinlock@fa00000 {
+		compatible = "qcom,ipc-spinlock-ldrex";
+		reg = <0xfa00000 0x200000>;
+		status = "disable";
+	};
+
+	cpu-pmu {
+		compatible = "qcom,krait-pmu";
+		qcom,irq-is-percpu;
+		interrupts = <1 7 0xf00>;
+	};
+
+	l2-pmu {
+		compatible = "qcom,l2-pmu";
+		interrupts = <0 1 0>;
+	};
+
+	qcom,smdtty {
+		compatible = "qcom,smdtty";
+
+		smdtty_apps_fm: qcom,smdtty-apps-fm {
+			qcom,smdtty-remote = "wcnss";
+			qcom,smdtty-port-name = "APPS_FM";
+		};
+
+		smdtty_apps_riva_bt_acl: smdtty-apps-riva-bt-acl {
+			qcom,smdtty-remote = "wcnss";
+			qcom,smdtty-port-name = "APPS_RIVA_BT_ACL";
+		};
+
+		smdtty_apps_riva_bt_cmd: qcom,smdtty-apps-riva-bt-cmd {
+			qcom,smdtty-remote = "wcnss";
+			qcom,smdtty-port-name = "APPS_RIVA_BT_CMD";
+		};
+
+		smdtty_mbalbridge: qcom,smdtty-mbalbridge {
+			qcom,smdtty-remote = "modem";
+			qcom,smdtty-port-name = "MBALBRIDGE";
+		};
+
+		smdtty_apps_riva_ant_cmd: smdtty-apps-riva-ant-cmd {
+			qcom,smdtty-remote = "wcnss";
+			qcom,smdtty-port-name = "APPS_RIVA_ANT_CMD";
+		};
+
+		smdtty_apps_riva_ant_data: smdtty-apps-riva-ant-data {
+			qcom,smdtty-remote = "wcnss";
+			qcom,smdtty-port-name = "APPS_RIVA_ANT_DATA";
+		};
+
+		smdtty_data1: qcom,smdtty-data1 {
+			qcom,smdtty-remote = "modem";
+			qcom,smdtty-port-name = "DATA1";
+		};
+
+		smdtty_data11: qcom,smdtty-data11 {
+			qcom,smdtty-remote = "modem";
+			qcom,smdtty-port-name = "DATA11";
+		};
+
+		smdtty_data21: qcom,smdtty-data21 {
+			qcom,smdtty-remote = "modem";
+			qcom,smdtty-port-name = "DATA21";
+		};
+
+		smdtty_gps_nmea: smdtty-gpsnmea {
+			qcom,smdtty-remote = "modem";
+			qcom,smdtty-port-name = "GPSNMEA";
+		};
+
+		smdtty_loopback: smdtty-loopback {
+			qcom,smdtty-remote = "modem";
+			qcom,smdtty-port-name = "LOOPBACK";
+			qcom,smdtty-dev-name = "LOOPBACK_TTY";
+		};
+	};
+};
+
+&gdsc_venus {
+	qcom,clock-names = "core_clk";
+	status = "ok";
+};
+
+&gdsc_mdss {
+	qcom,clock-names = "core_clk", "lut_clk";
+	status = "ok";
+};
+
+&gdsc_jpeg {
+	qcom,clock-names = "core0_clk", "core1_clk", "core2_clk";
+	status = "ok";
+};
+
+&gdsc_vfe {
+	qcom,clock-names = "core0_clk", "core1_clk", "csi0_clk", "csi1_clk",
+			   "cpp_clk";
+	status = "ok";
+};
+
+&gdsc_oxili_gx {
+	qcom,clock-names = "core_clk";
+	status = "ok";
+};
+
+&gdsc_oxili_cx {
+	status = "ok";
+};
+
+&gdsc_usb_hsic {
+	status = "ok";
+};
diff --git a/arch/arm/boot/dts/NX503A/zte-dsi-panel-sharp-1080p-5p0-video.dtsi b/arch/arm/boot/dts/NX503A/zte-dsi-panel-sharp-1080p-5p0-video.dtsi
new file mode 100755
index 0000000..281943c
--- /dev/null
+++ b/arch/arm/boot/dts/NX503A/zte-dsi-panel-sharp-1080p-5p0-video.dtsi
@@ -0,0 +1,88 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*---------------------------------------------------------------------------
+ * This file is autogenerated file using gcdb parser. Please do not edit it.
+ * Update input XML file to add a new entry or update variable in this file
+ * VERSION = "1.0"
+ *---------------------------------------------------------------------------*/
+&mdss_mdp {
+	dsi_sp_1080_5p0_vid: qcom,mdss_dsi_sharp_1080p_5p0_video {
+		qcom,mdss-dsi-panel-name = "sharp 1080p 5p0 video mode dsi panel";
+		qcom,mdss-dsi-panel-controller = <&mdss_dsi0>;
+		qcom,mdss-dsi-panel-type = "dsi_video_mode";
+		qcom,mdss-dsi-panel-destination = "display_1";
+		qcom,mdss-dsi-panel-framerate = <60>;
+		qcom,mdss-dsi-virtual-channel-id = <0>;
+		qcom,mdss-dsi-stream = <0>;
+		qcom,mdss-dsi-panel-width = <1080>;
+		qcom,mdss-dsi-panel-height = <1920>;
+		qcom,mdss-dsi-h-front-porch = <100>;
+		qcom,mdss-dsi-h-back-porch = <58>;
+		qcom,mdss-dsi-h-pulse-width = <12>;
+		qcom,mdss-dsi-h-sync-skew = <0>;
+		qcom,mdss-dsi-v-back-porch = <4>;
+		qcom,mdss-dsi-v-front-porch = <4>;
+		qcom,mdss-dsi-v-pulse-width = <2>;
+		qcom,mdss-dsi-h-left-border = <0>;
+		qcom,mdss-dsi-h-right-border = <0>;
+		qcom,mdss-dsi-v-top-border = <0>;
+		qcom,mdss-dsi-v-bottom-border = <0>;
+		qcom,mdss-dsi-bpp = <24>;
+		qcom,mdss-dsi-underflow-color = <0xff>;
+		qcom,mdss-dsi-border-color = <0>;
+		qcom,mdss-dsi-on-command = [
+					23 01 00 00 00 00 02 b0 04
+					05 01 00 00 00 00 02 00 00
+					05 01 00 00 00 00 02 00 00
+					23 01 00 00 00 00 02 d6 01
+					29 01 00 00 00 00 08 ce 00 01 88 c1 00 1e 04
+					];
+		qcom,mdss-dsi-on-second_command = [
+					39 01 00 00 00 00 02 55 01
+					39 01 00 00 00 00 02 53 2c
+					39 01 00 00 00 00 02 29 00
+					39 01 00 00 64 00 02 11 00
+					];
+		qcom,mdss-dsi-off-command = [
+					39 01 00 00 10 00 02 28 00
+					39 01 00 00 40 00 02 10 00];
+		qcom,mdss-dsi-on-command-state = "dsi_lp_mode";
+		qcom,mdss-dsi-off-command-state = "dsi_hs_mode";
+		qcom,mdss-dsi-h-sync-pulse = <0>;
+		qcom,mdss-dsi-traffic-mode = "burst_mode";
+		qcom,mdss-dsi-bllp-eof-power-mode;
+		qcom,mdss-dsi-bllp-power-mode;
+		qcom,mdss-dsi-lane-0-state;
+		qcom,mdss-dsi-lane-1-state;
+		qcom,mdss-dsi-lane-2-state;
+		qcom,mdss-dsi-lane-3-state;
+		qcom,mdss-dsi-panel-timings = [42 36 24 00 66 68 28 38 2a 03 04 00];
+		qcom,mdss-dsi-t-clk-post = <0x04>;
+		qcom,mdss-dsi-t-clk-pre = <0x1C>;
+		qcom,mdss-brightness-max-level = <255>;
+		qcom,mdss-dsi-bl-min-level = <58>;
+		qcom,mdss-dsi-bl-max-level = <4095>;
+		qcom,mdss-dsi-bright-to-bl-lvl-para-a1 = <1872>;
+		qcom,mdss-dsi-bright-to-bl-lvl-para-a2 = <594>;
+		qcom,mdss-dsi-bright-to-bl-lvl-para-b1 = <1812>;
+		qcom,mdss-dsi-bright-to-bl-lvl-para-b2 = <257978>;
+		qcom,mdss-dsi-bright-to-bl-lvl-turn-point = <186>;	
+		mdss-dsi-bllp-power-mode;
+		mdss-dsi-bllp-eof-power-mode;
+		qcom,mdss-dsi-dma-trigger = "trigger_sw";
+		qcom,mdss-dsi-mdp-trigger = "none";
+		qcom,mdss-dsi-bl-pmic-control-type = "bl_ctrl_dcs";
+		qcom,mdss-dsi-bl-pmic-control-reg  = <0x51>;
+		qcom,mdss-dsi-reset-sequence = <1 10>;
+	};
+};
diff --git a/arch/arm/boot/dts/msm8974-clock.dtsi b/arch/arm/boot/dts/msm8974-clock.dtsi
index 8d90771..f1bebfd 100644
--- a/arch/arm/boot/dts/msm8974-clock.dtsi
+++ b/arch/arm/boot/dts/msm8974-clock.dtsi
@@ -16,6 +16,7 @@
 	};
 
 	pm8941_clkdiv2: clkdiv@5c00 {
+			qcom,cxo-div = <1>;
 	};
 
 	pm8941_clkdiv3: clkdiv@5d00 {
diff --git a/arch/arm/boot/dts/msm8974-v2.0-1-mtp-NX503A.dts b/arch/arm/boot/dts/msm8974-v2.0-1-mtp-NX503A.dts
new file mode 100755
index 0000000..38bc326
--- /dev/null
+++ b/arch/arm/boot/dts/msm8974-v2.0-1-mtp-NX503A.dts
@@ -0,0 +1,28 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+/include/ "NX503A/msm8974-v2.0-1.dtsi"
+/include/ "NX503A/msm8974-mtp.dtsi"
+
+/ {
+	model = "Qualcomm MSM 8974v2.0/1 MTP";
+	compatible = "qcom,msm8974-mtp", "qcom,msm8974", "qcom,mtp";
+	qcom,msm-id = <126 8 0x20000>,
+		      <185 8 0x20000>,
+		      <186 8 0x20000>;
+};
+
+&pm8941_chg {
+	qcom,bpd-detection = "bpd_thm";
+};
diff --git a/arch/arm/boot/dts/msm8974-v2.2-mtp-NX503A.dts b/arch/arm/boot/dts/msm8974-v2.2-mtp-NX503A.dts
new file mode 100755
index 0000000..5d28c73
--- /dev/null
+++ b/arch/arm/boot/dts/msm8974-v2.2-mtp-NX503A.dts
@@ -0,0 +1,28 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+/include/ "NX503A/msm8974-v2.2.dtsi"
+/include/ "NX503A/msm8974-mtp.dtsi"
+
+/ {
+	model = "Qualcomm MSM 8974v2.2 MTP";
+	compatible = "qcom,msm8974-mtp", "qcom,msm8974", "qcom,mtp";
+	qcom,msm-id = <126 8 0x20002>,
+		      <185 8 0x20002>,
+		      <186 8 0x20002>;
+};
+
+&pm8941_chg {
+	qcom,bpd-detection = "bpd_thm";
+};
diff --git a/arch/arm/boot/dts/msm8974pro-pma8084-mtp.dtsi b/arch/arm/boot/dts/msm8974pro-pma8084-mtp.dtsi
old mode 100644
new mode 100755
diff --git a/arch/arm/configs/msm8974-NX503A_defconfig b/arch/arm/configs/msm8974-NX503A_defconfig
new file mode 100755
index 0000000..95a734d
--- /dev/null
+++ b/arch/arm/configs/msm8974-NX503A_defconfig
@@ -0,0 +1,554 @@
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_EXPERIMENTAL=y
+CONFIG_LOCALVERSION="-perf"
+CONFIG_SYSVIPC=y
+CONFIG_AUDIT=y
+CONFIG_RCU_FAST_NO_HZ=y
+CONFIG_IKCONFIG=y
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_PANIC_TIMEOUT=5
+CONFIG_KALLSYMS_ALL=y
+CONFIG_EMBEDDED=y
+# CONFIG_SLUB_DEBUG is not set
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=y
+CONFIG_KPROBES=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_EFI_PARTITION=y
+CONFIG_IOSCHED_TEST=y
+CONFIG_DEFAULT_ROW=y
+CONFIG_ARCH_MSM=y
+CONFIG_ARCH_MSM8974=y
+CONFIG_MSM_KRAIT_TBB_ABORT_HANDLER=y
+CONFIG_ARCH_MSM8974_ZTEMT=y
+CONFIG_BOARD_ZTEMT_NX503A=y
+CONFIG_ZTEMT_RESTART=y
+CONFIG_EMMC_UNSUPPORTED_HPI=y
+# CONFIG_MSM_STACKED_MEMORY is not set
+CONFIG_CPU_HAS_L2_PMU=y
+# CONFIG_MSM_FIQ_SUPPORT is not set
+# CONFIG_MSM_PROC_COMM is not set
+CONFIG_MSM_SMD=y
+CONFIG_MSM_SMD_PKG4=y
+CONFIG_MSM_BAM_DMUX=y
+CONFIG_MSM_SMP2P=y
+CONFIG_MSM_SMP2P_TEST=y
+CONFIG_MSM_IPC_LOGGING=y
+CONFIG_MSM_IPC_ROUTER=y
+CONFIG_MSM_IPC_ROUTER_SMD_XPRT=y
+CONFIG_MSM_IPC_ROUTER_SECURITY=y
+CONFIG_MSM_QMI_INTERFACE=y
+CONFIG_MSM_SUBSYSTEM_RESTART=y
+CONFIG_MSM_SYSMON_COMM=y
+CONFIG_MSM_PIL_LPASS_QDSP6V5=y
+CONFIG_MSM_PIL_MSS_QDSP6V5=y
+CONFIG_MSM_PIL_VENUS=y
+CONFIG_MSM_BUSPM_DEV=m
+CONFIG_MSM_TZ_LOG=y
+CONFIG_MSM_RPM_RBCPR_STATS_V2_LOG=y
+CONFIG_MSM_DIRECT_SCLK_ACCESS=y
+CONFIG_MSM_EVENT_TIMER=y
+CONFIG_MSM_BUS_SCALING=y
+CONFIG_MSM_WATCHDOG_V2=y
+CONFIG_MSM_MEMORY_DUMP=y
+CONFIG_MSM_DLOAD_MODE=y
+CONFIG_MSM_ADSP_LOADER=y
+CONFIG_MSM_OCMEM=y
+CONFIG_MSM_OCMEM_LOCAL_POWER_CTRL=y
+CONFIG_MSM_OCMEM_DEBUG=y
+CONFIG_SENSORS_ADSP=y
+CONFIG_MSM_RTB=y
+CONFIG_MSM_RTB_SEPARATE_CPUS=y
+CONFIG_MSM_CACHE_ERP=y
+CONFIG_MSM_L1_ERR_PANIC=y
+CONFIG_MSM_L1_RECOV_ERR_PANIC=y
+CONFIG_MSM_L1_ERR_LOG=y
+CONFIG_MSM_L2_ERP_2BIT_PANIC=y
+CONFIG_MSM_ENABLE_WDOG_DEBUG_CONTROL=y
+CONFIG_MSM_BOOT_STATS=y
+CONFIG_STRICT_MEMORY_RWX=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_SMP=y
+# CONFIG_SMP_ON_UP is not set
+CONFIG_SCHED_MC=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_COMPACTION=y
+CONFIG_ENABLE_VMALLOC_SAVING=y
+CONFIG_CC_STACKPROTECTOR=y
+CONFIG_CP_ACCESS=y
+CONFIG_USE_OF=y
+CONFIG_BUILD_ARM_APPENDED_DTB_IMAGE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_PM_AUTOSLEEP=y
+CONFIG_PM_WAKELOCKS=y
+CONFIG_PM_WAKELOCKS_LIMIT=0
+# CONFIG_PM_WAKELOCKS_GC is not set
+CONFIG_PM_RUNTIME=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_NETFILTER=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y
+CONFIG_NETFILTER_XT_TARGET_LOG=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_DSCP=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_SECURITY=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+CONFIG_BRIDGE_NF_EBTABLES=y
+CONFIG_BRIDGE_EBT_BROUTE=y
+CONFIG_BRIDGE=y
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_HTB=y
+CONFIG_NET_SCH_PRIO=y
+CONFIG_NET_CLS_FW=y
+CONFIG_NET_CLS_U32=y
+CONFIG_CLS_U32_MARK=y
+CONFIG_NET_CLS_FLOW=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_CMP=y
+CONFIG_NET_EMATCH_NBYTE=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_NET_EMATCH_META=y
+CONFIG_NET_EMATCH_TEXT=y
+CONFIG_NET_CLS_ACT=y
+CONFIG_BT=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_HCISMD=y
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_MSM_SLEEP=y
+CONFIG_MSM_BT_POWER=y
+CONFIG_CFG80211=y
+CONFIG_NL80211_TESTMODE=y
+CONFIG_CFG80211_INTERNAL_REGDB=y
+CONFIG_RFKILL=y
+CONFIG_NFC_PN544=y
+CONFIG_GENLOCK=y
+CONFIG_GENLOCK_MISCDEVICE=y
+CONFIG_CMA=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_TSPP=m
+CONFIG_QSEECOM=y
+CONFIG_QPNP_MISC=y
+CONFIG_USB_HSIC_SMSC_HUB=y
+CONFIG_TI_DRV2667=y
+CONFIG_ZTEMT_HAPTICS_DRV2605=y
+CONFIG_SCSI=y
+CONFIG_SCSI_TGT=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_CHR_DEV_SCH=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=y
+CONFIG_NETDEVICES=y
+CONFIG_DUMMY=y
+CONFIG_TUN=y
+CONFIG_KS8851=m
+# CONFIG_MSM_RMNET is not set
+CONFIG_MSM_RMNET_BAM=y
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOE=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_SLIP=y
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_SLIP_MODE_SLIP6=y
+CONFIG_USB_USBNET=y
+CONFIG_BCMDHD=y
+CONFIG_BCMDHD_FW_PATH="/system/etc/firmware/bcm4339/fw_bcmdhd.bin"
+CONFIG_BCMDHD_NVRAM_PATH="/system/etc/firmware/bcm4339/nvram.txt"
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_EVBUG=m
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_JOYSTICK_XPAD=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_CYPRESS_TMA463=y
+CONFIG_CYTTSP4_5P0_INCH_OTG_GW=y
+CONFIG_CYPRESS_CYTTSP4_BUS=y
+CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BUTTON=y
+# CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PROXIMITY is not set
+CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_LOADER=y
+CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE=y
+CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX=y
+CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_S3208_5keys=y
+CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_CORE=y
+CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_RMI_DEV=y
+CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_FW_UPDATE=y
+CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_TEST_REPORTING=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_HBTP_INPUT=y
+CONFIG_INPUT_UINPUT=y
+# CONFIG_DEVMEM is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_MSM_HS=y
+CONFIG_SERIAL_MSM_HSL=y
+CONFIG_SERIAL_MSM_HSL_CONSOLE=y
+CONFIG_DIAG_CHAR=y
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_MSM=y
+CONFIG_MSM_ADSPRPC=y
+CONFIG_MSM_RDBG=m
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_QUP=y
+CONFIG_SPI=y
+CONFIG_SPI_QUP=y
+CONFIG_SPI_SPIDEV=m
+CONFIG_SPMI=y
+CONFIG_SPMI_MSM_PMIC_ARB=y
+CONFIG_MSM_QPNP_INT=y
+CONFIG_SLIMBUS_MSM_NGD=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_QPNP_PIN=y
+CONFIG_GPIO_QPNP_PIN_DEBUG=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_SMB350_CHARGER=y
+CONFIG_BATTERY_BQ28400=y
+CONFIG_QPNP_CHARGER=y
+CONFIG_BATTERY_BCL=y
+CONFIG_ZTEMT_COMM_CHARGE=y
+CONFIG_ZTEMT_NX503A_CHARGE=y
+CONFIG_QPNP_BMS=y
+CONFIG_SENSORS_EPM_ADC=y
+CONFIG_SENSORS_QPNP_ADC_VOLTAGE=y
+CONFIG_SENSORS_QPNP_ADC_CURRENT=y
+CONFIG_ZTEMT_SENSORS=y
+CONFIG_FEATURE_ZTEMT_SENSORS_LOG_ON=y
+CONFIG_ZTEMT_SENSORS_COMMON=y
+CONFIG_ZTEMT_SENSORS_ALS_PS=y
+CONFIG_ZTEMT_SENSORS_ALS_PS_TMG3993=y
+CONFIG_ZTEMT_SENSORS_ALS_PS_TMD2772=y
+CONFIG_ZTEMT_SENSORS_IR_REMOTE=y
+CONFIG_ZTEMT_SENSORS_IR_REMOTE_MAXQ616=y
+CONFIG_ZTEMT_HSL_UART_DMEN_PATCH=y
+CONFIG_ZTEMT_LIQUID_LED=y
+CONFIG_NX503A_ZTEMT_DEVICE_INFO=y
+CONFIG_ZTEMT_BREATH_LED_NX503A=y
+CONFIG_THERMAL=y
+CONFIG_THERMAL_TSENS8974=y
+CONFIG_THERMAL_MONITOR=y
+CONFIG_THERMAL_QPNP=y
+CONFIG_THERMAL_QPNP_ADC_TM=y
+CONFIG_WCD9320_CODEC=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_STUB=y
+CONFIG_REGULATOR_QPNP=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+CONFIG_DVB_CORE=m
+# CONFIG_MSM_CAMERA is not set
+CONFIG_MSMB_CAMERA=y
+CONFIG_MSM_CAMERA_SENSOR=y
+CONFIG_MSM_CPP=y
+CONFIG_MSM_CCI=y
+CONFIG_MSM_CSI30_HEADER=y
+CONFIG_MSM_CSIPHY=y
+CONFIG_MSM_CSID=y
+CONFIG_MSM_EEPROM=y
+CONFIG_MSM_ISPIF=y
+CONFIG_IMX135_Z5S=y
+CONFIG_IMX135_Z5S_069=y
+CONFIG_OV5648_Z5S=y
+CONFIG_MSMB_JPEG=y
+CONFIG_MSM_VIDC_V4L2=y
+CONFIG_MSM_WFD=y
+CONFIG_DVB_MPQ=m
+CONFIG_DVB_MPQ_DEMUX=m
+CONFIG_VIDEOBUF2_MSM_MEM=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_RADIO_IRIS=y
+CONFIG_RADIO_IRIS_TRANSPORT=m
+CONFIG_ION=y
+CONFIG_ION_MSM=y
+CONFIG_MSM_KGSL=y
+CONFIG_KGSL_PER_PROCESS_PAGE_TABLE=y
+CONFIG_FB=y
+CONFIG_FB_MSM=y
+# CONFIG_FB_MSM_BACKLIGHT is not set
+CONFIG_FB_MSM_MDSS=y
+CONFIG_FB_MSM_MDSS_WRITEBACK=y
+CONFIG_FB_MSM_MDSS_HDMI_PANEL=y
+CONFIG_FB_MSM_MDSS_HDMI_MHL_SII8334=y
+CONFIG_ZTEMT_LCD_MIPI_COMMON=y
+CONFIG_ZTEMT_LCD_POWER_CONTRL=y
+CONFIG_ZTEMT_LCD_AVDD_CONFIG_BY_TPS65132=y
+CONFIG_ZTEMT_LCD_DISP_ENHANCE=y
+CONFIG_ZTEMT_LCD_BACKLIGHT_LINEAR_CONTROL_METHOLD=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_SOUND=y
+CONFIG_ZTEMT_AUDIO_HEADSET_SW=y
+CONFIG_ZTEMT_AUDIO_MBHC_OPEN=y
+CONFIG_SND=y
+CONFIG_SND_USB_AUDIO=y
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_MSM8974=y
+CONFIG_SND_SOC_APQ8074=y
+CONFIG_SND_SOC_WCD9320=y
+CONFIG_UHID=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_ELECOM=y
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_SUSPEND=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_EHSET=y
+CONFIG_USB_EHCI_MSM=y
+CONFIG_USB_EHCI_MSM_HSIC=y
+CONFIG_USB_ACM=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+CONFIG_USB_STORAGE_ENE_UB6250=y
+CONFIG_USB_EHSET_TEST_FIXTURE=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DEBUG_FILES=y
+CONFIG_USB_CI13XXX_MSM=y
+CONFIG_USB_DWC3_MSM=y
+CONFIG_USB_G_ANDROID=y
+CONFIG_MMC=y
+CONFIG_MMC_PERF_PROFILING=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_CLKGATE=y
+CONFIG_MMC_PARANOID_SD_INIT=y
+CONFIG_MMC_BLOCK_MINORS=32
+# CONFIG_MMC_BLOCK_BOUNCE is not set
+CONFIG_MMC_TEST=m
+CONFIG_MMC_BLOCK_TEST=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_MSM=y
+CONFIG_MMC_SDHCI_MSM=y
+CONFIG_MMC_MSM_SPS_SUPPORT=y
+CONFIG_LEDS_QPNP=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_BACKLIGHT=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+CONFIG_SWITCH=y
+CONFIG_RTC_CLASS=y
+# CONFIG_RTC_DRV_MSM is not set
+CONFIG_RTC_DRV_QPNP=y
+CONFIG_ZTE_POWEROFF_ALARM=y
+CONFIG_UIO=y
+CONFIG_UIO_MSM_SHAREDMEM=y
+CONFIG_STAGING=y
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ASHMEM=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_SPS=y
+CONFIG_USB_BAM=y
+CONFIG_SPS_SUPPORT_BAMDMA=y
+CONFIG_SPS_SUPPORT_NDP_BAM=y
+CONFIG_QPNP_PWM=y
+CONFIG_QPNP_POWER_ON=y
+CONFIG_QPNP_CLKDIV=y
+CONFIG_QPNP_REVID=y
+CONFIG_QPNP_COINCELL=y
+CONFIG_MSM_IOMMU_V1=y
+CONFIG_IOMMU_PGTABLES_L2=y
+CONFIG_MOBICORE_SUPPORT=m
+CONFIG_MOBICORE_API=m
+CONFIG_BIF=y
+CONFIG_BIF_QPNP=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_FUSE_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_UTF8=y
+CONFIG_PRINTK_TIME=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_SYSRQ_SCHED_DEBUG is not set
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_PREEMPT is not set
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_ENABLE_DEFAULT_TRACERS=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_DEBUG_USER=y
+CONFIG_PID_IN_CONTEXTIDR=y
+CONFIG_DEBUG_SET_MODULE_RONX=y
+CONFIG_KEYS=y
+CONFIG_SECURITY=y
+CONFIG_SECURITY_NETWORK=y
+CONFIG_LSM_MMAP_MIN_ADDR=4096
+CONFIG_SECURITY_SELINUX=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_XCBC=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_DEV_QCRYPTO=m
+CONFIG_CRYPTO_DEV_QCE=y
+CONFIG_CRYPTO_DEV_QCEDEV=y
diff --git a/arch/arm/mach-msm/Kconfig b/arch/arm/mach-msm/Kconfig
old mode 100644
new mode 100755
index 60f05c6..4ac0b61
--- a/arch/arm/mach-msm/Kconfig
+++ b/arch/arm/mach-msm/Kconfig
@@ -1137,7 +1137,7 @@ config MACH_FSM9XXX_SURF
 	  Support for the Qualcomm FSM9xxx femtocell
 	  chipset based SURF evaluation board and
 	  FFA board.
-
+source "arch/arm/mach-msm/board/Kconfig"
 endmenu
 
 config MSM_STACKED_MEMORY
@@ -3043,6 +3043,7 @@ config KRAIT_REGULATOR
 	 line from the PMIC. This supply line is powered by multiple
 	 regulators running in ganged mode inside the PMIC. Enable
 	 this option to support such configurations.
+
 endif
 
 config KERNEL_TEXT_MPU_PROT
diff --git a/arch/arm/mach-msm/Makefile b/arch/arm/mach-msm/Makefile
old mode 100644
new mode 100755
index c8f46a6..8c9246b
--- a/arch/arm/mach-msm/Makefile
+++ b/arch/arm/mach-msm/Makefile
@@ -264,6 +264,9 @@ obj-$(CONFIG_MACH_MSM8930_FLUID) += board-8930-all.o board-8930-regulator-pm8038
 obj-$(CONFIG_PM8921_BMS) += bms-batterydata.o bms-batterydata-desay.o batterydata-lib.o
 obj-$(CONFIG_QPNP_BMS) += bms-batterydata.o bms-batterydata-desay.o batterydata-lib.o
 obj-$(CONFIG_QPNP_BMS) += bms-batterydata-oem.o bms-batterydata-qrd-4v35-2000mah.o bms-batterydata-qrd-4v2-1300mah.o
+#ZTEMT Added
+obj-$(CONFIG_ZTEMT_NX503A_CHARGE) += bms_ztemt_NX503A_batterydata_2300mAh.o
+#ZTEMT END
 obj-$(CONFIG_MACH_APQ8064_CDP) += board-8064-all.o board-8064-regulator.o
 obj-$(CONFIG_MACH_APQ8064_MTP) += board-8064-all.o board-8064-regulator.o
 obj-$(CONFIG_MACH_APQ8064_LIQUID) += board-8064-all.o board-8064-regulator.o
@@ -273,9 +276,13 @@ obj-$(CONFIG_ARCH_MSM9615) += board-9615.o devices-9615.o board-9615-regulator.o
 obj-$(CONFIG_ARCH_MSM9615) += clock-local.o clock-9615.o acpuclock-9615.o clock-rpm.o clock-pll.o
 obj-$(CONFIG_ARCH_APQ8084) += board-8084.o board-8084-gpiomux.o
 obj-$(CONFIG_ARCH_APQ8084) += clock-8084.o
-obj-$(CONFIG_ARCH_MSM8974) += board-8974.o board-8974-gpiomux.o
+#obj-$(CONFIG_ARCH_MSM8974) += board-8974.o board-8974-gpiomux.o
+obj-$(CONFIG_ARCH_MSM8974_ORIG) += board-8974.o board-8974-gpiomux.o
+obj-$(CONFIG_ARCH_MSM8974_ZTEMT)	+= board/
 obj-$(CONFIG_ARCH_MSM8974) += clock-krait-8974.o
-obj-$(CONFIG_ARCH_MSM8974) += clock-local2.o clock-pll.o clock-8974.o clock-rpm.o clock-voter.o clock-mdss-8974.o
+#obj-$(CONFIG_ARCH_MSM8974) += clock-local2.o clock-pll.o clock-8974.o clock-rpm.o clock-voter.o clock-mdss-8974.o
+obj-$(CONFIG_ARCH_MSM8974) += clock-local2.o clock-pll.o  clock-rpm.o clock-voter.o clock-mdss-8974.o
+obj-$(CONFIG_ARCH_MSM8974_ORIG) += clock-8974.o
 obj-$(CONFIG_ARCH_MSM8974) += gdsc.o
 obj-$(CONFIG_ARCH_MSM9625) += gdsc.o
 obj-$(CONFIG_ARCH_MSM8226) += gdsc.o
@@ -415,6 +422,7 @@ obj-$(CONFIG_MSM_CPR_REGULATOR) += cpr-regulator.o
 obj-$(CONFIG_CPU_FREQ_MSM) += cpufreq.o
 obj-$(CONFIG_MSM_DEVFREQ_CPUBW) += devfreq_cpubw.o
 
+obj-y += board-8974-brcm-wifi.o
 obj-$(CONFIG_WALL_CLK) += wallclk.o
 obj-$(CONFIG_WALL_CLK_SYSFS) += wallclk_sysfs.o
 obj-$(CONFIG_ARCH_RANDOM) += early_random.o
diff --git a/arch/arm/mach-msm/Makefile.boot b/arch/arm/mach-msm/Makefile.boot
old mode 100644
new mode 100755
diff --git a/arch/arm/mach-msm/bms_ztemt_NX503A_batterydata_2300mAh.c b/arch/arm/mach-msm/bms_ztemt_NX503A_batterydata_2300mAh.c
new file mode 100755
index 0000000..fa0d1eb
--- /dev/null
+++ b/arch/arm/mach-msm/bms_ztemt_NX503A_batterydata_2300mAh.c
@@ -0,0 +1,101 @@
+#include <linux/batterydata-lib.h>
+
+/*Have Nothing To Do With The Bat Voltage And Current */
+static struct single_row_lut fcc_temp = {
+    .x      = {-20, -5, 0, 25, 40, 45, 50, 60},
+    .y      = {2288, 2300, 2313, 2278, 2265, 2253, 2231, 2186},
+    .cols   = 8
+};
+
+static struct single_row_lut fcc_sf = {
+    .x      = {0},
+    .y      = {100},
+    .cols   = 1
+};
+
+static struct sf_lut rbatt_sf = { 
+        .rows           = 29, 
+        .cols           = 8,
+        /* row_entries are temperature */
+        .row_entries            = {-20, -5, 0, 25, 40, 45, 50, 60},
+        .percent        = {100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 15, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1},
+        .sf                     = {
+{957,280,210,100,87,85,83,81},
+{981,290,217,103,89,86,84,82},
+{1006,298,225,107,91,89,87,84},
+{1082,300,231,112,94,91,89,85},
+{1035,302,239,116,97,93,91,88},
+{986,285,221,122,101,97,93,90},
+{979,286,216,127,106,101,97,93},
+{984,284,213,115,107,103,101,96},
+{1006,284,212,103,90,88,86,84},
+{1058,289,214,102,89,87,85,84},
+{1122,294,218,105,92,89,87,85},
+{1194,302,223,108,94,92,90,87},
+{1280,316,232,112,95,94,93,90},
+{1387,334,247,114,95,92,91,87},
+{1512,350,261,112,92,89,86,85},
+{1676,377,265,111,91,88,86,84},
+{1893,440,293,109,91,88,86,83},
+{2261,557,378,114,93,90,88,86},
+{2204,470,340,112,93,90,88,86},
+{2310,485,350,116,95,91,89,87},
+{2430,501,361,118,97,92,90,88},
+{2585,523,372,122,97,94,91,87},
+{2806,551,387,122,94,91,89,84},
+{3071,585,408,117,93,89,87,85},
+{3408,628,435,118,96,91,88,87},
+{3885,683,467,123,101,94,90,90},
+{4839,759,511,132,125,100,93,105},
+{10405,893,581,158,538,131,102,205},
+{100430,1304,724,1696,221,1381,141,193},
+        }
+};
+
+static struct pc_temp_ocv_lut pc_temp_ocv = {
+    .rows       = 29,
+    .cols   	= 8,
+    .temp       = {-20, -5, 0, 25, 40, 45, 50, 60},
+    .percent    = {100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 15, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0},
+    .ocv    	= {
+                {4332, 4329, 4330, 4323, 4317, 4314, 4311, 4305},
+                {4232, 4249, 4256, 4255, 4252, 4249, 4247, 4241},
+                {4163, 4188, 4197, 4198, 4196, 4192, 4191, 4185},
+                {4103, 4132, 4142, 4144, 4141, 4138, 4137, 4131}, //85
+                {4047, 4077, 4090, 4092, 4090, 4086, 4086, 4080},
+                {3980, 4020, 4041, 4044, 4042, 4038, 4038, 4033},
+                {3930, 3960, 3981, 3999, 3998, 3995, 3994, 3990},
+                {3886, 3920, 3935, 3957, 3957, 3954, 3954, 3950},
+                {3851, 3882, 3891, 3907, 3911, 3909, 3911, 3908},//60
+                {3824, 3849, 3857, 3865, 3865, 3864, 3864, 3861},
+                {3805, 3821, 3830, 3836, 3836, 3834, 3835, 3834},
+                {3790, 3797, 3807, 3813, 3814, 3813, 3813, 3811},
+                {3776, 3780, 3789, 3795, 3794, 3794, 3794, 3793},
+                {3761, 3767, 3776, 3780, 3778, 3777, 3778, 3776},
+                {3744, 3751, 3765, 3767, 3762, 3760, 3759, 3754},//30
+                {3725, 3731, 3747, 3752, 3744, 3740, 3738, 3731},
+                {3702, 3711, 3716, 3728, 3719, 3715, 3715, 3705},
+                {3673, 3693, 3693, 3696, 3687, 3681, 3678, 3672},
+                {3621, 3666, 3678, 3678, 3666, 3664, 3666, 3653},//10
+                {3605, 3657, 3674, 3676, 3661, 3654, 3656, 3645},
+                {3584, 3643, 3666, 3673, 3656, 3643, 3641, 3636},
+                {3561, 3624, 3651, 3668, 3649, 3631, 3625, 3626},
+                {3536, 3600, 3628, 3651, 3632, 3612, 3606, 3612},
+                {3507, 3570, 3597, 3614, 3592, 3578, 3579, 3573},//5
+                {3473, 3528, 3555, 3562, 3537, 3523, 3537, 3517},
+                {3431, 3466, 3494, 3495, 3468, 3454, 3475, 3455},
+                {3370, 3368, 3403, 3406, 3378, 3363, 3395, 3384},
+                {3249, 3218, 3250, 3278, 3260, 3236, 3288, 3297},
+                {3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000}
+    }
+};
+
+struct bms_battery_data ztemt_NX503A_2300mAh_data = {
+    .fcc        		= 2300,
+    .fcc_temp_lut       = &fcc_temp,
+    .fcc_sf_lut         = &fcc_sf,
+    .pc_temp_ocv_lut    = &pc_temp_ocv,
+    .rbatt_sf_lut       =&rbatt_sf,
+    .default_rbatt_mohm     =146,
+
+};
diff --git a/arch/arm/mach-msm/board-8974-brcm-wifi.c b/arch/arm/mach-msm/board-8974-brcm-wifi.c
new file mode 100755
index 0000000..b53344d
--- /dev/null
+++ b/arch/arm/mach-msm/board-8974-brcm-wifi.c
@@ -0,0 +1,326 @@
+/* linux/arch/arm/mach-msm/board-bcm-wifi.c
+*/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <asm/mach-types.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <linux/skbuff.h>
+#include <linux/wlan_plat.h>
+#include <linux/if.h> /*For IFHWADDRLEN */
+
+#include <linux/gpio.h>
+
+#define BCM_GPIO_WIFI_SHUTDOWN_N	41
+#define BCM_GPIO_WIFI_IRQ		42
+
+//#define GET_WIFI_MAC_ADDR_FROM_NV_ITEM	1
+
+int bcm_wifi_power(int on);
+int bcm_wifi_reset(int on);
+int bcm_wifi_set_carddetect(int on);
+
+#define WLAN_STATIC_SCAN_BUF0		5
+#define WLAN_STATIC_SCAN_BUF1		6
+#define WLAN_STATIC_DHD_INFO_BUF	7
+#define WLAN_SCAN_BUF_SIZE		(64 * 1024)
+#define WLAN_DHD_INFO_BUF_SIZE	(16 * 1024)
+#define PREALLOC_WLAN_SEC_NUM		4
+#define PREALLOC_WLAN_BUF_NUM		160
+#define PREALLOC_WLAN_SECTION_HEADER	24
+
+#define WLAN_SECTION_SIZE_0	(PREALLOC_WLAN_BUF_NUM * 128)
+#define WLAN_SECTION_SIZE_1	(PREALLOC_WLAN_BUF_NUM * 128)
+#define WLAN_SECTION_SIZE_2	(PREALLOC_WLAN_BUF_NUM * 512)
+#define WLAN_SECTION_SIZE_3	(PREALLOC_WLAN_BUF_NUM * 1024)
+
+#define DHD_SKB_HDRSIZE			336
+#define DHD_SKB_1PAGE_BUFSIZE	((PAGE_SIZE*1)-DHD_SKB_HDRSIZE)
+#define DHD_SKB_2PAGE_BUFSIZE	((PAGE_SIZE*2)-DHD_SKB_HDRSIZE)
+#define DHD_SKB_4PAGE_BUFSIZE	((PAGE_SIZE*4)-DHD_SKB_HDRSIZE)
+
+#define WLAN_SKB_BUF_NUM	17
+
+static struct sk_buff *wlan_static_skb[WLAN_SKB_BUF_NUM];
+
+struct wlan_mem_prealloc {
+	void *mem_ptr;
+	unsigned long size;
+};
+
+static struct wlan_mem_prealloc wlan_mem_array[PREALLOC_WLAN_SEC_NUM] = {
+	{NULL, (WLAN_SECTION_SIZE_0 + PREALLOC_WLAN_SECTION_HEADER)},
+	{NULL, (WLAN_SECTION_SIZE_1 + PREALLOC_WLAN_SECTION_HEADER)},
+	{NULL, (WLAN_SECTION_SIZE_2 + PREALLOC_WLAN_SECTION_HEADER)},
+	{NULL, (WLAN_SECTION_SIZE_3 + PREALLOC_WLAN_SECTION_HEADER)}
+};
+
+void *wlan_static_scan_buf0;
+void *wlan_static_scan_buf1;
+void *wlan_static_dhd_info_buf;
+
+static void *bcm_wifi_mem_prealloc(int section, unsigned long size)
+{
+	if (section == PREALLOC_WLAN_SEC_NUM)
+		return wlan_static_skb;
+
+	if (section == WLAN_STATIC_SCAN_BUF0)
+		return wlan_static_scan_buf0;
+
+	if (section == WLAN_STATIC_SCAN_BUF1)
+		return wlan_static_scan_buf1;
+
+	if (section == WLAN_STATIC_DHD_INFO_BUF) {
+		if (size > WLAN_DHD_INFO_BUF_SIZE) {
+			pr_err("request DHD_INFO size(%lu) is bigger than static size(%d).\n", size, WLAN_DHD_INFO_BUF_SIZE);
+			return NULL;
+		}
+		return wlan_static_dhd_info_buf;
+	}
+
+	if ((section < 0) || (section > PREALLOC_WLAN_SEC_NUM))
+		return NULL;
+
+	if (wlan_mem_array[section].size < size)
+		return NULL;
+
+	return wlan_mem_array[section].mem_ptr;
+}
+
+int __init bcm_init_wifi_mem(void)
+{
+	int i;
+	int j;
+
+	for (i = 0; i < 8; i++) {
+		wlan_static_skb[i] = dev_alloc_skb(DHD_SKB_1PAGE_BUFSIZE);
+		if (!wlan_static_skb[i])
+			goto err_skb_alloc;
+	}
+
+	for (; i < 16; i++) {
+		wlan_static_skb[i] = dev_alloc_skb(DHD_SKB_2PAGE_BUFSIZE);
+		if (!wlan_static_skb[i])
+			goto err_skb_alloc;
+	}
+
+	wlan_static_skb[i] = dev_alloc_skb(DHD_SKB_4PAGE_BUFSIZE);
+	if (!wlan_static_skb[i])
+		goto err_skb_alloc;
+
+	for (i = 0 ; i < PREALLOC_WLAN_SEC_NUM ; i++) {
+		wlan_mem_array[i].mem_ptr =
+				kmalloc(wlan_mem_array[i].size, GFP_KERNEL);
+
+		if (!wlan_mem_array[i].mem_ptr)
+			goto err_mem_alloc;
+	}
+
+	wlan_static_scan_buf0 = kmalloc(WLAN_SCAN_BUF_SIZE, GFP_KERNEL);
+	if (!wlan_static_scan_buf0)
+		goto err_mem_alloc;
+
+	wlan_static_scan_buf1 = kmalloc(WLAN_SCAN_BUF_SIZE, GFP_KERNEL);
+	if (!wlan_static_scan_buf1)
+		goto err_mem_alloc;
+
+	wlan_static_dhd_info_buf = kmalloc(WLAN_DHD_INFO_BUF_SIZE, GFP_KERNEL);
+	if (!wlan_static_dhd_info_buf)
+		goto err_mem_alloc;
+
+	printk(KERN_INFO"%s: WIFI MEM Allocated\n", __func__);
+	return 0;
+
+ err_mem_alloc:
+	pr_err("Failed to mem_alloc for WLAN\n");
+	for (j = 0 ; j < i ; j++)
+		kfree(wlan_mem_array[j].mem_ptr);
+
+	i = WLAN_SKB_BUF_NUM;
+
+ err_skb_alloc:
+	pr_err("Failed to skb_alloc for WLAN\n");
+	for (j = 0 ; j < i ; j++)
+		dev_kfree_skb(wlan_static_skb[j]);
+
+	return -ENOMEM;
+}
+
+static int bcm_wifi_cd = 0; /* WIFI virtual 'card detect' status */
+static void (*wifi_status_cb)(int card_present, void *dev_id);
+static void *wifi_status_cb_devid;
+static int detect_flag = 0;
+
+void set_detect_flag(void)
+{
+		detect_flag = 1;
+		printk("Broadcom wifi enter %s, flag = %d \n", __func__, detect_flag);
+}
+
+void clear_detect_flag(void)
+{
+		detect_flag = 0;
+		printk("Broadcom wifi enter %s, flag = %d \n", __func__, detect_flag);
+}
+EXPORT_SYMBOL(clear_detect_flag);
+
+int check_detect_flag(void)
+{
+		printk("Broadcom wifi enter %s, flag = %d \n", __func__, detect_flag);
+		return detect_flag;
+}
+EXPORT_SYMBOL(check_detect_flag);
+
+
+int bcm_wifi_status_register(
+			void (*callback)(int card_present, void *dev_id),
+			void *dev_id)
+{
+	if (wifi_status_cb)
+		return -EAGAIN;
+	wifi_status_cb = callback;
+	wifi_status_cb_devid = dev_id;
+	return 0;
+}
+
+EXPORT_SYMBOL(bcm_wifi_status_register);
+unsigned int bcm_wifi_status(struct device *dev)
+{
+	return bcm_wifi_cd;
+}
+
+
+int bcm_wifi_set_carddetect(int val)
+{
+	pr_info("%s: %d\n", __func__, val);
+	bcm_wifi_cd = val;
+	if (wifi_status_cb) {
+		set_detect_flag();
+		wifi_status_cb(val, wifi_status_cb_devid);
+	} else
+		pr_warning("%s: Nobody to notify\n", __func__);
+	return 0;
+}
+
+
+int bcm_wifi_power(int on)
+{
+	printk("%s:  Broadcom wifi power %d \n", __func__, on);
+
+	if(on) {
+		if((gpio_request(BCM_GPIO_WIFI_SHUTDOWN_N,"Broadcom wifi")) < 0) {
+			printk("request fail \n");
+		} else {
+			printk("Broadcom wifi request reg_on  success \n");
+			gpio_direction_output(BCM_GPIO_WIFI_SHUTDOWN_N, 0);
+			mdelay(10);
+			gpio_direction_output(BCM_GPIO_WIFI_SHUTDOWN_N, on);
+			mdelay(200);
+		}
+	} else {
+			gpio_direction_output(BCM_GPIO_WIFI_SHUTDOWN_N, 0);
+			gpio_free(BCM_GPIO_WIFI_SHUTDOWN_N);
+	}
+
+	printk("Broadcom wifi gpio_set_value = %d \n", 
+		gpio_get_value(BCM_GPIO_WIFI_SHUTDOWN_N));
+
+	return 0;
+}
+
+
+int bcm_wifi_reset(int on)
+{
+	printk("%s: enter\n", __func__);
+	bcm_wifi_power(on);
+	return 0;
+}
+
+#ifdef GET_WIFI_MAC_ADDR_FROM_NV_ITEM
+static unsigned char bcm_mac_addr[IFHWADDRLEN] = { 0x11,0x22,0x33,0x44,0x55,0x66 };
+
+static int bcm_wifi_get_mac_addr(unsigned char *buf)
+{
+	int rc = 0;
+	unsigned int data1, data2;
+
+	if (!buf){
+		printk("%s, null parameter !!\n", __func__);	
+		return -EFAULT;
+	}
+
+    	data2 = (1<<31);//for wifi mac   
+	rc = msm_proc_comm(PCOM_CUSTOMER_CMD1, &data1, &data2);
+	printk("================zbs, rc=%d\n", rc);
+	if(!rc) {
+		bcm_mac_addr[5] = (unsigned char)((data2>>8)&0xff); 
+		bcm_mac_addr[4] = (unsigned char)(data2&0xff); 
+ 		bcm_mac_addr[3] = (unsigned char)((data1>>24)&0xff); 
+		bcm_mac_addr[2] = (unsigned char)((data1>>16)&0xff); 
+		bcm_mac_addr[1] = (unsigned char)((data1>>8)&0xff); 
+		bcm_mac_addr[0] = (unsigned char)(data1&0xff); 
+
+		memcpy(buf, bcm_mac_addr, IFHWADDRLEN);
+		printk("wifi mac: %x:%x:%x:%x:%x:%x\n", bcm_mac_addr[0], bcm_mac_addr[1], bcm_mac_addr[2], bcm_mac_addr[3], bcm_mac_addr[4], bcm_mac_addr[5]);
+				
+		return 0;
+	} else {
+ 		printk("%s fail !!\n", __func__);		
+		return -EFAULT;
+	}		
+}
+#endif
+
+static struct resource bcm_wifi_resources[] = {
+	[0] = {
+		.name		= "bcmdhd_wlan_irq",
+		//.start		= MSM_GPIO_TO_INT(BCM_GPIO_WIFI_IRQ),
+		//.end		= MSM_GPIO_TO_INT(BCM_GPIO_WIFI_IRQ),
+		.flags          = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL | IORESOURCE_IRQ_SHAREABLE,
+		//.flags          = IRQF_TRIGGER_FALLING,
+
+	},
+};
+
+static struct wifi_platform_data bcm_wifi_control = {
+	.set_power      = bcm_wifi_power,
+	.set_reset      = bcm_wifi_reset,
+	.set_carddetect = bcm_wifi_set_carddetect,
+	.mem_prealloc	= bcm_wifi_mem_prealloc,
+#ifdef GET_WIFI_MAC_ADDR_FROM_NV_ITEM	
+	.get_mac_addr	= bcm_wifi_get_mac_addr,
+#endif 	
+};
+
+static struct platform_device bcm_wifi_device = {
+        .name           = "bcmdhd_wlan",
+        .id             = 1,
+        .num_resources  = ARRAY_SIZE(bcm_wifi_resources),
+        .resource       = bcm_wifi_resources,
+        .dev            = {
+                .platform_data = &bcm_wifi_control,
+        },
+};
+
+int __init bcm_wifi_init(void)
+{
+	int ret;
+
+	pr_err("++++%s++++ \n", __func__);
+	gpio_request(BCM_GPIO_WIFI_IRQ, "oob_irq");
+	gpio_direction_input(BCM_GPIO_WIFI_IRQ);
+
+	bcm_wifi_resources[0].start = gpio_to_irq(BCM_GPIO_WIFI_IRQ);
+	bcm_wifi_resources[0].end = gpio_to_irq(BCM_GPIO_WIFI_IRQ);
+	gpio_set_value(BCM_GPIO_WIFI_SHUTDOWN_N, 0);
+	bcm_init_wifi_mem();
+	ret = platform_device_register(&bcm_wifi_device);
+	pr_err("----%s----\n", __func__);
+        return ret;
+}
+
+//late_initcall(bcm_wifi_init);
diff --git a/arch/arm/mach-msm/board/Kconfig b/arch/arm/mach-msm/board/Kconfig
new file mode 100755
index 0000000..25c83cf
--- /dev/null
+++ b/arch/arm/mach-msm/board/Kconfig
@@ -0,0 +1,39 @@
+#
+# Board configuration
+#
+menuconfig ARCH_MSM8974
+	bool "Select the Supported Board of Nubia"
+	help
+	  Say Y here, and a list of supported Boards will be displayed.
+	  This option doesn't affect the kernel.
+
+	  If unsure, say Y.
+
+if ARCH_MSM8974
+	  
+config ARCH_MSM8974_ZTEMT
+	bool "ZTEMT ARCH_MSM8974"
+	help
+	  Support for ZTEMT MSM8974AB/AC MTP board.
+
+choice
+	depends on ARCH_MSM8974_ZTEMT
+	prompt "MSM8974_MTP Based ZTEMT Board"
+
+config BOARD_ZTEMT_NX503A
+	bool "ZTEMT NX503A"
+	help
+	  Support for the ZTEMT NX503A board.	
+endchoice	
+
+config ZTEMT_RESTART
+	bool "ZTEMT restart"
+	help
+	  Support for the ZTEMT restart
+
+config EMMC_UNSUPPORTED_HPI
+	bool "ZTEMT emmc unsupported hpi feature"
+	help
+	  emmc unsupported hpi feature.
+endif
+
diff --git a/arch/arm/mach-msm/board/Makefile b/arch/arm/mach-msm/board/Makefile
new file mode 100755
index 0000000..be160bb
--- /dev/null
+++ b/arch/arm/mach-msm/board/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_BOARD_ZTEMT_NX503A) += board-8974-NX503A.o board-8974-gpiomux-NX503A.o clock-8974-NX503A.o
\ No newline at end of file
diff --git a/arch/arm/mach-msm/board/board-8974-NX503A.c b/arch/arm/mach-msm/board/board-8974-NX503A.c
new file mode 100755
index 0000000..53d4b1c
--- /dev/null
+++ b/arch/arm/mach-msm/board/board-8974-NX503A.c
@@ -0,0 +1,203 @@
+/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/memory.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/krait-regulator.h>
+#include <linux/msm_tsens.h>
+#include <linux/msm_thermal.h>
+#include <asm/mach/map.h>
+#include <asm/hardware/gic.h>
+#include <asm/mach/map.h>
+#include <asm/mach/arch.h>
+#include <mach/board.h>
+#include <mach/gpiomux.h>
+#include <mach/msm_iomap.h>
+#ifdef CONFIG_ION_MSM
+#include <mach/ion.h>
+#endif
+#include <mach/msm_memtypes.h>
+#include <mach/msm_smd.h>
+#include <mach/restart.h>
+#include <mach/rpm-smd.h>
+#include <mach/rpm-regulator-smd.h>
+#include <mach/socinfo.h>
+#include <mach/msm_smem.h>
+#include "../board-dt.h"
+#include "../clock.h"
+#include "../devices.h"
+#include "../spm.h"
+#include "../pm.h"
+#include "../modem_notifier.h"
+#include "../platsmp.h"
+
+
+static struct memtype_reserve msm8974_reserve_table[] __initdata = {
+	[MEMTYPE_SMI] = {
+	},
+	[MEMTYPE_EBI0] = {
+		.flags	=	MEMTYPE_FLAGS_1M_ALIGN,
+	},
+	[MEMTYPE_EBI1] = {
+		.flags	=	MEMTYPE_FLAGS_1M_ALIGN,
+	},
+};
+
+static int msm8974_paddr_to_memtype(phys_addr_t paddr)
+{
+	return MEMTYPE_EBI1;
+}
+
+static struct reserve_info msm8974_reserve_info __initdata = {
+	.memtype_reserve_table = msm8974_reserve_table,
+	.paddr_to_memtype = msm8974_paddr_to_memtype,
+};
+
+void __init msm_8974_reserve(void)
+{
+	reserve_info = &msm8974_reserve_info;
+	of_scan_flat_dt(dt_scan_for_memory_reserve, msm8974_reserve_table);
+	msm_reserve();
+}
+
+static void __init msm8974_early_memory(void)
+{
+	reserve_info = &msm8974_reserve_info;
+	of_scan_flat_dt(dt_scan_for_memory_hole, msm8974_reserve_table);
+}
+
+/*
+ * Used to satisfy dependencies for devices that need to be
+ * run early or in a particular order. Most likely your device doesn't fall
+ * into this category, and thus the driver should not be added here. The
+ * EPROBE_DEFER can satisfy most dependency problems.
+ */
+void __init msm8974_add_drivers(void)
+{
+	msm_smem_init();
+	msm_init_modem_notifier_list();
+	msm_smd_init();
+	msm_rpm_driver_init();
+	msm_pm_sleep_status_init();
+	rpm_regulator_smd_driver_init();
+	msm_spm_device_init();
+	krait_power_init();
+	if (of_board_is_rumi())
+		msm_clock_init(&msm8974_rumi_clock_init_data);
+	else
+		msm_clock_init(&msm8974_clock_init_data);
+	tsens_tm_init_driver();
+	msm_thermal_device_init();
+}
+
+static struct of_dev_auxdata msm_hsic_host_adata[] = {
+	OF_DEV_AUXDATA("qcom,hsic-host", 0xF9A00000, "msm_hsic_host", NULL),
+	{}
+};
+
+static struct of_dev_auxdata msm8974_auxdata_lookup[] __initdata = {
+	OF_DEV_AUXDATA("qcom,hsusb-otg", 0xF9A55000, \
+			"msm_otg", NULL),
+	OF_DEV_AUXDATA("qcom,ehci-host", 0xF9A55000, \
+			"msm_ehci_host", NULL),
+	OF_DEV_AUXDATA("qcom,dwc-usb3-msm", 0xF9200000, \
+			"msm_dwc3", NULL),
+	OF_DEV_AUXDATA("qcom,usb-bam-msm", 0xF9304000, \
+			"usb_bam", NULL),
+	OF_DEV_AUXDATA("qcom,spi-qup-v2", 0xF9924000, \
+			"spi_qsd.1", NULL),
+	OF_DEV_AUXDATA("qcom,msm-sdcc", 0xF9824000, \
+			"msm_sdcc.1", NULL),
+	OF_DEV_AUXDATA("qcom,msm-sdcc", 0xF98A4000, \
+			"msm_sdcc.2", NULL),
+	OF_DEV_AUXDATA("qcom,msm-sdcc", 0xF9864000, \
+			"msm_sdcc.3", NULL),
+	OF_DEV_AUXDATA("qcom,msm-sdcc", 0xF98E4000, \
+			"msm_sdcc.4", NULL),
+	OF_DEV_AUXDATA("qcom,sdhci-msm", 0xF9824900, \
+			"msm_sdcc.1", NULL),
+	OF_DEV_AUXDATA("qcom,sdhci-msm", 0xF98A4900, \
+			"msm_sdcc.2", NULL),
+	OF_DEV_AUXDATA("qcom,sdhci-msm", 0xF9864900, \
+			"msm_sdcc.3", NULL),
+	OF_DEV_AUXDATA("qcom,sdhci-msm", 0xF98E4900, \
+			"msm_sdcc.4", NULL),
+	OF_DEV_AUXDATA("qcom,msm-rng", 0xF9BFF000, \
+			"msm_rng", NULL),
+	OF_DEV_AUXDATA("qcom,qseecom", 0xFE806000, \
+			"qseecom", NULL),
+	OF_DEV_AUXDATA("qcom,mdss_mdp", 0xFD900000, "mdp.0", NULL),
+	OF_DEV_AUXDATA("qcom,msm-tsens", 0xFC4A8000, \
+			"msm-tsens", NULL),
+	OF_DEV_AUXDATA("qcom,qcedev", 0xFD440000, \
+			"qcedev.0", NULL),
+	OF_DEV_AUXDATA("qcom,qcrypto", 0xFD440000, \
+			"qcrypto.0", NULL),
+	OF_DEV_AUXDATA("qcom,hsic-host", 0xF9A00000, \
+			"msm_hsic_host", NULL),
+	OF_DEV_AUXDATA("qcom,hsic-smsc-hub", 0, "msm_smsc_hub",
+			msm_hsic_host_adata),
+	{}
+};
+
+static void __init msm8974_map_io(void)
+{
+	msm_map_8974_io();
+}
+
+extern int __init bcm_wifi_init(void);
+void __init msm8974_init(void)
+{
+	struct of_dev_auxdata *adata = msm8974_auxdata_lookup;
+
+	if (socinfo_init() < 0)
+		pr_err("%s: socinfo_init() failed\n", __func__);
+
+	msm_8974_init_gpiomux();
+	regulator_has_full_constraints();
+	board_dt_populate(adata);
+	bcm_wifi_init(); //add for wifi init. 12-08-2013 pengqin
+	msm8974_add_drivers();
+}
+
+void __init msm8974_init_very_early(void)
+{
+	msm8974_early_memory();
+}
+
+static const char *msm8974_dt_match[] __initconst = {
+	"qcom,msm8974",
+	"qcom,apq8074",
+	NULL
+};
+
+DT_MACHINE_START(MSM8974_DT, "Qualcomm MSM 8974 (Flattened Device Tree)")
+	.map_io = msm8974_map_io,
+	.init_irq = msm_dt_init_irq,
+	.init_machine = msm8974_init,
+	.handle_irq = gic_handle_irq,
+	.timer = &msm_dt_timer,
+	.dt_compat = msm8974_dt_match,
+	.reserve = msm_8974_reserve,
+	.init_very_early = msm8974_init_very_early,
+	.restart = msm_restart,
+	.smp = &msm8974_smp_ops,
+MACHINE_END
diff --git a/arch/arm/mach-msm/board/board-8974-gpiomux-NX503A.c b/arch/arm/mach-msm/board/board-8974-gpiomux-NX503A.c
new file mode 100644
index 0000000..99e5533
--- /dev/null
+++ b/arch/arm/mach-msm/board/board-8974-gpiomux-NX503A.c
@@ -0,0 +1,1764 @@
+/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <mach/board.h>
+#include <mach/gpio.h>
+#include <mach/gpiomux.h>
+#include <mach/socinfo.h>
+
+#define KS8851_IRQ_GPIO 94
+
+static struct gpiomux_setting ap2mdm_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_NONE,
+	.dir = GPIOMUX_OUT_LOW,
+};
+/*
+static struct gpiomux_setting mdm2ap_status_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_NONE,
+	.dir = GPIOMUX_OUT_LOW,
+};
+*/
+static struct gpiomux_setting mdm2ap_errfatal_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_NONE,
+	.dir = GPIOMUX_OUT_LOW,
+};
+
+static struct gpiomux_setting mdm2ap_pblrdy = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_NONE,
+	.dir = GPIOMUX_IN,
+};
+
+
+static struct gpiomux_setting ap2mdm_soft_reset_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_NONE,
+	.dir = GPIOMUX_OUT_LOW,
+};
+
+static struct gpiomux_setting ap2mdm_wakeup = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_NONE,
+	.dir = GPIOMUX_OUT_LOW,
+};
+
+static struct msm_gpiomux_config mdm_configs[] __initdata = {
+	/* AP2MDM_STATUS */
+	{
+		.gpio = 105,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &ap2mdm_cfg,
+		}
+	},
+	/* MDM2AP_STATUS */
+	/* liaojs
+	{
+		.gpio = 46,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &mdm2ap_status_cfg,
+		}
+	},
+	*/
+	/* MDM2AP_ERRFATAL */
+	{
+		.gpio = 82,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &mdm2ap_errfatal_cfg,
+		}
+	},
+	/* AP2MDM_ERRFATAL */
+	{
+		.gpio = 106,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &ap2mdm_cfg,
+		}
+	},
+	/* AP2MDM_SOFT_RESET, aka AP2MDM_PON_RESET_N */
+	{
+		.gpio = 24,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &ap2mdm_soft_reset_cfg,
+		}
+	},
+	/* AP2MDM_WAKEUP */
+	{
+		.gpio = 104,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &ap2mdm_wakeup,
+		}
+	},
+	/* MDM2AP_PBL_READY*/
+	{
+		.gpio = 80,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &mdm2ap_pblrdy,
+		}
+	},
+};
+
+static struct gpiomux_setting gpio_uart_config = {
+	.func = GPIOMUX_FUNC_2,
+	.drv = GPIOMUX_DRV_16MA,
+	.pull = GPIOMUX_PULL_NONE,
+	.dir = GPIOMUX_OUT_HIGH,
+};
+
+static struct gpiomux_setting slimbus = {
+	.func = GPIOMUX_FUNC_1,
+	.drv = GPIOMUX_DRV_8MA,
+	.pull = GPIOMUX_PULL_KEEPER,
+};
+
+#if defined(CONFIG_KS8851) || defined(CONFIG_KS8851_MODULE)
+static struct gpiomux_setting gpio_eth_config = {
+	.pull = GPIOMUX_PULL_UP,
+	.drv = GPIOMUX_DRV_2MA,
+	.func = GPIOMUX_FUNC_GPIO,
+};
+
+#ifdef CONFIG_ZTEMT_LCD_POWER_CONTRL
+/*avdd neg ctl by gpio8 board2 add ,mayu 6.25*/
+#else
+/*qcom ori*/
+static struct gpiomux_setting gpio_spi_cs2_config = {
+	.func = GPIOMUX_FUNC_4,
+	.drv = GPIOMUX_DRV_6MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+#endif
+static struct gpiomux_setting gpio_spi_config = {
+	.func = GPIOMUX_FUNC_1,
+	.drv = GPIOMUX_DRV_12MA,
+	.pull = GPIOMUX_PULL_NONE,
+};
+static struct gpiomux_setting gpio_spi_susp_config = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+
+#ifdef CONFIG_ZTEMT_LCD_POWER_CONTRL
+/*avdd neg ctl by gpio8 board2 add ,mayu 6.25*/
+#else
+/*qcom ori*/
+static struct gpiomux_setting gpio_spi_cs1_config = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_6MA,
+	.pull = GPIOMUX_PULL_UP,
+};
+#endif
+static struct msm_gpiomux_config msm_eth_configs[] = {
+	{
+		.gpio = KS8851_IRQ_GPIO,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_eth_config,
+		}
+	},
+};
+#endif
+
+static struct gpiomux_setting gpio_suspend_config[] = {
+	{
+		.func = GPIOMUX_FUNC_GPIO,  /* IN-NP */
+		.drv = GPIOMUX_DRV_2MA,
+		.pull = GPIOMUX_PULL_NONE,
+	},
+	{
+		.func = GPIOMUX_FUNC_GPIO,  /* O-LOW */
+		.drv = GPIOMUX_DRV_2MA,
+		.pull = GPIOMUX_PULL_NONE,
+		.dir = GPIOMUX_OUT_LOW,
+	},
+};
+
+static struct gpiomux_setting gpio_epm_config = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv  = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_NONE,
+	.dir = GPIOMUX_OUT_HIGH,
+};
+
+static struct gpiomux_setting gpio_epm_marker_config = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv  = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_NONE,
+	.dir = GPIOMUX_OUT_HIGH,
+};
+
+static struct gpiomux_setting wcnss_5wire_suspend_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv  = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_UP,
+};
+
+static struct gpiomux_setting wcnss_5wire_active_cfg = {
+	.func = GPIOMUX_FUNC_1,
+	.drv  = GPIOMUX_DRV_6MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+
+static struct gpiomux_setting ath_gpio_active_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_UP,
+};
+
+static struct gpiomux_setting ath_gpio_suspend_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+
+static struct gpiomux_setting gpio_i2c_config = {
+	.func = GPIOMUX_FUNC_3,
+	/*
+	 * Please keep I2C GPIOs drive-strength at minimum (2ma). It is a
+	 * workaround for HW issue of glitches caused by rapid GPIO current-
+	 * change.
+	 */
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_NONE,
+};
+
+static struct gpiomux_setting gpio_i2c_act_config = {
+	.func = GPIOMUX_FUNC_3,
+	/*
+	 * Please keep I2C GPIOs drive-strength at minimum (2ma). It is a
+	 * workaround for HW issue of glitches caused by rapid GPIO current-
+	 * change.
+	 */
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_UP,
+};
+
+
+static struct gpiomux_setting lcd_en_act_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_8MA,
+	.pull = GPIOMUX_PULL_NONE,
+	.dir = GPIOMUX_OUT_HIGH,
+};
+
+static struct gpiomux_setting lcd_en_sus_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+#ifdef CONFIG_ZTEMT_LCD_POWER_CONTRL
+/*avdd neg ctl board2 add ,mayu 6.25*/
+static struct gpiomux_setting lcd_avdd_neg_en_act_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_8MA,
+	.pull = GPIOMUX_PULL_NONE,
+	.dir = GPIOMUX_OUT_HIGH,
+};
+
+static struct gpiomux_setting lcd_avdd_neg_en_sus_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+#endif
+static struct gpiomux_setting atmel_resout_sus_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_6MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+
+static struct gpiomux_setting atmel_resout_act_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_6MA,
+	.pull = GPIOMUX_PULL_UP,
+};
+
+static struct gpiomux_setting atmel_int_act_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_8MA,
+	.pull = GPIOMUX_PULL_UP,
+};
+
+static struct gpiomux_setting atmel_int_sus_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+
+static struct gpiomux_setting taiko_reset = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_6MA,
+	.pull = GPIOMUX_PULL_NONE,
+	.dir = GPIOMUX_OUT_LOW,
+};
+
+static struct gpiomux_setting taiko_int = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_NONE,
+};
+static struct gpiomux_setting hap_lvl_shft_suspended_config = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+
+static struct gpiomux_setting hap_lvl_shft_active_config = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_8MA,
+	.pull = GPIOMUX_PULL_UP,
+};
+static struct msm_gpiomux_config hap_lvl_shft_config[] __initdata = {
+	{
+		.gpio = 86,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &hap_lvl_shft_suspended_config,
+			[GPIOMUX_ACTIVE] = &hap_lvl_shft_active_config,
+		},
+	},
+};
+
+static struct msm_gpiomux_config msm_touch_configs[] __initdata = {
+	{
+		.gpio      = 60,		/* TOUCH RESET */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &atmel_resout_act_cfg,
+			[GPIOMUX_SUSPENDED] = &atmel_resout_sus_cfg,
+		},
+	},
+	{
+		.gpio      = 61,		/* TOUCH IRQ */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &atmel_int_act_cfg,
+			[GPIOMUX_SUSPENDED] = &atmel_int_sus_cfg,
+		},
+	},
+
+};
+#ifdef CONFIG_NFC_PN544
+static struct msm_gpiomux_config msm_nxp_configs[] __initdata = {
+	{
+		.gpio      = 85,		/* NXP VEN */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &atmel_resout_act_cfg,
+			[GPIOMUX_SUSPENDED] = &atmel_resout_sus_cfg,
+		},
+	},
+	{
+		.gpio      = 13,		/* NXP GPIO4 */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &atmel_resout_act_cfg,
+			[GPIOMUX_SUSPENDED] = &atmel_resout_sus_cfg,
+		},
+	},
+	{
+		//changed by chengdongsheng 20130904 for NFC_IQR chaned to GPIO80
+		.gpio      = 80,		/* NXP IRQ */
+		//.gpio      = 68,		/* NXP IRQ */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &atmel_int_act_cfg,
+			[GPIOMUX_SUSPENDED] = &atmel_int_sus_cfg,
+		},
+	},
+
+};
+#endif
+static struct gpiomux_setting hsic_sus_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+
+static struct gpiomux_setting hsic_act_cfg = {
+	.func = GPIOMUX_FUNC_1,
+	.drv = GPIOMUX_DRV_12MA,
+	.pull = GPIOMUX_PULL_NONE,
+};
+
+static struct gpiomux_setting hsic_hub_act_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_UP,
+	.dir = GPIOMUX_IN,
+};
+
+static struct gpiomux_setting hsic_resume_act_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_DOWN,
+	.dir = GPIOMUX_OUT_LOW,
+};
+
+static struct gpiomux_setting hsic_resume_susp_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_NONE,
+};
+#ifdef CONFIG_SND_SOC_ES325
+static struct msm_gpiomux_config msm_es325_configs[] __initdata = {
+	{
+		.gpio      = 55,		/* NXP VEN */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &atmel_resout_act_cfg,
+			[GPIOMUX_SUSPENDED] = &atmel_resout_sus_cfg,
+		},
+	},
+	{
+		.gpio      = 56,		/* NXP GPIO4 */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &atmel_resout_act_cfg,
+			[GPIOMUX_SUSPENDED] = &atmel_resout_sus_cfg,
+		},
+	},
+	{
+		//changed by chengdongsheng 20130904 for NFC_IQR chaned to GPIO80
+		.gpio      = 92,		/* NXP IRQ */
+		//.gpio      = 68,		/* NXP IRQ */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &atmel_int_act_cfg,
+			[GPIOMUX_SUSPENDED] = &atmel_int_sus_cfg,
+		},
+	},
+
+};
+#endif
+
+static struct msm_gpiomux_config msm_hsic_configs[] = {
+	{
+		.gpio = 144,               /*HSIC_STROBE */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &hsic_act_cfg,
+			[GPIOMUX_SUSPENDED] = &hsic_sus_cfg,
+		},
+	},
+	{
+		.gpio = 145,               /* HSIC_DATA */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &hsic_act_cfg,
+			[GPIOMUX_SUSPENDED] = &hsic_sus_cfg,
+		},
+	},
+	{
+		.gpio = 80,
+		.settings = {
+			[GPIOMUX_ACTIVE] = &hsic_resume_act_cfg,
+			[GPIOMUX_SUSPENDED] = &hsic_resume_susp_cfg,
+		},
+	},
+};
+
+static struct msm_gpiomux_config msm_hsic_hub_configs[] = {
+	{
+		.gpio = 50,               /* HSIC_HUB_INT_N */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &hsic_hub_act_cfg,
+			[GPIOMUX_SUSPENDED] = &hsic_sus_cfg,
+		},
+	},
+};
+
+static struct gpiomux_setting mhl_suspend_config = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+
+static struct gpiomux_setting mhl_active_1_cfg = {
+	.func = GPIOMUX_FUNC_1,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_UP,
+	.dir = GPIOMUX_OUT_HIGH,
+};
+
+static struct gpiomux_setting hdmi_suspend_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+
+static struct gpiomux_setting hdmi_active_1_cfg = {
+	.func = GPIOMUX_FUNC_1,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_UP,
+};
+
+static struct gpiomux_setting hdmi_active_2_cfg = {
+	.func = GPIOMUX_FUNC_1,
+	.drv = GPIOMUX_DRV_16MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+/* ZTEMT Added by LiuYongfeng, 2013/8/9 */
+static struct gpiomux_setting slimport_suspend_config = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_UP,	
+};
+
+static struct gpiomux_setting slimport_active_1_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_UP,
+	.dir = GPIOMUX_OUT_HIGH,
+};
+
+/*disable slimport ic by pull up the gpio anx7808 pwr, in order to enable the usb port while system bring up*/
+static struct msm_gpiomux_config msm_slimport_default_configs[] __initdata = {
+	{
+		/*slimport anx7808 en*/
+		.gpio = 14,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &slimport_suspend_config,
+			[GPIOMUX_ACTIVE]    = &slimport_active_1_cfg,
+		},
+
+	},
+	{
+		/* slimport-anx7808 pwr */
+		.gpio = 26,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &slimport_suspend_config,
+			[GPIOMUX_ACTIVE]    = &slimport_active_1_cfg,
+		},
+	},
+};
+/* ZTEMT END */
+static struct msm_gpiomux_config msm_mhl_configs[] __initdata = {
+	{
+		/* mhl-sii8334 pwr */
+		.gpio = 12,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &mhl_suspend_config,
+			[GPIOMUX_ACTIVE]    = &mhl_active_1_cfg,
+		},
+	},
+	{
+		/* mhl-sii8334 intr */
+		.gpio = 82,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &mhl_suspend_config,
+			[GPIOMUX_ACTIVE]    = &mhl_active_1_cfg,
+		},
+	},
+};
+
+
+static struct msm_gpiomux_config msm_hdmi_configs[] __initdata = {
+	{
+		.gpio = 31,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &hdmi_active_1_cfg,
+			[GPIOMUX_SUSPENDED] = &hdmi_suspend_cfg,
+		},
+	},
+	{
+		.gpio = 32,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &hdmi_active_1_cfg,
+			[GPIOMUX_SUSPENDED] = &hdmi_suspend_cfg,
+		},
+	},
+	{
+		.gpio = 33,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &hdmi_active_1_cfg,
+			[GPIOMUX_SUSPENDED] = &hdmi_suspend_cfg,
+		},
+	},
+	{
+		.gpio = 34,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &hdmi_active_2_cfg,
+			[GPIOMUX_SUSPENDED] = &hdmi_suspend_cfg,
+		},
+	},
+};
+#if 0 //liaojunsheng
+static struct gpiomux_setting gpio_uart7_active_cfg = {
+	.func = GPIOMUX_FUNC_3,
+	.drv = GPIOMUX_DRV_8MA,
+	.pull = GPIOMUX_PULL_NONE,
+};
+
+static struct gpiomux_setting gpio_uart7_suspend_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+
+static struct msm_gpiomux_config msm_blsp2_uart7_configs[] __initdata = {
+	{
+		.gpio	= 41,	/* BLSP2 UART7 TX */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &gpio_uart7_active_cfg,
+			[GPIOMUX_SUSPENDED] = &gpio_uart7_suspend_cfg,
+		},
+	},
+	{
+		.gpio	= 42,	/* BLSP2 UART7 RX */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &gpio_uart7_active_cfg,
+			[GPIOMUX_SUSPENDED] = &gpio_uart7_suspend_cfg,
+		},
+	},
+	{
+		.gpio	= 43,	/* BLSP2 UART7 CTS */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &gpio_uart7_active_cfg,
+			[GPIOMUX_SUSPENDED] = &gpio_uart7_suspend_cfg,
+		},
+	},
+	{
+		.gpio	= 44,	/* BLSP2 UART7 RFR */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &gpio_uart7_active_cfg,
+			[GPIOMUX_SUSPENDED] = &gpio_uart7_suspend_cfg,
+		},
+	},
+};
+#endif
+
+#if 0
+static struct msm_gpiomux_config msm_rumi_blsp_configs[] __initdata = {
+	{
+		.gpio      = 45,	/* BLSP2 UART8 TX */
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_uart_config,
+		},
+	},
+	{
+		.gpio      = 46,	/* BLSP2 UART8 RX */
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_uart_config,
+		},
+	},
+};
+#endif 
+
+
+#if 1
+
+static struct gpiomux_setting bt4339_reset_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_8MA,
+	.pull = GPIOMUX_PULL_NONE,
+};
+
+static struct gpiomux_setting bcm_sleep_gpio_active_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_NONE,
+};
+
+static struct gpiomux_setting bcm_sleep_gpio_suspend_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_NONE,
+};
+static struct gpiomux_setting bcm_lte_gpio_suspend_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_NONE,
+	.dir = GPIOMUX_IN,
+};
+static struct msm_gpiomux_config bcm_sleep_gpio_configs[] = {
+	{
+		.gpio = 130,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &bcm_lte_gpio_suspend_cfg,
+			[GPIOMUX_SUSPENDED] = &bcm_lte_gpio_suspend_cfg,
+		},
+	},	
+	{
+		.gpio = 131,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &bcm_lte_gpio_suspend_cfg,
+			[GPIOMUX_SUSPENDED] = &bcm_lte_gpio_suspend_cfg,
+		},
+	},	
+	{
+		.gpio = 132,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &bcm_lte_gpio_suspend_cfg,
+			[GPIOMUX_SUSPENDED] = &bcm_lte_gpio_suspend_cfg,
+		},
+	},
+	{
+		.gpio = 25,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &bcm_sleep_gpio_active_cfg,
+			[GPIOMUX_SUSPENDED] = &bcm_sleep_gpio_suspend_cfg,
+		},
+	},
+	{
+		.gpio = 43,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &bcm_sleep_gpio_active_cfg,
+			[GPIOMUX_SUSPENDED] = &bcm_sleep_gpio_suspend_cfg,
+		},
+	},
+	{
+		.gpio = 44,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &bcm_sleep_gpio_active_cfg,
+			[GPIOMUX_SUSPENDED] = &bcm_sleep_gpio_suspend_cfg,
+		},
+	},	
+	{
+		.gpio      = 69,	/* BT_RESET */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &bt4339_reset_cfg ,
+			[GPIOMUX_SUSPENDED] = &bt4339_reset_cfg,
+		},
+	}
+};
+#endif 
+
+#if 1
+static struct gpiomux_setting gpio_uart8_active_cfg = {
+	.func = GPIOMUX_FUNC_2,
+	.drv = GPIOMUX_DRV_8MA,
+	.pull = GPIOMUX_PULL_NONE,
+};
+
+static struct gpiomux_setting gpio_uart8_suspend_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+
+static struct msm_gpiomux_config msm_blsp2_uart8_configs[] __initdata = {
+	{
+		.gpio      = 45,	/* BLSP2 UART8 TX */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &gpio_uart8_active_cfg,
+			[GPIOMUX_SUSPENDED] = &gpio_uart8_suspend_cfg,
+		},
+	},
+	{
+		.gpio      = 46,	/* BLSP2 UART8 RX */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &gpio_uart8_active_cfg,
+			[GPIOMUX_SUSPENDED] = &gpio_uart8_suspend_cfg,
+		},
+	},
+	{
+		.gpio      = 47,	/* BLSP2 UART8 CTS */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &gpio_uart8_active_cfg,
+			[GPIOMUX_SUSPENDED] = &gpio_uart8_suspend_cfg,
+		},
+	},
+	{
+		.gpio      = 48,	/* BLSP2 UART8 RFR */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &gpio_uart8_active_cfg,
+			[GPIOMUX_SUSPENDED] = &gpio_uart8_suspend_cfg,
+		},
+	}
+};
+#endif
+static struct msm_gpiomux_config msm_lcd_configs[] __initdata = {
+	{
+		.gpio = 58,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &lcd_en_act_cfg,
+			[GPIOMUX_SUSPENDED] = &lcd_en_sus_cfg,
+		},
+	},
+#ifdef CONFIG_ZTEMT_LCD_POWER_CONTRL
+/*avdd neg ctl board2 add ,mayu 6.25*/
+	{
+		.gpio = 8,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &lcd_avdd_neg_en_act_cfg ,
+			[GPIOMUX_SUSPENDED] = &lcd_avdd_neg_en_sus_cfg ,
+		},
+	},
+#endif
+};
+
+static struct msm_gpiomux_config msm_epm_configs[] __initdata = {
+	{
+		.gpio      = 81,		/* EPM enable */
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_epm_config,
+		},
+	},
+	{
+		.gpio      = 85,		/* EPM MARKER2 */
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_epm_marker_config,
+		},
+	},
+	{
+		.gpio      = 96,		/* EPM MARKER1 */
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_epm_marker_config,
+		},
+	},
+};
+
+static struct msm_gpiomux_config msm_blsp_configs[] __initdata = {
+#if defined(CONFIG_KS8851) || defined(CONFIG_KS8851_MODULE)
+	{
+		.gpio      = 0,		/* BLSP1 QUP SPI_DATA_MOSI */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &gpio_spi_config,
+			[GPIOMUX_SUSPENDED] = &gpio_spi_susp_config,
+		},
+	},
+	{
+		.gpio      = 1,		/* BLSP1 QUP SPI_DATA_MISO */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &gpio_spi_config,
+			[GPIOMUX_SUSPENDED] = &gpio_spi_susp_config,
+		},
+	},
+#ifdef CONFIG_ZTEMT_LCD_POWER_CONTRL
+/*avdd neg ctl by gpio8 board2 add ,mayu 6.25*/
+#else
+/*qcom ori*/
+	{
+		.gpio      = 3,		/* BLSP1 QUP SPI_CLK */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &gpio_spi_config,
+			[GPIOMUX_SUSPENDED] = &gpio_spi_susp_config,
+		},
+	},
+	{
+		.gpio      = 9,		/* BLSP1 QUP SPI_CS2A_N */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &gpio_spi_cs2_config,
+			[GPIOMUX_SUSPENDED] = &gpio_spi_susp_config,
+		},
+	},
+	{
+		.gpio      = 8,		/* BLSP1 QUP SPI_CS1_N */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &gpio_spi_cs1_config,
+			[GPIOMUX_SUSPENDED] = &gpio_spi_susp_config,
+		},
+	},
+#endif //CONFIG_ZTEMT_LCD_AVDD_NEGATIVE_CONTRL
+#endif
+	{
+		.gpio      = 6,		/* BLSP1 QUP2 I2C_DAT */
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_i2c_config,
+			[GPIOMUX_ACTIVE] = &gpio_i2c_act_config,
+		},
+	},
+	{
+		.gpio      = 7,		/* BLSP1 QUP2 I2C_CLK */
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_i2c_config,
+			[GPIOMUX_ACTIVE] = &gpio_i2c_act_config,
+		},
+	},
+	{
+		.gpio      = 83,		/* BLSP11 QUP I2C_DAT */
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_i2c_config,
+		},
+	},
+	{
+		.gpio      = 84,		/* BLSP11 QUP I2C_CLK */
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_i2c_config,
+		},
+	},
+	{
+		.gpio      = 4,			/* BLSP2 UART TX */
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_uart_config,
+		},
+	},
+	{
+		.gpio      = 5,			/* BLSP2 UART RX */
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_uart_config,
+		},
+	},
+	{                           /* NFC */
+		.gpio      = 29,		/* BLSP1 QUP6 I2C_DAT */
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_i2c_config,
+		},
+	},
+	{                           /* NFC */
+		.gpio      = 30,		/* BLSP1 QUP6 I2C_CLK */
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_i2c_config,
+		},
+	},
+	{
+		.gpio      = 53,		/* BLSP2 QUP4 SPI_DATA_MOSI */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &gpio_spi_config,
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[1],
+		},
+	},
+	{
+		.gpio      = 54,		/* BLSP2 QUP4 SPI_DATA_MISO */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &gpio_spi_config,
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[1],
+		},
+	},
+#ifndef CONFIG_SND_SOC_ES325
+	{
+		.gpio      = 56,		/* BLSP2 QUP4 SPI_CLK */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &gpio_spi_config,
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[0],
+		},
+	},
+	{
+		.gpio      = 55,		/* BLSP2 QUP4 SPI_CS0_N */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &gpio_spi_config,
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[0],
+		},
+	},
+#endif
+};
+
+static struct msm_gpiomux_config msm8974_slimbus_config[] __initdata = {
+	{
+		.gpio	= 70,		/* slimbus clk */
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &slimbus,
+		},
+	},
+	{
+		.gpio	= 71,		/* slimbus data */
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &slimbus,
+		},
+	},
+};
+
+static struct gpiomux_setting cam_settings[] = {
+	{
+		.func = GPIOMUX_FUNC_1, /*active 1*/ /* 0 */
+		.drv = GPIOMUX_DRV_2MA,
+		.pull = GPIOMUX_PULL_NONE,
+	},
+
+	{
+		.func = GPIOMUX_FUNC_1, /*suspend*/ /* 1 */
+		.drv = GPIOMUX_DRV_2MA,
+		.pull = GPIOMUX_PULL_DOWN,
+	},
+
+	{
+		.func = GPIOMUX_FUNC_1, /*i2c suspend*/ /* 2 */
+		.drv = GPIOMUX_DRV_2MA,
+		.pull = GPIOMUX_PULL_KEEPER,
+	},
+
+	{
+		.func = GPIOMUX_FUNC_GPIO, /*active 0*/ /* 3 */
+		.drv = GPIOMUX_DRV_2MA,
+		.pull = GPIOMUX_PULL_NONE,
+	},
+
+	{
+		.func = GPIOMUX_FUNC_GPIO, /*suspend 0*/ /* 4 */
+		.drv = GPIOMUX_DRV_2MA,
+		.pull = GPIOMUX_PULL_DOWN,
+	},
+};
+
+static struct gpiomux_setting sd_card_det_active_config = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_NONE,
+	.dir = GPIOMUX_IN,
+};
+
+static struct gpiomux_setting sd_card_det_sleep_config = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_UP,
+	.dir = GPIOMUX_IN,
+};
+
+static struct msm_gpiomux_config sd_card_det __initdata = {
+	.gpio = 62,
+	.settings = {
+		[GPIOMUX_ACTIVE]    = &sd_card_det_active_config,
+		[GPIOMUX_SUSPENDED] = &sd_card_det_sleep_config,
+	},
+};
+
+static struct msm_gpiomux_config msm_sensor_configs[] __initdata = {
+	{
+		.gpio = 15, /* CAM_MCLK0 */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[0],
+			[GPIOMUX_SUSPENDED] = &cam_settings[1],
+		},
+	},
+	{
+		.gpio = 16, /* CAM_MCLK1 */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[0],
+			[GPIOMUX_SUSPENDED] = &cam_settings[1],
+		},
+	},
+	{
+		.gpio = 17, /* CAM_MCLK2 */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[0],
+			[GPIOMUX_SUSPENDED] = &cam_settings[1],
+		},
+	},
+	{
+		.gpio = 18, /* WEBCAM1_RESET_N / CAM_MCLK3 */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[3],
+			[GPIOMUX_SUSPENDED] = &cam_settings[4],
+		},
+	},
+	{
+		.gpio = 19, /* CCI_I2C_SDA0 */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[0],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[0],
+		},
+	},
+	{
+		.gpio = 20, /* CCI_I2C_SCL0 */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[0],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[0],
+		},
+	},
+	{
+		.gpio = 21, /* CCI_I2C_SDA1 */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[0],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[0],
+		},
+	},
+	{
+		.gpio = 22, /* CCI_I2C_SCL1 */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[0],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[0],
+		},
+	},
+	{
+		.gpio = 23, /* FLASH_LED_EN */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[0],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[1],
+		},
+	},
+	{
+		.gpio = 24, /* FLASH_LED_NOW */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[0],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[1],
+		},
+	},
+	{
+		.gpio = 25, /* WEBCAM2_RESET_N */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[3],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[1],
+		},
+	},
+	{
+		.gpio = 26, /* CAM_IRQ */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[0],
+			[GPIOMUX_SUSPENDED] = &cam_settings[1],
+		},
+	},
+	{
+		.gpio = 27, /* OIS_SYNC */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[0],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[1],
+		},
+	},
+	{
+		.gpio = 28, /* WEBCAM1_STANDBY */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[3],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[1],
+		},
+	},
+	{
+		.gpio = 89, /* CAM1_STANDBY_N */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[3],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[1],
+		},
+	},
+	{
+		.gpio = 90, /* CAM1_RST_N */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[3],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[1],
+		},
+	},
+	{
+		.gpio = 91, /* CAM2_STANDBY_N */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[3],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[1],
+		},
+	},
+#ifndef CONFIG_SND_SOC_ES325
+	{
+		.gpio = 92, /* CAM2_RST_N */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[3],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[1],
+		},
+	},
+#endif
+	  #ifdef CONFIG_OV5648
+      {
+               /* CAM1_STANDBY_N */
+               .gpio      = 95,
+               .settings = {
+                     [GPIOMUX_ACTIVE]    = &cam_settings[3],
+                       [GPIOMUX_SUSPENDED] = &cam_settings[4],
+               },
+       },
+       #endif
+};
+
+static struct msm_gpiomux_config msm_sensor_configs_dragonboard[] __initdata = {
+	{
+		.gpio = 15, /* CAM_MCLK0 */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[0],
+			[GPIOMUX_SUSPENDED] = &cam_settings[1],
+		},
+	},
+	{
+		.gpio = 16, /* CAM_MCLK1 */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[0],
+			[GPIOMUX_SUSPENDED] = &cam_settings[1],
+		},
+	},
+	{
+		.gpio = 17, /* CAM_MCLK2 */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[0],
+			[GPIOMUX_SUSPENDED] = &cam_settings[1],
+		},
+	},
+	{
+		.gpio = 18, /* WEBCAM1_RESET_N / CAM_MCLK3 */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[3],
+			[GPIOMUX_SUSPENDED] = &cam_settings[4],
+		},
+	},
+	{
+		.gpio = 19, /* CCI_I2C_SDA0 */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[0],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[0],
+		},
+	},
+	{
+		.gpio = 20, /* CCI_I2C_SCL0 */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[0],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[0],
+		},
+	},
+	{
+		.gpio = 21, /* CCI_I2C_SDA1 */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[0],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[0],
+		},
+	},
+	{
+		.gpio = 22, /* CCI_I2C_SCL1 */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[0],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[0],
+		},
+	},
+	{
+		.gpio = 23, /* FLASH_LED_EN */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[0],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[1],
+		},
+	},
+	{
+		.gpio = 24, /* FLASH_LED_NOW */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[0],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[1],
+		},
+	},
+	{
+		.gpio = 25, /* WEBCAM2_RESET_N */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[3],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[1],
+		},
+	},
+	{
+		.gpio = 26, /* CAM_IRQ */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[0],
+			[GPIOMUX_SUSPENDED] = &cam_settings[1],
+		},
+	},
+	{
+		.gpio = 27, /* OIS_SYNC */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[0],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[1],
+		},
+	},
+	{
+		.gpio = 28, /* WEBCAM1_STANDBY */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[3],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[1],
+		},
+	},
+	{
+		.gpio = 89, /* CAM1_STANDBY_N */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[3],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[1],
+		},
+	},
+	{
+		.gpio = 90, /* CAM1_RST_N */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[3],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[1],
+		},
+	},
+	{
+		.gpio = 91, /* CAM2_STANDBY_N */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[3],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[1],
+		},
+	},
+	{
+		.gpio = 94, /* CAM2_RST_N */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[3],
+			[GPIOMUX_SUSPENDED] = &gpio_suspend_config[1],
+		},
+	},
+};
+
+static struct gpiomux_setting auxpcm_act_cfg = {
+	.func = GPIOMUX_FUNC_1,
+	.drv = GPIOMUX_DRV_8MA,
+	.pull = GPIOMUX_PULL_NONE,
+};
+
+
+static struct gpiomux_setting auxpcm_sus_cfg = {
+	.func = GPIOMUX_FUNC_1,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+
+/* Primary AUXPCM port sharing GPIO lines with Primary MI2S */
+static struct msm_gpiomux_config msm8974_pri_pri_auxpcm_configs[] __initdata = {
+	{
+		.gpio = 65,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &auxpcm_sus_cfg,
+			[GPIOMUX_ACTIVE] = &auxpcm_act_cfg,
+		},
+	},
+	{
+		.gpio = 66,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &auxpcm_sus_cfg,
+			[GPIOMUX_ACTIVE] = &auxpcm_act_cfg,
+		},
+	},
+	{
+		.gpio = 67,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &auxpcm_sus_cfg,
+			[GPIOMUX_ACTIVE] = &auxpcm_act_cfg,
+		},
+	},
+	{
+		.gpio = 68,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &auxpcm_sus_cfg,
+			[GPIOMUX_ACTIVE] = &auxpcm_act_cfg,
+		},
+	},
+};
+
+/* Primary AUXPCM port sharing GPIO lines with Tertiary MI2S */
+static struct msm_gpiomux_config msm8974_pri_ter_auxpcm_configs[] __initdata = {
+	{
+		.gpio = 74,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &auxpcm_sus_cfg,
+			[GPIOMUX_ACTIVE] = &auxpcm_act_cfg,
+		},
+	},
+	{
+		.gpio = 75,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &auxpcm_sus_cfg,
+			[GPIOMUX_ACTIVE] = &auxpcm_act_cfg,
+		},
+	},
+	{
+		.gpio = 76,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &auxpcm_sus_cfg,
+			[GPIOMUX_ACTIVE] = &auxpcm_act_cfg,
+		},
+	},
+	{
+		.gpio = 77,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &auxpcm_sus_cfg,
+			[GPIOMUX_ACTIVE] = &auxpcm_act_cfg,
+		},
+	},
+};
+
+static struct msm_gpiomux_config msm8974_sec_auxpcm_configs[] __initdata = {
+	{
+		.gpio = 79,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &auxpcm_sus_cfg,
+			[GPIOMUX_ACTIVE] = &auxpcm_act_cfg,
+		},
+	},
+	{
+		.gpio = 80,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &auxpcm_sus_cfg,
+			[GPIOMUX_ACTIVE] = &auxpcm_act_cfg,
+		},
+	},
+	{
+		.gpio = 81,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &auxpcm_sus_cfg,
+			[GPIOMUX_ACTIVE] = &auxpcm_act_cfg,
+		},
+	},
+	{
+		.gpio = 82,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &auxpcm_sus_cfg,
+			[GPIOMUX_ACTIVE] = &auxpcm_act_cfg,
+		},
+	},
+};
+
+static struct msm_gpiomux_config wcnss_5wire_interface[] = {
+	{
+		.gpio = 36,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &wcnss_5wire_active_cfg,
+			[GPIOMUX_SUSPENDED] = &wcnss_5wire_suspend_cfg,
+		},
+	},
+	{
+		.gpio = 37,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &wcnss_5wire_active_cfg,
+			[GPIOMUX_SUSPENDED] = &wcnss_5wire_suspend_cfg,
+		},
+	},
+	{
+		.gpio = 38,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &wcnss_5wire_active_cfg,
+			[GPIOMUX_SUSPENDED] = &wcnss_5wire_suspend_cfg,
+		},
+	},
+	{
+		.gpio = 39,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &wcnss_5wire_active_cfg,
+			[GPIOMUX_SUSPENDED] = &wcnss_5wire_suspend_cfg,
+		},
+	},
+	{
+		.gpio = 40,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &wcnss_5wire_active_cfg,
+			[GPIOMUX_SUSPENDED] = &wcnss_5wire_suspend_cfg,
+		},
+	},
+};
+
+
+static struct msm_gpiomux_config ath_gpio_configs[] = {
+	{
+		.gpio = 51,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &ath_gpio_active_cfg,
+			[GPIOMUX_SUSPENDED] = &ath_gpio_suspend_cfg,
+		},
+	},
+	{
+		.gpio = 79,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &ath_gpio_active_cfg,
+			[GPIOMUX_SUSPENDED] = &ath_gpio_suspend_cfg,
+		},
+	},
+};
+
+static struct msm_gpiomux_config msm_taiko_config[] __initdata = {
+	{
+		.gpio	= 63,		/* SYS_RST_N */
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &taiko_reset,
+		},
+	},
+	{
+		.gpio	= 72,		/* CDC_INT */
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &taiko_int,
+		},
+	},
+};
+
+static struct gpiomux_setting sdc3_clk_actv_cfg = {
+	.func = GPIOMUX_FUNC_2,
+	.drv = GPIOMUX_DRV_8MA,
+	.pull = GPIOMUX_PULL_NONE,
+};
+
+static struct gpiomux_setting sdc3_cmd_data_0_3_actv_cfg = {
+	.func = GPIOMUX_FUNC_2,
+	.drv = GPIOMUX_DRV_8MA,
+	.pull = GPIOMUX_PULL_UP,
+};
+
+static struct gpiomux_setting sdc3_suspend_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+
+static struct gpiomux_setting sdc3_data_1_suspend_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_8MA,
+	.pull = GPIOMUX_PULL_UP,
+};
+
+static struct msm_gpiomux_config msm8974_sdc3_configs[] __initdata = {
+	{
+		/* DAT3 */
+		.gpio      = 35,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &sdc3_cmd_data_0_3_actv_cfg,
+			[GPIOMUX_SUSPENDED] = &sdc3_suspend_cfg,
+		},
+	},
+	{
+		/* DAT2 */
+		.gpio      = 36,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &sdc3_cmd_data_0_3_actv_cfg,
+			[GPIOMUX_SUSPENDED] = &sdc3_suspend_cfg,
+		},
+	},
+	{
+		/* DAT1 */
+		.gpio      = 37,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &sdc3_cmd_data_0_3_actv_cfg,
+			[GPIOMUX_SUSPENDED] = &sdc3_data_1_suspend_cfg,
+		},
+	},
+	{
+		/* DAT0 */
+		.gpio      = 38,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &sdc3_cmd_data_0_3_actv_cfg,
+			[GPIOMUX_SUSPENDED] = &sdc3_suspend_cfg,
+		},
+	},
+	{
+		/* CMD */
+		.gpio      = 39,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &sdc3_cmd_data_0_3_actv_cfg,
+			[GPIOMUX_SUSPENDED] = &sdc3_suspend_cfg,
+		},
+	},
+	{
+		/* CLK */
+		.gpio      = 40,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &sdc3_clk_actv_cfg,
+			[GPIOMUX_SUSPENDED] = &sdc3_suspend_cfg,
+		},
+	},
+};
+
+static void msm_gpiomux_sdc3_install(void)
+{
+	msm_gpiomux_install(msm8974_sdc3_configs,
+			    ARRAY_SIZE(msm8974_sdc3_configs));
+}
+
+#ifdef CONFIG_MMC_MSM_SDC4_SUPPORT
+static struct gpiomux_setting sdc4_clk_actv_cfg = {
+	.func = GPIOMUX_FUNC_2,
+	.drv = GPIOMUX_DRV_8MA,
+	.pull = GPIOMUX_PULL_NONE,
+};
+
+static struct gpiomux_setting sdc4_cmd_data_0_3_actv_cfg = {
+	.func = GPIOMUX_FUNC_2,
+	.drv = GPIOMUX_DRV_8MA,
+	.pull = GPIOMUX_PULL_UP,
+};
+
+static struct gpiomux_setting sdc4_suspend_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+
+static struct gpiomux_setting sdc4_data_1_suspend_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_8MA,
+	.pull = GPIOMUX_PULL_UP,
+};
+
+static struct msm_gpiomux_config msm8974_sdc4_configs[] __initdata = {
+	{
+		/* DAT3 */
+		.gpio      = 92,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &sdc4_cmd_data_0_3_actv_cfg,
+			[GPIOMUX_SUSPENDED] = &sdc4_suspend_cfg,
+		},
+	},
+	{
+		/* DAT2 */
+		.gpio      = 94,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &sdc4_cmd_data_0_3_actv_cfg,
+			[GPIOMUX_SUSPENDED] = &sdc4_suspend_cfg,
+		},
+	},
+	{
+		/* DAT1 */
+		.gpio      = 95,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &sdc4_cmd_data_0_3_actv_cfg,
+			[GPIOMUX_SUSPENDED] = &sdc4_data_1_suspend_cfg,
+		},
+	},
+	{
+		/* DAT0 */
+		.gpio      = 96,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &sdc4_cmd_data_0_3_actv_cfg,
+			[GPIOMUX_SUSPENDED] = &sdc4_suspend_cfg,
+		},
+	},
+	{
+		/* CMD */
+		.gpio      = 91,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &sdc4_cmd_data_0_3_actv_cfg,
+			[GPIOMUX_SUSPENDED] = &sdc4_suspend_cfg,
+		},
+	},
+	{
+		/* CLK */
+		.gpio      = 93,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &sdc4_clk_actv_cfg,
+			[GPIOMUX_SUSPENDED] = &sdc4_suspend_cfg,
+		},
+	},
+};
+
+static void msm_gpiomux_sdc4_install(void)
+{
+	msm_gpiomux_install(msm8974_sdc4_configs,
+			    ARRAY_SIZE(msm8974_sdc4_configs));
+}
+#else
+static void msm_gpiomux_sdc4_install(void) {}
+#endif /* CONFIG_MMC_MSM_SDC4_SUPPORT */
+
+static struct msm_gpiomux_config apq8074_dragonboard_ts_config[] __initdata = {
+	{
+		/* BLSP1 QUP I2C_DATA */
+		.gpio      = 2,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_i2c_config,
+		},
+	},
+	{
+		/* BLSP1 QUP I2C_CLK */
+		.gpio      = 3,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_i2c_config,
+		},
+	},
+};
+
+void __init msm_8974_init_gpiomux(void)
+{
+	int rc;
+
+	rc = msm_gpiomux_init_dt();
+	if (rc) {
+		pr_err("%s failed %d\n", __func__, rc);
+		return;
+	}
+
+	pr_err("%s:%d socinfo_get_version %x\n", __func__, __LINE__,
+		socinfo_get_version());
+	if (socinfo_get_version() >= 0x20000)
+		msm_tlmm_misc_reg_write(TLMM_SPARE_REG, 0xf);
+
+#if defined(CONFIG_KS8851) || defined(CONFIG_KS8851_MODULE)
+	if (!(of_board_is_dragonboard() && machine_is_apq8074()))
+		msm_gpiomux_install(msm_eth_configs, \
+			ARRAY_SIZE(msm_eth_configs));
+#endif
+	msm_gpiomux_install(msm_blsp_configs, ARRAY_SIZE(msm_blsp_configs));
+#if 0
+	msm_gpiomux_install(msm_blsp2_uart7_configs,
+			 ARRAY_SIZE(msm_blsp2_uart7_configs));
+#endif
+#if 1 //liaojunsheng
+	msm_gpiomux_install(msm_blsp2_uart8_configs,
+			 ARRAY_SIZE(msm_blsp2_uart8_configs));
+
+#endif
+
+#if 1
+	msm_gpiomux_install(bcm_sleep_gpio_configs,
+			 ARRAY_SIZE(bcm_sleep_gpio_configs));
+#endif			 
+	msm_gpiomux_install(wcnss_5wire_interface,
+				ARRAY_SIZE(wcnss_5wire_interface));
+	if (of_board_is_liquid())
+		msm_gpiomux_install_nowrite(ath_gpio_configs,
+					ARRAY_SIZE(ath_gpio_configs));
+	msm_gpiomux_install(msm8974_slimbus_config,
+			ARRAY_SIZE(msm8974_slimbus_config));
+
+	msm_gpiomux_install(msm_touch_configs, ARRAY_SIZE(msm_touch_configs));
+		msm_gpiomux_install(hap_lvl_shft_config,
+				ARRAY_SIZE(hap_lvl_shft_config));
+#ifdef CONFIG_NFC_PN544
+	//add by chengdongsheng for nfc
+	msm_gpiomux_install(msm_nxp_configs, ARRAY_SIZE(msm_nxp_configs));
+	//end
+#endif
+#ifdef CONFIG_SND_SOC_ES325
+	msm_gpiomux_install(msm_es325_configs, ARRAY_SIZE(msm_es325_configs));
+#endif
+
+	if (of_board_is_dragonboard() && machine_is_apq8074())
+		msm_gpiomux_install(msm_sensor_configs_dragonboard, \
+				ARRAY_SIZE(msm_sensor_configs_dragonboard));
+	else
+		msm_gpiomux_install(msm_sensor_configs, \
+				ARRAY_SIZE(msm_sensor_configs));
+
+	msm_gpiomux_install(&sd_card_det, 1);
+
+	if (machine_is_apq8074() && (of_board_is_liquid() || \
+	    of_board_is_dragonboard()))
+		msm_gpiomux_sdc3_install();
+
+	if (!(of_board_is_dragonboard() && machine_is_apq8074()))
+		msm_gpiomux_sdc4_install();
+
+	msm_gpiomux_install(msm_taiko_config, ARRAY_SIZE(msm_taiko_config));
+
+	msm_gpiomux_install(msm_hsic_configs, ARRAY_SIZE(msm_hsic_configs));
+	msm_gpiomux_install(msm_hsic_hub_configs,
+				ARRAY_SIZE(msm_hsic_hub_configs));
+
+/* ZTEMT Added by LiuYongfeng, 2013/8/9 disable simport chip in order to enable usb connect*/
+	msm_gpiomux_install(msm_slimport_default_configs, 
+				ARRAY_SIZE(msm_slimport_default_configs));
+	msm_gpiomux_install(msm_hdmi_configs, ARRAY_SIZE(msm_hdmi_configs));
+	if (of_board_is_fluid())
+		msm_gpiomux_install(msm_mhl_configs,
+				    ARRAY_SIZE(msm_mhl_configs));
+
+	if (of_board_is_liquid() ||
+	    (of_board_is_dragonboard() && machine_is_apq8074()))
+		msm_gpiomux_install(msm8974_pri_ter_auxpcm_configs,
+				 ARRAY_SIZE(msm8974_pri_ter_auxpcm_configs));
+	else
+		msm_gpiomux_install(msm8974_pri_pri_auxpcm_configs,
+				 ARRAY_SIZE(msm8974_pri_pri_auxpcm_configs));
+
+	if (of_board_is_cdp())
+		msm_gpiomux_install(msm8974_sec_auxpcm_configs,
+				 ARRAY_SIZE(msm8974_sec_auxpcm_configs));
+	else if (of_board_is_liquid() || of_board_is_fluid() ||
+						of_board_is_mtp())
+		msm_gpiomux_install(msm_epm_configs,
+				ARRAY_SIZE(msm_epm_configs));
+
+	msm_gpiomux_install_nowrite(msm_lcd_configs,
+			ARRAY_SIZE(msm_lcd_configs));
+
+#if 0 //liaojunsheng
+	if (of_board_is_rumi())
+		msm_gpiomux_install(msm_rumi_blsp_configs,
+				    ARRAY_SIZE(msm_rumi_blsp_configs));
+#endif 
+	if (socinfo_get_platform_subtype() == PLATFORM_SUBTYPE_MDM)
+		msm_gpiomux_install(mdm_configs,
+			ARRAY_SIZE(mdm_configs));
+
+	if (of_board_is_dragonboard() && machine_is_apq8074())
+		msm_gpiomux_install(apq8074_dragonboard_ts_config,
+			ARRAY_SIZE(apq8074_dragonboard_ts_config));
+}
+
diff --git a/arch/arm/mach-msm/board/clock-8974-NX503A.c b/arch/arm/mach-msm/board/clock-8974-NX503A.c
new file mode 100755
index 0000000..d4bd688
--- /dev/null
+++ b/arch/arm/mach-msm/board/clock-8974-NX503A.c
@@ -0,0 +1,5928 @@
+/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/ctype.h>
+#include <linux/io.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/iopoll.h>
+#include <linux/regulator/consumer.h>
+
+#include <mach/rpm-regulator-smd.h>
+#include <mach/socinfo.h>
+#include <mach/rpm-smd.h>
+#include <mach/clock-generic.h>
+
+#include "../clock-local2.h"
+#include "../clock-pll.h"
+#include "../clock-rpm.h"
+#include "../clock-voter.h"
+#include "../clock-mdss-8974.h"
+#include "../clock.h"
+
+enum {
+	GCC_BASE,
+	MMSS_BASE,
+	LPASS_BASE,
+	APCS_BASE,
+	N_BASES,
+};
+
+static void __iomem *virt_bases[N_BASES];
+
+#define GCC_REG_BASE(x) (void __iomem *)(virt_bases[GCC_BASE] + (x))
+#define MMSS_REG_BASE(x) (void __iomem *)(virt_bases[MMSS_BASE] + (x))
+#define LPASS_REG_BASE(x) (void __iomem *)(virt_bases[LPASS_BASE] + (x))
+#define APCS_REG_BASE(x) (void __iomem *)(virt_bases[APCS_BASE] + (x))
+
+#define GPLL0_MODE_REG                 0x0000
+#define GPLL0_L_REG                    0x0004
+#define GPLL0_M_REG                    0x0008
+#define GPLL0_N_REG                    0x000C
+#define GPLL0_USER_CTL_REG             0x0010
+#define GPLL0_CONFIG_CTL_REG           0x0014
+#define GPLL0_TEST_CTL_REG             0x0018
+#define GPLL0_STATUS_REG               0x001C
+
+#define GPLL1_MODE_REG                 0x0040
+#define GPLL1_L_REG                    0x0044
+#define GPLL1_M_REG                    0x0048
+#define GPLL1_N_REG                    0x004C
+#define GPLL1_USER_CTL_REG             0x0050
+#define GPLL1_CONFIG_CTL_REG           0x0054
+#define GPLL1_TEST_CTL_REG             0x0058
+#define GPLL1_STATUS_REG               0x005C
+
+#define GPLL4_MODE_REG                 0x1DC0
+#define GPLL4_L_REG                    0x1DC4
+#define GPLL4_M_REG                    0x1DC8
+#define GPLL4_N_REG                    0x1DCC
+#define GPLL4_USER_CTL_REG             0x1DD0
+#define GPLL4_CONFIG_CTL_REG           0x1DD4
+#define GPLL4_TEST_CTL_REG             0x1DD8
+#define GPLL4_STATUS_REG               0x1DDC
+
+#define MMPLL0_MODE_REG                0x0000
+#define MMPLL0_L_REG                   0x0004
+#define MMPLL0_M_REG                   0x0008
+#define MMPLL0_N_REG                   0x000C
+#define MMPLL0_USER_CTL_REG            0x0010
+#define MMPLL0_CONFIG_CTL_REG          0x0014
+#define MMPLL0_TEST_CTL_REG            0x0018
+#define MMPLL0_STATUS_REG              0x001C
+
+#define MMPLL1_MODE_REG                0x0040
+#define MMPLL1_L_REG                   0x0044
+#define MMPLL1_M_REG                   0x0048
+#define MMPLL1_N_REG                   0x004C
+#define MMPLL1_USER_CTL_REG            0x0050
+#define MMPLL1_CONFIG_CTL_REG          0x0054
+#define MMPLL1_TEST_CTL_REG            0x0058
+#define MMPLL1_STATUS_REG              0x005C
+
+#define MMPLL3_MODE_REG                0x0080
+#define MMPLL3_L_REG                   0x0084
+#define MMPLL3_M_REG                   0x0088
+#define MMPLL3_N_REG                   0x008C
+#define MMPLL3_USER_CTL_REG            0x0090
+#define MMPLL3_CONFIG_CTL_REG          0x0094
+#define MMPLL3_TEST_CTL_REG            0x0098
+#define MMPLL3_STATUS_REG              0x009C
+
+#define LPAPLL_MODE_REG                0x0000
+#define LPAPLL_L_REG                   0x0004
+#define LPAPLL_M_REG                   0x0008
+#define LPAPLL_N_REG                   0x000C
+#define LPAPLL_USER_CTL_REG            0x0010
+#define LPAPLL_CONFIG_CTL_REG          0x0014
+#define LPAPLL_TEST_CTL_REG            0x0018
+#define LPAPLL_STATUS_REG              0x001C
+
+#define GCC_DEBUG_CLK_CTL_REG          0x1880
+#define CLOCK_FRQ_MEASURE_CTL_REG      0x1884
+#define CLOCK_FRQ_MEASURE_STATUS_REG   0x1888
+#define GCC_XO_DIV4_CBCR_REG           0x10C8
+#define GCC_PLLTEST_PAD_CFG_REG        0x188C
+#define APCS_GPLL_ENA_VOTE_REG         0x1480
+#define MMSS_PLL_VOTE_APCS_REG         0x0100
+#define MMSS_DEBUG_CLK_CTL_REG         0x0900
+#define LPASS_DEBUG_CLK_CTL_REG        0x29000
+#define LPASS_LPA_PLL_VOTE_APPS_REG    0x2000
+
+#define GLB_CLK_DIAG_REG               0x001C
+#define L2_CBCR_REG                    0x004C
+
+#define USB30_MASTER_CMD_RCGR          0x03D4
+#define USB30_MOCK_UTMI_CMD_RCGR       0x03E8
+#define USB_HSIC_SYSTEM_CMD_RCGR       0x041C
+#define USB_HSIC_CMD_RCGR              0x0440
+#define USB_HSIC_IO_CAL_CMD_RCGR       0x0458
+#define USB_HS_SYSTEM_CMD_RCGR         0x0490
+#define SYS_NOC_USB3_AXI_CBCR	       0x0108
+#define USB30_SLEEP_CBCR	       0x03CC
+#define USB2A_PHY_SLEEP_CBCR	       0x04AC
+#define USB2B_PHY_SLEEP_CBCR	       0x04B4
+#define SDCC1_APPS_CMD_RCGR            0x04D0
+#define SDCC2_APPS_CMD_RCGR            0x0510
+#define SDCC3_APPS_CMD_RCGR            0x0550
+#define SDCC4_APPS_CMD_RCGR            0x0590
+#define BLSP1_QUP1_SPI_APPS_CMD_RCGR   0x064C
+#define BLSP1_QUP1_I2C_APPS_CMD_RCGR   0x0660
+#define BLSP1_UART1_APPS_CMD_RCGR      0x068C
+#define BLSP1_QUP2_SPI_APPS_CMD_RCGR   0x06CC
+#define BLSP1_QUP2_I2C_APPS_CMD_RCGR   0x06E0
+#define BLSP1_UART2_APPS_CMD_RCGR      0x070C
+#define BLSP1_QUP3_SPI_APPS_CMD_RCGR   0x074C
+#define BLSP1_QUP3_I2C_APPS_CMD_RCGR   0x0760
+#define BLSP1_UART3_APPS_CMD_RCGR      0x078C
+#define BLSP1_QUP4_SPI_APPS_CMD_RCGR   0x07CC
+#define BLSP1_QUP4_I2C_APPS_CMD_RCGR   0x07E0
+#define BLSP1_UART4_APPS_CMD_RCGR      0x080C
+#define BLSP1_QUP5_SPI_APPS_CMD_RCGR   0x084C
+#define BLSP1_QUP5_I2C_APPS_CMD_RCGR   0x0860
+#define BLSP1_UART5_APPS_CMD_RCGR      0x088C
+#define BLSP1_QUP6_SPI_APPS_CMD_RCGR   0x08CC
+#define BLSP1_QUP6_I2C_APPS_CMD_RCGR   0x08E0
+#define BLSP1_UART6_APPS_CMD_RCGR      0x090C
+#define BLSP2_QUP1_SPI_APPS_CMD_RCGR   0x098C
+#define BLSP2_QUP1_I2C_APPS_CMD_RCGR   0x09A0
+#define BLSP2_UART1_APPS_CMD_RCGR      0x09CC
+#define BLSP2_QUP2_SPI_APPS_CMD_RCGR   0x0A0C
+#define BLSP2_QUP2_I2C_APPS_CMD_RCGR   0x0A20
+#define BLSP2_UART2_APPS_CMD_RCGR      0x0A4C
+#define BLSP2_QUP3_SPI_APPS_CMD_RCGR   0x0A8C
+#define BLSP2_QUP3_I2C_APPS_CMD_RCGR   0x0AA0
+#define BLSP2_UART3_APPS_CMD_RCGR      0x0ACC
+#define BLSP2_QUP4_SPI_APPS_CMD_RCGR   0x0B0C
+#define BLSP2_QUP4_I2C_APPS_CMD_RCGR   0x0B20
+#define BLSP2_UART4_APPS_CMD_RCGR      0x0B4C
+#define BLSP2_QUP5_SPI_APPS_CMD_RCGR   0x0B8C
+#define BLSP2_QUP5_I2C_APPS_CMD_RCGR   0x0BA0
+#define BLSP2_UART5_APPS_CMD_RCGR      0x0BCC
+#define BLSP2_QUP6_SPI_APPS_CMD_RCGR   0x0C0C
+#define BLSP2_QUP6_I2C_APPS_CMD_RCGR   0x0C20
+#define BLSP2_UART6_APPS_CMD_RCGR      0x0C4C
+#define PDM2_CMD_RCGR                  0x0CD0
+#define TSIF_REF_CMD_RCGR              0x0D90
+#define CE1_CMD_RCGR                   0x1050
+#define CE2_CMD_RCGR                   0x1090
+#define GP1_CMD_RCGR                   0x1904
+#define GP2_CMD_RCGR                   0x1944
+#define GP3_CMD_RCGR                   0x1984
+#define LPAIF_SPKR_CMD_RCGR            0xA000
+#define LPAIF_PRI_CMD_RCGR             0xB000
+#define LPAIF_SEC_CMD_RCGR             0xC000
+#define LPAIF_TER_CMD_RCGR             0xD000
+#define LPAIF_QUAD_CMD_RCGR            0xE000
+#define LPAIF_PCM0_CMD_RCGR            0xF000
+#define LPAIF_PCM1_CMD_RCGR            0x10000
+#define RESAMPLER_CMD_RCGR             0x11000
+#define SLIMBUS_CMD_RCGR               0x12000
+#define LPAIF_PCMOE_CMD_RCGR           0x13000
+#define AHBFABRIC_CMD_RCGR             0x18000
+#define VCODEC0_CMD_RCGR               0x1000
+#define PCLK0_CMD_RCGR                 0x2000
+#define PCLK1_CMD_RCGR                 0x2020
+#define MDP_CMD_RCGR                   0x2040
+#define EXTPCLK_CMD_RCGR               0x2060
+#define VSYNC_CMD_RCGR                 0x2080
+#define EDPPIXEL_CMD_RCGR              0x20A0
+#define EDPLINK_CMD_RCGR               0x20C0
+#define EDPAUX_CMD_RCGR                0x20E0
+#define HDMI_CMD_RCGR                  0x2100
+#define BYTE0_CMD_RCGR                 0x2120
+#define BYTE1_CMD_RCGR                 0x2140
+#define ESC0_CMD_RCGR                  0x2160
+#define ESC1_CMD_RCGR                  0x2180
+#define CSI0PHYTIMER_CMD_RCGR          0x3000
+#define CSI1PHYTIMER_CMD_RCGR          0x3030
+#define CSI2PHYTIMER_CMD_RCGR          0x3060
+#define CSI0_CMD_RCGR                  0x3090
+#define CSI1_CMD_RCGR                  0x3100
+#define CSI2_CMD_RCGR                  0x3160
+#define CSI3_CMD_RCGR                  0x31C0
+#define CCI_CMD_RCGR                   0x3300
+#define MCLK0_CMD_RCGR                 0x3360
+#define MCLK1_CMD_RCGR                 0x3390
+#define MCLK2_CMD_RCGR                 0x33C0
+#define MCLK3_CMD_RCGR                 0x33F0
+#define MMSS_GP0_CMD_RCGR              0x3420
+#define MMSS_GP1_CMD_RCGR              0x3450
+#define JPEG0_CMD_RCGR                 0x3500
+#define JPEG1_CMD_RCGR                 0x3520
+#define JPEG2_CMD_RCGR                 0x3540
+#define VFE0_CMD_RCGR                  0x3600
+#define VFE1_CMD_RCGR                  0x3620
+#define CPP_CMD_RCGR                   0x3640
+#define GFX3D_CMD_RCGR                 0x4000
+#define RBCPR_CMD_RCGR                 0x4060
+#define AHB_CMD_RCGR                   0x5000
+#define AXI_CMD_RCGR                   0x5040
+#define OCMEMNOC_CMD_RCGR              0x5090
+#define OCMEMCX_OCMEMNOC_CBCR          0x4058
+
+#define MMSS_BCR                  0x0240
+#define USB_30_BCR                0x03C0
+#define USB3_PHY_BCR              0x03FC
+#define USB_HS_HSIC_BCR           0x0400
+#define USB_HS_BCR                0x0480
+#define SDCC1_BCR                 0x04C0
+#define SDCC2_BCR                 0x0500
+#define SDCC3_BCR                 0x0540
+#define SDCC4_BCR                 0x0580
+#define BLSP1_BCR                 0x05C0
+#define BLSP1_QUP1_BCR            0x0640
+#define BLSP1_UART1_BCR           0x0680
+#define BLSP1_QUP2_BCR            0x06C0
+#define BLSP1_UART2_BCR           0x0700
+#define BLSP1_QUP3_BCR            0x0740
+#define BLSP1_UART3_BCR           0x0780
+#define BLSP1_QUP4_BCR            0x07C0
+#define BLSP1_UART4_BCR           0x0800
+#define BLSP1_QUP5_BCR            0x0840
+#define BLSP1_UART5_BCR           0x0880
+#define BLSP1_QUP6_BCR            0x08C0
+#define BLSP1_UART6_BCR           0x0900
+#define BLSP2_BCR                 0x0940
+#define BLSP2_QUP1_BCR            0x0980
+#define BLSP2_UART1_BCR           0x09C0
+#define BLSP2_QUP2_BCR            0x0A00
+#define BLSP2_UART2_BCR           0x0A40
+#define BLSP2_QUP3_BCR            0x0A80
+#define BLSP2_UART3_BCR           0x0AC0
+#define BLSP2_QUP4_BCR            0x0B00
+#define BLSP2_UART4_BCR           0x0B40
+#define BLSP2_QUP5_BCR            0x0B80
+#define BLSP2_UART5_BCR           0x0BC0
+#define BLSP2_QUP6_BCR            0x0C00
+#define BLSP2_UART6_BCR           0x0C40
+#define BOOT_ROM_BCR              0x0E00
+#define PDM_BCR                   0x0CC0
+#define PRNG_BCR                  0x0D00
+#define BAM_DMA_BCR               0x0D40
+#define TSIF_BCR                  0x0D80
+#define CE1_BCR                   0x1040
+#define CE2_BCR                   0x1080
+#define AUDIO_CORE_BCR            0x4000
+#define VENUS0_BCR                0x1020
+#define MDSS_BCR                  0x2300
+#define CAMSS_PHY0_BCR            0x3020
+#define CAMSS_PHY1_BCR            0x3050
+#define CAMSS_PHY2_BCR            0x3080
+#define CAMSS_CSI0_BCR            0x30B0
+#define CAMSS_CSI0PHY_BCR         0x30C0
+#define CAMSS_CSI0RDI_BCR         0x30D0
+#define CAMSS_CSI0PIX_BCR         0x30E0
+#define CAMSS_CSI1_BCR            0x3120
+#define CAMSS_CSI1PHY_BCR         0x3130
+#define CAMSS_CSI1RDI_BCR         0x3140
+#define CAMSS_CSI1PIX_BCR         0x3150
+#define CAMSS_CSI2_BCR            0x3180
+#define CAMSS_CSI2PHY_BCR         0x3190
+#define CAMSS_CSI2RDI_BCR         0x31A0
+#define CAMSS_CSI2PIX_BCR         0x31B0
+#define CAMSS_CSI3_BCR            0x31E0
+#define CAMSS_CSI3PHY_BCR         0x31F0
+#define CAMSS_CSI3RDI_BCR         0x3200
+#define CAMSS_CSI3PIX_BCR         0x3210
+#define CAMSS_ISPIF_BCR           0x3220
+#define CAMSS_CCI_BCR             0x3340
+#define CAMSS_MCLK0_BCR           0x3380
+#define CAMSS_MCLK1_BCR           0x33B0
+#define CAMSS_MCLK2_BCR           0x33E0
+#define CAMSS_MCLK3_BCR           0x3410
+#define CAMSS_GP0_BCR             0x3440
+#define CAMSS_GP1_BCR             0x3470
+#define CAMSS_TOP_BCR             0x3480
+#define CAMSS_MICRO_BCR           0x3490
+#define CAMSS_JPEG_BCR            0x35A0
+#define CAMSS_VFE_BCR             0x36A0
+#define CAMSS_CSI_VFE0_BCR        0x3700
+#define CAMSS_CSI_VFE1_BCR        0x3710
+#define OCMEMNOC_BCR              0x50B0
+#define MMSSNOCAHB_BCR            0x5020
+#define MMSSNOCAXI_BCR            0x5060
+#define OXILI_GFX3D_CBCR          0x4028
+#define OXILICX_AHB_CBCR          0x403C
+#define OXILICX_AXI_CBCR          0x4038
+#define OXILI_BCR                 0x4020
+#define OXILICX_BCR               0x4030
+#define LPASS_Q6SS_BCR            0x6000
+
+#define OCMEM_SYS_NOC_AXI_CBCR                   0x0244
+#define OCMEM_NOC_CFG_AHB_CBCR                   0x0248
+#define MMSS_NOC_CFG_AHB_CBCR                    0x024C
+
+#define USB30_MASTER_CBCR                        0x03C8
+#define USB30_MOCK_UTMI_CBCR                     0x03D0
+#define USB_HSIC_AHB_CBCR                        0x0408
+#define USB_HSIC_SYSTEM_CBCR                     0x040C
+#define USB_HSIC_CBCR                            0x0410
+#define USB_HSIC_IO_CAL_CBCR                     0x0414
+#define USB_HS_SYSTEM_CBCR                       0x0484
+#define USB_HS_AHB_CBCR                          0x0488
+#define SDCC1_APPS_CBCR                          0x04C4
+#define SDCC1_AHB_CBCR                           0x04C8
+#define SDCC1_CDCCAL_SLEEP_CBCR                  0x04E4
+#define SDCC1_CDCCAL_FF_CBCR                     0x04E8
+#define SDCC2_APPS_CBCR                          0x0504
+#define SDCC2_AHB_CBCR                           0x0508
+#define SDCC3_APPS_CBCR                          0x0544
+#define SDCC3_AHB_CBCR                           0x0548
+#define SDCC4_APPS_CBCR                          0x0584
+#define SDCC4_AHB_CBCR                           0x0588
+#define BLSP1_AHB_CBCR                           0x05C4
+#define BLSP1_QUP1_SPI_APPS_CBCR                 0x0644
+#define BLSP1_QUP1_I2C_APPS_CBCR                 0x0648
+#define BLSP1_UART1_APPS_CBCR                    0x0684
+#define BLSP1_UART1_SIM_CBCR                     0x0688
+#define BLSP1_QUP2_SPI_APPS_CBCR                 0x06C4
+#define BLSP1_QUP2_I2C_APPS_CBCR                 0x06C8
+#define BLSP1_UART2_APPS_CBCR                    0x0704
+#define BLSP1_UART2_SIM_CBCR                     0x0708
+#define BLSP1_QUP3_SPI_APPS_CBCR                 0x0744
+#define BLSP1_QUP3_I2C_APPS_CBCR                 0x0748
+#define BLSP1_UART3_APPS_CBCR                    0x0784
+#define BLSP1_UART3_SIM_CBCR                     0x0788
+#define BLSP1_QUP4_SPI_APPS_CBCR                 0x07C4
+#define BLSP1_QUP4_I2C_APPS_CBCR                 0x07C8
+#define BLSP1_UART4_APPS_CBCR                    0x0804
+#define BLSP1_UART4_SIM_CBCR                     0x0808
+#define BLSP1_QUP5_SPI_APPS_CBCR                 0x0844
+#define BLSP1_QUP5_I2C_APPS_CBCR                 0x0848
+#define BLSP1_UART5_APPS_CBCR                    0x0884
+#define BLSP1_UART5_SIM_CBCR                     0x0888
+#define BLSP1_QUP6_SPI_APPS_CBCR                 0x08C4
+#define BLSP1_QUP6_I2C_APPS_CBCR                 0x08C8
+#define BLSP1_UART6_APPS_CBCR                    0x0904
+#define BLSP1_UART6_SIM_CBCR                     0x0908
+#define BLSP2_AHB_CBCR                           0x0944
+#define BOOT_ROM_AHB_CBCR                        0x0E04
+#define BLSP2_QUP1_SPI_APPS_CBCR                 0x0984
+#define BLSP2_QUP1_I2C_APPS_CBCR                 0x0988
+#define BLSP2_UART1_APPS_CBCR                    0x09C4
+#define BLSP2_UART1_SIM_CBCR                     0x09C8
+#define BLSP2_QUP2_SPI_APPS_CBCR                 0x0A04
+#define BLSP2_QUP2_I2C_APPS_CBCR                 0x0A08
+#define BLSP2_UART2_APPS_CBCR                    0x0A44
+#define BLSP2_UART2_SIM_CBCR                     0x0A48
+#define BLSP2_QUP3_SPI_APPS_CBCR                 0x0A84
+#define BLSP2_QUP3_I2C_APPS_CBCR                 0x0A88
+#define BLSP2_UART3_APPS_CBCR                    0x0AC4
+#define BLSP2_UART3_SIM_CBCR                     0x0AC8
+#define BLSP2_QUP4_SPI_APPS_CBCR                 0x0B04
+#define BLSP2_QUP4_I2C_APPS_CBCR                 0x0B08
+#define BLSP2_UART4_APPS_CBCR                    0x0B44
+#define BLSP2_UART4_SIM_CBCR                     0x0B48
+#define BLSP2_QUP5_SPI_APPS_CBCR                 0x0B84
+#define BLSP2_QUP5_I2C_APPS_CBCR                 0x0B88
+#define BLSP2_UART5_APPS_CBCR                    0x0BC4
+#define BLSP2_UART5_SIM_CBCR                     0x0BC8
+#define BLSP2_QUP6_SPI_APPS_CBCR                 0x0C04
+#define BLSP2_QUP6_I2C_APPS_CBCR                 0x0C08
+#define BLSP2_UART6_APPS_CBCR                    0x0C44
+#define BLSP2_UART6_SIM_CBCR                     0x0C48
+#define PDM_AHB_CBCR                             0x0CC4
+#define PDM_XO4_CBCR                             0x0CC8
+#define PDM2_CBCR                                0x0CCC
+#define PRNG_AHB_CBCR                            0x0D04
+#define BAM_DMA_AHB_CBCR                         0x0D44
+#define TSIF_AHB_CBCR                            0x0D84
+#define TSIF_REF_CBCR                            0x0D88
+#define MSG_RAM_AHB_CBCR                         0x0E44
+#define CE1_CBCR                                 0x1044
+#define CE1_AXI_CBCR                             0x1048
+#define CE1_AHB_CBCR                             0x104C
+#define CE2_CBCR                                 0x1084
+#define CE2_AXI_CBCR                             0x1088
+#define CE2_AHB_CBCR                             0x108C
+#define GCC_AHB_CBCR                             0x10C0
+#define GP1_CBCR                                 0x1900
+#define GP2_CBCR                                 0x1940
+#define GP3_CBCR                                 0x1980
+#define AUDIO_CORE_GDSCR			 0x7000
+#define AUDIO_CORE_IXFABRIC_CBCR		 0x1B000
+#define AUDIO_CORE_LPAIF_CODEC_SPKR_OSR_CBCR     0xA014
+#define AUDIO_CORE_LPAIF_CODEC_SPKR_IBIT_CBCR    0xA018
+#define AUDIO_CORE_LPAIF_CODEC_SPKR_EBIT_CBCR    0xA01C
+#define AUDIO_CORE_LPAIF_PRI_OSR_CBCR            0xB014
+#define AUDIO_CORE_LPAIF_PRI_IBIT_CBCR           0xB018
+#define AUDIO_CORE_LPAIF_PRI_EBIT_CBCR           0xB01C
+#define AUDIO_CORE_LPAIF_SEC_OSR_CBCR            0xC014
+#define AUDIO_CORE_LPAIF_SEC_IBIT_CBCR           0xC018
+#define AUDIO_CORE_LPAIF_SEC_EBIT_CBCR           0xC01C
+#define AUDIO_CORE_LPAIF_TER_OSR_CBCR            0xD014
+#define AUDIO_CORE_LPAIF_TER_IBIT_CBCR           0xD018
+#define AUDIO_CORE_LPAIF_TER_EBIT_CBCR           0xD01C
+#define AUDIO_CORE_LPAIF_QUAD_OSR_CBCR           0xE014
+#define AUDIO_CORE_LPAIF_QUAD_IBIT_CBCR          0xE018
+#define AUDIO_CORE_LPAIF_QUAD_EBIT_CBCR          0xE01C
+#define AUDIO_CORE_LPAIF_PCM0_IBIT_CBCR          0xF014
+#define AUDIO_CORE_LPAIF_PCM0_EBIT_CBCR          0xF018
+#define AUDIO_CORE_LPAIF_PCM1_IBIT_CBCR          0x10014
+#define AUDIO_CORE_LPAIF_PCM1_EBIT_CBCR          0x10018
+#define AUDIO_CORE_RESAMPLER_CORE_CBCR           0x11014
+#define AUDIO_CORE_RESAMPLER_LFABIF_CBCR         0x11018
+#define AUDIO_CORE_SLIMBUS_CORE_CBCR             0x12014
+#define AUDIO_CORE_SLIMBUS_LFABIF_CBCR           0x12018
+#define AUDIO_CORE_LPAIF_PCM_DATA_OE_CBCR        0x13014
+#define VENUS0_VCODEC0_CBCR                      0x1028
+#define VENUS0_AHB_CBCR                          0x1030
+#define VENUS0_AXI_CBCR                          0x1034
+#define VENUS0_OCMEMNOC_CBCR                     0x1038
+#define MDSS_AHB_CBCR                            0x2308
+#define MDSS_HDMI_AHB_CBCR                       0x230C
+#define MDSS_AXI_CBCR                            0x2310
+#define MDSS_PCLK0_CBCR                          0x2314
+#define MDSS_PCLK1_CBCR                          0x2318
+#define MDSS_MDP_CBCR                            0x231C
+#define MDSS_MDP_LUT_CBCR                        0x2320
+#define MDSS_EXTPCLK_CBCR                        0x2324
+#define MDSS_VSYNC_CBCR                          0x2328
+#define MDSS_EDPPIXEL_CBCR                       0x232C
+#define MDSS_EDPLINK_CBCR                        0x2330
+#define MDSS_EDPAUX_CBCR                         0x2334
+#define MDSS_HDMI_CBCR                           0x2338
+#define MDSS_BYTE0_CBCR                          0x233C
+#define MDSS_BYTE1_CBCR                          0x2340
+#define MDSS_ESC0_CBCR                           0x2344
+#define MDSS_ESC1_CBCR                           0x2348
+#define CAMSS_PHY0_CSI0PHYTIMER_CBCR             0x3024
+#define CAMSS_PHY1_CSI1PHYTIMER_CBCR             0x3054
+#define CAMSS_PHY2_CSI2PHYTIMER_CBCR             0x3084
+#define CAMSS_CSI0_CBCR                          0x30B4
+#define CAMSS_CSI0_AHB_CBCR                      0x30BC
+#define CAMSS_CSI0PHY_CBCR                       0x30C4
+#define CAMSS_CSI0RDI_CBCR                       0x30D4
+#define CAMSS_CSI0PIX_CBCR                       0x30E4
+#define CAMSS_CSI1_CBCR                          0x3124
+#define CAMSS_CSI1_AHB_CBCR                      0x3128
+#define CAMSS_CSI1PHY_CBCR                       0x3134
+#define CAMSS_CSI1RDI_CBCR                       0x3144
+#define CAMSS_CSI1PIX_CBCR                       0x3154
+#define CAMSS_CSI2_CBCR                          0x3184
+#define CAMSS_CSI2_AHB_CBCR                      0x3188
+#define CAMSS_CSI2PHY_CBCR                       0x3194
+#define CAMSS_CSI2RDI_CBCR                       0x31A4
+#define CAMSS_CSI2PIX_CBCR                       0x31B4
+#define CAMSS_CSI3_CBCR                          0x31E4
+#define CAMSS_CSI3_AHB_CBCR                      0x31E8
+#define CAMSS_CSI3PHY_CBCR                       0x31F4
+#define CAMSS_CSI3RDI_CBCR                       0x3204
+#define CAMSS_CSI3PIX_CBCR                       0x3214
+#define CAMSS_ISPIF_AHB_CBCR                     0x3224
+#define CAMSS_CCI_CCI_CBCR                       0x3344
+#define CAMSS_CCI_CCI_AHB_CBCR                   0x3348
+#define CAMSS_MCLK0_CBCR                         0x3384
+#define CAMSS_MCLK1_CBCR                         0x33B4
+#define CAMSS_MCLK2_CBCR                         0x33E4
+#define CAMSS_MCLK3_CBCR                         0x3414
+#define CAMSS_GP0_CBCR                           0x3444
+#define CAMSS_GP1_CBCR                           0x3474
+#define CAMSS_TOP_AHB_CBCR                       0x3484
+#define CAMSS_MICRO_AHB_CBCR                     0x3494
+#define CAMSS_JPEG_JPEG0_CBCR                    0x35A8
+#define CAMSS_JPEG_JPEG1_CBCR                    0x35AC
+#define CAMSS_JPEG_JPEG2_CBCR                    0x35B0
+#define CAMSS_JPEG_JPEG_AHB_CBCR                 0x35B4
+#define CAMSS_JPEG_JPEG_AXI_CBCR                 0x35B8
+#define CAMSS_JPEG_JPEG_OCMEMNOC_CBCR            0x35BC
+#define CAMSS_VFE_VFE0_CBCR                      0x36A8
+#define CAMSS_VFE_VFE1_CBCR                      0x36AC
+#define CAMSS_VFE_CPP_CBCR                       0x36B0
+#define CAMSS_VFE_CPP_AHB_CBCR                   0x36B4
+#define CAMSS_VFE_VFE_AHB_CBCR                   0x36B8
+#define CAMSS_VFE_VFE_AXI_CBCR                   0x36BC
+#define CAMSS_VFE_VFE_OCMEMNOC_CBCR              0x36C0
+#define CAMSS_CSI_VFE0_CBCR                      0x3704
+#define CAMSS_CSI_VFE1_CBCR                      0x3714
+#define MMSS_MMSSNOC_AXI_CBCR                    0x506C
+#define MMSS_MMSSNOC_AHB_CBCR                    0x5024
+#define MMSS_MMSSNOC_BTO_AHB_CBCR                0x5028
+#define MMSS_MISC_AHB_CBCR                       0x502C
+#define MMSS_S0_AXI_CBCR                         0x5064
+#define OCMEMNOC_CBCR                            0x50B4
+#define LPASS_Q6SS_AHB_LFABIF_CBCR               0x22000
+#define LPASS_Q6SS_XO_CBCR                       0x26000
+#define LPASS_Q6_AXI_CBCR			 0x11C0
+#define Q6SS_AHBM_CBCR				 0x22004
+#define AUDIO_WRAPPER_BR_CBCR			 0x24000
+#define MSS_CFG_AHB_CBCR                         0x0280
+#define MSS_Q6_BIMC_AXI_CBCR			 0x0284
+
+#define APCS_CLOCK_BRANCH_ENA_VOTE 0x1484
+#define APCS_CLOCK_SLEEP_ENA_VOTE  0x1488
+
+/* Mux source select values */
+#define cxo_source_val	0
+#define gpll0_source_val 1
+#define gpll1_source_val 2
+#define gpll4_source_val 5
+#define gnd_source_val	5
+#define mmpll0_mm_source_val 1
+#define mmpll1_mm_source_val 2
+#define mmpll3_mm_source_val 3
+#define gpll0_mm_source_val 5
+#define cxo_mm_source_val 0
+#define mm_gnd_source_val 6
+#define gpll1_hsic_source_val 4
+#define cxo_lpass_source_val 0
+#define gpll0_lpass_source_val 5
+#define edp_mainlink_mm_source_val 4
+#define edp_pixel_mm_source_val 5
+#define edppll_350_mm_source_val 4
+#define dsipll_750_mm_source_val 1
+#define dsipll0_byte_mm_source_val 1
+#define dsipll0_pixel_mm_source_val 1
+#define hdmipll_mm_source_val 3
+
+#define F_GCC_GND \
+	{ \
+		.freq_hz = 0, \
+		.m_val = 0, \
+		.n_val  = 0, \
+		.div_src_val = BVAL(4, 0, 1) | BVAL(10, 8, gnd_source_val), \
+	}
+
+#define F(f, s, div, m, n) \
+	{ \
+		.freq_hz = (f), \
+		.src_clk = &s##_clk_src.c, \
+		.m_val = (m), \
+		.n_val = ~((n)-(m)) * !!(n), \
+		.d_val = ~(n),\
+		.div_src_val = BVAL(4, 0, (int)(2*(div) - 1)) \
+			| BVAL(10, 8, s##_source_val), \
+	}
+
+#define F_MM(f, s, div, m, n) \
+	{ \
+		.freq_hz = (f), \
+		.src_clk = &s##_clk_src.c, \
+		.m_val = (m), \
+		.n_val = ~((n)-(m)) * !!(n), \
+		.d_val = ~(n),\
+		.div_src_val = BVAL(4, 0, (int)(2*(div) - 1)) \
+			| BVAL(10, 8, s##_mm_source_val), \
+	}
+
+#define F_EDP(f, s, div, m, n) \
+	{ \
+		.freq_hz = (f), \
+		.src_clk = &s##_clk_src.c, \
+		.m_val = (m), \
+		.n_val = ~((n)-(m)) * !!(n), \
+		.d_val = ~(n),\
+		.div_src_val = BVAL(4, 0, (int)(2*(div) - 1)) \
+			| BVAL(10, 8, s##_mm_source_val), \
+	}
+
+#define F_MDSS(f, s, div, m, n) \
+	{ \
+		.freq_hz = (f), \
+		.m_val = (m), \
+		.n_val = ~((n)-(m)) * !!(n), \
+		.d_val = ~(n),\
+		.div_src_val = BVAL(4, 0, (int)(2*(div) - 1)) \
+			| BVAL(10, 8, s##_mm_source_val), \
+	}
+
+#define F_HSIC(f, s, div, m, n) \
+	{ \
+		.freq_hz = (f), \
+		.src_clk = &s##_clk_src.c, \
+		.m_val = (m), \
+		.n_val = ~((n)-(m)) * !!(n), \
+		.d_val = ~(n),\
+		.div_src_val = BVAL(4, 0, (int)(2*(div) - 1)) \
+			| BVAL(10, 8, s##_hsic_source_val), \
+	}
+
+#define F_LPASS(f, s, div, m, n) \
+	{ \
+		.freq_hz = (f), \
+		.src_clk = &s##_clk_src.c, \
+		.m_val = (m), \
+		.n_val = ~((n)-(m)) * !!(n), \
+		.d_val = ~(n),\
+		.div_src_val = BVAL(4, 0, (int)(2*(div) - 1)) \
+			| BVAL(10, 8, s##_lpass_source_val), \
+	}
+
+#define VDD_DIG_FMAX_MAP1(l1, f1) \
+	.vdd_class = &vdd_dig,			\
+	.fmax = (unsigned long[VDD_DIG_NUM]) {	\
+		[VDD_DIG_##l1] = (f1),		\
+	},					\
+	.num_fmax = VDD_DIG_NUM
+#define VDD_DIG_FMAX_MAP2(l1, f1, l2, f2) \
+	.vdd_class = &vdd_dig,			\
+	.fmax = (unsigned long[VDD_DIG_NUM]) {	\
+		[VDD_DIG_##l1] = (f1),		\
+		[VDD_DIG_##l2] = (f2),		\
+	},					\
+	.num_fmax = VDD_DIG_NUM
+#define VDD_DIG_FMAX_MAP3(l1, f1, l2, f2, l3, f3) \
+	.vdd_class = &vdd_dig,			\
+	.fmax = (unsigned long[VDD_DIG_NUM]) {	\
+		[VDD_DIG_##l1] = (f1),		\
+		[VDD_DIG_##l2] = (f2),		\
+		[VDD_DIG_##l3] = (f3),		\
+	},					\
+	.num_fmax = VDD_DIG_NUM
+
+enum vdd_dig_levels {
+	VDD_DIG_NONE,
+	VDD_DIG_LOW,
+	VDD_DIG_NOMINAL,
+	VDD_DIG_HIGH,
+	VDD_DIG_NUM
+};
+
+static int vdd_corner[] = {
+	RPM_REGULATOR_CORNER_NONE,		/* VDD_DIG_NONE */
+	RPM_REGULATOR_CORNER_SVS_SOC,		/* VDD_DIG_LOW */
+	RPM_REGULATOR_CORNER_NORMAL,		/* VDD_DIG_NOMINAL */
+	RPM_REGULATOR_CORNER_SUPER_TURBO,	/* VDD_DIG_HIGH */
+};
+
+static DEFINE_VDD_REGULATORS(vdd_dig, VDD_DIG_NUM, 1, vdd_corner, NULL);
+
+#define RPM_MISC_CLK_TYPE	0x306b6c63
+#define RPM_BUS_CLK_TYPE	0x316b6c63
+#define RPM_MEM_CLK_TYPE	0x326b6c63
+
+#define RPM_SMD_KEY_ENABLE	0x62616E45
+
+#define CXO_ID			0x0
+#define QDSS_ID			0x1
+
+#define PNOC_ID		0x0
+#define SNOC_ID		0x1
+#define CNOC_ID		0x2
+#define MMSSNOC_AHB_ID  0x3
+
+#define BIMC_ID		0x0
+#define OXILI_ID	0x1
+#define OCMEM_ID	0x2
+
+#define D0_ID		 1
+#define D1_ID		 2
+#define A0_ID		 4
+#define A1_ID		 5
+#define A2_ID		 6
+#define DIFF_CLK_ID	 7
+#define DIV_CLK1_ID	11
+#define DIV_CLK2_ID	12
+
+DEFINE_CLK_RPM_SMD(pnoc_clk, pnoc_a_clk, RPM_BUS_CLK_TYPE, PNOC_ID, NULL);
+DEFINE_CLK_RPM_SMD(snoc_clk, snoc_a_clk, RPM_BUS_CLK_TYPE, SNOC_ID, NULL);
+DEFINE_CLK_RPM_SMD(cnoc_clk, cnoc_a_clk, RPM_BUS_CLK_TYPE, CNOC_ID, NULL);
+DEFINE_CLK_RPM_SMD(mmssnoc_ahb_clk, mmssnoc_ahb_a_clk, RPM_BUS_CLK_TYPE,
+			MMSSNOC_AHB_ID, NULL);
+
+DEFINE_CLK_RPM_SMD(bimc_clk, bimc_a_clk, RPM_MEM_CLK_TYPE, BIMC_ID, NULL);
+DEFINE_CLK_RPM_SMD(ocmemgx_clk, ocmemgx_a_clk, RPM_MEM_CLK_TYPE, OCMEM_ID,
+			NULL);
+DEFINE_CLK_RPM_SMD(gfx3d_clk_src, gfx3d_a_clk_src, RPM_MEM_CLK_TYPE, OXILI_ID,
+			NULL);
+
+DEFINE_CLK_RPM_SMD_BRANCH(cxo_clk_src, cxo_a_clk_src,
+				RPM_MISC_CLK_TYPE, CXO_ID, 19200000);
+DEFINE_CLK_RPM_SMD_QDSS(qdss_clk, qdss_a_clk, RPM_MISC_CLK_TYPE, QDSS_ID);
+
+DEFINE_CLK_RPM_SMD_XO_BUFFER(cxo_d0, cxo_d0_a, D0_ID);
+DEFINE_CLK_RPM_SMD_XO_BUFFER(cxo_d1, cxo_d1_a, D1_ID);
+DEFINE_CLK_RPM_SMD_XO_BUFFER(cxo_a0, cxo_a0_a, A0_ID);
+DEFINE_CLK_RPM_SMD_XO_BUFFER(cxo_a1, cxo_a1_a, A1_ID);
+DEFINE_CLK_RPM_SMD_XO_BUFFER(cxo_a2, cxo_a2_a, A2_ID);
+DEFINE_CLK_RPM_SMD_XO_BUFFER(div_clk1, div_a_clk1, DIV_CLK1_ID);
+DEFINE_CLK_RPM_SMD_XO_BUFFER(div_clk2, div_a_clk2, DIV_CLK2_ID);
+DEFINE_CLK_RPM_SMD_XO_BUFFER(diff_clk, diff_a_clk, DIFF_CLK_ID);
+
+DEFINE_CLK_RPM_SMD_XO_BUFFER_PINCTRL(cxo_d0_pin, cxo_d0_a_pin, D0_ID);
+DEFINE_CLK_RPM_SMD_XO_BUFFER_PINCTRL(cxo_d1_pin, cxo_d1_a_pin, D1_ID);
+DEFINE_CLK_RPM_SMD_XO_BUFFER_PINCTRL(cxo_a0_pin, cxo_a0_a_pin, A0_ID);
+DEFINE_CLK_RPM_SMD_XO_BUFFER_PINCTRL(cxo_a1_pin, cxo_a1_a_pin, A1_ID);
+DEFINE_CLK_RPM_SMD_XO_BUFFER_PINCTRL(cxo_a2_pin, cxo_a2_a_pin, A2_ID);
+
+static unsigned int soft_vote_gpll0;
+
+static struct pll_vote_clk gpll0_ao_clk_src = {
+	.en_reg = (void __iomem *)APCS_GPLL_ENA_VOTE_REG,
+	.en_mask = BIT(0),
+	.status_reg = (void __iomem *)GPLL0_STATUS_REG,
+	.status_mask = BIT(17),
+	.soft_vote = &soft_vote_gpll0,
+	.soft_vote_mask = PLL_SOFT_VOTE_ACPU,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &cxo_a_clk_src.c,
+		.rate = 600000000,
+		.dbg_name = "gpll0_ao_clk_src",
+		.ops = &clk_ops_pll_acpu_vote,
+		CLK_INIT(gpll0_ao_clk_src.c),
+	},
+};
+
+static struct pll_vote_clk gpll0_clk_src = {
+	.en_reg = (void __iomem *)APCS_GPLL_ENA_VOTE_REG,
+	.en_mask = BIT(0),
+	.status_reg = (void __iomem *)GPLL0_STATUS_REG,
+	.status_mask = BIT(17),
+	.soft_vote = &soft_vote_gpll0,
+	.soft_vote_mask = PLL_SOFT_VOTE_PRIMARY,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &cxo_clk_src.c,
+		.rate = 600000000,
+		.dbg_name = "gpll0_clk_src",
+		.ops = &clk_ops_pll_acpu_vote,
+		CLK_INIT(gpll0_clk_src.c),
+	},
+};
+
+static struct pll_vote_clk gpll1_clk_src = {
+	.en_reg = (void __iomem *)APCS_GPLL_ENA_VOTE_REG,
+	.en_mask = BIT(1),
+	.status_reg = (void __iomem *)GPLL1_STATUS_REG,
+	.status_mask = BIT(17),
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &cxo_clk_src.c,
+		.rate = 480000000,
+		.dbg_name = "gpll1_clk_src",
+		.ops = &clk_ops_pll_vote,
+		CLK_INIT(gpll1_clk_src.c),
+	},
+};
+
+static struct pll_vote_clk gpll4_clk_src = {
+	.en_reg = (void __iomem *)APCS_GPLL_ENA_VOTE_REG,
+	.en_mask = BIT(4),
+	.status_reg = (void __iomem *)GPLL4_STATUS_REG,
+	.status_mask = BIT(17),
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &cxo_clk_src.c,
+		.rate = 768000000,
+		.dbg_name = "gpll4_clk_src",
+		.ops = &clk_ops_pll_vote,
+		CLK_INIT(gpll4_clk_src.c),
+	},
+};
+
+static struct pll_vote_clk mmpll0_clk_src = {
+	.en_reg = (void __iomem *)MMSS_PLL_VOTE_APCS_REG,
+	.en_mask = BIT(0),
+	.status_reg = (void __iomem *)MMPLL0_STATUS_REG,
+	.status_mask = BIT(17),
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &cxo_clk_src.c,
+		.dbg_name = "mmpll0_clk_src",
+		.rate = 800000000,
+		.ops = &clk_ops_pll_vote,
+		CLK_INIT(mmpll0_clk_src.c),
+	},
+};
+
+static struct pll_vote_clk mmpll1_clk_src = {
+	.en_reg = (void __iomem *)MMSS_PLL_VOTE_APCS_REG,
+	.en_mask = BIT(1),
+	.status_reg = (void __iomem *)MMPLL1_STATUS_REG,
+	.status_mask = BIT(17),
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &cxo_clk_src.c,
+		.dbg_name = "mmpll1_clk_src",
+		.rate = 846000000,
+		.ops = &clk_ops_pll_vote,
+		/* May be reassigned at runtime; alloc memory at compile time */
+		VDD_DIG_FMAX_MAP1(LOW, 846000000),
+		CLK_INIT(mmpll1_clk_src.c),
+	},
+};
+
+static struct pll_clk mmpll3_clk_src = {
+	.mode_reg = (void __iomem *)MMPLL3_MODE_REG,
+	.status_reg = (void __iomem *)MMPLL3_STATUS_REG,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &cxo_clk_src.c,
+		.dbg_name = "mmpll3_clk_src",
+		.rate = 820000000,
+		.ops = &clk_ops_local_pll,
+		CLK_INIT(mmpll3_clk_src.c),
+	},
+};
+
+static DEFINE_CLK_VOTER(pnoc_msmbus_clk, &pnoc_clk.c, LONG_MAX);
+static DEFINE_CLK_VOTER(snoc_msmbus_clk, &snoc_clk.c, LONG_MAX);
+static DEFINE_CLK_VOTER(cnoc_msmbus_clk, &cnoc_clk.c, LONG_MAX);
+static DEFINE_CLK_VOTER(pnoc_msmbus_a_clk, &pnoc_a_clk.c, LONG_MAX);
+static DEFINE_CLK_VOTER(snoc_msmbus_a_clk, &snoc_a_clk.c, LONG_MAX);
+static DEFINE_CLK_VOTER(cnoc_msmbus_a_clk, &cnoc_a_clk.c, LONG_MAX);
+
+static DEFINE_CLK_VOTER(bimc_msmbus_clk, &bimc_clk.c, LONG_MAX);
+static DEFINE_CLK_VOTER(bimc_msmbus_a_clk, &bimc_a_clk.c, LONG_MAX);
+static DEFINE_CLK_VOTER(bimc_acpu_a_clk, &bimc_a_clk.c, LONG_MAX);
+static DEFINE_CLK_VOTER(oxili_gfx3d_clk_src, &gfx3d_clk_src.c, LONG_MAX);
+static DEFINE_CLK_VOTER(ocmemgx_msmbus_clk, &ocmemgx_clk.c, LONG_MAX);
+static DEFINE_CLK_VOTER(ocmemgx_msmbus_a_clk, &ocmemgx_a_clk.c, LONG_MAX);
+static DEFINE_CLK_VOTER(ocmemgx_core_clk, &ocmemgx_clk.c, LONG_MAX);
+
+static DEFINE_CLK_VOTER(pnoc_keepalive_a_clk, &pnoc_a_clk.c, LONG_MAX);
+static DEFINE_CLK_VOTER(pnoc_sps_clk, &pnoc_clk.c, 0);
+
+static DEFINE_CLK_BRANCH_VOTER(cxo_otg_clk, &cxo_clk_src.c);
+static DEFINE_CLK_BRANCH_VOTER(cxo_pil_lpass_clk, &cxo_clk_src.c);
+static DEFINE_CLK_BRANCH_VOTER(cxo_pil_mss_clk, &cxo_clk_src.c);
+static DEFINE_CLK_BRANCH_VOTER(cxo_wlan_clk, &cxo_clk_src.c);
+static DEFINE_CLK_BRANCH_VOTER(cxo_pil_pronto_clk, &cxo_clk_src.c);
+static DEFINE_CLK_BRANCH_VOTER(cxo_dwc3_clk, &cxo_clk_src.c);
+static DEFINE_CLK_BRANCH_VOTER(cxo_ehci_host_clk, &cxo_clk_src.c);
+static DEFINE_CLK_BRANCH_VOTER(cxo_lpm_clk, &cxo_clk_src.c);
+
+static struct clk_freq_tbl ftbl_gcc_usb30_master_clk[] = {
+	F(125000000,  gpll0,   1,   5,  24),
+	F_END
+};
+
+static struct rcg_clk usb30_master_clk_src = {
+	.cmd_rcgr_reg = USB30_MASTER_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_usb30_master_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "usb30_master_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP1(NOMINAL, 125000000),
+		CLK_INIT(usb30_master_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_gcc_blsp1_2_qup1_6_spi_apps_clk[] = {
+	F(  960000,    cxo,  10,   1,   2),
+	F( 4800000,    cxo,   4,   0,   0),
+	F( 9600000,    cxo,   2,   0,   0),
+	F(15000000,  gpll0,  10,   1,   4),
+	F(19200000,    cxo,   1,   0,   0),
+	F(25000000,  gpll0,  12,   1,   2),
+	F(50000000,  gpll0,  12,   0,   0),
+	F_END
+};
+
+static struct rcg_clk blsp1_qup1_spi_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP1_QUP1_SPI_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_spi_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp1_qup1_spi_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 25000000, NOMINAL, 50000000),
+		CLK_INIT(blsp1_qup1_spi_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp1_qup2_spi_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP1_QUP2_SPI_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_spi_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp1_qup2_spi_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 25000000, NOMINAL, 50000000),
+		CLK_INIT(blsp1_qup2_spi_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp1_qup3_spi_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP1_QUP3_SPI_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_spi_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp1_qup3_spi_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 25000000, NOMINAL, 50000000),
+		CLK_INIT(blsp1_qup3_spi_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp1_qup4_spi_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP1_QUP4_SPI_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_spi_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp1_qup4_spi_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 25000000, NOMINAL, 50000000),
+		CLK_INIT(blsp1_qup4_spi_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp1_qup5_spi_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP1_QUP5_SPI_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_spi_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp1_qup5_spi_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 25000000, NOMINAL, 50000000),
+		CLK_INIT(blsp1_qup5_spi_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp1_qup6_spi_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP1_QUP6_SPI_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_spi_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp1_qup6_spi_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 25000000, NOMINAL, 50000000),
+		CLK_INIT(blsp1_qup6_spi_apps_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_gcc_blsp1_2_qup1_6_i2c_apps_clk[] = {
+	F(19200000,    cxo,   1,   0,   0),
+	F(50000000,  gpll0,  12,   0,   0),
+	F_END
+};
+
+static struct rcg_clk blsp1_qup1_i2c_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP1_QUP1_I2C_APPS_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_i2c_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp1_qup1_i2c_apps_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP1(LOW, 50000000),
+		CLK_INIT(blsp1_qup1_i2c_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp1_qup2_i2c_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP1_QUP2_I2C_APPS_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_i2c_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp1_qup2_i2c_apps_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP1(LOW, 50000000),
+		CLK_INIT(blsp1_qup2_i2c_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp1_qup3_i2c_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP1_QUP3_I2C_APPS_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_i2c_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp1_qup3_i2c_apps_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP1(LOW, 50000000),
+		CLK_INIT(blsp1_qup3_i2c_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp1_qup4_i2c_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP1_QUP4_I2C_APPS_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_i2c_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp1_qup4_i2c_apps_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP1(LOW, 50000000),
+		CLK_INIT(blsp1_qup4_i2c_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp1_qup5_i2c_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP1_QUP5_I2C_APPS_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_i2c_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp1_qup5_i2c_apps_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP1(LOW, 50000000),
+		CLK_INIT(blsp1_qup5_i2c_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp1_qup6_i2c_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP1_QUP6_I2C_APPS_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_i2c_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp1_qup6_i2c_apps_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP1(LOW, 50000000),
+		CLK_INIT(blsp1_qup6_i2c_apps_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_gcc_blsp1_2_uart1_6_apps_clk[] = {
+	F_GCC_GND,
+	F( 3686400,  gpll0,    1,  96,  15625),
+	F( 7372800,  gpll0,    1, 192,  15625),
+	F(14745600,  gpll0,    1, 384,  15625),
+	F(16000000,  gpll0,    5,   2,     15),
+	F(19200000,    cxo,    1,   0,      0),
+	F(24000000,  gpll0,    5,   1,      5),
+	F(32000000,  gpll0,    1,   4,     75),
+	F(40000000,  gpll0,   15,   0,      0),
+	F(46400000,  gpll0,    1,  29,    375),
+	F(48000000,  gpll0, 12.5,   0,      0),
+	F(51200000,  gpll0,    1,  32,    375),
+	F(56000000,  gpll0,    1,   7,     75),
+	F(58982400,  gpll0,    1, 1536, 15625),
+	F(60000000,  gpll0,   10,   0,      0),
+	F(63160000,  gpll0,  9.5,   0,      0),
+	F_END
+};
+
+static struct rcg_clk blsp1_uart1_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP1_UART1_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_uart1_6_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp1_uart1_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 31580000, NOMINAL, 63160000),
+		CLK_INIT(blsp1_uart1_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp1_uart2_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP1_UART2_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_uart1_6_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp1_uart2_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 31580000, NOMINAL, 63160000),
+		CLK_INIT(blsp1_uart2_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp1_uart3_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP1_UART3_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_uart1_6_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp1_uart3_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 31580000, NOMINAL, 63160000),
+		CLK_INIT(blsp1_uart3_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp1_uart4_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP1_UART4_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_uart1_6_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp1_uart4_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 31580000, NOMINAL, 63160000),
+		CLK_INIT(blsp1_uart4_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp1_uart5_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP1_UART5_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_uart1_6_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp1_uart5_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 31580000, NOMINAL, 63160000),
+		CLK_INIT(blsp1_uart5_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp1_uart6_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP1_UART6_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_uart1_6_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp1_uart6_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 31580000, NOMINAL, 63160000),
+		CLK_INIT(blsp1_uart6_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp2_qup1_spi_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP2_QUP1_SPI_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_spi_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp2_qup1_spi_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 25000000, NOMINAL, 50000000),
+		CLK_INIT(blsp2_qup1_spi_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp2_qup2_spi_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP2_QUP2_SPI_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_spi_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp2_qup2_spi_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 25000000, NOMINAL, 50000000),
+		CLK_INIT(blsp2_qup2_spi_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp2_qup3_spi_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP2_QUP3_SPI_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_spi_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp2_qup3_spi_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 25000000, NOMINAL, 50000000),
+		CLK_INIT(blsp2_qup3_spi_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp2_qup4_spi_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP2_QUP4_SPI_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_spi_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp2_qup4_spi_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 25000000, NOMINAL, 50000000),
+		CLK_INIT(blsp2_qup4_spi_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp2_qup5_spi_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP2_QUP5_SPI_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_spi_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp2_qup5_spi_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 25000000, NOMINAL, 50000000),
+		CLK_INIT(blsp2_qup5_spi_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp2_qup6_spi_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP2_QUP6_SPI_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_spi_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp2_qup6_spi_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 25000000, NOMINAL, 50000000),
+		CLK_INIT(blsp2_qup6_spi_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp2_qup1_i2c_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP2_QUP1_I2C_APPS_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_i2c_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp2_qup1_i2c_apps_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP1(LOW, 50000000),
+		CLK_INIT(blsp2_qup1_i2c_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp2_qup2_i2c_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP2_QUP2_I2C_APPS_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_i2c_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp2_qup2_i2c_apps_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP1(LOW, 50000000),
+		CLK_INIT(blsp2_qup2_i2c_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp2_qup3_i2c_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP2_QUP3_I2C_APPS_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_i2c_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp2_qup3_i2c_apps_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP1(LOW, 50000000),
+		CLK_INIT(blsp2_qup3_i2c_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp2_qup4_i2c_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP2_QUP4_I2C_APPS_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_i2c_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp2_qup4_i2c_apps_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP1(LOW, 50000000),
+		CLK_INIT(blsp2_qup4_i2c_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp2_qup5_i2c_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP2_QUP5_I2C_APPS_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_i2c_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp2_qup5_i2c_apps_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP1(LOW, 50000000),
+		CLK_INIT(blsp2_qup5_i2c_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp2_qup6_i2c_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP2_QUP6_I2C_APPS_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_gcc_blsp1_2_qup1_6_i2c_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp2_qup6_i2c_apps_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP1(LOW, 50000000),
+		CLK_INIT(blsp2_qup6_i2c_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp2_uart1_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP2_UART1_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_uart1_6_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp2_uart1_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 31580000, NOMINAL, 63160000),
+		CLK_INIT(blsp2_uart1_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp2_uart2_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP2_UART2_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_uart1_6_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp2_uart2_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 31580000, NOMINAL, 63160000),
+		CLK_INIT(blsp2_uart2_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp2_uart3_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP2_UART3_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_uart1_6_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp2_uart3_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 31580000, NOMINAL, 63160000),
+		CLK_INIT(blsp2_uart3_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp2_uart4_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP2_UART4_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_uart1_6_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp2_uart4_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 31580000, NOMINAL, 63160000),
+		CLK_INIT(blsp2_uart4_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp2_uart5_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP2_UART5_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_uart1_6_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp2_uart5_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 31580000, NOMINAL, 63160000),
+		CLK_INIT(blsp2_uart5_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk blsp2_uart6_apps_clk_src = {
+	.cmd_rcgr_reg = BLSP2_UART6_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_blsp1_2_uart1_6_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "blsp2_uart6_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 31580000, NOMINAL, 63160000),
+		CLK_INIT(blsp2_uart6_apps_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_gcc_ce1_clk[] = {
+	F( 50000000,  gpll0,  12,   0,   0),
+	F(100000000,  gpll0,   6,   0,   0),
+	F_END
+};
+
+static struct clk_freq_tbl ftbl_gcc_ce1_pro_clk[] = {
+	F( 50000000,  gpll0,  12,   0,   0),
+	F( 75000000,  gpll0,   8,   0,   0),
+	F(100000000,  gpll0,   6,   0,   0),
+	F(150000000,  gpll0,   4,   0,   0),
+	F_END
+};
+
+static struct rcg_clk ce1_clk_src = {
+	.cmd_rcgr_reg = CE1_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_gcc_ce1_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "ce1_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP2(LOW, 50000000, NOMINAL, 100000000),
+		CLK_INIT(ce1_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_gcc_ce2_clk[] = {
+	F( 50000000,  gpll0,  12,   0,   0),
+	F(100000000,  gpll0,   6,   0,   0),
+	F_END
+};
+
+static struct clk_freq_tbl ftbl_gcc_ce2_pro_clk[] = {
+	F( 50000000,  gpll0,  12,   0,   0),
+	F( 75000000,  gpll0,   8,   0,   0),
+	F(100000000,  gpll0,   6,   0,   0),
+	F(150000000,  gpll0,   4,   0,   0),
+	F_END
+};
+
+static struct rcg_clk ce2_clk_src = {
+	.cmd_rcgr_reg = CE2_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_gcc_ce2_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "ce2_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP2(LOW, 50000000, NOMINAL, 100000000),
+		CLK_INIT(ce2_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_gcc_gp_clk[] = {
+	F( 4800000,   cxo,  4,  0,   0),
+	F( 6000000, gpll0, 10,  1,  10),
+	F( 6750000, gpll0,  1,  1,  89),
+	F( 8000000, gpll0, 15,  1,   5),
+	F( 9600000,   cxo,  2,  0,   0),
+	F(16000000, gpll0,  1,  2,  75),
+	F(19200000,   cxo,  1,  0,   0),
+	F(24000000, gpll0,  5,  1,   5),
+	F_END
+};
+
+static struct rcg_clk gp1_clk_src = {
+	.cmd_rcgr_reg = GP1_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_gp_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gp1_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 100000000, NOMINAL, 200000000),
+		CLK_INIT(gp1_clk_src.c),
+	},
+};
+
+static struct rcg_clk gp2_clk_src = {
+	.cmd_rcgr_reg = GP2_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_gp_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gp2_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 100000000, NOMINAL, 200000000),
+		CLK_INIT(gp2_clk_src.c),
+	},
+};
+
+static struct rcg_clk gp3_clk_src = {
+	.cmd_rcgr_reg = GP3_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_gp_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gp3_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 100000000, NOMINAL, 200000000),
+		CLK_INIT(gp3_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_gcc_pdm2_clk[] = {
+	F(60000000,  gpll0,  10,   0,   0),
+	F_END
+};
+
+static struct rcg_clk pdm2_clk_src = {
+	.cmd_rcgr_reg = PDM2_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_gcc_pdm2_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "pdm2_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP1(LOW, 60000000),
+		CLK_INIT(pdm2_clk_src.c),
+	},
+};
+
+/* For MSM8974Pro SDCC1 */
+static struct clk_freq_tbl ftbl_gcc_sdcc1_apps_clk_ac[] = {
+	F(   144000,    cxo,  16,   3,  25),
+	F(   400000,    cxo,  12,   1,   4),
+	F( 20000000,  gpll0,  15,   1,   2),
+	F( 25000000,  gpll0,  12,   1,   2),
+	F( 50000000,  gpll0,  12,   0,   0),
+	F(100000000,  gpll0,   6,   0,   0),
+	F(192000000,  gpll4,   4,   0,   0),
+	F(384000000,  gpll4,   2,   0,   0),
+	F_END
+};
+
+/* For SDCC1 on MSM8974 v2 and SDCC[2-4] on all MSM8974 */
+static struct clk_freq_tbl ftbl_gcc_sdcc1_4_apps_clk[] = {
+	F(   144000,    cxo,  16,   3,  25),
+	F(   400000,    cxo,  12,   1,   4),
+	F( 20000000,  gpll0,  15,   1,   2),
+	F( 25000000,  gpll0,  12,   1,   2),
+	F( 50000000,  gpll0,  12,   0,   0),
+	F(100000000,  gpll0,   6,   0,   0),
+	F(200000000,  gpll0,   3,   0,   0),
+	F_END
+};
+
+static struct clk_freq_tbl ftbl_gcc_sdcc_apps_rumi_clk[] = {
+	F(   400000,    cxo,  12,   1,   4),
+	F( 19200000,    cxo,  1,    0,   0),
+	F_END
+};
+
+static struct rcg_clk sdcc1_apps_clk_src = {
+	.cmd_rcgr_reg = SDCC1_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_sdcc1_4_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "sdcc1_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 100000000, NOMINAL, 200000000),
+		CLK_INIT(sdcc1_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk sdcc2_apps_clk_src = {
+	.cmd_rcgr_reg = SDCC2_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_sdcc1_4_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "sdcc2_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 100000000, NOMINAL, 200000000),
+		CLK_INIT(sdcc2_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk sdcc3_apps_clk_src = {
+	.cmd_rcgr_reg = SDCC3_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_sdcc1_4_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "sdcc3_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 50000000, NOMINAL, 100000000),
+		CLK_INIT(sdcc3_apps_clk_src.c),
+	},
+};
+
+static struct rcg_clk sdcc4_apps_clk_src = {
+	.cmd_rcgr_reg = SDCC4_APPS_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_sdcc1_4_apps_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "sdcc4_apps_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 50000000, NOMINAL, 100000000),
+		CLK_INIT(sdcc4_apps_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_gcc_tsif_ref_clk[] = {
+	F(105000,    cxo,   2,   1,  91),
+	F_END
+};
+
+static struct rcg_clk tsif_ref_clk_src = {
+	.cmd_rcgr_reg = TSIF_REF_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_gcc_tsif_ref_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "tsif_ref_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP1(LOW, 105500),
+		CLK_INIT(tsif_ref_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_gcc_usb30_mock_utmi_clk[] = {
+	F(60000000,  gpll0,   10,   0,   0),
+	F_END
+};
+
+static struct rcg_clk usb30_mock_utmi_clk_src = {
+	.cmd_rcgr_reg = USB30_MOCK_UTMI_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_gcc_usb30_mock_utmi_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "usb30_mock_utmi_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP1(NOMINAL, 60000000),
+		CLK_INIT(usb30_mock_utmi_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_gcc_usb_hs_system_clk[] = {
+	F(75000000,  gpll0,   8,   0,   0),
+	F_END
+};
+
+static struct rcg_clk usb_hs_system_clk_src = {
+	.cmd_rcgr_reg = USB_HS_SYSTEM_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_gcc_usb_hs_system_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "usb_hs_system_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP2(LOW, 37500000, NOMINAL, 75000000),
+		CLK_INIT(usb_hs_system_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_gcc_usb_hsic_clk[] = {
+	F_HSIC(480000000,  gpll1,   1,   0,   0),
+	F_END
+};
+
+static struct rcg_clk usb_hsic_clk_src = {
+	.cmd_rcgr_reg = USB_HSIC_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_gcc_usb_hsic_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "usb_hsic_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP1(LOW, 480000000),
+		CLK_INIT(usb_hsic_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_gcc_usb_hsic_io_cal_clk[] = {
+	F(9600000,    cxo,   2,   0,   0),
+	F_END
+};
+
+static struct rcg_clk usb_hsic_io_cal_clk_src = {
+	.cmd_rcgr_reg = USB_HSIC_IO_CAL_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_gcc_usb_hsic_io_cal_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "usb_hsic_io_cal_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP1(LOW, 9600000),
+		CLK_INIT(usb_hsic_io_cal_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_gcc_usb_hsic_system_clk[] = {
+	F(75000000,  gpll0,   8,   0,   0),
+	F_END
+};
+
+static struct rcg_clk usb_hsic_system_clk_src = {
+	.cmd_rcgr_reg = USB_HSIC_SYSTEM_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_gcc_usb_hsic_system_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "usb_hsic_system_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP2(LOW, 37500000, NOMINAL, 75000000),
+		CLK_INIT(usb_hsic_system_clk_src.c),
+	},
+};
+
+static struct local_vote_clk gcc_bam_dma_ahb_clk = {
+	.cbcr_reg = BAM_DMA_AHB_CBCR,
+	.vote_reg = APCS_CLOCK_BRANCH_ENA_VOTE,
+	.en_mask = BIT(12),
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_bam_dma_ahb_clk",
+		.ops = &clk_ops_vote,
+		CLK_INIT(gcc_bam_dma_ahb_clk.c),
+	},
+};
+
+static struct local_vote_clk gcc_blsp1_ahb_clk = {
+	.cbcr_reg = BLSP1_AHB_CBCR,
+	.vote_reg = APCS_CLOCK_BRANCH_ENA_VOTE,
+	.en_mask = BIT(17),
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_blsp1_ahb_clk",
+		.ops = &clk_ops_vote,
+		CLK_INIT(gcc_blsp1_ahb_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp1_qup1_i2c_apps_clk = {
+	.cbcr_reg = BLSP1_QUP1_I2C_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &cxo_clk_src.c,
+		.dbg_name = "gcc_blsp1_qup1_i2c_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp1_qup1_i2c_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp1_qup1_spi_apps_clk = {
+	.cbcr_reg = BLSP1_QUP1_SPI_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp1_qup1_spi_apps_clk_src.c,
+		.dbg_name = "gcc_blsp1_qup1_spi_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp1_qup1_spi_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp1_qup2_i2c_apps_clk = {
+	.cbcr_reg = BLSP1_QUP2_I2C_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &cxo_clk_src.c,
+		.dbg_name = "gcc_blsp1_qup2_i2c_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp1_qup2_i2c_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp1_qup2_spi_apps_clk = {
+	.cbcr_reg = BLSP1_QUP2_SPI_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp1_qup2_spi_apps_clk_src.c,
+		.dbg_name = "gcc_blsp1_qup2_spi_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp1_qup2_spi_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp1_qup3_i2c_apps_clk = {
+	.cbcr_reg = BLSP1_QUP3_I2C_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &cxo_clk_src.c,
+		.dbg_name = "gcc_blsp1_qup3_i2c_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp1_qup3_i2c_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp1_qup3_spi_apps_clk = {
+	.cbcr_reg = BLSP1_QUP3_SPI_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp1_qup3_spi_apps_clk_src.c,
+		.dbg_name = "gcc_blsp1_qup3_spi_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp1_qup3_spi_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp1_qup4_i2c_apps_clk = {
+	.cbcr_reg = BLSP1_QUP4_I2C_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &cxo_clk_src.c,
+		.dbg_name = "gcc_blsp1_qup4_i2c_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp1_qup4_i2c_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp1_qup4_spi_apps_clk = {
+	.cbcr_reg = BLSP1_QUP4_SPI_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp1_qup4_spi_apps_clk_src.c,
+		.dbg_name = "gcc_blsp1_qup4_spi_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp1_qup4_spi_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp1_qup5_i2c_apps_clk = {
+	.cbcr_reg = BLSP1_QUP5_I2C_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &cxo_clk_src.c,
+		.dbg_name = "gcc_blsp1_qup5_i2c_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp1_qup5_i2c_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp1_qup5_spi_apps_clk = {
+	.cbcr_reg = BLSP1_QUP5_SPI_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp1_qup5_spi_apps_clk_src.c,
+		.dbg_name = "gcc_blsp1_qup5_spi_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp1_qup5_spi_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp1_qup6_i2c_apps_clk = {
+	.cbcr_reg = BLSP1_QUP6_I2C_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &cxo_clk_src.c,
+		.dbg_name = "gcc_blsp1_qup6_i2c_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp1_qup6_i2c_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp1_qup6_spi_apps_clk = {
+	.cbcr_reg = BLSP1_QUP6_SPI_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp1_qup6_spi_apps_clk_src.c,
+		.dbg_name = "gcc_blsp1_qup6_spi_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp1_qup6_spi_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp1_uart1_apps_clk = {
+	.cbcr_reg = BLSP1_UART1_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp1_uart1_apps_clk_src.c,
+		.dbg_name = "gcc_blsp1_uart1_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp1_uart1_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp1_uart2_apps_clk = {
+	.cbcr_reg = BLSP1_UART2_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp1_uart2_apps_clk_src.c,
+		.dbg_name = "gcc_blsp1_uart2_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp1_uart2_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp1_uart3_apps_clk = {
+	.cbcr_reg = BLSP1_UART3_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp1_uart3_apps_clk_src.c,
+		.dbg_name = "gcc_blsp1_uart3_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp1_uart3_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp1_uart4_apps_clk = {
+	.cbcr_reg = BLSP1_UART4_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp1_uart4_apps_clk_src.c,
+		.dbg_name = "gcc_blsp1_uart4_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp1_uart4_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp1_uart5_apps_clk = {
+	.cbcr_reg = BLSP1_UART5_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp1_uart5_apps_clk_src.c,
+		.dbg_name = "gcc_blsp1_uart5_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp1_uart5_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp1_uart6_apps_clk = {
+	.cbcr_reg = BLSP1_UART6_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp1_uart6_apps_clk_src.c,
+		.dbg_name = "gcc_blsp1_uart6_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp1_uart6_apps_clk.c),
+	},
+};
+
+static struct local_vote_clk gcc_boot_rom_ahb_clk = {
+	.cbcr_reg = BOOT_ROM_AHB_CBCR,
+	.vote_reg = APCS_CLOCK_BRANCH_ENA_VOTE,
+	.en_mask = BIT(10),
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_boot_rom_ahb_clk",
+		.ops = &clk_ops_vote,
+		CLK_INIT(gcc_boot_rom_ahb_clk.c),
+	},
+};
+
+static struct local_vote_clk gcc_blsp2_ahb_clk = {
+	.cbcr_reg = BLSP2_AHB_CBCR,
+	.vote_reg = APCS_CLOCK_BRANCH_ENA_VOTE,
+	.en_mask = BIT(15),
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_blsp2_ahb_clk",
+		.ops = &clk_ops_vote,
+		CLK_INIT(gcc_blsp2_ahb_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp2_qup1_i2c_apps_clk = {
+	.cbcr_reg = BLSP2_QUP1_I2C_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &cxo_clk_src.c,
+		.dbg_name = "gcc_blsp2_qup1_i2c_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp2_qup1_i2c_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp2_qup1_spi_apps_clk = {
+	.cbcr_reg = BLSP2_QUP1_SPI_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp2_qup1_spi_apps_clk_src.c,
+		.dbg_name = "gcc_blsp2_qup1_spi_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp2_qup1_spi_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp2_qup2_i2c_apps_clk = {
+	.cbcr_reg = BLSP2_QUP2_I2C_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &cxo_clk_src.c,
+		.dbg_name = "gcc_blsp2_qup2_i2c_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp2_qup2_i2c_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp2_qup2_spi_apps_clk = {
+	.cbcr_reg = BLSP2_QUP2_SPI_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp2_qup2_spi_apps_clk_src.c,
+		.dbg_name = "gcc_blsp2_qup2_spi_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp2_qup2_spi_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp2_qup3_i2c_apps_clk = {
+	.cbcr_reg = BLSP2_QUP3_I2C_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &cxo_clk_src.c,
+		.dbg_name = "gcc_blsp2_qup3_i2c_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp2_qup3_i2c_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp2_qup3_spi_apps_clk = {
+	.cbcr_reg = BLSP2_QUP3_SPI_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp2_qup3_spi_apps_clk_src.c,
+		.dbg_name = "gcc_blsp2_qup3_spi_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp2_qup3_spi_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp2_qup4_i2c_apps_clk = {
+	.cbcr_reg = BLSP2_QUP4_I2C_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &cxo_clk_src.c,
+		.dbg_name = "gcc_blsp2_qup4_i2c_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp2_qup4_i2c_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp2_qup4_spi_apps_clk = {
+	.cbcr_reg = BLSP2_QUP4_SPI_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp2_qup4_spi_apps_clk_src.c,
+		.dbg_name = "gcc_blsp2_qup4_spi_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp2_qup4_spi_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp2_qup5_i2c_apps_clk = {
+	.cbcr_reg = BLSP2_QUP5_I2C_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &cxo_clk_src.c,
+		.dbg_name = "gcc_blsp2_qup5_i2c_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp2_qup5_i2c_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp2_qup5_spi_apps_clk = {
+	.cbcr_reg = BLSP2_QUP5_SPI_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp2_qup5_spi_apps_clk_src.c,
+		.dbg_name = "gcc_blsp2_qup5_spi_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp2_qup5_spi_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp2_qup6_i2c_apps_clk = {
+	.cbcr_reg = BLSP2_QUP6_I2C_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &cxo_clk_src.c,
+		.dbg_name = "gcc_blsp2_qup6_i2c_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp2_qup6_i2c_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp2_qup6_spi_apps_clk = {
+	.cbcr_reg = BLSP2_QUP6_SPI_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp2_qup6_spi_apps_clk_src.c,
+		.dbg_name = "gcc_blsp2_qup6_spi_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp2_qup6_spi_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp2_uart1_apps_clk = {
+	.cbcr_reg = BLSP2_UART1_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp2_uart1_apps_clk_src.c,
+		.dbg_name = "gcc_blsp2_uart1_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp2_uart1_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp2_uart2_apps_clk = {
+	.cbcr_reg = BLSP2_UART2_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp2_uart2_apps_clk_src.c,
+		.dbg_name = "gcc_blsp2_uart2_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp2_uart2_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp2_uart3_apps_clk = {
+	.cbcr_reg = BLSP2_UART3_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp2_uart3_apps_clk_src.c,
+		.dbg_name = "gcc_blsp2_uart3_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp2_uart3_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp2_uart4_apps_clk = {
+	.cbcr_reg = BLSP2_UART4_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp2_uart4_apps_clk_src.c,
+		.dbg_name = "gcc_blsp2_uart4_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp2_uart4_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp2_uart5_apps_clk = {
+	.cbcr_reg = BLSP2_UART5_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp2_uart5_apps_clk_src.c,
+		.dbg_name = "gcc_blsp2_uart5_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp2_uart5_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_blsp2_uart6_apps_clk = {
+	.cbcr_reg = BLSP2_UART6_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &blsp2_uart6_apps_clk_src.c,
+		.dbg_name = "gcc_blsp2_uart6_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_blsp2_uart6_apps_clk.c),
+	},
+};
+
+static struct local_vote_clk gcc_ce1_clk = {
+	.cbcr_reg = CE1_CBCR,
+	.vote_reg = APCS_CLOCK_BRANCH_ENA_VOTE,
+	.en_mask = BIT(5),
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &ce1_clk_src.c,
+		.dbg_name = "gcc_ce1_clk",
+		.ops = &clk_ops_vote,
+		CLK_INIT(gcc_ce1_clk.c),
+	},
+};
+
+static struct local_vote_clk gcc_ce1_ahb_clk = {
+	.cbcr_reg = CE1_AHB_CBCR,
+	.vote_reg = APCS_CLOCK_BRANCH_ENA_VOTE,
+	.en_mask = BIT(3),
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_ce1_ahb_clk",
+		.ops = &clk_ops_vote,
+		CLK_INIT(gcc_ce1_ahb_clk.c),
+	},
+};
+
+static struct local_vote_clk gcc_ce1_axi_clk = {
+	.cbcr_reg = CE1_AXI_CBCR,
+	.vote_reg = APCS_CLOCK_BRANCH_ENA_VOTE,
+	.en_mask = BIT(4),
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_ce1_axi_clk",
+		.ops = &clk_ops_vote,
+		CLK_INIT(gcc_ce1_axi_clk.c),
+	},
+};
+
+static struct local_vote_clk gcc_ce2_clk = {
+	.cbcr_reg = CE2_CBCR,
+	.vote_reg = APCS_CLOCK_BRANCH_ENA_VOTE,
+	.en_mask = BIT(2),
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &ce2_clk_src.c,
+		.dbg_name = "gcc_ce2_clk",
+		.ops = &clk_ops_vote,
+		CLK_INIT(gcc_ce2_clk.c),
+	},
+};
+
+static struct local_vote_clk gcc_ce2_ahb_clk = {
+	.cbcr_reg = CE2_AHB_CBCR,
+	.vote_reg = APCS_CLOCK_BRANCH_ENA_VOTE,
+	.en_mask = BIT(0),
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_ce2_ahb_clk",
+		.ops = &clk_ops_vote,
+		CLK_INIT(gcc_ce2_ahb_clk.c),
+	},
+};
+
+static struct local_vote_clk gcc_ce2_axi_clk = {
+	.cbcr_reg = CE2_AXI_CBCR,
+	.vote_reg = APCS_CLOCK_BRANCH_ENA_VOTE,
+	.en_mask = BIT(1),
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_ce2_axi_clk",
+		.ops = &clk_ops_vote,
+		CLK_INIT(gcc_ce2_axi_clk.c),
+	},
+};
+
+static struct branch_clk gcc_gp1_clk = {
+	.cbcr_reg = GP1_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &gp1_clk_src.c,
+		.dbg_name = "gcc_gp1_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_gp1_clk.c),
+	},
+};
+
+static struct branch_clk gcc_gp2_clk = {
+	.cbcr_reg = GP2_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &gp2_clk_src.c,
+		.dbg_name = "gcc_gp2_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_gp2_clk.c),
+	},
+};
+
+static struct branch_clk gcc_gp3_clk = {
+	.cbcr_reg = GP3_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &gp3_clk_src.c,
+		.dbg_name = "gcc_gp3_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_gp3_clk.c),
+	},
+};
+
+static struct branch_clk gcc_pdm2_clk = {
+	.cbcr_reg = PDM2_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &pdm2_clk_src.c,
+		.dbg_name = "gcc_pdm2_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_pdm2_clk.c),
+	},
+};
+
+static struct branch_clk gcc_pdm_ahb_clk = {
+	.cbcr_reg = PDM_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_pdm_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_pdm_ahb_clk.c),
+	},
+};
+
+static struct local_vote_clk gcc_prng_ahb_clk = {
+	.cbcr_reg = PRNG_AHB_CBCR,
+	.vote_reg = APCS_CLOCK_BRANCH_ENA_VOTE,
+	.en_mask = BIT(13),
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_prng_ahb_clk",
+		.ops = &clk_ops_vote,
+		CLK_INIT(gcc_prng_ahb_clk.c),
+	},
+};
+
+static struct branch_clk gcc_sdcc1_ahb_clk = {
+	.cbcr_reg = SDCC1_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_sdcc1_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_sdcc1_ahb_clk.c),
+	},
+};
+
+static struct branch_clk gcc_sdcc1_apps_clk = {
+	.cbcr_reg = SDCC1_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &sdcc1_apps_clk_src.c,
+		.dbg_name = "gcc_sdcc1_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_sdcc1_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_sdcc1_cdccal_ff_clk = {
+	.cbcr_reg = SDCC1_CDCCAL_FF_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &cxo_clk_src.c,
+		.dbg_name = "gcc_sdcc1_cdccal_ff_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_sdcc1_cdccal_ff_clk.c),
+	},
+};
+
+static struct branch_clk gcc_sdcc1_cdccal_sleep_clk = {
+	.cbcr_reg = SDCC1_CDCCAL_SLEEP_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_sdcc1_cdccal_sleep_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_sdcc1_cdccal_sleep_clk.c),
+	},
+};
+
+static struct branch_clk gcc_sdcc2_ahb_clk = {
+	.cbcr_reg = SDCC2_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_sdcc2_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_sdcc2_ahb_clk.c),
+	},
+};
+
+static struct branch_clk gcc_sdcc2_apps_clk = {
+	.cbcr_reg = SDCC2_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &sdcc2_apps_clk_src.c,
+		.dbg_name = "gcc_sdcc2_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_sdcc2_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_sdcc3_ahb_clk = {
+	.cbcr_reg = SDCC3_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_sdcc3_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_sdcc3_ahb_clk.c),
+	},
+};
+
+static struct branch_clk gcc_sdcc3_apps_clk = {
+	.cbcr_reg = SDCC3_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &sdcc3_apps_clk_src.c,
+		.dbg_name = "gcc_sdcc3_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_sdcc3_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_sdcc4_ahb_clk = {
+	.cbcr_reg = SDCC4_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_sdcc4_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_sdcc4_ahb_clk.c),
+	},
+};
+
+static struct branch_clk gcc_sdcc4_apps_clk = {
+	.cbcr_reg = SDCC4_APPS_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &sdcc4_apps_clk_src.c,
+		.dbg_name = "gcc_sdcc4_apps_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_sdcc4_apps_clk.c),
+	},
+};
+
+static struct branch_clk gcc_tsif_ahb_clk = {
+	.cbcr_reg = TSIF_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_tsif_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_tsif_ahb_clk.c),
+	},
+};
+
+static struct branch_clk gcc_tsif_ref_clk = {
+	.cbcr_reg = TSIF_REF_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &tsif_ref_clk_src.c,
+		.dbg_name = "gcc_tsif_ref_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_tsif_ref_clk.c),
+	},
+};
+
+struct branch_clk gcc_sys_noc_usb3_axi_clk = {
+	.cbcr_reg = SYS_NOC_USB3_AXI_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &usb30_master_clk_src.c,
+		.dbg_name = "gcc_sys_noc_usb3_axi_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_sys_noc_usb3_axi_clk.c),
+	},
+};
+
+static struct branch_clk gcc_usb30_master_clk = {
+	.cbcr_reg = USB30_MASTER_CBCR,
+	.bcr_reg = USB_30_BCR,
+	.has_sibling = 1,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &usb30_master_clk_src.c,
+		.dbg_name = "gcc_usb30_master_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_usb30_master_clk.c),
+		.depends = &gcc_sys_noc_usb3_axi_clk.c,
+	},
+};
+
+static struct branch_clk gcc_usb30_mock_utmi_clk = {
+	.cbcr_reg = USB30_MOCK_UTMI_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &usb30_mock_utmi_clk_src.c,
+		.dbg_name = "gcc_usb30_mock_utmi_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_usb30_mock_utmi_clk.c),
+	},
+};
+
+struct branch_clk gcc_usb30_sleep_clk = {
+	.cbcr_reg = USB30_SLEEP_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_usb30_sleep_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_usb30_sleep_clk.c),
+	},
+};
+
+struct branch_clk gcc_usb2a_phy_sleep_clk = {
+	.cbcr_reg = USB2A_PHY_SLEEP_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_usb2a_phy_sleep_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_usb2a_phy_sleep_clk.c),
+	},
+};
+
+struct branch_clk gcc_usb2b_phy_sleep_clk = {
+	.cbcr_reg = USB2B_PHY_SLEEP_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_usb2b_phy_sleep_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_usb2b_phy_sleep_clk.c),
+	},
+};
+
+static struct branch_clk gcc_usb_hs_ahb_clk = {
+	.cbcr_reg = USB_HS_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_usb_hs_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_usb_hs_ahb_clk.c),
+	},
+};
+
+static struct branch_clk gcc_usb_hs_system_clk = {
+	.cbcr_reg = USB_HS_SYSTEM_CBCR,
+	.bcr_reg = USB_HS_BCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &usb_hs_system_clk_src.c,
+		.dbg_name = "gcc_usb_hs_system_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_usb_hs_system_clk.c),
+	},
+};
+
+static struct branch_clk gcc_usb_hsic_ahb_clk = {
+	.cbcr_reg = USB_HSIC_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_usb_hsic_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_usb_hsic_ahb_clk.c),
+	},
+};
+
+static struct branch_clk gcc_usb_hsic_clk = {
+	.cbcr_reg = USB_HSIC_CBCR,
+	.bcr_reg = USB_HS_HSIC_BCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &usb_hsic_clk_src.c,
+		.dbg_name = "gcc_usb_hsic_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_usb_hsic_clk.c),
+	},
+};
+
+static struct branch_clk gcc_usb_hsic_io_cal_clk = {
+	.cbcr_reg = USB_HSIC_IO_CAL_CBCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &usb_hsic_io_cal_clk_src.c,
+		.dbg_name = "gcc_usb_hsic_io_cal_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_usb_hsic_io_cal_clk.c),
+	},
+};
+
+static struct branch_clk gcc_usb_hsic_system_clk = {
+	.cbcr_reg = USB_HSIC_SYSTEM_CBCR,
+	.bcr_reg = USB_HS_HSIC_BCR,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.parent = &usb_hsic_system_clk_src.c,
+		.dbg_name = "gcc_usb_hsic_system_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_usb_hsic_system_clk.c),
+	},
+};
+
+struct branch_clk gcc_mmss_noc_cfg_ahb_clk = {
+	.cbcr_reg = MMSS_NOC_CFG_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_mmss_noc_cfg_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_mmss_noc_cfg_ahb_clk.c),
+	},
+};
+
+struct branch_clk gcc_ocmem_noc_cfg_ahb_clk = {
+	.cbcr_reg = OCMEM_NOC_CFG_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_ocmem_noc_cfg_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_ocmem_noc_cfg_ahb_clk.c),
+	},
+};
+
+static struct branch_clk gcc_mss_cfg_ahb_clk = {
+	.cbcr_reg = MSS_CFG_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_mss_cfg_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_mss_cfg_ahb_clk.c),
+	},
+};
+
+static struct branch_clk gcc_mss_q6_bimc_axi_clk = {
+	.cbcr_reg = MSS_Q6_BIMC_AXI_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_mss_q6_bimc_axi_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_mss_q6_bimc_axi_clk.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_mmss_axi_clk[] = {
+	F_MM( 19200000,    cxo,     1,   0,   0),
+	F_MM( 37500000,  gpll0,    16,   0,   0),
+	F_MM( 50000000,  gpll0,    12,   0,   0),
+	F_MM( 75000000,  gpll0,     8,   0,   0),
+	F_MM(100000000,  gpll0,     6,   0,   0),
+	F_MM(150000000,  gpll0,     4,   0,   0),
+	F_MM(282000000, mmpll1,     3,   0,   0),
+	F_MM(400000000, mmpll0,     2,   0,   0),
+	F_END
+};
+
+static struct clk_freq_tbl ftbl_mmss_axi_v2_clk[] = {
+	F_MM( 19200000,    cxo,     1,   0,   0),
+	F_MM( 37500000,  gpll0,    16,   0,   0),
+	F_MM( 50000000,  gpll0,    12,   0,   0),
+	F_MM( 75000000,  gpll0,     8,   0,   0),
+	F_MM(100000000,  gpll0,     6,   0,   0),
+	F_MM(150000000,  gpll0,     4,   0,   0),
+	F_MM(291750000, mmpll1,     4,   0,   0),
+	F_MM(400000000, mmpll0,     2,   0,   0),
+	F_MM(466800000, mmpll1,   2.5,   0,   0),
+	F_END
+};
+
+static struct rcg_clk axi_clk_src = {
+	.cmd_rcgr_reg = 0x5040,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_mmss_axi_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "axi_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP3(LOW, 150000000, NOMINAL, 282000000,
+				  HIGH, 400000000),
+		CLK_INIT(axi_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_ocmemnoc_clk[] = {
+	F_MM( 19200000,    cxo,   1,   0,   0),
+	F_MM( 37500000,  gpll0,  16,   0,   0),
+	F_MM( 50000000,  gpll0,  12,   0,   0),
+	F_MM( 75000000,  gpll0,   8,   0,   0),
+	F_MM(100000000,  gpll0,   6,   0,   0),
+	F_MM(150000000,  gpll0,   4,   0,   0),
+	F_MM(282000000, mmpll1,   3,   0,   0),
+	F_MM(400000000, mmpll0,   2,   0,   0),
+	F_END
+};
+
+static struct clk_freq_tbl ftbl_ocmemnoc_v2_clk[] = {
+	F_MM( 19200000,    cxo,   1,   0,   0),
+	F_MM( 37500000,  gpll0,  16,   0,   0),
+	F_MM( 50000000,  gpll0,  12,   0,   0),
+	F_MM( 75000000,  gpll0,   8,   0,   0),
+	F_MM(100000000,  gpll0,   6,   0,   0),
+	F_MM(150000000,  gpll0,   4,   0,   0),
+	F_MM(291750000, mmpll1,   4,   0,   0),
+	F_MM(400000000, mmpll0,   2,   0,   0),
+	F_END
+};
+
+struct rcg_clk ocmemnoc_clk_src = {
+	.cmd_rcgr_reg = OCMEMNOC_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_ocmemnoc_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "ocmemnoc_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP3(LOW, 150000000, NOMINAL, 282000000,
+				  HIGH, 400000000),
+		CLK_INIT(ocmemnoc_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_camss_csi0_3_clk[] = {
+	F_MM(100000000,  gpll0,   6,   0,   0),
+	F_MM(200000000, mmpll0,   4,   0,   0),
+	F_END
+};
+
+static struct rcg_clk csi0_clk_src = {
+	.cmd_rcgr_reg = CSI0_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_camss_csi0_3_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "csi0_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP2(LOW, 100000000, NOMINAL, 200000000),
+		CLK_INIT(csi0_clk_src.c),
+	},
+};
+
+static struct rcg_clk csi1_clk_src = {
+	.cmd_rcgr_reg = CSI1_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_camss_csi0_3_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "csi1_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP2(LOW, 100000000, NOMINAL, 200000000),
+		CLK_INIT(csi1_clk_src.c),
+	},
+};
+
+static struct rcg_clk csi2_clk_src = {
+	.cmd_rcgr_reg = CSI2_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_camss_csi0_3_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "csi2_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP2(LOW, 100000000, NOMINAL, 200000000),
+		CLK_INIT(csi2_clk_src.c),
+	},
+};
+
+static struct rcg_clk csi3_clk_src = {
+	.cmd_rcgr_reg = CSI3_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_camss_csi0_3_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "csi3_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP2(LOW, 100000000, NOMINAL, 200000000),
+		CLK_INIT(csi3_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_camss_vfe_vfe0_1_clk[] = {
+	F_MM( 37500000,  gpll0,  16,   0,   0),
+	F_MM( 50000000,  gpll0,  12,   0,   0),
+	F_MM( 60000000,  gpll0,  10,   0,   0),
+	F_MM( 80000000,  gpll0, 7.5,   0,   0),
+	F_MM(100000000,  gpll0,   6,   0,   0),
+	F_MM(109090000,  gpll0, 5.5,   0,   0),
+	F_MM(150000000,  gpll0,   4,   0,   0),
+	F_MM(200000000,  gpll0,   3,   0,   0),
+	F_MM(228570000, mmpll0, 3.5,   0,   0),
+	F_MM(266670000, mmpll0,   3,   0,   0),
+	F_MM(320000000, mmpll0, 2.5,   0,   0),
+	F_MM(465000000, mmpll3,   2,   0,   0),
+	F_END
+};
+
+static struct rcg_clk vfe0_clk_src = {
+	.cmd_rcgr_reg = VFE0_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_camss_vfe_vfe0_1_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "vfe0_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP3(LOW, 133330000, NOMINAL, 266670000,
+				  HIGH, 320000000),
+		CLK_INIT(vfe0_clk_src.c),
+	},
+};
+
+static struct rcg_clk vfe1_clk_src = {
+	.cmd_rcgr_reg = VFE1_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_camss_vfe_vfe0_1_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "vfe1_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP3(LOW, 133330000, NOMINAL, 266670000,
+				  HIGH, 320000000),
+		CLK_INIT(vfe1_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_mdss_mdp_clk[] = {
+	F_MM( 37500000,  gpll0,  16,   0,   0),
+	F_MM( 60000000,  gpll0,  10,   0,   0),
+	F_MM( 75000000,  gpll0,   8,   0,   0),
+	F_MM( 85710000,  gpll0,   7,   0,   0),
+	F_MM(100000000,  gpll0,   6,   0,   0),
+	F_MM(133330000, mmpll0,   6,   0,   0),
+	F_MM(160000000, mmpll0,   5,   0,   0),
+	F_MM(200000000, mmpll0,   4,   0,   0),
+	F_MM(240000000,  gpll0, 2.5,   0,   0),
+	F_MM(266670000, mmpll0,   3,   0,   0),
+	F_MM(320000000, mmpll0, 2.5,   0,   0),
+	F_END
+};
+
+static struct rcg_clk mdp_clk_src = {
+	.cmd_rcgr_reg = MDP_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_mdss_mdp_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "mdp_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP3(LOW, 133330000, NOMINAL, 266670000,
+				  HIGH, 320000000),
+		CLK_INIT(mdp_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_camss_cci_cci_clk[] = {
+	F_MM(19200000,    cxo,   1,   0,   0),
+	F_END
+};
+
+static struct rcg_clk cci_clk_src = {
+	.cmd_rcgr_reg = CCI_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_camss_cci_cci_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "cci_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP2(LOW, 20000000, NOMINAL, 40000000),
+		CLK_INIT(cci_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_camss_gp0_1_clk[] = {
+	F_MM(   10000,    cxo,  16,   1, 120),
+	F_MM(   20000,    cxo,  16,   1,  50),
+	F_MM( 6000000,  gpll0,  10,   1,  10),
+	F_MM(12000000,  gpll0,  10,   1,   5),
+	F_MM(13000000,  gpll0,  10,  13,  60),
+	F_MM(24000000,  gpll0,   5,   1,   5),
+	F_END
+};
+
+static struct rcg_clk mmss_gp0_clk_src = {
+	.cmd_rcgr_reg = MMSS_GP0_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_camss_gp0_1_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "mmss_gp0_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 100000000, NOMINAL, 200000000),
+		CLK_INIT(mmss_gp0_clk_src.c),
+	},
+};
+
+static struct rcg_clk mmss_gp1_clk_src = {
+	.cmd_rcgr_reg = MMSS_GP1_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_camss_gp0_1_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "mmss_gp1_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP2(LOW, 100000000, NOMINAL, 200000000),
+		CLK_INIT(mmss_gp1_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_camss_jpeg_jpeg0_2_clk[] = {
+	F_MM( 75000000,  gpll0,   8,   0,   0),
+	F_MM(150000000,  gpll0,   4,   0,   0),
+	F_MM(200000000,  gpll0,   3,   0,   0),
+	F_MM(228570000, mmpll0, 3.5,   0,   0),
+	F_MM(266670000, mmpll0,   3,   0,   0),
+	F_MM(320000000, mmpll0, 2.5,   0,   0),
+	F_END
+};
+
+static struct rcg_clk jpeg0_clk_src = {
+	.cmd_rcgr_reg = JPEG0_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_camss_jpeg_jpeg0_2_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "jpeg0_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP3(LOW, 133330000, NOMINAL, 266670000,
+				  HIGH, 320000000),
+		CLK_INIT(jpeg0_clk_src.c),
+	},
+};
+
+static struct rcg_clk jpeg1_clk_src = {
+	.cmd_rcgr_reg = JPEG1_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_camss_jpeg_jpeg0_2_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "jpeg1_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP3(LOW, 133330000, NOMINAL, 266670000,
+				  HIGH, 320000000),
+		CLK_INIT(jpeg1_clk_src.c),
+	},
+};
+
+static struct rcg_clk jpeg2_clk_src = {
+	.cmd_rcgr_reg = JPEG2_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_camss_jpeg_jpeg0_2_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "jpeg2_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP3(LOW, 133330000, NOMINAL, 266670000,
+				  HIGH, 320000000),
+		CLK_INIT(jpeg2_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_camss_mclk0_3_clk[] = {
+	F_MM(19200000,    cxo,   1,   0,   0),
+	F_MM(66670000,  gpll0,   9,   0,   0),
+	F_END
+};
+
+static struct clk_freq_tbl ftbl_camss_mclk0_3_pro_clk[] = {
+	F_MM( 4800000,    cxo,    4,   0,   0),
+	F_MM( 6000000,  gpll0,   10,   1,  10),
+	F_MM( 8000000,  gpll0,   15,   1,   5),
+	F_MM( 9600000,    cxo,    2,   0,   0),
+	F_MM(16000000,  gpll0, 12.5,   1,   3),
+	F_MM(19200000,    cxo,    1,   0,   0),
+	F_MM(24000000,  gpll0,    5,   1,   5),
+	F_MM(32000000, mmpll0,    5,   1,   5),
+	F_MM(48000000,  gpll0, 12.5,   0,   0),
+	F_MM(64000000, mmpll0, 12.5,   0,   0),
+	F_MM(66670000,  gpll0,    9,   0,   0),
+	F_END
+};
+
+static struct rcg_clk mclk0_clk_src = {
+	.cmd_rcgr_reg = MCLK0_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_camss_mclk0_3_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "mclk0_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP1(LOW, 66670000),
+		CLK_INIT(mclk0_clk_src.c),
+	},
+};
+
+static struct rcg_clk mclk1_clk_src = {
+	.cmd_rcgr_reg = MCLK1_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_camss_mclk0_3_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "mclk1_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP1(LOW, 66670000),
+		CLK_INIT(mclk1_clk_src.c),
+	},
+};
+
+static struct rcg_clk mclk2_clk_src = {
+	.cmd_rcgr_reg = MCLK2_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_camss_mclk0_3_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "mclk2_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP1(LOW, 66670000),
+		CLK_INIT(mclk2_clk_src.c),
+	},
+};
+
+static struct rcg_clk mclk3_clk_src = {
+	.cmd_rcgr_reg = MCLK3_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_camss_mclk0_3_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "mclk3_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP1(LOW, 66670000),
+		CLK_INIT(mclk3_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_camss_phy0_2_csi0_2phytimer_clk[] = {
+	F_MM(100000000,  gpll0,   6,   0,   0),
+	F_MM(200000000, mmpll0,   4,   0,   0),
+	F_END
+};
+
+static struct rcg_clk csi0phytimer_clk_src = {
+	.cmd_rcgr_reg = CSI0PHYTIMER_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_camss_phy0_2_csi0_2phytimer_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "csi0phytimer_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP2(LOW, 100000000, NOMINAL, 200000000),
+		CLK_INIT(csi0phytimer_clk_src.c),
+	},
+};
+
+static struct rcg_clk csi1phytimer_clk_src = {
+	.cmd_rcgr_reg = CSI1PHYTIMER_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_camss_phy0_2_csi0_2phytimer_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "csi1phytimer_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP2(LOW, 100000000, NOMINAL, 200000000),
+		CLK_INIT(csi1phytimer_clk_src.c),
+	},
+};
+
+static struct rcg_clk csi2phytimer_clk_src = {
+	.cmd_rcgr_reg = CSI2PHYTIMER_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_camss_phy0_2_csi0_2phytimer_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "csi2phytimer_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP2(LOW, 100000000, NOMINAL, 200000000),
+		CLK_INIT(csi2phytimer_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_camss_vfe_cpp_clk[] = {
+	F_MM(150000000,  gpll0,   4,   0,   0),
+	F_MM(266670000, mmpll0,   3,   0,   0),
+	F_MM(320000000, mmpll0, 2.5,   0,   0),
+	F_MM(465000000, mmpll3,   2,   0,   0),
+	F_END
+};
+
+static struct rcg_clk cpp_clk_src = {
+	.cmd_rcgr_reg = CPP_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_camss_vfe_cpp_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "cpp_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP3(LOW, 133330000, NOMINAL, 266670000,
+				  HIGH, 320000000),
+		CLK_INIT(cpp_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl byte_freq_tbl[] = {
+	{
+		.src_clk = &byte_clk_src_8974.c,
+		.div_src_val = BVAL(10, 8, dsipll0_byte_mm_source_val),
+	},
+	F_END
+};
+
+static struct rcg_clk byte0_clk_src = {
+	.cmd_rcgr_reg = BYTE0_CMD_RCGR,
+	.current_freq = byte_freq_tbl,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &byte_clk_src_8974.c,
+		.dbg_name = "byte0_clk_src",
+		.ops = &clk_ops_byte,
+		VDD_DIG_FMAX_MAP3(LOW, 93800000, NOMINAL, 187500000,
+				  HIGH, 188000000),
+		CLK_INIT(byte0_clk_src.c),
+	},
+};
+
+static struct rcg_clk byte1_clk_src = {
+	.cmd_rcgr_reg = BYTE1_CMD_RCGR,
+	.current_freq = byte_freq_tbl,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &byte_clk_src_8974.c,
+		.dbg_name = "byte1_clk_src",
+		.ops = &clk_ops_byte,
+		VDD_DIG_FMAX_MAP3(LOW, 93800000, NOMINAL, 187500000,
+				  HIGH, 188000000),
+		CLK_INIT(byte1_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_mdss_edpaux_clk[] = {
+	F_MM(19200000,    cxo,   1,   0,   0),
+	F_END
+};
+
+static struct rcg_clk edpaux_clk_src = {
+	.cmd_rcgr_reg = EDPAUX_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_mdss_edpaux_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "edpaux_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP2(LOW, 20000000, NOMINAL, 40000000),
+		CLK_INIT(edpaux_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_mdss_edplink_clk[] = {
+	F_EDP(162000000, edp_mainlink,  1,   0,   0),
+	F_EDP(270000000, edp_mainlink,  1,   0,   0),
+	F_END
+};
+
+static struct rcg_clk edplink_clk_src = {
+	.cmd_rcgr_reg = EDPLINK_CMD_RCGR,
+	.freq_tbl = ftbl_mdss_edplink_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "edplink_clk_src",
+		.ops = &clk_ops_rcg_edp,
+		VDD_DIG_FMAX_MAP2(LOW, 135000000, NOMINAL, 270000000),
+		CLK_INIT(edplink_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl edp_pixel_freq_tbl[] = {
+	{
+		.src_clk = &edp_pixel_clk_src.c,
+		.div_src_val = BVAL(10, 8, edp_pixel_mm_source_val)
+				| BVAL(4, 0, 0),
+	},
+	F_END
+};
+
+static struct rcg_clk edppixel_clk_src = {
+	.cmd_rcgr_reg = EDPPIXEL_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.current_freq = edp_pixel_freq_tbl,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &edp_pixel_clk_src.c,
+		.dbg_name = "edppixel_clk_src",
+		.ops = &clk_ops_edppixel,
+		VDD_DIG_FMAX_MAP2(LOW, 175000000, NOMINAL, 350000000),
+		CLK_INIT(edppixel_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_mdss_esc0_1_clk[] = {
+	F_MM(19200000,    cxo,   1,   0,   0),
+	F_END
+};
+
+static struct rcg_clk esc0_clk_src = {
+	.cmd_rcgr_reg = ESC0_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_mdss_esc0_1_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "esc0_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP2(LOW, 20000000, NOMINAL, 40000000),
+		CLK_INIT(esc0_clk_src.c),
+	},
+};
+
+static struct rcg_clk esc1_clk_src = {
+	.cmd_rcgr_reg = ESC1_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_mdss_esc0_1_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "esc1_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP2(LOW, 20000000, NOMINAL, 40000000),
+		CLK_INIT(esc1_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_mdss_extpclk_clk[] = {
+	F_MM(148500000, hdmipll, 1, 0, 0),
+	F_END
+};
+
+static struct rcg_clk extpclk_clk_src = {
+	.cmd_rcgr_reg = EXTPCLK_CMD_RCGR,
+	.freq_tbl = ftbl_mdss_extpclk_clk,
+	.current_freq = ftbl_mdss_extpclk_clk,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "extpclk_clk_src",
+		.parent = &hdmipll_clk_src.c,
+		.ops = &clk_ops_rcg_hdmi,
+		VDD_DIG_FMAX_MAP2(LOW, 148500000, NOMINAL, 297000000),
+		CLK_INIT(extpclk_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_mdss_hdmi_clk[] = {
+	F_MDSS(19200000,    cxo,   1,   0,   0),
+	F_END
+};
+
+static struct rcg_clk hdmi_clk_src = {
+	.cmd_rcgr_reg = HDMI_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_mdss_hdmi_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "hdmi_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP2(LOW, 20000000, NOMINAL, 40000000),
+		CLK_INIT(hdmi_clk_src.c),
+	},
+};
+
+struct clk_ops clk_ops_pixel_clock;
+
+static long round_rate_pixel(struct clk *clk, unsigned long rate)
+{
+	int frac_num[] = {3, 2, 4, 1};
+	int frac_den[] = {8, 9, 9, 1};
+	int delta = 100000;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(frac_num); i++) {
+		unsigned long request = (rate * frac_den[i]) / frac_num[i];
+		unsigned long src_rate;
+
+		src_rate = clk_round_rate(clk->parent, request);
+		if ((src_rate < (request - delta)) ||
+			(src_rate > (request + delta)))
+			continue;
+
+		return (src_rate * frac_num[i]) / frac_den[i];
+	}
+
+	return -EINVAL;
+}
+
+
+static int set_rate_pixel(struct clk *clk, unsigned long rate)
+{
+	struct rcg_clk *rcg = to_rcg_clk(clk);
+	struct clk_freq_tbl *pixel_freq = rcg->current_freq;
+	int frac_num[] = {3, 2, 4, 1};
+	int frac_den[] = {8, 9, 9, 1};
+	int delta = 100000;
+	int i, rc;
+
+	for (i = 0; i < ARRAY_SIZE(frac_num); i++) {
+		unsigned long request = (rate * frac_den[i]) / frac_num[i];
+		unsigned long src_rate;
+
+		src_rate = clk_round_rate(clk->parent, request);
+		if ((src_rate < (request - delta)) ||
+			(src_rate > (request + delta)))
+			continue;
+
+		rc =  clk_set_rate(clk->parent, src_rate);
+		if (rc)
+			return rc;
+
+		pixel_freq->div_src_val &= ~BM(4, 0);
+		if (frac_den[i] == frac_num[i]) {
+			pixel_freq->m_val = 0;
+			pixel_freq->n_val = 0;
+		} else {
+			pixel_freq->m_val = frac_num[i];
+			pixel_freq->n_val = ~(frac_den[i] - frac_num[i]);
+			pixel_freq->d_val = ~frac_den[i];
+		}
+		set_rate_mnd(rcg, pixel_freq);
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static struct clk_freq_tbl pixel_freq_tbl[] = {
+	{
+		.src_clk = &pixel_clk_src_8974.c,
+		.div_src_val = BVAL(10, 8, dsipll0_pixel_mm_source_val)
+				| BVAL(4, 0, 0),
+	},
+	F_END
+};
+
+static struct rcg_clk pclk0_clk_src = {
+	.cmd_rcgr_reg = PCLK0_CMD_RCGR,
+	.current_freq = pixel_freq_tbl,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &pixel_clk_src_8974.c,
+		.dbg_name = "pclk0_clk_src",
+		.ops = &clk_ops_pixel_clock,
+		VDD_DIG_FMAX_MAP2(LOW, 125000000, NOMINAL, 250000000),
+		CLK_INIT(pclk0_clk_src.c),
+	},
+};
+
+static struct rcg_clk pclk1_clk_src = {
+	.cmd_rcgr_reg = PCLK1_CMD_RCGR,
+	.current_freq = pixel_freq_tbl,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &pixel_clk_src_8974.c,
+		.dbg_name = "pclk1_clk_src",
+		.ops = &clk_ops_pixel_clock,
+		VDD_DIG_FMAX_MAP2(LOW, 125000000, NOMINAL, 250000000),
+		CLK_INIT(pclk1_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_mdss_vsync_clk[] = {
+	F_MDSS(19200000,    cxo,   1,   0,   0),
+	F_END
+};
+
+static struct rcg_clk vsync_clk_src = {
+	.cmd_rcgr_reg = VSYNC_CMD_RCGR,
+	.set_rate = set_rate_hid,
+	.freq_tbl = ftbl_mdss_vsync_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "vsync_clk_src",
+		.ops = &clk_ops_rcg,
+		VDD_DIG_FMAX_MAP2(LOW, 20000000, NOMINAL, 40000000),
+		CLK_INIT(vsync_clk_src.c),
+	},
+};
+
+static struct clk_freq_tbl ftbl_venus0_vcodec0_clk[] = {
+	F_MM( 50000000,  gpll0,  12,   0,   0),
+	F_MM(100000000,  gpll0,   6,   0,   0),
+	F_MM(133330000, mmpll0,   6,   0,   0),
+	F_MM(200000000, mmpll0,   4,   0,   0),
+	F_MM(266670000, mmpll0,   3,   0,   0),
+	F_MM(410000000, mmpll3,   2,   0,   0),
+	F_END
+};
+
+static struct clk_freq_tbl ftbl_venus0_vcodec0_v2_clk[] = {
+	F_MM( 50000000,  gpll0,  12,   0,   0),
+	F_MM(100000000,  gpll0,   6,   0,   0),
+	F_MM(133330000, mmpll0,   6,   0,   0),
+	F_MM(200000000, mmpll0,   4,   0,   0),
+	F_MM(266670000, mmpll0,   3,   0,   0),
+	F_MM(465000000, mmpll3,   2,   0,   0),
+	F_END
+};
+
+static struct rcg_clk vcodec0_clk_src = {
+	.cmd_rcgr_reg = VCODEC0_CMD_RCGR,
+	.set_rate = set_rate_mnd,
+	.freq_tbl = ftbl_venus0_vcodec0_clk,
+	.current_freq = &rcg_dummy_freq,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "vcodec0_clk_src",
+		.ops = &clk_ops_rcg_mnd,
+		VDD_DIG_FMAX_MAP3(LOW, 133330000, NOMINAL, 266670000,
+				  HIGH, 410000000),
+		CLK_INIT(vcodec0_clk_src.c),
+	},
+};
+
+static struct branch_clk camss_cci_cci_ahb_clk = {
+	.cbcr_reg = CAMSS_CCI_CCI_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "camss_cci_cci_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_cci_cci_ahb_clk.c),
+	},
+};
+
+static struct branch_clk camss_cci_cci_clk = {
+	.cbcr_reg = CAMSS_CCI_CCI_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &cci_clk_src.c,
+		.dbg_name = "camss_cci_cci_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_cci_cci_clk.c),
+	},
+};
+
+static struct branch_clk camss_csi0_ahb_clk = {
+	.cbcr_reg = CAMSS_CSI0_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "camss_csi0_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_csi0_ahb_clk.c),
+	},
+};
+
+static struct branch_clk camss_csi0_clk = {
+	.cbcr_reg = CAMSS_CSI0_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &csi0_clk_src.c,
+		.dbg_name = "camss_csi0_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_csi0_clk.c),
+	},
+};
+
+static struct branch_clk camss_csi0phy_clk = {
+	.cbcr_reg = CAMSS_CSI0PHY_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &csi0_clk_src.c,
+		.dbg_name = "camss_csi0phy_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_csi0phy_clk.c),
+	},
+};
+
+static struct branch_clk camss_csi0pix_clk = {
+	.cbcr_reg = CAMSS_CSI0PIX_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &csi0_clk_src.c,
+		.dbg_name = "camss_csi0pix_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_csi0pix_clk.c),
+	},
+};
+
+static struct branch_clk camss_csi0rdi_clk = {
+	.cbcr_reg = CAMSS_CSI0RDI_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &csi0_clk_src.c,
+		.dbg_name = "camss_csi0rdi_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_csi0rdi_clk.c),
+	},
+};
+
+static struct branch_clk camss_csi1_ahb_clk = {
+	.cbcr_reg = CAMSS_CSI1_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "camss_csi1_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_csi1_ahb_clk.c),
+	},
+};
+
+static struct branch_clk camss_csi1_clk = {
+	.cbcr_reg = CAMSS_CSI1_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &csi1_clk_src.c,
+		.dbg_name = "camss_csi1_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_csi1_clk.c),
+	},
+};
+
+static struct branch_clk camss_csi1phy_clk = {
+	.cbcr_reg = CAMSS_CSI1PHY_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &csi1_clk_src.c,
+		.dbg_name = "camss_csi1phy_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_csi1phy_clk.c),
+	},
+};
+
+static struct branch_clk camss_csi1pix_clk = {
+	.cbcr_reg = CAMSS_CSI1PIX_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &csi1_clk_src.c,
+		.dbg_name = "camss_csi1pix_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_csi1pix_clk.c),
+	},
+};
+
+static struct branch_clk camss_csi1rdi_clk = {
+	.cbcr_reg = CAMSS_CSI1RDI_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &csi1_clk_src.c,
+		.dbg_name = "camss_csi1rdi_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_csi1rdi_clk.c),
+	},
+};
+
+static struct branch_clk camss_csi2_ahb_clk = {
+	.cbcr_reg = CAMSS_CSI2_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "camss_csi2_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_csi2_ahb_clk.c),
+	},
+};
+
+static struct branch_clk camss_csi2_clk = {
+	.cbcr_reg = CAMSS_CSI2_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &csi2_clk_src.c,
+		.dbg_name = "camss_csi2_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_csi2_clk.c),
+	},
+};
+
+static struct branch_clk camss_csi2phy_clk = {
+	.cbcr_reg = CAMSS_CSI2PHY_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &csi2_clk_src.c,
+		.dbg_name = "camss_csi2phy_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_csi2phy_clk.c),
+	},
+};
+
+static struct branch_clk camss_csi2pix_clk = {
+	.cbcr_reg = CAMSS_CSI2PIX_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &csi2_clk_src.c,
+		.dbg_name = "camss_csi2pix_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_csi2pix_clk.c),
+	},
+};
+
+static struct branch_clk camss_csi2rdi_clk = {
+	.cbcr_reg = CAMSS_CSI2RDI_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &csi2_clk_src.c,
+		.dbg_name = "camss_csi2rdi_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_csi2rdi_clk.c),
+	},
+};
+
+static struct branch_clk camss_csi3_ahb_clk = {
+	.cbcr_reg = CAMSS_CSI3_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "camss_csi3_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_csi3_ahb_clk.c),
+	},
+};
+
+static struct branch_clk camss_csi3_clk = {
+	.cbcr_reg = CAMSS_CSI3_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &csi3_clk_src.c,
+		.dbg_name = "camss_csi3_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_csi3_clk.c),
+	},
+};
+
+static struct branch_clk camss_csi3phy_clk = {
+	.cbcr_reg = CAMSS_CSI3PHY_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &csi3_clk_src.c,
+		.dbg_name = "camss_csi3phy_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_csi3phy_clk.c),
+	},
+};
+
+static struct branch_clk camss_csi3pix_clk = {
+	.cbcr_reg = CAMSS_CSI3PIX_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &csi3_clk_src.c,
+		.dbg_name = "camss_csi3pix_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_csi3pix_clk.c),
+	},
+};
+
+static struct branch_clk camss_csi3rdi_clk = {
+	.cbcr_reg = CAMSS_CSI3RDI_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &csi3_clk_src.c,
+		.dbg_name = "camss_csi3rdi_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_csi3rdi_clk.c),
+	},
+};
+
+static struct branch_clk camss_csi_vfe0_clk = {
+	.cbcr_reg = CAMSS_CSI_VFE0_CBCR,
+	.bcr_reg = CAMSS_CSI_VFE0_BCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &vfe0_clk_src.c,
+		.dbg_name = "camss_csi_vfe0_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_csi_vfe0_clk.c),
+	},
+};
+
+static struct branch_clk camss_csi_vfe1_clk = {
+	.cbcr_reg = CAMSS_CSI_VFE1_CBCR,
+	.bcr_reg = CAMSS_CSI_VFE1_BCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &vfe1_clk_src.c,
+		.dbg_name = "camss_csi_vfe1_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_csi_vfe1_clk.c),
+	},
+};
+
+static struct branch_clk camss_gp0_clk = {
+	.cbcr_reg = CAMSS_GP0_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &mmss_gp0_clk_src.c,
+		.dbg_name = "camss_gp0_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_gp0_clk.c),
+	},
+};
+
+static struct branch_clk camss_gp1_clk = {
+	.cbcr_reg = CAMSS_GP1_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &mmss_gp1_clk_src.c,
+		.dbg_name = "camss_gp1_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_gp1_clk.c),
+	},
+};
+
+static struct branch_clk camss_ispif_ahb_clk = {
+	.cbcr_reg = CAMSS_ISPIF_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "camss_ispif_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_ispif_ahb_clk.c),
+	},
+};
+
+static struct branch_clk camss_jpeg_jpeg0_clk = {
+	.cbcr_reg = CAMSS_JPEG_JPEG0_CBCR,
+	.bcr_reg = CAMSS_JPEG_BCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &jpeg0_clk_src.c,
+		.dbg_name = "camss_jpeg_jpeg0_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_jpeg_jpeg0_clk.c),
+	},
+};
+
+static struct branch_clk camss_jpeg_jpeg1_clk = {
+	.cbcr_reg = CAMSS_JPEG_JPEG1_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &jpeg1_clk_src.c,
+		.dbg_name = "camss_jpeg_jpeg1_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_jpeg_jpeg1_clk.c),
+	},
+};
+
+static struct branch_clk camss_jpeg_jpeg2_clk = {
+	.cbcr_reg = CAMSS_JPEG_JPEG2_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &jpeg2_clk_src.c,
+		.dbg_name = "camss_jpeg_jpeg2_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_jpeg_jpeg2_clk.c),
+	},
+};
+
+static struct branch_clk camss_jpeg_jpeg_ahb_clk = {
+	.cbcr_reg = CAMSS_JPEG_JPEG_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "camss_jpeg_jpeg_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_jpeg_jpeg_ahb_clk.c),
+	},
+};
+
+static struct branch_clk camss_jpeg_jpeg_axi_clk = {
+	.cbcr_reg = CAMSS_JPEG_JPEG_AXI_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &axi_clk_src.c,
+		.dbg_name = "camss_jpeg_jpeg_axi_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_jpeg_jpeg_axi_clk.c),
+	},
+};
+
+static struct branch_clk camss_jpeg_jpeg_ocmemnoc_clk = {
+	.cbcr_reg = CAMSS_JPEG_JPEG_OCMEMNOC_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &ocmemnoc_clk_src.c,
+		.dbg_name = "camss_jpeg_jpeg_ocmemnoc_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_jpeg_jpeg_ocmemnoc_clk.c),
+	},
+};
+
+static struct branch_clk camss_mclk0_clk = {
+	.cbcr_reg = CAMSS_MCLK0_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &mclk0_clk_src.c,
+		.dbg_name = "camss_mclk0_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_mclk0_clk.c),
+	},
+};
+
+static struct branch_clk camss_mclk1_clk = {
+	.cbcr_reg = CAMSS_MCLK1_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &mclk1_clk_src.c,
+		.dbg_name = "camss_mclk1_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_mclk1_clk.c),
+	},
+};
+
+static struct branch_clk camss_mclk2_clk = {
+	.cbcr_reg = CAMSS_MCLK2_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &mclk2_clk_src.c,
+		.dbg_name = "camss_mclk2_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_mclk2_clk.c),
+	},
+};
+
+static struct branch_clk camss_mclk3_clk = {
+	.cbcr_reg = CAMSS_MCLK3_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &mclk3_clk_src.c,
+		.dbg_name = "camss_mclk3_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_mclk3_clk.c),
+	},
+};
+
+static struct branch_clk camss_micro_ahb_clk = {
+	.cbcr_reg = CAMSS_MICRO_AHB_CBCR,
+	.has_sibling = 1,
+	.bcr_reg = CAMSS_MICRO_BCR,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "camss_micro_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_micro_ahb_clk.c),
+	},
+};
+
+static struct branch_clk camss_phy0_csi0phytimer_clk = {
+	.cbcr_reg = CAMSS_PHY0_CSI0PHYTIMER_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &csi0phytimer_clk_src.c,
+		.dbg_name = "camss_phy0_csi0phytimer_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_phy0_csi0phytimer_clk.c),
+	},
+};
+
+static struct branch_clk camss_phy1_csi1phytimer_clk = {
+	.cbcr_reg = CAMSS_PHY1_CSI1PHYTIMER_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &csi1phytimer_clk_src.c,
+		.dbg_name = "camss_phy1_csi1phytimer_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_phy1_csi1phytimer_clk.c),
+	},
+};
+
+static struct branch_clk camss_phy2_csi2phytimer_clk = {
+	.cbcr_reg = CAMSS_PHY2_CSI2PHYTIMER_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &csi2phytimer_clk_src.c,
+		.dbg_name = "camss_phy2_csi2phytimer_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_phy2_csi2phytimer_clk.c),
+	},
+};
+
+static struct branch_clk camss_top_ahb_clk = {
+	.cbcr_reg = CAMSS_TOP_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "camss_top_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_top_ahb_clk.c),
+	},
+};
+
+static struct branch_clk camss_vfe_cpp_ahb_clk = {
+	.cbcr_reg = CAMSS_VFE_CPP_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "camss_vfe_cpp_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_vfe_cpp_ahb_clk.c),
+	},
+};
+
+static struct branch_clk camss_vfe_cpp_clk = {
+	.cbcr_reg = CAMSS_VFE_CPP_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &cpp_clk_src.c,
+		.dbg_name = "camss_vfe_cpp_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_vfe_cpp_clk.c),
+	},
+};
+
+static struct branch_clk camss_vfe_vfe0_clk = {
+	.cbcr_reg = CAMSS_VFE_VFE0_CBCR,
+	.bcr_reg = CAMSS_VFE_BCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &vfe0_clk_src.c,
+		.dbg_name = "camss_vfe_vfe0_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_vfe_vfe0_clk.c),
+	},
+};
+
+static struct branch_clk camss_vfe_vfe1_clk = {
+	.cbcr_reg = CAMSS_VFE_VFE1_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &vfe1_clk_src.c,
+		.dbg_name = "camss_vfe_vfe1_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_vfe_vfe1_clk.c),
+	},
+};
+
+static struct branch_clk camss_vfe_vfe_ahb_clk = {
+	.cbcr_reg = CAMSS_VFE_VFE_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "camss_vfe_vfe_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_vfe_vfe_ahb_clk.c),
+	},
+};
+
+static struct branch_clk camss_vfe_vfe_axi_clk = {
+	.cbcr_reg = CAMSS_VFE_VFE_AXI_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &axi_clk_src.c,
+		.dbg_name = "camss_vfe_vfe_axi_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_vfe_vfe_axi_clk.c),
+	},
+};
+
+static struct branch_clk camss_vfe_vfe_ocmemnoc_clk = {
+	.cbcr_reg = CAMSS_VFE_VFE_OCMEMNOC_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &ocmemnoc_clk_src.c,
+		.dbg_name = "camss_vfe_vfe_ocmemnoc_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(camss_vfe_vfe_ocmemnoc_clk.c),
+	},
+};
+
+static struct branch_clk mdss_ahb_clk = {
+	.cbcr_reg = MDSS_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "mdss_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(mdss_ahb_clk.c),
+	},
+};
+
+static struct branch_clk mdss_axi_clk = {
+	.cbcr_reg = MDSS_AXI_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &axi_clk_src.c,
+		.dbg_name = "mdss_axi_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(mdss_axi_clk.c),
+	},
+};
+
+static struct branch_clk mdss_byte0_clk = {
+	.cbcr_reg = MDSS_BYTE0_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &byte0_clk_src.c,
+		.dbg_name = "mdss_byte0_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(mdss_byte0_clk.c),
+	},
+};
+
+static struct branch_clk mdss_byte1_clk = {
+	.cbcr_reg = MDSS_BYTE1_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &byte1_clk_src.c,
+		.dbg_name = "mdss_byte1_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(mdss_byte1_clk.c),
+	},
+};
+
+static struct branch_clk mdss_edpaux_clk = {
+	.cbcr_reg = MDSS_EDPAUX_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &edpaux_clk_src.c,
+		.dbg_name = "mdss_edpaux_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(mdss_edpaux_clk.c),
+	},
+};
+
+static struct branch_clk mdss_edplink_clk = {
+	.cbcr_reg = MDSS_EDPLINK_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &edplink_clk_src.c,
+		.dbg_name = "mdss_edplink_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(mdss_edplink_clk.c),
+	},
+};
+
+static struct branch_clk mdss_edppixel_clk = {
+	.cbcr_reg = MDSS_EDPPIXEL_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &edppixel_clk_src.c,
+		.dbg_name = "mdss_edppixel_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(mdss_edppixel_clk.c),
+	},
+};
+
+static struct branch_clk mdss_esc0_clk = {
+	.cbcr_reg = MDSS_ESC0_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &esc0_clk_src.c,
+		.dbg_name = "mdss_esc0_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(mdss_esc0_clk.c),
+	},
+};
+
+static struct branch_clk mdss_esc1_clk = {
+	.cbcr_reg = MDSS_ESC1_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &esc1_clk_src.c,
+		.dbg_name = "mdss_esc1_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(mdss_esc1_clk.c),
+	},
+};
+
+static struct branch_clk mdss_extpclk_clk = {
+	.cbcr_reg = MDSS_EXTPCLK_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &extpclk_clk_src.c,
+		.dbg_name = "mdss_extpclk_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(mdss_extpclk_clk.c),
+	},
+};
+
+static struct branch_clk mdss_hdmi_ahb_clk = {
+	.cbcr_reg = MDSS_HDMI_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "mdss_hdmi_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(mdss_hdmi_ahb_clk.c),
+	},
+};
+
+static struct branch_clk mdss_hdmi_clk = {
+	.cbcr_reg = MDSS_HDMI_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &hdmi_clk_src.c,
+		.dbg_name = "mdss_hdmi_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(mdss_hdmi_clk.c),
+	},
+};
+
+static struct branch_clk mdss_mdp_clk = {
+	.cbcr_reg = MDSS_MDP_CBCR,
+	.bcr_reg = MDSS_BCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &mdp_clk_src.c,
+		.dbg_name = "mdss_mdp_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(mdss_mdp_clk.c),
+	},
+};
+
+static struct branch_clk mdss_mdp_lut_clk = {
+	.cbcr_reg = MDSS_MDP_LUT_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &mdp_clk_src.c,
+		.dbg_name = "mdss_mdp_lut_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(mdss_mdp_lut_clk.c),
+	},
+};
+
+static struct branch_clk mdss_pclk0_clk = {
+	.cbcr_reg = MDSS_PCLK0_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &pclk0_clk_src.c,
+		.dbg_name = "mdss_pclk0_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(mdss_pclk0_clk.c),
+	},
+};
+
+static struct branch_clk mdss_pclk1_clk = {
+	.cbcr_reg = MDSS_PCLK1_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &pclk1_clk_src.c,
+		.dbg_name = "mdss_pclk1_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(mdss_pclk1_clk.c),
+	},
+};
+
+static struct branch_clk mdss_vsync_clk = {
+	.cbcr_reg = MDSS_VSYNC_CBCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &vsync_clk_src.c,
+		.dbg_name = "mdss_vsync_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(mdss_vsync_clk.c),
+	},
+};
+
+static struct branch_clk mmss_misc_ahb_clk = {
+	.cbcr_reg = MMSS_MISC_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "mmss_misc_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(mmss_misc_ahb_clk.c),
+	},
+};
+
+static struct branch_clk mmss_mmssnoc_axi_clk = {
+	.cbcr_reg = MMSS_MMSSNOC_AXI_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &axi_clk_src.c,
+		.dbg_name = "mmss_mmssnoc_axi_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(mmss_mmssnoc_axi_clk.c),
+	},
+};
+
+static struct branch_clk mmss_s0_axi_clk = {
+	.cbcr_reg = MMSS_S0_AXI_CBCR,
+	/* The bus driver needs set_rate to go through to the parent */
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &axi_clk_src.c,
+		.dbg_name = "mmss_s0_axi_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(mmss_s0_axi_clk.c),
+		.depends = &mmss_mmssnoc_axi_clk.c,
+	},
+};
+
+struct branch_clk ocmemnoc_clk = {
+	.cbcr_reg = OCMEMNOC_CBCR,
+	.has_sibling = 0,
+	.bcr_reg = 0x50b0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &ocmemnoc_clk_src.c,
+		.dbg_name = "ocmemnoc_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(ocmemnoc_clk.c),
+	},
+};
+
+struct branch_clk ocmemcx_ocmemnoc_clk = {
+	.cbcr_reg = OCMEMCX_OCMEMNOC_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &ocmemnoc_clk_src.c,
+		.dbg_name = "ocmemcx_ocmemnoc_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(ocmemcx_ocmemnoc_clk.c),
+	},
+};
+
+static struct branch_clk venus0_ahb_clk = {
+	.cbcr_reg = VENUS0_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "venus0_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(venus0_ahb_clk.c),
+	},
+};
+
+static struct branch_clk venus0_axi_clk = {
+	.cbcr_reg = VENUS0_AXI_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &axi_clk_src.c,
+		.dbg_name = "venus0_axi_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(venus0_axi_clk.c),
+	},
+};
+
+static struct branch_clk venus0_ocmemnoc_clk = {
+	.cbcr_reg = VENUS0_OCMEMNOC_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &ocmemnoc_clk_src.c,
+		.dbg_name = "venus0_ocmemnoc_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(venus0_ocmemnoc_clk.c),
+	},
+};
+
+static struct branch_clk venus0_vcodec0_clk = {
+	.cbcr_reg = VENUS0_VCODEC0_CBCR,
+	.bcr_reg = VENUS0_BCR,
+	.has_sibling = 0,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &vcodec0_clk_src.c,
+		.dbg_name = "venus0_vcodec0_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(venus0_vcodec0_clk.c),
+	},
+};
+
+static struct branch_clk oxilicx_axi_clk = {
+	.cbcr_reg = OXILICX_AXI_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &axi_clk_src.c,
+		.dbg_name = "oxilicx_axi_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(oxilicx_axi_clk.c),
+	},
+};
+
+static struct branch_clk oxili_gfx3d_clk = {
+	.cbcr_reg = OXILI_GFX3D_CBCR,
+	.bcr_reg = OXILI_BCR,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.parent = &oxili_gfx3d_clk_src.c,
+		.dbg_name = "oxili_gfx3d_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(oxili_gfx3d_clk.c),
+		.depends = &oxilicx_axi_clk.c,
+	},
+};
+
+static struct branch_clk oxilicx_ahb_clk = {
+	.cbcr_reg = OXILICX_AHB_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[MMSS_BASE],
+	.c = {
+		.dbg_name = "oxilicx_ahb_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(oxilicx_ahb_clk.c),
+	},
+};
+
+static struct branch_clk q6ss_ahb_lfabif_clk = {
+	.cbcr_reg = LPASS_Q6SS_AHB_LFABIF_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[LPASS_BASE],
+	.c = {
+		.dbg_name = "q6ss_ahb_lfabif_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(q6ss_ahb_lfabif_clk.c),
+	},
+};
+
+
+static struct branch_clk gcc_lpass_q6_axi_clk = {
+	.cbcr_reg = LPASS_Q6_AXI_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[GCC_BASE],
+	.c = {
+		.dbg_name = "gcc_lpass_q6_axi_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(gcc_lpass_q6_axi_clk.c),
+	},
+};
+
+static struct branch_clk q6ss_xo_clk = {
+	.cbcr_reg = LPASS_Q6SS_XO_CBCR,
+	.bcr_reg = LPASS_Q6SS_BCR,
+	.has_sibling = 1,
+	.base = &virt_bases[LPASS_BASE],
+	.c = {
+		.dbg_name = "q6ss_xo_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(q6ss_xo_clk.c),
+	},
+};
+
+static struct branch_clk q6ss_ahbm_clk = {
+	.cbcr_reg = Q6SS_AHBM_CBCR,
+	.has_sibling = 1,
+	.base = &virt_bases[LPASS_BASE],
+	.c = {
+		.dbg_name = "q6ss_ahbm_clk",
+		.ops = &clk_ops_branch,
+		CLK_INIT(q6ss_ahbm_clk.c),
+	},
+};
+
+static DEFINE_CLK_MEASURE(l2_m_clk);
+static DEFINE_CLK_MEASURE(krait0_m_clk);
+static DEFINE_CLK_MEASURE(krait1_m_clk);
+static DEFINE_CLK_MEASURE(krait2_m_clk);
+static DEFINE_CLK_MEASURE(krait3_m_clk);
+static DEFINE_CLK_MEASURE(wcnss_m_clk);
+
+#ifdef CONFIG_DEBUG_FS
+
+struct measure_mux_entry {
+	struct clk *c;
+	int base;
+	u32 debug_mux;
+};
+
+enum {
+	M_ACPU0 = 0,
+	M_ACPU1,
+	M_ACPU2,
+	M_ACPU3,
+	M_L2,
+};
+
+struct measure_mux_entry measure_mux[] = {
+	{&gcc_pdm_ahb_clk.c,			GCC_BASE, 0x00d0},
+	{&gcc_blsp2_qup1_i2c_apps_clk.c,	GCC_BASE, 0x00ab},
+	{&gcc_blsp2_qup3_spi_apps_clk.c,	GCC_BASE, 0x00b3},
+	{&gcc_blsp2_uart5_apps_clk.c,		GCC_BASE, 0x00be},
+	{&gcc_usb30_master_clk.c,		GCC_BASE, 0x0050},
+	{&gcc_blsp2_qup3_i2c_apps_clk.c,	GCC_BASE, 0x00b4},
+	{&gcc_usb_hsic_system_clk.c,		GCC_BASE, 0x0059},
+	{&gcc_sdcc1_cdccal_sleep_clk.c,		GCC_BASE, 0x006a},
+	{&gcc_sdcc1_cdccal_ff_clk.c,		GCC_BASE, 0x006b},
+	{&gcc_blsp2_uart3_apps_clk.c,		GCC_BASE, 0x00b5},
+	{&gcc_usb_hsic_io_cal_clk.c,		GCC_BASE, 0x005b},
+	{&gcc_ce2_axi_clk.c,			GCC_BASE, 0x0141},
+	{&gcc_sdcc3_ahb_clk.c,			GCC_BASE, 0x0079},
+	{&gcc_blsp1_qup5_i2c_apps_clk.c,	GCC_BASE, 0x009d},
+	{&gcc_blsp1_qup1_spi_apps_clk.c,	GCC_BASE, 0x008a},
+	{&gcc_blsp2_uart4_apps_clk.c,		GCC_BASE, 0x00ba},
+	{&gcc_ce2_clk.c,			GCC_BASE, 0x0140},
+	{&gcc_blsp1_uart2_apps_clk.c,		GCC_BASE, 0x0091},
+	{&gcc_sdcc1_ahb_clk.c,			GCC_BASE, 0x0069},
+	{&gcc_mss_cfg_ahb_clk.c,		GCC_BASE, 0x0030},
+	{&gcc_tsif_ahb_clk.c,			GCC_BASE, 0x00e8},
+	{&gcc_sdcc4_ahb_clk.c,			GCC_BASE, 0x0081},
+	{&gcc_blsp1_qup4_spi_apps_clk.c,	GCC_BASE, 0x0098},
+	{&gcc_blsp2_qup4_spi_apps_clk.c,	GCC_BASE, 0x00b8},
+	{&gcc_blsp1_qup3_spi_apps_clk.c,	GCC_BASE, 0x0093},
+	{&gcc_blsp1_qup6_i2c_apps_clk.c,	GCC_BASE, 0x00a2},
+	{&gcc_blsp2_qup6_i2c_apps_clk.c,	GCC_BASE, 0x00c2},
+	{&gcc_bam_dma_ahb_clk.c,		GCC_BASE, 0x00e0},
+	{&gcc_sdcc3_apps_clk.c,			GCC_BASE, 0x0078},
+	{&gcc_usb_hs_system_clk.c,		GCC_BASE, 0x0060},
+	{&gcc_blsp1_ahb_clk.c,			GCC_BASE, 0x0088},
+	{&gcc_sdcc1_apps_clk.c,			GCC_BASE, 0x0068},
+	{&gcc_blsp2_qup5_i2c_apps_clk.c,	GCC_BASE, 0x00bd},
+	{&gcc_blsp1_uart4_apps_clk.c,		GCC_BASE, 0x009a},
+	{&gcc_blsp2_qup2_spi_apps_clk.c,	GCC_BASE, 0x00ae},
+	{&gcc_blsp2_qup6_spi_apps_clk.c,	GCC_BASE, 0x00c1},
+	{&gcc_blsp2_uart2_apps_clk.c,		GCC_BASE, 0x00b1},
+	{&gcc_blsp1_qup2_spi_apps_clk.c,	GCC_BASE, 0x008e},
+	{&gcc_usb_hsic_ahb_clk.c,		GCC_BASE, 0x0058},
+	{&gcc_blsp1_uart3_apps_clk.c,		GCC_BASE, 0x0095},
+	{&gcc_usb30_mock_utmi_clk.c,		GCC_BASE, 0x0052},
+	{&gcc_ce1_axi_clk.c,			GCC_BASE, 0x0139},
+	{&gcc_sdcc4_apps_clk.c,			GCC_BASE, 0x0080},
+	{&gcc_blsp1_qup5_spi_apps_clk.c,	GCC_BASE, 0x009c},
+	{&gcc_usb_hs_ahb_clk.c,			GCC_BASE, 0x0061},
+	{&gcc_blsp1_qup6_spi_apps_clk.c,	GCC_BASE, 0x00a1},
+	{&gcc_blsp2_qup2_i2c_apps_clk.c,	GCC_BASE, 0x00b0},
+	{&gcc_prng_ahb_clk.c,			GCC_BASE, 0x00d8},
+	{&gcc_blsp1_qup3_i2c_apps_clk.c,	GCC_BASE, 0x0094},
+	{&gcc_usb_hsic_clk.c,			GCC_BASE, 0x005a},
+	{&gcc_blsp1_uart6_apps_clk.c,		GCC_BASE, 0x00a3},
+	{&gcc_sdcc2_apps_clk.c,			GCC_BASE, 0x0070},
+	{&gcc_tsif_ref_clk.c,			GCC_BASE, 0x00e9},
+	{&gcc_blsp1_uart1_apps_clk.c,		GCC_BASE, 0x008c},
+	{&gcc_blsp2_qup5_spi_apps_clk.c,	GCC_BASE, 0x00bc},
+	{&gcc_blsp1_qup4_i2c_apps_clk.c,	GCC_BASE, 0x0099},
+	{&gcc_mmss_noc_cfg_ahb_clk.c,		GCC_BASE, 0x002a},
+	{&gcc_blsp2_ahb_clk.c,			GCC_BASE, 0x00a8},
+	{&gcc_boot_rom_ahb_clk.c,		GCC_BASE, 0x00f8},
+	{&gcc_ce1_ahb_clk.c,			GCC_BASE, 0x013a},
+	{&gcc_pdm2_clk.c,			GCC_BASE, 0x00d2},
+	{&gcc_blsp2_qup4_i2c_apps_clk.c,	GCC_BASE, 0x00b9},
+	{&gcc_ce2_ahb_clk.c,			GCC_BASE, 0x0142},
+	{&gcc_blsp1_uart5_apps_clk.c,		GCC_BASE, 0x009e},
+	{&gcc_blsp2_qup1_spi_apps_clk.c,	GCC_BASE, 0x00aa},
+	{&gcc_blsp1_qup2_i2c_apps_clk.c,	GCC_BASE, 0x0090},
+	{&gcc_blsp2_uart1_apps_clk.c,		GCC_BASE, 0x00ac},
+	{&gcc_blsp1_qup1_i2c_apps_clk.c,	GCC_BASE, 0x008b},
+	{&gcc_blsp2_uart6_apps_clk.c,		GCC_BASE, 0x00c3},
+	{&gcc_sdcc2_ahb_clk.c,			GCC_BASE, 0x0071},
+	{&gcc_usb30_sleep_clk.c,		GCC_BASE, 0x0051},
+	{&gcc_usb2a_phy_sleep_clk.c,		GCC_BASE, 0x0063},
+	{&gcc_usb2b_phy_sleep_clk.c,		GCC_BASE, 0x0064},
+	{&gcc_sys_noc_usb3_axi_clk.c,		GCC_BASE, 0x0001},
+	{&gcc_ocmem_noc_cfg_ahb_clk.c,		GCC_BASE, 0x0029},
+	{&gcc_ce1_clk.c,			GCC_BASE, 0x0138},
+	{&gcc_lpass_q6_axi_clk.c,		GCC_BASE, 0x0160},
+	{&gcc_mss_q6_bimc_axi_clk.c,		GCC_BASE, 0x0031},
+	{&cnoc_clk.c,                           GCC_BASE, 0x0008},
+	{&pnoc_clk.c,                           GCC_BASE, 0x0010},
+	{&snoc_clk.c,                           GCC_BASE, 0x0000},
+	{&bimc_clk.c,                           GCC_BASE, 0x0155},
+	{&wcnss_m_clk,                          GCC_BASE, 0x0198},
+	{&mmss_mmssnoc_axi_clk.c,		MMSS_BASE, 0x0004},
+	{&ocmemnoc_clk.c,			MMSS_BASE, 0x0007},
+	{&ocmemcx_ocmemnoc_clk.c,		MMSS_BASE, 0x0009},
+	{&camss_cci_cci_ahb_clk.c,		MMSS_BASE, 0x002e},
+	{&camss_cci_cci_clk.c,			MMSS_BASE, 0x002d},
+	{&camss_csi0_ahb_clk.c,			MMSS_BASE, 0x0042},
+	{&camss_csi0_clk.c,			MMSS_BASE, 0x0041},
+	{&camss_csi0phy_clk.c,			MMSS_BASE, 0x0043},
+	{&camss_csi0pix_clk.c,			MMSS_BASE, 0x0045},
+	{&camss_csi0rdi_clk.c,			MMSS_BASE, 0x0044},
+	{&camss_csi1_ahb_clk.c,			MMSS_BASE, 0x0047},
+	{&camss_csi1_clk.c,			MMSS_BASE, 0x0046},
+	{&camss_csi1phy_clk.c,			MMSS_BASE, 0x0048},
+	{&camss_csi1pix_clk.c,			MMSS_BASE, 0x004a},
+	{&camss_csi1rdi_clk.c,			MMSS_BASE, 0x0049},
+	{&camss_csi2_ahb_clk.c,			MMSS_BASE, 0x004c},
+	{&camss_csi2_clk.c,			MMSS_BASE, 0x004b},
+	{&camss_csi2phy_clk.c,			MMSS_BASE, 0x004d},
+	{&camss_csi2pix_clk.c,			MMSS_BASE, 0x004f},
+	{&camss_csi2rdi_clk.c,			MMSS_BASE, 0x004e},
+	{&camss_csi3_ahb_clk.c,			MMSS_BASE, 0x0051},
+	{&camss_csi3_clk.c,			MMSS_BASE, 0x0050},
+	{&camss_csi3phy_clk.c,			MMSS_BASE, 0x0052},
+	{&camss_csi3pix_clk.c,			MMSS_BASE, 0x0054},
+	{&camss_csi3rdi_clk.c,			MMSS_BASE, 0x0053},
+	{&camss_csi_vfe0_clk.c,			MMSS_BASE, 0x003f},
+	{&camss_csi_vfe1_clk.c,			MMSS_BASE, 0x0040},
+	{&camss_gp0_clk.c,			MMSS_BASE, 0x0027},
+	{&camss_gp1_clk.c,			MMSS_BASE, 0x0028},
+	{&camss_ispif_ahb_clk.c,		MMSS_BASE, 0x0055},
+	{&camss_jpeg_jpeg0_clk.c,		MMSS_BASE, 0x0032},
+	{&camss_jpeg_jpeg1_clk.c,		MMSS_BASE, 0x0033},
+	{&camss_jpeg_jpeg2_clk.c,		MMSS_BASE, 0x0034},
+	{&camss_jpeg_jpeg_ahb_clk.c,		MMSS_BASE, 0x0035},
+	{&camss_jpeg_jpeg_axi_clk.c,		MMSS_BASE, 0x0036},
+	{&camss_jpeg_jpeg_ocmemnoc_clk.c,	MMSS_BASE, 0x0037},
+	{&camss_mclk0_clk.c,			MMSS_BASE, 0x0029},
+	{&camss_mclk1_clk.c,			MMSS_BASE, 0x002a},
+	{&camss_mclk2_clk.c,			MMSS_BASE, 0x002b},
+	{&camss_mclk3_clk.c,			MMSS_BASE, 0x002c},
+	{&camss_micro_ahb_clk.c,		MMSS_BASE, 0x0026},
+	{&camss_phy0_csi0phytimer_clk.c,	MMSS_BASE, 0x002f},
+	{&camss_phy1_csi1phytimer_clk.c,	MMSS_BASE, 0x0030},
+	{&camss_phy2_csi2phytimer_clk.c,	MMSS_BASE, 0x0031},
+	{&camss_top_ahb_clk.c,			MMSS_BASE, 0x0025},
+	{&camss_vfe_cpp_ahb_clk.c,		MMSS_BASE, 0x003b},
+	{&camss_vfe_cpp_clk.c,			MMSS_BASE, 0x003a},
+	{&camss_vfe_vfe0_clk.c,			MMSS_BASE, 0x0038},
+	{&camss_vfe_vfe1_clk.c,			MMSS_BASE, 0x0039},
+	{&camss_vfe_vfe_ahb_clk.c,		MMSS_BASE, 0x003c},
+	{&camss_vfe_vfe_axi_clk.c,		MMSS_BASE, 0x003d},
+	{&camss_vfe_vfe_ocmemnoc_clk.c,		MMSS_BASE, 0x003e},
+	{&oxilicx_axi_clk.c,			MMSS_BASE, 0x000b},
+	{&oxilicx_ahb_clk.c,			MMSS_BASE, 0x000c},
+	{&ocmemcx_ocmemnoc_clk.c,		MMSS_BASE, 0x0009},
+	{&oxili_gfx3d_clk.c,			MMSS_BASE, 0x000d},
+	{&venus0_axi_clk.c,			MMSS_BASE, 0x000f},
+	{&venus0_ocmemnoc_clk.c,		MMSS_BASE, 0x0010},
+	{&venus0_ahb_clk.c,			MMSS_BASE, 0x0011},
+	{&venus0_vcodec0_clk.c,			MMSS_BASE, 0x000e},
+	{&mmss_s0_axi_clk.c,			MMSS_BASE, 0x0005},
+	{&mmssnoc_ahb_clk.c,			MMSS_BASE, 0x0001},
+	{&mdss_ahb_clk.c,			MMSS_BASE, 0x0022},
+	{&mdss_hdmi_clk.c,			MMSS_BASE, 0x001d},
+	{&mdss_mdp_clk.c,			MMSS_BASE, 0x0014},
+	{&mdss_mdp_lut_clk.c,			MMSS_BASE, 0x0015},
+	{&mdss_axi_clk.c,			MMSS_BASE, 0x0024},
+	{&mdss_vsync_clk.c,			MMSS_BASE, 0x001c},
+	{&mdss_esc0_clk.c,			MMSS_BASE, 0x0020},
+	{&mdss_esc1_clk.c,			MMSS_BASE, 0x0021},
+	{&mdss_edpaux_clk.c,			MMSS_BASE, 0x001b},
+	{&mdss_byte0_clk.c,			MMSS_BASE, 0x001e},
+	{&mdss_byte1_clk.c,			MMSS_BASE, 0x001f},
+	{&mdss_edplink_clk.c,			MMSS_BASE, 0x001a},
+	{&mdss_edppixel_clk.c,			MMSS_BASE, 0x0019},
+	{&mdss_extpclk_clk.c,			MMSS_BASE, 0x0018},
+	{&mdss_hdmi_ahb_clk.c,			MMSS_BASE, 0x0023},
+	{&mdss_pclk0_clk.c,			MMSS_BASE, 0x0016},
+	{&mdss_pclk1_clk.c,			MMSS_BASE, 0x0017},
+	{&q6ss_xo_clk.c,			LPASS_BASE, 0x002b},
+	{&q6ss_ahb_lfabif_clk.c,		LPASS_BASE, 0x001e},
+	{&q6ss_ahbm_clk.c,			LPASS_BASE, 0x001d},
+
+	{&krait0_m_clk,				APCS_BASE, M_ACPU0},
+	{&krait1_m_clk,				APCS_BASE, M_ACPU1},
+	{&krait2_m_clk,				APCS_BASE, M_ACPU2},
+	{&krait3_m_clk,				APCS_BASE, M_ACPU3},
+	{&l2_m_clk,				APCS_BASE, M_L2},
+
+	{&dummy_clk,				N_BASES,   0x0000},
+};
+
+static int measure_clk_set_parent(struct clk *c, struct clk *parent)
+{
+	struct measure_clk *clk = to_measure_clk(c);
+	unsigned long flags;
+	u32 regval, clk_sel, i;
+
+	if (!parent)
+		return -EINVAL;
+
+	for (i = 0; i < (ARRAY_SIZE(measure_mux) - 1); i++)
+		if (measure_mux[i].c == parent)
+			break;
+
+	if (measure_mux[i].c == &dummy_clk)
+		return -EINVAL;
+
+	spin_lock_irqsave(&local_clock_reg_lock, flags);
+	/*
+	 * Program the test vector, measurement period (sample_ticks)
+	 * and scaling multiplier.
+	 */
+	clk->sample_ticks = 0x10000;
+	clk->multiplier = 1;
+
+	switch (measure_mux[i].base) {
+
+	case GCC_BASE:
+		writel_relaxed(0, GCC_REG_BASE(GCC_DEBUG_CLK_CTL_REG));
+		clk_sel = measure_mux[i].debug_mux;
+		break;
+
+	case MMSS_BASE:
+		writel_relaxed(0, MMSS_REG_BASE(MMSS_DEBUG_CLK_CTL_REG));
+		clk_sel = 0x02C;
+		regval = BVAL(11, 0, measure_mux[i].debug_mux);
+		writel_relaxed(regval, MMSS_REG_BASE(MMSS_DEBUG_CLK_CTL_REG));
+
+		/* Activate debug clock output */
+		regval |= BIT(16);
+		writel_relaxed(regval, MMSS_REG_BASE(MMSS_DEBUG_CLK_CTL_REG));
+		break;
+
+	case LPASS_BASE:
+		writel_relaxed(0, LPASS_REG_BASE(LPASS_DEBUG_CLK_CTL_REG));
+		clk_sel = 0x161;
+		regval = BVAL(11, 0, measure_mux[i].debug_mux);
+		writel_relaxed(regval, LPASS_REG_BASE(LPASS_DEBUG_CLK_CTL_REG));
+
+		/* Activate debug clock output */
+		regval |= BIT(20);
+		writel_relaxed(regval, LPASS_REG_BASE(LPASS_DEBUG_CLK_CTL_REG));
+		break;
+
+	case APCS_BASE:
+		clk->multiplier = 4;
+		clk_sel = 0x16A;
+
+		if (SOCINFO_VERSION_MAJOR(socinfo_get_version()) == 1 &&
+		    cpu_is_msm8974()) {
+			if (measure_mux[i].debug_mux == M_L2)
+				regval = BIT(7)|BIT(0);
+			else
+				regval = BIT(7)|(measure_mux[i].debug_mux << 3);
+		} else {
+			if (measure_mux[i].debug_mux == M_L2)
+				regval = BIT(12);
+			else
+				regval = measure_mux[i].debug_mux << 8;
+			writel_relaxed(BIT(0), APCS_REG_BASE(L2_CBCR_REG));
+		}
+		writel_relaxed(regval, APCS_REG_BASE(GLB_CLK_DIAG_REG));
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	/* Set debug mux clock index */
+	regval = BVAL(8, 0, clk_sel);
+	writel_relaxed(regval, GCC_REG_BASE(GCC_DEBUG_CLK_CTL_REG));
+
+	/* Activate debug clock output */
+	regval |= BIT(16);
+	writel_relaxed(regval, GCC_REG_BASE(GCC_DEBUG_CLK_CTL_REG));
+
+	/* Make sure test vector is set before starting measurements. */
+	mb();
+	spin_unlock_irqrestore(&local_clock_reg_lock, flags);
+
+	return 0;
+}
+
+/* Sample clock for 'ticks' reference clock ticks. */
+static u32 run_measurement(unsigned ticks)
+{
+	/* Stop counters and set the XO4 counter start value. */
+	writel_relaxed(ticks, GCC_REG_BASE(CLOCK_FRQ_MEASURE_CTL_REG));
+
+	/* Wait for timer to become ready. */
+	while ((readl_relaxed(GCC_REG_BASE(CLOCK_FRQ_MEASURE_STATUS_REG)) &
+			BIT(25)) != 0)
+		cpu_relax();
+
+	/* Run measurement and wait for completion. */
+	writel_relaxed(BIT(20)|ticks, GCC_REG_BASE(CLOCK_FRQ_MEASURE_CTL_REG));
+	while ((readl_relaxed(GCC_REG_BASE(CLOCK_FRQ_MEASURE_STATUS_REG)) &
+			BIT(25)) == 0)
+		cpu_relax();
+
+	/* Return measured ticks. */
+	return readl_relaxed(GCC_REG_BASE(CLOCK_FRQ_MEASURE_STATUS_REG)) &
+				BM(24, 0);
+}
+
+/*
+ * Perform a hardware rate measurement for a given clock.
+ * FOR DEBUG USE ONLY: Measurements take ~15 ms!
+ */
+static unsigned long measure_clk_get_rate(struct clk *c)
+{
+	unsigned long flags;
+	u32 gcc_xo4_reg_backup;
+	u64 raw_count_short, raw_count_full;
+	struct measure_clk *clk = to_measure_clk(c);
+	unsigned ret;
+
+	ret = clk_prepare_enable(&cxo_clk_src.c);
+	if (ret) {
+		pr_warning("CXO clock failed to enable. Can't measure\n");
+		return 0;
+	}
+
+	spin_lock_irqsave(&local_clock_reg_lock, flags);
+
+	/* Enable CXO/4 and RINGOSC branch. */
+	gcc_xo4_reg_backup = readl_relaxed(GCC_REG_BASE(GCC_XO_DIV4_CBCR_REG));
+	writel_relaxed(0x1, GCC_REG_BASE(GCC_XO_DIV4_CBCR_REG));
+
+	/*
+	 * The ring oscillator counter will not reset if the measured clock
+	 * is not running.  To detect this, run a short measurement before
+	 * the full measurement.  If the raw results of the two are the same
+	 * then the clock must be off.
+	 */
+
+	/* Run a short measurement. (~1 ms) */
+	raw_count_short = run_measurement(0x1000);
+	/* Run a full measurement. (~14 ms) */
+	raw_count_full = run_measurement(clk->sample_ticks);
+
+	writel_relaxed(gcc_xo4_reg_backup, GCC_REG_BASE(GCC_XO_DIV4_CBCR_REG));
+
+	/* Return 0 if the clock is off. */
+	if (raw_count_full == raw_count_short) {
+		ret = 0;
+	} else {
+		/* Compute rate in Hz. */
+		raw_count_full = ((raw_count_full * 10) + 15) * 4800000;
+		do_div(raw_count_full, ((clk->sample_ticks * 10) + 35));
+		ret = (raw_count_full * clk->multiplier);
+	}
+
+	writel_relaxed(0x51A00, GCC_REG_BASE(GCC_PLLTEST_PAD_CFG_REG));
+	spin_unlock_irqrestore(&local_clock_reg_lock, flags);
+
+	clk_disable_unprepare(&cxo_clk_src.c);
+
+	return ret;
+}
+#else /* !CONFIG_DEBUG_FS */
+static int measure_clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	return -EINVAL;
+}
+
+static unsigned long measure_clk_get_rate(struct clk *clk)
+{
+	return 0;
+}
+#endif /* CONFIG_DEBUG_FS */
+
+static struct clk_ops clk_ops_measure = {
+	.set_parent = measure_clk_set_parent,
+	.get_rate = measure_clk_get_rate,
+};
+
+static struct measure_clk measure_clk = {
+	.c = {
+		.dbg_name = "measure_clk",
+		.ops = &clk_ops_measure,
+		CLK_INIT(measure_clk.c),
+	},
+	.multiplier = 1,
+};
+
+
+static struct clk_lookup msm_clocks_8974_rumi[] = {
+	CLK_LOOKUP("iface_clk", gcc_sdcc1_ahb_clk.c, "msm_sdcc.1"),
+	CLK_LOOKUP("core_clk", gcc_sdcc1_apps_clk.c, "msm_sdcc.1"),
+	CLK_LOOKUP("iface_clk", gcc_sdcc2_ahb_clk.c, "msm_sdcc.2"),
+	CLK_LOOKUP("core_clk", gcc_sdcc2_apps_clk.c, "msm_sdcc.2"),
+	CLK_LOOKUP("iface_clk", gcc_sdcc3_ahb_clk.c, "msm_sdcc.3"),
+	CLK_LOOKUP("core_clk", gcc_sdcc3_apps_clk.c, "msm_sdcc.3"),
+	CLK_LOOKUP("iface_clk", gcc_sdcc4_ahb_clk.c, "msm_sdcc.4"),
+	CLK_LOOKUP("core_clk", gcc_sdcc4_apps_clk.c, "msm_sdcc.4"),
+	CLK_DUMMY("xo",		XO_CLK,		NULL,	OFF),
+	CLK_DUMMY("xo",		XO_CLK,		"fb21b000.qcom,pronto", OFF),
+	CLK_DUMMY("core_clk",	BLSP2_UART_CLK,	"f991f000.serial",	OFF),
+	CLK_DUMMY("iface_clk",	BLSP2_UART_CLK,	"f991f000.serial",	OFF),
+	CLK_DUMMY("core_clk",	SDC1_CLK,	NULL,			OFF),
+	CLK_DUMMY("iface_clk",	SDC1_P_CLK,	NULL,			OFF),
+	CLK_DUMMY("core_clk",	SDC3_CLK,	NULL,			OFF),
+	CLK_DUMMY("iface_clk",	SDC3_P_CLK,	NULL,			OFF),
+	CLK_DUMMY("phy_clk", NULL, "msm_otg", OFF),
+	CLK_DUMMY("core_clk", NULL, "msm_otg", OFF),
+	CLK_DUMMY("iface_clk", NULL, "msm_otg", OFF),
+	CLK_DUMMY("xo", NULL, "msm_otg", OFF),
+	CLK_DUMMY("dfab_clk",	DFAB_CLK,	NULL, 0),
+	CLK_DUMMY("dma_bam_pclk",	DMA_BAM_P_CLK,	NULL, 0),
+	CLK_DUMMY("mem_clk",	NULL,	NULL, 0),
+	CLK_DUMMY("core_clk",	SPI_CLK,	"spi_qsd.1",	OFF),
+	CLK_DUMMY("iface_clk",	SPI_P_CLK,	"spi_qsd.1",	OFF),
+	CLK_DUMMY("core_clk",	NULL,	"f9966000.i2c", 0),
+	CLK_DUMMY("iface_clk",	NULL,	"f9966000.i2c", 0),
+	CLK_DUMMY("core_clk",	NULL,	"fe12f000.slim",	OFF),
+	CLK_DUMMY("core_clk", "mdp.0", NULL, 0),
+	CLK_DUMMY("core_clk_src", "mdp.0", NULL, 0),
+	CLK_DUMMY("lut_clk", "mdp.0", NULL, 0),
+	CLK_DUMMY("vsync_clk", "mdp.0", NULL, 0),
+	CLK_DUMMY("iface_clk", "mdp.0", NULL, 0),
+	CLK_DUMMY("bus_clk", "mdp.0", NULL, 0),
+	CLK_DUMMY("iface_clk", NULL, "fda64000.qcom,iommu", OFF),
+	CLK_DUMMY("core_clk", NULL, "fda64000.qcom,iommu", OFF),
+	CLK_DUMMY("alt_core_clk", NULL, "fda64000.qcom,iommu", OFF),
+	CLK_DUMMY("iface_clk", NULL, "fda44000.qcom,iommu", OFF),
+	CLK_DUMMY("core_clk", NULL, "fda44000.qcom,iommu", OFF),
+	CLK_DUMMY("alt_core_clk", NULL, "fda44000.qcom,iommu", OFF),
+	CLK_DUMMY("iface_clk", NULL, "fd928000.qcom,iommu", OFF),
+	CLK_DUMMY("core_clk", NULL, "fd928000.qcom,iommu", oFF),
+	CLK_DUMMY("core_clk", NULL, "fdb10000.qcom,iommu", OFF),
+	CLK_DUMMY("iface_clk", NULL, "fdb10000.qcom,iommu", OFF),
+	CLK_DUMMY("alt_core_clk", NULL, "fdb10000.qcom,iommu", OFF),
+	CLK_DUMMY("iface_clk", NULL, "fdc84000.qcom,iommu", OFF),
+	CLK_DUMMY("alt_core_clk", NULL, "fdc84000.qcom,iommu", oFF),
+	CLK_DUMMY("core_clk", NULL, "fdc84000.qcom,iommu", oFF),
+};
+
+static struct clk_lookup msm_clocks_8974pro_only[] __initdata = {
+	CLK_LOOKUP("gpll4", gpll4_clk_src.c, ""),
+	CLK_LOOKUP("sleep_clk", gcc_sdcc1_cdccal_sleep_clk.c, "msm_sdcc.1"),
+	CLK_LOOKUP("cal_clk", gcc_sdcc1_cdccal_ff_clk.c, "msm_sdcc.1"),
+	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "6e.qcom,camera"),
+	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "20.qcom,camera"),
+	#ifdef CONFIG_IMX135_Z5S_069
+	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "200.qcom,camera"),
+	#endif
+	CLK_LOOKUP("cam_src_clk", mclk2_clk_src.c, "6c.qcom,camera"),
+	CLK_LOOKUP("cam_src_clk", mclk1_clk_src.c, "90.qcom,camera"),
+	CLK_LOOKUP("cam_clk", camss_mclk0_clk.c, "6e.qcom,camera"),
+	CLK_LOOKUP("cam_clk", camss_mclk0_clk.c, "20.qcom,camera"),
+	#ifdef CONFIG_IMX135_Z5S_069
+	CLK_LOOKUP("cam_clk", camss_mclk0_clk.c, "200.qcom,camera"),
+	#endif
+	CLK_LOOKUP("cam_clk", camss_mclk2_clk.c, "6c.qcom,camera"),
+	CLK_LOOKUP("cam_clk", camss_mclk1_clk.c, "90.qcom,camera"),
+	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "0.qcom,camera"),
+	CLK_LOOKUP("cam_src_clk", mclk1_clk_src.c, "1.qcom,camera"),
+	CLK_LOOKUP("cam_src_clk", mclk2_clk_src.c, "2.qcom,camera"),
+	CLK_LOOKUP("cam_clk", camss_mclk0_clk.c, "0.qcom,camera"),
+	CLK_LOOKUP("cam_clk", camss_mclk1_clk.c, "1.qcom,camera"),
+	CLK_LOOKUP("cam_clk", camss_mclk2_clk.c, "2.qcom,camera"),
+};
+
+static struct clk_lookup msm_clocks_8974_only[] __initdata = {
+	CLK_LOOKUP("cam_src_clk", mmss_gp0_clk_src.c, "6e.qcom,camera"),
+	CLK_LOOKUP("cam_src_clk", mmss_gp0_clk_src.c, "20.qcom,camera"),
+	#ifdef CONFIG_IMX135_Z5S_069
+       CLK_LOOKUP("cam_src_clk", mmss_gp0_clk_src.c, "200.qcom,camera"),
+       #endif
+	CLK_LOOKUP("cam_src_clk", gp1_clk_src.c, "6c.qcom,camera"),
+	CLK_LOOKUP("cam_src_clk", mmss_gp1_clk_src.c, "90.qcom,camera"),
+	CLK_LOOKUP("cam_clk", camss_gp0_clk.c, "6e.qcom,camera"),
+	CLK_LOOKUP("cam_clk", camss_gp0_clk.c, "20.qcom,camera"),
+	#ifdef CONFIG_IMX135_Z5S_069
+	CLK_LOOKUP("cam_clk", camss_gp0_clk.c, "200.qcom,camera"),
+	#endif
+	CLK_LOOKUP("cam_clk", gcc_gp1_clk.c, "6c.qcom,camera"),
+	CLK_LOOKUP("cam_clk", camss_gp1_clk.c, "90.qcom,camera"),
+	CLK_LOOKUP("cam_src_clk", mmss_gp0_clk_src.c, "0.qcom,camera"),
+	CLK_LOOKUP("cam_src_clk", gp1_clk_src.c, "2.qcom,camera"),
+	CLK_LOOKUP("cam_src_clk", mmss_gp1_clk_src.c, "1.qcom,camera"),
+	CLK_LOOKUP("cam_clk", camss_gp0_clk.c, "0.qcom,camera"),
+	CLK_LOOKUP("cam_clk", gcc_gp1_clk.c, "2.qcom,camera"),
+	CLK_LOOKUP("cam_clk", camss_gp1_clk.c, "1.qcom,camera"),
+};
+
+static struct clk_lookup msm_clocks_8974_common[] __initdata = {
+	CLK_LOOKUP("xo",        cxo_otg_clk.c,                  "msm_otg"),
+	CLK_LOOKUP("xo",  cxo_pil_lpass_clk.c,      "fe200000.qcom,lpass"),
+	CLK_LOOKUP("xo",    cxo_pil_mss_clk.c,        "fc880000.qcom,mss"),
+	CLK_LOOKUP("xo",       cxo_wlan_clk.c, "fb000000.qcom,wcnss-wlan"),
+	CLK_LOOKUP("rf_clk",         cxo_a2.c, "fb000000.qcom,wcnss-wlan"),
+	CLK_LOOKUP("xo", cxo_pil_pronto_clk.c,     "fb21b000.qcom,pronto"),
+	CLK_LOOKUP("xo",       cxo_dwc3_clk.c,                 "msm_dwc3"),
+	CLK_LOOKUP("xo",  cxo_ehci_host_clk.c,            "msm_ehci_host"),
+	CLK_LOOKUP("xo",        cxo_lpm_clk.c,        "fc4281d0.qcom,mpm"),
+	CLK_LOOKUP("ref_clk",  cxo_d1_a_pin.c,                   "3-000e"),
+	CLK_LOOKUP("ref_clk_rf", cxo_a2_a_pin.c,                 "3-000e"),
+	CLK_LOOKUP("measure",	measure_clk.c,	"debug"),
+
+	CLK_LOOKUP("hfpll_src", cxo_a_clk_src.c,   "f9016000.qcom,clock-krait"),
+	CLK_LOOKUP("aux_clk",   gpll0_ao_clk_src.c,
+						"f9016000.qcom,clock-krait"),
+	CLK_LOOKUP("gpll0", gpll0_clk_src.c, ""),
+
+	CLK_LOOKUP("dma_bam_pclk", gcc_bam_dma_ahb_clk.c, "msm_sps"),
+	CLK_LOOKUP("iface_clk", gcc_blsp1_ahb_clk.c, "f991f000.serial"),
+	CLK_LOOKUP("iface_clk", gcc_blsp1_ahb_clk.c, "f9924000.i2c"),
+#ifdef CONFIG_SERIAL_MSM_HSL
+	CLK_LOOKUP("iface_clk", gcc_blsp1_ahb_clk.c, "f991d000.serial"),
+#endif
+	CLK_LOOKUP("iface_clk", gcc_blsp1_ahb_clk.c, "f991e000.serial"),
+	CLK_LOOKUP("core_clk", gcc_blsp1_qup1_i2c_apps_clk.c, "f9923000.i2c"),
+	CLK_LOOKUP("iface_clk", gcc_blsp1_ahb_clk.c, "f9923000.i2c"),
+	CLK_LOOKUP("core_clk", gcc_blsp1_qup2_i2c_apps_clk.c, "f9924000.i2c"),
+	CLK_LOOKUP("core_clk", gcc_blsp1_qup2_spi_apps_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_blsp1_qup1_spi_apps_clk.c, "f9923000.spi"),
+	CLK_LOOKUP("iface_clk", gcc_blsp1_ahb_clk.c, "f9923000.spi"),
+	CLK_LOOKUP("core_clk", gcc_blsp1_qup3_i2c_apps_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_blsp1_qup3_spi_apps_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_blsp1_qup4_i2c_apps_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_blsp1_qup4_spi_apps_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_blsp1_qup5_i2c_apps_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_blsp1_qup5_spi_apps_clk.c, ""),
+
+	/* I2C Clocks nfc */
+	CLK_LOOKUP("iface_clk",          gcc_blsp1_ahb_clk.c, "f9928000.i2c"),
+	CLK_LOOKUP("core_clk", gcc_blsp1_qup6_i2c_apps_clk.c, "f9928000.i2c"),
+
+	CLK_LOOKUP("core_clk", gcc_blsp1_qup6_spi_apps_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_blsp1_uart1_apps_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_blsp1_uart2_apps_clk.c, "f991e000.serial"),
+	CLK_LOOKUP("core_clk", gcc_blsp1_uart3_apps_clk.c, "f991f000.serial"),
+	CLK_LOOKUP("core_clk", gcc_blsp1_uart4_apps_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_blsp1_uart5_apps_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_blsp1_uart6_apps_clk.c, ""),
+
+	CLK_LOOKUP("iface_clk", gcc_blsp2_ahb_clk.c, "f9967000.i2c"),
+	CLK_LOOKUP("iface_clk", gcc_blsp2_ahb_clk.c, "f9966000.spi"),
+	//CLK_LOOKUP("iface_clk", gcc_blsp2_ahb_clk.c, "f995e000.serial"), // broadcom
+	CLK_LOOKUP("iface_clk", gcc_blsp2_ahb_clk.c, "f995e000.uart"),		// broadcom
+	//CLK_LOOKUP("iface_clk", gcc_blsp2_ahb_clk.c, "f995d000.uart"),
+	// broadcom 3449 begin
+
+	// broadcom 3449 end
+	CLK_LOOKUP("core_clk", gcc_blsp2_qup1_i2c_apps_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_blsp2_qup1_spi_apps_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_blsp2_qup2_i2c_apps_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_blsp2_qup2_spi_apps_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_blsp2_qup3_i2c_apps_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_blsp2_qup3_spi_apps_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_blsp2_qup4_i2c_apps_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_blsp2_qup5_i2c_apps_clk.c, "f9967000.i2c"),
+	CLK_LOOKUP("core_clk", gcc_blsp2_qup4_spi_apps_clk.c, "f9966000.spi"),
+	CLK_LOOKUP("core_clk", gcc_blsp2_qup5_spi_apps_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_blsp2_qup6_i2c_apps_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_blsp2_qup6_spi_apps_clk.c, ""),
+	//CLK_LOOKUP("core_clk", gcc_blsp2_uart1_apps_clk.c, "f995d000.uart"),
+	//CLK_LOOKUP("core_clk", gcc_blsp2_uart2_apps_clk.c, "f995e000.serial"), // broadcom
+	CLK_LOOKUP("core_clk", gcc_blsp2_uart2_apps_clk.c, "f995e000.uart"),	 // broadcom
+	CLK_LOOKUP("core_clk", gcc_blsp2_uart3_apps_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_blsp2_uart4_apps_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_blsp2_uart5_apps_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_blsp2_uart6_apps_clk.c, ""),
+
+	CLK_LOOKUP("core_clk_src", ce1_clk_src.c, ""),
+	CLK_LOOKUP("core_clk", gcc_ce1_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_ce2_clk.c, ""),
+	CLK_LOOKUP("iface_clk", gcc_ce1_ahb_clk.c, ""),
+	CLK_LOOKUP("iface_clk", gcc_ce2_ahb_clk.c, ""),
+	CLK_LOOKUP("bus_clk", gcc_ce1_axi_clk.c, ""),
+	CLK_LOOKUP("bus_clk", gcc_ce2_axi_clk.c, ""),
+
+	CLK_LOOKUP("core_clk",     gcc_ce2_clk.c,         "qcedev.0"),
+	CLK_LOOKUP("iface_clk",    gcc_ce2_ahb_clk.c,     "qcedev.0"),
+	CLK_LOOKUP("bus_clk",      gcc_ce2_axi_clk.c,     "qcedev.0"),
+	CLK_LOOKUP("core_clk_src", ce2_clk_src.c,         "qcedev.0"),
+
+	CLK_LOOKUP("core_clk",     gcc_ce2_clk.c,     "qcrypto.0"),
+	CLK_LOOKUP("iface_clk",    gcc_ce2_ahb_clk.c, "qcrypto.0"),
+	CLK_LOOKUP("bus_clk",      gcc_ce2_axi_clk.c, "qcrypto.0"),
+	CLK_LOOKUP("core_clk_src", ce2_clk_src.c,     "qcrypto.0"),
+
+	CLK_LOOKUP("core_clk",     gcc_ce1_clk.c,         "qseecom"),
+	CLK_LOOKUP("iface_clk",    gcc_ce1_ahb_clk.c,     "qseecom"),
+	CLK_LOOKUP("bus_clk",      gcc_ce1_axi_clk.c,     "qseecom"),
+	CLK_LOOKUP("core_clk_src", ce1_clk_src.c,         "qseecom"),
+
+	CLK_LOOKUP("ce_drv_core_clk",     gcc_ce2_clk.c,         "qseecom"),
+	CLK_LOOKUP("ce_drv_iface_clk",    gcc_ce2_ahb_clk.c,     "qseecom"),
+	CLK_LOOKUP("ce_drv_bus_clk",      gcc_ce2_axi_clk.c,     "qseecom"),
+	CLK_LOOKUP("ce_drv_core_clk_src", ce2_clk_src.c,         "qseecom"),
+
+	CLK_LOOKUP("core_clk",     gcc_ce1_clk.c,         "mcd"),
+	CLK_LOOKUP("iface_clk",    gcc_ce1_ahb_clk.c,     "mcd"),
+	CLK_LOOKUP("bus_clk",      gcc_ce1_axi_clk.c,     "mcd"),
+	CLK_LOOKUP("core_clk_src", ce1_clk_src.c,         "mcd"),
+
+	CLK_LOOKUP("core_clk",     gcc_ce1_clk.c,         "scm"),
+	CLK_LOOKUP("iface_clk",    gcc_ce1_ahb_clk.c,     "scm"),
+	CLK_LOOKUP("bus_clk",      gcc_ce1_axi_clk.c,     "scm"),
+	CLK_LOOKUP("core_clk_src", ce1_clk_src.c,         "scm"),
+
+	CLK_LOOKUP("core_clk", gcc_gp1_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_gp2_clk.c, ""),
+	CLK_LOOKUP("core_clk", gcc_gp3_clk.c, ""),
+
+	CLK_LOOKUP("core_clk", gcc_pdm2_clk.c, ""),
+	CLK_LOOKUP("iface_clk", gcc_pdm_ahb_clk.c, ""),
+	CLK_LOOKUP("iface_clk", gcc_prng_ahb_clk.c, ""),
+
+	CLK_LOOKUP("iface_clk", gcc_sdcc1_ahb_clk.c, "msm_sdcc.1"),
+	CLK_LOOKUP("core_clk", gcc_sdcc1_apps_clk.c, "msm_sdcc.1"),
+	CLK_LOOKUP("iface_clk", gcc_sdcc2_ahb_clk.c, "msm_sdcc.2"),
+	CLK_LOOKUP("core_clk", gcc_sdcc2_apps_clk.c, "msm_sdcc.2"),
+	CLK_LOOKUP("iface_clk", gcc_sdcc3_ahb_clk.c, "msm_sdcc.3"),
+	CLK_LOOKUP("core_clk", gcc_sdcc3_apps_clk.c, "msm_sdcc.3"),
+	CLK_LOOKUP("iface_clk", gcc_sdcc4_ahb_clk.c, "msm_sdcc.4"),
+	CLK_LOOKUP("core_clk", gcc_sdcc4_apps_clk.c, "msm_sdcc.4"),
+
+	CLK_LOOKUP("iface_clk", gcc_tsif_ahb_clk.c, "f99d8000.msm_tspp"),
+	CLK_LOOKUP("ref_clk", gcc_tsif_ref_clk.c, "f99d8000.msm_tspp"),
+
+	CLK_LOOKUP("mem_clk", gcc_usb30_master_clk.c,           "usb_bam"),
+	CLK_LOOKUP("mem_iface_clk", gcc_sys_noc_usb3_axi_clk.c, "usb_bam"),
+	CLK_LOOKUP("core_clk", gcc_usb30_master_clk.c,    "msm_dwc3"),
+	CLK_LOOKUP("utmi_clk", gcc_usb30_mock_utmi_clk.c, "msm_dwc3"),
+	CLK_LOOKUP("iface_clk", gcc_sys_noc_usb3_axi_clk.c, "msm_dwc3"),
+	CLK_LOOKUP("iface_clk", gcc_sys_noc_usb3_axi_clk.c, "msm_usb3"),
+	CLK_LOOKUP("sleep_clk", gcc_usb30_sleep_clk.c, "msm_dwc3"),
+	CLK_LOOKUP("sleep_a_clk", gcc_usb2a_phy_sleep_clk.c, "msm_dwc3"),
+	CLK_LOOKUP("sleep_b_clk", gcc_usb2b_phy_sleep_clk.c, "msm_dwc3"),
+	CLK_LOOKUP("ref_clk", diff_clk.c, "msm_dwc3"),
+	CLK_LOOKUP("iface_clk", gcc_usb_hs_ahb_clk.c,     "msm_otg"),
+	CLK_LOOKUP("core_clk", gcc_usb_hs_system_clk.c,   "msm_otg"),
+	CLK_LOOKUP("iface_clk", gcc_usb_hsic_ahb_clk.c,	  "msm_hsic_host"),
+	CLK_LOOKUP("phy_clk", gcc_usb_hsic_clk.c,	  "msm_hsic_host"),
+	CLK_LOOKUP("cal_clk", gcc_usb_hsic_io_cal_clk.c,  "msm_hsic_host"),
+	CLK_LOOKUP("core_clk", gcc_usb_hsic_system_clk.c, "msm_hsic_host"),
+	CLK_LOOKUP("osr_clk", div_clk1.c, "msm-dai-q6-dev.16384"),
+	CLK_LOOKUP("ref_clk", div_clk2.c, "msm_smsc_hub"),
+	CLK_LOOKUP("iface_clk", gcc_usb_hs_ahb_clk.c,     "msm_ehci_host"),
+	CLK_LOOKUP("core_clk", gcc_usb_hs_system_clk.c,   "msm_ehci_host"),
+	CLK_LOOKUP("sleep_clk", gcc_usb2b_phy_sleep_clk.c, "msm_ehci_host"),
+	CLK_LOOKUP("pwm_clk", div_clk2.c, "0-0048"),
+
+	CLK_LOOKUP("measure",   measure_clk.c, "fb000000.qcom,wcnss-wlan"),
+	CLK_LOOKUP("wcnss_debug", wcnss_m_clk, "fb000000.qcom,wcnss-wlan"),
+
+	/* Multimedia clocks */
+	CLK_LOOKUP("bus_clk_src", axi_clk_src.c, ""),
+	CLK_LOOKUP("bus_clk", mmss_mmssnoc_axi_clk.c, ""),
+	CLK_LOOKUP("bus_clk", mmssnoc_ahb_clk.c, ""),
+	CLK_LOOKUP("core_clk", mdss_edpaux_clk.c, "fd923400.qcom,mdss_edp"),
+	CLK_LOOKUP("pixel_clk", mdss_edppixel_clk.c, "fd923400.qcom,mdss_edp"),
+	CLK_LOOKUP("link_clk", mdss_edplink_clk.c, "fd923400.qcom,mdss_edp"),
+	CLK_LOOKUP("mdp_core_clk", mdss_mdp_clk.c, "fd923400.qcom,mdss_edp"),
+	CLK_LOOKUP("byte_clk", mdss_byte0_clk.c, "fd922800.qcom,mdss_dsi"),
+	CLK_LOOKUP("byte_clk", mdss_byte1_clk.c, "fd922e00.qcom,mdss_dsi"),
+	CLK_LOOKUP("core_clk", mdss_esc0_clk.c, "fd922800.qcom,mdss_dsi"),
+	CLK_LOOKUP("core_clk", mdss_esc1_clk.c, "fd922e00.qcom,mdss_dsi"),
+	CLK_LOOKUP("iface_clk", mdss_ahb_clk.c, "fd922800.qcom,mdss_dsi"),
+	CLK_LOOKUP("iface_clk", mdss_ahb_clk.c, "fd922e00.qcom,mdss_dsi"),
+	CLK_LOOKUP("bus_clk", mdss_axi_clk.c, "fd922800.qcom,mdss_dsi"),
+	CLK_LOOKUP("bus_clk", mdss_axi_clk.c, "fd922e00.qcom,mdss_dsi"),
+	CLK_LOOKUP("pixel_clk", mdss_pclk0_clk.c, "fd922800.qcom,mdss_dsi"),
+	CLK_LOOKUP("pixel_clk", mdss_pclk1_clk.c, "fd922e00.qcom,mdss_dsi"),
+	CLK_LOOKUP("mdp_core_clk", mdss_mdp_clk.c, "fd922800.qcom,mdss_dsi"),
+	CLK_LOOKUP("mdp_core_clk", mdss_mdp_clk.c, "fd922e00.qcom,mdss_dsi"),
+	CLK_LOOKUP("iface_clk", mdss_ahb_clk.c, "fd922100.qcom,hdmi_tx"),
+	CLK_LOOKUP("alt_iface_clk", mdss_hdmi_ahb_clk.c,
+		"fd922100.qcom,hdmi_tx"),
+	CLK_LOOKUP("core_clk", mdss_hdmi_clk.c, "fd922100.qcom,hdmi_tx"),
+	CLK_LOOKUP("mdp_core_clk", mdss_mdp_clk.c, "fd922100.qcom,hdmi_tx"),
+	CLK_LOOKUP("extp_clk", mdss_extpclk_clk.c, "fd922100.qcom,hdmi_tx"),
+	CLK_LOOKUP("core_clk", mdss_mdp_clk.c, "mdp.0"),
+	CLK_LOOKUP("lut_clk", mdss_mdp_lut_clk.c, "mdp.0"),
+	CLK_LOOKUP("core_clk_src", mdp_clk_src.c, "mdp.0"),
+	CLK_LOOKUP("vsync_clk", mdss_vsync_clk.c, "mdp.0"),
+
+	/* MM sensor clocks placeholder */
+	CLK_LOOKUP("", camss_mclk0_clk.c, ""),
+	CLK_LOOKUP("", camss_mclk1_clk.c, ""),
+	CLK_LOOKUP("", camss_mclk2_clk.c, ""),
+	CLK_LOOKUP("", camss_mclk3_clk.c, ""),
+	CLK_LOOKUP("", mmss_gp0_clk_src.c, ""),
+	CLK_LOOKUP("", mmss_gp1_clk_src.c, ""),
+	CLK_LOOKUP("", camss_gp0_clk.c, ""),
+	CLK_LOOKUP("", camss_gp1_clk.c, ""),
+
+	/* CCI clocks */
+	CLK_LOOKUP("camss_top_ahb_clk", camss_top_ahb_clk.c,
+		"fda0c000.qcom,cci"),
+	CLK_LOOKUP("cci_ahb_clk", camss_cci_cci_ahb_clk.c, "fda0c000.qcom,cci"),
+	CLK_LOOKUP("cci_src_clk", cci_clk_src.c, "fda0c000.qcom,cci"),
+	CLK_LOOKUP("cci_clk", camss_cci_cci_clk.c, "fda0c000.qcom,cci"),
+	/* CSIPHY clocks */
+	CLK_LOOKUP("camss_top_ahb_clk", camss_top_ahb_clk.c,
+		"fda0ac00.qcom,csiphy"),
+	CLK_LOOKUP("ispif_ahb_clk", camss_ispif_ahb_clk.c,
+		"fda0ac00.qcom,csiphy"),
+	CLK_LOOKUP("csiphy_timer_src_clk", csi0phytimer_clk_src.c,
+		"fda0ac00.qcom,csiphy"),
+	CLK_LOOKUP("csiphy_timer_clk", camss_phy0_csi0phytimer_clk.c,
+		"fda0ac00.qcom,csiphy"),
+	CLK_LOOKUP("camss_top_ahb_clk", camss_top_ahb_clk.c,
+		"fda0b000.qcom,csiphy"),
+	CLK_LOOKUP("ispif_ahb_clk", camss_ispif_ahb_clk.c,
+		"fda0b000.qcom,csiphy"),
+	CLK_LOOKUP("csiphy_timer_src_clk", csi1phytimer_clk_src.c,
+		"fda0b000.qcom,csiphy"),
+	CLK_LOOKUP("csiphy_timer_clk", camss_phy1_csi1phytimer_clk.c,
+		"fda0b000.qcom,csiphy"),
+	CLK_LOOKUP("camss_top_ahb_clk", camss_top_ahb_clk.c,
+		"fda0b400.qcom,csiphy"),
+	CLK_LOOKUP("ispif_ahb_clk", camss_ispif_ahb_clk.c,
+		"fda0b400.qcom,csiphy"),
+	CLK_LOOKUP("csiphy_timer_src_clk", csi2phytimer_clk_src.c,
+		"fda0b400.qcom,csiphy"),
+	CLK_LOOKUP("csiphy_timer_clk", camss_phy2_csi2phytimer_clk.c,
+		"fda0b400.qcom,csiphy"),
+
+	/* CSID clocks */
+	CLK_LOOKUP("ispif_ahb_clk", camss_ispif_ahb_clk.c,
+					"fda08000.qcom,csid"),
+	CLK_LOOKUP("camss_top_ahb_clk", camss_top_ahb_clk.c,
+					"fda08000.qcom,csid"),
+	CLK_LOOKUP("csi_ahb_clk", camss_csi0_ahb_clk.c,
+					"fda08000.qcom,csid"),
+	CLK_LOOKUP("csi_src_clk", csi0_clk_src.c,
+					"fda08000.qcom,csid"),
+	CLK_LOOKUP("csi_phy_clk", camss_csi0phy_clk.c,
+					"fda08000.qcom,csid"),
+	CLK_LOOKUP("csi_clk", camss_csi0_clk.c,
+					"fda08000.qcom,csid"),
+	CLK_LOOKUP("csi_pix_clk", camss_csi0pix_clk.c,
+					"fda08000.qcom,csid"),
+	CLK_LOOKUP("csi_rdi_clk", camss_csi0rdi_clk.c,
+					"fda08000.qcom,csid"),
+
+	CLK_LOOKUP("ispif_ahb_clk", camss_ispif_ahb_clk.c,
+					"fda08400.qcom,csid"),
+	CLK_LOOKUP("camss_top_ahb_clk", camss_top_ahb_clk.c,
+					"fda08400.qcom,csid"),
+	CLK_LOOKUP("csi_ahb_clk", camss_csi1_ahb_clk.c,
+					"fda08400.qcom,csid"),
+	CLK_LOOKUP("csi_src_clk", csi1_clk_src.c,
+					"fda08400.qcom,csid"),
+	CLK_LOOKUP("csi_phy_clk", camss_csi1phy_clk.c,
+					"fda08400.qcom,csid"),
+	CLK_LOOKUP("csi_clk", camss_csi1_clk.c,
+					"fda08400.qcom,csid"),
+	CLK_LOOKUP("csi_pix_clk", camss_csi1pix_clk.c,
+					"fda08400.qcom,csid"),
+	CLK_LOOKUP("csi_rdi_clk", camss_csi1rdi_clk.c,
+					"fda08400.qcom,csid"),
+
+	CLK_LOOKUP("ispif_ahb_clk", camss_ispif_ahb_clk.c,
+					"fda08800.qcom,csid"),
+	CLK_LOOKUP("camss_top_ahb_clk", camss_top_ahb_clk.c,
+					"fda08800.qcom,csid"),
+	CLK_LOOKUP("csi_ahb_clk", camss_csi2_ahb_clk.c,
+					"fda08800.qcom,csid"),
+	CLK_LOOKUP("csi_src_clk", csi2_clk_src.c,
+					"fda08800.qcom,csid"),
+	CLK_LOOKUP("csi_phy_clk", camss_csi2phy_clk.c,
+					"fda08800.qcom,csid"),
+	CLK_LOOKUP("csi_clk", camss_csi2_clk.c,
+					"fda08800.qcom,csid"),
+	CLK_LOOKUP("csi_pix_clk", camss_csi2pix_clk.c,
+					"fda08800.qcom,csid"),
+	CLK_LOOKUP("csi_rdi_clk", camss_csi2rdi_clk.c,
+					"fda08800.qcom,csid"),
+
+	CLK_LOOKUP("ispif_ahb_clk", camss_ispif_ahb_clk.c,
+					"fda08c00.qcom,csid"),
+	CLK_LOOKUP("camss_top_ahb_clk", camss_top_ahb_clk.c,
+					"fda08c00.qcom,csid"),
+	CLK_LOOKUP("csi_ahb_clk", camss_csi3_ahb_clk.c,
+					"fda08c00.qcom,csid"),
+	CLK_LOOKUP("csi_src_clk", csi3_clk_src.c,
+					"fda08c00.qcom,csid"),
+	CLK_LOOKUP("csi_phy_clk", camss_csi3phy_clk.c,
+					"fda08c00.qcom,csid"),
+	CLK_LOOKUP("csi_clk", camss_csi3_clk.c,
+					"fda08c00.qcom,csid"),
+	CLK_LOOKUP("csi_pix_clk", camss_csi3pix_clk.c,
+					"fda08c00.qcom,csid"),
+	CLK_LOOKUP("csi_rdi_clk", camss_csi3rdi_clk.c,
+					"fda08c00.qcom,csid"),
+
+	/* ISPIF clocks */
+	CLK_LOOKUP("ispif_ahb_clk", camss_ispif_ahb_clk.c,
+					"fda0a000.qcom,ispif"),
+
+	CLK_LOOKUP("vfe0_clk_src", vfe0_clk_src.c,
+					"fda0a000.qcom,ispif"),
+	CLK_LOOKUP("camss_vfe_vfe0_clk", camss_vfe_vfe0_clk.c,
+					"fda0a000.qcom,ispif"),
+	CLK_LOOKUP("camss_csi_vfe0_clk", camss_csi_vfe0_clk.c,
+					"fda0a000.qcom,ispif"),
+	CLK_LOOKUP("vfe1_clk_src", vfe1_clk_src.c,
+					"fda0a000.qcom,ispif"),
+	CLK_LOOKUP("camss_vfe_vfe1_clk", camss_vfe_vfe1_clk.c,
+					"fda0a000.qcom,ispif"),
+	CLK_LOOKUP("camss_csi_vfe1_clk", camss_csi_vfe1_clk.c,
+					"fda0a000.qcom,ispif"),
+
+	CLK_LOOKUP("csi0_src_clk", csi0_clk_src.c,
+					"fda0a000.qcom,ispif"),
+	CLK_LOOKUP("csi0_clk", camss_csi0_clk.c,
+					"fda0a000.qcom,ispif"),
+	CLK_LOOKUP("csi0_pix_clk", camss_csi0pix_clk.c,
+					"fda0a000.qcom,ispif"),
+	CLK_LOOKUP("csi0_rdi_clk", camss_csi0rdi_clk.c,
+					"fda0a000.qcom,ispif"),
+
+	CLK_LOOKUP("csi1_src_clk", csi1_clk_src.c,
+					"fda0a000.qcom,ispif"),
+	CLK_LOOKUP("csi1_clk", camss_csi1_clk.c,
+					"fda0a000.qcom,ispif"),
+	CLK_LOOKUP("csi1_pix_clk", camss_csi1pix_clk.c,
+					"fda0a000.qcom,ispif"),
+	CLK_LOOKUP("csi1_rdi_clk", camss_csi1rdi_clk.c,
+					"fda0a000.qcom,ispif"),
+
+	CLK_LOOKUP("csi2_src_clk", csi2_clk_src.c,
+					"fda0a000.qcom,ispif"),
+	CLK_LOOKUP("csi2_clk", camss_csi2_clk.c,
+					"fda0a000.qcom,ispif"),
+	CLK_LOOKUP("csi2_pix_clk", camss_csi2pix_clk.c,
+					"fda0a000.qcom,ispif"),
+	CLK_LOOKUP("csi2_rdi_clk", camss_csi2rdi_clk.c,
+					"fda0a000.qcom,ispif"),
+
+	CLK_LOOKUP("csi3_src_clk", csi3_clk_src.c,
+					"fda0a000.qcom,ispif"),
+	CLK_LOOKUP("csi3_clk", camss_csi3_clk.c,
+					"fda0a000.qcom,ispif"),
+	CLK_LOOKUP("csi3_pix_clk", camss_csi3pix_clk.c,
+					"fda0a000.qcom,ispif"),
+	CLK_LOOKUP("csi3_rdi_clk", camss_csi3rdi_clk.c,
+					"fda0a000.qcom,ispif"),
+
+	/*VFE clocks*/
+	CLK_LOOKUP("camss_top_ahb_clk", camss_top_ahb_clk.c,
+					"fda10000.qcom,vfe"),
+	CLK_LOOKUP("vfe_clk_src", vfe0_clk_src.c,	 "fda10000.qcom,vfe"),
+	CLK_LOOKUP("camss_vfe_vfe_clk", camss_vfe_vfe0_clk.c,
+					"fda10000.qcom,vfe"),
+	CLK_LOOKUP("camss_csi_vfe_clk", camss_csi_vfe0_clk.c,
+					"fda10000.qcom,vfe"),
+	CLK_LOOKUP("iface_clk", camss_vfe_vfe_ahb_clk.c, "fda10000.qcom,vfe"),
+	CLK_LOOKUP("bus_clk", camss_vfe_vfe_axi_clk.c,	 "fda10000.qcom,vfe"),
+	CLK_LOOKUP("alt_bus_clk", camss_vfe_vfe_ocmemnoc_clk.c,
+					"fda10000.qcom,vfe"),
+	CLK_LOOKUP("camss_top_ahb_clk", camss_top_ahb_clk.c,
+					"fda14000.qcom,vfe"),
+	CLK_LOOKUP("vfe_clk_src", vfe1_clk_src.c,	 "fda14000.qcom,vfe"),
+	CLK_LOOKUP("camss_vfe_vfe_clk", camss_vfe_vfe1_clk.c,
+					"fda14000.qcom,vfe"),
+	CLK_LOOKUP("camss_csi_vfe_clk", camss_csi_vfe1_clk.c,
+					"fda14000.qcom,vfe"),
+	CLK_LOOKUP("iface_clk", camss_vfe_vfe_ahb_clk.c, "fda14000.qcom,vfe"),
+	CLK_LOOKUP("bus_clk", camss_vfe_vfe_axi_clk.c,	 "fda14000.qcom,vfe"),
+	CLK_LOOKUP("alt_bus_clk", camss_vfe_vfe_ocmemnoc_clk.c,
+					"fda14000.qcom,vfe"),
+	/*Jpeg Clocks*/
+	CLK_LOOKUP("core_clk", camss_jpeg_jpeg0_clk.c, "fda1c000.qcom,jpeg"),
+	CLK_LOOKUP("core_clk", camss_jpeg_jpeg1_clk.c, "fda20000.qcom,jpeg"),
+	CLK_LOOKUP("core_clk", camss_jpeg_jpeg2_clk.c, "fda24000.qcom,jpeg"),
+	CLK_LOOKUP("iface_clk", camss_jpeg_jpeg_ahb_clk.c,
+						"fda1c000.qcom,jpeg"),
+	CLK_LOOKUP("iface_clk", camss_jpeg_jpeg_ahb_clk.c,
+						"fda20000.qcom,jpeg"),
+	CLK_LOOKUP("iface_clk", camss_jpeg_jpeg_ahb_clk.c,
+						"fda24000.qcom,jpeg"),
+	CLK_LOOKUP("iface_clk", camss_jpeg_jpeg_ahb_clk.c,
+						"fda64000.qcom,iommu"),
+	CLK_LOOKUP("core_clk", camss_jpeg_jpeg_axi_clk.c,
+						"fda64000.qcom,iommu"),
+	CLK_LOOKUP("alt_core_clk", camss_top_ahb_clk.c, "fda64000.qcom,iommu"),
+	CLK_LOOKUP("bus_clk0", camss_jpeg_jpeg_axi_clk.c, "fda1c000.qcom,jpeg"),
+	CLK_LOOKUP("bus_clk0", camss_jpeg_jpeg_axi_clk.c, "fda20000.qcom,jpeg"),
+	CLK_LOOKUP("bus_clk0", camss_jpeg_jpeg_axi_clk.c, "fda24000.qcom,jpeg"),
+	CLK_LOOKUP("alt_bus_clk", camss_jpeg_jpeg_ocmemnoc_clk.c,
+						"fda1c000.qcom,jpeg"),
+	CLK_LOOKUP("alt_bus_clk", camss_jpeg_jpeg_ocmemnoc_clk.c,
+						"fda20000.qcom,jpeg"),
+	CLK_LOOKUP("alt_bus_clk", camss_jpeg_jpeg_ocmemnoc_clk.c,
+						"fda24000.qcom,jpeg"),
+	CLK_LOOKUP("camss_top_ahb_clk", camss_top_ahb_clk.c,
+						"fda1c000.qcom,jpeg"),
+	CLK_LOOKUP("camss_top_ahb_clk", camss_top_ahb_clk.c,
+						"fda20000.qcom,jpeg"),
+	CLK_LOOKUP("camss_top_ahb_clk", camss_top_ahb_clk.c,
+						"fda24000.qcom,jpeg"),
+	CLK_LOOKUP("micro_iface_clk", camss_micro_ahb_clk.c,
+		"fda04000.qcom,cpp"),
+	CLK_LOOKUP("camss_top_ahb_clk", camss_top_ahb_clk.c,
+		"fda04000.qcom,cpp"),
+	CLK_LOOKUP("cpp_iface_clk", camss_vfe_cpp_ahb_clk.c,
+		"fda04000.qcom,cpp"),
+	CLK_LOOKUP("cpp_core_clk", camss_vfe_cpp_clk.c, "fda04000.qcom,cpp"),
+	CLK_LOOKUP("cpp_bus_clk", camss_vfe_vfe_axi_clk.c, "fda04000.qcom,cpp"),
+	CLK_LOOKUP("vfe_clk_src", vfe0_clk_src.c,	 "fda04000.qcom,cpp"),
+	CLK_LOOKUP("camss_vfe_vfe_clk", camss_vfe_vfe0_clk.c,
+					"fda04000.qcom,cpp"),
+	CLK_LOOKUP("iface_clk", camss_vfe_vfe_ahb_clk.c, "fda04000.qcom,cpp"),
+
+
+	CLK_LOOKUP("iface_clk", camss_micro_ahb_clk.c, ""),
+	CLK_LOOKUP("iface_clk", camss_vfe_vfe_ahb_clk.c, "fda44000.qcom,iommu"),
+	CLK_LOOKUP("core_clk", camss_vfe_vfe_axi_clk.c, "fda44000.qcom,iommu"),
+	CLK_LOOKUP("alt_core_clk", camss_top_ahb_clk.c, "fda44000.qcom,iommu"),
+	CLK_LOOKUP("iface_clk", mdss_ahb_clk.c, "mdp.0"),
+	CLK_LOOKUP("iface_clk", mdss_ahb_clk.c, "fd923400.qcom,mdss_edp"),
+	CLK_LOOKUP("iface_clk", mdss_ahb_clk.c, "fd928000.qcom,iommu"),
+	CLK_LOOKUP("core_clk", mdss_axi_clk.c, "fd928000.qcom,iommu"),
+	CLK_LOOKUP("bus_clk", mdss_axi_clk.c, "mdp.0"),
+	CLK_LOOKUP("core_clk", oxili_gfx3d_clk.c, "fdb00000.qcom,kgsl-3d0"),
+	CLK_LOOKUP("iface_clk", oxilicx_ahb_clk.c, "fdb00000.qcom,kgsl-3d0"),
+	CLK_LOOKUP("mem_iface_clk", ocmemcx_ocmemnoc_clk.c,
+						"fdb00000.qcom,kgsl-3d0"),
+	CLK_LOOKUP("core_clk", oxilicx_axi_clk.c, "fdb10000.qcom,iommu"),
+	CLK_LOOKUP("iface_clk", oxilicx_ahb_clk.c, "fdb10000.qcom,iommu"),
+	CLK_LOOKUP("alt_core_clk", oxili_gfx3d_clk.c, "fdb10000.qcom,iommu"),
+	CLK_LOOKUP("core_clk", ocmemgx_core_clk.c, "fdd00000.qcom,ocmem"),
+	CLK_LOOKUP("iface_clk", ocmemcx_ocmemnoc_clk.c, "fdd00000.qcom,ocmem"),
+	CLK_LOOKUP("iface_clk", venus0_ahb_clk.c, "fdc84000.qcom,iommu"),
+	CLK_LOOKUP("alt_core_clk", venus0_vcodec0_clk.c, "fdc84000.qcom,iommu"),
+	CLK_LOOKUP("core_clk", venus0_axi_clk.c, "fdc84000.qcom,iommu"),
+	CLK_LOOKUP("bus_clk", venus0_axi_clk.c, ""),
+	CLK_LOOKUP("src_clk",  vcodec0_clk_src.c, "fdce0000.qcom,venus"),
+	CLK_LOOKUP("core_clk", venus0_vcodec0_clk.c, "fdce0000.qcom,venus"),
+	CLK_LOOKUP("iface_clk",  venus0_ahb_clk.c, "fdce0000.qcom,venus"),
+	CLK_LOOKUP("bus_clk",  venus0_axi_clk.c, "fdce0000.qcom,venus"),
+	CLK_LOOKUP("mem_clk",  venus0_ocmemnoc_clk.c, "fdce0000.qcom,venus"),
+	CLK_LOOKUP("core_clk", venus0_vcodec0_clk.c, "fdc00000.qcom,vidc"),
+	CLK_LOOKUP("iface_clk",  venus0_ahb_clk.c, "fdc00000.qcom,vidc"),
+	CLK_LOOKUP("bus_clk",  venus0_axi_clk.c, "fdc00000.qcom,vidc"),
+	CLK_LOOKUP("mem_clk",  venus0_ocmemnoc_clk.c, "fdc00000.qcom,vidc"),
+
+	CLK_LOOKUP("core_clk", venus0_vcodec0_clk.c, "fd8c1024.qcom,gdsc"),
+	CLK_LOOKUP("core_clk", mdss_mdp_clk.c, "fd8c2304.qcom,gdsc"),
+	CLK_LOOKUP("lut_clk", mdss_mdp_lut_clk.c, "fd8c2304.qcom,gdsc"),
+	CLK_LOOKUP("core0_clk", camss_jpeg_jpeg0_clk.c, "fd8c35a4.qcom,gdsc"),
+	CLK_LOOKUP("core1_clk", camss_jpeg_jpeg1_clk.c, "fd8c35a4.qcom,gdsc"),
+	CLK_LOOKUP("core2_clk", camss_jpeg_jpeg2_clk.c, "fd8c35a4.qcom,gdsc"),
+	CLK_LOOKUP("core0_clk", camss_vfe_vfe0_clk.c,	"fd8c36a4.qcom,gdsc"),
+	CLK_LOOKUP("core1_clk", camss_vfe_vfe1_clk.c,	"fd8c36a4.qcom,gdsc"),
+	CLK_LOOKUP("csi0_clk", camss_csi_vfe0_clk.c,	"fd8c36a4.qcom,gdsc"),
+	CLK_LOOKUP("csi1_clk", camss_csi_vfe1_clk.c,	"fd8c36a4.qcom,gdsc"),
+	CLK_LOOKUP("cpp_clk", camss_vfe_cpp_clk.c,	"fd8c36a4.qcom,gdsc"),
+	CLK_LOOKUP("core_clk", oxili_gfx3d_clk.c, "fd8c4024.qcom,gdsc"),
+
+	/* LPASS clocks */
+	CLK_LOOKUP("bus_clk", gcc_mss_q6_bimc_axi_clk.c, "fc880000.qcom,mss"),
+	CLK_LOOKUP("iface_clk", gcc_mss_cfg_ahb_clk.c, "fc880000.qcom,mss"),
+	CLK_LOOKUP("mem_clk", gcc_boot_rom_ahb_clk.c,  "fc880000.qcom,mss"),
+
+	CLK_LOOKUP("core_clk",         q6ss_xo_clk.c,  "fe200000.qcom,lpass"),
+	CLK_LOOKUP("bus_clk", gcc_lpass_q6_axi_clk.c,  "fe200000.qcom,lpass"),
+	CLK_LOOKUP("iface_clk", q6ss_ahb_lfabif_clk.c, "fe200000.qcom,lpass"),
+	CLK_LOOKUP("reg_clk",        q6ss_ahbm_clk.c,  "fe200000.qcom,lpass"),
+	CLK_LOOKUP("core_clk", gcc_prng_ahb_clk.c, "msm_rng"),
+
+	CLK_LOOKUP("dfab_clk", pnoc_sps_clk.c, "msm_sps"),
+	CLK_LOOKUP("bus_clk", pnoc_keepalive_a_clk.c, ""),
+
+	CLK_LOOKUP("bus_clk", snoc_clk.c, ""),
+	CLK_LOOKUP("bus_clk", pnoc_clk.c, ""),
+	CLK_LOOKUP("bus_clk", cnoc_clk.c, ""),
+	CLK_LOOKUP("mem_clk", bimc_clk.c, ""),
+	CLK_LOOKUP("mem_clk", ocmemgx_clk.c, ""),
+	CLK_LOOKUP("bus_clk", snoc_a_clk.c, ""),
+	CLK_LOOKUP("bus_clk", pnoc_a_clk.c, ""),
+	CLK_LOOKUP("bus_clk", cnoc_a_clk.c, ""),
+	CLK_LOOKUP("mem_clk", bimc_a_clk.c, ""),
+	CLK_LOOKUP("mem_clk", ocmemgx_a_clk.c, ""),
+
+	CLK_LOOKUP("bus_clk",	cnoc_msmbus_clk.c,	"msm_config_noc"),
+	CLK_LOOKUP("bus_a_clk",	cnoc_msmbus_a_clk.c,	"msm_config_noc"),
+	CLK_LOOKUP("bus_clk",	snoc_msmbus_clk.c,	"msm_sys_noc"),
+	CLK_LOOKUP("bus_a_clk",	snoc_msmbus_a_clk.c,	"msm_sys_noc"),
+	CLK_LOOKUP("bus_clk",	pnoc_msmbus_clk.c,	"msm_periph_noc"),
+	CLK_LOOKUP("bus_a_clk",	pnoc_msmbus_a_clk.c,	"msm_periph_noc"),
+	CLK_LOOKUP("mem_clk",	bimc_msmbus_clk.c,	"msm_bimc"),
+	CLK_LOOKUP("mem_a_clk",	bimc_msmbus_a_clk.c,	"msm_bimc"),
+	CLK_LOOKUP("mem_clk",	bimc_acpu_a_clk.c,	""),
+	CLK_LOOKUP("ocmem_clk",	ocmemgx_msmbus_clk.c,	  "msm_bus"),
+	CLK_LOOKUP("ocmem_a_clk", ocmemgx_msmbus_a_clk.c, "msm_bus"),
+	CLK_LOOKUP("bus_clk",	ocmemnoc_clk.c,		"msm_ocmem_noc"),
+	CLK_LOOKUP("bus_a_clk",	ocmemnoc_clk.c,		"msm_ocmem_noc"),
+	CLK_LOOKUP("bus_clk",	mmss_s0_axi_clk.c,	"msm_mmss_noc"),
+	CLK_LOOKUP("bus_a_clk",	mmss_s0_axi_clk.c,	"msm_mmss_noc"),
+	CLK_LOOKUP("iface_clk", gcc_mmss_noc_cfg_ahb_clk.c, ""),
+	CLK_LOOKUP("iface_clk", gcc_ocmem_noc_cfg_ahb_clk.c, ""),
+
+	/* CoreSight clocks */
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc322000.tmc"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc318000.tpiu"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc31c000.replicator"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc307000.tmc"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc31b000.funnel"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc319000.funnel"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc31a000.funnel"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc345000.funnel"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc364000.funnel"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc321000.stm"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc33c000.etm"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc33d000.etm"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc33e000.etm"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc33f000.etm"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc308000.cti"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc309000.cti"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc30a000.cti"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc30b000.cti"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc30c000.cti"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc30d000.cti"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc30e000.cti"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc30f000.cti"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc310000.cti"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc340000.cti"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc341000.cti"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc342000.cti"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc343000.cti"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc344000.cti"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc348000.cti"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc34d000.cti"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc350000.cti"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc354000.cti"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fc358000.cti"),
+	CLK_LOOKUP("core_clk", qdss_clk.c, "fdf30018.hwevent"),
+
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc322000.tmc"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc318000.tpiu"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc31c000.replicator"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc307000.tmc"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc31b000.funnel"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc319000.funnel"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc31a000.funnel"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc345000.funnel"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc364000.funnel"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc321000.stm"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc33c000.etm"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc33d000.etm"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc33e000.etm"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc33f000.etm"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc308000.cti"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc309000.cti"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc30a000.cti"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc30b000.cti"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc30c000.cti"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc30d000.cti"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc30e000.cti"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc30f000.cti"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc310000.cti"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc340000.cti"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc341000.cti"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc342000.cti"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc343000.cti"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc344000.cti"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc348000.cti"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc34d000.cti"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc350000.cti"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc354000.cti"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fc358000.cti"),
+	CLK_LOOKUP("core_a_clk", qdss_a_clk.c, "fdf30018.hwevent"),
+
+	CLK_LOOKUP("core_mmss_clk", mmss_misc_ahb_clk.c, "fdf30018.hwevent"),
+
+	CLK_LOOKUP("l2_m_clk",		l2_m_clk,     ""),
+	CLK_LOOKUP("krait0_m_clk",	krait0_m_clk, ""),
+	CLK_LOOKUP("krait1_m_clk",	krait1_m_clk, ""),
+	CLK_LOOKUP("krait2_m_clk",	krait2_m_clk, ""),
+	CLK_LOOKUP("krait3_m_clk",	krait3_m_clk, ""),
+
+	/* DSI PLL clocks */
+	CLK_LOOKUP("",		dsi_vco_clk_8974.c,                  ""),
+	CLK_LOOKUP("",		analog_postdiv_clk_8974.c,         ""),
+	CLK_LOOKUP("",		indirect_path_div2_clk_8974.c,     ""),
+	CLK_LOOKUP("",		pixel_clk_src_8974.c,              ""),
+	CLK_LOOKUP("",		byte_mux_8974.c,                   ""),
+	CLK_LOOKUP("",		byte_clk_src_8974.c,               ""),
+};
+
+static struct clk_lookup msm_clocks_8974[ARRAY_SIZE(msm_clocks_8974_common)
+	+ ARRAY_SIZE(msm_clocks_8974_only)
+	+ ARRAY_SIZE(msm_clocks_8974pro_only)];
+
+static struct pll_config_regs mmpll0_regs __initdata = {
+	.l_reg = (void __iomem *)MMPLL0_L_REG,
+	.m_reg = (void __iomem *)MMPLL0_M_REG,
+	.n_reg = (void __iomem *)MMPLL0_N_REG,
+	.config_reg = (void __iomem *)MMPLL0_USER_CTL_REG,
+	.mode_reg = (void __iomem *)MMPLL0_MODE_REG,
+	.base = &virt_bases[MMSS_BASE],
+};
+
+/* MMPLL0 at 800 MHz, main output enabled. */
+static struct pll_config mmpll0_config __initdata = {
+	.l = 0x29,
+	.m = 0x2,
+	.n = 0x3,
+	.vco_val = 0x0,
+	.vco_mask = BM(21, 20),
+	.pre_div_val = 0x0,
+	.pre_div_mask = BM(14, 12),
+	.post_div_val = 0x0,
+	.post_div_mask = BM(9, 8),
+	.mn_ena_val = BIT(24),
+	.mn_ena_mask = BIT(24),
+	.main_output_val = BIT(0),
+	.main_output_mask = BIT(0),
+};
+
+static struct pll_config_regs mmpll1_regs __initdata = {
+	.l_reg = (void __iomem *)MMPLL1_L_REG,
+	.m_reg = (void __iomem *)MMPLL1_M_REG,
+	.n_reg = (void __iomem *)MMPLL1_N_REG,
+	.config_reg = (void __iomem *)MMPLL1_USER_CTL_REG,
+	.mode_reg = (void __iomem *)MMPLL1_MODE_REG,
+	.base = &virt_bases[MMSS_BASE],
+};
+
+/* MMPLL1 at 846 MHz, main output enabled. */
+static struct pll_config mmpll1_config __initdata = {
+	.l = 0x2C,
+	.m = 0x1,
+	.n = 0x10,
+	.vco_val = 0x0,
+	.vco_mask = BM(21, 20),
+	.pre_div_val = 0x0,
+	.pre_div_mask = BM(14, 12),
+	.post_div_val = 0x0,
+	.post_div_mask = BM(9, 8),
+	.mn_ena_val = BIT(24),
+	.mn_ena_mask = BIT(24),
+	.main_output_val = BIT(0),
+	.main_output_mask = BIT(0),
+};
+
+/* MMPLL1 at 1167 MHz, main output enabled. */
+static struct pll_config mmpll1_v2_config __initdata = {
+	.l = 60,
+	.m = 25,
+	.n = 32,
+	.vco_val = 0x0,
+	.vco_mask = BM(21, 20),
+	.pre_div_val = 0x0,
+	.pre_div_mask = BM(14, 12),
+	.post_div_val = 0x0,
+	.post_div_mask = BM(9, 8),
+	.mn_ena_val = BIT(24),
+	.mn_ena_mask = BIT(24),
+	.main_output_val = BIT(0),
+	.main_output_mask = BIT(0),
+};
+
+static struct pll_config_regs mmpll3_regs __initdata = {
+	.l_reg = (void __iomem *)MMPLL3_L_REG,
+	.m_reg = (void __iomem *)MMPLL3_M_REG,
+	.n_reg = (void __iomem *)MMPLL3_N_REG,
+	.config_reg = (void __iomem *)MMPLL3_USER_CTL_REG,
+	.mode_reg = (void __iomem *)MMPLL3_MODE_REG,
+	.base = &virt_bases[MMSS_BASE],
+};
+
+/* MMPLL3 at 820 MHz, main output enabled. */
+static struct pll_config mmpll3_config __initdata = {
+	.l = 0x2A,
+	.m = 0x11,
+	.n = 0x18,
+	.vco_val = 0x0,
+	.vco_mask = BM(21, 20),
+	.pre_div_val = 0x0,
+	.pre_div_mask = BM(14, 12),
+	.post_div_val = 0x0,
+	.post_div_mask = BM(9, 8),
+	.mn_ena_val = BIT(24),
+	.mn_ena_mask = BIT(24),
+	.main_output_val = BIT(0),
+	.main_output_mask = BIT(0),
+};
+
+/* MMPLL3 at 930 MHz, main output enabled. */
+static struct pll_config mmpll3_v2_config __initdata = {
+	.l = 48,
+	.m = 7,
+	.n = 16,
+	.vco_val = 0x0,
+	.vco_mask = BM(21, 20),
+	.pre_div_val = 0x0,
+	.pre_div_mask = BM(14, 12),
+	.post_div_val = 0x0,
+	.post_div_mask = BM(9, 8),
+	.mn_ena_val = BIT(24),
+	.mn_ena_mask = BIT(24),
+	.main_output_val = BIT(0),
+	.main_output_mask = BIT(0),
+	.aux_output_val = BIT(1),
+	.aux_output_mask = BIT(1),
+};
+
+#define cpu_is_msm8974pro() (cpu_is_msm8974pro_aa() || cpu_is_msm8974pro_ab() \
+			     || cpu_is_msm8974pro_ac())
+
+static void __init reg_init(void)
+{
+	u32 regval;
+
+	configure_sr_hpm_lp_pll(&mmpll0_config, &mmpll0_regs, 1);
+
+	if (SOCINFO_VERSION_MAJOR(socinfo_get_version()) == 2
+	    || cpu_is_msm8974pro()) {
+		configure_sr_hpm_lp_pll(&mmpll1_v2_config, &mmpll1_regs, 1);
+		configure_sr_hpm_lp_pll(&mmpll3_v2_config, &mmpll3_regs, 0);
+	} else {
+		configure_sr_hpm_lp_pll(&mmpll1_config, &mmpll1_regs, 1);
+		configure_sr_hpm_lp_pll(&mmpll3_config, &mmpll3_regs, 0);
+	}
+
+	/* Vote for GPLL0 to turn on. Needed by acpuclock. */
+	regval = readl_relaxed(GCC_REG_BASE(APCS_GPLL_ENA_VOTE_REG));
+	regval |= BIT(0);
+	writel_relaxed(regval, GCC_REG_BASE(APCS_GPLL_ENA_VOTE_REG));
+
+	/*
+	 * V2 requires additional votes to allow the LPASS and MMSS
+	 * controllers to use GPLL0.
+	 */
+	if (SOCINFO_VERSION_MAJOR(socinfo_get_version()) == 2
+	    || cpu_is_msm8974pro()) {
+		regval = readl_relaxed(
+				GCC_REG_BASE(APCS_CLOCK_BRANCH_ENA_VOTE));
+		writel_relaxed(regval | BIT(26) | BIT(25),
+				GCC_REG_BASE(APCS_CLOCK_BRANCH_ENA_VOTE));
+	}
+}
+
+static void __init msm8974_clock_post_init(void)
+{
+	if (SOCINFO_VERSION_MAJOR(socinfo_get_version()) == 2
+	    || cpu_is_msm8974pro()) {
+		clk_set_rate(&axi_clk_src.c, 291750000);
+		clk_set_rate(&ocmemnoc_clk_src.c, 291750000);
+	} else {
+		clk_set_rate(&axi_clk_src.c, 282000000);
+		clk_set_rate(&ocmemnoc_clk_src.c, 282000000);
+	}
+
+	/*
+	 * Hold an active set vote at a rate of 40MHz for the MMSS NOC AHB
+	 * source. Sleep set vote is 0.
+	 */
+	clk_set_rate(&mmssnoc_ahb_a_clk.c, 40000000);
+	clk_prepare_enable(&mmssnoc_ahb_a_clk.c);
+
+	/*
+	 * Hold an active set vote for the PNOC AHB source. Sleep set vote is 0.
+	 */
+	clk_set_rate(&pnoc_keepalive_a_clk.c, 19200000);
+	clk_prepare_enable(&pnoc_keepalive_a_clk.c);
+
+	/*
+	 * Hold an active set vote for CXO; this is because CXO is expected
+	 * to remain on whenever CPUs aren't power collapsed.
+	 */
+	clk_prepare_enable(&cxo_a_clk_src.c);
+
+	/*
+	 * TODO: Temporarily enable NOC configuration AHB clocks. Remove when
+	 * the bus driver is ready.
+	 */
+	clk_prepare_enable(&gcc_mmss_noc_cfg_ahb_clk.c);
+	clk_prepare_enable(&gcc_ocmem_noc_cfg_ahb_clk.c);
+
+	/* Set rates for single-rate clocks. */
+	clk_set_rate(&usb30_master_clk_src.c,
+			usb30_master_clk_src.freq_tbl[0].freq_hz);
+	clk_set_rate(&tsif_ref_clk_src.c,
+			tsif_ref_clk_src.freq_tbl[0].freq_hz);
+	clk_set_rate(&usb_hs_system_clk_src.c,
+			usb_hs_system_clk_src.freq_tbl[0].freq_hz);
+	clk_set_rate(&usb_hsic_clk_src.c,
+			usb_hsic_clk_src.freq_tbl[0].freq_hz);
+	clk_set_rate(&usb_hsic_io_cal_clk_src.c,
+			usb_hsic_io_cal_clk_src.freq_tbl[0].freq_hz);
+	clk_set_rate(&usb_hsic_system_clk_src.c,
+			usb_hsic_system_clk_src.freq_tbl[0].freq_hz);
+	clk_set_rate(&usb30_mock_utmi_clk_src.c,
+			usb30_mock_utmi_clk_src.freq_tbl[0].freq_hz);
+	clk_set_rate(&pdm2_clk_src.c, pdm2_clk_src.freq_tbl[0].freq_hz);
+	clk_set_rate(&cci_clk_src.c, cci_clk_src.freq_tbl[0].freq_hz);
+	clk_set_rate(&mclk0_clk_src.c, mclk0_clk_src.freq_tbl[0].freq_hz);
+	clk_set_rate(&mclk1_clk_src.c, mclk1_clk_src.freq_tbl[0].freq_hz);
+	clk_set_rate(&mclk2_clk_src.c, mclk2_clk_src.freq_tbl[0].freq_hz);
+	clk_set_rate(&edpaux_clk_src.c, edpaux_clk_src.freq_tbl[0].freq_hz);
+	clk_set_rate(&esc0_clk_src.c, esc0_clk_src.freq_tbl[0].freq_hz);
+	clk_set_rate(&esc1_clk_src.c, esc1_clk_src.freq_tbl[0].freq_hz);
+	clk_set_rate(&hdmi_clk_src.c, hdmi_clk_src.freq_tbl[0].freq_hz);
+	clk_set_rate(&vsync_clk_src.c, vsync_clk_src.freq_tbl[0].freq_hz);
+}
+
+#define GCC_CC_PHYS		0xFC400000
+#define GCC_CC_SIZE		SZ_16K
+
+#define MMSS_CC_PHYS		0xFD8C0000
+#define MMSS_CC_SIZE		SZ_256K
+
+#define LPASS_CC_PHYS		0xFE000000
+#define LPASS_CC_SIZE		SZ_256K
+
+#define APCS_GCC_CC_PHYS	0xF9011000
+#define APCS_GCC_CC_SIZE	SZ_4K
+
+static struct clk *qup_i2c_clks[][2] __initdata = {
+	{&gcc_blsp1_qup1_i2c_apps_clk.c, &blsp1_qup1_i2c_apps_clk_src.c,},
+	{&gcc_blsp1_qup2_i2c_apps_clk.c, &blsp1_qup2_i2c_apps_clk_src.c,},
+	{&gcc_blsp1_qup3_i2c_apps_clk.c, &blsp1_qup3_i2c_apps_clk_src.c,},
+	{&gcc_blsp1_qup4_i2c_apps_clk.c, &blsp1_qup4_i2c_apps_clk_src.c,},
+	{&gcc_blsp1_qup5_i2c_apps_clk.c, &blsp1_qup5_i2c_apps_clk_src.c,},
+	{&gcc_blsp1_qup6_i2c_apps_clk.c, &blsp1_qup6_i2c_apps_clk_src.c,},
+	{&gcc_blsp2_qup1_i2c_apps_clk.c, &blsp2_qup1_i2c_apps_clk_src.c,},
+	{&gcc_blsp2_qup2_i2c_apps_clk.c, &blsp2_qup2_i2c_apps_clk_src.c,},
+	{&gcc_blsp2_qup3_i2c_apps_clk.c, &blsp2_qup3_i2c_apps_clk_src.c,},
+	{&gcc_blsp2_qup4_i2c_apps_clk.c, &blsp2_qup4_i2c_apps_clk_src.c,},
+	{&gcc_blsp2_qup5_i2c_apps_clk.c, &blsp2_qup5_i2c_apps_clk_src.c,},
+	{&gcc_blsp2_qup6_i2c_apps_clk.c, &blsp2_qup6_i2c_apps_clk_src.c,},
+};
+
+/* v1 to v2 clock changes */
+static void __init msm8974_v2_clock_override(void)
+{
+	int i;
+
+	mmpll3_clk_src.c.rate =  930000000;
+	mmpll1_clk_src.c.rate = 1167000000;
+	mmpll1_clk_src.c.fmax[VDD_DIG_NOMINAL] = 1167000000;
+
+	ocmemnoc_clk_src.freq_tbl = ftbl_ocmemnoc_v2_clk;
+	ocmemnoc_clk_src.c.fmax[VDD_DIG_NOMINAL] = 291750000;
+
+	axi_clk_src.freq_tbl = ftbl_mmss_axi_v2_clk;
+	axi_clk_src.c.fmax[VDD_DIG_NOMINAL] = 291750000;
+	axi_clk_src.c.fmax[VDD_DIG_HIGH] = 466800000;
+
+	vcodec0_clk_src.freq_tbl = ftbl_venus0_vcodec0_v2_clk;
+	vcodec0_clk_src.c.fmax[VDD_DIG_HIGH] = 465000000;
+
+	mdp_clk_src.c.fmax[VDD_DIG_NOMINAL] = 240000000;
+
+	/* The parent of each of the QUP I2C clocks is an RCG on V2 */
+	for (i = 0; i < ARRAY_SIZE(qup_i2c_clks); i++)
+		qup_i2c_clks[i][0]->parent =  qup_i2c_clks[i][1];
+}
+
+/* v2 to pro clock changes */
+static void __init msm8974_pro_clock_override(void)
+{
+	ce1_clk_src.c.fmax[VDD_DIG_LOW] = 75000000;
+	ce1_clk_src.c.fmax[VDD_DIG_NOMINAL] = 150000000;
+	ce1_clk_src.freq_tbl = ftbl_gcc_ce1_pro_clk;
+	ce2_clk_src.c.fmax[VDD_DIG_LOW] = 75000000;
+	ce2_clk_src.c.fmax[VDD_DIG_NOMINAL] = 150000000;
+	ce2_clk_src.freq_tbl = ftbl_gcc_ce2_pro_clk;
+
+	sdcc1_apps_clk_src.c.fmax[VDD_DIG_LOW] = 200000000;
+	sdcc1_apps_clk_src.c.fmax[VDD_DIG_NOMINAL] = 400000000;
+	sdcc1_apps_clk_src.freq_tbl = ftbl_gcc_sdcc1_apps_clk_ac;
+
+	vfe0_clk_src.c.fmax[VDD_DIG_LOW] = 150000000;
+	vfe0_clk_src.c.fmax[VDD_DIG_NOMINAL] = 320000000;
+	vfe1_clk_src.c.fmax[VDD_DIG_LOW] = 150000000;
+	vfe1_clk_src.c.fmax[VDD_DIG_NOMINAL] = 320000000;
+	cpp_clk_src.c.fmax[VDD_DIG_LOW] = 150000000;
+	cpp_clk_src.c.fmax[VDD_DIG_NOMINAL] = 320000000;
+
+	if (cpu_is_msm8974pro_ab() || cpu_is_msm8974pro_ac()) {
+		vfe0_clk_src.c.fmax[VDD_DIG_HIGH] = 465000000;
+		vfe1_clk_src.c.fmax[VDD_DIG_HIGH] = 465000000;
+		cpp_clk_src.c.fmax[VDD_DIG_HIGH] = 465000000;
+	} else if (cpu_is_msm8974pro_aa()) {
+		vfe0_clk_src.c.fmax[VDD_DIG_HIGH] = 320000000;
+		vfe1_clk_src.c.fmax[VDD_DIG_HIGH] = 320000000;
+		cpp_clk_src.c.fmax[VDD_DIG_HIGH] = 320000000;
+	}
+
+	mdp_clk_src.c.fmax[VDD_DIG_NOMINAL] = 266670000;
+
+	mclk0_clk_src.freq_tbl = ftbl_camss_mclk0_3_pro_clk;
+	mclk1_clk_src.freq_tbl = ftbl_camss_mclk0_3_pro_clk;
+	mclk2_clk_src.freq_tbl = ftbl_camss_mclk0_3_pro_clk;
+	mclk3_clk_src.freq_tbl = ftbl_camss_mclk0_3_pro_clk;
+	mclk0_clk_src.set_rate = set_rate_mnd;
+	mclk1_clk_src.set_rate = set_rate_mnd;
+	mclk2_clk_src.set_rate = set_rate_mnd;
+	mclk3_clk_src.set_rate = set_rate_mnd;
+	mclk0_clk_src.c.ops = &clk_ops_rcg_mnd;
+	mclk1_clk_src.c.ops = &clk_ops_rcg_mnd;
+	mclk2_clk_src.c.ops = &clk_ops_rcg_mnd;
+	mclk3_clk_src.c.ops = &clk_ops_rcg_mnd;
+}
+
+static void __init msm8974_clock_pre_init(void)
+{
+	virt_bases[GCC_BASE] = ioremap(GCC_CC_PHYS, GCC_CC_SIZE);
+	if (!virt_bases[GCC_BASE])
+		panic("clock-8974: Unable to ioremap GCC memory!");
+
+	virt_bases[MMSS_BASE] = ioremap(MMSS_CC_PHYS, MMSS_CC_SIZE);
+	if (!virt_bases[MMSS_BASE])
+		panic("clock-8974: Unable to ioremap MMSS_CC memory!");
+
+	virt_bases[LPASS_BASE] = ioremap(LPASS_CC_PHYS, LPASS_CC_SIZE);
+	if (!virt_bases[LPASS_BASE])
+		panic("clock-8974: Unable to ioremap LPASS_CC memory!");
+
+	virt_bases[APCS_BASE] = ioremap(APCS_GCC_CC_PHYS, APCS_GCC_CC_SIZE);
+	if (!virt_bases[APCS_BASE])
+		panic("clock-8974: Unable to ioremap APCS_GCC_CC memory!");
+
+	clk_ops_local_pll.enable = sr_hpm_lp_pll_clk_enable;
+
+	vdd_dig.regulator[0] = regulator_get(NULL, "vdd_dig");
+	if (IS_ERR(vdd_dig.regulator[0]))
+		panic("clock-8974: Unable to get the vdd_dig regulator!");
+
+	enable_rpm_scaling();
+
+	reg_init();
+
+	memcpy(msm_clocks_8974, msm_clocks_8974_common,
+	       sizeof(msm_clocks_8974_common));
+
+	/* version specific clock changes */
+	if (SOCINFO_VERSION_MAJOR(socinfo_get_version()) >= 2
+	    || cpu_is_msm8974pro())
+		msm8974_v2_clock_override();
+	if (cpu_is_msm8974pro())
+		msm8974_pro_clock_override();
+
+	/* version specific lookup table changes */
+	if (cpu_is_msm8974()) {
+		memcpy(msm_clocks_8974 + ARRAY_SIZE(msm_clocks_8974_common),
+		       msm_clocks_8974_only, sizeof(msm_clocks_8974_only));
+		msm8974_clock_init_data.size +=
+			ARRAY_SIZE(msm_clocks_8974_only);
+	} else if (cpu_is_msm8974pro()) {
+		memcpy(msm_clocks_8974 + ARRAY_SIZE(msm_clocks_8974_common),
+		       msm_clocks_8974pro_only,
+		       sizeof(msm_clocks_8974pro_only));
+		msm8974_clock_init_data.size +=
+			ARRAY_SIZE(msm_clocks_8974pro_only);
+	}
+
+	clk_ops_pixel_clock = clk_ops_pixel;
+	clk_ops_pixel_clock.set_rate = set_rate_pixel;
+	clk_ops_pixel_clock.round_rate = round_rate_pixel;
+
+	/*
+	 * MDSS needs the ahb clock and needs to init before we register the
+	 * lookup table.
+	 */
+	mdss_clk_ctrl_pre_init(&mdss_ahb_clk.c);
+}
+
+static void __init msm8974_rumi_clock_pre_init(void)
+{
+	virt_bases[GCC_BASE] = ioremap(GCC_CC_PHYS, GCC_CC_SIZE);
+	if (!virt_bases[GCC_BASE])
+		panic("clock-8974: Unable to ioremap GCC memory!");
+
+	/* SDCC clocks are partially emulated in the RUMI */
+	sdcc1_apps_clk_src.freq_tbl = ftbl_gcc_sdcc_apps_rumi_clk;
+	sdcc2_apps_clk_src.freq_tbl = ftbl_gcc_sdcc_apps_rumi_clk;
+	sdcc3_apps_clk_src.freq_tbl = ftbl_gcc_sdcc_apps_rumi_clk;
+	sdcc4_apps_clk_src.freq_tbl = ftbl_gcc_sdcc_apps_rumi_clk;
+
+	vdd_dig.regulator[0] = regulator_get(NULL, "vdd_dig");
+	if (IS_ERR(vdd_dig.regulator[0]))
+		panic("clock-8974: Unable to get the vdd_dig regulator!");
+}
+
+struct clock_init_data msm8974_clock_init_data __initdata = {
+	.table = msm_clocks_8974,
+	.size = ARRAY_SIZE(msm_clocks_8974_common),
+	.pre_init = msm8974_clock_pre_init,
+	.post_init = msm8974_clock_post_init,
+};
+
+struct clock_init_data msm8974_rumi_clock_init_data __initdata = {
+	.table = msm_clocks_8974_rumi,
+	.size = ARRAY_SIZE(msm_clocks_8974_rumi),
+	.pre_init = msm8974_rumi_clock_pre_init,
+};
diff --git a/arch/arm/mach-msm/clock-debug.c b/arch/arm/mach-msm/clock-debug.c
old mode 100644
new mode 100755
index c3b7229..a009f52
--- a/arch/arm/mach-msm/clock-debug.c
+++ b/arch/arm/mach-msm/clock-debug.c
@@ -33,7 +33,11 @@ static LIST_HEAD(clk_list);
 static DEFINE_SPINLOCK(clk_list_lock);
 
 static struct dentry *debugfs_base;
+#ifdef CONFIG_ZTEMT_POWER_DEBUG
+static u32 debug_suspend = 1;
+#else
 static u32 debug_suspend;
+#endif
 
 struct clk_table {
 	struct list_head node;
diff --git a/arch/arm/mach-msm/include/mach/restart.h b/arch/arm/mach-msm/include/mach/restart.h
old mode 100644
new mode 100755
index 84bb91d..f502944
--- a/arch/arm/mach-msm/include/mach/restart.h
+++ b/arch/arm/mach-msm/include/mach/restart.h
@@ -26,6 +26,9 @@ void fsm_restart(char mode, const char *cmd);
 #define msm_set_restart_mode(mode)
 #endif
 
+#ifdef CONFIG_ZTE_POWEROFF_ALARM
+extern void *restart_reason;
+#endif
 extern int pmic_reset_irq;
 
 #endif
diff --git a/arch/arm/mach-msm/restart.c b/arch/arm/mach-msm/restart.c
old mode 100644
new mode 100755
index a96b02f..67c9dc5
--- a/arch/arm/mach-msm/restart.c
+++ b/arch/arm/mach-msm/restart.c
@@ -98,12 +98,12 @@ static void set_dload_mode(int on)
 		dload_mode_enabled = on;
 	}
 }
-
+#ifndef CONFIG_ZTEMT_RESTART
 static bool get_dload_mode(void)
 {
 	return dload_mode_enabled;
 }
-
+#endif
 static void enable_emergency_dload_mode(void)
 {
 	if (emergency_dload_mode_addr) {
@@ -258,6 +258,15 @@ static void msm_restart_prepare(const char *cmd)
 	/* Write download mode flags if we're panic'ing */
 	set_dload_mode(in_panic);
 
+#ifdef CONFIG_ZTEMT_RESTART
+        /* Judge restart_mode after download_mode, when device reset,
+         the diag cannot make the device enter download mode. */
+	if (!download_mode)
+		set_dload_mode(0);
+
+	if (restart_mode == RESTART_DLOAD)
+		set_dload_mode(1);
+#else
 	/* Write download mode flags if restart_mode says so */
 	if (restart_mode == RESTART_DLOAD)
 		set_dload_mode(1);
@@ -266,14 +275,20 @@ static void msm_restart_prepare(const char *cmd)
 	if (!download_mode)
 		set_dload_mode(0);
 #endif
+#endif
 
 	pm8xxx_reset_pwr_off(1);
 
+#ifdef CONFIG_ZTEMT_RESTART
+	/* for menu reboot, the cmd is NULL, warm reset for restart reason. */
+	qpnp_pon_system_pwr_off(PON_POWER_OFF_WARM_RESET);
+#else
 	/* Hard reset the PMIC unless memory contents must be maintained. */
 	if (get_dload_mode() || (cmd != NULL && cmd[0] != '\0'))
 		qpnp_pon_system_pwr_off(PON_POWER_OFF_WARM_RESET);
 	else
 		qpnp_pon_system_pwr_off(PON_POWER_OFF_HARD_RESET);
+#endif
 
 	if (cmd != NULL) {
 		if (!strncmp(cmd, "bootloader", 10)) {
@@ -292,6 +307,12 @@ static void msm_restart_prepare(const char *cmd)
 			__raw_writel(0x77665501, restart_reason);
 		}
 	}
+#ifdef CONFIG_ZTEMT_RESTART
+	/* for menu reboot, the cmd is NULL, default 0x77665501. */
+	else {
+		__raw_writel(0x77665501, restart_reason);
+	}
+#endif
 
 	flush_cache_all();
 	outer_flush_all();
diff --git a/arch/sh/boot/compressed/vmlinux.scr b/arch/sh/boot/compressed/vmlinux.scr
deleted file mode 100644
index 862d748..0000000
--- a/arch/sh/boot/compressed/vmlinux.scr
+++ /dev/null
@@ -1,10 +0,0 @@
-SECTIONS
-{
-  .rodata..compressed : {
-	input_len = .;
-	LONG(input_data_end - input_data) input_data = .;
-	*(.data)
-	output_len = . - 4;
-	input_data_end = .;
-	}
-}
diff --git a/arch/sh/boot/romimage/vmlinux.scr b/arch/sh/boot/romimage/vmlinux.scr
deleted file mode 100644
index 590394e..0000000
--- a/arch/sh/boot/romimage/vmlinux.scr
+++ /dev/null
@@ -1,8 +0,0 @@
-SECTIONS
-{
-  .text : {
-	zero_page_pos = .;
-	*(.data)
-	end_data = .;
-	}
-}
diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index cbb463b..3309346 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -23,7 +23,9 @@
  * if wakeup events are registered during or immediately before the transition.
  */
 bool events_check_enabled __read_mostly;
-
+#ifdef CONFIG_ZTEMT_POWER_DEBUG
+extern bool wakeup_wake_lock_debug;
+#endif
 /*
  * Combined counters of registered wakeup events and wakeup events in progress.
  * They need to be modified together atomically, so it's better to use one
@@ -400,7 +402,12 @@ static void wakeup_source_report_event(struct wakeup_source *ws)
 	/* This is racy, but the counter is approximate anyway. */
 	if (events_check_enabled)
 		ws->wakeup_count++;
-
+	#ifdef CONFIG_ZTEMT_POWER_DEBUG
+	if (wakeup_wake_lock_debug){
+	  wakeup_wake_lock_debug = false;
+	  printk("First wakeup lock:%s\n", ws->name);
+	}
+	#endif
 	if (!ws->active)
 		wakeup_source_activate(ws);
 }
@@ -765,6 +772,31 @@ void pm_wakep_autosleep_enabled(bool set)
 
 static struct dentry *wakeup_sources_stats_dentry;
 
+#ifdef CONFIG_ZTEMT_POWER_DEBUG
+void global_print_active_locks_debug(struct wakeup_source *ws)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ws->lock, flags);
+
+	if (ws->active) {
+		printk("active wake lock %s\n", ws->name);
+	} 
+	spin_unlock_irqrestore(&ws->lock, flags);
+}
+
+void global_print_active_locks(void *unused)
+{
+	struct wakeup_source *ws;
+  
+	rcu_read_lock();
+	list_for_each_entry_rcu(ws, &wakeup_sources, entry)
+		global_print_active_locks_debug(ws);
+	rcu_read_unlock();
+
+}
+
+#endif
 /**
  * print_wakeup_source_stats - Print wakeup source statistics information.
  * @m: seq_file to print the statistics into.
diff --git a/drivers/bluetooth/bluesleep.c b/drivers/bluetooth/bluesleep.c
old mode 100644
new mode 100755
index 6dc9862..9f2ad21
--- a/drivers/bluetooth/bluesleep.c
+++ b/drivers/bluetooth/bluesleep.c
@@ -1,5 +1,4 @@
 /*
-
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 2 as
    published by the Free Software Foundation.
@@ -13,7 +12,6 @@
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
 
-
    Copyright (C) 2006-2007 - Motorola
    Copyright (c) 2008-2010, The Linux Foundation. All rights reserved.
 
@@ -41,20 +39,32 @@
 #include <linux/platform_device.h>
 
 #include <linux/irq.h>
+#include <linux/ioport.h>
 #include <linux/param.h>
 #include <linux/bitops.h>
 #include <linux/termios.h>
+#include <linux/wakelock.h>
 #include <mach/gpio.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+
 #include <mach/msm_serial_hs.h>
+#include <linux/serial_core.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h> /* event notifications */
 #include "hci_uart.h"
 
-#define BT_SLEEP_DBG
+//#define BT_SLEEP_DBG
 #ifndef BT_SLEEP_DBG
-#define BT_DBG(fmt, arg...)
+//#define BT_DBG(fmt, arg...)
+//#else
+//#define BT_DBG(fmt, arg...)  printk("%s: " fmt "\n" , __func__, ## arg)
 #endif
+ 
+#define BT_ERR(fmt, arg...)  printk(KERN_ERR "%s: " fmt "\n" , __func__ , ## arg)
+
+
 /*
  * Defines
  */
@@ -62,11 +72,22 @@
 #define VERSION		"1.1"
 #define PROC_DIR	"bluetooth/sleep"
 
+#define POLARITY_LOW 0
+#define POLARITY_HIGH 1
+
+/* enable/disable wake-on-bluetooth */
+#define BT_ENABLE_IRQ_WAKE 1
+
+#define BT_BLUEDROID_SUPPORT 1
+
 struct bluesleep_info {
-	unsigned host_wake;
-	unsigned ext_wake;
-	unsigned host_wake_irq;
-	struct uart_port *uport;
+    unsigned host_wake;
+    unsigned ext_wake;
+    unsigned host_wake_irq;
+    struct uart_port *uport;
+    struct wake_lock wake_lock;
+    int irq_polarity;
+    int has_ext_wake;
 };
 
 /* work function */
@@ -82,16 +103,23 @@ DECLARE_DELAYED_WORK(sleep_workqueue, bluesleep_sleep_work);
 #define bluesleep_tx_idle()     schedule_delayed_work(&sleep_workqueue, 0)
 
 /* 1 second timeout */
-#define TX_TIMER_INTERVAL	1
+#define TX_TIMER_INTERVAL  10
 
 /* state variable names and bit positions */
 #define BT_PROTO	0x01
 #define BT_TXDATA	0x02
 #define BT_ASLEEP	0x04
+#define BT_EXT_WAKE     0x08
+#define BT_SUSPEND      0x10
 
+#if BT_BLUEDROID_SUPPORT
+static bool has_lpm_enabled = false;
+#else
 /* global pointer to a single hci device. */
 static struct hci_dev *bluesleep_hdev;
+#endif
 
+static struct platform_device *bluesleep_uart_dev;
 static struct bluesleep_info *bsi;
 
 /* module usage */
@@ -100,14 +128,16 @@ static atomic_t open_count = ATOMIC_INIT(1);
 /*
  * Local function prototypes
  */
-
+#if !BT_BLUEDROID_SUPPORT
 static int bluesleep_hci_event(struct notifier_block *this,
-			    unsigned long event, void *data);
+                        unsigned long event, void *data);
+#endif
+static int bluesleep_start(void);
+static void bluesleep_stop(void);
 
 /*
  * Global variables
  */
-
 /** Global state flags */
 static unsigned long flags;
 
@@ -115,30 +145,36 @@ static unsigned long flags;
 static struct tasklet_struct hostwake_task;
 
 /** Transmission timer */
-static struct timer_list tx_timer;
+    static void bluesleep_tx_timer_expire(unsigned long data);
+    static DEFINE_TIMER(tx_timer, bluesleep_tx_timer_expire, 0, 0);
 
 /** Lock for state transitions */
 static spinlock_t rw_lock;
 
+#if !BT_BLUEDROID_SUPPORT
 /** Notifier block for HCI events */
 struct notifier_block hci_event_nblock = {
 	.notifier_call = bluesleep_hci_event,
 };
+#endif
 
 struct proc_dir_entry *bluetooth_dir, *sleep_dir;
 
 /*
  * Local functions
  */
-
 static void hsuart_power(int on)
 {
+       if (test_bit(BT_SUSPEND, &flags))
+              return;
 	if (on) {
 		msm_hs_request_clock_on(bsi->uport);
 		msm_hs_set_mctrl(bsi->uport, TIOCM_RTS);
+		BT_DBG("uart_power on");
 	} else {
 		msm_hs_set_mctrl(bsi->uport, 0);
 		msm_hs_request_clock_off(bsi->uport);
+		BT_DBG("uart_power off");
 	}
 }
 
@@ -146,25 +182,37 @@ static void hsuart_power(int on)
 /**
  * @return 1 if the Host can go to sleep, 0 otherwise.
  */
-static inline int bluesleep_can_sleep(void)
+int bluesleep_can_sleep(void)
 {
-	/* check if MSM_WAKE_BT_GPIO and BT_WAKE_MSM_GPIO are both deasserted */
-	return gpio_get_value(bsi->ext_wake) &&
-		gpio_get_value(bsi->host_wake) &&
-		(bsi->uport != NULL);
+    BT_DBG("(gpio_get_value(bsi->host_wake) != bsi->irq_polarity is %d,(!test_bit(BT_EXT_WAKE, &flags)) is %d,(bsi->uport != NULL) is %d",
+    gpio_get_value(bsi->host_wake) != bsi->irq_polarity,!test_bit(BT_EXT_WAKE, &flags),bsi->uport != NULL);
+    
+    /* check if MSM_WAKE_BT_GPIO and BT_WAKE_MSM_GPIO are both deasserted */
+    return ((gpio_get_value(bsi->host_wake) != bsi->irq_polarity) &&
+                (!test_bit(BT_EXT_WAKE, &flags)) &&
+                (bsi->uport != NULL));
 }
 
-void bluesleep_sleep_wakeup(void)
+int bluesleep_sleep_wakeup(void)
 {
+	int clk_flag = 0;
+	
 	if (test_bit(BT_ASLEEP, &flags)) {
 		BT_DBG("waking up...");
+             wake_lock(&bsi->wake_lock);
 		/* Start the timer */
 		mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL * HZ));
-		gpio_set_value(bsi->ext_wake, 0);
+        
+             if (bsi->has_ext_wake == 1)
+                   gpio_set_value(bsi->ext_wake, 1);
+             
+             set_bit(BT_EXT_WAKE, &flags);
 		clear_bit(BT_ASLEEP, &flags);
 		/*Activating UART */
-		hsuart_power(1);
+		clk_flag = 1;
 	}
+
+	return clk_flag;
 }
 
 /**
@@ -173,7 +221,9 @@ void bluesleep_sleep_wakeup(void)
  */
 static void bluesleep_sleep_work(struct work_struct *work)
 {
+	int wake_flag = 0;
 	if (bluesleep_can_sleep()) {
+		BT_DBG("bluesleep can sleep");		// added by  yjhuang 2013-08-08
 		/* already asleep, this is an error case */
 		if (test_bit(BT_ASLEEP, &flags)) {
 			BT_DBG("already asleep");
@@ -185,13 +235,29 @@ static void bluesleep_sleep_work(struct work_struct *work)
 			set_bit(BT_ASLEEP, &flags);
 			/*Deactivating UART */
 			hsuart_power(0);
+                    /* UART clk is not turned off immediately. Release
+                     * wakelock after 500 ms.
+                     */
+                    wake_lock_timeout(&bsi->wake_lock, HZ / 2);
 		} else {
-
-		  mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL * HZ));
-			return;
-		}
+                    mod_timer(&tx_timer, jiffies + TX_TIMER_INTERVAL * HZ);
+			 return;
+	      }
+        } 
+        else if (!test_bit(BT_EXT_WAKE, &flags)  && !test_bit(BT_ASLEEP, &flags)) {
+		BT_DBG("== set bt exit wake ==");	// added by yjhuang 2013-08-08
+             mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL * HZ));
+             
+             if (bsi->has_ext_wake == 1)
+                  gpio_set_value(bsi->ext_wake, 1);
+             
+             set_bit(BT_EXT_WAKE, &flags);
 	} else {
-		bluesleep_sleep_wakeup();
+		BT_DBG("== call bluesleep wakeup ==");	// added by yjhuang 2013-08-08
+		wake_flag = bluesleep_sleep_wakeup();
+        
+		if(wake_flag)
+			hsuart_power(1);
 	}
 }
 
@@ -205,45 +271,128 @@ static void bluesleep_hostwake_task(unsigned long data)
 	BT_DBG("hostwake line change");
 
 	spin_lock(&rw_lock);
-
-	if (gpio_get_value(bsi->host_wake))
-		bluesleep_rx_busy();
-	else
-		bluesleep_rx_idle();
-
+    
+        if ((gpio_get_value(bsi->host_wake) == bsi->irq_polarity))
+                bluesleep_rx_busy();
+        else
+                bluesleep_rx_idle();
+        
 	spin_unlock(&rw_lock);
+
 }
 
 /**
  * Handles proper timer action when outgoing data is delivered to the
  * HCI line discipline. Sets BT_TXDATA.
  */
-static void bluesleep_outgoing_data(void)
+static int bluesleep_outgoing_data(void)
 {
 	unsigned long irq_flags;
 
+	int i = 0;
+
 	spin_lock_irqsave(&rw_lock, irq_flags);
+    
+        /* log data passing by */
+        set_bit(BT_TXDATA, &flags);
+        /* if the tx side is sleeping... */
+        if (!test_bit(BT_EXT_WAKE, &flags)) {
+                BT_DBG("tx was sleeping");
+                i = bluesleep_sleep_wakeup();
+        }
+	spin_unlock_irqrestore(&rw_lock, irq_flags);
 
-	/* log data passing by */
-	set_bit(BT_TXDATA, &flags);
+	return i;
+}
 
-	/* if the tx side is sleeping... */
-	if (gpio_get_value(bsi->ext_wake)) {
+#if BT_BLUEDROID_SUPPORT
+/*    static struct uart_port *bluesleep_get_uart_port(void)
+    {
+            struct uart_port *uport = NULL;
+            if (bluesleep_uart_dev)
+                    uport =  (struct uart_port *)platform_get_drvdata(bluesleep_uart_dev);
 
-		BT_DBG("tx was sleeping");
-		bluesleep_sleep_wakeup();
-	}
+            return uport;
+    }
+*/
 
-	spin_unlock_irqrestore(&rw_lock, irq_flags);
+static int bluesleep_read_proc_lpm(char *page, char **start, off_t offset,
+                                        int count, int *eof, void *data)
+{
+        *eof = 1;
+        return sprintf(page, "unsupported to read\n");
+}
+
+static int bluesleep_write_proc_lpm(struct file *file, const char *buffer,
+                                        unsigned long count, void *data)
+{
+        char b;
+
+	BT_DBG("zhanglongbo: bluesleep_write_proc_lpm in");
+
+        if (count < 1)
+                return -EINVAL;
+
+        if (copy_from_user(&b, buffer, 1))
+                return -EFAULT;
+
+	BT_DBG("zhanglongbo: b is %c",b);
+	
+        if (b == '0') {
+                /* HCI_DEV_UNREG */
+                bluesleep_stop();
+                has_lpm_enabled = false;
+                bsi->uport = NULL;
+        } else {
+                /* HCI_DEV_REG */
+                if (!has_lpm_enabled) {
+                        has_lpm_enabled = true;
+
+			//we get uport in bluesleep_start() don't use this
+			//bsi->uport = bluesleep_get_uart_port();
+                        /* if bluetooth started, start bluesleep*/
+                        bluesleep_start();
+                }
+        }
+
+        return count;
 }
 
+static int bluesleep_read_proc_btwrite(char *page, char **start, off_t offset,
+                                        int count, int *eof, void *data)
+{
+        *eof = 1;
+        return sprintf(page, "unsupported to read\n");
+}
+
+static int bluesleep_write_proc_btwrite(struct file *file, const char *buffer,
+                                        unsigned long count, void *data)
+{
+        char b;
+	int wake_flag = 0;
+        if (count < 1)
+                return -EINVAL;
+
+        if (copy_from_user(&b, buffer, 1))
+                return -EFAULT;
+
+        /* HCI_DEV_WRITE */
+        if (b != '0') {
+                wake_flag = bluesleep_outgoing_data();
+		if(wake_flag)
+			hsuart_power(1);
+        }
+
+        return count;
+}
+#else
 /**
- * Handles HCI device events.
- * @param this Not used.
- * @param event The event that occurred.
- * @param data The HCI device associated with the event.
- * @return <code>NOTIFY_DONE</code>.
- */
+* Handles HCI device events.
+* @param this Not used.
+* @param event The event that occurred.
+* @param data The HCI device associated with the event.
+* @return <code>NOTIFY_DONE</code>.
+*/
 static int bluesleep_hci_event(struct notifier_block *this,
 				unsigned long event, void *data)
 {
@@ -261,12 +410,16 @@ static int bluesleep_hci_event(struct notifier_block *this,
 			hu  = (struct hci_uart *) hdev->driver_data;
 			state = (struct uart_state *) hu->tty->driver_data;
 			bsi->uport = state->uart_port;
+                    /* if bluetooth started, start bluesleep*/
+                    bluesleep_start();
 		}
 		break;
 	case HCI_DEV_UNREG:
+            bluesleep_stop();
 		bluesleep_hdev = NULL;
 		bsi->uport = NULL;
-		break;
+            /* if bluetooth stopped, stop bluesleep also */
+            break;
 	case HCI_DEV_WRITE:
 		bluesleep_outgoing_data();
 		break;
@@ -274,6 +427,7 @@ static int bluesleep_hci_event(struct notifier_block *this,
 
 	return NOTIFY_DONE;
 }
+#endif
 
 /**
  * Handles transmission timer expiration.
@@ -281,16 +435,18 @@ static int bluesleep_hci_event(struct notifier_block *this,
  */
 static void bluesleep_tx_timer_expire(unsigned long data)
 {
-	unsigned long irq_flags;
+    unsigned long irq_flags;
 
-	spin_lock_irqsave(&rw_lock, irq_flags);
+    BT_DBG("Tx timer expired");
 
-	BT_DBG("Tx timer expired");
+    spin_lock_irqsave(&rw_lock, irq_flags);
 
 	/* were we silent during the last timeout? */
 	if (!test_bit(BT_TXDATA, &flags)) {
 		BT_DBG("Tx has been idle");
-		gpio_set_value(bsi->ext_wake, 1);
+            if (bsi->has_ext_wake == 1)
+                    gpio_set_value(bsi->ext_wake, 0);
+            clear_bit(BT_EXT_WAKE, &flags);
 		bluesleep_tx_idle();
 	} else {
 		BT_DBG("Tx data during last period");
@@ -327,12 +483,20 @@ static int bluesleep_start(void)
 	unsigned long irq_flags;
 
 	spin_lock_irqsave(&rw_lock, irq_flags);
-
+	
+	/*bt sleep get uart port start*/
+	bsi->uport = msm_hs_get_uart_port(1);
+	if(bsi->uport == NULL){
+		BT_ERR("get bt sleep uart port error");
+		return -1;
+	} else
+		BT_ERR("get bt sleep uart port success");
+	/*bt sleep get uart port end*/
+	
 	if (test_bit(BT_PROTO, &flags)) {
 		spin_unlock_irqrestore(&rw_lock, irq_flags);
 		return 0;
 	}
-
 	spin_unlock_irqrestore(&rw_lock, irq_flags);
 
 	if (!atomic_dec_and_test(&open_count)) {
@@ -341,27 +505,23 @@ static int bluesleep_start(void)
 	}
 
 	/* start the timer */
-
 	mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL*HZ));
 
 	/* assert BT_WAKE */
-	gpio_set_value(bsi->ext_wake, 0);
-	retval = request_irq(bsi->host_wake_irq, bluesleep_hostwake_isr,
-				IRQF_DISABLED | IRQF_TRIGGER_FALLING,
-				"bluetooth hostwake", NULL);
-	if (retval  < 0) {
-		BT_ERR("Couldn't acquire BT_HOST_WAKE IRQ");
-		goto fail;
-	}
-
+        if (bsi->has_ext_wake == 1)
+            gpio_set_value(bsi->ext_wake, 1);
+        
+        set_bit(BT_EXT_WAKE, &flags);
+    #if BT_ENABLE_IRQ_WAKE
 	retval = enable_irq_wake(bsi->host_wake_irq);
 	if (retval < 0) {
 		BT_ERR("Couldn't enable BT_HOST_WAKE as wakeup interrupt");
-		free_irq(bsi->host_wake_irq, NULL);
 		goto fail;
 	}
-
-	set_bit(BT_PROTO, &flags);
+    #endif
+        set_bit(BT_PROTO, &flags);
+        wake_lock(&bsi->wake_lock);
+        BT_DBG("== bluesleep start ==");	// added by yjhuang 2013-08-08
 	return 0;
 fail:
 	del_timer(&tx_timer);
@@ -378,14 +538,15 @@ static void bluesleep_stop(void)
 	unsigned long irq_flags;
 
 	spin_lock_irqsave(&rw_lock, irq_flags);
-
 	if (!test_bit(BT_PROTO, &flags)) {
 		spin_unlock_irqrestore(&rw_lock, irq_flags);
 		return;
 	}
+        /* assert BT_WAKE */
+        if (bsi->has_ext_wake == 1)
+                gpio_set_value(bsi->ext_wake, 1);
+        set_bit(BT_EXT_WAKE, &flags);
 
-	/* assert BT_WAKE */
-	gpio_set_value(bsi->ext_wake, 0);
 	del_timer(&tx_timer);
 	clear_bit(BT_PROTO, &flags);
 
@@ -395,11 +556,13 @@ static void bluesleep_stop(void)
 	}
 
 	atomic_inc(&open_count);
+        spin_unlock_irqrestore(&rw_lock, irq_flags);
 
-	spin_unlock_irqrestore(&rw_lock, irq_flags);
-	if (disable_irq_wake(bsi->host_wake_irq))
-		BT_ERR("Couldn't disable hostwake IRQ wakeup mode\n");
-	free_irq(bsi->host_wake_irq, NULL);
+    #if BT_ENABLE_IRQ_WAKE
+            if (disable_irq_wake(bsi->host_wake_irq))
+                    BT_ERR("Couldn't disable hostwake IRQ wakeup mode\n");
+    #endif
+        wake_lock_timeout(&bsi->wake_lock, HZ / 2);
 }
 /**
  * Read the <code>BT_WAKE</code> GPIO pin value via the proc interface.
@@ -416,8 +579,8 @@ static void bluesleep_stop(void)
 static int bluepower_read_proc_btwake(char *page, char **start, off_t offset,
 					int count, int *eof, void *data)
 {
-	*eof = 1;
-	return sprintf(page, "btwake:%u\n", gpio_get_value(bsi->ext_wake));
+    *eof = 1;
+    return sprintf(page, "btwake:%u\n",test_bit(BT_EXT_WAKE, &flags));
 }
 
 /**
@@ -445,11 +608,14 @@ static int bluepower_write_proc_btwake(struct file *file, const char *buffer,
 		kfree(buf);
 		return -EFAULT;
 	}
-
-	if (buf[0] == '0') {
-		gpio_set_value(bsi->ext_wake, 0);
-	} else if (buf[0] == '1') {
-		gpio_set_value(bsi->ext_wake, 1);
+        if (buf[0] == '0') {
+            if (bsi->has_ext_wake == 1)
+                    gpio_set_value(bsi->ext_wake, 0);
+            clear_bit(BT_EXT_WAKE, &flags);
+        } else if (buf[0] == '1') {
+            if (bsi->has_ext_wake == 1)
+                    gpio_set_value(bsi->ext_wake, 1);
+            set_bit(BT_EXT_WAKE, &flags);
 	} else {
 		kfree(buf);
 		return -EINVAL;
@@ -474,8 +640,8 @@ static int bluepower_write_proc_btwake(struct file *file, const char *buffer,
 static int bluepower_read_proc_hostwake(char *page, char **start, off_t offset,
 					int count, int *eof, void *data)
 {
-	*eof = 1;
-	return sprintf(page, "hostwake: %u \n", gpio_get_value(bsi->host_wake));
+    *eof = 1;
+    return sprintf(page, "hostwake: %u\n", gpio_get_value(bsi->host_wake));
 }
 
 
@@ -537,70 +703,203 @@ static int bluesleep_write_proc_proto(struct file *file, const char *buffer,
 {
 	char proto;
 
-	if (count < 1)
-		return -EINVAL;
+	BT_DBG("== write bluesleep proto ==");	// added by yjhuang 2013-08-08
+        if (count < 1)
+                return -EINVAL;
 
-	if (copy_from_user(&proto, buffer, 1))
-		return -EFAULT;
+        if (copy_from_user(&proto, buffer, 1))
+                return -EFAULT;
 
-	if (proto == '0')
+	if (proto == '0'){
+		BT_DBG("== call bluesleep stop ==");		// added by yjhuang 2013-08-08
 		bluesleep_stop();
-	else
+	}
+	else{
+		BT_DBG("== call bluesleep start ==");	// added by yjhuang 2013-08-08
 		bluesleep_start();
+	}
 
 	/* claim that we wrote everything */
 	return count;
 }
 
-static int __init bluesleep_probe(struct platform_device *pdev)
+void bluesleep_setup_uart_port(struct platform_device *uart_dev)
+{
+        bluesleep_uart_dev = uart_dev;
+}
+
+//add api for bt sleep start
+static int bluesleep_populate_dt_pinfo(struct platform_device *pdev)
+{
+	BT_DBG("");
+
+	if (!bsi)
+		return -ENOMEM;
+
+	bsi->host_wake = of_get_named_gpio(pdev->dev.of_node, "host-wake-gpio", 0);
+	if (bsi->host_wake < 0) {
+		BT_ERR("couldn't find host_wake gpio\n");
+		return -ENODEV;
+	}
+
+	bsi->ext_wake = of_get_named_gpio(pdev->dev.of_node,	 "ext-wake-gpio", 0);
+	if (bsi->ext_wake < 0) {
+		BT_ERR("couldn't find ext_wake gpio\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int bluesleep_populate_pinfo(struct platform_device *pdev)
 {
-	int ret;
 	struct resource *res;
 
+	BT_DBG("");
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_IO,"gpio_host_wake");
+	if (!res) {
+		BT_ERR("couldn't find host_wake gpio\n");
+		return -ENODEV;
+	}
+	bsi->host_wake = res->start;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_IO,"gpio_ext_wake");
+	if (!res) {
+		BT_ERR("couldn't find ext_wake gpio\n");
+		return -ENODEV;
+	}
+	bsi->ext_wake = res->start;
+
+	return 0;
+}
+//add api for bt sleep end
+
+    static int bluesleep_probe(struct platform_device *pdev)
+{
+	int ret;
+	//struct resource *res;
+
 	bsi = kzalloc(sizeof(struct bluesleep_info), GFP_KERNEL);
 	if (!bsi)
 		return -ENOMEM;
 
-	res = platform_get_resource_byname(pdev, IORESOURCE_IO,
+	//=========================================
+	//add for bluetooth sleep start
+	if (pdev->dev.of_node) {
+		ret = bluesleep_populate_dt_pinfo(pdev);
+		if (ret < 0) {
+			BT_ERR("Failed to populate device tree info");
+			goto free_bsi;
+		}
+	} else {
+		ret = bluesleep_populate_pinfo(pdev);
+		if (ret < 0) {
+			BT_ERR("Failed to populate device info");
+			goto free_bsi;
+		}
+	}
+
+	//add to define get resource success
+	bsi->has_ext_wake = 1;
+	
+	BT_DBG("host_wake_gpio: %d ext_wake_gpio: %d",	bsi->host_wake, bsi->ext_wake);
+
+	bsi->host_wake_irq = platform_get_irq_byname(pdev, "host_wake");
+	if (bsi->host_wake_irq < 0) {
+		BT_ERR("couldn't find host_wake irq\n");
+		ret = -ENODEV;
+		goto free_bsi;
+	}
+
+	bsi->irq_polarity = POLARITY_HIGH;	/* high edge (rasing edge) */
+
+	//return 0;
+	// add for bluetooth sleep end
+	//=========================================
+
+	/*res = platform_get_resource_byname(pdev, IORESOURCE_IO,
 				"gpio_host_wake");
 	if (!res) {
 		BT_ERR("couldn't find host_wake gpio\n");
 		ret = -ENODEV;
 		goto free_bsi;
 	}
-	bsi->host_wake = res->start;
+	bsi->host_wake = res->start;*/
 
 	ret = gpio_request(bsi->host_wake, "bt_host_wake");
 	if (ret)
 		goto free_bsi;
 	ret = gpio_direction_input(bsi->host_wake);
-	if (ret)
-		goto free_bt_host_wake;
-
-	res = platform_get_resource_byname(pdev, IORESOURCE_IO,
+        if (ret < 0) {
+                pr_err("gpio-keys: failed to configure input"
+                                " direction for GPIO %d, error %d\n",
+                                bsi->host_wake, ret);
+                gpio_free(bsi->host_wake);
+                goto free_bsi;
+        }
+
+	/*res = platform_get_resource_byname(pdev, IORESOURCE_IO,
 				"gpio_ext_wake");
-	if (!res) {
-		BT_ERR("couldn't find ext_wake gpio\n");
-		ret = -ENODEV;
-		goto free_bt_host_wake;
-	}
-	bsi->ext_wake = res->start;
-
-	ret = gpio_request(bsi->ext_wake, "bt_ext_wake");
-	if (ret)
-		goto free_bt_host_wake;
-	/* assert bt wake */
-	ret = gpio_direction_output(bsi->ext_wake, 0);
-	if (ret)
-		goto free_bt_ext_wake;
 
-	bsi->host_wake_irq = platform_get_irq_byname(pdev, "host_wake");
+            if (!res)
+                    bsi->has_ext_wake = 0;
+            else
+                    bsi->has_ext_wake = 1;*/
+
+        if (bsi->has_ext_wake) {
+                //bsi->ext_wake = res->start;
+            ret = gpio_request(bsi->ext_wake, "bt_ext_wake");
+	      if (ret)
+		    goto free_bt_host_wake;
+
+            /* configure ext_wake as output mode*/
+            ret = gpio_direction_output(bsi->ext_wake, 1);
+            if (ret < 0) {
+                    pr_err("gpio-keys: failed to configure output"
+                            " direction for GPIO %d, error %d\n",
+                              bsi->ext_wake, ret);
+                    gpio_free(bsi->ext_wake);
+                    goto free_bt_host_wake;
+            }
+       } 
+        else      set_bit(BT_EXT_WAKE, &flags);
+
+           /* res = platform_get_resource_byname(pdev, IORESOURCE_IRQ,
+                                                    "host_wake");
+            if (!res) {
+                    BT_ERR("couldn't find host_wake irq\n");
+                    ret = -ENODEV;
+                    goto free_bt_host_wake;
+            }*/
+            
+            //bsi->host_wake_irq = res->start;
 	if (bsi->host_wake_irq < 0) {
 		BT_ERR("couldn't find host_wake irq\n");
 		ret = -ENODEV;
 		goto free_bt_ext_wake;
 	}
-
+        //if (res->flags & IORESOURCE_IRQ_LOWEDGE)
+               // bsi->irq_polarity = POLARITY_LOW;/*low edge (falling edge)*/
+       // else
+                //bsi->irq_polarity = POLARITY_HIGH;/*anything else*/
+
+        wake_lock_init(&bsi->wake_lock, WAKE_LOCK_SUSPEND, "bluesleep");
+        clear_bit(BT_SUSPEND, &flags);
+
+        if (bsi->irq_polarity == POLARITY_LOW) {
+                ret = request_irq(bsi->host_wake_irq, bluesleep_hostwake_isr,
+                                IRQF_DISABLED | IRQF_TRIGGER_FALLING,
+                                "bluetooth hostwake", NULL);
+        } else {
+                ret = request_irq(bsi->host_wake_irq, bluesleep_hostwake_isr,
+                                IRQF_DISABLED | IRQF_TRIGGER_RISING,
+                                "bluetooth hostwake", NULL);
+        }
+        if (ret  < 0) {
+                BT_ERR("Couldn't acquire BT_HOST_WAKE IRQ");
+                goto free_bt_ext_wake;
+        }
 
 	return 0;
 
@@ -615,28 +914,51 @@ free_bsi:
 
 static int bluesleep_remove(struct platform_device *pdev)
 {
-	/* assert bt wake */
-	gpio_set_value(bsi->ext_wake, 0);
-	if (test_bit(BT_PROTO, &flags)) {
-		if (disable_irq_wake(bsi->host_wake_irq))
-			BT_ERR("Couldn't disable hostwake IRQ wakeup mode \n");
-		free_irq(bsi->host_wake_irq, NULL);
-		del_timer(&tx_timer);
-		if (test_bit(BT_ASLEEP, &flags))
-			hsuart_power(1);
-	}
+    free_irq(bsi->host_wake_irq, NULL);
+    gpio_free(bsi->host_wake);
+    gpio_free(bsi->ext_wake);
+    wake_lock_destroy(&bsi->wake_lock);
+    kfree(bsi);
+    return 0;
+}
 
-	gpio_free(bsi->host_wake);
-	gpio_free(bsi->ext_wake);
-	kfree(bsi);
-	return 0;
+
+static int bluesleep_resume(struct platform_device *pdev)
+{
+        if (test_bit(BT_SUSPEND, &flags)) {
+            BT_DBG("bluesleep resuming...\n");
+            if ((bsi->uport != NULL) &&  (gpio_get_value(bsi->host_wake) == bsi->irq_polarity)) {
+                BT_DBG("bluesleep resume form BT event...\n");
+                msm_hs_request_clock_on(bsi->uport);
+                msm_hs_set_mctrl(bsi->uport, TIOCM_RTS);
+            }
+            clear_bit(BT_SUSPEND, &flags);
+        }
+        return 0;
+}
+
+static int bluesleep_suspend(struct platform_device *pdev, pm_message_t state)
+{
+    BT_DBG("bluesleep suspending...\n");
+    set_bit(BT_SUSPEND, &flags);
+    return 0;
 }
 
+/** Device table */
+static struct of_device_id bcmsleep_match_table[] = {
+	{ .compatible = "qca,bcm4339_bluesleep" },
+	{}
+};
+
 static struct platform_driver bluesleep_driver = {
+            .probe = bluesleep_probe,
 	.remove = bluesleep_remove,
+            .suspend = bluesleep_suspend,
+            .resume = bluesleep_resume,
 	.driver = {
-		.name = "bluesleep",
+		.name = "bcmbtsleep",
 		.owner = THIS_MODULE,
+		.of_match_table = bcmsleep_match_table,
 	},
 };
 /**
@@ -648,14 +970,24 @@ static int __init bluesleep_init(void)
 {
 	int retval;
 	struct proc_dir_entry *ent;
-
-	BT_INFO("MSM Sleep Mode Driver Ver %s", VERSION);
-
-	retval = platform_driver_probe(&bluesleep_driver, bluesleep_probe);
+	
+	BT_ERR("bulesleep init");
+       BT_INFO("BlueSleep Mode Driver Ver %s", VERSION);
+
+	//platform_driver_register(&bluesleep_driver);
+	
+	
+       retval = platform_driver_register(&bluesleep_driver);
 	if (retval)
 		return retval;
+	
+
+    if (bsi == NULL)
+            return 0;
 
+    #if !BT_BLUEDROID_SUPPORT
 	bluesleep_hdev = NULL;
+    #endif
 
 	bluetooth_dir = proc_mkdir("bluetooth", NULL);
 	if (bluetooth_dir == NULL) {
@@ -705,6 +1037,28 @@ static int __init bluesleep_init(void)
 		goto fail;
 	}
 
+    #if BT_BLUEDROID_SUPPORT
+            /* read/write proc entries */
+            ent = create_proc_entry("lpm", 0, sleep_dir);
+            if (ent == NULL) {
+                    BT_ERR("Unable to create /proc/%s/lpm entry", PROC_DIR);
+                    retval = -ENOMEM;
+                    goto fail;
+            }
+            ent->read_proc = bluesleep_read_proc_lpm;
+            ent->write_proc = bluesleep_write_proc_lpm;
+
+            /* read/write proc entries */
+            ent = create_proc_entry("btwrite", 0, sleep_dir);
+            if (ent == NULL) {
+                    BT_ERR("Unable to create /proc/%s/btwrite entry", PROC_DIR);
+                    retval = -ENOMEM;
+                    goto fail;
+            }
+            ent->read_proc = bluesleep_read_proc_btwrite;
+            ent->write_proc = bluesleep_write_proc_btwrite;
+    #endif
+
 	flags = 0; /* clear all status bits */
 
 	/* Initialize spinlock. */
@@ -718,11 +1072,20 @@ static int __init bluesleep_init(void)
 	/* initialize host wake tasklet */
 	tasklet_init(&hostwake_task, bluesleep_hostwake_task, 0);
 
+            if (bsi->has_ext_wake == 1)
+                    gpio_set_value(bsi->ext_wake, 1);
+            set_bit(BT_EXT_WAKE, &flags);
+    #if !BT_BLUEDROID_SUPPORT
 	hci_register_notifier(&hci_event_nblock);
+    #endif
 
 	return 0;
 
 fail:
+#if BT_BLUEDROID_SUPPORT
+    remove_proc_entry("btwrite", sleep_dir);
+    remove_proc_entry("lpm", sleep_dir);
+#endif
 	remove_proc_entry("asleep", sleep_dir);
 	remove_proc_entry("proto", sleep_dir);
 	remove_proc_entry("hostwake", sleep_dir);
@@ -737,9 +1100,31 @@ fail:
  */
 static void __exit bluesleep_exit(void)
 {
+            if (bsi == NULL)
+                    return;
+
+            /* assert bt wake */
+            if (bsi->has_ext_wake == 1)
+                    gpio_set_value(bsi->ext_wake, 1);
+            set_bit(BT_EXT_WAKE, &flags);
+            if (test_bit(BT_PROTO, &flags)) {
+                    if (disable_irq_wake(bsi->host_wake_irq))
+                            BT_ERR("Couldn't disable hostwake IRQ wakeup mode\n");
+                    free_irq(bsi->host_wake_irq, NULL);
+                    del_timer(&tx_timer);
+                    if (test_bit(BT_ASLEEP, &flags))
+                            hsuart_power(1);
+            }
+
+    #if !BT_BLUEDROID_SUPPORT
 	hci_unregister_notifier(&hci_event_nblock);
+    #endif
 	platform_driver_unregister(&bluesleep_driver);
 
+    #if BT_BLUEDROID_SUPPORT
+            remove_proc_entry("btwrite", sleep_dir);
+            remove_proc_entry("lpm", sleep_dir);
+    #endif
 	remove_proc_entry("asleep", sleep_dir);
 	remove_proc_entry("proto", sleep_dir);
 	remove_proc_entry("hostwake", sleep_dir);
diff --git a/drivers/bluetooth/bluetooth-power.c b/drivers/bluetooth/bluetooth-power.c
old mode 100644
new mode 100755
index 9ccee05..255fcea
--- a/drivers/bluetooth/bluetooth-power.c
+++ b/drivers/bluetooth/bluetooth-power.c
@@ -1,499 +1,134 @@
-/* Copyright (c) 2009-2010, 2013 The Linux Foundation. All rights reserved.
+/*
+ * Copyright (C) 2009 Google, Inc.
+ * Copyright (C) 2009 HTC Corporation.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- */
-/*
- * Bluetooth Power Switch Module
- * controls power to external Bluetooth device
- * with interface to power management device
+ *
  */
 
-#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/device.h>
 #include <linux/module.h>
-#include <linux/kernel.h>
 #include <linux/platform_device.h>
 #include <linux/rfkill.h>
-#include <linux/gpio.h>
-#include <linux/of_gpio.h>
-#include <linux/delay.h>
-#include <linux/bluetooth-power.h>
-#include <linux/slab.h>
-#include <linux/regulator/consumer.h>
-
-#define BT_PWR_DBG(fmt, arg...)  pr_debug("%s: " fmt "\n" , __func__ , ## arg)
-#define BT_PWR_INFO(fmt, arg...) pr_info("%s: " fmt "\n" , __func__ , ## arg)
-#define BT_PWR_ERR(fmt, arg...)  pr_err("%s: " fmt "\n" , __func__ , ## arg)
-#define BT_VDD_PA_CURRENT        60000
-
-static struct of_device_id bt_power_match_table[] = {
-	{	.compatible = "qca,ar3002" },
-	{}
-};
-
-static struct bluetooth_power_platform_data *bt_power_pdata;
-static struct platform_device *btpdev;
-static bool previous;
-
-static int bt_vreg_init(struct bt_power_vreg_data *vreg)
-{
-	int rc = 0;
-	struct device *dev = &btpdev->dev;
-
-	BT_PWR_DBG("vreg_get for : %s", vreg->name);
-
-	/* Get the regulator handle */
-	vreg->reg = regulator_get(dev, vreg->name);
-	if (IS_ERR(vreg->reg)) {
-		rc = PTR_ERR(vreg->reg);
-		pr_err("%s: regulator_get(%s) failed. rc=%d\n",
-			__func__, vreg->name, rc);
-		goto out;
-	}
-
-	if ((regulator_count_voltages(vreg->reg) > 0)
-			&& (vreg->low_vol_level) && (vreg->high_vol_level))
-		vreg->set_voltage_sup = 1;
-
-out:
-	return rc;
-}
-
-static int bt_vreg_enable(struct bt_power_vreg_data *vreg)
-{
-	int rc = 0;
-
-	BT_PWR_DBG("vreg_en for : %s", vreg->name);
-
-	if (!vreg->is_enabled) {
-		if (vreg->set_voltage_sup) {
-			rc = regulator_set_voltage(vreg->reg,
-						vreg->low_vol_level,
-						vreg->high_vol_level);
-			if (rc < 0) {
-				BT_PWR_ERR("vreg_set_vol(%s) failed rc=%d\n",
-						vreg->name, rc);
-				goto out;
-			}
-		}
-
-		rc = regulator_enable(vreg->reg);
-		if (rc < 0) {
-			BT_PWR_ERR("regulator_enable(%s) failed. rc=%d\n",
-					vreg->name, rc);
-			goto out;
-		}
-		vreg->is_enabled = true;
-	}
-out:
-	return rc;
-}
-
-static int bt_vreg_disable(struct bt_power_vreg_data *vreg)
-{
-	int rc = 0;
-
-	if (!vreg)
-		return rc;
-
-	BT_PWR_DBG("vreg_disable for : %s", vreg->name);
-
-	if (vreg->is_enabled) {
-		rc = regulator_disable(vreg->reg);
-		if (rc < 0) {
-			BT_PWR_ERR("regulator_disable(%s) failed. rc=%d\n",
-					vreg->name, rc);
-			goto out;
-		}
-		vreg->is_enabled = false;
-
-		if (vreg->set_voltage_sup) {
-			/* Set the min voltage to 0 */
-			rc = regulator_set_voltage(vreg->reg,
-						0,
-						vreg->high_vol_level);
-			if (rc < 0) {
-				BT_PWR_ERR("vreg_set_vol(%s) failed rc=%d\n",
-						vreg->name, rc);
-				goto out;
-
-			}
-		}
-	}
-out:
-	return rc;
-}
-
-static int bt_configure_vreg(struct bt_power_vreg_data *vreg)
-{
-	int rc = 0;
+#include <asm/gpio.h>
+#include <asm/mach-types.h>
 
-	BT_PWR_DBG("config %s", vreg->name);
+//#include "board-mahimahi.h"
 
-	/* Get the regulator handle for vreg */
-	if (!(vreg->reg)) {
-		rc = bt_vreg_init(vreg);
-		if (rc < 0)
-			return rc;
-	}
-	rc = bt_vreg_enable(vreg);
+static struct rfkill *btrfk;
+static const char btname[] = "bcm4339";
 
-	return rc;
-}
+#define GPIO_BT_RESET_N 69
 
-static int bt_configure_gpios(int on)
+static int bluetooth_set_power(void *data, bool blocked)
 {
-	int rc = 0;
-	int bt_reset_gpio = bt_power_pdata->bt_gpio_sys_rst;
-
-	BT_PWR_DBG("%s  bt_gpio= %d on: %d", __func__, bt_reset_gpio, on);
-
-	if (on) {
-		rc = gpio_request(bt_reset_gpio, "bt_sys_rst_n");
-		if (rc) {
-			BT_PWR_ERR("unable to request gpio %d (%d)\n",
-					bt_reset_gpio, rc);
-			return rc;
-		}
-
-		rc = gpio_direction_output(bt_reset_gpio, 0);
-		if (rc) {
-			BT_PWR_ERR("Unable to set direction\n");
-			return rc;
-		}
-
-		rc = gpio_direction_output(bt_reset_gpio, 1);
-		if (rc) {
-			BT_PWR_ERR("Unable to set direction\n");
-			return rc;
-		}
-		msleep(100);
-	} else {
-		gpio_set_value(bt_reset_gpio, 0);
-
-		rc = gpio_direction_input(bt_reset_gpio);
-		if (rc)
-			BT_PWR_ERR("Unable to set direction\n");
-
-		msleep(100);
-	}
-	return rc;
-}
-
-static int bluetooth_power(int on)
-{
-	int rc = 0;
-
-	BT_PWR_DBG("on: %d", on);
-
-	if (on) {
-		if (bt_power_pdata->bt_vdd_io) {
-			rc = bt_configure_vreg(bt_power_pdata->bt_vdd_io);
-			if (rc < 0) {
-				BT_PWR_ERR("bt_power vddio config failed");
-				goto out;
-			}
-		}
-		if (bt_power_pdata->bt_vdd_ldo) {
-			rc = bt_configure_vreg(bt_power_pdata->bt_vdd_ldo);
-			if (rc < 0) {
-				BT_PWR_ERR("bt_power vddldo config failed");
-				goto vdd_ldo_fail;
-			}
-		}
-		if (bt_power_pdata->bt_vdd_pa) {
-			rc = bt_configure_vreg(bt_power_pdata->bt_vdd_pa);
-			if (rc < 0) {
-				BT_PWR_ERR("bt_power vddpa config failed");
-				goto vdd_pa_fail;
-			}
-			regulator_set_optimum_mode(
-				bt_power_pdata->bt_vdd_pa->reg,
-				BT_VDD_PA_CURRENT);
-		}
-		if (bt_power_pdata->bt_chip_pwd) {
-			rc = bt_configure_vreg(bt_power_pdata->bt_chip_pwd);
-			if (rc < 0) {
-				BT_PWR_ERR("bt_power vddldo config failed");
-				goto chip_pwd_fail;
-			}
-		}
-		if (bt_power_pdata->bt_gpio_sys_rst) {
-			rc = bt_configure_gpios(on);
-			if (rc < 0) {
-				BT_PWR_ERR("bt_power gpio config failed");
-				goto gpio_fail;
-			}
-		}
+	printk("%s(), line: %d , rfkill blocked %d\n",__func__, __LINE__, blocked);
+	if (!blocked) {
+        printk("%s(), line: %d , set GPIO_BT_RESET_N to 1\n",__func__, __LINE__);
+ 		gpio_direction_output(GPIO_BT_RESET_N, 1);
 	} else {
-		bt_configure_gpios(on);
-gpio_fail:
-		if (bt_power_pdata->bt_gpio_sys_rst)
-			gpio_free(bt_power_pdata->bt_gpio_sys_rst);
-		bt_vreg_disable(bt_power_pdata->bt_chip_pwd);
-chip_pwd_fail:
-		bt_vreg_disable(bt_power_pdata->bt_vdd_pa);
-vdd_pa_fail:
-		bt_vreg_disable(bt_power_pdata->bt_vdd_ldo);
-vdd_ldo_fail:
-		bt_vreg_disable(bt_power_pdata->bt_vdd_io);
+	printk("%s(), line: %d , set GPIO_BT_RESET_N to 0\n",__func__, __LINE__);
+		gpio_direction_output(GPIO_BT_RESET_N, 0);
 	}
 
-out:
-	return rc;
-}
-
-static int bluetooth_toggle_radio(void *data, bool blocked)
-{
-	int ret = 0;
-	int (*power_control)(int enable);
-
-	power_control =
-		((struct bluetooth_power_platform_data *)data)->bt_power_setup;
-
-	if (previous != blocked)
-		ret = (*power_control)(!blocked);
-	if (!ret)
-		previous = blocked;
-	return ret;
+    printk("%s(), LINE: %d , gpio set value to : %d \n", __FUNCTION__, __LINE__,  gpio_get_value(GPIO_BT_RESET_N));
+	return 0;
 }
 
-static const struct rfkill_ops bluetooth_power_rfkill_ops = {
-	.set_block = bluetooth_toggle_radio,
+static struct rfkill_ops bluetooth_rfkill_ops = {
+	.set_block = bluetooth_set_power,
 };
 
-static int bluetooth_power_rfkill_probe(struct platform_device *pdev)
+static int mahimahi_rfkill_probe(struct platform_device *pdev)
 {
-	struct rfkill *rfkill;
-	int ret;
-
-	rfkill = rfkill_alloc("bt_power", &pdev->dev, RFKILL_TYPE_BLUETOOTH,
-			      &bluetooth_power_rfkill_ops,
-			      pdev->dev.platform_data);
-
-	if (!rfkill) {
-		dev_err(&pdev->dev, "rfkill allocate failed\n");
-		return -ENOMEM;
+	int rc = 0;
+	bool default_state = true;  /* off */
+
+	printk("%s(), LINE: %d \n", __FUNCTION__, __LINE__);
+	rc = gpio_request(GPIO_BT_RESET_N, "bt_reset_4339");
+	if (rc){
+        printk("%s(), LINE: %d , gpio_request GPIO_BT_RESET_N failed \n", __FUNCTION__, __LINE__);
+		goto err_gpio_reset;
+       }
+
+	gpio_direction_output(GPIO_BT_RESET_N, 0);
+      printk("%s(), LINE: %d , gpio set value to : %d \n", __FUNCTION__, __LINE__,  gpio_get_value(GPIO_BT_RESET_N));
+	bluetooth_set_power(NULL, default_state);
+
+	btrfk = rfkill_alloc(btname, &pdev->dev, RFKILL_TYPE_BLUETOOTH,
+				&bluetooth_rfkill_ops, NULL);
+	if (!btrfk) {
+		rc = -ENOMEM;
+		goto err_rfkill_alloc;
 	}
 
-	/* force Bluetooth off during init to allow for user control */
-	rfkill_init_sw_state(rfkill, 1);
-	previous = 1;
+	rfkill_set_states(btrfk, default_state, false);
 
-	ret = rfkill_register(rfkill);
-	if (ret) {
-		dev_err(&pdev->dev, "rfkill register failed=%d\n", ret);
-		rfkill_destroy(rfkill);
-		return ret;
-	}
+	/* userspace cannot take exclusive control */
 
-	platform_set_drvdata(pdev, rfkill);
+	rc = rfkill_register(btrfk);
+	if (rc)
+		goto err_rfkill_reg;
 
 	return 0;
-}
-
-static void bluetooth_power_rfkill_remove(struct platform_device *pdev)
-{
-	struct rfkill *rfkill;
-
-	dev_dbg(&pdev->dev, "%s\n", __func__);
-
-	rfkill = platform_get_drvdata(pdev);
-	if (rfkill)
-		rfkill_unregister(rfkill);
-	rfkill_destroy(rfkill);
-	platform_set_drvdata(pdev, NULL);
-}
-
-#define MAX_PROP_SIZE 32
-static int bt_dt_parse_vreg_info(struct device *dev,
-		struct bt_power_vreg_data **vreg_data, const char *vreg_name)
-{
-	int len, ret = 0;
-	const __be32 *prop;
-	char prop_name[MAX_PROP_SIZE];
-	struct bt_power_vreg_data *vreg;
-	struct device_node *np = dev->of_node;
-
-	BT_PWR_DBG("vreg dev tree parse for %s", vreg_name);
-
-	snprintf(prop_name, MAX_PROP_SIZE, "%s-supply", vreg_name);
-	if (of_parse_phandle(np, prop_name, 0)) {
-		vreg = devm_kzalloc(dev, sizeof(*vreg), GFP_KERNEL);
-		if (!vreg) {
-			dev_err(dev, "No memory for vreg: %s\n", vreg_name);
-			ret = -ENOMEM;
-			goto err;
-		}
-
-		vreg->name = vreg_name;
-
-		snprintf(prop_name, MAX_PROP_SIZE,
-				"qcom,%s-voltage-level", vreg_name);
-		prop = of_get_property(np, prop_name, &len);
-		if (!prop || (len != (2 * sizeof(__be32)))) {
-			dev_warn(dev, "%s %s property\n",
-				prop ? "invalid format" : "no", prop_name);
-		} else {
-			vreg->low_vol_level = be32_to_cpup(&prop[0]);
-			vreg->high_vol_level = be32_to_cpup(&prop[1]);
-		}
-
-		*vreg_data = vreg;
-		BT_PWR_DBG("%s: vol=[%d %d]uV\n",
-			vreg->name, vreg->low_vol_level,
-			vreg->high_vol_level);
-	} else
-		BT_PWR_INFO("%s: is not provided in device tree", vreg_name);
-
-err:
-	return ret;
-}
-
-static int bt_power_populate_dt_pinfo(struct platform_device *pdev)
-{
-	int rc;
-
-	BT_PWR_DBG("");
-
-	if (!bt_power_pdata)
-		return -ENOMEM;
-
-	if (pdev->dev.of_node) {
-		bt_power_pdata->bt_gpio_sys_rst =
-			of_get_named_gpio(pdev->dev.of_node,
-						"qca,bt-reset-gpio", 0);
-		if (bt_power_pdata->bt_gpio_sys_rst < 0) {
-			BT_PWR_ERR("bt-reset-gpio not provided in device tree");
-			return bt_power_pdata->bt_gpio_sys_rst;
-		}
 
-		rc = bt_dt_parse_vreg_info(&pdev->dev,
-					&bt_power_pdata->bt_vdd_io,
-					"qca,bt-vdd-io");
-		if (rc < 0)
-			return rc;
-
-		rc = bt_dt_parse_vreg_info(&pdev->dev,
-					&bt_power_pdata->bt_vdd_pa,
-					"qca,bt-vdd-pa");
-		if (rc < 0)
-			return rc;
-
-		rc = bt_dt_parse_vreg_info(&pdev->dev,
-					&bt_power_pdata->bt_vdd_ldo,
-					"qca,bt-vdd-ldo");
-		if (rc < 0)
-			return rc;
-
-		rc = bt_dt_parse_vreg_info(&pdev->dev,
-					&bt_power_pdata->bt_chip_pwd,
-					"qca,bt-chip-pwd");
-		if (rc < 0)
-			return rc;
-
-	}
-
-	bt_power_pdata->bt_power_setup = bluetooth_power;
-
-	return 0;
+err_rfkill_reg:
+	rfkill_destroy(btrfk);
+err_rfkill_alloc:
+	//gpio_free(MAHIMAHI_GPIO_BT_SHUTDOWN_N);
+//err_gpio_shutdown:
+	gpio_free(GPIO_BT_RESET_N);
+err_gpio_reset:
+	return rc;
 }
 
-static int __devinit bt_power_probe(struct platform_device *pdev)
+static int mahimahi_rfkill_remove(struct platform_device *dev)
 {
-	int ret = 0;
-
-	dev_dbg(&pdev->dev, "%s\n", __func__);
-
-	bt_power_pdata =
-		kzalloc(sizeof(struct bluetooth_power_platform_data),
-			GFP_KERNEL);
-
-	if (!bt_power_pdata) {
-		BT_PWR_ERR("Failed to allocate memory");
-		return -ENOMEM;
-	}
-
-	if (pdev->dev.of_node) {
-		ret = bt_power_populate_dt_pinfo(pdev);
-		if (ret < 0) {
-			BT_PWR_ERR("Failed to populate device tree info");
-			goto free_pdata;
-		}
-		pdev->dev.platform_data = bt_power_pdata;
-	} else if (pdev->dev.platform_data) {
-		/* Optional data set to default if not provided */
-		if (!((struct bluetooth_power_platform_data *)
-			(pdev->dev.platform_data))->bt_power_setup)
-			((struct bluetooth_power_platform_data *)
-				(pdev->dev.platform_data))->bt_power_setup =
-						bluetooth_power;
-
-		memcpy(bt_power_pdata, pdev->dev.platform_data,
-			sizeof(struct bluetooth_power_platform_data));
-	} else {
-		BT_PWR_ERR("Failed to get platform data");
-		goto free_pdata;
-	}
-
-	if (bluetooth_power_rfkill_probe(pdev) < 0)
-		goto free_pdata;
-
-	btpdev = pdev;
+	rfkill_unregister(btrfk);
+	rfkill_destroy(btrfk);
+	gpio_free(GPIO_BT_RESET_N);
 
 	return 0;
-
-free_pdata:
-	kfree(bt_power_pdata);
-	return ret;
 }
 
-static int __devexit bt_power_remove(struct platform_device *pdev)
-{
-	dev_dbg(&pdev->dev, "%s\n", __func__);
-
-	bluetooth_power_rfkill_remove(pdev);
-
-	if (bt_power_pdata->bt_chip_pwd->reg)
-		regulator_put(bt_power_pdata->bt_chip_pwd->reg);
-
-	kfree(bt_power_pdata);
+#define BCM4339_PLATFORM_DEVICE_NAME "bcm4339_rfkill"
 
-	return 0;
-}
-
-static struct platform_driver bt_power_driver = {
-	.probe = bt_power_probe,
-	.remove = __devexit_p(bt_power_remove),
+static struct platform_driver mahimahi_rfkill_driver = {
+	.probe = mahimahi_rfkill_probe,
+	.remove = mahimahi_rfkill_remove,
 	.driver = {
-		.name = "bt_power",
+		.name = BCM4339_PLATFORM_DEVICE_NAME,
 		.owner = THIS_MODULE,
-		.of_match_table = bt_power_match_table,
 	},
 };
 
-static int __init bluetooth_power_init(void)
-{
-	int ret;
+struct platform_device bcm4339_rfkill_dev = {
+	.name		= BCM4339_PLATFORM_DEVICE_NAME,
+	.id		= -1,
+};
 
-	ret = platform_driver_register(&bt_power_driver);
-	return ret;
+static int __init mahimahi_rfkill_init(void)
+{
+	printk("%s", __FUNCTION__);
+	platform_device_register(&bcm4339_rfkill_dev);
+	return platform_driver_register(&mahimahi_rfkill_driver);
 }
 
-static void __exit bluetooth_power_exit(void)
+static void __exit mahimahi_rfkill_exit(void)
 {
-	platform_driver_unregister(&bt_power_driver);
+	platform_driver_unregister(&mahimahi_rfkill_driver);
 }
 
-MODULE_LICENSE("GPL v2");
-MODULE_DESCRIPTION("MSM Bluetooth power control driver");
-MODULE_VERSION("1.40");
-
-module_init(bluetooth_power_init);
-module_exit(bluetooth_power_exit);
+module_init(mahimahi_rfkill_init);
+module_exit(mahimahi_rfkill_exit);
+MODULE_DESCRIPTION("mahimahi rfkill");
+MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/char/diag/diagfwd.c b/drivers/char/diag/diagfwd.c
old mode 100644
new mode 100755
index 9f2d5d3..64b7415
--- a/drivers/char/diag/diagfwd.c
+++ b/drivers/char/diag/diagfwd.c
@@ -1729,6 +1729,22 @@ int diag_process_apps_pkt(unsigned char *buf, int len)
 		/* Not required, represents that command isnt sent to modem */
 		return 0;
 	}
+#ifdef CONFIG_ZTEMT_RESTART
+	/*Check for restart command, to perform reset, will not get into download mode*/
+	else if ((cpu_is_msm8x60() || chk_apps_master()) &&
+		((*buf == 0x29) && (*(buf+1) == 0x02) && (*(buf+2) == 0x00))) {
+		/*send response pack*/
+		driver->apps_rsp_buf[0] = *buf;
+		encode_rsp_and_send(0);
+		msleep(5000);
+		/*call restart API*/
+		msm_set_restart_mode(RESTART_NORMAL);
+		printk(KERN_CRIT "diag: restart mode set, Rebooting SOC..\n");
+		kernel_restart(NULL);
+		/*Not required, represents that command isnt send to modem*/
+		return 0;
+	}
+#endif
 	/* Check for polling for Apps only DIAG */
 	else if ((*buf == 0x4b) && (*(buf+1) == 0x32) &&
 		(*(buf+2) == 0x03)) {
diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
old mode 100644
new mode 100755
index 1ed287a..11c1f2c
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -1426,6 +1426,110 @@ config SENSORS_MC13783_ADC
         help
           Support for the A/D converter on MC13783 and MC13892 PMIC.
 
+################################################# SENROS START
+menuconfig ZTEMT_SENSORS
+	tristate "ZTEMT ZTEMT_SENSORS"
+	default n	       
+
+if ZTEMT_SENSORS
+
+	config FEATURE_ZTEMT_SENSORS_LOG_ON
+	tristate "ZTEMT SENSORS LOG ON"
+	depends on ZTEMT_SENSORS
+	default n	
+	help 
+		If you want to enable the sensor log,
+		then choose this config 
+
+################################################# SENSOR_COMMON START
+	config ZTEMT_SENSORS_COMMON
+	tristate "ZTEMT SENSORS COMMON"
+	depends on ZTEMT_SENSORS
+	default n	
+	help 
+		If you want to enable the sensor common,
+		then choose this config 
+################################################# SENSOR_COMMON END
+		
+################################################# ALS_PS START
+menuconfig ZTEMT_SENSORS_ALS_PS
+	tristate "ZTEMT ALS and PS"
+	default n
+
+if ZTEMT_SENSORS_ALS_PS
+
+config ZTEMT_SENSORS_ALS_PS_AUTO_DETECT
+	tristate "ALS_PS_SENSOR auto detect"
+	depends on ZTEMT_SENSORS_ALS_PS
+	help
+	  If you say yes here,the ALS_PS_SENSOR is auto detect
+
+config ZTEMT_SENSORS_ALS_PS_TMG3993
+	tristate "TMG3993 device driver"
+	depends on ZTEMT_SENSORS_ALS_PS
+	help
+	  If you say yes here you get support for AMS's 
+	  als ps TMG3993
+
+config ZTEMT_SENSORS_ALS_PS_TMD2772
+	tristate "TMD2772 device driver"
+	depends on ZTEMT_SENSORS_ALS_PS
+	help
+	  If you say yes here you get support for AMS's 
+	  als ps TMD2772
+	  
+endif
+################################################# ALS_PS END		
+
+################################################# IR REMOTE START
+menuconfig ZTEMT_SENSORS_IR_REMOTE
+	tristate "ZTEMT IR REMOTE CONTROL"
+	default n
+
+if ZTEMT_SENSORS_IR_REMOTE
+
+config ZTEMT_SENSORS_IR_REMOTE_MAXQ616
+	tristate "MAXQ616 device driver"
+	depends on ZTEMT_SENSORS_IR_REMOTE
+	help
+	  If you say yes here you get support for UEI's 
+	  IR Remote control maxq616
+	  
+config ZTEMT_HSL_UART_DMEN_PATCH
+	tristate "HSL_UART_DMEN PATCH"
+	depends on ZTEMT_SENSORS_IR_REMOTE
+	help
+	  If you say yes here, then will force the HAL UART DMEN 
+	  register to be 0
+endif
+################################################# IR REMOTE END		
+
+endif
+################################################# SENROS END
+
+# ZTEMT ADD by hongdanlong
+config ZTEMT_LIQUID_LED
+	bool "ZTEMT liquid led"
+	default n
+	help
+	  ZTEMT liquid led
+#ZTEMT END 
+
+#
+config  NX503A_ZTEMT_DEVICE_INFO
+	bool "ZTEMT Device information Recognization"
+	default n
+	help
+	  ZTEMT Device information Recognization
+#
+
+config ZTEMT_BREATH_LED_NX503A
+	bool "ZTEMT_BREATH_LED_NX503A"
+	default n
+	help
+	  ZTEMT_BREATH_LED_NX503A
+#ZTEMT END 
+
 if ACPI
 
 comment "ACPI drivers"
diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
old mode 100644
new mode 100755
index ad5c6bb..fd20ebb
--- a/drivers/hwmon/Makefile
+++ b/drivers/hwmon/Makefile
@@ -133,6 +133,31 @@ obj-$(CONFIG_SENSORS_EPM_ADC)	+= epm_adc.o
 obj-$(CONFIG_SENSORS_QPNP_ADC_VOLTAGE)	+= qpnp-adc-voltage.o qpnp-adc-common.o
 obj-$(CONFIG_SENSORS_QPNP_ADC_CURRENT)	+= qpnp-adc-current.o qpnp-adc-common.o
 
+################################################# SENROS START
+		
+################################################# ALS_PS START
+obj-$(CONFIG_ZTEMT_SENSORS_ALS_PS_TMG3993) += tmg399x.o
+obj-$(CONFIG_ZTEMT_SENSORS_ALS_PS_TMD2772) += tmd2772.o
+################################################# ALS_PS END
+
+################################################# TEMP_HUMI START
+obj-$(CONFIG_ZTEMT_SENSORS_COMMON)      += sensor_common.o
+################################################# TEMP_HUMI END
+
+
+################################################# IR_REMOTE START
+obj-$(CONFIG_ZTEMT_SENSORS_IR_REMOTE_MAXQ616)      += maxq616.o
+################################################# IR_REMOTE END
+
+################################################# SENROS END
+
+#ZTEMT ADD by hongdanlong
+obj-$(CONFIG_ZTEMT_LIQUID_LED)      += aw_9106b.o
+#ZTEMT END
+#add for device information
+obj-$(CONFIG_NX503A_ZTEMT_DEVICE_INFO)      += qpnp-device-info.o
+#
+
 obj-$(CONFIG_PMBUS)		+= pmbus/
 
 ccflags-$(CONFIG_HWMON_DEBUG_CHIP) := -DDEBUG
diff --git a/drivers/hwmon/als_prox.c b/drivers/hwmon/als_prox.c
new file mode 100755
index 0000000..1575d60
--- /dev/null
+++ b/drivers/hwmon/als_prox.c
@@ -0,0 +1,65 @@
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/i2c/tmg399x.h>
+#include <linux/i2c/taos_common.h>
+#include <linux/qpnp/qpnp-device-info.h>
+
+
+#define LOG_TAG "SENSOR_ALS_PROX_COMMON"
+#define DEBUG_ON //DEBUG SWITCH
+
+#define SENSOR_LOG_FILE__ strrchr(__FILE__, '/') ? (strrchr(__FILE__, '/')+1) : __FILE__
+
+#ifdef  CONFIG_FEATURE_ZTEMT_SENSORS_LOG_ON
+#define SENSOR_LOG_ERROR(fmt, args...) printk(KERN_ERR   "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #ifdef  DEBUG_ON
+#define SENSOR_LOG_INFO(fmt, args...)  printk(KERN_INFO  "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+                                              
+#define SENSOR_LOG_DEBUG(fmt, args...) printk(KERN_DEBUG "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #else
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+    #endif
+
+#else
+#define SENSOR_LOG_ERROR(fmt, args...)
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+#endif
+
+extern struct i2c_driver tmd2772_driver;
+extern struct i2c_driver tmg399x_driver;
+extern int ztemt_get_device_index(char* result);
+
+
+static int __init als_prox_init(void) 
+{
+    int project_id = ztemt_get_device_index(NULL);
+
+    SENSOR_LOG_INFO("project_id is %d\n",project_id);
+
+    if (DEVICE_01AMB_B_WTR1605_L_EMMC_16_32 == project_id)
+    {
+        SENSOR_LOG_INFO("add tmd2772 driver\n");
+        return i2c_add_driver(&tmd2772_driver);
+
+    }
+    else
+    {        
+        SENSOR_LOG_INFO("add tmg399x driver\n");
+	    return i2c_add_driver(&tmg399x_driver);
+    }
+}
+
+
+module_init(als_prox_init);
+
diff --git a/drivers/hwmon/aw_9106b.c b/drivers/hwmon/aw_9106b.c
new file mode 100755
index 0000000..e72622e
--- /dev/null
+++ b/drivers/hwmon/aw_9106b.c
@@ -0,0 +1,1247 @@
+/***********************************************************************************/
+/* File Name: aw_9106b.c */
+/* File Description: this file is used to make aw9106b driver to be added in kernel or module. */
+
+/*  Copyright (c) 2002-2012, ZTEMT, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: ZTEMT, Inc.,            */
+/***********************************************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/errno.h>
+#include <linux/wait.h>
+#include <linux/poll.h>
+#include <linux/irq.h>
+#include <linux/kobject.h>
+#include <linux/io.h>
+#include <linux/kthread.h>
+
+#include <linux/bug.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/spinlock_types.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/init.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/earlysuspend.h>
+
+#include <linux/i2c.h>
+#include "aw_9106b.h"
+#include  <../../include/linux/printk.h>
+
+static bool AW9106B_SUSPEND_FLAG=false; 
+#define GPIO_PWDN 28
+#define DELAY_256MS_UNIT 1
+#define AW_DRIVER_NAME "aw9106bdrv"
+#define DRV_NAME "class/leds/red/outn"
+//#define AW_GPIO_CONFIG
+
+#define AW_LED_DELAY_MS 650
+#define TIME_MS_UNIT  1000000ULL
+#define CONST_MIN_GRADE  10
+#define CONST_MAX_GRADE  200
+#define START_OUTN 3
+#define END_OUTN 5
+#define FADE_PARAM_LEN 20
+#define GRADE_PARAM_LEN 20
+#if 0
+enum aw_fade_time {
+	FADE_0_MS = 0x00,
+	FADE_256_MS = 0x09,
+	FADE_512_MS = 0x12,
+	FADE_1024_MS = 0x1b,
+	FADE_2048_MS = 0x24,
+	FADE_4096_MS = 0x2d,
+};
+enum aw_fullon_time {
+	FULLON_0_MS,
+	FULLON_256_MS,
+	FULLON_512_MS,
+	FULLON_1024_MS,
+	FULLON_2048_MS,
+	FULLON_4096_MS,
+	FULLON_8192_MS,
+	FULLON_16384_MS,
+};
+
+enum aw_fulloff_time {
+	FULLOFF_0_MS = 0x00,
+	FULLOFF_256_MS = 0x08,
+	FULLOFF_512_MS = 0x10,
+	FULLOFF_1024_MS = 0x18,
+	FULLOFF_2048_MS = 0x20,
+	FULLOFF_4096_MS = 0x28,
+	FULLOFF_8192_MS = 0x30,
+	FULLOFF_16384_MS = 0x38,
+};
+#endif
+enum aw_fade_time {
+	FADE_0_MS,
+	FADE_256_MS,
+	FADE_512_MS,
+	FADE_1024_MS,
+	FADE_2048_MS,
+	FADE_4096_MS,
+};
+enum aw_fullon_time {
+	FULLON_0_MS,
+	FULLON_256_MS,
+	FULLON_512_MS,
+	FULLON_1024_MS,
+	FULLON_2048_MS,
+	FULLON_4096_MS,
+	FULLON_8192_MS,
+	FULLON_16384_MS,
+};
+
+enum aw_fulloff_time {
+	FULLOFF_0_MS,
+	FULLOFF_256_MS,
+	FULLOFF_512_MS,
+	FULLOFF_1024_MS,
+	FULLOFF_2048_MS,
+	FULLOFF_4096_MS,
+	FULLOFF_8192_MS,
+	FULLOFF_16384_MS,
+};
+enum aw_max_current {
+	MAX_37_MA,
+	MAX_27_8__MA,
+	MAX_18_5__MA,
+	MAX_9_25__MA,
+};
+
+enum aw_ctl {
+	AW_CTL_DISABLE,
+	AW_CTL_ENABLE,
+};
+
+enum aw_reg_ctl {
+	REG_BIT_CLEAR,
+	REG_BIT_SET,
+};
+
+enum aw_gpio_led {
+	AW_LED_MODE,
+	AW_GPIO_MODE,
+};
+
+enum aw_smart_blink{
+	AW_SMART_MODE,
+	AW_BLINK_MODE,
+};
+
+enum aw_smart_fade{
+	AW_FADE_OFF,
+	AW_FADE_ON,
+};
+
+enum aw_led_close_mode{
+	AW_CLOSE_NOW,
+	AW_CLOSE_DELAY,
+};
+
+enum aw_power_state{
+	AW_POWER_DOWN,
+	AW_POWER_ON,
+};
+
+enum aw_out_val{
+	AW_OUT_LOW,
+	AW_OUT_HIGH,
+};
+
+enum aw_outn_mode{
+	AW_POWER_OFF,// 0
+	AW_CONST_ON,  // 1
+	AW_CONST_OFF, // 2
+	AW_FADE_AUTO, // 3 
+	AW_FADE_ON_STEP,  // 4
+	AW_FADE_OFF_STEP, // 5
+	AW_FADE_CYCLE, // 6
+	AW_RESERVED, //7
+};
+#if 0
+typedef struct {
+	enum aw_fade_time fade_t;
+	enum aw_fullon_time fullon_t;
+	enum aw_fulloff_time fulloff_t;
+	enum aw_max_current max_ma;
+} breath_config;
+
+typedef struct {
+	enum aw_fade_time fade_t;
+	enum aw_max_current max_ma;
+} smart_config;
+
+typedef struct  {
+	breath_config breath_t[3];
+	smart_config  smart_t[2];
+} aw9106b_config_param;
+#endif
+typedef struct {
+	u16 in_mode;
+	u16 dim_grade;
+	u16 grade_updown;
+} fade_data;
+
+static int debug_mask = 0;
+module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
+#define AW_DBG(x...) do {if (debug_mask) pr_info("aw9106b  " x); } while (0)
+
+static int max_current = MAX_9_25__MA;
+module_param(max_current, int, 0644);
+
+static int min_grade = CONST_MIN_GRADE;
+static int max_grade = CONST_MAX_GRADE;
+static int start_grade = CONST_MIN_GRADE;
+static char grade_parameter[GRADE_PARAM_LEN];
+
+static int fade_time= FADE_2048_MS;
+static int fullon_time= FULLON_0_MS;
+static int fulloff_time= FULLOFF_4096_MS;
+static char fade_parameter[FADE_PARAM_LEN];
+
+static int outn = 0;
+static u16 aw_running = 0;
+static int timer_running = 0;
+static int fade_outn = 0;
+fade_data fade[6];
+struct aw9106b_plat_data aw9106b_data;
+static struct aw9106b_regs_data aw9106b_regs = 
+{
+	.en_bre = 0x14 ,
+	.smart_blink = 0x05,
+	.in_out = 0x05,
+	.out_val = 0x03,
+	.smart_fade = 0x03,
+	.led_gpio = 0x13,
+	.fade_tmr = 0x15,
+	.full_tmr = 0x16,
+	.delay_bre0 = 0x17,
+	.dim0 = 0x20,
+	.aw_reset = 0x7f,
+	.ctl = 0x11,
+};
+#if 0
+aw9106b_config_param aw_config = {
+	.breath_t = {
+		{FADE_2048_MS,FULLON_0_MS,FULLOFF_4096_MS,MAX_9_25__MA},
+		{FADE_2048_MS,FULLON_0_MS,FULLOFF_4096_MS,MAX_9_25__MA},
+		{FADE_1024_MS,FULLON_0_MS,FULLOFF_2048_MS,MAX_9_25__MA}
+	},
+	.smart_t ={
+		{FADE_2048_MS,MAX_9_25__MA},
+		{FADE_2048_MS,MAX_9_25__MA}
+	},
+};
+#endif
+#ifdef CONFIG_OF
+static struct of_device_id aw_9106b_match_table[] = {
+	{ .compatible = "aw,9106b", },
+	{}
+};
+#endif
+
+/******************************************************** 
+ *					 I2C I/O function 				              *
+ *********************************************************/
+
+//read aw9106b i2c function
+static int aw9106b_i2c_rx_byte_data(
+		struct i2c_client *i2c,
+		unsigned char  reg,
+		unsigned char* buf)
+{
+
+	struct i2c_msg msgs[2];
+
+	//write message: this is the sub address that we are reading from
+	msgs[0].addr = i2c->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = 1;
+	msgs[0].buf = &reg;
+
+	//read message: now we read into the buffer
+	msgs[1].addr = i2c->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = 1;
+	msgs[1].buf = buf;
+
+	if (i2c_transfer(i2c->adapter, msgs, 2) < 0) {
+		dev_err(&i2c->dev, "%s: transfer failed.\n", __func__);
+		return -4;
+	}
+	pr_debug("return  buf[0]=0x%x!\n",buf[0]);
+
+	return 0;
+}
+
+//write aw9106b i2c function
+static int aw9106b_i2c_tx_byte_data(
+		struct i2c_client *i2c,
+		unsigned char reg, 
+		unsigned char buf)
+{
+	struct i2c_msg msgs;
+	char bufwr[2];
+
+	bufwr[0] = reg;
+	bufwr[1] = buf;
+
+	//write message: this is the sub address that we are reading from
+	msgs.addr = i2c->addr;
+	msgs.flags = 0;
+	msgs.len = 2;
+	msgs.buf = bufwr;
+
+	if (i2c_transfer(i2c->adapter, &msgs, 1) < 0) {
+		dev_err(&i2c->dev, "%s: transfer failed.\n", __func__);
+		return -4;
+	}
+
+	return 0;
+}
+
+//modigy aw9106b i2c function
+static int aw9106b_modify_regs(int reg,char bitn,enum aw_reg_ctl set)
+{
+	char buf = 0;
+	int ret;
+
+	ret = aw9106b_i2c_rx_byte_data(aw9106b_data.i2c_client,reg,&buf);
+	if(ret < 0)
+		pr_err("%s: read reg[0x%x] fail!\n",__func__,reg);
+
+	if(set == REG_BIT_SET)
+		buf |= (0x01 << bitn);
+	else
+		buf &= ~(0x01 << bitn);
+
+	ret = aw9106b_i2c_tx_byte_data(aw9106b_data.i2c_client,reg,buf);
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,reg);
+
+	return ret;
+
+}
+
+static void aw9106b_power_set(enum aw_power_state power_set)
+{
+	gpio_set_value(GPIO_PWDN, power_set);
+	AW_DBG("aw9106b_power_set = %d,GPIO_PWDN = %d\n", power_set,GPIO_PWDN);
+}
+
+static int set_fade_time(int fade_t)
+{
+	char buf;
+	int ret;
+
+	buf = fade_t;
+	ret = aw9106b_i2c_tx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.fade_tmr,buf);
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,aw9106b_regs.fade_tmr);
+
+	return ret;
+}
+
+static int set_full_onoff_time(int full_on, int full_off)
+{
+	char buf;
+	int ret;
+
+	buf = full_on | full_off;
+
+	ret = aw9106b_i2c_tx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.full_tmr,buf);
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,aw9106b_regs.full_tmr);
+	return ret;
+}
+/******************************************************** 
+ *                                Config AW Outn mode                                 *
+ *********************************************************/
+
+static int set_out_led_gpio(int out,enum aw_gpio_led gpmd_mode)
+{
+	enum aw_reg_ctl set;
+	int ret;
+	int reg;
+	int shift;
+
+	if( out <= AW_OUT_3 ){
+		reg = aw9106b_regs.led_gpio;
+		shift = out;
+	}
+	else{
+		reg = 0x12;
+		shift = out - AW_OUT_4;
+	}
+
+	if(gpmd_mode == AW_LED_MODE)
+		set = REG_BIT_CLEAR;
+	else
+		set = REG_BIT_SET;
+
+	ret = aw9106b_modify_regs(reg,shift,set);
+
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,reg);
+	return ret;
+}
+
+static int set_out_breath(int out,enum aw_ctl enable)
+{
+	enum aw_reg_ctl set;
+	int ret;
+	int reg;
+
+	reg = aw9106b_regs.en_bre;
+	if( enable == AW_CTL_DISABLE )
+		set = REG_BIT_CLEAR;
+	else
+		set = REG_BIT_SET;
+
+	ret = aw9106b_modify_regs(reg,out,set);
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,reg);
+	return ret;
+}
+
+static int set_out_smart_blink(int out,enum aw_smart_blink blink_cfg)
+{
+	enum aw_reg_ctl set;
+	int ret;
+	int reg;
+	int shift;
+
+	if( out <= AW_OUT_3 ){
+		reg = aw9106b_regs.smart_blink;
+		shift = out;
+	}
+	else{
+		reg = 0x04;
+		shift = out - AW_OUT_4;
+	}
+
+	if(blink_cfg == AW_SMART_MODE)
+		set = REG_BIT_CLEAR;
+	else
+		set = REG_BIT_SET;
+
+	ret = aw9106b_modify_regs(reg,shift,set);
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,reg);
+	return ret;
+}
+
+static int set_out_smart_fade(int out,enum aw_smart_fade fade_onoff)
+{
+	enum aw_reg_ctl set;
+	int ret;
+	int reg;
+	int shift;
+
+	if( out <= AW_OUT_3 ){
+		reg = aw9106b_regs.smart_fade;
+		shift = out;
+	}
+	else{
+		reg = 0x02;
+		shift = out - AW_OUT_4;
+	}
+
+	if(fade_onoff == AW_FADE_OFF)
+		set = REG_BIT_CLEAR;
+	else
+		set = REG_BIT_SET;
+
+	ret = aw9106b_modify_regs(reg,shift,set);
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,reg);
+	return ret;
+}
+
+static int set_out_delay_time(int out,int delay_unit)
+{
+	char buf;
+	int ret;
+	int reg;
+
+	reg = aw9106b_regs.delay_bre0 + out;
+
+	buf = delay_unit;
+
+	ret = aw9106b_i2c_tx_byte_data(aw9106b_data.i2c_client,reg,buf);
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,reg);
+	return ret;
+}
+
+static int set_out_dim_grade(int out,char grade)
+{
+	char buf;
+	int ret;
+	int reg;
+
+	reg = aw9106b_regs.dim0 + out;
+
+	buf = grade;
+
+	ret = aw9106b_i2c_tx_byte_data(aw9106b_data.i2c_client,reg,buf);
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,reg);
+	return ret;
+}
+
+static int set_const_current(enum aw_max_current max_i)
+{
+	char buf;
+	int ret;
+
+	buf = max_i;
+
+	ret = aw9106b_i2c_tx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.ctl,buf);
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,aw9106b_regs.ctl);
+	return ret;
+}
+
+static int start_blink_led(enum aw_max_current max_i)
+{
+	char buf;
+	int ret;
+
+	buf = max_i | 0x80;
+
+	ret = aw9106b_i2c_tx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.ctl,buf);
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,aw9106b_regs.ctl);
+	return ret;
+}
+
+static int close_out_blink_led(enum aw_led_close_mode close_mode)
+{
+	char buf;
+	int ret;
+
+	buf = 0;
+
+	if(close_mode == AW_CLOSE_NOW)
+		ret = aw9106b_i2c_tx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.en_bre,buf);
+	else
+		ret = aw9106b_i2c_tx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.smart_blink,buf);
+
+
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,aw9106b_regs.ctl);
+	return ret;
+}
+
+int aw_full_fade_time_confg(int fade_t,	int full_on, int full_off)
+{
+	int ret;
+	fade_t = (fade_t<<3) + fade_t;
+	full_off = full_off<<3;
+	AW_DBG("fade_t= %d, full_on=%d full_off=%d\n",fade_t,full_on,full_off);
+	ret = set_fade_time(fade_t);
+	if(ret < 0)
+		pr_err("%s: config fade time  fail!\n",__func__);
+
+	ret = set_full_onoff_time(full_on,full_off);
+	if(ret < 0)
+		pr_err("%s: config full time fail!\n",__func__);
+
+	return ret;
+}
+
+static void aw9106b_control_init(void)
+{
+	outn = 0;
+	aw_running = 0;
+}
+
+static void aw9106b_fade_data_init(void)
+{
+	int i;
+
+	for(i=0; i<6;i++){
+		fade[i].in_mode = 0;
+		fade[i].dim_grade = 0;
+		fade[i].grade_updown = 1;
+	}
+	timer_running = 0;
+	fade_outn = 0;
+}
+
+static int aw9106b_solft_reset(void)
+{
+	char buf;
+	int ret;
+	buf = 0x00;
+
+	ret = aw9106b_i2c_tx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.aw_reset,buf);
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,aw9106b_regs.aw_reset);
+	return ret;
+}
+
+#ifdef AW_GPIO_CONFIG
+static int set_out0_gpio_value(enum aw_out_val out_val)
+{
+	char buf;
+	int ret;
+
+	buf = out_val;
+
+	ret = aw9106b_i2c_tx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.out_val,buf);
+	if(ret < 0)
+		pr_err("%s: write out_val[0x%x] fail!\n",__func__,aw9106b_regs.out_val);
+	return ret;
+}
+int enable_out0_gpio(enum aw_out_val out_val)
+{
+
+	int ret;
+	//power on aw9106b
+	aw9106b_power_set(AW_POWER_ON);
+
+	ret = set_out_led_gpio(aw9106b_data.outn ,AW_GPIO_MODE);
+	if(ret < 0)
+		pr_err("%s: config fade time  fail!\n",__func__);
+
+	ret = set_out0_gpio_value(out_val);
+	if(ret < 0)
+		pr_err("%s: config fade time  fail!\n",__func__);
+
+	return ret;
+}
+
+#endif 
+
+void enable_outn_fade_onoff(int val, int max_ma, enum aw_smart_fade fade_onoff)
+{
+	int rc = 0;
+	int n = 0;
+
+	for(n = START_OUTN; n <= END_OUTN; n++){
+		if((outn & (1<<n))&&(fade[n].in_mode != val)){
+			//store the corrent mode
+			fade[n].in_mode = val;
+
+			if(fade_onoff == AW_FADE_ON){
+				rc = set_out_breath(n,AW_CTL_DISABLE);
+				if(rc < 0)
+					pr_err("%s: diable out[%d] breath mode fail!\n",__func__,n);
+			}
+
+			//set fade,fullon,fulloff time
+			rc = aw_full_fade_time_confg(fade_time,FULLON_0_MS,FULLOFF_0_MS);
+			if(rc < 0)
+				pr_err("%s: config fade full on/off time fail!\n",__func__);
+
+			//set outn led mode
+			rc = set_out_led_gpio(n,AW_LED_MODE);
+			if(rc < 0)
+				pr_err("%s: set out[%d] LED mode fail!\n",__func__,n);
+
+			//enable outn breath func
+			rc = set_out_breath(n,AW_CTL_ENABLE);
+			if(rc < 0)
+				pr_err("%s: set out[%d] breath mode fail!\n",__func__,n);
+
+			//set outn blink
+			rc = set_out_smart_blink(n,AW_SMART_MODE);
+			if(rc < 0)
+				pr_err("%s: set out smart-fade mode fail!\n",__func__);
+
+			//set Imax
+			rc = set_const_current(max_ma);
+			if(rc < 0)
+				pr_err("%s: set imax fail!\n",__func__);
+
+			//set outn delay time
+			rc = set_out_delay_time(n,0*DELAY_256MS_UNIT);
+			if(rc < 0)
+				pr_err("%s: set out delay time fail!\n",__func__);
+
+			//set outn smart fade
+			rc = set_out_smart_fade(n,fade_onoff);
+			if(rc < 0)
+				pr_err("%s: start samrt-fade mode fail!\n",__func__);
+		}
+		outn &= ~(1<<n);
+		AW_DBG("fade_onoff outn= 0x%x\n",outn);
+	}
+}
+
+
+void enable_outn_const_led(int val,int max_ma, char grade)
+
+{
+
+	int rc = 0;
+	int n = 0;
+
+	for(n = START_OUTN; n <= END_OUTN; n++){
+		if((outn & (1<<n)&&(fade[n].in_mode != val))){
+			//store the corrent mode
+			fade[n].in_mode = val;
+
+			//disable breathing mode
+			rc = set_out_breath(n,AW_CTL_DISABLE);
+			if(rc < 0)
+				pr_err("%s: set out[%d] breath mode fail!\n",__func__,n);
+
+			//set outn led mode
+			rc = set_out_led_gpio(n,AW_LED_MODE);
+			if(rc < 0)
+				pr_err("%s: set out[%d] LED mode fail!\n",__func__,n);
+
+			//set Imax
+			rc = set_const_current(max_ma);
+			if(rc < 0)
+				pr_err("%s: set imax fail!\n",__func__);
+
+			//set const current = (grade/256)*imax
+			rc = set_out_dim_grade(n,grade);
+			if(rc < 0)
+				pr_err("%s: set out[%d] dim grade fail!\n",__func__,n);
+		}
+
+		//clean the corresponding bit of outn
+		outn &= ~(1<<n);
+		AW_DBG("const_led outn= 0x%x\n",outn);
+	}
+}
+
+
+void enable_outn_blink_led(int val, int max_ma)
+
+{
+	int rc = 0;
+	int n = 0;
+
+	aw9106b_fade_data_init();
+	rc = aw9106b_solft_reset();
+	if(rc < 0)
+		pr_err("%s: solft reset fail!\n",__func__);
+
+	for(n = START_OUTN; n <= END_OUTN; n++){
+		if((outn & (1<<n))&&(fade[n].in_mode != val)){
+			//store the corrent mode
+			fade[n].in_mode = val;
+
+			//set fade,fullon,fulloff time
+			rc = aw_full_fade_time_confg(fade_time,fullon_time,fulloff_time);
+			if(rc < 0)
+				pr_err("%s: config fade full on/off time fail!\n",__func__);
+
+			//set outn led mode
+			rc = set_out_led_gpio(n,AW_LED_MODE);
+			if(rc < 0)
+				pr_err("%s: set out[%d] LED mode fail!\n",__func__,n);
+
+			//enable outn breath func
+			rc = set_out_breath(n,AW_CTL_ENABLE);
+			if(rc < 0)
+				pr_err("%s: set out[%d] breath mode fail!\n",__func__,n);
+
+			//set outn blink
+			rc = set_out_smart_blink(n,AW_BLINK_MODE);
+			if(rc < 0)
+				pr_err("%s: set out[%d] blink mode fail!\n",__func__,n);
+
+			//set outn delay time
+			rc = set_out_delay_time(n,0*DELAY_256MS_UNIT);
+			if(rc < 0)
+				pr_err("%s: set out[%d] delay time fail!\n",__func__,n);
+		}
+
+		//clean the corresponding bit of outn
+		outn &= ~(1<<n);
+		AW_DBG("blink_led outn= 0x%x\n",outn);
+	}
+
+	//start outn blink led
+	rc |= start_blink_led(max_ma);
+	if(rc < 0)
+		pr_err("%s: start blink fail!\n",__func__);
+}
+
+
+
+static void aw9106b_work_func(struct work_struct *work)
+
+{
+
+	int rc;
+	int n;
+
+	for(n = START_OUTN; n <= END_OUTN; n++){
+		if(fade_outn & (1<<n)){
+			if(fade[n].in_mode != AW_FADE_CYCLE){
+				//first time to set fade mode for this channel,disable breathing mode
+				rc = set_out_breath(n,AW_CTL_DISABLE);
+
+				//set outn led mode
+				rc |= set_out_led_gpio(n,AW_LED_MODE);
+
+				//set Imax
+				rc |= set_const_current(max_current);
+				if(rc < 0)
+					pr_err("%s: set imax fail!\n",__func__);
+
+				fade[n].in_mode = AW_FADE_CYCLE;
+				fade[n].dim_grade = min_grade;
+				fade[n].grade_updown = 1;
+				timer_running |= (1<<n);
+				AW_DBG("work_func:timer_running = 0x%x\n", timer_running);
+			}
+
+			if(fade[n].dim_grade == 0)
+				fade[n].dim_grade = start_grade;
+
+			if(fade[n].grade_updown == 1 && fade[n].dim_grade < max_grade)
+				fade[n].dim_grade++;
+			else if(fade[n].grade_updown == 2 && fade[n].dim_grade>min_grade)
+				fade[n].dim_grade--;
+
+			rc = set_out_dim_grade(n,fade[n].dim_grade);
+			if(rc < 0){
+				fade[n].in_mode = AW_CONST_ON;
+				fade[n].dim_grade = 0;
+				fade[n].grade_updown = 1;
+				timer_running &=~(1<<n);
+				fade_outn &=~(1<<n);
+				pr_err("%s: set out dim grade fail!\n",__func__);
+				return;
+			}
+
+			if(fade[n].grade_updown == 1 && fade[n].dim_grade>=max_grade)
+				fade[n].grade_updown = 2;
+
+			else if(fade[n].grade_updown == 2 && fade[n].dim_grade <= min_grade){
+				//fade cycle finish
+				fade[n].dim_grade = 0;
+				fade[n].in_mode = AW_CONST_ON;
+				fade[n].grade_updown = 1;
+				timer_running &=~(1<<n);
+				fade_outn &=~(1<<n);
+				AW_DBG("work_func:timer_running = 0x%x, fade_outn = 0x%x\n",timer_running, fade_outn);
+				AW_DBG("%s: end breath!\n",__func__);
+			}
+
+			if((timer_running & 0x3f) !=0)
+				hrtimer_start(&aw9106b_data.timer,ktime_set(0,1*TIME_MS_UNIT),HRTIMER_MODE_REL);
+		}
+	}
+}
+
+
+static enum hrtimer_restart aw9106b_timer(struct hrtimer *timer)
+
+{
+	schedule_work(&aw9106b_data.work);
+	return HRTIMER_NORESTART;
+}
+
+/*********************       aw9106b_breath_mode_set    *********************/
+
+void aw9106b_breath_mode_set(struct led_classdev *led_cdev,
+
+		enum led_brightness brightness)
+
+{
+	int val = brightness;
+	int rc = 0;
+	if(AW9106B_SUSPEND_FLAG==true)return;
+
+	gpio_tlmm_config(GPIO_CFG(GPIO_PWDN, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),GPIO_CFG_ENABLE);
+	AW_DBG("val=%d fade_outn= 0x%x, outn= 0x%x \n",val,fade_outn, outn);
+
+	if (aw_running == 0 && val != AW_POWER_OFF) { 
+		aw9106b_power_set(AW_POWER_ON);
+		rc = aw9106b_solft_reset();
+		if(rc < 0)
+			pr_err("%s: solft reset fail!\n",__func__);
+		aw_running = 1;
+	}
+
+	switch (val) {
+		case AW_POWER_OFF:
+			aw9106b_fade_data_init();
+			aw9106b_control_init();
+			aw9106b_power_set(AW_POWER_DOWN);
+			break;
+
+		case AW_CONST_ON: 
+			enable_outn_const_led(val, max_current, min_grade);
+			break;
+
+		case AW_CONST_OFF:
+			enable_outn_const_led(val, max_current, 0);
+			break;
+
+			//blink breath mode
+		case AW_FADE_AUTO:
+			enable_outn_blink_led(val, max_current);
+			break;
+
+			//smart breath mode
+		case AW_FADE_ON_STEP:
+			enable_outn_fade_onoff(val, max_current,AW_FADE_ON);
+			break;
+
+		case AW_FADE_OFF_STEP:
+			enable_outn_fade_onoff(val,max_current,AW_FADE_OFF);
+			break;
+
+			//fade 1 cycle for press home key
+		case AW_FADE_CYCLE:
+			fade_outn |= outn;
+			if((timer_running & 0x3f) == 0){
+				AW_DBG("timer_running = 0x%x, start fade mode.\n",timer_running);
+				hrtimer_start(&aw9106b_data.timer,ktime_set(0,0),HRTIMER_MODE_REL);
+			}
+			break;
+
+		case AW_RESERVED:
+			break;
+
+		default:
+			break;
+
+	}
+}
+
+EXPORT_SYMBOL_GPL(aw9106b_breath_mode_set);
+
+
+static void aw9106b_show_regs(void)
+
+{
+	char buf[1];
+
+	//read EN_BRE
+	buf[0] = 0x0;
+	aw9106b_i2c_rx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.en_bre,buf);
+	printk("read  en_bre[0x%x]= 0x%x\n",aw9106b_regs.en_bre,buf[0]);
+
+	//set led_gpio 
+	buf[0] = 0x0;
+	aw9106b_i2c_rx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.led_gpio,buf);
+	printk("read  led_gpio[0x%x] = 0x%x\n",aw9106b_regs.led_gpio,buf[0]);
+
+	//set BLINK 
+	buf[0] = 0x0;
+	aw9106b_i2c_rx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.smart_blink,buf);
+	printk("read  smart_blink[0x%x] = 0x%x\n",aw9106b_regs.smart_blink,buf[0]);
+
+	//set delay time 
+	buf[0] = 0x0;
+	aw9106b_i2c_rx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.delay_bre0,buf);
+	printk("read  delay_bre0[0x%x] = 0x%x\n",aw9106b_regs.delay_bre0,buf[0]);
+
+	//set flade time 
+	buf[0] = 0x0;
+	aw9106b_i2c_rx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.fade_tmr,buf);
+	printk("read  fade_tmr[0x%x] = 0x%x\n",aw9106b_regs.fade_tmr,buf[0]);
+
+	//set full on and off  time 
+	buf[0] = 0x0;
+	aw9106b_i2c_rx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.full_tmr,buf);
+	printk("read  full_tmr[0x%x] = 0x%x\n",aw9106b_regs.full_tmr,buf[0]);
+
+	//set gpio in and out 
+	buf[0] = 0x0;
+	aw9106b_i2c_rx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.in_out,buf);
+	printk("read  in_out[0x%x] = 0x%x\n",aw9106b_regs.in_out,buf[0]);
+
+	//start
+	buf[0] = 0x0;
+	aw9106b_i2c_rx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.ctl,buf);
+	printk("read  ctl[0x%x] = 0x%x\n",aw9106b_regs.ctl,buf[0]);
+}
+
+//fade_parameter
+static ssize_t show_fade_parameter(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+
+	snprintf(fade_parameter, FADE_PARAM_LEN,	"%4d %4d %4d\n",
+			fade_time, fullon_time, fulloff_time);
+
+	return sprintf(buf, "%s\n", fade_parameter);
+}
+
+static ssize_t set_fade_parameter(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+
+	strncpy(fade_parameter, buf, FADE_PARAM_LEN);
+	sscanf(fade_parameter, "%d %d %d", &fade_time, &fullon_time, &fulloff_time);
+	AW_DBG("fade_time= %d, fullon_time=%d fulloff_time=%d\n",fade_time,fullon_time,fulloff_time);
+
+	return count;
+}
+
+//path: sys/class/leds/red/
+const static DEVICE_ATTR(fade_parameter, S_IRUGO | S_IWUSR,
+		show_fade_parameter, set_fade_parameter);
+
+//grade_parameter
+static ssize_t show_grade_parameter(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+
+	snprintf(grade_parameter, GRADE_PARAM_LEN,	"%4d %4d\n",
+			min_grade, max_grade);
+
+	return sprintf(buf, "%s\n", grade_parameter);
+}
+
+static ssize_t set_grade_parameter(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+
+	strncpy(grade_parameter, buf, GRADE_PARAM_LEN);
+	sscanf(grade_parameter, "%d %d", &min_grade, &max_grade);
+	AW_DBG("min_grade= %d, max_grade=%d \n",min_grade,max_grade);
+
+	return count;
+}
+//path: sys/class/leds/red/
+const static DEVICE_ATTR(grade_parameter, S_IRUGO | S_IWUSR,
+		show_grade_parameter, set_grade_parameter);
+
+
+//out_n
+static ssize_t show_outn(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+
+	return sprintf(buf, "%d\n", outn);
+}
+
+static ssize_t set_outn(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+
+	sscanf(buf, "%d", &outn);
+	AW_DBG("outn= %d \n",outn);
+
+#ifdef CONFIG_ZTEMT_BREATH_LED_NX503A
+    if(outn==16)outn=8;
+#endif
+	return count;
+}
+//path: sys/class/leds/red/
+const static DEVICE_ATTR(outn, S_IRUGO | S_IWUSR,
+		show_outn, set_outn);
+
+#if 0
+static int store_outn(const char *val, struct kernel_param *kp)
+
+{
+	int ret = 0;
+	ret = param_set_int(val, kp);
+	if (ret) {
+		pr_err("error setting value %d\n", ret);
+		return ret;
+	}
+	return ret;
+}
+module_param_call(outn, store_outn, param_get_uint,
+		&outn, 0644);
+#endif
+static int led_config;
+static int set_led_mode(const char *val, struct kernel_param *kp)
+
+{
+	int ret;
+	int rc = 0;
+
+	ret = param_set_int(val, kp);
+	if (ret) {
+		pr_err("error setting value %d\n", ret);
+		return ret;
+	}
+
+	printk("__%s: led_config=%d!\n",__func__,led_config);
+
+	switch(led_config){
+		case 0:
+			aw9106b_power_set(AW_POWER_DOWN);
+			break;
+
+		case 1:
+			outn = AW_OUT_0;
+			break;
+
+		case 2:
+			outn = AW_OUT_1;
+			break;
+
+		case 3:
+			aw9106b_show_regs();
+			break;
+
+		case 4:
+			enable_outn_const_led(AW_CONST_ON, MAX_18_5__MA,min_grade);
+			break;
+
+		case 5:
+			enable_outn_blink_led(AW_FADE_AUTO,max_current);
+			rc |= start_blink_led(max_current);
+			if(rc < 0)
+				pr_err("%s: start blink fail!\n",__func__);
+			break;
+
+		case 6:
+			close_out_blink_led(AW_CLOSE_NOW);
+			break;
+
+		case 7:
+			close_out_blink_led(AW_CLOSE_DELAY);
+			break;
+
+		default:
+			break;
+	};
+	return 0;
+}
+
+module_param_call(led_config, set_led_mode, param_get_uint,
+		&led_config, 0644);
+
+
+static struct led_classdev breath_led = {
+	.name		= "red",
+	.brightness_set	= aw9106b_breath_mode_set,
+};
+
+
+static int  aw9106b_probe(struct i2c_client *client,
+
+		const struct i2c_device_id *dev_id)
+
+{
+	int ret = 0;
+
+	printk("%s: start probe:\n",__func__);
+
+	aw9106b_data.i2c_client = client;
+	ret = led_classdev_register(NULL, &breath_led);
+	if (ret) {
+		pr_err("unable to register breath_led ret=%d\n",ret);
+		goto init_fail;
+	}
+
+	ret = device_create_file(breath_led.dev, &dev_attr_fade_parameter);
+	if (unlikely(ret < 0)) {
+		dev_err(breath_led.dev, "failed: cannot create fade_parameter.\n");
+	}
+
+	ret = device_create_file(breath_led.dev, &dev_attr_grade_parameter);
+	if (unlikely(ret < 0)) {
+		dev_err(breath_led.dev, "failed: cannot create grade_parameter.\n");
+	}
+
+	ret = device_create_file(breath_led.dev, &dev_attr_outn);
+	if (unlikely(ret < 0)) {
+		dev_err(breath_led.dev, "failed: cannot create outn.\n");
+	}
+
+	INIT_WORK(&aw9106b_data.work, aw9106b_work_func);
+
+	hrtimer_init(&aw9106b_data.timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	aw9106b_data.timer.function = aw9106b_timer;
+
+	aw9106b_fade_data_init();
+	aw9106b_control_init();
+
+	ret = gpio_request(GPIO_PWDN, "aw9106b_shdn");
+	if (ret) {
+		pr_err("%s: fail gpio_request(%d)=%d\n", __func__,GPIO_PWDN, ret);
+	}
+	gpio_tlmm_config(GPIO_CFG(GPIO_PWDN, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),GPIO_CFG_ENABLE);
+
+	printk("%s: finish probe:\n",__func__);
+	return 0;
+
+init_fail:
+	return ret;
+
+}
+
+static int aw9106b_remove(struct i2c_client *client)
+{	
+	led_classdev_unregister(&breath_led);
+	gpio_free(GPIO_PWDN);
+	return 0;
+}
+
+static int aw9106b_suspend(struct i2c_client *cl, pm_message_t mesg)
+{
+    AW9106B_SUSPEND_FLAG=true;
+	return 0;
+};
+
+static int aw9106b_resume(struct i2c_client *cl)
+{   
+    AW9106B_SUSPEND_FLAG=false;
+	return 0;
+};
+
+
+static const struct i2c_device_id aw9106b_id[] = {
+	{ "aw_9106b", 1 },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, BQ27520_id);
+
+static struct i2c_driver aw9106b_driver = {
+	.driver = {
+		.name = "aw_9106b",
+#ifdef CONFIG_OF
+		.of_match_table = aw_9106b_match_table,
+#endif
+	},
+	.id_table 	= aw9106b_id,
+	.probe 		= aw9106b_probe,
+	.remove 	= aw9106b_remove,
+	.suspend	= aw9106b_suspend,
+	.resume 	= aw9106b_resume,
+};
+
+
+static int __init aw9106b_init(void)
+{
+	printk( "%s:enter...\n", __func__);
+	return i2c_add_driver(&aw9106b_driver);
+}
+
+static void __exit aw9106b_exit(void)
+{
+	printk( "%s:%d:aw9106b is exiting\n", __func__,__LINE__);
+	i2c_del_driver(&aw9106b_driver);
+}
+
+
+late_initcall(aw9106b_init);
+module_exit(aw9106b_exit);
+
+MODULE_VERSION("1.0");
+MODULE_AUTHOR("wangshuai <wang.shuai12@zte.com.cn>");
+MODULE_DESCRIPTION("aw9106b Linux driver");
+MODULE_ALIAS("platform:aw9106b");
+
diff --git a/drivers/hwmon/aw_9106b.h b/drivers/hwmon/aw_9106b.h
new file mode 100755
index 0000000..f581521
--- /dev/null
+++ b/drivers/hwmon/aw_9106b.h
@@ -0,0 +1,57 @@
+/* Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __AW_9106B_H__
+#define __AW_9106B_H__
+
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <mach/board.h>
+#include <linux/mfd/pm8xxx/pm8921-charger.h>
+
+#define AW_DEVICE_NAME "aw_9106b"
+
+enum aw_outn{
+	AW_OUT_0,
+	AW_OUT_1,
+	AW_OUT_2,
+	AW_OUT_3,
+	AW_OUT_4,
+	AW_OUT_5,
+};
+
+struct aw9106b_plat_data {
+	struct i2c_client *i2c_client;
+	struct i2c_driver *i2c_driver;
+	struct work_struct work;
+	struct hrtimer timer;
+};
+
+struct aw9106b_regs_data {
+	int en_bre;    //enable or disable breath func
+	int smart_blink;  //blink or smart-fade modle
+	int in_out;  //gpio in and out 
+	int out_val;
+	int smart_fade;
+	int led_gpio;  //led or gpio
+	int fade_tmr; //fade time
+	int full_tmr; //full light and black
+	int delay_bre0; //delay breath time
+	int dim0;
+	int aw_reset;
+	int ctl;  //set start blink
+};
+
+#endif /* __AW_9106B_H__ */
+
+
diff --git a/drivers/hwmon/maxq616.c b/drivers/hwmon/maxq616.c
new file mode 100755
index 0000000..015f45f
--- /dev/null
+++ b/drivers/hwmon/maxq616.c
@@ -0,0 +1,296 @@
+/******************** (C) COPYRIGHT 2013 STMicroelectronics ********************
+*
+* File Name          : maxq616.c
+* Authors            : Zhu Bing
+* Version            : V.1.0.0
+* Date               : 07/024/2013
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+********************************************************************************
+Version History.
+ 
+Revision 1-0-0 07/024/2013
+ first revision
+
+*******************************************************************************/
+ 
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kobject.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/miscdevice.h>
+#include <linux/regulator/consumer.h>
+#include <linux/err.h>
+#include <linux/of_gpio.h>
+#include <linux/pm_runtime.h>
+#include <linux/i2c/maxq616.h>
+
+
+#define LOG_TAG "IR_REMOTE"
+#define DEBUG_ON //DEBUG SWITCH
+
+#define SENSOR_LOG_FILE__ strrchr(__FILE__, '/') ? (strrchr(__FILE__, '/')+1) : __FILE__
+
+#ifdef  CONFIG_FEATURE_ZTEMT_SENSORS_LOG_ON
+#define SENSOR_LOG_ERROR(fmt, args...) printk(KERN_ERR   "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #ifdef  DEBUG_ON
+#define SENSOR_LOG_INFO(fmt, args...)  printk(KERN_INFO  "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+                                              
+#define SENSOR_LOG_DEBUG(fmt, args...) printk(KERN_DEBUG "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #else
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+    #endif
+
+#else
+#define SENSOR_LOG_ERROR(fmt, args...)
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+#endif
+
+
+static int maxq616_power_init(struct maxq616_chip *chip)
+{
+	int rc;
+
+    chip->power = regulator_get(&(chip->client->dev), "vdd-chip");
+
+	if (IS_ERR(chip->power))
+    {
+		rc = PTR_ERR(chip->power);
+		SENSOR_LOG_ERROR("Regulator get failed chip->power rc=%d\n", rc);
+		return rc;
+	}
+
+	if (regulator_count_voltages(chip->power) > 0)
+    {
+		rc = regulator_set_voltage(chip->power, 1800000, 1800000);
+		if (rc)
+        {
+			SENSOR_LOG_ERROR("Regulator set chip->power failed rc=%d\n", rc);
+			goto error_set_voltage;
+		}
+	}
+    
+    rc = regulator_set_optimum_mode(chip->power, 600000);
+    if (rc < 0)
+    {
+        SENSOR_LOG_ERROR("Regulator chip->power set_opt failed rc=%d\n", rc);
+        goto error_set_optimum;
+    }
+    
+    SENSOR_LOG_INFO("success\n");
+    return 0;
+
+error_set_optimum:
+    regulator_set_voltage(chip->power, 0, 1800000);
+    regulator_put(chip->power);
+
+error_set_voltage:
+	regulator_put(chip->power);
+    SENSOR_LOG_INFO("failed\n");
+	return rc;
+}
+
+
+
+static int maxq616_power_on(struct maxq616_chip *chip, bool enable)
+{
+	int rc;
+    if (enable == chip->power_on)
+    {
+        SENSOR_LOG_INFO("double %s power, retern here\n",enable? "enable" : "disable");
+        return 0;
+    }
+    else
+    {
+        SENSOR_LOG_INFO("%s power\n",enable? "enable" : "disable");
+    }
+
+    if (enable)
+    {
+        rc = regulator_enable(chip->power);
+        if (rc)
+        {
+            SENSOR_LOG_ERROR("Regulator chip->power enable failed rc=%d\n", rc);
+            goto err_power_enable_failed;
+        }
+        chip->power_on = true;
+    }
+    else
+    {
+        rc = regulator_disable(chip->power);
+        if (rc)
+        {
+            SENSOR_LOG_ERROR("Regulator chip->power enable failed rc=%d\n", rc);
+            goto err_power_disable_failed;
+        }
+        chip->power_on = false;
+    }
+    
+    return 0;
+
+err_power_enable_failed:
+err_power_disable_failed:
+    return rc;
+
+}
+
+static void maxq616_chip_data_init(struct maxq616_chip *chip)
+{
+    chip->power_on = false;
+}
+ 
+static int __devinit maxq616_probe(struct i2c_client *client,
+                  const struct i2c_device_id *id)
+{
+    static struct maxq616_chip *chip;
+    int ret;
+
+    SENSOR_LOG_INFO("prob start\n");
+
+    chip = kzalloc(sizeof(struct maxq616_chip), GFP_KERNEL);
+    if (!chip) {
+        ret = -ENOMEM;
+        goto malloc_chip_failed;
+    }
+
+    maxq616_chip_data_init(chip);
+
+    chip->client = client;
+    i2c_set_clientdata(client, chip);
+
+    maxq616_power_init(chip);
+
+    maxq616_power_on(chip, true);
+
+    SENSOR_LOG_INFO("prob success\n");
+
+    return 0;
+
+malloc_chip_failed:
+    SENSOR_LOG_INFO("prob failed\n");
+    return ret;
+}
+
+ 
+ /**
+  * maxq616_remove() - remove device
+  * @client: I2C client device
+  */
+ static int __devexit maxq616_remove(struct i2c_client *client)
+ {
+     struct maxq616_chip *chip = i2c_get_clientdata(client);
+     kfree(chip);
+     chip = NULL;
+     SENSOR_LOG_INFO("maxq616_remove\n");
+     return 0;
+ }
+
+
+//resume
+static int maxq616_resume(struct device *dev)
+{
+	struct maxq616_chip *chip = dev_get_drvdata(dev);
+    if (0)
+    {
+        SENSOR_LOG_INFO("enter\n");
+        maxq616_power_on(chip, true);
+        SENSOR_LOG_INFO("eixt\n");
+    }
+    return 0 ;
+}
+
+//suspend
+static int maxq616_suspend(struct device *dev)
+{
+	struct maxq616_chip *chip = dev_get_drvdata(dev);
+    if (0)
+    {
+        SENSOR_LOG_INFO("enter\n");
+        maxq616_power_on(chip, false);
+        SENSOR_LOG_INFO("eixt\n");
+    }
+    return 0 ;
+}
+
+static const struct dev_pm_ops maxq616_pm_ops = {
+    .suspend = maxq616_suspend,
+    .resume  = maxq616_resume,
+};
+
+
+static const struct i2c_device_id maxq616_idtable_id[] = {
+     { "uie,maxq616", 0 },
+     { },
+ };
+ 
+static struct of_device_id of_maxq616_idtable[] = {
+     { .compatible = "uei,maxq616",},
+     {}
+};
+ 
+ MODULE_DEVICE_TABLE(i2c, maxq616_idtable);
+ 
+ static struct i2c_driver maxq616_driver = {
+     .driver = {
+         .name = "maxq616",
+         .of_match_table = of_maxq616_idtable,
+         .pm = &maxq616_pm_ops,
+     },
+     .id_table = maxq616_idtable_id,
+     .probe = maxq616_probe,
+     .remove = __devexit_p(maxq616_remove),
+ };
+
+
+
+static int __init maxq616_init(void)
+{
+        SENSOR_LOG_INFO("driver: init\n");
+        return i2c_add_driver(&maxq616_driver);
+}
+ 
+static void __exit maxq616_exit(void)
+{
+        SENSOR_LOG_INFO("driver: exit\n");
+        i2c_del_driver(&maxq616_driver);
+}
+
+module_init(maxq616_init);
+module_exit(maxq616_exit);
+ 
+MODULE_DESCRIPTION("UEI maxq616 driver");
+MODULE_AUTHOR("ZhuBing, ZTEMT");
+MODULE_LICENSE("GPL");
diff --git a/drivers/hwmon/qpnp-adc-common.c b/drivers/hwmon/qpnp-adc-common.c
old mode 100644
new mode 100755
index 5847b4b..bc4456a
--- a/drivers/hwmon/qpnp-adc-common.c
+++ b/drivers/hwmon/qpnp-adc-common.c
@@ -44,6 +44,34 @@
    and provided to the battery driver in the units desired for
    their framework which is 0.1DegC. True resolution of 0.1DegC
    will result in the below table size to increase by 10 times */
+
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+static const struct qpnp_vadc_map_pt adcmap_btm_threshold[] = {
+	{-300, 1626},
+	{-250, 1573},
+	{-200, 1510},
+	{-150, 1438},
+	{-100, 1358},
+	{-50, 1274},
+	{0,   1188},
+	{50,  1103},
+	{100, 1022},
+	{150,  946},
+	{200,  877},
+	{250,  816},
+	{300,  763},
+	{350,  718},
+	{400,  679},
+	{450,  647},
+	{500,  619},
+	{550,  596},
+	{600,  577},
+	{650,  561},
+	{700,  548},
+	{750,  537},
+	{800,  528}
+};
+#else
 static const struct qpnp_vadc_map_pt adcmap_btm_threshold[] = {
 	{-300,	1642},
 	{-200,	1544},
@@ -129,7 +157,7 @@ static const struct qpnp_vadc_map_pt adcmap_btm_threshold[] = {
 	{780,	208},
 	{790,	203}
 };
-
+#endif
 static const struct qpnp_vadc_map_pt adcmap_qrd_btm_threshold[] = {
 	{-200,	1540},
 	{-180,	1517},
diff --git a/drivers/hwmon/qpnp-device-info.c b/drivers/hwmon/qpnp-device-info.c
new file mode 100755
index 0000000..36e6d95
--- /dev/null
+++ b/drivers/hwmon/qpnp-device-info.c
@@ -0,0 +1,497 @@
+/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) "%s: " fmt, __func__
+
+#include <linux/kernel.h>
+#include <linux/of.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/mutex.h>
+#include <linux/types.h>
+#include <linux/hwmon.h>
+#include <linux/module.h>
+#include <linux/debugfs.h>
+#include <linux/spmi.h>
+#include <linux/of_irq.h>
+#include <linux/interrupt.h>
+#include <linux/completion.h>
+#include <linux/qpnp/qpnp-adc.h>
+#include <linux/platform_device.h>
+#include <linux/qpnp/qpnp-device-info.h>
+
+#define QPNP_ZTEMT_HW_VERSION_DEV_NAME	"qcom,qpnp-ztemt_hw_version"
+
+/**
+ * struct qpnp_chg_chip - device information
+ * @dev:			device pointer to access the parent
+ * @spmi:			spmi pointer to access spmi information
+ */
+struct qpnp_ztemt_hw_version_chip {
+	struct device	     *dev;
+	struct spmi_device	 *spmi;
+	struct work_struct	 work;
+	struct mutex	     lock;
+};
+
+static struct qpnp_vadc_chip* g_vadc_dev = NULL;
+
+static int debug_device_info_mask = 1;
+module_param_named(debug_device_info_mask, debug_device_info_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
+#define DBG_DEVICE_INFO(x...) do {if (debug_device_info_mask) pr_info(">>ZTEMT_DEVICE_INFO>>  " x); } while (0)
+
+//
+#define DEBUG 
+#undef KERN_DEBUG
+#define KERN_DEBUG KERN_ERR
+
+#undef KERN_INFO
+#define KERN_INFO KERN_ERR
+
+#define ADC_PROJECT_ID  LR_MUX5_AMUX_THM2
+#define ADC_HW_ID       LR_MUX4_AMUX_THM1
+
+
+#define PROJECT_ID_MAX   5
+#define HRADWARE_ID_MAX  5
+struct hardware_id_map_st hardware_id_map[PROJECT_ID_MAX][HRADWARE_ID_MAX] = {
+  {
+  	{0, 	0,		Z5S_HW_INVALID,	"unknow" ,DEVICE_INDEX_INVALID,"JD"},  //id_mv=0
+	},
+			//0V
+	{
+		{0, 	0,		Z5S_HW_INVALID,	"unknow" ,DEVICE_INDEX_INVALID,"JD"},  //id_mv=0
+		{0, 	150,		Z5S_HW_01AMB_B,	"QB8974_01AMB_B" ,DEVICE_01AMB_B_BCM4339,"SC"},  //id_mv=0
+		{750, 	1050,	Z5S_HW_01AMB_D,	"QB8974_01AMB_D", DEVICE_01AMB_D,"JD"},  //id_mv= 0.9V
+		{1650, 	1950,	Z5S_HW_01AMB_C,	"QB8974_01AMB_C", DEVICE_01AMB_C,"JD"}  //id_mv= 1.8V
+  },
+  			//0.3V
+	{
+		{0, 	0,		Z5S_HW_INVALID,	"unknow" ,DEVICE_INDEX_INVALID,"JD"},  //id_mv=0
+		{0, 	150,		Z5S_HW_01AMB_B,	"QB8974_01AMB_B" ,DEVICE_01AMB_B_BCM4339,"SC"},  //id_mv=0
+		{750, 	1050,	Z5S_HW_01AMB_D,	"QB8974_01AMB_D", DEVICE_01AMB_D,"JD"},  //id_mv= 0.9V
+		{1650, 	1950,	Z5S_HW_01AMB_C,	"QB8974_01AMB_C", DEVICE_01AMB_C,"JD"}  //id_mv= 1.8V
+  },
+  //0.9V
+  {
+  {0, 	0,		Z5S_HW_INVALID,	"unknow" ,DEVICE_INDEX_INVALID,"JD"},  //id_mv=0
+		{0, 	150,		Z5S_HW_01AMB_B_SIMPLIFY,	"QB8974_01AMB_B_SIMPLIFY",DEVICE_01AMB_B_WTR1605_L_EMMC_16_32,"JD"},  //id_mv=0
+		{750, 	1050,	Z5S_HW_P3,	"QB8974_P3",DEVICE_PCB3,"JD"},  //id_mv= 
+		{1650, 	1950,	Z5S_HW_P2,	"QB8974_P2",DEVICE_PCB2,"JD"}  //id_mv=
+  },
+  ///1.8V
+	{	
+	 {0, 	0,		Z5S_HW_INVALID,	"unknow" ,DEVICE_INDEX_INVALID,"JD"},  //id_mv=0
+		{0, 150,	Z5S_HW_01AMBC_A,		"QB8974_01AMBC_A", DEVICE_01AMBC_A_3680,"JD"},  //id_mv=0
+		{750, 1050,		Z5S_HW_01AMBC_C,		"QB8974_01AMBC_C", DEVICE_01AMBC_C,"JD"},  //id_mv= 
+		{1650, 1950,	Z5S_HW_01AMBC_B,		"QB8974_01AMBC_B",DEVICE_01AMBC_B,"JD"}  //id_mv=
+	}
+};
+
+struct project_id_map_st project_id_map[] = {
+	{0, 0,Z5S_PROJECT_INVALID,"unknow"},  //id_mv=0
+	{0, 150,Z5S_PROJECT_AMB,"QB8974_01AMB"},  //id_mv=0
+	{150, 450,Z5S_PROJECT_NX503J_V4,"NX503J_V4"},  //id_mv=0.3V
+	{750, 1050,Z5S_PROJECT_AMB_SIMPLIFY,"QB8974_01AMB_SIMPLIFY"},  //id_mv= 0.9V	
+	{1650, 1950,Z5S_PROJECT_AMBC,"QB8974_01AMBC"},  //id_mv= 1.8V
+};
+
+project_version_type ztemt_project_id = Z5S_PROJECT_INVALID;
+hw_version_type ztemt_hw_id = Z5S_HW_INVALID;
+
+static int32_t zte_qpnp_vadc_read(enum qpnp_vadc_channels channel,
+				struct qpnp_vadc_result *result)
+{
+	if(!g_vadc_dev)
+		goto fail_adc_enable;
+
+	return qpnp_vadc_read(g_vadc_dev,channel,result);
+
+	fail_adc_enable:
+	return -EINVAL;
+}
+
+static int 
+ztemt_get_project_type( struct project_id_map_st *pts,
+		int tablesize, int input)
+{
+	int i = 0;
+	if ( pts == NULL )
+		return Z5S_PROJECT_INVALID;
+
+	while (i < tablesize) {
+		if ( (pts[i].low_mv*1000 <= input) &&( input <= pts[i].high_mv*1000) ) {
+			DBG_DEVICE_INFO(" project_index = %d \n" , i);
+			break;
+			}
+		else 
+			i++;
+	}
+
+	if ( i < tablesize ) 
+		return pts[i].project_type;
+	else 
+		return Z5S_PROJECT_INVALID;
+	
+}
+
+int 
+ztemt_get_project_id( void )
+{
+	int rc;
+	int64_t project_id_uv = 0;
+	static int get_project = 0;
+	struct qpnp_vadc_result  adc_result;
+
+
+	if(get_project && (ztemt_project_id != Z5S_PROJECT_INVALID))
+		return ztemt_project_id;
+
+	rc = zte_qpnp_vadc_read(ADC_PROJECT_ID, &adc_result);
+	if (rc) {
+		DBG_DEVICE_INFO("error reading channel = %d, rc = %d\n",ADC_PROJECT_ID, rc);
+		return rc;
+	}
+	project_id_uv = adc_result.physical;
+
+DBG_DEVICE_INFO("project_id_uv.physical = %lld \n", adc_result.physical);
+
+	ztemt_project_id = ztemt_get_project_type(project_id_map,
+			ARRAY_SIZE(project_id_map),	(project_id_uv));
+
+	DBG_DEVICE_INFO("project_id_uv = %lld uv project_id=%d project_ver=%s\n",
+		project_id_uv,
+		ztemt_project_id ,
+		project_id_map[ztemt_project_id].project_ver);
+
+	get_project = 1;
+	return ztemt_project_id;
+}
+
+static int 
+ztemt_get_hardware_type( struct hardware_id_map_st pts[][HRADWARE_ID_MAX] , int project_id,
+		int tablesize, int input)
+{
+	uint32_t i = 0;
+	if ( pts == NULL )
+		return Z5S_HW_INVALID ;
+
+	while (i < tablesize) {
+		if ( (pts[project_id][i].low_mv*1000 <= input) && (input <= pts[project_id][i].high_mv*1000) ) {
+     	DBG_DEVICE_INFO(" pcb_index = %d \n" , i);
+			break;
+			}
+		else 
+			i++;
+	}
+
+	if ( i < tablesize ) 
+		return pts[project_id][i].hw_type;
+	else 
+		return Z5S_HW_INVALID;
+}
+
+int 
+ztemt_get_hw_id(int project_id)
+{
+	int rc;
+	int64_t hw_id_uv = 0;
+	static int get_hw = 0;
+	struct qpnp_vadc_result  adc_result;
+
+	if(get_hw &&( ztemt_hw_id !=Z5S_HW_INVALID))
+		return ztemt_hw_id;
+
+	rc = zte_qpnp_vadc_read(ADC_HW_ID, &adc_result);
+	if (rc) {
+		DBG_DEVICE_INFO("error reading channel  = %d, rc = %d\n",ADC_HW_ID, rc);
+		return rc;
+	}
+	hw_id_uv = adc_result.physical;
+
+DBG_DEVICE_INFO("hw_id_uv.physical = %lld \n", adc_result.physical);
+
+	DBG_DEVICE_INFO(">> ZTEMT >> size = %d \n" , 
+		ARRAY_SIZE(hardware_id_map[project_id] ));
+	
+	ztemt_hw_id = 
+		ztemt_get_hardware_type( hardware_id_map,
+			project_id,
+			ARRAY_SIZE(hardware_id_map[project_id]),
+			hw_id_uv );
+
+	DBG_DEVICE_INFO("hw_id_uv=%lld uv hw_id=%d hw_ver=%s\n",
+		hw_id_uv,
+		ztemt_hw_id,
+		hardware_id_map[project_id][ztemt_hw_id].hw_ver);
+
+	get_hw = 1;
+	return ztemt_hw_id;
+}
+
+/*
+* Public Interface
+*/
+
+int ztemt_get_device_index(char* result)
+{
+	int hw_id, project_id;
+	/* */
+	device_index_type device_index = 
+							DEVICE_01AMB_B_WTR1605_L_EMMC_16_32;
+	
+	project_id = ztemt_get_project_id();
+	if(project_id != Z5S_PROJECT_INVALID)
+	{
+		hw_id = ztemt_get_hw_id( project_id );
+		if(hw_id != Z5S_HW_INVALID){
+			device_index = hardware_id_map[project_id][hw_id].device_index;
+			}	
+	}
+
+	if(result){
+			sprintf(result, "%d",device_index);
+	}
+	
+	return device_index;
+}
+
+/**
+Return Device Name
+*/
+void ztemt_get_device_name(char* result)
+{
+	int hw_id, project_id;
+	if(!result)
+		return;
+
+	project_id = ztemt_get_project_id();
+	if(project_id != Z5S_PROJECT_INVALID)
+	{
+		hw_id = ztemt_get_hw_id( project_id );
+		if(hw_id != Z5S_HW_INVALID){
+			sprintf(result, "%s",hardware_id_map[project_id][hw_id].names);
+	}else
+		sprintf(result, "%s","unknow");
+	}
+	else
+		sprintf(result, "%s","unknow");
+
+	 return ;
+}
+
+void 
+ztemt_get_hw_pcb_version(char* result)
+{
+	int hw_id, project_id;
+	if(!result)
+		return;
+
+	project_id = ztemt_get_project_id();
+	if(project_id != Z5S_PROJECT_INVALID)
+	{
+		hw_id = ztemt_get_hw_id( project_id );
+		if(hw_id != Z5S_HW_INVALID){
+			sprintf(result, "%s",hardware_id_map[project_id][hw_id].hw_ver);
+	}else
+		sprintf(result, "%s","unknow");
+	}
+	else
+		sprintf(result, "%s","unknow");
+}
+EXPORT_SYMBOL(ztemt_get_hw_pcb_version);
+
+void 
+ztemt_get_project_version(char* result)
+{
+	int project_id;
+	if(!result)
+		return;
+
+	project_id = ztemt_get_project_id();
+	if(project_id != Z5S_PROJECT_INVALID){
+		sprintf(result, "%s",project_id_map[project_id].project_ver);
+	}else
+		sprintf(result, "%s","unknow");
+}
+EXPORT_SYMBOL(ztemt_get_project_version);
+
+static ssize_t  projectid_info_show(struct device *dev, 
+		struct device_attribute *attr, char *buf)
+{
+	char *tmp = buf;
+	ztemt_get_project_version(buf);
+	while ((*tmp++ ) != '\0');
+	return (tmp - buf);
+}
+static ssize_t projectid_info_store(struct device *dev, 
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+     return count;
+}
+static DEVICE_ATTR(project_info, 0444, projectid_info_show, projectid_info_store);
+
+static ssize_t  hardwareid_pcb_info_show(struct device *dev, 
+		struct device_attribute *attr, char *buf)
+{
+	char *tmp = buf;
+	ztemt_get_hw_pcb_version(buf);
+	while ((*tmp++ ) != '\0');
+	return (tmp - buf);
+}
+static ssize_t hardwareid_pcb_store(struct device *dev, 
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+     return count;
+}
+static DEVICE_ATTR(pcb_info, 0444, hardwareid_pcb_info_show, hardwareid_pcb_store);
+
+static ssize_t  device_index_show(struct device *dev, 
+		struct device_attribute *attr, char *buf)
+{
+		ztemt_get_device_index(buf);
+		return 1;
+}
+static ssize_t device_index_store(struct device *dev, 
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+     return count;
+}
+static DEVICE_ATTR(index, 0444, device_index_show, device_index_store);
+
+/*
+* /sys/ztemt_device_info
+*/
+static struct kobject * device_info_kobject = NULL;
+int device_info_init(struct qpnp_vadc_chip * vadc_dev )
+{
+	int ret;
+
+	g_vadc_dev = vadc_dev;
+	
+	device_info_kobject = kobject_create_and_add("ztemt_device_info", NULL);
+	if(device_info_kobject == NULL) {
+		ret = -ENOMEM;
+		goto err1;
+	}
+
+	ret = sysfs_create_file(device_info_kobject, &dev_attr_project_info.attr);
+	if(ret){
+		goto err;
+	}
+	
+	ret = sysfs_create_file(device_info_kobject, &dev_attr_pcb_info.attr);
+	if(ret){
+		goto err;
+	}
+
+	ret = sysfs_create_file(device_info_kobject, &dev_attr_index.attr);
+	if(ret){
+		goto err;
+	}
+	return 0;
+
+err:
+	kobject_del(device_info_kobject);
+err1:
+	DBG_DEVICE_INFO("DeviceInfo: Failed To Create Device Info Sys File \n");
+	return ret;
+}
+EXPORT_SYMBOL(device_info_init);
+
+/**
+  For Compatile Other Project
+*/
+static ssize_t ztemt_device_name_store(struct device *dev, 
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+     return count;
+}
+
+static ssize_t ztemt_device_name_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+//	char *tmp = buf;
+	ztemt_get_device_name(buf);
+	//while ((*tmp++ ) != '\0');
+	//return (tmp - buf);
+	  return sprintf(buf,"%s\n",buf);
+}
+
+static DEVICE_ATTR(ztemt_hw_sc, 0444, ztemt_device_name_show, ztemt_device_name_store);
+
+static int __devinit
+qpnp_ztemt_hw_version_probe(struct spmi_device *spmi)
+{
+	
+	struct qpnp_ztemt_hw_version_chip	*chip;
+	int rc = 0;
+
+   printk("Enter HW Device Module\n");
+   
+	chip = devm_kzalloc(&spmi->dev,
+			sizeof(struct qpnp_ztemt_hw_version_chip), GFP_KERNEL);
+	if (chip == NULL) {
+		pr_err("qpnp_ztemt_hw_version_probe : kzalloc() failed.\n");
+		return -ENOMEM;
+	}
+    dev_set_drvdata(&spmi->dev, chip);
+	chip->dev = &(spmi->dev);
+	chip->spmi = spmi;
+	
+    rc=sysfs_create_file(&chip->dev->kobj,&dev_attr_ztemt_hw_sc.attr);
+	return rc;
+}
+
+static int __devexit
+qpnp_ztemt_hw_version_remove(struct spmi_device *spmi)
+{
+	struct qpnp_ztemt_hw_version_chip *chip = dev_get_drvdata(&spmi->dev);
+    devm_kfree(&spmi->dev,chip);
+	return 0;
+}
+
+static struct of_device_id qpnp_ztemt_hw_version_match_table[] = {
+	{ .compatible = QPNP_ZTEMT_HW_VERSION_DEV_NAME, },
+	{}
+};
+
+static struct spmi_driver qpnp_ztemt_hw_version_driver = {
+	.probe		= qpnp_ztemt_hw_version_probe,
+	.remove		= __devexit_p(qpnp_ztemt_hw_version_remove),
+	.driver		= {
+		.name		    = QPNP_ZTEMT_HW_VERSION_DEV_NAME,
+		.owner		    = THIS_MODULE,
+		.of_match_table	= qpnp_ztemt_hw_version_match_table,
+	},
+};
+
+int __init
+qpnp_ztemt_hw_version_init(void)
+{
+	return spmi_driver_register(&qpnp_ztemt_hw_version_driver);
+}
+module_init(qpnp_ztemt_hw_version_init);
+
+static void __exit
+qpnp_ztemt_hw_version_exit(void)
+{
+	spmi_driver_unregister(&qpnp_ztemt_hw_version_driver);
+}
+module_exit(qpnp_ztemt_hw_version_exit);
+
+MODULE_DESCRIPTION("qpnp ztemt_hw_version driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" QPNP_ZTEMT_HW_VERSION_DEV_NAME);
+
diff --git a/drivers/hwmon/sensor_common.c b/drivers/hwmon/sensor_common.c
new file mode 100755
index 0000000..eb1a67b
--- /dev/null
+++ b/drivers/hwmon/sensor_common.c
@@ -0,0 +1,547 @@
+/******************** (C) COPYRIGHT 2013 STMicroelectronics ********************
+*
+* File Name          : hts221.c
+* Authors            : Motion MEMS
+*                      Morris Chen (morris.chen@st.com)
+* Version            : V.1.0.0
+* Date               : 06/03/2013
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+********************************************************************************
+Version History.
+ 
+Revision 1-0-0 06/03/2013
+ first revision
+
+*******************************************************************************/
+ 
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kobject.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+#include <linux/device.h>
+#include <linux/i2c/sensor_common.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/miscdevice.h>
+#include <linux/of_gpio.h>
+
+
+#define LOG_TAG "SENSOR_COMMON"
+#define DEBUG_ON //DEBUG SWITCH
+
+#define SENSOR_LOG_FILE__ strrchr(__FILE__, '/') ? (strrchr(__FILE__, '/')+1) : __FILE__
+
+#ifdef  CONFIG_FEATURE_ZTEMT_SENSORS_LOG_ON
+#define SENSOR_LOG_ERROR(fmt, args...) printk(KERN_ERR   "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #ifdef  DEBUG_ON
+#define SENSOR_LOG_INFO(fmt, args...)  printk(KERN_INFO  "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+                                              
+#define SENSOR_LOG_DEBUG(fmt, args...) printk(KERN_DEBUG "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #else
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+    #endif
+
+#else
+#define SENSOR_LOG_ERROR(fmt, args...)
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+#endif
+
+static const struct i2c_device_id sensor_common_idtable_id[] = {
+    { "zte,sensor_common", 0 },
+    { },
+};
+ 
+static struct of_device_id of_sensor_common_idtable[] = {
+    { .compatible = "zte,sensor_common",},
+    {}
+};
+ 
+ MODULE_DEVICE_TABLE(i2c, sensor_common_idtable);
+ 
+static struct i2c_driver sensor_common_driver = {
+    .driver = {
+        .name = "sensor_common",
+        .of_match_table = of_sensor_common_idtable,
+        .pm = NULL,
+    },
+    .id_table = sensor_common_idtable_id,
+    .probe = sensor_common_probe,
+    .remove = __devexit_p(sensor_common_remove),
+};
+
+
+struct class  *sensor_common_class;
+
+static dev_t const sensor_compass_dev               =   MKDEV(MISC_MAJOR, 210);
+static dev_t const sensor_temp_humidity_dev         =   MKDEV(MISC_MAJOR, 211);
+
+int sensor_common_read_file_int(char *file_path)
+{
+    struct file *file_p;
+    int vfs_read_retval = 0;
+    mm_segment_t old_fs; 
+    char read_buf[32];
+    //unsigned short read_value;
+    int read_value;
+
+    if (NULL==file_path)
+    {
+        SENSOR_LOG_ERROR("file_path is NULL\n");
+        goto error;
+    }
+
+    memset(read_buf, 0, 32);
+
+    file_p = filp_open(file_path, O_RDONLY, 0);
+    if (IS_ERR(file_p))
+    {
+        SENSOR_LOG_ERROR("[open file <%s>failed]\n",file_path);
+        goto error;
+    }
+
+    old_fs = get_fs();
+    set_fs(KERNEL_DS);
+    
+    vfs_read_retval = vfs_read(file_p, (char*)read_buf, 16, &file_p->f_pos);
+    if (vfs_read_retval < 0)
+    {
+        SENSOR_LOG_ERROR("[read file <%s>failed]\n",file_path);
+        goto error;
+    }
+
+    set_fs(old_fs);
+    filp_close(file_p, NULL);
+
+    read_value = simple_strtol(read_buf, NULL, 10);
+
+    return read_value;
+
+error:
+    return 0;
+}
+
+int sensor_common_read_file_char(char *file_path, char *save_buf)
+{
+    struct file *file_p;
+    int vfs_read_retval = 0;
+    mm_segment_t old_fs; 
+    char read_buf[32];
+
+    if (NULL==file_path)
+    {
+        SENSOR_LOG_ERROR("file_path is NULL\n");
+        goto error;
+    }
+
+    memset(read_buf, 0, 32);
+
+    file_p = filp_open(file_path, O_RDONLY, 0);
+    if (IS_ERR(file_p))
+    {
+        SENSOR_LOG_ERROR("[open file <%s>failed]\n",file_path);
+        goto error;
+    }
+
+    old_fs = get_fs();
+    set_fs(KERNEL_DS);
+    
+    vfs_read_retval = vfs_read(file_p, (char*)read_buf, 16, &file_p->f_pos);
+    if (vfs_read_retval < 0)
+    {
+        SENSOR_LOG_ERROR("[read file <%s>failed]\n",file_path);
+        goto error;
+    }
+
+    set_fs(old_fs);
+    filp_close(file_p, NULL);
+
+    SENSOR_LOG_ERROR("read_buf is %s\n",read_buf);
+
+    return sprintf(save_buf, "%s",read_buf);
+
+
+error:
+    return 0;
+}
+
+
+
+static ssize_t compass_int_pin_get(struct device *dev,struct device_attribute *attr, char *buf)
+{    
+	struct sensor_common_data *chip = dev_get_drvdata(dev);
+    return sprintf(buf, "gpio is %d\n",gpio_get_value(chip->compass_irq_gpio));
+}
+ 
+
+static ssize_t compass_int_pin_set(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+    bool value;
+	struct sensor_common_data *chip = dev_get_drvdata(dev);
+
+    if (strtobool(buf, &value))
+        return -EINVAL;
+
+    if (value)
+    { 
+        SENSOR_LOG_INFO("set to be 1\n");
+        gpio_set_value(chip->compass_irq_gpio, 1);
+    }
+    else
+    {
+        SENSOR_LOG_INFO("set to be 0\n");
+        gpio_set_value(chip->compass_irq_gpio, 0);
+    }
+
+    return size;
+}
+
+
+
+static struct device_attribute attrs_sensor_compass[] = {
+	__ATTR(int_pin,                  0640,   compass_int_pin_get,          compass_int_pin_set),
+};
+
+
+
+static int sensor_compass_create_sysfs_interfaces(struct device *dev)
+{
+    int i;
+    for (i = 0; i < ARRAY_SIZE(attrs_sensor_compass); i++)
+     if (device_create_file(dev, attrs_sensor_compass + i))
+         goto error;
+    return 0;
+
+error:
+    for ( ; i >= 0; i--)
+    device_remove_file(dev, attrs_sensor_compass + i);
+    SENSOR_LOG_ERROR("Unable to create interface\n");
+    return -1;
+}
+
+
+
+
+static ssize_t attr_raw_temp_get(struct device *dev,struct device_attribute *attr, char *buf)
+{
+    static int raw_temp;
+
+    raw_temp = sensor_common_read_file_int(PATH_RAW_TEMP);
+    SENSOR_LOG_INFO("raw_temp is %d\n",raw_temp);
+    return sprintf(buf, "%d\n", raw_temp);
+}
+
+static ssize_t attr_raw_humidity_get(struct device *dev,struct device_attribute *attr, char *buf)
+{
+    static int raw_humidity;
+
+    raw_humidity = sensor_common_read_file_int(PATH_RAW_HUMIDITY);
+    SENSOR_LOG_INFO("raw_humidity is %d\n",raw_humidity);
+    return sprintf(buf, "%d\n", raw_humidity);
+}
+
+
+static ssize_t attr_timestamp_get(struct device *dev,struct device_attribute *attr, char *buf)
+{
+    static struct timespec time;
+    time = current_kernel_time();
+    
+    return sprintf(buf, "%ld.%ld\n",time.tv_sec,time.tv_nsec);
+}
+
+
+static ssize_t attr_temp_cpu_0_get(struct device *dev,struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", sensor_common_read_file_int(PATH_TEMP_CPU_0));
+}
+
+static ssize_t attr_temp_cpu_1_get(struct device *dev,struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", sensor_common_read_file_int(PATH_TEMP_CPU_1));
+}
+
+static ssize_t attr_temp_cpu_2_get(struct device *dev,struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", sensor_common_read_file_int(PATH_TEMP_CPU_2));
+}
+
+static ssize_t attr_temp_cpu_3_get(struct device *dev,struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", sensor_common_read_file_int(PATH_TEMP_CPU_3));
+}
+
+static ssize_t attr_temp_rf(struct device *dev,struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n",sensor_common_read_file_int(PATH_TEMP_RF));
+}
+
+static ssize_t attr_temp_battery(struct device *dev,struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n",sensor_common_read_file_int(PATH_TEMP_BATTERY));
+}
+
+static ssize_t attr_temp_charging(struct device *dev,struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n",sensor_common_read_file_int(PATH_TEMP_CHARGING));
+}
+
+static ssize_t attr_temp_lcd(struct device *dev,struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n",sensor_common_read_file_int(PATH_TEMP_LCD));
+}
+
+
+static ssize_t attr_lcd_brightness_get(struct device *dev,struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", sensor_common_read_file_int(PATH_LCD_BRIGHTNESS)*100 / 255);
+}
+
+static ssize_t attr_battery_level(struct device *dev,struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n",sensor_common_read_file_int(PATH_BATTERY_LEVEL));
+}
+
+static ssize_t attr_battery_state(struct device *dev,struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n",sensor_common_read_file_int(PATH_BATTERY_STATE));
+}
+
+static ssize_t attr_charge_current(struct device *dev,struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n",sensor_common_read_file_int(PATH_CHARGE_CURRENT));
+}
+
+
+/*
+ "Unknown", "Charging", "Discharging", "Not charging", "Full"
+     0          1             2              3           4
+ */
+static ssize_t attr_charge_state(struct device *dev,struct device_attribute *attr, char *buf)
+{
+
+    char *charge_status[5] = {"Unknown", "Charging", "Discharging", "Not charging", "Full"};
+    char save_buf[32];
+    int charge_state = 0;
+    int i = 0;
+
+    sensor_common_read_file_char(PATH_CHARGE_STATE, save_buf);
+
+    for (i=0; i<5; i++)
+    {
+        SENSOR_LOG_ERROR("charge_status[%d] is %s\n",i,charge_status[i]);
+        if (0 == strncmp(save_buf, charge_status[i], strlen(charge_status[i])))
+        {
+            charge_state = i;
+            break;
+        }
+    }
+   
+    return sprintf(buf, "%d\n",charge_state);
+}
+
+static ssize_t attr_rf_state(struct device *dev,struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "1\n");
+}
+
+static struct device_attribute attrs_sensor_temp_humidity[] = {
+	__ATTR(timestamp,                  0644,        attr_timestamp_get,                  NULL),
+    __ATTR(raw_temp,                   0644,        attr_raw_temp_get,                   NULL),
+    __ATTR(raw_humidity,               0644,        attr_raw_humidity_get,               NULL),
+    __ATTR(temp_cpu_0,                 0644,        attr_temp_cpu_0_get,                 NULL),
+    __ATTR(temp_cpu_1,                 0644,        attr_temp_cpu_1_get,                 NULL),
+    __ATTR(temp_cpu_2,                 0644,        attr_temp_cpu_2_get,                 NULL),
+    __ATTR(temp_cpu_3,                 0644,        attr_temp_cpu_3_get,                 NULL),
+    __ATTR(temp_rf,                    0644,        attr_temp_rf,                        NULL),
+    __ATTR(temp_battery,               0644,        attr_temp_battery,                   NULL),
+    __ATTR(temp_charging,              0644,        attr_temp_charging,                  NULL),
+    __ATTR(temp_lcd,                   0644,        attr_temp_lcd,                       NULL),
+    __ATTR(lcd_brightness,             0644,        attr_lcd_brightness_get,             NULL),
+    __ATTR(battery_level,              0644,        attr_battery_level,                  NULL),
+    __ATTR(battery_state,              0644,        attr_battery_state,                  NULL),
+    __ATTR(charge_current,             0644,        attr_charge_current,                 NULL),
+    __ATTR(charge_state,               0644,        attr_charge_state,                   NULL),
+    __ATTR(rf_state,                   0644,        attr_rf_state,                       NULL),
+
+};
+
+static int sensor_temp_humidity_create_sysfs_interfaces(struct device *dev)
+{
+    int i;
+    for (i = 0; i < ARRAY_SIZE(attrs_sensor_temp_humidity); i++)
+     if (device_create_file(dev, attrs_sensor_temp_humidity + i))
+         goto error;
+    return 0;
+
+error:
+    for ( ; i >= 0; i--)
+    device_remove_file(dev, attrs_sensor_temp_humidity + i);
+    SENSOR_LOG_ERROR("Unable to create interface\n");
+    return -1;
+}
+
+
+static int sensor_compass_int_pin_init(int pin_num)
+{
+    int ret = 0;
+
+    ret = gpio_request(pin_num, "compass_int");
+    if (ret)    
+    {
+        SENSOR_LOG_INFO("gpio %d is busy and then to free it\n",pin_num);
+        
+        gpio_free(pin_num);
+        ret = gpio_request(pin_num, "compass_int");
+        if (ret) 
+        {
+            SENSOR_LOG_INFO("gpio %d is busy and then to free it\n",pin_num);
+            return ret;
+        }
+    }
+    else
+    {
+        SENSOR_LOG_INFO("gpio %d get success\n",pin_num);
+    }
+
+    ret = gpio_tlmm_config(GPIO_CFG(pin_num, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+    if (ret < 0)
+    {
+        SENSOR_LOG_ERROR("gpio_tlmm_config failed ret = %d",ret);
+    }
+    
+    return ret;
+}
+
+static int sensor_common_parse_dt(struct sensor_common_data *chip)
+{
+	struct device_node *np = chip->client->dev.of_node;
+	chip->compass_irq_gpio = of_get_named_gpio(np, "compass,irq-gpio", 0);
+    SENSOR_LOG_INFO("compass_irq_gpio is %d\n",chip->compass_irq_gpio);
+    return 0;
+}
+
+
+static int __devinit sensor_common_probe(struct i2c_client *client,
+                  const struct i2c_device_id *id)
+{
+
+    int ret;
+
+    struct sensor_common_data *chip_data;
+
+    SENSOR_LOG_INFO("prob start\n");
+
+	chip_data = kzalloc(sizeof(struct sensor_common_data), GFP_KERNEL);
+    chip_data->client = client;
+
+    i2c_set_clientdata(client, chip_data);
+
+    sensor_common_parse_dt(chip_data);
+
+    sensor_common_class = class_create(THIS_MODULE, "sensor");
+
+    chip_data->sensor_compass_dev = device_create(sensor_common_class, NULL, sensor_compass_dev, &sensor_common_driver ,"compass");
+    if (IS_ERR(chip_data->sensor_compass_dev)) 
+    {
+        ret = PTR_ERR(chip_data->sensor_compass_dev);
+        goto create_sensor_compass_failed;
+    }
+    dev_set_drvdata(chip_data->sensor_compass_dev, chip_data);
+
+
+    chip_data->sensor_temp_humidity_dev = device_create(sensor_common_class, NULL, sensor_temp_humidity_dev, &sensor_common_driver ,"temp_humidity");
+    if (IS_ERR(chip_data->sensor_temp_humidity_dev)) 
+    {
+        ret = PTR_ERR(chip_data->sensor_temp_humidity_dev);
+        goto create_sensor_sensor_temp_humidity_failed;
+    }
+    dev_set_drvdata(chip_data->sensor_temp_humidity_dev, chip_data);
+
+    sensor_compass_create_sysfs_interfaces(chip_data->sensor_compass_dev);
+    sensor_temp_humidity_create_sysfs_interfaces(chip_data->sensor_temp_humidity_dev);
+
+
+    sensor_compass_int_pin_init(chip_data->compass_irq_gpio);
+
+
+    SENSOR_LOG_INFO("prob success\n");
+
+    return 0;
+
+create_sensor_sensor_temp_humidity_failed:
+    chip_data->sensor_compass_dev = NULL;
+    class_destroy(sensor_common_class); 
+
+
+create_sensor_compass_failed:
+    chip_data->sensor_compass_dev = NULL;
+    class_destroy(sensor_common_class); 
+
+    return ret;
+}
+
+ 
+ /**
+  * sensor_common_remove() - remove device
+  * @client: I2C client device
+  */
+ static int __devexit sensor_common_remove(struct i2c_client *client)
+ {
+     struct sensor_common_data *chip_data = i2c_get_clientdata(client);
+ 
+      SENSOR_LOG_INFO("sensor_common_remove\n");
+     //hwmon_device_unregister(chip_data->hwmon_dev);
+     //sysfs_remove_group(&client->dev.kobj, &sensor_common_attr_group);
+    
+     kfree(chip_data);
+     return 0;
+ }
+
+static int __init sensor_common_init(void)
+{
+        SENSOR_LOG_INFO("driver: init\n");
+        return i2c_add_driver(&sensor_common_driver);
+}
+ 
+static void __exit sensor_common_exit(void)
+{
+        SENSOR_LOG_INFO("driver: exit\n");
+        i2c_del_driver(&sensor_common_driver);
+}
+
+module_init(sensor_common_init);
+module_exit(sensor_common_exit);
+ 
+MODULE_DESCRIPTION("sensor commom driver");
+MODULE_AUTHOR("ZhuBing, ZTEMT");
+MODULE_LICENSE("GPL");
diff --git a/drivers/hwmon/tmd2772.c b/drivers/hwmon/tmd2772.c
new file mode 100755
index 0000000..8e2d421
--- /dev/null
+++ b/drivers/hwmon/tmd2772.c
@@ -0,0 +1,3540 @@
+/*******************************************************************************
+*                                                                              *
+*   File Name:    taos.c                                                      *
+*   Description:   Linux device driver for Taos ambient light and         *
+*   proximity sensors.                                     *
+*   Author:         John Koshi                                             *
+*   History:   09/16/2009 - Initial creation                          *
+*           10/09/2009 - Triton version         *
+*           12/21/2009 - Probe/remove mode                *
+*           02/07/2010 - Add proximity          *
+*                                                                                       *
+********************************************************************************
+*    Proprietary to Taos Inc., 1001 Klein Road #300, Plano, TX 75074        *
+*******************************************************************************/
+// includes
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/hwmon.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <asm/delay.h>
+#include <linux/i2c/taos_common.h>
+#include <linux/delay.h>
+#include <linux/irq.h> 
+#include <linux/interrupt.h> 
+#include <linux/slab.h>
+#include <asm/gpio.h> 
+#include <linux/poll.h> 
+#include <linux/wakelock.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/miscdevice.h>
+#include <linux/hrtimer.h>
+#include <linux/of_gpio.h>
+
+
+#ifdef CONFIG_ZTE_DEVICE_INFO_SHOW
+#include <linux/zte_device_info.h>
+#endif
+
+#define LOG_TAG "SENSOR_ALS_PROX"
+#define DEBUG_ON //DEBUG SWITCH
+
+#define SENSOR_LOG_FILE__ strrchr(__FILE__, '/') ? (strrchr(__FILE__, '/')+1) : __FILE__
+
+#ifdef  CONFIG_FEATURE_ZTEMT_SENSORS_LOG_ON
+#define SENSOR_LOG_ERROR(fmt, args...) printk(KERN_ERR   "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #ifdef  DEBUG_ON
+#define SENSOR_LOG_INFO(fmt, args...)  printk(KERN_INFO  "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+                                              
+#define SENSOR_LOG_DEBUG(fmt, args...) printk(KERN_DEBUG "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #else
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+    #endif
+
+#else
+#define SENSOR_LOG_ERROR(fmt, args...)
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+#endif
+
+
+// device name/id/address/counts
+#define TAOS_DEVICE_NAME                "taos"
+#define TAOS_DEVICE_ID                  "tritonFN"
+#define TAOS_ID_NAME_SIZE               10
+#define TAOS_TRITON_CHIPIDVAL           0x00
+#define TAOS_TRITON_MAXREGS             32
+#define TAOS_DEVICE_ADDR1               0x29
+#define TAOS_DEVICE_ADDR2               0x39
+#define TAOS_DEVICE_ADDR3               0x49
+#define TAOS_MAX_NUM_DEVICES            3
+#define TAOS_MAX_DEVICE_REGS            32
+#define I2C_MAX_ADAPTERS                12
+
+// TRITON register offsets
+#define TAOS_TRITON_CNTRL               0x00
+#define TAOS_TRITON_ALS_TIME            0X01
+#define TAOS_TRITON_PRX_TIME            0x02
+#define TAOS_TRITON_WAIT_TIME           0x03
+#define TAOS_TRITON_ALS_MINTHRESHLO     0X04
+#define TAOS_TRITON_ALS_MINTHRESHHI     0X05
+#define TAOS_TRITON_ALS_MAXTHRESHLO     0X06
+#define TAOS_TRITON_ALS_MAXTHRESHHI     0X07
+#define TAOS_TRITON_PRX_MINTHRESHLO     0X08
+#define TAOS_TRITON_PRX_MINTHRESHHI     0X09
+#define TAOS_TRITON_PRX_MAXTHRESHLO     0X0A
+#define TAOS_TRITON_PRX_MAXTHRESHHI     0X0B
+#define TAOS_TRITON_INTERRUPT           0x0C
+#define TAOS_TRITON_PRX_CFG             0x0D
+#define TAOS_TRITON_PRX_COUNT           0x0E
+#define TAOS_TRITON_GAIN                0x0F
+#define TAOS_TRITON_REVID               0x11
+#define TAOS_TRITON_CHIPID              0x12
+#define TAOS_TRITON_STATUS              0x13
+#define TAOS_TRITON_ALS_CHAN0LO         0x14
+#define TAOS_TRITON_ALS_CHAN0HI         0x15
+#define TAOS_TRITON_ALS_CHAN1LO         0x16
+#define TAOS_TRITON_ALS_CHAN1HI         0x17
+#define TAOS_TRITON_PRX_LO              0x18
+#define TAOS_TRITON_PRX_HI              0x19
+#define TAOS_TRITON_TEST_STATUS         0x1F
+
+// Triton cmd reg masks
+//0x by clli2
+#define TAOS_TRITON_CMD_REG             0X80
+#define TAOS_TRITON_CMD_AUTO            0x20 
+#define TAOS_TRITON_CMD_BYTE_RW         0x00 
+#define TAOS_TRITON_CMD_WORD_BLK_RW     0x20 
+#define TAOS_TRITON_CMD_SPL_FN          0x60 
+#define TAOS_TRITON_CMD_PROX_INTCLR     0X05 
+#define TAOS_TRITON_CMD_ALS_INTCLR      0X06 
+#define TAOS_TRITON_CMD_PROXALS_INTCLR  0X07 
+#define TAOS_TRITON_CMD_TST_REG         0X08 
+#define TAOS_TRITON_CMD_USER_REG        0X09
+
+// Triton cntrl reg masks
+#define TAOS_TRITON_CNTL_PROX_INT_ENBL  0X20
+#define TAOS_TRITON_CNTL_ALS_INT_ENBL   0X10
+#define TAOS_TRITON_CNTL_WAIT_TMR_ENBL  0X08
+#define TAOS_TRITON_CNTL_PROX_DET_ENBL  0X04
+#define TAOS_TRITON_CNTL_ADC_ENBL       0x02
+#define TAOS_TRITON_CNTL_PWRON          0x01
+
+// Triton status reg masks
+#define TAOS_TRITON_STATUS_ADCVALID     0x01
+#define TAOS_TRITON_STATUS_PRXVALID     0x02
+#define TAOS_TRITON_STATUS_ADCINTR      0x10
+#define TAOS_TRITON_STATUS_PRXINTR      0x20
+
+// lux constants
+#define TAOS_MAX_LUX                    10000
+#define TAOS_SCALE_MILLILUX             3
+#define TAOS_FILTER_DEPTH               3
+#define CHIP_ID                         0x3d
+
+#define TAOS_INPUT_NAME                 "lightsensor"
+#define	POLL_DELAY	                    msecs_to_jiffies(5)
+#define	TAOS_ALS_ADC_TIME_WHEN_PROX_ON	0xF0//0XF5//0XEB
+#define TAOS_ALS_GAIN_DIVIDE            1000
+#define TAOS_ALS_GAIN_1X                0
+#define TAOS_ALS_GAIN_8X                1
+#define TAOS_ALS_GAIN_16X               2
+#define TAOS_ALS_GAIN_120X              3
+
+#define CAL_THRESHOLD                      "/persist/proxdata/threshold"
+#define PATH_PROX_OFFSET                   "/persist/sensors/proximity/offset/proximity_offset"
+#define PATH_PROX_UNCOVER_DATA             "/persist/sensors/proximity/uncover_data"
+
+#define PROX_LED_PULSE_CNT                  12
+#define PROX_THRESHOLD_DISTANCE             100
+#define PROX_DATA_TARGET                    150
+#define PROX_DATA_MAX                       1023
+#define PROX_OFFSET_CAL_BUFFER_SIZE         30
+#define PROX_OFFSET_CAL_THRESHOLD           800
+#define PROX_OFFSET_CAL_ABILITY_MAX         72 // -9*72
+#define PROX_DATA_SAFE_RANGE_MIN            (PROX_DATA_TARGET - 50)
+#define PROX_DATA_SAFE_RANGE_MAX            (PROX_DATA_TARGET + 350)
+#define PROX_OFFSET_CAL_GETDATA_DELAY       10
+#define PROX_OFFSET_CAL_PER_BIT             10/85
+#define PROX_DEFAULT_THRESHOLD_HIGH         800
+#define PROX_DEFAULT_THRESHOLD_LOW          700
+#define PROX_THRESHOLD_HIGH_MAX             800
+#define PROX_THRESHOLD_HIGH_MIN             250
+#define PROX_DEFAULT_OFFSET_CNT              0
+#define PROX_THRESHOLD_SAFE_DISTANCE        PROX_THRESHOLD_DISTANCE / 2
+
+
+
+// ZTEMT ADD by zhubing 2012-2-20 V8000/X501
+// added the work mode marco
+//#define WORK_UES_POLL_MODE
+// ZTEMT ADD by zhubing 2012-2-20 V8000/X501 END
+
+//#define IRQ_TRIGER_LEVEL_LOW
+
+// forward declarations
+static int tmd2772_probe(struct i2c_client *clientp, const struct i2c_device_id *idp);
+static int tmd2772_remove(struct i2c_client *client);
+static int taos_get_lux(void);
+static int taos_lux_filter(int raw_lux);
+static int taos_device_name(unsigned char *bufp, char **device_name);
+static int taos_prox_poll(struct taos_prox_info *prxp);
+static void taos_prox_poll_timer_func(unsigned long param);
+static void taos_prox_poll_timer_start(void);
+//iVIZM
+static int taos_prox_threshold_set(void);
+static int taos_als_get_data(void);
+static int taos_interrupts_clear(void);
+static int taos_resume(struct i2c_client *client);
+static int taos_suspend(struct i2c_client *client,pm_message_t mesg);
+//CLLI@
+
+
+static int taos_sensors_als_poll_on(void);
+static int taos_sensors_als_poll_off(void);
+static void taos_als_poll_work_func(struct work_struct *work);
+static int taos_als_gain_set(unsigned als_gain);
+static void taos_update_sat_als(void);
+static int taos_prox_on(void);
+static int taos_prox_off(void);
+static int taos_prox_calibrate(void);
+static void taos_prox_calibrate_work_func(struct work_struct *work);
+static void taos_prox_offset_cal_work_func(struct work_struct *work);
+static void taos_wakelock_ops(struct taos_wake_lock *wakelock, bool enable);
+static int taos_write_cal_file(char *file_path,unsigned int value);
+static int taos_read_cal_value(char *file_path);
+static enum hrtimer_restart  taos_prox_unwakelock_work_func(struct hrtimer *timer);
+
+
+static dev_t const tmd2772_proximity_dev_t = MKDEV(MISC_MAJOR, 101);
+static dev_t const tmd2772_light_dev_t     = MKDEV(MISC_MAJOR, 102);
+
+
+DECLARE_WAIT_QUEUE_HEAD(waitqueue_read);//iVIZM
+
+struct ReadData { //iVIZM
+    unsigned int data;
+    unsigned int interrupt;
+};
+struct ReadData readdata[2];//iVIZM
+
+// workqueue struct
+//static struct workqueue_struct *taos_wq; //iVIZM
+
+// class structure for this device
+struct class *taos_class;
+
+// board and address info   iVIZM
+struct i2c_board_info taos_board_info[] = {
+    {I2C_BOARD_INFO(TAOS_DEVICE_ID, TAOS_DEVICE_ADDR2),},
+};
+
+unsigned short const taos_addr_list[2] = {TAOS_DEVICE_ADDR2, I2C_CLIENT_END};//iVIZM
+
+// client and device
+struct i2c_client *my_clientp;
+struct i2c_client *bad_clientp[TAOS_MAX_NUM_DEVICES];
+static int device_found = 0;
+
+static struct class         *proximity_class;
+static struct class         *light_class;
+
+
+//iVIZM
+static char pro_buf[4]; //iVIZM
+static int mcount = 0; //iVIZM
+static bool pro_ft = false; //by clli2
+static bool flag_prox_debug = false;
+static bool flag_als_debug  = false;
+static bool flag_just_open_light = false;
+static unsigned int als_poll_delay = 1000;
+static unsigned int prox_debug_delay_time = 0;
+u16 status = 0;
+static int als_poll_time_mul  = 1;
+static unsigned char reg_addr = 0;
+static bool wakeup_from_sleep = false;
+
+// ZTEMT ADD by zhubing
+// modify for input filter the same data
+static int last_proximity_data = -1;
+//static int last_als_data       = -1;
+// ZTEMT ADD by zhubing END
+
+
+static const struct i2c_device_id tmd2772_idtable_id[] = {
+	{ "ams,ams-sensor", 0 },
+	{ },
+};
+
+static struct of_device_id of_tmd2772_idtable[] = {
+	{ .compatible = "ams,ams-sensor",},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, tmd2772_idtable);
+
+struct i2c_driver tmd2772_driver = {
+	.driver = {
+		.name = "ams-sensor-tmd2772",
+        .of_match_table = of_tmd2772_idtable,
+		//.pm = NULL,
+	},
+	.id_table = tmd2772_idtable_id,
+	.probe = tmd2772_probe,
+	.remove = __devexit_p(tmd2772_remove),
+#ifdef CONFIG_PM_SLEEP //by clli2
+    .resume = taos_resume,
+    .suspend = taos_suspend,
+#endif
+
+};
+
+
+
+
+
+
+// per-device data
+struct taos_data {
+	struct i2c_client *client;
+	struct cdev cdev;
+	unsigned int addr;
+	//struct input_dev *input_dev;//iVIZM
+	//struct work_struct work;//iVIZM
+	struct delayed_work work;//iVIZM
+	struct work_struct irq_work;
+	struct workqueue_struct *irq_work_queue;
+	struct taos_wake_lock proximity_wakelock;//iVIZM
+	struct mutex lock;
+	struct device *class_dev;
+	struct delayed_work als_poll_work;
+	struct delayed_work prox_calibrate_work;
+	struct delayed_work prox_offset_cal_work;
+	struct hrtimer  prox_unwakelock_timer;
+	struct input_dev *p_idev;
+	struct input_dev *a_idev;
+
+	struct device *proximity_dev;
+	struct device *light_dev;
+	struct device *gesture_dev;
+
+	char taos_id;
+	char taos_name[TAOS_ID_NAME_SIZE];
+
+	char *prox_name;
+	char *als_name;
+	bool prox_calibrate_flag;
+	bool prox_calibrate_result;
+	bool prox_offset_cal_result;
+
+	bool phone_is_sleep;
+
+	int  prox_calibrate_times;
+	int  prox_thres_hi_max;
+	int  prox_thres_hi_min;
+	int  prox_data_max;
+	int  prox_manual_calibrate_threshold;
+	int  irq_pin_num;
+
+    u8   prox_uncover_data;
+
+	char *chip_name;
+
+
+	bool prox_on;
+	bool als_on;
+	bool irq_enabled;
+	bool irq_work_status;
+	bool init;
+	int als_poll_time_mul;
+
+	struct semaphore update_lock;
+	char valid;
+} *taos_datap;
+
+// device configuration by clli2
+struct taos_cfg *taos_cfgp;
+static u32 calibrate_target_param = 300000;
+static u16 als_time_param = 41;
+static u16 scale_factor_param_prox = 6;    
+static u16 scale_factor_param_als = 6;
+static u16 gain_trim_param = 512;          //NULL
+static u8 filter_history_param = 3;        //NULL
+static u8 filter_count_param = 1;          //NULL
+/* gain_param  00--1X, 01--8X, 10--16X, 11--120X
+ */
+static u8 gain_param = 0;                  //same as prox-gain_param 1:0 8X
+static u16 prox_calibrate_hi_param = 500;
+static u16 prox_calibrate_lo_param = 330;
+static u16 prox_threshold_hi_param = PROX_DEFAULT_THRESHOLD_HIGH;
+static u16 prox_threshold_lo_param = PROX_DEFAULT_THRESHOLD_LOW;
+static u16 als_threshold_hi_param  = 3000; 
+static u16 als_threshold_lo_param  = 10;   
+static u8  prox_int_time_param     = 0xF0;//0xCD; // time of the ALS ADC TIME, TIME = (255 - prox_int_time_param) * 2.72ms
+static u8  prox_adc_time_param     = 0xFF; // time of the PRO ADC TIME, TIME = (255 - prox_int_time_param) * 2.72ms
+static u8  prox_wait_time_param    = 0xFF; // time of the    Wait TIME, TIME = (255 - prox_int_time_param) * 2.72ms
+/*7~4->pls,3~0->als*/
+static u8  prox_intr_filter_param  = 0x33; // Int filter, Bit7--Bit4:PROX  Bit3--Bit0:ALS
+static u8  prox_config_param       = 0x00; // wait long time disable
+/*pulse/62.5Khz  less  32 recommand*/
+static u8  prox_pulse_cnt_param    = PROX_LED_PULSE_CNT; //PROX LED pluse count to send for each measure 0x00--0xff:0--255
+/* 7:6 11->100ma        00->12.5ma
+   5:4 01->ch0          10->ch1    11->both
+   1:0(als gain ctrol)  1X 8X 16X 128X        */
+static u8  prox_gain_param = 0x20;   //50ma     8X
+static u8  prox_config_offset_param  = 0x0;
+// prox info
+struct taos_prox_info prox_cal_info[20];
+struct taos_prox_info prox_cur_info;
+struct taos_prox_info *prox_cur_infop = &prox_cur_info;
+static struct timer_list prox_poll_timer;
+static int device_released = 0;
+static u16 sat_als = 0;
+static u16 sat_prox = 0;
+
+
+
+// device reg init values
+u8 taos_triton_reg_init[16] = {0x00,0xFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00};
+
+// lux time scale
+struct time_scale_factor  {
+    u16 numerator;
+    u16 denominator;
+    u16 saturation;
+};
+struct time_scale_factor TritonTime = {1, 0, 0};
+struct time_scale_factor *lux_timep = &TritonTime;
+
+// gain table
+u8 taos_triton_gain_table[] = {1, 8, 16, 120};
+
+// lux data
+struct lux_data {
+    u16 ratio;
+    u16 clear;
+    u16 ir;
+};
+struct lux_data TritonFN_lux_data[] = {
+    { 9830,  8320,  15360 },
+    { 12452, 10554, 22797 },
+    { 14746, 6234,  11430 },
+    { 17695, 3968,  6400  },
+    { 0,     0,     0     }
+};
+struct lux_data *lux_tablep = TritonFN_lux_data;
+static int lux_history[TAOS_FILTER_DEPTH] = {-ENODATA, -ENODATA, -ENODATA};//iVIZM
+
+static int taos_get_data(void);
+
+
+static void taos_irq_ops(bool enable, bool flag_sync)
+{
+    if (enable == taos_datap->irq_enabled)
+    {
+        SENSOR_LOG_INFO("doubule %s irq, retern here\n",enable? "enable" : "disable");
+        return;
+    }
+
+    if (enable)
+    {
+        enable_irq(taos_datap->client->irq);
+    }
+    else
+    {
+        if (flag_sync)
+        {
+            disable_irq(taos_datap->client->irq);
+
+        }
+        else
+        {
+            disable_irq_nosync(taos_datap->client->irq);
+        }
+    }
+
+    taos_datap->irq_enabled  = enable;
+    //SENSOR_LOG_INFO("%s irq \n",enable? "enable" : "disable");
+}
+
+
+static ssize_t attr_set_prox_led_pluse_cnt(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_pulse_cnt_param = val;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_pulse_cnt = prox_pulse_cnt_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0E), taos_cfgp->prox_pulse_cnt))) < 0) 
+        {
+            SENSOR_LOG_ERROR("failed to write the prox_pulse_cnt reg\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_prox_led_pluse_cnt(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_led_pluse_cnt is %d\n", taos_cfgp->prox_pulse_cnt);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_als_adc_time(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_int_time_param = 255 - val;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_int_time = prox_int_time_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x01), taos_cfgp->prox_int_time))) < 0) 
+        {
+            SENSOR_LOG_ERROR("failed to write the als_adc_time reg\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_als_adc_time(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "als_adc_time is 2.72 * %d ms\n", 255 - taos_cfgp->prox_int_time);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_prox_adc_time(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_adc_time_param = 255 - val;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_adc_time = prox_adc_time_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x02), taos_cfgp->prox_adc_time))) < 0) 
+        {
+            SENSOR_LOG_ERROR("failed to write the prox_adc_time reg\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_prox_adc_time(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_adc_time is 2.72 * %d ms\n", 255 - taos_cfgp->prox_adc_time);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_wait_time(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_wait_time_param = 255 - val;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_wait_time = prox_wait_time_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x03), taos_cfgp->prox_wait_time))) < 0) 
+        {   
+            SENSOR_LOG_ERROR("failed to write the wait_time reg\n");
+        }
+
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_wait_time(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "wait_time is 2.72 * %d ms\n", 255 - taos_cfgp->prox_wait_time);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_prox_led_strength_level(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (val>4 || val<=0)
+    {        
+        SENSOR_LOG_ERROR("input error, please input a number 1~~4");
+    }
+    else
+    {
+        val = 4 - val;
+        prox_gain_param = (prox_gain_param & 0x3F) | (val<<6);
+
+        if (NULL!=taos_cfgp)
+        {
+            taos_cfgp->prox_gain = prox_gain_param;
+            if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0F), taos_cfgp->prox_gain))) < 0) 
+            {
+                SENSOR_LOG_ERROR("failed to write the prox_led_strength reg\n");
+            }
+        }
+        else
+        {
+            SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+        }
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_prox_led_strength_level(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    char *p_led_strength[4] = {"100", "50", "25", "12.5"};
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_led_strength is %s mA\n", p_led_strength[(taos_cfgp->prox_gain) >> 6]);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_set_als_gain(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (val>4 || val<=0)
+    {        
+        SENSOR_LOG_ERROR("input error, please input a number 1~~4");
+    }
+    else
+    {
+        val = val-1;
+        prox_gain_param = (prox_gain_param & 0xFC) | val;
+        gain_param      = prox_gain_param & 0x03;
+
+        if (NULL!=taos_cfgp)
+        {
+            taos_cfgp->gain      = gain_param;
+            taos_cfgp->prox_gain = prox_gain_param;
+            if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0F), taos_cfgp->prox_gain))) < 0) 
+            {
+                SENSOR_LOG_ERROR("failed to write the prox_led_strength reg\n");
+            }
+        }
+        else
+        {
+            SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+        }
+    }
+
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_als_gain(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    u8 als_gain[4] = {1, 8, 16, 120};
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "als gain is x%d\n", als_gain[taos_cfgp->prox_gain & 0x03]);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_prox_debug_delay(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_debug_delay_time =  val;
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_prox_debug_delay(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_debug_delay_time is %d\n", prox_debug_delay_time);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_prox_debug_store(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (val)
+    {
+        flag_prox_debug = true;
+    }
+    else
+    {       
+        flag_prox_debug = false;
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_prox_debug_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "flag_prox_debug is %s\n", flag_prox_debug? "true" : "false");
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_calibrate_start_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "flag_prox_calibrate_startis %s\n", flag_prox_debug? "true" : "false");
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_prox_offset_cal_start_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "flag_prox_offset_cal_startis %s\n", flag_prox_debug? "true" : "false");
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_prox_phone_is_sleep_store(struct device *dev, struct device_attribute *attr, 
+                                            const char *buf, size_t size)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	unsigned int recv;
+    int ret = kstrtouint(buf, 10, &recv);
+    if (ret) 
+    {
+        SENSOR_LOG_ERROR("input error\n");
+        return -EINVAL;
+    }
+
+    mutex_lock(&chip->lock);
+    if (recv==chip->phone_is_sleep)
+    {
+        SENSOR_LOG_INFO("double %s phone_is_sleep\n",recv? "enable" : "false");
+    }
+    else
+    {        
+        chip->phone_is_sleep = recv;
+        SENSOR_LOG_INFO("success %s phone_is_sleep\n",recv? "enable" : "false");
+    }
+    mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t attr_prox_phone_is_sleep_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+    SENSOR_LOG_INFO("prox calibrate is %s\n",chip->phone_is_sleep? "true" : "false");
+	return snprintf(buf, PAGE_SIZE, "prox calibrate is %s\n\n", chip->phone_is_sleep? "true" : "false");
+}
+
+static ssize_t attr_prox_prox_wakelock_store(struct device *dev, struct device_attribute *attr, 
+                                            const char *buf, size_t size)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	unsigned int recv;
+    int ret = kstrtouint(buf, 10, &recv);
+    if (ret) 
+    {
+        SENSOR_LOG_ERROR("input error\n");
+        return -EINVAL;
+    }
+
+    mutex_lock(&chip->lock);
+    if (recv)
+    {
+        taos_wakelock_ops(&(chip->proximity_wakelock),true);
+    }
+    else
+    {       
+    	 //cancel_delayed_work_sync(&chip->prox_unwakelock_work);
+	hrtimer_cancel(&taos_datap->prox_unwakelock_timer);
+	taos_wakelock_ops(&(chip->proximity_wakelock),false);
+    }
+    mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t attr_prox_prox_wakelock_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+    SENSOR_LOG_INFO("proximity_wakelock is %s\n",chip->proximity_wakelock.locked ? "true" : "false");
+	return snprintf(buf, PAGE_SIZE, "proximity_wakelock is %s\n",chip->proximity_wakelock.locked ? "true" : "false");
+}
+
+
+//als
+static ssize_t attr_set_als_debug(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (val)
+    {
+        flag_als_debug = true;
+    }
+    else
+    {       
+        flag_als_debug = false;
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_als_debug(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "flag_prox_debug is %s\n", flag_als_debug? "true" : "false");
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_irq(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (val)
+    {
+        taos_irq_ops(true, true);
+    }
+    else
+    {       
+        taos_irq_ops(false, true);
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_irq(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        return sprintf(buf, "flag_irq is %s\n", taos_datap->irq_enabled? "true" : "false");
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_set_prox_calibrate(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    int val,ret;
+
+	ret=kstrtouint(buf, 10, &val);
+    SENSOR_LOG_ERROR("enter\n");
+    if (ret<0)
+    {
+        return -EINVAL;
+    }
+
+    if (val>1)
+    {
+     taos_datap->prox_calibrate_times= val;
+    taos_prox_calibrate();
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("your input error, please input a number that bigger than 1\n");
+    }
+   
+	return size;
+}
+
+static ssize_t attr_prox_thres_high_store(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (val>0)
+    {
+        prox_calibrate_hi_param = val;
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("you input error, please input a number that bigger than 0\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_prox_thres_high_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_calibrate_hi_param is %d\n",prox_calibrate_hi_param);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_thres_low_store(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (val>0)
+    {
+        prox_calibrate_lo_param = val;
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("you input error, please input a number that bigger than 0\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_prox_thres_low_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_calibrate_lo_param is %d\n",prox_calibrate_lo_param);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_thres_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_calibrate_lo_param is %d\n prox_calibrate_hi_param is %d\n",taos_cfgp->prox_threshold_lo,taos_cfgp->prox_threshold_hi);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+static ssize_t attr_prox_thres_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	static long value;
+	int rc;
+
+	rc = kstrtol(buf, 10, &value);
+	if (rc)
+		return -EINVAL;
+	mutex_lock(&taos_datap->lock);
+
+	if (value==1)
+    {
+   		if( (rc=taos_read_cal_value(CAL_THRESHOLD))<0)
+        {
+            mutex_unlock(&taos_datap->lock);
+            return -EINVAL;
+        }
+		else
+		{
+			if(rc > (taos_datap->prox_thres_hi_min))
+            		{
+			taos_datap->prox_calibrate_flag = false;
+			taos_datap->prox_manual_calibrate_threshold =rc;
+			taos_cfgp->prox_threshold_hi= rc;
+			taos_cfgp->prox_threshold_lo  = rc - PROX_THRESHOLD_DISTANCE;
+			input_report_rel(taos_datap->p_idev, REL_Y, taos_cfgp->prox_threshold_hi);
+			input_report_rel(taos_datap->p_idev, REL_Z, taos_cfgp->prox_threshold_lo);
+			input_sync(taos_datap->p_idev);
+			SENSOR_LOG_ERROR("prox_th_high  = %d\n",taos_cfgp->prox_threshold_hi);
+			SENSOR_LOG_ERROR("prox_th_low   = %d\n",taos_cfgp->prox_threshold_lo);
+           		 }
+
+		}
+	}
+	else
+    {	
+		mutex_unlock(&taos_datap->lock);
+		return -EINVAL;
+	}
+
+	mutex_unlock(&taos_datap->lock);
+
+	return size;
+}
+static ssize_t attr_set_als_scale_factor_param_prox(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (val>0)
+    {
+        scale_factor_param_prox = val;
+        if (NULL!=taos_cfgp)
+        {
+            taos_cfgp->scale_factor_prox = scale_factor_param_prox;
+        }
+        else
+        {
+            SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("you input error, please input a number that bigger than 0\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_get_als_scale_factor_param_prox(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        sprintf(buf, "als_scale_factor_param_prox is %d\n",taos_cfgp->scale_factor_prox);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_als_scale_factor_param_als(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (val>0)
+    {
+        scale_factor_param_als = val;
+        if (NULL!=taos_cfgp)
+        {
+            taos_cfgp->scale_factor_als = scale_factor_param_als;
+        }
+        else
+        {
+            SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("you input error, please input a number that bigger than 0\n");
+    }
+
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_get_als_scale_factor_param_als(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        sprintf(buf, "als_scale_factor_param_als is %d\n",taos_cfgp->scale_factor_als);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_get_prox_threshold_high(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "%d", taos_cfgp->prox_threshold_hi);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_prox_threshold_high(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_threshold_hi = val;
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+
+static ssize_t attr_get_prox_threshold_low(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "%d", taos_cfgp->prox_threshold_lo);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_prox_threshold_low(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_threshold_lo = val;
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_set_prox_offset(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_config_offset_param = val;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_config_offset = prox_config_offset_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x1E), taos_cfgp->prox_config_offset))) < 0) 
+        {
+            SENSOR_LOG_ERROR("failed to write the prox_config_offset  reg\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_prox_offset(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_config_offset_param is %d\n", taos_cfgp->prox_config_offset);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_calibrate_result_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        return sprintf(buf, "%d", taos_datap->prox_calibrate_result);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+static ssize_t attr_prox_offset_cal_result_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        return sprintf(buf, "%d", taos_datap->prox_offset_cal_result);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_thres_hi_max(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+            SENSOR_LOG_ERROR( "prox_thres_hi_max is %d\n",taos_datap->prox_thres_hi_max);
+
+        return sprintf(buf, "%d", taos_datap->prox_thres_hi_max);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_prox_thres_hi_min(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        SENSOR_LOG_ERROR("prox_thres_hi_min is %d\n",taos_datap->prox_thres_hi_min);
+        return sprintf(buf, "%d", taos_datap->prox_thres_hi_min);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_data_safa_range_max_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+            SENSOR_LOG_ERROR( "PROX_DATA_SAFE_RANGE_MAX is %d\n",PROX_DATA_SAFE_RANGE_MAX);
+
+        return sprintf(buf, "%d", PROX_DATA_SAFE_RANGE_MAX);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_prox_data_safa_range_min_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+                SENSOR_LOG_ERROR("PROX_DATA_SAFE_RANGE_MIN is %d\n",PROX_DATA_SAFE_RANGE_MIN);
+
+        return sprintf(buf, "%d", PROX_DATA_SAFE_RANGE_MIN);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+static ssize_t attr_chip_name_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        return sprintf(buf, "%s", taos_datap->chip_name);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_prox_data_max(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        return sprintf(buf, "%d", taos_datap->prox_data_max);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_manual_calibrate_threshold(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        return sprintf(buf, "%d", taos_datap->prox_manual_calibrate_threshold);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_reg_addr(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    reg_addr = val;
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_reg_addr(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+   
+    SENSOR_LOG_ERROR("enter\n");
+    SENSOR_LOG_ERROR("reg_addr = 0x%02X\n",reg_addr);
+	return strlen(buf);
+    SENSOR_LOG_ERROR("exit\n");
+
+}
+
+
+static ssize_t attr_set_reg_data(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (100==reg_addr)
+    {
+        SENSOR_LOG_ERROR("reg addr error!\n");
+    }
+    else
+    {
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|reg_addr), val))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write reg\n");
+        }   
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_get_reg_data(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    unsigned char i;
+    if (100 == reg_addr)
+    {
+        for (i=0x00; i<=0x0F; i++)
+        {
+            i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | i));
+            SENSOR_LOG_ERROR("reg[0x%02X] = 0x%02X",i,i2c_smbus_read_byte(taos_datap->client));
+        }
+        for (i=0x11; i<=0x19; i++)
+        {
+            i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | i));
+            SENSOR_LOG_ERROR("reg[0x%02X] = 0x%02X",i,i2c_smbus_read_byte(taos_datap->client));            
+        }
+
+        i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | 0x1F));
+        SENSOR_LOG_ERROR("reg[0x1F] = 0x%02X",i2c_smbus_read_byte(taos_datap->client));  
+    }   
+    else
+    {
+        i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | reg_addr));
+        SENSOR_LOG_ERROR("reg[0x%02X] = 0x%02X",reg_addr,i2c_smbus_read_byte(taos_datap->client)); 
+    }
+
+	return strlen(buf);
+}
+
+static ssize_t attr_get_prox_value(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+
+	 return sprintf(buf, "%d\n", last_proximity_data%100000);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+/*
+static struct device_attribute attributes[] = {
+#ifdef CONFIG_FEATURE_ZTEMT_SENSORS_LOG_ON
+	__ATTR(taos_prox_led_pluse_cnt,             0644,   attr_get_prox_led_pluse_cnt,                attr_set_prox_led_pluse_cnt),
+	__ATTR(taos_als_adc_time,                   0644,   attr_get_als_adc_time,                      attr_set_als_adc_time),
+	__ATTR(taos_prox_adc_time,                  0644,   attr_get_prox_adc_time,                     attr_set_prox_adc_time),
+	__ATTR(taos_wait_time,                      0644,   attr_get_wait_time,                         attr_set_wait_time),
+	__ATTR(taos_prox_led_strength_level,        0644,   attr_get_prox_led_strength_level,           attr_set_prox_led_strength_level),
+	__ATTR(taos_als_gain,                       0644,   attr_get_als_gain,                          attr_set_als_gain),
+	__ATTR(taos_prox_debug,                     0644,   attr_get_prox_debug,                        attr_set_prox_debug),
+	__ATTR(taos_als_debug,                      0644,   attr_get_als_debug,                         attr_set_als_debug),
+	__ATTR(taos_prox_debug_delay,               0644,   attr_get_prox_debug_delay,                  attr_set_prox_debug_delay),   
+	__ATTR(taos_irq,                            0644,   attr_get_irq,                               attr_set_irq),       
+	__ATTR(taos_prox_calibrate,                 0644,   NULL,                                       attr_set_prox_calibrate),
+	__ATTR(taos_prox_calibrate_hi_param,        0644,   attr_get_prox_calibrate_hi_param,           attr_set_prox_calibrate_hi_param),
+	__ATTR(taos_prox_calibrate_lo_param,        0644,   attr_get_prox_calibrate_lo_param,           attr_set_prox_calibrate_lo_param),
+	__ATTR(taos_als_scale_factor_param_als,     0644,   attr_get_als_scale_factor_param_als,        attr_set_als_scale_factor_param_als),
+	__ATTR(taos_als_scale_factor_param_prox,    0644,   attr_get_als_scale_factor_param_prox,       attr_set_als_scale_factor_param_prox),
+	__ATTR(taos_prox_threshold_high,            0644,   attr_get_prox_threshold_high,               NULL),
+	__ATTR(taos_prox_threshold_low,             0644,   attr_get_prox_threshold_low,                NULL),
+	__ATTR(taos_prox_offset,                    0644,   attr_get_prox_offset,                       attr_set_prox_offset),
+#endif
+    __ATTR(taos_reg_addr,                       0644,   attr_get_reg_addr,                          attr_set_reg_addr),
+    __ATTR(taos_reg_data,                       0644,   attr_get_reg_data,                          attr_set_reg_data),
+	__ATTR(th_hi,                               0644,   attr_get_threshold_hi,                      attr_set_threshold_hi),
+	__ATTR(th_low,                              0644,   attr_get_threshold_lo,                      attr_set_threshold_lo),
+	__ATTR(prox_value,                          0644,   attr_get_prox_value,                        NULL),
+};
+*/
+
+
+///***************************************************************************************///
+//light
+static ssize_t attr_als_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_on);
+}
+
+static ssize_t attr_als_enable_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	bool value;
+
+	if (strtobool(buf, &value))
+		return -EINVAL;
+
+    mutex_lock(&chip->lock);
+
+	if (value)
+    {
+        taos_sensors_als_poll_on();
+    }
+    else
+    {
+        taos_sensors_als_poll_off();
+    }
+
+    mutex_unlock(&chip->lock);
+
+	return size;
+}
+
+static ssize_t attr_als_poll_time_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "als_poll_time = %d\n", als_poll_delay);
+}
+
+static ssize_t attr_als_poll_time_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	unsigned long time;
+	int rc;
+
+	rc = kstrtoul(buf, 10, &time);
+	if (rc)
+		return -EINVAL;
+	als_poll_delay = time;
+	return size;
+}
+
+
+
+//prox
+static ssize_t attr_prox_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prox_on);
+}
+
+static ssize_t attr_prox_enable_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	bool value;
+	if (strtobool(buf, &value))
+		return -EINVAL;
+    mutex_lock(&chip->lock);
+    SENSOR_LOG_INFO("enter\n");
+
+	if (value)
+    {
+        taos_prox_on();
+    }
+	else
+    {
+        taos_prox_off();
+    }
+    SENSOR_LOG_INFO("exit\n");
+    mutex_unlock(&chip->lock);
+
+	return size;
+}
+
+static ssize_t attr_prox_init_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	return sprintf(buf, "chip->init%d\n", chip->init);
+	
+}
+
+static ssize_t attr_prox_init_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	int value =1;
+	int ret =0,err=1;
+	ret = kstrtouint(buf, 10, &value);
+	if (ret)
+		return -EINVAL;
+    mutex_lock(&taos_datap->lock);
+    SENSOR_LOG_INFO("enter\n");
+
+	if (value ==1)
+    {
+    	if((ret=taos_read_cal_value(PATH_PROX_OFFSET))>0)
+        {
+		    taos_cfgp->prox_config_offset = ret;
+        }
+
+    	if((ret=taos_read_cal_value(CAL_THRESHOLD))<0)
+		{
+		    SENSOR_LOG_ERROR("tmg399x_prox_init<0\n");
+		    err=taos_write_cal_file(CAL_THRESHOLD,0);
+			if(err<0)
+			{
+				SENSOR_LOG_ERROR("ERROR=%s\n",CAL_THRESHOLD);
+				mutex_unlock(&taos_datap->lock);
+				return -EINVAL;
+			}
+           	taos_datap->prox_calibrate_flag = true;
+		}
+		else 
+        {
+            if (ret==0)
+            {
+                taos_datap->prox_calibrate_flag = true;
+                SENSOR_LOG_ERROR("taos_prox_calibrate==1\n");
+    		}
+    		else 
+            {
+                taos_datap->prox_calibrate_flag = false;
+                taos_datap->prox_manual_calibrate_threshold =ret;
+                taos_cfgp->prox_threshold_hi = ret;
+                taos_cfgp->prox_threshold_lo  = ret - PROX_THRESHOLD_DISTANCE;
+                input_report_rel(taos_datap->p_idev, REL_Y, taos_cfgp->prox_threshold_hi);
+                input_report_rel(taos_datap->p_idev, REL_Z, taos_cfgp->prox_threshold_lo);
+                input_sync(taos_datap->p_idev);
+                SENSOR_LOG_ERROR("taos_prox_init> 0\n");
+    		}
+        }
+
+        if((ret=taos_read_cal_value(PATH_PROX_UNCOVER_DATA))>0)
+        {
+		    taos_datap->prox_uncover_data = ret;
+            taos_datap->prox_thres_hi_min = taos_datap->prox_uncover_data + PROX_THRESHOLD_SAFE_DISTANCE + PROX_THRESHOLD_DISTANCE;
+        }
+	}
+	else
+    {
+		SENSOR_LOG_ERROR("ERROR=tmg399x_prox_init_store\n");
+		mutex_unlock(&taos_datap->lock);
+		return -EINVAL;
+	}
+    SENSOR_LOG_INFO("exit\n");
+    mutex_unlock(&taos_datap->lock);
+
+	return size;
+}
+
+static ssize_t attr_prox_offset_cal_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	int value =1;
+	int ret =0;
+	ret = kstrtouint(buf, 10, &value);
+	if (ret)
+	{
+		return -EINVAL;
+	}
+		mutex_lock(&taos_datap->lock);
+		SENSOR_LOG_INFO("enter\n");
+
+	if (value ==1)
+      {
+             schedule_delayed_work(&taos_datap->prox_offset_cal_work, msecs_to_jiffies(0));
+             mutex_unlock(&taos_datap->lock);
+	}
+	else
+      {
+             SENSOR_LOG_ERROR("input error\n");
+       	mutex_unlock(&taos_datap->lock);
+		return -EINVAL;
+      }
+		SENSOR_LOG_INFO("exit\n");
+		return size;
+}
+
+
+static struct device_attribute attrs_light[] = {
+	__ATTR(enable,                         0640,   attr_als_enable_show,                       attr_als_enable_store),
+    __ATTR(light_gain,                     0644,   attr_get_als_gain,                          attr_set_als_gain),
+    __ATTR(light_debug,                    0644,   attr_get_als_debug,                         attr_set_als_debug),
+    __ATTR(light_adc_time,                 0644,   attr_get_als_adc_time,                      attr_set_als_adc_time),
+    __ATTR(light_scale_factor_param,       0644,   attr_get_als_scale_factor_param_als,        attr_set_als_scale_factor_param_als),
+    __ATTR(prox_scale_factor_param,        0644,   attr_get_als_scale_factor_param_prox,       attr_set_als_scale_factor_param_prox),
+    __ATTR(delay,                          0640,   attr_als_poll_time_show,                    attr_als_poll_time_store),
+};
+
+
+static struct device_attribute attrs_prox[] = {
+    __ATTR(chip_name,                      0640,   attr_chip_name_show,                        NULL),
+	__ATTR(enable,                         0640,   attr_prox_enable_show,                      attr_prox_enable_store),    
+	__ATTR(prox_init,                      0640,   attr_prox_init_show,                        attr_prox_init_store),  
+	__ATTR(prox_led_pluse_cnt,             0644,   attr_get_prox_led_pluse_cnt,                attr_set_prox_led_pluse_cnt),
+    __ATTR(prox_adc_time,                  0644,   attr_get_prox_adc_time,                     attr_set_prox_adc_time),
+    __ATTR(prox_led_strength_level,        0644,   attr_get_prox_led_strength_level,           attr_set_prox_led_strength_level),
+    __ATTR(prox_debug_delay,               0644,   attr_get_prox_debug_delay,                  attr_set_prox_debug_delay),   
+    __ATTR(prox_calibrate,                 0644,   NULL,                                       attr_set_prox_calibrate),
+    __ATTR(prox_threshold_high,            0644,   attr_get_prox_threshold_high,               attr_set_prox_threshold_high),
+    __ATTR(prox_threshold_low,             0644,   attr_get_prox_threshold_low,                attr_set_prox_threshold_low),
+    __ATTR(prox_offset,                    0644,   attr_get_prox_offset,                       attr_set_prox_offset),
+    __ATTR(prox_value,                     0644,   attr_get_prox_value,                        NULL),
+    __ATTR(prox_calibrate_result,          0640,   attr_prox_calibrate_result_show,            NULL), 
+    __ATTR(prox_thres_param_high,          0640,   attr_prox_thres_high_show,                  attr_prox_thres_high_store),
+    __ATTR(prox_thres_param_low,           0640,   attr_prox_thres_low_show,                   attr_prox_thres_low_store),
+    __ATTR(prox_thres,                     0640,   attr_prox_thres_show,                       attr_prox_thres_store),
+    __ATTR(prox_debug,                     0640,   attr_prox_debug_show,                       attr_prox_debug_store),
+    __ATTR(prox_calibrate_start,           0640,   attr_prox_calibrate_start_show,             attr_prox_debug_store),
+    __ATTR(prox_thres_max,                 0644,   attr_prox_thres_hi_max,                     NULL), 
+    __ATTR(prox_thres_min,                 0644,   attr_prox_thres_hi_min,                     NULL), 
+    __ATTR(prox_data_max,                  0640,   attr_prox_data_max,                         NULL), 
+    __ATTR(prox_manual_calibrate_threshold,0644,   attr_prox_manual_calibrate_threshold,       NULL), 
+    __ATTR(prox_phone_is_sleep,            0640,   attr_prox_phone_is_sleep_show,              attr_prox_phone_is_sleep_store),
+    __ATTR(prox_wakelock,                  0640,   attr_prox_prox_wakelock_show,               attr_prox_prox_wakelock_store),
+    __ATTR(reg_addr,                       0644,   attr_get_reg_addr,                          attr_set_reg_addr),
+    __ATTR(reg_data,                       0644,   attr_get_reg_data,                          attr_set_reg_data),
+    __ATTR(irq_status,                     0644,   attr_get_irq,                               attr_set_irq),       
+    __ATTR(wait_time,                      0644,   attr_get_wait_time,                         attr_set_wait_time),
+    __ATTR(prox_offset_cal_start,           0640,   attr_prox_offset_cal_start_show,     attr_prox_debug_store),
+    __ATTR(prox_offset_cal,                 0640,   attr_get_prox_offset,           attr_prox_offset_cal_store),
+    __ATTR(prox_offset_cal_result,          0640,   attr_prox_offset_cal_result_show,            NULL), 
+    __ATTR(prox_data_safe_range_max,        0644,   attr_prox_data_safa_range_max_show,  NULL), 
+    __ATTR(prox_data_safe_range_min,        0644,   attr_prox_data_safa_range_min_show,  NULL), 
+
+};
+
+
+
+static int create_sysfs_interfaces_prox(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attrs_prox); i++)
+		if (device_create_file(dev, attrs_prox + i))
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attrs_prox + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static int create_sysfs_interfaces_light(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attrs_light); i++)
+		if (device_create_file(dev, attrs_light + i))
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attrs_light + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+
+static void taos_wakelock_ops(struct taos_wake_lock *wakelock, bool enable)
+{
+    if (enable == wakelock->locked)
+    {
+        SENSOR_LOG_INFO("doubule %s %s, retern here\n",enable? "lock" : "unlock",wakelock->name);
+        return;
+    }
+
+    if (enable)
+    {
+        wake_lock(&wakelock->lock);
+    }
+    else
+    {
+        wake_unlock(&wakelock->lock);
+    }
+
+    wakelock->locked = enable;
+
+    SENSOR_LOG_INFO("%s %s \n",enable? "lock" : "unlock",wakelock->name);
+}
+
+static int taos_write_cal_file(char *file_path,unsigned int value)
+{
+    struct file *file_p;
+    char write_buf[10];
+	 mm_segment_t old_fs; 
+    int vfs_write_retval=0;
+    if (NULL==file_path)
+    {
+        SENSOR_LOG_ERROR("file_path is NULL\n");
+      
+    }
+       memset(write_buf, 0, sizeof(write_buf));
+      sprintf(write_buf, "%d\n", value);
+    file_p = filp_open(file_path, O_CREAT|O_RDWR , 0665);
+    if (IS_ERR(file_p))
+    {
+        SENSOR_LOG_ERROR("[open file <%s>failed]\n",file_path);
+        goto error;
+    }
+    old_fs = get_fs();
+    set_fs(KERNEL_DS);
+    
+    vfs_write_retval = vfs_write(file_p, (char*)write_buf, sizeof(write_buf), &file_p->f_pos);
+    if (vfs_write_retval < 0)
+    {
+        SENSOR_LOG_ERROR("[write file <%s>failed]\n",file_path);
+        goto error;
+    }
+
+    set_fs(old_fs);
+    filp_close(file_p, NULL);
+
+
+    return 1;
+
+error:
+    return -1;
+}
+
+
+static int taos_read_cal_value(char *file_path)
+{
+    struct file *file_p;
+    int vfs_read_retval = 0;
+    mm_segment_t old_fs; 
+    char read_buf[32];
+    unsigned short read_value;
+
+    if (NULL==file_path)
+    {
+        SENSOR_LOG_ERROR("file_path is NULL\n");
+        goto error;
+    }
+
+    memset(read_buf, 0, 32);
+
+    file_p = filp_open(file_path, O_RDONLY , 0);
+    if (IS_ERR(file_p))
+    {
+        SENSOR_LOG_ERROR("[open file <%s>failed]\n",file_path);
+        goto error;
+    }
+
+    old_fs = get_fs();
+    set_fs(KERNEL_DS);
+    
+    vfs_read_retval = vfs_read(file_p, (char*)read_buf, 16, &file_p->f_pos);
+    if (vfs_read_retval < 0)
+    {
+        SENSOR_LOG_ERROR("[read file <%s>failed]\n",file_path);
+        goto error;
+    }
+
+    set_fs(old_fs);
+    filp_close(file_p, NULL);
+
+    if (kstrtou16(read_buf, 10, &read_value) < 0)
+    {
+        SENSOR_LOG_ERROR("[kstrtou16 %s failed]\n",read_buf);
+        goto error;
+    }
+    
+    SENSOR_LOG_ERROR("[the content of %s is %s]\n", file_path, read_buf);
+
+    return read_value;
+
+error:
+    return -1;
+}
+
+static void taos_irq_work_func(struct work_struct * work) //iVIZM
+{
+    int retry_times = 0;
+    int ret;
+    mutex_lock(&taos_datap->lock);
+    SENSOR_LOG_INFO("enter\n");
+    if (wakeup_from_sleep)
+    {  
+        SENSOR_LOG_INFO(" wakeup_from_sleep = true\n");
+        mdelay(50);
+        wakeup_from_sleep = false;
+    }
+
+    for (retry_times=0; retry_times<=50; retry_times++)
+    {
+        ret = taos_get_data();
+        if (ret >= 0)
+        {
+            break;
+        }
+        mdelay(20);
+    }
+    taos_interrupts_clear();
+
+    hrtimer_cancel(&taos_datap->prox_unwakelock_timer);
+    taos_datap->irq_work_status = false;
+   // SENSOR_LOG_INFO("########  taos_irq_work_func enter   hrtimer_start #########\n");
+    hrtimer_start(&taos_datap->prox_unwakelock_timer, ktime_set(3, 0), HRTIMER_MODE_REL);
+
+   //  schedule_delayed_work(&taos_datap->prox_unwakelock_work, msecs_to_jiffies(1000));
+	
+    taos_irq_ops(true, true);
+    SENSOR_LOG_INFO(" retry_times = %d\n",retry_times);
+    mutex_unlock(&taos_datap->lock);
+}
+
+static irqreturn_t taos_irq_handler(int irq, void *dev_id) //iVIZM
+{
+    SENSOR_LOG_INFO("enter\n");
+    taos_datap->irq_work_status = true;
+    taos_irq_ops(false, false);
+    taos_wakelock_ops(&(taos_datap->proximity_wakelock), true);
+    if (0==queue_work(taos_datap->irq_work_queue, &taos_datap->irq_work))
+    {
+        SENSOR_LOG_INFO("schedule_work failed!\n");
+    }
+    SENSOR_LOG_INFO("exit\n");
+    return IRQ_HANDLED;
+}
+
+static int taos_get_data(void)//iVIZM
+{
+    int ret = 0;
+
+    ret = i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_STATUS));
+    
+    if (ret < 0)
+    {
+        SENSOR_LOG_ERROR("read TAOS_TRITON_STATUS failed\n");
+        return ret;
+    }
+    else
+    { 
+        ret = taos_prox_threshold_set();
+    }
+    return ret;
+}
+
+
+static int taos_interrupts_clear(void)//iVIZM
+{
+    int ret = 0;
+    if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG|TAOS_TRITON_CMD_SPL_FN|0x07)))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte(2) failed in taos_work_func()\n");
+        return (ret);
+    }
+    return ret;
+}
+
+static int taos_als_get_data(void)//iVIZM
+{
+    int ret = 0;
+    u8 reg_val;
+    int lux_val = 0;
+    if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL)))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte failed in ioctl als_data\n");
+        return (ret);
+    }
+    reg_val = i2c_smbus_read_byte(taos_datap->client);
+    if ((reg_val & (TAOS_TRITON_CNTL_ADC_ENBL | TAOS_TRITON_CNTL_PWRON)) != (TAOS_TRITON_CNTL_ADC_ENBL | TAOS_TRITON_CNTL_PWRON))
+        return -ENODATA;
+    if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_STATUS)))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte failed in ioctl als_data\n");
+        return (ret);
+    }
+    reg_val = i2c_smbus_read_byte(taos_datap->client);
+    if ((reg_val & TAOS_TRITON_STATUS_ADCVALID) != TAOS_TRITON_STATUS_ADCVALID)
+        return -ENODATA;
+
+    if ((lux_val = taos_get_lux()) < 0)
+    {
+        printk(KERN_ERR "TAOS: call to taos_get_lux() returned error %d in ioctl als_data\n", lux_val);
+    }
+
+    if (lux_val<TAOS_ALS_GAIN_DIVIDE && gain_param!=TAOS_ALS_GAIN_8X)
+    {
+        taos_als_gain_set(TAOS_ALS_GAIN_8X);
+    }
+    else
+    {
+        if (lux_val>TAOS_ALS_GAIN_DIVIDE && gain_param!=TAOS_ALS_GAIN_1X)
+        {
+            taos_als_gain_set(TAOS_ALS_GAIN_1X);
+        }
+    }
+    
+    if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_ALS_TIME)))) < 0)
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte failed in ioctl als_data\n");
+        return (ret);
+    }
+
+    reg_val = i2c_smbus_read_byte(taos_datap->client);
+
+    if (flag_als_debug)
+    {        
+        SENSOR_LOG_ERROR(KERN_INFO "reg_val = %d lux_val = %d\n",reg_val,lux_val);
+    }
+
+    if (reg_val != prox_int_time_param)
+    {
+        lux_val = (lux_val * (101 - (0XFF - reg_val)))/20;
+    }
+
+    lux_val = taos_lux_filter(lux_val);
+
+    if (flag_als_debug)
+    {        
+        SENSOR_LOG_ERROR(KERN_INFO "lux_val = %d",lux_val);
+    }
+
+    input_report_rel(taos_datap->a_idev, REL_X, lux_val+1);
+    input_sync(taos_datap->a_idev);
+
+    return ret;
+}
+
+static int taos_prox_threshold_set(void)//iVIZM
+{
+    int i,ret = 0;
+    u8 chdata[6];
+    u16 proxdata = 0;
+    u16 cleardata = 0;
+
+    for (i = 0; i < 6; i++) {
+        chdata[i] = (i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CMD_WORD_BLK_RW| (TAOS_TRITON_ALS_CHAN0LO + i))));
+    }
+    cleardata = chdata[0] + chdata[1]*256;
+    proxdata = chdata[4] + chdata[5]*256;
+
+	if (pro_ft || flag_prox_debug)
+    {
+        pro_buf[0] = 0xff;
+        pro_buf[1] = 0xff;
+        pro_buf[2] = 0xff;
+        pro_buf[3] = 0xff;
+        
+        for( mcount=0; mcount<4; mcount++ )
+        {
+            if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x08) + mcount, pro_buf[mcount]))) < 0)
+            {
+                 printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in taos prox threshold set\n");
+                 return (ret);
+            }
+        }      
+
+        if (pro_ft)
+        {
+            SENSOR_LOG_INFO( "init the prox threshold");
+        }
+
+        if (flag_prox_debug)
+        {
+            mdelay(prox_debug_delay_time);
+            SENSOR_LOG_INFO( "proxdata = %d",proxdata);
+	        input_report_rel(taos_datap->p_idev, REL_MISC, proxdata);
+
+        }
+		pro_ft = false;
+	} 
+    else 
+    {
+        if (proxdata < taos_cfgp->prox_threshold_lo) 
+        {   //FAR
+            pro_buf[0] = 0x0;
+            pro_buf[1] = 0x0;
+            pro_buf[2] = taos_cfgp->prox_threshold_hi & 0x0ff;
+            pro_buf[3] = taos_cfgp->prox_threshold_hi >> 8;
+    		SENSOR_LOG_INFO( "Far!!! proxdata = %d\n",proxdata);
+            input_report_rel(taos_datap->p_idev, REL_X, proxdata);
+        } 
+        else 
+        {
+                if (proxdata > taos_cfgp->prox_threshold_hi)
+                {   //NEAR
+                    if (cleardata > ((sat_als*80)/100))
+                    {
+                    	printk(KERN_ERR "TAOS: %u <= %u*0.8 int data\n",proxdata,sat_als);
+                    	msleep(100);
+                        return -ENODATA;
+                    }
+                    pro_buf[0] = taos_cfgp->prox_threshold_lo & 0x0ff;
+                    pro_buf[1] = taos_cfgp->prox_threshold_lo >> 8;
+                    pro_buf[2] = 0xff;
+                    pro_buf[3] = 0xff;
+                    SENSOR_LOG_INFO("Near!!! proxdata = %d\n",proxdata);
+                    input_report_rel(taos_datap->p_idev, REL_X, proxdata);
+                }
+                else
+                {
+                    if( (taos_cfgp->prox_threshold_hi-proxdata) > (proxdata-taos_cfgp->prox_threshold_lo))
+                    {
+                        //FAR
+                        pro_buf[0] = 0x0;
+                        pro_buf[1] = 0x0;
+                        pro_buf[2] = taos_cfgp->prox_threshold_hi & 0x0ff;
+                        pro_buf[3] = taos_cfgp->prox_threshold_hi >> 8;
+                		SENSOR_LOG_INFO( "Far!!! proxdata = %d\n",proxdata);
+                        input_report_rel(taos_datap->p_idev, REL_X, taos_cfgp->prox_threshold_lo-50);
+                    }
+                    else
+                    {
+                        //NEAR
+                        if (cleardata > ((sat_als*80)/100))
+                        {
+                        	printk(KERN_ERR "TAOS: %u <= %u*0.8 int data\n",proxdata,sat_als);
+                        	msleep(100);
+                            return -ENODATA;
+                        }
+                        pro_buf[0] = taos_cfgp->prox_threshold_lo & 0x0ff;
+                        pro_buf[1] = taos_cfgp->prox_threshold_lo >> 8;
+                        pro_buf[2] = 0xff;
+                        pro_buf[3] = 0xff;
+                        SENSOR_LOG_INFO( "Near!!! proxdata = %d\n",proxdata);
+                        input_report_rel(taos_datap->p_idev, REL_X, taos_cfgp->prox_threshold_hi+50);
+                    }
+                }
+            }
+    }
+
+    input_sync(taos_datap->p_idev);
+
+    for( mcount=0; mcount<4; mcount++) 
+    { 
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x08) + mcount, pro_buf[mcount]))) < 0)
+        {
+             printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in taos prox threshold set\n");
+             return (ret);
+        }
+    }
+
+    return ret;
+}
+
+// driver init
+static int __init taos_init(void) 
+{
+#ifdef CONFIG_ZTEMT_SENSORS_ALS_PS_AUTO_DETECT
+    return 0;
+#else
+    return i2c_add_driver(&tmd2772_driver);
+#endif
+}
+
+// driver exit
+static void __exit taos_exit(void) 
+{
+	i2c_del_driver(&tmd2772_driver);
+}
+
+static int tmd2772_parse_dt(struct taos_data *chip)
+{
+	struct device_node *np = chip->client->dev.of_node;
+	chip->irq_pin_num = of_get_named_gpio(np, "ams,irq-gpio", 0);
+    SENSOR_LOG_INFO("irq_pin_num is %d\n",chip->irq_pin_num);
+    return 0;
+}
+
+static void tmd2772_data_init(void)
+{
+    taos_datap->als_on  = false;
+    taos_datap->prox_on = false;
+    taos_datap->init = false;
+    taos_datap->als_poll_time_mul = 1;
+    taos_datap->prox_name = "proximity";
+    taos_datap->als_name  = "light";
+    taos_datap->chip_name = "tmd2772";
+    taos_datap->prox_calibrate_result = false;
+    taos_datap->prox_offset_cal_result = false;
+    taos_datap->prox_thres_hi_max = PROX_THRESHOLD_HIGH_MAX;
+    taos_datap->prox_thres_hi_min = PROX_DATA_SAFE_RANGE_MAX + PROX_THRESHOLD_DISTANCE;
+    taos_datap->prox_data_max     = PROX_DATA_MAX;
+    taos_datap->prox_uncover_data = 0;
+    taos_datap->prox_calibrate_times = 10;
+    taos_datap->prox_calibrate_flag = true;//true :auto_calibrate,false :manual_calibrate
+    taos_datap->prox_manual_calibrate_threshold = 0;
+    taos_datap->proximity_wakelock.name = "proximity-wakelock";
+    taos_datap->proximity_wakelock.locked = false;
+    taos_datap->phone_is_sleep = false;
+    taos_datap->irq_work_status = false;
+    taos_datap->irq_enabled = true;
+}
+
+
+
+// client probe
+static int __devinit tmd2772_probe(struct i2c_client *clientp, const struct i2c_device_id *idp) 
+{
+    int ret = 0;
+    int i = 0;
+    int chip_id = -1;
+    unsigned char buf[TAOS_MAX_DEVICE_REGS];
+    char *device_name;
+    SENSOR_LOG_INFO("Prob Start\n");
+    chip_id = i2c_smbus_read_byte_data(clientp, (TAOS_TRITON_CMD_REG | (TAOS_TRITON_CNTRL + 0x12))); //iVIZM
+    /*TSL27711=0x00 TSL27713=0x09 TMD27711=0x20 TMD27713=0x29 	2011.09.07*/
+	SENSOR_LOG_ERROR(" TAOS chip_id = %x TMD27713=30,TMD27723=39\n",chip_id);	
+	//printk(" TAOS ID reg = %d\n",(TAOS_TRITON_CMD_REG | (TAOS_TRITON_CNTRL + 0x12)));	
+    if(chip_id != 0x39) 
+    {
+    	printk(" chip id that was read does not match TMD27723\n");	
+        return -ENODEV;
+    }
+    if (device_found)
+        return -ENODEV;
+    if (!i2c_check_functionality(clientp->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) 
+    {
+        printk(KERN_ERR "TAOS: taos_probe() - i2c smbus byte data functions unsupported\n");
+        return -EOPNOTSUPP;
+    }
+
+    taos_datap = kmalloc(sizeof(struct taos_data), GFP_KERNEL);
+    if (!taos_datap) 
+    {
+         SENSOR_LOG_ERROR("kmalloc for struct taos_data failed\n");
+         return -ENOMEM;
+    }
+
+    taos_datap->client = clientp;
+
+    i2c_set_clientdata(clientp, taos_datap);
+
+    
+
+    INIT_WORK(&(taos_datap->irq_work),taos_irq_work_func);  
+
+	sema_init(&taos_datap->update_lock,1);
+	mutex_init(&(taos_datap->lock));
+    wake_lock_init(&taos_datap->proximity_wakelock.lock, WAKE_LOCK_SUSPEND, "proximity-wakelock");
+
+    tmd2772_data_init();
+
+    tmd2772_parse_dt(taos_datap);
+
+    for (i = 0; i < TAOS_MAX_DEVICE_REGS; i++) 
+    {
+        if ((ret = (i2c_smbus_write_byte(clientp, (TAOS_TRITON_CMD_REG | (TAOS_TRITON_CNTRL + i))))) < 0) 
+        {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte() to control reg failed in taos_probe()\n");
+            return(ret);
+        }
+        buf[i] = i2c_smbus_read_byte(clientp);
+    }
+
+    if ((ret = taos_device_name(buf, &device_name)) == 0) 
+    {
+        printk(KERN_ERR "TAOS: chip id that was read found mismatched by taos_device_name(), in taos_probe()\n");
+        return -ENODEV;
+    }
+    if (strcmp(device_name, TAOS_DEVICE_ID)) 
+    {
+        printk(KERN_ERR "TAOS: chip id that was read does not match expected id in taos_probe()\n");
+        return -ENODEV;
+    }
+    else 
+    {
+        SENSOR_LOG_ERROR( "TAOS: chip id of %s that was read matches expected id in taos_probe()\n", device_name);
+        device_found = 1;
+    }
+    if ((ret = (i2c_smbus_write_byte(clientp, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL)))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte() to control reg failed in taos_probe()\n");
+        return(ret);
+    }
+    strlcpy(clientp->name, TAOS_DEVICE_ID, I2C_NAME_SIZE);
+    strlcpy(taos_datap->taos_name, TAOS_DEVICE_ID, TAOS_ID_NAME_SIZE);
+    taos_datap->valid = 0;
+    if (!(taos_cfgp = kmalloc(sizeof(struct taos_cfg), GFP_KERNEL))) {
+        printk(KERN_ERR "TAOS: kmalloc for struct taos_cfg failed in taos_probe()\n");
+        return -ENOMEM;
+    }
+    taos_cfgp->calibrate_target = calibrate_target_param;
+    taos_cfgp->als_time = als_time_param;
+    taos_cfgp->scale_factor_als = scale_factor_param_als;
+	taos_cfgp->scale_factor_prox = scale_factor_param_prox;
+    taos_cfgp->gain_trim = gain_trim_param;
+    taos_cfgp->filter_history = filter_history_param;
+    taos_cfgp->filter_count = filter_count_param;
+    taos_cfgp->gain = gain_param;
+    taos_cfgp->als_threshold_hi = als_threshold_hi_param;//iVIZM
+    taos_cfgp->als_threshold_lo = als_threshold_lo_param;//iVIZM
+    taos_cfgp->prox_threshold_hi = prox_threshold_hi_param;
+    taos_cfgp->prox_threshold_lo = prox_threshold_lo_param;
+    taos_cfgp->prox_int_time = prox_int_time_param;
+    taos_cfgp->prox_adc_time = prox_adc_time_param;
+    taos_cfgp->prox_wait_time = prox_wait_time_param;
+    taos_cfgp->prox_intr_filter = prox_intr_filter_param;
+    taos_cfgp->prox_config = prox_config_param;
+    taos_cfgp->prox_pulse_cnt = prox_pulse_cnt_param;
+    taos_cfgp->prox_gain = prox_gain_param;
+    taos_cfgp->prox_config_offset=prox_config_offset_param;
+    sat_als = (256 - taos_cfgp->prox_int_time) << 10;
+    sat_prox = (256 - taos_cfgp->prox_adc_time) << 10;
+
+    /*dmobile ::power down for init ,Rambo liu*/
+    SENSOR_LOG_ERROR("TAOS:Rambo::light sensor will pwr down \n");
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x00), 0x00))) < 0) {
+        printk(KERN_ERR "TAOS:Rambo, i2c_smbus_write_byte_data failed in power down\n");
+        return (ret);
+    }
+
+
+    taos_datap->irq_work_queue = create_singlethread_workqueue("taos_work_queue");
+    if (!taos_datap->irq_work_queue)
+    {
+        ret = -ENOMEM;
+        SENSOR_LOG_INFO( "---------%s: %d: cannot create work taos_work_queue, err = %d",__func__,__LINE__,ret);
+        return ret;
+    }
+
+    ret = gpio_request(taos_datap->irq_pin_num, "ALS_PS_INT");
+    if (ret)    
+    {
+        SENSOR_LOG_INFO("gpio %d is busy and then to free it\n",taos_datap->irq_pin_num);
+        
+        gpio_free(taos_datap->irq_pin_num);
+        ret = gpio_request(taos_datap->irq_pin_num, "ALS_PS_INT");
+        if (ret) 
+        {
+            SENSOR_LOG_INFO("gpio %d is busy and then to free it\n",taos_datap->irq_pin_num);
+            return ret;
+        }
+    }
+    else
+    {
+        SENSOR_LOG_INFO("get gpio %d success\n",taos_datap->irq_pin_num);
+    }
+
+
+    ret = gpio_tlmm_config(GPIO_CFG(taos_datap->irq_pin_num, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+
+    taos_datap->client->irq = gpio_to_irq(taos_datap->irq_pin_num);
+
+	ret = request_threaded_irq(taos_datap->client->irq, NULL, &taos_irq_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT, "taos_irq", taos_datap);
+    if (ret != 0) 
+    {
+        gpio_free(taos_datap->irq_pin_num);
+        return(ret);
+    }
+
+    taos_irq_ops(false, true);
+    INIT_DELAYED_WORK(&taos_datap->als_poll_work, taos_als_poll_work_func);
+    INIT_DELAYED_WORK(&taos_datap->prox_calibrate_work, taos_prox_calibrate_work_func);
+    INIT_DELAYED_WORK(&taos_datap->prox_offset_cal_work, taos_prox_offset_cal_work_func);
+
+  //  INIT_DELAYED_WORK(&taos_datap->prox_unwakelock_work, taos_prox_unwakelock_work_func);
+    hrtimer_init(&taos_datap->prox_unwakelock_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    ( taos_datap->prox_unwakelock_timer).function = taos_prox_unwakelock_work_func ;
+   // hrtimer_start(&taos_datap->prox_unwakelock_timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+    proximity_class = class_create(THIS_MODULE, "proximity");
+    light_class     = class_create(THIS_MODULE, "light");
+
+    taos_datap->proximity_dev = device_create(proximity_class, NULL, tmd2772_proximity_dev_t, &tmd2772_driver ,"proximity");
+    if (IS_ERR(taos_datap->proximity_dev)) 
+    {
+      ret = PTR_ERR(taos_datap->proximity_dev);
+      SENSOR_LOG_ERROR("device_create proximity failed\n");
+      goto create_proximity_dev_failed;
+    }
+
+    taos_datap->light_dev= device_create(light_class, NULL, tmd2772_light_dev_t, &tmd2772_driver ,"light");
+    if (IS_ERR(taos_datap->light_dev)) 
+    {
+      ret = PTR_ERR(taos_datap->light_dev);
+      SENSOR_LOG_ERROR("device_create light failed\n");
+      goto create_light_dev_failed;
+    }
+
+    //prox input 
+    taos_datap->p_idev = input_allocate_device();
+    if (!taos_datap->p_idev)
+    {
+        SENSOR_LOG_ERROR("no memory for input_dev '%s'\n",taos_datap->prox_name);
+        ret = -ENODEV;
+        goto input_p_alloc_failed;
+    }
+    taos_datap->p_idev->name = taos_datap->prox_name;
+    taos_datap->p_idev->id.bustype = BUS_I2C;
+    dev_set_drvdata(&taos_datap->p_idev->dev, taos_datap);
+    ret = input_register_device(taos_datap->p_idev);
+    if (ret) 
+    {
+        input_free_device(taos_datap->p_idev);
+        SENSOR_LOG_ERROR("cant register input '%s'\n",taos_datap->prox_name);
+        goto input_p_register_failed;
+    }
+
+    set_bit(EV_REL, taos_datap->p_idev->evbit);
+    set_bit(REL_X,  taos_datap->p_idev->relbit);
+    set_bit(REL_Y,  taos_datap->p_idev->relbit);
+    set_bit(REL_Z,  taos_datap->p_idev->relbit);
+    set_bit(REL_MISC,  taos_datap->p_idev->relbit);
+
+    //light input
+    taos_datap->a_idev = input_allocate_device();
+	if (!taos_datap->a_idev) 
+    {
+		SENSOR_LOG_ERROR("no memory for input_dev '%s'\n",taos_datap->als_name);
+		ret = -ENODEV;
+		goto input_a_alloc_failed;
+	}
+	taos_datap->a_idev->name = taos_datap->als_name;
+	taos_datap->a_idev->id.bustype = BUS_I2C;
+    
+    /*
+	set_bit(EV_ABS, chip->a_idev->evbit);
+	set_bit(ABS_MISC, chip->a_idev->absbit);
+	input_set_abs_params(chip->a_idev, ABS_MISC, 0, 65535, 0, 0);
+    */
+
+    set_bit(EV_REL, taos_datap->a_idev->evbit);
+    set_bit(REL_X,  taos_datap->a_idev->relbit);
+    set_bit(REL_Y,  taos_datap->a_idev->relbit);
+
+
+	//chip->a_idev->open = tmg399x_als_idev_open;
+	//chip->a_idev->close = tmg399x_als_idev_close;
+	dev_set_drvdata(&taos_datap->a_idev->dev, taos_datap);
+	ret = input_register_device(taos_datap->a_idev);
+	if (ret) 
+    {
+		input_free_device(taos_datap->a_idev);
+		SENSOR_LOG_ERROR("cant register input '%s'\n",taos_datap->prox_name);
+		goto input_a_register_failed;
+	}
+
+	dev_set_drvdata(taos_datap->proximity_dev, taos_datap);
+	dev_set_drvdata(taos_datap->light_dev, taos_datap);
+
+
+    create_sysfs_interfaces_prox(taos_datap->proximity_dev);
+    create_sysfs_interfaces_light(taos_datap->light_dev);
+
+    SENSOR_LOG_INFO("Prob OK\n");
+
+	return 0;
+
+
+input_a_register_failed:
+    input_free_device(taos_datap->a_idev);
+input_a_alloc_failed:
+
+input_p_register_failed:
+    input_free_device(taos_datap->p_idev);
+input_p_alloc_failed:
+
+create_light_dev_failed:
+    taos_datap->light_dev = NULL;
+    class_destroy(light_class);
+
+create_proximity_dev_failed:
+    taos_datap->proximity_dev = NULL;
+    class_destroy(proximity_class);
+
+    SENSOR_LOG_INFO("Prob Failed\n");
+
+    return (ret);
+}
+
+#ifdef CONFIG_PM_SLEEP
+//don't move these pm blew to ioctl
+//resume  
+static int taos_resume(struct i2c_client *client) {
+	int ret = 0;
+    SENSOR_LOG_INFO("enter\n");
+	if(1 == taos_datap->prox_on)
+    {
+        SENSOR_LOG_INFO( "----------%s: %d: disable irq wakeup\n",__func__,__LINE__);
+		ret = disable_irq_wake(taos_datap->client->irq);
+	}
+    if(ret < 0)
+		printk(KERN_ERR "TAOS: disable_irq_wake failed\n");
+    SENSOR_LOG_INFO("eixt\n");
+    return ret ;
+}
+
+//suspend  
+static int taos_suspend(struct i2c_client *client, pm_message_t mesg) 
+{
+	int ret = 0;
+    SENSOR_LOG_INFO("enter\n");
+	if(1 == taos_datap->prox_on)
+    {
+        SENSOR_LOG_INFO( "----------%s: %d: enable irq wakeup\n",__func__,__LINE__);
+       	ret = enable_irq_wake(taos_datap->client->irq);
+    }
+	if(ret < 0)
+    {
+		printk(KERN_ERR "TAOS: enable_irq_wake failed\n");
+    }
+
+    wakeup_from_sleep = true;
+
+    SENSOR_LOG_INFO("eixt\n");
+    return ret ;
+}
+
+#endif
+// client remove
+static int __devexit tmd2772_remove(struct i2c_client *client) {
+    int ret = 0;
+
+    return (ret);
+}
+
+
+// read/calculate lux value
+static int taos_get_lux(void) 
+{
+    int raw_clear = 0, raw_ir = 0, raw_lux = 0;
+    u32 lux = 0;
+    u32 ratio = 0;
+    u8 dev_gain = 0;
+    u16 Tint = 0;
+    struct lux_data *p;
+    int ret = 0;
+    u8 chdata[4];
+    int tmp = 0, i = 0,tmp_gain=1;
+    for (i = 0; i < 4; i++) {
+        if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | (TAOS_TRITON_ALS_CHAN0LO + i))))) < 0) {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte() to chan0/1/lo/hi reg failed in taos_get_lux()\n");
+            return (ret);
+        }
+        chdata[i] = i2c_smbus_read_byte(taos_datap->client);
+    }
+
+    tmp = (taos_cfgp->als_time + 25)/50;            //if atime =100  tmp = (atime+25)/50=2.5   time = 2.7*(256-atime)=  412.5
+    TritonTime.numerator = 1;
+    TritonTime.denominator = tmp;
+
+    tmp = 300 * taos_cfgp->als_time;               //tmp = 300*atime  400
+    if(tmp > 65535)
+        tmp = 65535;
+    TritonTime.saturation = tmp;
+    raw_clear = chdata[1];
+    raw_clear <<= 8;
+    raw_clear |= chdata[0];
+    raw_ir    = chdata[3];
+    raw_ir    <<= 8;
+    raw_ir    |= chdata[2];
+
+    raw_clear *= ((taos_cfgp->scale_factor_als )*tmp_gain);
+    raw_ir *= (taos_cfgp->scale_factor_prox );
+
+    if(raw_ir > raw_clear) {
+        raw_lux = raw_ir;
+        raw_ir = raw_clear;
+        raw_clear = raw_lux;
+    }
+    dev_gain = taos_triton_gain_table[taos_cfgp->gain & 0x3];
+    if(raw_clear >= lux_timep->saturation)
+        return(TAOS_MAX_LUX);
+    if(raw_ir >= lux_timep->saturation)
+        return(TAOS_MAX_LUX);
+    if(raw_clear == 0)
+        return(0);
+    if(dev_gain == 0 || dev_gain > 127) {
+        printk(KERN_ERR "TAOS: dev_gain = 0 or > 127 in taos_get_lux()\n");
+        return -1;
+    }
+    if(lux_timep->denominator == 0) {
+        printk(KERN_ERR "TAOS: lux_timep->denominator = 0 in taos_get_lux()\n");
+        return -1;
+    }
+    ratio = (raw_ir<<15)/raw_clear;
+    for (p = lux_tablep; p->ratio && p->ratio < ratio; p++);
+	#ifdef WORK_UES_POLL_MODE
+    if(!p->ratio) {//iVIZM
+        if(lux_history[0] < 0)
+            return 0;
+        else
+            return lux_history[0];
+    }
+	#endif
+    Tint = taos_cfgp->als_time;
+    raw_clear = ((raw_clear*400 + (dev_gain>>1))/dev_gain + (Tint>>1))/Tint;
+    raw_ir = ((raw_ir*400 +(dev_gain>>1))/dev_gain + (Tint>>1))/Tint;
+    lux = ((raw_clear*(p->clear)) - (raw_ir*(p->ir)));
+    lux = (lux + 32000)/64000;
+    if(lux > TAOS_MAX_LUX) {
+        lux = TAOS_MAX_LUX;
+    }
+    return(lux);
+}
+
+static int taos_lux_filter(int lux)
+{
+    static u8 middle[] = {1,0,2,0,0,2,0,1};
+    int index;
+
+    lux_history[2] = lux_history[1];
+    lux_history[1] = lux_history[0];
+    lux_history[0] = lux;
+
+    if(lux_history[2] < 0) { //iVIZM
+        if(lux_history[1] > 0)
+            return lux_history[1];       
+        else 
+            return lux_history[0];
+    }
+    index = 0;
+    if( lux_history[0] > lux_history[1] ) 
+        index += 4;
+    if( lux_history[1] > lux_history[2] ) 
+        index += 2;
+    if( lux_history[0] > lux_history[2] )
+        index++;
+    return(lux_history[middle[index]]);
+}
+
+// verify device
+static int taos_device_name(unsigned char *bufp, char **device_name)
+{
+    /*
+    int i=0 ,j;
+    for (i = 0; i < TAOS_MAX_DEVICE_REGS; i++) 
+    {
+	  	j=bufp[i];
+	  	printk("(bufp[i=%x]=%x,\n",i,j);
+    }
+    */
+    *device_name="tritonFN";
+    return(1);
+}
+
+// proximity poll
+static int taos_prox_poll(struct taos_prox_info *prxp)
+{
+    int i = 0, ret = 0; //wait_count = 0;
+    u8 chdata[6];
+
+    for (i = 0; i < 6; i++) {
+        chdata[i] = (i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CMD_AUTO | (TAOS_TRITON_ALS_CHAN0LO + i))));
+    }
+    prxp->prox_clear = chdata[1];
+    prxp->prox_clear <<= 8;
+    prxp->prox_clear |= chdata[0];
+    if (prxp->prox_clear > ((sat_als*80)/100))
+    {
+		printk(KERN_ERR "TAOS: %u <= %u*0.8 poll data\n",prxp->prox_clear,sat_als);
+        return -ENODATA;
+    }
+    prxp->prox_data = chdata[5];
+    prxp->prox_data <<= 8;
+    prxp->prox_data |= chdata[4];
+
+    return (ret);
+}
+
+// prox poll timer function
+static void taos_prox_poll_timer_func(unsigned long param) {
+    int ret = 0;
+
+    if (!device_released) {
+        if ((ret = taos_prox_poll(prox_cur_infop)) < 0) {
+            printk(KERN_ERR "TAOS: call to prox_poll failed in taos_prox_poll_timer_func()\n");
+            return;
+        }
+        taos_prox_poll_timer_start();
+    }
+    return;
+}
+
+// start prox poll timer
+static void taos_prox_poll_timer_start(void) {
+    init_timer(&prox_poll_timer);
+    prox_poll_timer.expires = jiffies + (HZ/10);
+    prox_poll_timer.function = taos_prox_poll_timer_func;
+    add_timer(&prox_poll_timer);
+    return;
+}
+
+static void taos_update_sat_als(void)
+{
+    u8 reg_val = 0;
+    int ret = 0;
+
+    if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_ALS_TIME)))) < 0) 
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte failed in ioctl als_calibrate\n");
+        return;
+    }
+    
+    reg_val = i2c_smbus_read_byte(taos_datap->client);
+
+    sat_als = (256 - reg_val) << 10;
+}
+
+static int taos_als_gain_set(unsigned als_gain)
+{
+    int ret;
+    prox_gain_param = (prox_gain_param & 0xFC) | als_gain;
+    gain_param      = prox_gain_param & 0x03;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->gain      = gain_param;
+        taos_cfgp->prox_gain = prox_gain_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0F), taos_cfgp->prox_gain))) < 0) 
+        {
+            SENSOR_LOG_ERROR("failed to write the prox_led_strength reg\n");
+            return -EINVAL;
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");        
+        return -EINVAL;
+    }
+
+    return ret;
+}
+
+static void taos_als_poll_work_func(struct work_struct *work)
+{
+    taos_als_get_data();
+    if (true == taos_datap->als_on)
+    {
+        schedule_delayed_work(&taos_datap->als_poll_work, msecs_to_jiffies(als_poll_time_mul*als_poll_delay));
+    }
+}
+
+static void taos_prox_calibrate_work_func(struct work_struct *work)
+{
+
+		taos_prox_calibrate();
+	
+}
+
+static int taos_prox_offset_cal_prepare(void)
+{
+    int ret =1;
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_config_offset = 0;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x1E), taos_cfgp->prox_config_offset))) < 0) 
+        {
+            SENSOR_LOG_ERROR("failed to write the prox_config_offset  reg\n");
+	     return ret;
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+	 return -EINVAL;
+    }
+	 return ret;
+}
+
+static int taos_prox_offset_calculate(int data, int target)
+{
+    int offset;
+
+    if (data > PROX_DATA_TARGET)
+    {
+        offset = (data - PROX_DATA_TARGET) * PROX_OFFSET_CAL_PER_BIT;
+    }
+    else
+    {
+        offset = (PROX_DATA_TARGET - data) * PROX_OFFSET_CAL_PER_BIT + 128;
+    }
+	
+   SENSOR_LOG_ERROR("TAOS:------------ taos_cfgp->prox_offset = %d\n",offset );
+
+    return offset;
+}
+
+static int taos_prox_uncover_data_get(void)
+{
+    u8 i = 0, j = 0;
+    int prox_sum = 0, ret = 0;
+    static struct taos_prox_info prox_info_temp;
+
+    mdelay(20);
+    for (i = 0, j = 0; i < PROX_OFFSET_CAL_BUFFER_SIZE / 5; i++)
+    {
+        if ((ret = taos_prox_poll(&prox_info_temp)) < 0)
+        {
+            SENSOR_LOG_ERROR("failed to tmd2772_prox_read_data\n");
+        }
+        else
+        {
+            j++;
+            prox_sum += prox_info_temp.prox_data;
+        }
+        mdelay(20);
+    }
+
+    if(j == 0)
+    {
+        ret = -1;
+        goto error;
+    }
+
+    taos_datap->prox_uncover_data = prox_sum / j;
+    taos_datap->prox_thres_hi_min = taos_datap->prox_uncover_data + PROX_THRESHOLD_SAFE_DISTANCE + PROX_THRESHOLD_DISTANCE;
+
+    SENSOR_LOG_ERROR("prox_uncover_data = %d, prox_thres_hi_min = %d\n", taos_datap->prox_uncover_data, taos_datap->prox_thres_hi_min);
+    taos_write_cal_file(PATH_PROX_UNCOVER_DATA, taos_datap->prox_uncover_data);
+
+    return 0;
+    
+error:
+    return ret;
+}
+
+static int taos_prox_offset_cal_process(void)
+{  
+    int ret;
+    int prox_sum = 0, prox_mean = 0;
+    int i = 0, j = 0;
+    u8 reg_val = 0;
+    u8 reg_cntrl = 0;
+
+    struct taos_prox_info *prox_cal_info = NULL;
+        prox_cal_info = kmalloc(sizeof(struct taos_prox_info) * (PROX_OFFSET_CAL_BUFFER_SIZE), GFP_KERNEL); 
+        if (NULL == prox_cal_info)
+        {
+            SENSOR_LOG_ERROR("malloc prox_cal_info failed\n");
+            ret = -1;
+            goto prox_offset_cal_buffer_error;
+        }
+        memset(prox_cal_info, 0, sizeof(struct taos_prox_info) * (taos_datap->prox_calibrate_times));
+
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x01), taos_cfgp->prox_int_time))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_int_time reg\n");
+            goto prox_calibrate_offset_error;
+        }
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x02), taos_cfgp->prox_adc_time))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_adc_time reg\n");
+            goto prox_calibrate_offset_error;
+        }
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x03), taos_cfgp->prox_wait_time))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_wait_time reg\n");
+            goto prox_calibrate_offset_error;
+        }
+
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0D), taos_cfgp->prox_config))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_config reg\n");
+            goto prox_calibrate_offset_error;
+        }
+
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0E), taos_cfgp->prox_pulse_cnt))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_pulse_cnt reg\n");
+            goto prox_calibrate_offset_error;
+        }
+	 if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x1E), taos_cfgp->prox_config_offset))) < 0) {
+        SENSOR_LOG_ERROR(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0F), taos_cfgp->prox_gain))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_gain reg\n");
+            goto prox_calibrate_offset_error;
+        }
+
+        reg_cntrl = reg_val | (TAOS_TRITON_CNTL_PROX_DET_ENBL | TAOS_TRITON_CNTL_PWRON | TAOS_TRITON_CNTL_ADC_ENBL);
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), reg_cntrl))) < 0)
+        {
+           SENSOR_LOG_ERROR("failed write cntrl reg\n");
+           goto prox_calibrate_offset_error;
+        }
+		
+        mdelay(30);
+		
+        for (i = 0; i < (PROX_OFFSET_CAL_BUFFER_SIZE); i++) 
+        {
+            if ((ret = taos_prox_poll(&prox_cal_info[i])) < 0)
+            {  
+            	   j++;
+                printk(KERN_ERR "TAOS: call to prox_poll failed in ioctl prox_calibrate\n");
+            }
+            prox_sum += prox_cal_info[i].prox_data;
+       
+            SENSOR_LOG_ERROR("prox get time %d data is %d",i,prox_cal_info[i].prox_data);
+            mdelay(30);
+        }
+
+        prox_mean = prox_sum/(PROX_OFFSET_CAL_BUFFER_SIZE);
+        SENSOR_LOG_ERROR("TAOS:------------ taos_cfgp->prox_mean = %d\n",prox_mean );
+	 if(j != 0)	 	
+            goto prox_calibrate_offset_error;
+
+	  prox_config_offset_param = taos_prox_offset_calculate(prox_mean, PROX_DATA_TARGET);
+	 
+        taos_cfgp->prox_config_offset = prox_config_offset_param;
+		
+        if((ret=taos_write_cal_file(PATH_PROX_OFFSET,taos_cfgp->prox_config_offset)) < 0)
+	      goto prox_calibrate_offset_error;
+
+
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x1E), taos_cfgp->prox_config_offset))) < 0) 
+        {
+            SENSOR_LOG_ERROR(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+            return (ret);
+        }     
+
+        //read prox data register after update offset register
+        ret = taos_prox_uncover_data_get();
+        if (ret < 0)
+        {
+         SENSOR_LOG_ERROR("failed to tmd2772_prox_uncover_data_get\n");
+         goto prox_calibrate_offset_error;
+        }
+
+        for (i = 0; i < sizeof(taos_triton_reg_init); i++)
+        {
+            if(i !=11)
+            {
+                if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|(TAOS_TRITON_CNTRL +i)), taos_triton_reg_init[i]))) < 0)
+                {
+                    SENSOR_LOG_ERROR("failed write triton_init reg\n");
+                               goto prox_calibrate_offset_error;
+
+                }
+             }
+         }
+
+
+
+
+	 kfree(prox_cal_info);
+	return 1;
+prox_calibrate_offset_error:
+    SENSOR_LOG_ERROR("ERROR\n");
+	 kfree(prox_cal_info);
+prox_offset_cal_buffer_error:
+
+	return -1;
+    }
+
+static void taos_prox_offset_cal_finish(void)
+{
+
+    if (true == (taos_datap->prox_on))
+    {
+        taos_prox_on();
+    }
+    else
+    {
+        taos_prox_off();
+    }
+}
+static int taos_prox_offset_cal(void)
+{
+    int ret = 0;
+    taos_datap->prox_offset_cal_result = false;
+
+    if ((ret=taos_prox_offset_cal_prepare())<0)
+	goto error;
+
+    mdelay(50);
+
+    if ((ret= taos_prox_offset_cal_process())>=0)
+    {
+        taos_datap->prox_offset_cal_result = true;
+    }
+
+    taos_prox_offset_cal_finish();
+	
+    return ret;
+error:
+    return ret;
+}
+
+
+static void taos_prox_offset_cal_work_func(struct work_struct *work)
+{
+
+		taos_prox_offset_cal();
+	
+}
+static enum hrtimer_restart  taos_prox_unwakelock_work_func(struct hrtimer *timer)
+{	 
+	SENSOR_LOG_INFO("######## taos_prox_unwakelock_timer_func #########\n");
+	if(false == taos_datap->irq_work_status )
+	taos_wakelock_ops(&(taos_datap->proximity_wakelock),false);
+	return HRTIMER_NORESTART;
+	
+}
+
+static int taos_sensors_als_poll_on(void) 
+{
+    int  ret = 0, i = 0;
+    u8   reg_val = 0, reg_cntrl = 0;
+
+    SENSOR_LOG_INFO("######## TAOS IOCTL ALS ON #########\n");
+
+    for (i = 0; i < TAOS_FILTER_DEPTH; i++)
+    {
+        lux_history[i] = -ENODATA;
+    }
+
+    if (taos_datap->prox_on)
+    {
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_ALS_TIME), TAOS_ALS_ADC_TIME_WHEN_PROX_ON))) < 0) 
+        {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+            return (ret);
+        }
+    }
+    else
+    {
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_ALS_TIME), taos_cfgp->prox_int_time))) < 0) 
+        {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl als_on\n");
+            return (ret);
+        }
+    }
+
+    reg_val = i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_GAIN));
+
+    //SENSOR_LOG_INFO("reg[0x0F] = 0x%02X\n",reg_val);
+
+    reg_val = reg_val & 0xFC;
+    reg_val = reg_val | (taos_cfgp->gain & 0x03);//*16
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_GAIN), reg_val))) < 0)
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl als_on\n");
+        return (ret);
+    }
+
+    reg_cntrl = i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL));
+    SENSOR_LOG_INFO("reg[0x00] = 0x%02X\n",reg_cntrl);
+
+    reg_cntrl |= (TAOS_TRITON_CNTL_ADC_ENBL | TAOS_TRITON_CNTL_PWRON);
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), reg_cntrl))) < 0) 
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl als_on\n");
+        return (ret);
+    }
+
+	schedule_delayed_work(&taos_datap->als_poll_work, msecs_to_jiffies(200));
+
+    flag_just_open_light = true;
+
+    taos_datap->als_on = true;
+
+    taos_update_sat_als();
+
+	return ret;
+}	
+
+static int taos_sensors_als_poll_off(void)
+{
+    int  ret = 0, i = 0;
+    u8  reg_val = 0;
+
+    SENSOR_LOG_INFO("######## TAOS IOCTL ALS OFF #########\n");
+
+    for (i = 0; i < TAOS_FILTER_DEPTH; i++)
+    {   
+        lux_history[i] = -ENODATA;
+    }
+
+    reg_val = i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL));
+
+    //SENSOR_LOG_INFO("reg[0x00] = 0x%02X\n",reg_val);
+
+    if ((reg_val & TAOS_TRITON_CNTL_PROX_DET_ENBL) == 0x00 && (0 == taos_datap->prox_on)) 
+    {        
+        SENSOR_LOG_INFO("TAOS_TRITON_CNTL_PROX_DET_ENBL = 0\n");
+        reg_val = 0x00;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), reg_val))) < 0) 
+        {
+           printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl als_off\n");
+           return (ret);
+        }
+
+    }
+
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|TAOS_TRITON_ALS_TIME), 0XFF))) < 0) 
+    {
+       printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+       return (ret);
+    }
+
+    taos_datap->als_on = false;
+
+    cancel_delayed_work_sync(&taos_datap->als_poll_work);
+
+    taos_update_sat_als();
+
+    return (ret);
+}
+
+static int taos_prox_on(void)
+{
+    int prox_sum = 0, prox_mean = 0, prox_max = 0;
+    int  ret = 0;
+    u8 reg_cntrl = 0, i = 0 ,j = 0;
+
+    taos_datap->prox_on = 1;
+    als_poll_time_mul = 2;
+
+    SENSOR_LOG_INFO("######## TAOS IOCTL PROX ON  ######## \n");
+
+    if (true==taos_datap->als_on)
+    {
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x01), TAOS_ALS_ADC_TIME_WHEN_PROX_ON))) < 0) 
+        {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+            return (ret);
+        }
+    }
+    else
+    {
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x01), 0XFF))) < 0) 
+        {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+            return (ret);
+        }
+    }
+
+    taos_update_sat_als();
+
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x02), taos_cfgp->prox_adc_time))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x03), taos_cfgp->prox_wait_time))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0C), taos_cfgp->prox_intr_filter))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0D), taos_cfgp->prox_config))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0E), taos_cfgp->prox_pulse_cnt))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0F), taos_cfgp->prox_gain))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x1E), taos_cfgp->prox_config_offset))) < 0) {
+        SENSOR_LOG_ERROR(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    reg_cntrl = TAOS_TRITON_CNTL_PROX_DET_ENBL | TAOS_TRITON_CNTL_PWRON    | TAOS_TRITON_CNTL_PROX_INT_ENBL | 
+		                                         TAOS_TRITON_CNTL_ADC_ENBL | TAOS_TRITON_CNTL_WAIT_TMR_ENBL  ;
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), reg_cntrl))) < 0) 
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+	pro_ft = true;
+    if (taos_datap->prox_calibrate_flag)
+    {
+        prox_sum = 0;
+        prox_max = 0;
+
+        mdelay(20);
+        for (i = 0, j = 0; i < 5; i++) 
+        {
+            if ((ret = taos_prox_poll(&prox_cal_info[i])) < 0)
+            {
+                j++;
+                printk(KERN_ERR "TAOS: call to prox_poll failed in ioctl prox_calibrate\n");
+            }
+            prox_sum += prox_cal_info[i].prox_data;
+            if (prox_cal_info[i].prox_data > prox_max)
+                prox_max = prox_cal_info[i].prox_data;
+            mdelay(20);
+        }
+
+        prox_mean = prox_sum/5;
+        if (j==0)
+        {
+            taos_cfgp->prox_threshold_hi = ((((prox_max - prox_mean) * prox_calibrate_hi_param) + 50)/100) + prox_mean+110;
+            taos_cfgp->prox_threshold_lo = ((((prox_max - prox_mean) * prox_calibrate_lo_param) + 50)/100) + prox_mean+35;
+
+            printk("TAOS:------------ taos_cfgp->prox_threshold_hi = %d\n",taos_cfgp->prox_threshold_hi );
+            printk("TAOS:------------ taos_cfgp->prox_threshold_lo = %d\n",taos_cfgp->prox_threshold_lo );
+            if( prox_mean >800 || taos_cfgp->prox_threshold_hi > 1000 || taos_cfgp->prox_threshold_lo > 900)
+            {
+                taos_cfgp->prox_threshold_hi= 800;
+                taos_cfgp->prox_threshold_lo =750;
+            }
+
+            if(taos_cfgp->prox_threshold_hi < 200)
+            {
+            	taos_cfgp->prox_threshold_hi = 200;
+            	taos_cfgp->prox_threshold_lo = 100;	
+            }
+
+            input_report_rel(taos_datap->p_idev, REL_Y, taos_cfgp->prox_threshold_hi);
+            input_report_rel(taos_datap->p_idev, REL_Z, taos_cfgp->prox_threshold_lo);
+            input_sync(taos_datap->p_idev);
+    	}
+    }
+    taos_prox_threshold_set();   
+    taos_irq_ops(true, true);
+    return (ret);
+}
+
+
+static int taos_prox_off(void)
+{    
+    int ret = 0;
+    SENSOR_LOG_INFO("########  TAOS IOCTL PROX OFF  ########\n");
+
+    if (true == (taos_datap->proximity_wakelock).locked)
+    {      
+    	  hrtimer_cancel(&taos_datap->prox_unwakelock_timer);
+        taos_wakelock_ops(&(taos_datap->proximity_wakelock), false);
+    }
+
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), 0x00))) < 0) 
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl als_off\n");
+        return (ret);
+    }
+
+    taos_datap->prox_on = 0;
+    als_poll_time_mul = 1;
+
+	if (true == taos_datap->als_on) 
+    {
+        taos_sensors_als_poll_on();
+	}
+
+   // cancel_work_sync(&taos_datap->irq_work);
+    if (true == taos_datap->irq_enabled)
+    {
+        taos_irq_ops(false, true);
+    }
+
+
+    return (ret);
+}
+
+
+static int taos_prox_calibrate(void)
+{  
+    int ret;
+    int prox_sum = 0, prox_mean = 0, prox_max = 0,prox_min = 1024;
+    u8 reg_cntrl = 0;
+    u8 reg_val = 0;
+    int i = 0, j = 0;
+    
+    struct taos_prox_info *prox_cal_info = NULL;
+        prox_cal_info = kmalloc(sizeof(struct taos_prox_info) * (taos_datap->prox_calibrate_times), GFP_KERNEL); 
+        if (NULL == prox_cal_info)
+        {
+            SENSOR_LOG_ERROR("malloc prox_cal_info failed\n");
+            ret = -1;
+            goto prox_calibrate_error1;
+        }
+        memset(prox_cal_info, 0, sizeof(struct taos_prox_info) * (taos_datap->prox_calibrate_times));
+
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x01), taos_cfgp->prox_int_time))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_int_time reg\n");
+            goto prox_calibrate_error;
+        }
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x02), taos_cfgp->prox_adc_time))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_adc_time reg\n");
+            goto prox_calibrate_error;
+        }
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x03), taos_cfgp->prox_wait_time))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_wait_time reg\n");
+            goto prox_calibrate_error;
+        }
+
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0D), taos_cfgp->prox_config))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_config reg\n");
+            goto prox_calibrate_error;
+        }
+
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0E), taos_cfgp->prox_pulse_cnt))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_pulse_cnt reg\n");
+            goto prox_calibrate_error;
+        }
+	 if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x1E), taos_cfgp->prox_config_offset))) < 0) {
+        SENSOR_LOG_ERROR(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0F), taos_cfgp->prox_gain))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_gain reg\n");
+            goto prox_calibrate_error;
+        }
+
+        reg_cntrl = reg_val | (TAOS_TRITON_CNTL_PROX_DET_ENBL | TAOS_TRITON_CNTL_PWRON | TAOS_TRITON_CNTL_ADC_ENBL);
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), reg_cntrl))) < 0)
+        {
+           SENSOR_LOG_ERROR("failed write cntrl reg\n");
+           goto prox_calibrate_error;
+        }
+
+        prox_sum = 0;
+        prox_max = 0;
+	 prox_min =1024;
+        mdelay(30);
+        for (i = 0; i < (taos_datap->prox_calibrate_times); i++) 
+        {
+            if ((ret = taos_prox_poll(&prox_cal_info[i])) < 0)
+            {  
+            	   j++;
+                printk(KERN_ERR "TAOS: call to prox_poll failed in ioctl prox_calibrate\n");
+            }
+            prox_sum += prox_cal_info[i].prox_data;
+            if (prox_cal_info[i].prox_data > prox_max)
+                prox_max = prox_cal_info[i].prox_data;
+		if (prox_cal_info[i].prox_data < prox_min)
+                prox_min = prox_cal_info[i].prox_data;
+            SENSOR_LOG_ERROR("prox get time %d data is %d",i,prox_cal_info[i].prox_data);
+            mdelay(30);
+        }
+
+        prox_mean = prox_sum/(taos_datap->prox_calibrate_times);
+	    if(j == 0)
+	 	{
+            taos_cfgp->prox_threshold_hi = ((((prox_max - prox_mean) * prox_calibrate_hi_param) + 50)/100) + prox_mean+120;
+            taos_cfgp->prox_threshold_lo = ((((prox_max - prox_mean) * prox_calibrate_lo_param) + 50)/100) + prox_mean+40;
+	 	}
+
+		if( prox_mean >700 || taos_cfgp->prox_threshold_hi > 1000 || taos_cfgp->prox_threshold_lo > 900)
+			{
+			 taos_cfgp->prox_threshold_hi = prox_threshold_hi_param;
+			taos_cfgp->prox_threshold_lo = prox_threshold_lo_param;	
+			prox_config_offset_param=0x0;
+			taos_cfgp->prox_config_offset = prox_config_offset_param;
+			}
+        SENSOR_LOG_ERROR("TAOS:------------ taos_cfgp->prox_threshold_hi = %d\n",taos_cfgp->prox_threshold_hi );
+        SENSOR_LOG_ERROR("TAOS:------------ taos_cfgp->prox_threshold_lo = %d\n",taos_cfgp->prox_threshold_lo );
+        SENSOR_LOG_ERROR("TAOS:------------ taos_cfgp->prox_mean = %d\n",prox_mean );
+        SENSOR_LOG_ERROR("TAOS:------------ taos_cfgp->prox_max = %d\n",prox_max );
+	 SENSOR_LOG_ERROR("TAOS:------------ taos_cfgp->prox_min = %d\n",prox_min );
+     
+        for (i = 0; i < sizeof(taos_triton_reg_init); i++)
+        {
+            if(i !=11)
+            {
+                if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|(TAOS_TRITON_CNTRL +i)), taos_triton_reg_init[i]))) < 0)
+                {
+                    SENSOR_LOG_ERROR("failed write triton_init reg\n");
+                               goto prox_calibrate_error;
+
+                }
+             }
+         }
+
+        input_report_rel(taos_datap->p_idev, REL_Y, taos_cfgp->prox_threshold_hi);
+        input_report_rel(taos_datap->p_idev, REL_Z, taos_cfgp->prox_threshold_lo);
+        input_sync(taos_datap->p_idev);
+	 kfree(prox_cal_info);
+	return 1;
+prox_calibrate_error:
+    SENSOR_LOG_ERROR("exit\n");
+	 kfree(prox_cal_info);
+prox_calibrate_error1:
+
+	return -1;
+    }
+
+
+MODULE_AUTHOR("John Koshi - Surya Software");
+MODULE_DESCRIPTION("TAOS ambient light and proximity sensor driver");
+MODULE_LICENSE("GPL");
+
+module_init(taos_init);
+module_exit(taos_exit);
+
diff --git a/drivers/hwmon/tmg399x.c b/drivers/hwmon/tmg399x.c
new file mode 100755
index 0000000..0342399
--- /dev/null
+++ b/drivers/hwmon/tmg399x.c
@@ -0,0 +1,5666 @@
+/*
+ * Device driver for monitoring ambient light intensity in (lux)
+ * proximity detection (prox), and Gesture functionality within the
+ * AMS-TAOS TMG3992/3.
+ *
+ * Copyright (c) 2013, AMS-TAOS USA, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/mutex.h>
+#include <linux/unistd.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/slab.h>
+#include <linux/pm.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/string.h>
+#include <linux/i2c/tmg399x.h>
+#include <mach/irqs.h>
+#include <linux/gpio.h>
+#include <linux/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/hrtimer.h>
+#include <linux/of_gpio.h>
+
+#define LOG_TAG "SENSOR_ALS_PROX_GES"
+#define DEBUG_ON //DEBUG SWITCH
+
+#define SENSOR_LOG_FILE__ strrchr(__FILE__, '/') ? (strrchr(__FILE__, '/')+1) : __FILE__
+
+#ifdef  CONFIG_FEATURE_ZTEMT_SENSORS_LOG_ON
+#define SENSOR_LOG_ERROR(fmt, args...) printk(KERN_ERR   "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #ifdef  DEBUG_ON
+#define SENSOR_LOG_INFO(fmt, args...)  printk(KERN_INFO  "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+                                              
+#define SENSOR_LOG_DEBUG(fmt, args...) printk(KERN_DEBUG "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #else
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+    #endif
+
+#else
+#define SENSOR_LOG_ERROR(fmt, args...)
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+#endif
+
+
+
+
+static u8 const tmg399x_ids[] = {
+	0x9C,
+	0x9E,
+	0x9F,
+    0XAA,
+};
+
+static char const *tmg399x_names[] = {
+	"tmg399x",
+	"tmg399x",
+	"tmg399x",
+    "tmg399x",
+};
+
+static u8 const restorable_regs[] = {
+	TMG399X_ALS_TIME,
+	TMG399X_WAIT_TIME,
+	TMG399X_PERSISTENCE,
+	TMG399X_CONFIG_1,
+	TMG399X_PRX_PULSE,
+	TMG399X_GAIN,
+	TMG399X_CONFIG_2,
+	TMG399X_PRX_OFFSET_NE,
+	TMG399X_PRX_OFFSET_SW,
+	TMG399X_CONFIG_3,
+};
+
+static u8 const prox_gains[] = {
+	1,
+	2,
+	4,
+	8
+};
+
+static u8 const als_gains[] = {
+	1,
+	4,
+	16,
+	64
+};
+
+static u8 const prox_pplens[] = {
+	4,
+	8,
+	16,
+	32
+};
+
+static u8 const led_drives[] = {
+	100,
+	50,
+	25,
+	12
+};
+
+static u16 const led_boosts[] = {
+	100,
+	150,
+	200,
+	300
+};
+
+static struct lux_segment segment_default[] = {
+	{
+		.d_factor = D_Factor1,
+		.r_coef = R_Coef1,
+		.g_coef = G_Coef1,
+		.b_coef = B_Coef1,
+		.ct_coef = CT_Coef1,
+		.ct_offset = CT_Offset1,
+	},
+	{
+		.d_factor = D_Factor1,
+		.r_coef = R_Coef1,
+		.g_coef = G_Coef1,
+		.b_coef = B_Coef1,
+		.ct_coef = CT_Coef1,
+		.ct_offset = CT_Offset1,
+	},
+};
+
+static struct tmg399x_parameters param_default = {
+#if 0
+	.als_time = 0xEE, /* 50ms */
+	.als_gain = AGAIN_16,
+	.als_deltaP = 10,
+	.wait_time = 0xFF, /* 2.78ms */
+	.prox_th_low = 50,
+	.prox_th_high = 80,
+	.persist = PRX_PERSIST(1) | ALS_PERSIST(2),
+	.als_prox_cfg1 = 0x60,
+	.prox_pulse = PPLEN_4US | PRX_PULSE_CNT(8),
+	.prox_gain = PGAIN_1,
+	.ldrive = PDRIVE_100MA,
+	.als_prox_cfg2 = LEDBOOST_300 | 0x01,
+	.prox_offset_ne = 0,
+	.prox_offset_sw = 0,
+	.als_prox_cfg3 = 0,
+
+	.ges_entry_th = 0,
+	.ges_exit_th = 0,
+	.ges_cfg1 = FIFOTH_1 | GEXPERS_2,
+	.ges_cfg2 = GGAIN_4 | GLDRIVE_100 | GWTIME_6,
+	.ges_offset_n = 0,
+	.ges_offset_s = 0,
+	.ges_pulse = GPLEN_16US | GES_PULSE_CNT(2),
+	.ges_offset_w = 0,
+	.ges_offset_e = 0,
+	.ges_dimension = GBOTH_PAIR,
+#endif
+};
+
+static int __devinit tmg399x_probe(struct i2c_client *client, const struct i2c_device_id *idp);
+static int __devexit tmg399x_remove(struct i2c_client *client);
+static int tmg399x_suspend(struct device *dev);
+static int tmg399x_resume(struct device *dev);
+static int tmg399x_prox_calibrate(struct tmg399x_chip *chip);
+int tmg399x_read_cal_value(char *file_path);
+int tmg399x_write_cal_file(char *file_path,unsigned int value);
+static int tmg399x_get_id(struct tmg399x_chip *chip, u8 *id, u8 *rev);
+
+
+static const struct i2c_device_id tmg399x_idtable_id[] = {
+	{ "ams,ams-sensor", 0 },
+	{ },
+};
+
+static struct of_device_id of_tmg399x_idtable[] = {
+	{ .compatible = "ams,ams-sensor",},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, tmg399x_idtable);
+
+static const struct dev_pm_ops tmg399x_pm_ops = {
+	.suspend = tmg399x_suspend,
+	.resume  = tmg399x_resume,
+};
+
+
+struct i2c_driver tmg399x_driver = {
+	.driver = {
+		.name = "ams-sensor-tmg3993",
+        .of_match_table = of_tmg399x_idtable,
+		.pm = &tmg399x_pm_ops,
+	},
+	.id_table = tmg399x_idtable_id,
+	.probe = tmg399x_probe,
+	.remove = __devexit_p(tmg399x_remove),
+};
+
+
+
+/**********************************  MARCO START ****************************************/
+
+/**********************************  MARCO  END  ****************************************/
+
+/**********************************  VARIABLE START ****************************************/
+
+struct tmg399x_chip *p_global_tmg399x_chip;
+
+static struct class         *proximity_class;
+static struct class         *light_class;
+static struct class         *gesture_class;
+
+
+static dev_t const tmg399x_proximity_dev_t = MKDEV(MISC_MAJOR, 245);
+static dev_t const tmg399x_light_dev_t     = MKDEV(MISC_MAJOR, 246);
+static dev_t const tmg399x_gesture_dev_t   = MKDEV(MISC_MAJOR, 247);
+
+
+wait_queue_head_t   gesture_drdy_wq;
+atomic_t            gesture_drdy;
+
+
+static unsigned char reg_addr = 0;
+
+/**********************************  VARIABLE END ****************************************/
+static int tmg399x_ges_enable(struct tmg399x_chip *chip, int on);
+static int tmg399x_get_prox(struct tmg399x_chip *chip);
+static void tmg399x_report_prox(struct tmg399x_chip *chip);
+
+
+
+static int board_tmg399x_init(void)
+{
+    SENSOR_LOG_INFO("\n");
+	return 0;
+}
+
+static int board_tmg399x_power(struct device *dev, enum tmg399x_pwr_state state)
+{
+    SENSOR_LOG_INFO("\n");
+	return 0;
+}
+
+static void board_tmg399x_teardown(struct device *dev)
+{
+    SENSOR_LOG_INFO("\n");
+}
+
+static const struct lux_segment tmg399x_segment[] = {
+	{
+		.d_factor = D_Factor1,
+		.r_coef = R_Coef1,
+		.g_coef = G_Coef1,
+		.b_coef = B_Coef1,
+		.ct_coef = CT_Coef1,
+		.ct_offset = CT_Offset1,
+	},
+	{
+		.d_factor = D_Factor1,
+		.r_coef = R_Coef1,
+		.g_coef = G_Coef1,
+		.b_coef = B_Coef1,
+		.ct_coef = CT_Coef1,
+		.ct_offset = CT_Offset1,
+	},
+};
+
+struct tmg399x_i2c_platform_data tmg399x_data = {
+	.platform_power = board_tmg399x_power,
+	.platform_init = board_tmg399x_init,
+	.platform_teardown = board_tmg399x_teardown,
+	.prox_name = "proximity",
+	.als_name = "light",
+    .ges_name = "gesture",
+	.parameters = {
+		.als_time = 0xEE, /* 50ms */
+		.als_gain = AGAIN_16,
+		.als_deltaP = 10,
+		.wait_time = 0xF6, //10* 2.78ms 
+		.prox_th_low = PROX_DEFAULT_THRESHOLD_LOW,
+		.prox_th_high = PROX_DEFAULT_THRESHOLD_HIGH,
+		.persist = PRX_PERSIST(1) | ALS_PERSIST(2),
+		.als_prox_cfg1 = 0x60,
+		.prox_pulse = PPLEN_8US | PRX_PULSE_CNT(PROX_LED_PULSE_CNT),
+		.prox_gain = PGAIN_4,
+		.ldrive = PDRIVE_100MA,
+        .als_prox_cfg2 = LEDBOOST_150 | 0x01,
+		.prox_offset_ne = PROX_DEFAULT_OFFSET_NE,
+		.prox_offset_sw = PROX_DEFAULT_OFFSET_SW,
+		.als_prox_cfg3 = 0,
+		
+		.ges_entry_th = GESTURE_ENTER_THRESHOLD,
+		.ges_exit_th = GESTURE_EXIT_THRESHOLD,
+		.ges_cfg1 = FIFOTH_4| GEXPERS_1,
+		.ges_cfg2 = GGAIN_4 | GLDRIVE_100 | GWTIME_3,
+		.ges_offset_n = GESTURE_DEFAULT_OFFSET_N,
+		.ges_offset_s = GESTURE_DEFAULT_OFFSET_S,
+		.ges_pulse = GPLEN_16US | GES_PULSE_CNT(GESTURE_LED_PULSE_CNT),
+		.ges_offset_w = GESTURE_DEFAULT_OFFSET_W,
+		.ges_offset_e = GESTURE_DEFAULT_OFFSET_E,
+		.ges_dimension = GBOTH_PAIR,
+	},
+	.als_can_wake = false,
+	.proximity_can_wake = true,
+	.segment = (struct lux_segment *) tmg399x_segment,
+	.segment_num = ARRAY_SIZE(tmg399x_segment),
+
+};
+
+static int tmg399x_parse_dt(struct tmg399x_chip *chip)
+{
+	struct device_node *np = chip->client->dev.of_node;
+	chip->irq_pin_num = of_get_named_gpio(np, "ams,irq-gpio", 0);
+    SENSOR_LOG_INFO("irq_pin_num is %d\n",chip->irq_pin_num);
+    return 0;
+}
+
+
+static int tmg399x_i2c_read(struct tmg399x_chip *chip, u8 reg, u8 *val)
+{
+	int ret;
+
+	s32 read;
+	struct i2c_client *client = chip->client;
+
+	reg += I2C_ADDR_OFFSET;
+	ret = i2c_smbus_write_byte(client, reg);
+	if (ret < 0) {
+		mdelay(3);
+		ret = i2c_smbus_write_byte(client, reg);
+		if (ret < 0) {
+			dev_err(&client->dev, "%s: failed 2x to write register %x\n",
+				__func__, reg);
+		return ret;
+		}
+	}
+	read = i2c_smbus_read_byte(client);
+	if (read < 0) {
+		mdelay(3);
+		read = i2c_smbus_read_byte(client);
+		if (read < 0) {
+			dev_err(&client->dev, "%s: failed read from register %x\n",
+				__func__, reg);
+		}
+		return ret;
+	}
+
+	*val = (u8)read;
+	return 0;
+}
+
+static int tmg399x_i2c_write(struct tmg399x_chip *chip, u8 reg, u8 val)
+{
+	int ret;
+	struct i2c_client *client = chip->client;
+
+	reg += I2C_ADDR_OFFSET;
+	ret = i2c_smbus_write_byte_data(client, reg, val);
+	if (ret < 0) {
+		mdelay(3);
+		ret = i2c_smbus_write_byte_data(client, reg, val);
+		if (ret < 0) {
+			dev_err(&client->dev, "%s: failed to write register %x err= %d\n",
+				__func__, reg, ret);
+		}
+	}
+
+	return ret;
+}
+
+static int tmg399x_i2c_modify(struct tmg399x_chip *chip, u8 reg, u8 mask, u8 val)
+{
+	int ret;
+	u8 temp;
+    
+	ret = tmg399x_i2c_read(chip, reg, &temp);
+	temp &= ~mask;
+	temp |= val;
+	ret |= tmg399x_i2c_write(chip, reg, temp);
+
+	return ret;
+}
+
+static int tmg399x_i2c_reg_blk_write(struct tmg399x_chip *chip,
+		u8 reg, u8 *val, int size)
+{
+	s32 ret;
+	struct i2c_client *client = chip->client;
+
+	reg += I2C_ADDR_OFFSET;
+	ret =  i2c_smbus_write_i2c_block_data(client,
+			reg, size, val);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: failed 2X at address %x (%d bytes)\n",
+				__func__, reg, size);
+	}
+
+	return ret;
+}
+
+static int tmg399x_i2c_ram_blk_read(struct tmg399x_chip *chip,
+		u8 reg, u8 *val, int size)
+{
+	s32 ret;
+	struct i2c_client *client = chip->client;
+
+	reg += I2C_ADDR_OFFSET;
+	ret =  i2c_smbus_read_i2c_block_data(client,
+			reg, size, val);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: failed 2X at address %x (%d bytes)\n",
+				__func__, reg, size);
+	}
+
+	return ret;
+}
+
+static int tmg399x_flush_regs(struct tmg399x_chip *chip)
+{
+	unsigned i;
+	int ret;
+	u8 reg;
+
+	dev_info(&chip->client->dev, "%s\n", __func__);
+
+	for (i = 0; i < ARRAY_SIZE(restorable_regs); i++) {
+		reg = restorable_regs[i];
+		ret = tmg399x_i2c_write(chip, reg, chip->shadow[reg]);
+		if (ret < 0) {
+			dev_err(&chip->client->dev, "%s: err on reg 0x%02x\n",
+					__func__, reg);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static void tmg399x_wakelock_ops(struct tmg399x_wake_lock *wakelock, bool enable)
+{
+	//struct tmg399x_chip *chip = container_of(wakelock, struct tmg399x_chip, proximity_wakelock);
+
+    if (enable == wakelock->locked)
+    {
+        if ((false==p_global_tmg399x_chip->prox_threshold_cal_start) && (false==p_global_tmg399x_chip->prox_offset_cal_start))
+        {
+            SENSOR_LOG_INFO("doubule %s %s, retern here\n",enable? "lock" : "unlock",wakelock->name);
+        }
+        return;
+    }
+
+    if (enable)
+    {
+        wake_lock(&wakelock->lock);
+    }
+    else
+    {
+        wake_unlock(&wakelock->lock);
+    }
+
+    wakelock->locked = enable;
+
+    SENSOR_LOG_INFO("%s %s \n",enable? "lock" : "unlock",wakelock->name);
+}
+
+
+static void tmg399x_chip_data_init(struct tmg399x_chip *chip)
+{
+    chip->light_debug_enable                = false;
+    chip->prox_debug_enable                 = false;
+    chip->ges_debug_enable                  = false;
+    chip->prx_enabled                       = false;
+    chip->als_enabled                       = false;
+    chip->ges_enabled                       = false;
+    chip->prox_calibrate_result             = false;
+    chip->prox_offset_cal_result            = false;
+    chip->gesture_offset_cal_result         = false;
+    chip->prox_data_max                     = PROX_DATA_MAX;
+    chip->prox_manual_calibrate_threshold   = 0;
+    chip->prox_thres_hi_max                 = PROX_THRESHOLD_HIGH_MAX;
+    chip->prox_thres_hi_min                 = PROX_DATA_SAFE_RANGE_MAX + PROX_THRESHOLD_DISTANCE;
+    chip->prox_data_safe_range_max          = PROX_DATA_SAFE_RANGE_MAX;
+    chip->prox_data_safe_range_min          = PROX_DATA_SAFE_RANGE_MIN;
+    chip->gesture_data_max                  = GESTURE_DATA_MAX;
+    chip->gesture_data_safe_range_max       = GESTURE_DATA_SAFE_RANGE_MAX;
+    chip->gesture_data_safe_range_min       = GESTURE_DATA_SAFE_RANGE_MIN;
+    chip->prox_calibrate_times              = 0;
+    chip->prox_uncover_data                 = 0;
+    chip->chip_name                         = "tmg3993";
+    chip->wakeup_from_sleep                 = false;
+    chip->wakelock_locked                   = false;
+    chip->irq_enabled                       = true;
+    chip->gesture_start                     = false;
+    chip->prox_threshold_cal_start          = false;
+    chip->prox_offset_cal_start             = false;
+    chip->gesture_offset_cal_start          = false;
+    chip->phone_is_sleep                    = false;
+    chip->irq_work_status                   = false;
+    chip->proximity_wakelock.name           = "proximity-wakelock";
+    chip->proximity_wakelock.locked         = false;
+    chip->light_poll_time                   = AMS_ALS_POLL_DELAY_SLOW;
+}
+
+static void tmg399x_irq_enable(bool enable, bool flag_sync)
+{
+    if (enable == p_global_tmg399x_chip->irq_enabled)
+    {
+        SENSOR_LOG_INFO("doubule %s irq, retern here\n",enable? "enable" : "disable");
+        return;
+    }
+
+    if (enable)
+    {
+        enable_irq(p_global_tmg399x_chip->client->irq);
+    }
+    else
+    {
+        if (flag_sync)
+        {
+            disable_irq(p_global_tmg399x_chip->client->irq);
+
+        }
+        else
+        {
+            disable_irq_nosync(p_global_tmg399x_chip->client->irq);
+        }
+    }
+
+    p_global_tmg399x_chip->irq_enabled  = enable;
+    //SENSOR_LOG_INFO("%s irq \n",enable? "enable" : "disable");
+}
+
+
+static int tmg399x_irq_clr(struct tmg399x_chip *chip, u8 int2clr)
+{
+	int ret, ret2;
+    
+	ret = i2c_smbus_write_byte(chip->client, int2clr);
+
+	if (ret < 0) {
+		mdelay(3);
+		ret2 = i2c_smbus_write_byte(chip->client, int2clr);
+		if (ret2 < 0) {
+			dev_err(&chip->client->dev, "%s: failed 2x, int to clr %02x\n",
+					__func__, int2clr);
+		}
+		return ret2;
+	}
+	return ret;
+}
+
+static int tmg399x_update_enable_reg(struct tmg399x_chip *chip)
+{
+	int ret;
+	
+    SENSOR_LOG_INFO("\n");
+
+	//mutex_lock(&chip->lock);
+	ret  = tmg399x_i2c_write(chip, TMG399X_CONTROL, chip->shadow[TMG399X_CONTROL]);
+	ret |= tmg399x_i2c_write(chip, TMG399X_GES_CFG_4, chip->shadow[TMG399X_GES_CFG_4]);
+    SENSOR_LOG_INFO("TMG399X_CONTROL   = %X\n",chip->shadow[TMG399X_CONTROL]);
+    SENSOR_LOG_INFO("TMG399X_GES_CFG_4 = %X\n",chip->shadow[TMG399X_GES_CFG_4]);
+
+	//mutex_unlock(&chip->lock);
+	
+    SENSOR_LOG_INFO("\n");
+	return ret;
+}
+
+static int tmg399x_set_als_gain(struct tmg399x_chip *chip, int gain)
+{
+	int ret;
+	u8 ctrl_reg  = chip->shadow[TMG399X_GAIN] & ~TMG399X_ALS_GAIN_MASK;
+
+	switch (gain) {
+	case 1:
+		ctrl_reg |= AGAIN_1;
+		break;
+	case 4:
+		ctrl_reg |= AGAIN_4;
+		break;
+	case 16:
+		ctrl_reg |= AGAIN_16;
+		break;
+	case 64:
+		ctrl_reg |= AGAIN_64;
+		break;
+	default:
+		break;
+	}
+    
+    SENSOR_LOG_INFO("TMG399X_ALS_AGL_MASK = %d\n",TMG399X_ALS_AGL_MASK);
+
+
+	//mutex_lock(&chip->lock);
+	ret = tmg399x_i2c_write(chip, TMG399X_GAIN, ctrl_reg);
+	if (!ret) {
+		chip->shadow[TMG399X_GAIN] = ctrl_reg;
+		chip->params.als_gain = ctrl_reg & TMG399X_ALS_GAIN_MASK;
+	}
+	return ret;
+}
+
+static void tmg399x_calc_cpl(struct tmg399x_chip *chip)
+{
+	u32 cpl;
+	u32 sat;
+	u8 atime = chip->shadow[TMG399X_ALS_TIME];
+
+	cpl = 256 - chip->shadow[TMG399X_ALS_TIME];
+	cpl *= TMG399X_ATIME_PER_100;
+	cpl /= 100;
+	cpl *= als_gains[chip->params.als_gain];
+
+    //SENSOR_LOG_INFO("chip->params.als_gain = %d\n",chip->params.als_gain);
+
+	sat = min_t(u32, MAX_ALS_VALUE, (u32)(256 - atime) << 10);
+	sat = sat * 8 / 10;
+	chip->als_inf.cpl = cpl;
+	chip->als_inf.saturation = sat;
+}
+
+static int tmg399x_get_lux(struct tmg399x_chip *chip)
+{
+	u32 rp1, gp1, bp1, cp1;
+	u32 lux = 0;
+	u32 cct;
+	u32 sat;
+	u32 sf;
+    bool lux_is_too_low = false;
+
+
+	/* use time in ms get scaling factor */
+	tmg399x_calc_cpl(chip);
+	sat = chip->als_inf.saturation;
+
+	if (!chip->als_gain_auto) 
+    {
+		if (chip->als_inf.clear_raw <= MIN_ALS_VALUE) 
+        {
+            SENSOR_LOG_INFO("darkness\n");
+			lux = 0;
+			goto exit;
+		} 
+        else
+        {
+            if (chip->als_inf.clear_raw >= sat) 
+            {
+                SENSOR_LOG_INFO("saturation, keep lux & cct, sat = %d\n",sat);
+			    lux = chip->als_inf.lux;
+			    goto exit;
+		    }
+        }
+	} 
+    else
+    {
+		u8 gain = als_gains[chip->params.als_gain];
+		int ret = -EIO;
+
+
+        //SENSOR_LOG_INFO("gain = %d, sat = %d, clear_raw = %d\n",gain,sat,chip->als_inf.clear_raw);
+
+		if (gain == 16 && chip->als_inf.clear_raw >= sat) 
+        {
+			ret = tmg399x_set_als_gain(chip, 1);
+		}   
+        else
+        { 
+            if (gain == 16 && chip->als_inf.clear_raw < GAIN_SWITCH_LEVEL) 
+            {
+			    ret = tmg399x_set_als_gain(chip, 64);
+		    } 
+            else 
+            {
+                if ((gain == 64 &&
+			        chip->als_inf.clear_raw >= (sat - GAIN_SWITCH_LEVEL)) ||
+			        (gain == 1 && chip->als_inf.clear_raw < GAIN_SWITCH_LEVEL)) 
+                {
+    			    ret = tmg399x_set_als_gain(chip, 16);
+    		    }
+            }
+        }
+
+		if (!ret) 
+        {
+            SENSOR_LOG_INFO("gain adjusted, skip\n");
+			tmg399x_calc_cpl(chip);
+			ret = -EAGAIN;
+			lux = chip->als_inf.lux;
+			goto exit;
+		}
+
+		if (chip->als_inf.clear_raw <= MIN_ALS_VALUE)
+        {
+            //SENSOR_LOG_INFO("darkness\n");
+			lux = 0;
+			goto exit;
+		} 
+        else
+        { 
+            if (chip->als_inf.clear_raw >= sat)
+            {
+                SENSOR_LOG_INFO("saturation, keep lux, sat = %d\n",sat);
+			    lux = chip->als_inf.lux;
+			    goto exit;
+		    }
+        }
+	}
+
+	/* remove ir from counts*/
+	rp1 = chip->als_inf.red_raw   - chip->als_inf.ir;
+	gp1 = chip->als_inf.green_raw - chip->als_inf.ir;
+	bp1 = chip->als_inf.blue_raw  - chip->als_inf.ir;
+	cp1 = chip->als_inf.clear_raw - chip->als_inf.ir;
+
+    
+    if (0==rp1)
+    {
+        //SENSOR_LOG_INFO("!!!!!!!!! rp1 =0\n");
+        rp1 = 1;
+        lux_is_too_low = true;
+    }
+    else
+    {        
+        if (p_global_tmg399x_chip->light_debug_enable)
+        {    
+            SENSOR_LOG_INFO("rp1 = %d\n",rp1);
+        }
+    }
+    
+    /*
+    SENSOR_LOG_INFO("chip->als_inf.red_raw   = %d\n",chip->als_inf.red_raw);
+    SENSOR_LOG_INFO("chip->als_inf.green_raw = %d\n",chip->als_inf.green_raw);
+    SENSOR_LOG_INFO("chip->als_inf.blue_raw  = %d\n",chip->als_inf.blue_raw);
+    SENSOR_LOG_INFO("chip->als_inf.clear_raw = %d\n",chip->als_inf.clear_raw);
+    SENSOR_LOG_INFO("lux = %d\n",lux);
+    */
+
+    //SENSOR_LOG_INFO("lux = %d\n",lux);
+
+
+	if (!chip->als_inf.cpl) 
+    {
+    	SENSOR_LOG_ERROR("zero cpl. Setting to 1\n");
+
+		chip->als_inf.cpl = 1;
+	}
+
+	if (chip->als_inf.red_raw > chip->als_inf.ir)
+    {
+		lux += chip->segment[chip->device_index].r_coef * rp1;
+        if (p_global_tmg399x_chip->light_debug_enable)
+        {  
+            //SENSOR_LOG_INFO("lux = %d, r_coef = %d\n",lux,chip->segment[chip->device_index].r_coef);
+        }
+    }
+	else
+    {
+    	//SENSOR_LOG_ERROR("lux rp1 = %d\n",(chip->segment[chip->device_index].r_coef * rp1));
+    }
+
+	if (chip->als_inf.green_raw > chip->als_inf.ir)
+    {
+		lux += chip->segment[chip->device_index].g_coef * gp1;
+        if (p_global_tmg399x_chip->light_debug_enable)
+        {  
+            //SENSOR_LOG_INFO("lux = %d, g_coef = %d\n",lux,chip->segment[chip->device_index].g_coef);
+        }
+    }
+	else
+	{	
+    	//SENSOR_LOG_ERROR("lux gp1 = %d\n",(chip->segment[chip->device_index].g_coef * rp1));
+    }
+
+	if (chip->als_inf.blue_raw > chip->als_inf.ir)
+	{
+    	lux -= chip->segment[chip->device_index].b_coef * bp1;
+        if (p_global_tmg399x_chip->light_debug_enable)
+        {  
+            //SENSOR_LOG_INFO("lux = %d, b_coef = %d\n",lux,chip->segment[chip->device_index].b_coef);
+	    }
+    }
+    else
+	{
+    	//SENSOR_LOG_ERROR("lux bp1 = %d\n",(chip->segment[chip->device_index].b_coef * rp1));
+    }
+
+    if (lux<0)
+    {
+        SENSOR_LOG_INFO("lux<0\n");
+        lux = 0;
+    }
+
+	sf = chip->als_inf.cpl;
+
+	if (sf > 131072)
+		goto error;
+
+    //SENSOR_LOG_INFO("sf = %d\n",sf);
+
+	lux /= sf;
+	lux *= chip->segment[chip->device_index].d_factor;
+	lux += 500;
+	lux /= 1000;
+	chip->als_inf.lux = (u16) lux;
+
+
+	cct = ((chip->segment[chip->device_index].ct_coef * bp1) / rp1) + chip->segment[chip->device_index].ct_offset;
+
+	chip->als_inf.cct = (u16) cct;
+
+    if (true == lux_is_too_low)
+    {
+        chip->als_inf.lux = 0;
+        lux_is_too_low = false;
+    }
+
+exit:
+return 0;
+
+error:
+	dev_err(&chip->client->dev, "ERROR Scale factor = %d", sf);
+
+return 1;
+
+}
+
+
+
+static int tmg399x_resume(struct device *dev)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	int ret = 0;
+	mutex_lock(&chip->lock);
+    SENSOR_LOG_INFO("enter\n");
+	if(true == chip->prx_enabled)
+    {
+        SENSOR_LOG_INFO( "disable irq wakeup\n");
+		ret = disable_irq_wake(chip->client->irq);
+	}
+    if(ret < 0)
+    {
+		SENSOR_LOG_INFO("disable_irq_wake failed\n");
+    }
+
+    if (true == chip->als_enabled)
+    {
+       SENSOR_LOG_INFO("recovery light sensor work\n");
+       schedule_delayed_work(&chip->als_poll_work, msecs_to_jiffies(1000));
+    }
+
+    SENSOR_LOG_INFO("eixt\n");
+	mutex_unlock(&chip->lock);
+    return ret ;
+}
+
+//suspend  
+static int tmg399x_suspend(struct device *dev)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	int ret = 0;
+	mutex_lock(&chip->lock);
+    SENSOR_LOG_INFO("enter\n");
+	 tmg399x_wakelock_ops(&(chip->proximity_wakelock),false);
+	if(true == chip->prx_enabled)
+    {  
+        SENSOR_LOG_INFO( "enable irq wakeup\n");
+       	ret = enable_irq_wake(chip->client->irq);
+        chip->wakeup_from_sleep = true;
+    }
+	if(ret < 0)
+    {
+		SENSOR_LOG_INFO("enable_irq_wake failed\n");
+    }
+
+    if (true == chip->als_enabled)
+    {
+        SENSOR_LOG_INFO("cancle light sensor work start\n");
+        cancel_delayed_work(&(chip->als_poll_work));
+        SENSOR_LOG_INFO("cancle light sensor work ...\n");
+        flush_delayed_work(&(chip->als_poll_work));
+        SENSOR_LOG_INFO("cancle light sensor work end\n");
+
+    }
+
+    SENSOR_LOG_INFO("eixt\n");
+	mutex_unlock(&chip->lock);
+    return ret ;
+}
+
+static u8 tmg399x_get_ges(struct tmg399x_chip *chip)
+{
+	u8 gstatus = 0;
+	u8 buffer[512];
+    u8 gesflvl = 0;
+    int i = 0;
+    int j = 0;
+    
+	//mutex_lock(&chip->lock);
+
+	tmg399x_i2c_read(chip, TMG399X_GES_FLVL, &gesflvl);
+
+    
+    if (chip->ges_debug_enable)
+    {
+        SENSOR_LOG_ERROR("gesflvl = %d\n",gesflvl);
+    }
+
+    if (gesflvl>0)
+    {
+        if (gesflvl>8)
+        {
+            gesflvl = 8;
+        }
+
+        tmg399x_i2c_read(chip, TMG399X_GES_STAT, &gstatus);
+        
+        //SENSOR_LOG_INFO("gstatus = %d\n",gstatus);
+
+    	if ( (gstatus & TMG399X_GES_ST_MASK) == TMG399X_GES_VALID)
+        {
+            tmg399x_i2c_ram_blk_read(chip, TMG399X_GES_NFIFO, buffer, 4 * gesflvl);
+
+            j += 4;
+
+            for(i=0; i<(gesflvl-1); i++)
+            {
+                chip->gesture_data[i].north = buffer[j + 0];
+                chip->gesture_data[i].south = buffer[j + 1];
+                chip->gesture_data[i].west  = buffer[j + 2];
+                chip->gesture_data[i].east  = buffer[j + 3];
+                j += 4;
+
+                if (chip->ges_debug_enable)
+                {
+                    SENSOR_LOG_ERROR("%4d, %4d, %4d, %4d\n",
+                                                       chip->gesture_data[i].north,
+                                                       chip->gesture_data[i].south,
+                                                       chip->gesture_data[i].west,
+                                                       chip->gesture_data[i].east);
+                }
+
+                if (chip->gesture_offset_cal_start)
+                {
+                    input_report_rel(chip->g_idev, REL_X,       chip->gesture_data[0].north);
+                    input_report_rel(chip->g_idev, REL_Y,       chip->gesture_data[0].south);
+                    input_report_rel(chip->g_idev, REL_Z,       chip->gesture_data[0].west);
+                    input_report_rel(chip->g_idev, REL_WHEEL,   chip->gesture_data[0].east);
+                    input_sync(chip->g_idev);
+                }
+            }
+
+            if (true == chip->prx_enabled)
+            {
+                i--;
+                chip->shadow[TMG399X_PRX_CHAN] = (chip->gesture_data[i].east  + 
+                                                  chip->gesture_data[i].west  + 
+                                                  chip->gesture_data[i].north +
+                                                  chip->gesture_data[i].south)/4;
+
+
+                //chip->shadow[TMG399X_PRX_CHAN] = (chip->shadow[TMG399X_PRX_CHAN] * 6) / 10;
+
+                //SENSOR_LOG_INFO("chip->shadow[TMG399X_PRX_CHAN] = %d\n",chip->shadow[TMG399X_PRX_CHAN]);
+
+                if (tmg399x_get_prox(chip))
+                {
+                    tmg399x_report_prox(chip);
+                }
+            }
+        }
+        else
+        {
+            SENSOR_LOG_ERROR("over flow !!!\n");
+            gesflvl = 0;
+        }
+    }
+    else
+    {
+        //SENSOR_LOG_INFO("fifi data overflow!\n");
+  
+        //tmg399x_i2c_modify(chip, TMG399X_GES_CFG_4, TMG399X_GES_INT_CLR, TMG399X_GES_INT_CLR);
+        /*
+        tmg399x_ges_enable(chip, 0);
+        tmg399x_ges_enable(chip, 1);
+        */
+
+        gesflvl = 0;
+
+    }
+
+    return ((gesflvl-1) >= 0)? (gesflvl-1) : 0;
+
+    //mutex_unlock(&chip->lock);
+
+}
+
+static int tmg399x_get_prox(struct tmg399x_chip *chip)
+{
+    int ret = 0;
+	chip->prx_inf.raw = chip->shadow[TMG399X_PRX_CHAN];
+
+    if (chip->prox_debug_enable || chip->prox_threshold_cal_start || chip->prox_offset_cal_start)
+    {
+        if (chip->prox_debug_enable)
+        {
+            SENSOR_LOG_ERROR("state = %d, data = %d, hi = %d, low = %d\n",
+                                                                         chip->prx_inf.detected,
+                                                                         chip->prx_inf.raw,
+                                                                         chip->params.prox_th_high,
+                                                                         chip->params.prox_th_low);
+        }
+
+        if (chip->prox_threshold_cal_start || chip->prox_offset_cal_start)
+        {
+            ret = 1;
+        }
+    }
+    else
+    {
+        if (chip->prx_inf.detected == PROX_UNKNOW)
+        {
+            if (chip->prx_inf.raw >= chip->params.prox_th_high) 
+            {
+                SENSOR_LOG_INFO("NEAR!\n");
+                chip->prx_inf.detected = PROX_NEAR;
+                chip->shadow[TMG399X_PRX_THRES_LOW] = chip->params.prox_th_low;
+                chip->shadow[TMG399X_PRX_THRES_HIGH] = 0xff;
+                tmg399x_i2c_write(chip, TMG399X_PRX_THRES_LOW, chip->shadow[TMG399X_PRX_THRES_LOW]);
+                tmg399x_i2c_write(chip, TMG399X_PRX_THRES_HIGH, chip->shadow[TMG399X_PRX_THRES_HIGH]);
+                ret = 1;
+            }
+            else
+            {
+                SENSOR_LOG_INFO("FAR!\n");
+                chip->prx_inf.detected = PROX_FAR;
+                chip->shadow[TMG399X_PRX_THRES_LOW] = 0x00;
+                chip->shadow[TMG399X_PRX_THRES_HIGH] = chip->params.prox_th_high;
+                tmg399x_i2c_write(chip, TMG399X_PRX_THRES_LOW, chip->shadow[TMG399X_PRX_THRES_LOW]);
+                tmg399x_i2c_write(chip, TMG399X_PRX_THRES_HIGH, chip->shadow[TMG399X_PRX_THRES_HIGH]);
+                ret = 1;  
+            }
+         }
+         else
+         {
+            if (chip->prx_inf.detected == PROX_FAR) 
+            {
+                if (chip->prx_inf.raw >= chip->shadow[TMG399X_PRX_THRES_HIGH]) 
+                {
+                    SENSOR_LOG_INFO("NEAR!\n");
+                    chip->prx_inf.detected = PROX_NEAR;
+                    chip->shadow[TMG399X_PRX_THRES_LOW] = chip->params.prox_th_low;
+                    chip->shadow[TMG399X_PRX_THRES_HIGH] = 0xff;
+                    tmg399x_i2c_write(chip, TMG399X_PRX_THRES_LOW, chip->shadow[TMG399X_PRX_THRES_LOW]);
+                    tmg399x_i2c_write(chip, TMG399X_PRX_THRES_HIGH, chip->shadow[TMG399X_PRX_THRES_HIGH]);
+                    ret = 1;
+                }
+            }
+            else 
+            {
+                if (chip->prx_inf.raw <= chip->shadow[TMG399X_PRX_THRES_LOW]) 
+                {
+                    SENSOR_LOG_INFO("FAR!\n");
+                    chip->prx_inf.detected = PROX_FAR;
+                    chip->shadow[TMG399X_PRX_THRES_LOW] = 0x00;
+                    chip->shadow[TMG399X_PRX_THRES_HIGH] = chip->params.prox_th_high;
+                    tmg399x_i2c_write(chip, TMG399X_PRX_THRES_LOW, chip->shadow[TMG399X_PRX_THRES_LOW]);
+                    tmg399x_i2c_write(chip, TMG399X_PRX_THRES_HIGH, chip->shadow[TMG399X_PRX_THRES_HIGH]); 
+                    ret = 1;
+                }
+                /*
+                else
+                {
+                    SENSOR_LOG_INFO("FAR!\n");
+                    chip->prx_inf.detected = PROX_FAR;
+                    chip->shadow[TMG399X_PRX_THRES_LOW] = 0x00;
+                    chip->shadow[TMG399X_PRX_THRES_HIGH] = chip->params.prox_th_high;
+                    tmg399x_i2c_write(chip, TMG399X_PRX_THRES_LOW, chip->shadow[TMG399X_PRX_THRES_LOW]);
+                    tmg399x_i2c_write(chip, TMG399X_PRX_THRES_HIGH, chip->shadow[TMG399X_PRX_THRES_HIGH]); 
+                }
+                */
+            }
+         }
+    }
+
+    
+   //SENSOR_LOG_INFO("HIGH = %d, LOW = %d\n",chip->shadow[TMG399X_PRX_THRES_HIGH],chip->shadow[TMG399X_PRX_THRES_LOW]);
+
+    return ret;
+}
+
+static void tmg399x_get_als(struct tmg399x_chip *chip)
+{
+	u8 *buf = &chip->shadow[TMG399X_CLR_CHANLO];
+
+	/* extract raw channel data */
+	chip->als_inf.clear_raw = le16_to_cpup((const __le16 *)&buf[0]);
+	chip->als_inf.red_raw   = le16_to_cpup((const __le16 *)&buf[2]);
+	chip->als_inf.green_raw = le16_to_cpup((const __le16 *)&buf[4]);
+	chip->als_inf.blue_raw  = le16_to_cpup((const __le16 *)&buf[6]);
+	chip->als_inf.ir =
+		(chip->als_inf.red_raw + chip->als_inf.green_raw +
+		chip->als_inf.blue_raw - chip->als_inf.clear_raw + 1) >> 1;
+	if (chip->als_inf.ir < 0)
+		chip->als_inf.ir = 0;
+}
+
+static int tmg399x_read_all(struct tmg399x_chip *chip)
+{
+	int ret;
+
+	//mutex_lock(&chip->lock);
+	
+	tmg399x_i2c_read(chip, TMG399X_STATUS,
+			&chip->shadow[TMG399X_STATUS]);
+
+	tmg399x_i2c_read(chip, TMG399X_CLR_CHANLO,
+			&chip->shadow[TMG399X_CLR_CHANLO]);
+	tmg399x_i2c_read(chip, TMG399X_CLR_CHANHI,
+			&chip->shadow[TMG399X_CLR_CHANHI]);
+
+	tmg399x_i2c_read(chip, TMG399X_RED_CHANLO,
+			&chip->shadow[TMG399X_RED_CHANLO]);
+	tmg399x_i2c_read(chip, TMG399X_RED_CHANHI,
+			&chip->shadow[TMG399X_RED_CHANHI]);
+
+	tmg399x_i2c_read(chip, TMG399X_GRN_CHANLO,
+			&chip->shadow[TMG399X_GRN_CHANLO]);
+	tmg399x_i2c_read(chip, TMG399X_GRN_CHANHI,
+			&chip->shadow[TMG399X_GRN_CHANHI]);
+
+	tmg399x_i2c_read(chip, TMG399X_BLU_CHANLO,
+			&chip->shadow[TMG399X_BLU_CHANLO]);
+	tmg399x_i2c_read(chip, TMG399X_BLU_CHANHI,
+			&chip->shadow[TMG399X_BLU_CHANHI]);
+
+	ret = tmg399x_i2c_read(chip, TMG399X_PRX_CHAN,
+			&chip->shadow[TMG399X_PRX_CHAN]);
+
+	//mutex_unlock(&chip->lock);
+	return (ret < 0) ? ret : 0;
+}
+
+/*
+static int tmg399x_read_status(struct tmg399x_chip *chip)
+{
+	int ret = 0;
+    
+	//mutex_lock(&chip->lock);
+
+    ret = tmg399x_i2c_read(chip, TMG399X_STATUS, &chip->shadow[TMG399X_STATUS]);
+
+	//mutex_unlock(&chip->lock);
+
+	return (ret < 0) ? ret : 0;
+}
+*/
+
+static int tmg399x_read_prox_data(struct tmg399x_chip *chip)
+{
+	int ret = 0;
+    ret = tmg399x_i2c_read(chip, TMG399X_PRX_CHAN, &chip->shadow[TMG399X_PRX_CHAN]);
+	return (ret < 0) ? ret : 0;
+}
+
+static int tmg399x_read_rgb_data(struct tmg399x_chip *chip)
+{
+    
+	//mutex_lock(&chip->lock);
+
+	tmg399x_i2c_read(chip, TMG399X_CLR_CHANLO, &chip->shadow[TMG399X_CLR_CHANLO]);
+	tmg399x_i2c_read(chip, TMG399X_CLR_CHANHI, &chip->shadow[TMG399X_CLR_CHANHI]);
+
+	tmg399x_i2c_read(chip, TMG399X_RED_CHANLO, &chip->shadow[TMG399X_RED_CHANLO]);
+	tmg399x_i2c_read(chip, TMG399X_RED_CHANHI, &chip->shadow[TMG399X_RED_CHANHI]);
+
+	tmg399x_i2c_read(chip, TMG399X_GRN_CHANLO, &chip->shadow[TMG399X_GRN_CHANLO]);
+	tmg399x_i2c_read(chip, TMG399X_GRN_CHANHI, &chip->shadow[TMG399X_GRN_CHANHI]);
+
+	tmg399x_i2c_read(chip, TMG399X_BLU_CHANLO, &chip->shadow[TMG399X_BLU_CHANLO]);
+	tmg399x_i2c_read(chip, TMG399X_BLU_CHANHI, &chip->shadow[TMG399X_BLU_CHANHI]);
+
+	//mutex_unlock(&chip->lock);
+
+	return 0;
+}
+
+static void tmg399x_als_atime_set(u8 time)
+{
+	p_global_tmg399x_chip->shadow[TMG399X_ALS_TIME] = time;
+	p_global_tmg399x_chip->params.als_time = time;
+	tmg399x_i2c_write(p_global_tmg399x_chip, TMG399X_ALS_TIME, p_global_tmg399x_chip->shadow[TMG399X_ALS_TIME]);
+}
+
+static int tmg399x_update_als_thres(struct tmg399x_chip *chip, bool on_enable)
+{
+	s32 ret;
+	u8 *buf = &chip->shadow[TMG399X_ALS_MINTHRESHLO];
+	u16 deltaP = chip->params.als_deltaP;
+	u16 from, to, cur;
+	u16 saturation = chip->als_inf.saturation;
+
+	cur = chip->als_inf.clear_raw;
+
+	if (on_enable) {
+		/* move deltaP far away from current position to force an irq */
+		from = to = cur > saturation / 2 ? 0 : saturation;
+	} else {
+		deltaP = cur * deltaP / 100;
+		if (!deltaP)
+			deltaP = 1;
+
+		if (cur > deltaP)
+			from = cur - deltaP;
+		else
+			from = 0;
+
+		if (cur < (saturation - deltaP))
+			to = cur + deltaP;
+		else
+			to = saturation;
+
+	}
+
+	*buf++ = from & 0xff;
+	*buf++ = from >> 8;
+	*buf++ = to & 0xff;
+	*buf++ = to >> 8;
+	ret = tmg399x_i2c_reg_blk_write(chip, TMG399X_ALS_MINTHRESHLO,
+			&chip->shadow[TMG399X_ALS_MINTHRESHLO],
+			TMG399X_ALS_MAXTHRESHHI - TMG399X_ALS_MINTHRESHLO + 1);
+
+	return (ret < 0) ? ret : 0;
+}
+
+static int tmg399x_ges_init(struct tmg399x_chip *chip, int on)
+{
+	int ret;
+	
+	if (on) 
+    {
+		if (chip->pdata) 
+        {
+			chip->params.ges_entry_th = chip->pdata->parameters.ges_entry_th;
+			chip->params.ges_exit_th = chip->pdata->parameters.ges_exit_th;
+			chip->params.ges_cfg1 = chip->pdata->parameters.ges_cfg1;
+			chip->params.ges_cfg2 = chip->pdata->parameters.ges_cfg2;
+			chip->params.ges_offset_n = chip->pdata->parameters.ges_offset_n;
+			chip->params.ges_offset_s = chip->pdata->parameters.ges_offset_s;
+			chip->params.ges_pulse = chip->pdata->parameters.ges_pulse;
+			chip->params.ges_offset_w = chip->pdata->parameters.ges_offset_w;
+			chip->params.ges_offset_e = chip->pdata->parameters.ges_offset_e;
+			chip->params.ges_dimension = chip->pdata->parameters.ges_dimension;
+		} 
+        else 
+        {
+			chip->params.ges_entry_th = param_default.ges_entry_th;
+			chip->params.ges_exit_th = param_default.ges_exit_th;
+			chip->params.ges_cfg1 = param_default.ges_cfg1;
+			chip->params.ges_cfg2 = param_default.ges_cfg2;
+			chip->params.ges_offset_n = param_default.ges_offset_n;
+			chip->params.ges_offset_s = param_default.ges_offset_s;
+			chip->params.ges_pulse = param_default.ges_pulse;
+			chip->params.ges_offset_w = param_default.ges_offset_w;
+			chip->params.ges_offset_e = param_default.ges_offset_e;
+			chip->params.ges_dimension = param_default.ges_dimension;
+		}
+	}
+    else 
+    {
+		chip->params.ges_entry_th = 0;
+		chip->params.ges_exit_th = 0;
+		chip->params.ges_cfg1 = 0;
+		chip->params.ges_cfg2 = 0;
+		chip->params.ges_offset_n = 0;
+		chip->params.ges_offset_s = 0;
+		chip->params.ges_pulse = 0;
+		chip->params.ges_offset_w = 0;
+		chip->params.ges_offset_e = 0;
+		chip->params.ges_dimension = 0;	
+	}
+
+	/* Initial gesture registers */
+	chip->shadow[TMG399X_GES_ENTH]  = chip->params.ges_entry_th;
+	chip->shadow[TMG399X_GES_EXTH]  = chip->params.ges_exit_th;
+	chip->shadow[TMG399X_GES_CFG_1] = chip->params.ges_cfg1;
+	chip->shadow[TMG399X_GES_CFG_2] = chip->params.ges_cfg2;
+	chip->shadow[TMG399X_GES_OFFSET_N] = chip->params.ges_offset_n;
+	chip->shadow[TMG399X_GES_OFFSET_S] = chip->params.ges_offset_s;
+	chip->shadow[TMG399X_GES_PULSE] = chip->params.ges_pulse;
+	chip->shadow[TMG399X_GES_OFFSET_W] = chip->params.ges_offset_w;
+	chip->shadow[TMG399X_GES_OFFSET_E] = chip->params.ges_offset_e;
+	chip->shadow[TMG399X_GES_CFG_3] = chip->params.ges_dimension;
+	
+	ret  = tmg399x_i2c_write(chip, TMG399X_GES_ENTH,     chip->shadow[TMG399X_GES_ENTH]);
+	ret |= tmg399x_i2c_write(chip, TMG399X_GES_EXTH,     chip->shadow[TMG399X_GES_EXTH]);
+	ret |= tmg399x_i2c_write(chip, TMG399X_GES_CFG_1,    chip->shadow[TMG399X_GES_CFG_1]);
+	ret |= tmg399x_i2c_write(chip, TMG399X_GES_CFG_2,    chip->shadow[TMG399X_GES_CFG_2]);
+	ret |= tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_N, chip->shadow[TMG399X_GES_OFFSET_N]);
+	ret |= tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_S, chip->shadow[TMG399X_GES_OFFSET_S]);
+	ret |= tmg399x_i2c_write(chip, TMG399X_GES_PULSE,    chip->shadow[TMG399X_GES_PULSE]);
+	ret |= tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_W, chip->shadow[TMG399X_GES_OFFSET_W]);
+	ret |= tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_E, chip->shadow[TMG399X_GES_OFFSET_E]);
+	ret |= tmg399x_i2c_write(chip, TMG399X_GES_CFG_3,    chip->shadow[TMG399X_GES_CFG_3]);
+
+	return ret;
+}
+
+static int tmg399x_ges_enable(struct tmg399x_chip *chip, int on)
+{
+	int ret = 0;
+
+    SENSOR_LOG_INFO("on = %d\n",on);
+	if (on) 
+    {
+		/* initialize */		
+		ret |= tmg399x_ges_init(chip, 1);		
+		if (ret < 0)
+        {
+            SENSOR_LOG_INFO("tmg399x_ges_init failed!\n");
+			return ret;
+        }
+        
+        chip->shadow[TMG399X_CONTROL] |= (TMG399X_EN_PWR_ON | TMG399X_EN_PRX | TMG399X_EN_GES);
+	    chip->shadow[TMG399X_CONTROL] &=(~(TMG399X_EN_WAIT));
+		chip->shadow[TMG399X_GES_CFG_4] |= (TMG399X_GES_EN_IRQ | TMG399X_GES_MODE);
+		ret |= tmg399x_update_enable_reg(chip);
+		
+		mdelay(3);
+
+        chip->light_poll_time = AMS_ALS_POLL_DELAY_SLOW;
+        tmg399x_als_atime_set(AMS_ALS_ATIME_SHORT);
+        tmg399x_irq_enable(true, true);
+
+	} 
+    else 
+    {
+        if (false == chip->prx_enabled)
+        {                        
+            chip->light_poll_time = AMS_ALS_POLL_DELAY_FAST;
+            tmg399x_als_atime_set(AMS_ALS_ATIME_LONG);
+            tmg399x_irq_enable(false, true);
+        }
+
+		chip->shadow[TMG399X_CONTROL] &= ~TMG399X_EN_GES;
+
+        if ((false == chip->prx_enabled) && (false == chip->als_enabled))
+        {
+			chip->shadow[TMG399X_CONTROL] &= ~TMG399X_EN_PWR_ON;
+        }
+		chip->shadow[TMG399X_GES_CFG_4] &= ~(TMG399X_GES_EN_IRQ | TMG399X_GES_MODE);
+
+		ret = tmg399x_update_enable_reg(chip);
+        
+		/* deinitialize */		
+		ret |= tmg399x_ges_init(chip, 0);
+		if (ret)
+        {
+            SENSOR_LOG_INFO("tmg399x_ges_init failed!\n");
+			return ret;
+        }
+	}
+
+    SENSOR_LOG_INFO("chip->shadow[TMG399X_CONTROL] = %X\n",chip->shadow[TMG399X_CONTROL]);
+
+	return ret;
+}
+
+static int tmg399x_prox_enable(struct tmg399x_chip *chip, int on)
+{
+	int ret;
+
+    SENSOR_LOG_INFO("on = %d\n",on);
+
+	if (on) 
+    {
+		tmg399x_irq_clr(chip, TMG399X_CMD_PROX_INT_CLR);
+
+        tmg399x_i2c_write(chip, TMG399X_PRX_THRES_LOW,  0x01);
+        tmg399x_i2c_write(chip, TMG399X_PRX_THRES_HIGH, 0x01);
+
+		chip->shadow[TMG399X_CONTROL] |= (TMG399X_EN_PWR_ON | TMG399X_EN_PRX | TMG399X_EN_PRX_IRQ | TMG399X_EN_WAIT);
+
+		ret = tmg399x_update_enable_reg(chip);
+		if (ret < 0)
+			return ret;
+		mdelay(3);
+    
+        chip->light_poll_time = AMS_ALS_POLL_DELAY_SLOW;
+        tmg399x_als_atime_set(AMS_ALS_ATIME_SHORT);
+
+        chip->prx_inf.detected = PROX_UNKNOW;
+        tmg399x_irq_enable(true, true);
+	} 
+    else 
+    {
+        if (true == (chip->proximity_wakelock).locked)
+        {
+            tmg399x_wakelock_ops(&(chip->proximity_wakelock),false);
+        }
+
+
+        if (false == chip->ges_enabled)
+        {
+            chip->light_poll_time = AMS_ALS_POLL_DELAY_FAST;
+            tmg399x_als_atime_set(AMS_ALS_ATIME_LONG);
+            tmg399x_irq_enable(false, true);
+        }
+
+        chip->shadow[TMG399X_CONTROL] &= ~(TMG399X_EN_PRX_IRQ | TMG399X_EN_PRX);
+
+        if ((false == chip->als_enabled) && (false == chip->ges_enabled))
+        {            
+            chip->shadow[TMG399X_CONTROL] &= ~TMG399X_EN_PWR_ON;
+        }
+
+		ret = tmg399x_update_enable_reg(chip);
+		if (ret < 0)
+			return ret;
+		tmg399x_irq_clr(chip, TMG399X_CMD_PROX_INT_CLR);
+        chip->prx_inf.detected = PROX_UNKNOW;
+	}
+
+    SENSOR_LOG_INFO("chip->shadow[TMG399X_CONTROL] = %X\n",chip->shadow[TMG399X_CONTROL]);
+
+	return ret;
+}
+
+static int tmg399x_als_enable(struct tmg399x_chip *chip, int on)
+{
+	int ret;
+
+    SENSOR_LOG_INFO("on = %d\n",on);
+
+	if (on) 
+    {
+        chip->als_enabled = true;
+		tmg399x_irq_clr(chip, TMG399X_CMD_ALS_INT_CLR);
+		tmg399x_update_als_thres(chip, 1);
+		chip->shadow[TMG399X_CONTROL] |= (TMG399X_EN_PWR_ON | TMG399X_EN_ALS /*| TMG399X_EN_ALS_IRQ*/);
+		ret = tmg399x_update_enable_reg(chip);
+		if (ret < 0)
+			return ret;
+		mdelay(3);
+        schedule_delayed_work(&p_global_tmg399x_chip->als_poll_work, msecs_to_jiffies(chip->light_poll_time));
+	}
+    else
+    {
+        chip->als_enabled = false;
+		//chip->shadow[TMG399X_CONTROL] &= ~(TMG399X_EN_ALS_IRQ);
+
+        if ((false == chip->prx_enabled) && (false == chip->ges_enabled))
+        {
+             chip->shadow[TMG399X_CONTROL] &= ~ (TMG399X_EN_ALS | TMG399X_EN_PWR_ON);
+        }     
+
+		ret = tmg399x_update_enable_reg(chip);
+
+		if (ret < 0)
+			return ret;
+		tmg399x_irq_clr(chip, TMG399X_CMD_ALS_INT_CLR);
+        //cancel_delayed_work_sync(&p_global_tmg399x_chip->als_poll_work);
+	}
+
+    SENSOR_LOG_INFO("chip->shadow[TMG399X_CONTROL] = %X\n",chip->shadow[TMG399X_CONTROL]);
+
+	if (!ret)
+		chip->als_enabled = on;
+
+	return ret;
+}
+
+static int tmg399x_wait_enable(struct tmg399x_chip *chip, int on)
+{
+	int ret;
+
+	dev_info(&chip->client->dev, "%s: on = %d\n", __func__, on);
+	if (on) {
+		chip->shadow[TMG399X_CONTROL] |= TMG399X_EN_WAIT;
+
+		ret = tmg399x_update_enable_reg(chip);
+		if (ret < 0)
+			return ret;
+		mdelay(3);
+	} else {
+		chip->shadow[TMG399X_CONTROL] &= ~TMG399X_EN_WAIT;
+
+		ret = tmg399x_update_enable_reg(chip);
+		if (ret < 0)
+			return ret;
+	}
+	if (!ret)
+	        chip->wait_enabled = on;
+
+	return ret;
+}
+
+static ssize_t tmg399x_ges_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->ges_enabled);
+}
+
+static ssize_t tmg399x_ges_enable_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	bool value;
+
+	if (strtobool(buf, &value))
+		return -EINVAL;
+    mutex_lock(&chip->lock);
+
+    chip->ges_enabled = (value>0) ? true : false;
+
+	if (value)
+    {
+        if (false==chip->prx_enabled)
+        {
+		    tmg399x_ges_enable(chip, true);
+        }
+	}
+    else
+    {   
+		tmg399x_ges_enable(chip, false);
+        chip->gesture_start = false;
+    }
+    mutex_unlock(&chip->lock);
+
+	return size;
+}
+
+static ssize_t tmg399x_prox_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prx_enabled);
+}
+
+static ssize_t tmg399x_prox_enable_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	bool value;
+
+	if (strtobool(buf, &value))
+		return -EINVAL;
+    mutex_lock(&chip->lock);
+
+    chip->prx_enabled = (value>0) ? true : false;
+
+	if (value)
+    {
+        if (true == chip->ges_enabled)
+        {
+            tmg399x_ges_enable(chip, false);
+        }
+
+		tmg399x_prox_enable(chip, true);
+    }
+	else
+    {
+		tmg399x_prox_enable(chip, false);
+
+        if (true == chip->ges_enabled)
+        {
+            tmg399x_ges_enable(chip, true);
+        }
+    }
+    mutex_unlock(&chip->lock);
+
+	return size;
+}
+
+static ssize_t tmg399x_als_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_enabled);
+}
+
+static ssize_t tmg399x_als_enable_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	bool value;
+
+	if (strtobool(buf, &value))
+		return -EINVAL;
+
+    mutex_lock(&chip->lock);
+
+	if (value)
+    {
+		tmg399x_als_enable(chip, true);
+	}
+    else
+    {
+		tmg399x_als_enable(chip, false);
+    }
+    mutex_unlock(&chip->lock);
+
+	return size;
+}
+
+static ssize_t tmg399x_light_debug_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "light_debug_enable is %s\n", chip->light_debug_enable? "true":"false");
+}
+
+static ssize_t tmg399x_light_debug_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	bool value;
+
+	if (strtobool(buf, &value))
+		return -EINVAL;
+    mutex_lock(&chip->lock);
+
+	if (value)
+    {
+        chip->light_debug_enable = true;
+	}
+    else
+    {
+        chip->light_debug_enable = false;
+    }
+    mutex_unlock(&chip->lock);
+
+	return size;
+}
+
+static ssize_t tmg399x_prox_debug_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "prox_debug_enable is %s\n", chip->prox_debug_enable? "true":"false");
+}
+
+static ssize_t tmg399x_prox_debug_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	bool value;
+
+	if (strtobool(buf, &value))
+		return -EINVAL;
+    mutex_lock(&chip->lock);
+
+	if (value)
+    {
+        chip->prox_debug_enable = true;
+	}
+    else
+    {
+        chip->prox_debug_enable = false;
+    }
+    mutex_unlock(&chip->lock);
+
+	return size;
+}
+
+
+static ssize_t tmg399x_prox_calibrate_result_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prox_calibrate_result);
+}
+
+static ssize_t tmg399x_chip_name_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%s\n", chip->chip_name);
+}
+
+static ssize_t tmg399x_prox_thres_hi_max(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prox_thres_hi_max);
+}
+
+static ssize_t tmg399x_prox_thres_hi_min(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    return snprintf(buf, PAGE_SIZE, "%d\n", chip->prox_thres_hi_min);
+}
+
+static ssize_t tmg399x_prox_data_safa_range_max_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    int input_data;
+    int ret;
+	ret = kstrtoint(buf, 10, &input_data);
+	if (ret) {
+		return -EINVAL;
+    }
+	if (input_data > 255 || input_data < 0) {
+		dev_err(&chip->client->dev, "prox offset max range [0, 255]\n");
+		return -EINVAL;
+	}
+    
+    chip->prox_data_safe_range_max = input_data;
+	return size;
+}
+
+static ssize_t tmg399x_prox_data_safa_range_max_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prox_data_safe_range_max);
+}
+
+static ssize_t tmg399x_prox_data_safa_range_min_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    int input_data;
+    int ret;
+	ret = kstrtoint(buf, 10, &input_data);
+	if (ret) {
+		return -EINVAL;
+    }
+	if (input_data > 255 || input_data < 0) {
+		dev_err(&chip->client->dev, "prox offset min range [0, 255]\n");
+		return -EINVAL;
+	}
+    
+    chip->prox_data_safe_range_min = input_data;
+	return size;
+}
+
+
+static ssize_t tmg399x_prox_data_safa_range_min_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prox_data_safe_range_min);
+}
+
+static ssize_t tmg399x_prox_data_max_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    int input_data;
+    int ret;
+	ret = kstrtoint(buf, 10, &input_data);
+	if (ret) {
+		return -EINVAL;
+    }
+	if (input_data > 255 || input_data < 0) {
+		dev_err(&chip->client->dev, "prox data max range [0, 255]\n");
+		return -EINVAL;
+	}
+    
+    chip->prox_data_max = input_data;
+	return size;
+}
+
+
+static ssize_t tmg399x_prox_data_max_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prox_data_max);
+}
+
+
+static ssize_t tmg399x_manual_calibrate_threshold(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prox_manual_calibrate_threshold);
+}
+
+
+static ssize_t tmg399x_ges_debug_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "ges_debug_enable is %s\n", chip->ges_debug_enable? "true":"false");
+}
+
+static ssize_t tmg399x_ges_debug_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	bool value;
+
+	if (strtobool(buf, &value))
+		return -EINVAL;
+    mutex_lock(&chip->lock);
+
+	if (value)
+    {
+        chip->ges_debug_enable = true;
+	}
+    else
+    {
+        chip->ges_debug_enable = false;
+    }
+    mutex_unlock(&chip->lock);
+
+	return size;
+}
+
+
+static ssize_t tmg399x_wait_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->wait_enabled);
+}
+
+static ssize_t tmg399x_wait_enable_store(struct device *dev,
+                                struct device_attribute *attr,
+                                const char *buf, size_t size)
+{
+    struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    bool value;
+
+    if (strtobool(buf, &value))
+            return -EINVAL;
+	mutex_lock(&chip->lock);
+
+    if (value)
+            tmg399x_wait_enable(chip, 1);
+    else
+            tmg399x_wait_enable(chip, 0);
+
+	mutex_unlock(&chip->lock);
+    return size;
+}
+
+static ssize_t tmg399x_als_itime_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	int t;
+	t = 256 - chip->params.als_time;
+	t *= TMG399X_ATIME_PER_100;
+	t /= 100;
+	return snprintf(buf, PAGE_SIZE, "%d (in ms)\n", t);
+}
+
+static ssize_t tmg399x_als_itime_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long itime;
+	int rc;
+
+	rc = kstrtoul(buf, 10, &itime);
+	if (rc)
+		return -EINVAL;
+	if (itime > 712 || itime < 3) {
+		dev_err(&chip->client->dev,
+			"als integration time range [3,712]\n");
+		return -EINVAL;
+	}
+
+	itime *= 100;
+	itime /= TMG399X_ATIME_PER_100;
+	itime = (256 - itime);
+   
+	mutex_lock(&chip->lock);
+	/*
+    chip->shadow[TMG399X_ALS_TIME] = (u8)itime;
+	chip->params.als_time = (u8)itime;
+	tmg399x_i2c_write(chip, TMG399X_ALS_TIME, chip->shadow[TMG399X_ALS_TIME]);
+	*/
+
+    tmg399x_als_atime_set((u8)itime);
+
+    mutex_unlock(&chip->lock);
+	
+    return size;
+}
+
+static ssize_t tmg399x_als_poll_time_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+    struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "delay is %d ms\n", chip->light_poll_time);
+}
+
+static ssize_t tmg399x_als_poll_time_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	unsigned long time;
+	int rc;
+    struct tmg399x_chip *chip = dev_get_drvdata(dev);
+
+	rc = kstrtoul(buf, 10, &time);
+	if (rc)
+		return -EINVAL;
+    SENSOR_LOG_INFO("set delay to %d ms\n",(int)time);
+	chip->light_poll_time = (int)time;
+	return size;
+}
+
+
+static ssize_t tmg399x_wait_time_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	int t;
+	t = 256 - chip->params.wait_time;
+	t *= TMG399X_ATIME_PER_100;
+	t /= 100;
+	if (chip->params.als_prox_cfg1 & WLONG)
+		t *= 12;
+	return snprintf(buf, PAGE_SIZE, "%d (in ms)\n", t);
+}
+
+static ssize_t tmg399x_wait_time_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long time;
+	int ret;
+	u8 cfg1;
+
+	ret = kstrtoul(buf, 10, &time);
+	if (ret) {
+		return -EINVAL;
+	}
+	if (time > 8540 || time < 3) {
+		dev_err(&chip->client->dev,
+			"wait time range [3,8540]\n");
+		return -EINVAL;
+	}
+	
+	cfg1 = chip->shadow[TMG399X_CONFIG_1] & ~0x02;
+	if (time > 712) {
+		cfg1 |= WLONG;
+		time /= 12;
+	}
+
+	time *= 100;
+	time /= TMG399X_ATIME_PER_100;
+	time = (256 - time);
+	mutex_lock(&chip->lock);
+	chip->shadow[TMG399X_WAIT_TIME] = (u8)time;
+	chip->params.wait_time = (u8)time;
+	chip->shadow[TMG399X_CONFIG_1] = cfg1;
+	chip->params.als_prox_cfg1 = cfg1;
+	tmg399x_i2c_write(chip, TMG399X_WAIT_TIME,
+		chip->shadow[TMG399X_WAIT_TIME]);
+	tmg399x_i2c_write(chip, TMG399X_CONFIG_1,
+		chip->shadow[TMG399X_CONFIG_1]);
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_prox_persist_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			(chip->params.persist & 0xF0) >> 4);
+}
+
+static ssize_t tmg399x_prox_persist_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long persist;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &persist);
+	if (ret) {
+		return -EINVAL;
+	}
+	
+	if (persist > 15) {
+		dev_err(&chip->client->dev,
+			"prox persistence range [0,15]\n");
+		return -EINVAL;
+	}
+	
+	mutex_lock(&chip->lock);
+	chip->shadow[TMG399X_PERSISTENCE] &= 0x0F;
+	chip->shadow[TMG399X_PERSISTENCE] |= (((u8)persist << 4) & 0xF0);
+	chip->params.persist = chip->shadow[TMG399X_PERSISTENCE];
+	tmg399x_i2c_write(chip, TMG399X_PERSISTENCE,
+		chip->shadow[TMG399X_PERSISTENCE]);
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_als_persist_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			(chip->params.persist & 0x0F));
+}
+
+static ssize_t tmg399x_als_persist_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long persist;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &persist);
+	if (ret) {
+		return -EINVAL;
+	}
+
+	if (persist > 15) {
+		dev_err(&chip->client->dev,
+			"als persistence range [0,15]\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&chip->lock);
+	chip->shadow[TMG399X_PERSISTENCE] &= 0xF0;
+	chip->shadow[TMG399X_PERSISTENCE] |= ((u8)persist & 0x0F);
+	chip->params.persist = chip->shadow[TMG399X_PERSISTENCE];
+	tmg399x_i2c_write(chip, TMG399X_PERSISTENCE,
+		chip->shadow[TMG399X_PERSISTENCE]);
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_prox_pulse_len_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	int i = (chip->params.prox_pulse & 0xC0) >> 6;
+	return snprintf(buf, PAGE_SIZE, "%duS\n", prox_pplens[i]);
+}
+
+static ssize_t tmg399x_prox_pulse_len_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long length;
+	int ret;
+	u8 ppulse;
+
+	ret = kstrtoul(buf, 10, &length);
+	if (ret) {
+		return -EINVAL;
+	}
+
+	if (length != 4 && length != 8 &&
+		length != 16 &&	length != 32) {
+		dev_err(&chip->client->dev, 
+			"pulse length set: {4, 8, 16, 32}\n");
+		return -EINVAL;
+	}
+	
+	mutex_lock(&chip->lock);
+	ppulse = chip->shadow[TMG399X_PRX_PULSE] & 0x3F;
+	switch (length){
+	case 4:
+		ppulse |= PPLEN_4US;
+		break;
+	case 8:
+		ppulse |= PPLEN_8US;
+		break;
+	case 16:
+		ppulse |= PPLEN_16US;
+		break;
+	case 32:
+		ppulse |= PPLEN_32US;
+		break;
+	default:
+		break;
+	}
+	chip->shadow[TMG399X_PRX_PULSE] = ppulse;
+	chip->params.prox_pulse = ppulse;
+	tmg399x_i2c_write(chip, TMG399X_PRX_PULSE,
+		chip->shadow[TMG399X_PRX_PULSE]);
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_prox_pulse_cnt_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			(chip->params.prox_pulse & 0x3F) + 1);
+}
+
+static ssize_t tmg399x_prox_pulse_cnt_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long count;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &count);
+	if (ret) {
+		return -EINVAL;
+	}
+
+	if (count > 32 || count == 0) {
+		dev_err(&chip->client->dev,
+			"prox pulse count range [1,32]\n");
+		return -EINVAL;
+	}
+	count -= 1;
+
+	mutex_lock(&chip->lock);
+	chip->shadow[TMG399X_PRX_PULSE] &= 0xC0;
+	chip->shadow[TMG399X_PRX_PULSE] |= ((u8)count & 0x3F);
+	chip->params.prox_pulse = chip->shadow[TMG399X_PRX_PULSE];
+	tmg399x_i2c_write(chip, TMG399X_PRX_PULSE,
+		chip->shadow[TMG399X_PRX_PULSE]);
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+
+static ssize_t tmg399x_ges_pulse_cnt_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			(chip->params.ges_pulse & 0x3F) + 1);
+}
+
+static ssize_t tmg399x_ges_pulse_cnt_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long count;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &count);
+	if (ret) {
+		return -EINVAL;
+	}
+
+	if (count > 32 || count == 0) {
+		dev_err(&chip->client->dev,
+			"prox pulse count range [1,32]\n");
+		return -EINVAL;
+	}
+	count -= 1;
+
+	mutex_lock(&chip->lock);
+	chip->shadow[TMG399X_GES_PULSE] &= 0xC0;
+	chip->shadow[TMG399X_GES_PULSE] |= ((u8)count & 0x3F);
+	chip->params.ges_pulse = chip->shadow[TMG399X_GES_PULSE];
+	tmg399x_i2c_write(chip, TMG399X_GES_PULSE, chip->shadow[TMG399X_GES_PULSE]);
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+
+
+static ssize_t tmg399x_ges_pulse_len_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	int i = (chip->params.ges_pulse & 0xC0) >> 6;
+	return snprintf(buf, PAGE_SIZE, "%duS\n", prox_pplens[i]);
+}
+
+static ssize_t tmg399x_ges_pulse_len_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long length;
+	int ret;
+	u8 ppulse;
+
+	ret = kstrtoul(buf, 10, &length);
+	if (ret) {
+		return -EINVAL;
+	}
+
+	if (length != 4 && length != 8 &&
+		length != 16 &&	length != 32) {
+		dev_err(&chip->client->dev, 
+			"pulse length set: {4, 8, 16, 32}\n");
+		return -EINVAL;
+	}
+	
+	mutex_lock(&chip->lock);
+	ppulse = chip->shadow[TMG399X_GES_PULSE] & 0x3F;
+	switch (length){
+	case 4:
+		ppulse |= GPLEN_4US;
+		break;
+	case 8:
+		ppulse |= GPLEN_8US;
+		break;
+	case 16:
+		ppulse |= GPLEN_16US;
+		break;
+	case 32:
+		ppulse |= GPLEN_32US;
+		break;
+	default:
+		break;
+	}
+	chip->shadow[TMG399X_GES_PULSE] = ppulse;
+	chip->params.ges_pulse = ppulse;
+	tmg399x_i2c_write(chip, TMG399X_GES_PULSE,
+		chip->shadow[TMG399X_GES_PULSE]);
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+
+static ssize_t tmg399x_ges_gain_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	int i = chip->params.ges_cfg2 >> 2;
+	return snprintf(buf, PAGE_SIZE, "%d\n", prox_gains[i]);
+}
+
+static ssize_t tmg399x_ges_gain_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long gain;
+	int ret;
+	u8 ctrl_reg;
+
+	ret = kstrtoul(buf, 10, &gain);
+	if (ret)
+    {
+		return -EINVAL;
+    }
+	if (gain != 1 && gain != 2 && gain != 4 && gain != 8) {
+		dev_err(&chip->client->dev,
+			"prox gain set: {1, 2, 4, 8}\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&chip->lock);
+	ctrl_reg = chip->shadow[TMG399X_GES_CFG_2] & ~TMG399X_GES_GAIN_MASK;
+	switch (gain){
+	case 1:
+		ctrl_reg |= GGAIN_1;
+		break;
+	case 2:
+		ctrl_reg |= GGAIN_2;
+		break;
+	case 4:
+		ctrl_reg |= GGAIN_4;
+		break;
+	case 8:
+		ctrl_reg |= GGAIN_8;
+		break;
+	default:
+		break;
+	}
+
+	ret = tmg399x_i2c_write(chip, TMG399X_GES_CFG_2, ctrl_reg);
+	if (!ret) {
+		chip->shadow[TMG399X_GES_CFG_2] = ctrl_reg;
+		chip->params.ges_cfg2 = ctrl_reg & TMG399X_GES_GAIN_MASK;
+	}
+	mutex_unlock(&chip->lock);
+	return ret ? ret : size;
+}
+
+
+
+
+static ssize_t tmg399x_prox_gain_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	int i = chip->params.prox_gain >> 2;
+	return snprintf(buf, PAGE_SIZE, "%d\n", prox_gains[i]);
+}
+
+static ssize_t tmg399x_prox_gain_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long gain;
+	int ret;
+	u8 ctrl_reg;
+
+	ret = kstrtoul(buf, 10, &gain);
+	if (ret)
+    {
+		return -EINVAL;
+    }
+	if (gain != 1 && gain != 2 && gain != 4 && gain != 8) {
+		dev_err(&chip->client->dev,
+			"prox gain set: {1, 2, 4, 8}\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&chip->lock);
+	ctrl_reg = chip->shadow[TMG399X_GAIN] & ~TMG399X_PRX_GAIN_MASK;
+	//cfg1_reg = chip->shadow[TMG399X_CONFIG_1] & ~0x80;
+	switch (gain){
+	case 1:
+		ctrl_reg |= PGAIN_1;
+		break;
+	case 2:
+		ctrl_reg |= PGAIN_2;
+		break;
+	case 4:
+		ctrl_reg |= PGAIN_4;
+		break;
+	case 8:
+		ctrl_reg |= PGAIN_8;
+		break;
+	default:
+		break;
+	}
+
+	ret = tmg399x_i2c_write(chip, TMG399X_GAIN, ctrl_reg);
+//	ret |= tmg399x_i2c_write(chip, TMG399X_CONFIG_1, cfg1_reg);
+	if (!ret) {
+		chip->shadow[TMG399X_GAIN] = ctrl_reg;
+		chip->params.prox_gain = ctrl_reg & TMG399X_PRX_GAIN_MASK;
+	}
+	mutex_unlock(&chip->lock);
+	return ret ? ret : size;
+}
+
+static ssize_t tmg399x_prox_led_drive_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%dmA\n",
+			led_drives[chip->params.ldrive]);
+}
+
+static ssize_t tmg399x_prox_led_drive_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long ldrive;
+	int ret;
+	u8 ctrl_reg;
+
+	ret = kstrtoul(buf, 10, &ldrive);
+	if (ret) 
+    {
+		return -EINVAL;
+    }
+	if (ldrive != 100 && ldrive != 50 &&
+		ldrive != 25 && ldrive != 12) {
+		dev_err(&chip->client->dev,
+			"led drive set: {100, 50, 25, 12}\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&chip->lock);
+	ctrl_reg = chip->shadow[TMG399X_GAIN] & ~TMG399X_LDRIVE_MASK;
+	switch (ldrive){
+	case 100:
+		ctrl_reg |= PDRIVE_100MA;
+		chip->params.ldrive = 0;
+		break;
+	case 50:
+		ctrl_reg |= PDRIVE_50MA;
+		chip->params.ldrive = 1;
+		break;
+	case 25:
+		ctrl_reg |= PDRIVE_25MA;
+		chip->params.ldrive = 2;
+		break;
+	case 12:
+		ctrl_reg |= PDRIVE_12MA;
+		chip->params.ldrive = 3;
+		break;
+	default:
+		break;
+	}
+	chip->shadow[TMG399X_GAIN] = ctrl_reg;
+	tmg399x_i2c_write(chip, TMG399X_GAIN, chip->shadow[TMG399X_GAIN]);
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_als_gain_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d (%s)\n",
+			als_gains[chip->params.als_gain],
+			chip->als_gain_auto ? "auto" : "manual");
+}
+
+static ssize_t tmg399x_als_gain_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long gain;
+	int i = 0;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &gain);
+	if (ret) 
+    {
+		return -EINVAL;
+	}	
+	if (gain != 0 && gain != 1 && gain != 4 &&
+		gain != 16 && gain != 64) {
+		dev_err(&chip->client->dev,
+			"als gain set: {0(auto), 1, 4, 16, 64}\n");
+		return -EINVAL;
+	}
+
+	while (i < sizeof(als_gains)) {
+		if (gain == als_gains[i])
+			break;
+		i++;
+	}
+
+	if (gain) {
+		chip->als_gain_auto = false;
+		ret = tmg399x_set_als_gain(chip, als_gains[i]);
+		if (!ret)
+			tmg399x_calc_cpl(chip);
+	} else {
+		chip->als_gain_auto = true;
+	}
+	mutex_unlock(&chip->lock);
+	return ret ? ret : size;
+}
+
+static ssize_t tmg399x_led_boost_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	int i = (chip->params.als_prox_cfg2 & 0x30) >> 4;
+	return snprintf(buf, PAGE_SIZE, "%d percents\n", led_boosts[i]);
+}
+
+static ssize_t tmg399x_led_boost_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long lboost;
+	int ret;
+	u8 cfg2;
+
+	ret = kstrtoul(buf, 10, &lboost);
+	if (ret) {
+		return -EINVAL;
+    }
+	if (lboost != 100 && lboost != 150 &&
+		lboost != 200 && lboost != 300) {
+		dev_err(&chip->client->dev,
+			"led boost set: {100, 150, 200, 300}\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&chip->lock);
+	cfg2 = chip->shadow[TMG399X_CONFIG_2] & ~0x30;
+	switch (lboost){
+	case 100:
+		cfg2 |= LEDBOOST_100;
+		break;
+	case 150:
+		cfg2 |= LEDBOOST_150;
+		break;
+	case 200:
+		cfg2 |= LEDBOOST_200;
+		break;
+	case 300:
+		cfg2 |= LEDBOOST_300;
+		break;
+	default:
+		break;
+	}
+	chip->shadow[TMG399X_CONFIG_2] = cfg2;
+	chip->params.als_prox_cfg2 = cfg2;
+	tmg399x_i2c_write(chip, TMG399X_CONFIG_2,
+		chip->shadow[TMG399X_CONFIG_2]);
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_sat_irq_en_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			(chip->params.als_prox_cfg2 & 0x80) >> 7);
+}
+
+static ssize_t tmg399x_sat_irq_en_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	bool psien;
+	int rc;
+
+	rc = strtobool(buf, &psien);
+	if (rc)
+		return -EINVAL;
+
+	mutex_lock(&chip->lock);
+	chip->shadow[TMG399X_CONFIG_2] &= 0x7F;
+	if (psien)
+		chip->shadow[TMG399X_CONFIG_2] |= PSIEN;
+	chip->params.als_prox_cfg2 = chip->shadow[TMG399X_CONFIG_2];
+	tmg399x_i2c_write(chip, TMG399X_CONFIG_2, chip->shadow[TMG399X_CONFIG_2]);
+	mutex_unlock(&chip->lock); 
+	return size;
+}
+
+static int tmg399x_prox_threshold_init(struct tmg399x_chip *chip)
+{
+    int ret;
+    if((ret=tmg399x_read_cal_value(PATH_CAL_THRESHOLD))<0)
+    {
+    	SENSOR_LOG_ERROR("tmg399x_prox_init<0\n");
+    	ret = tmg399x_write_cal_file(PATH_CAL_THRESHOLD,0);
+    	if(ret < 0)
+    	{
+    		SENSOR_LOG_ERROR("ERROR=%s\n",PATH_CAL_THRESHOLD);
+    		return -EINVAL;
+    	}
+    	chip->prox_calibrate_times = 5;	
+        schedule_delayed_work(&p_global_tmg399x_chip->prox_thres_cal_work, msecs_to_jiffies(1000));
+    }
+    else 
+    {
+        if (ret==0)
+        {
+            chip->prox_calibrate_times = 5;	
+            schedule_delayed_work(&p_global_tmg399x_chip->prox_thres_cal_work, msecs_to_jiffies(1000));
+            SENSOR_LOG_ERROR("tmg399x_prox_calibrate==1\n");
+        }
+    	else 
+        {
+	        chip->prox_manual_calibrate_threshold = ret;
+            chip->params.prox_th_high = ret;
+            chip->params.prox_th_low  = ret - PROX_THRESHOLD_DISTANCE;
+    		input_report_rel(chip->p_idev, REL_Y, chip->params.prox_th_high);
+    		input_report_rel(chip->p_idev, REL_Z, chip->params.prox_th_low);
+    		input_sync(chip->p_idev);
+    		SENSOR_LOG_ERROR("tmg399x_prox_init> 0\n");
+        }
+    }
+    return ret;
+}
+
+
+static int tmg399x_prox_uncover_data_init(struct tmg399x_chip *chip)
+{
+    int ret;
+
+    if((ret=tmg399x_read_cal_value(PATH_PROX_UNCOVER_DATA))>0)
+    {
+        chip->prox_uncover_data = ret;
+        chip->prox_thres_hi_min = chip->prox_uncover_data + PROX_THRESHOLD_SAFE_DISTANCE + PROX_THRESHOLD_DISTANCE;
+    }
+    
+    return ret;
+}
+
+
+
+static int tmg399x_prox_offset_ne_set(struct tmg399x_chip *chip, int offset)
+{
+    int ret;
+    chip->params.prox_offset_ne = (u8)offset;
+	chip->shadow[TMG399X_PRX_OFFSET_NE] = offset;
+   	ret = tmg399x_i2c_write(chip, TMG399X_PRX_OFFSET_NE, offset);
+    if (ret<0)
+    {
+        SENSOR_LOG_ERROR("write prox_offset_ne failed\n");
+    }
+    return ret;
+}
+
+static int tmg399x_prox_offset_sw_set(struct tmg399x_chip *chip, int offset)
+{
+    int ret;
+    chip->params.prox_offset_sw= (u8)offset;
+	chip->shadow[TMG399X_PRX_OFFSET_SW] = offset;
+   	ret = tmg399x_i2c_write(chip, TMG399X_PRX_OFFSET_SW, offset);
+    if (ret<0)
+    {
+        SENSOR_LOG_ERROR("write prox_offset_sw failed\n");
+    }
+    return ret;
+}
+
+static int tmg399x_prox_offset_ne_init(struct tmg399x_chip *chip)
+{
+    int ret;
+    if((ret=tmg399x_read_cal_value(PATH_PROX_OFFSET_NE))<0)
+    {
+    	SENSOR_LOG_ERROR("read %s failed\n",PATH_PROX_OFFSET_NE);
+    	ret = tmg399x_write_cal_file(PATH_PROX_OFFSET_NE,0);
+    	if(ret < 0)
+    	{
+    		SENSOR_LOG_ERROR("write %s failed\n",PATH_PROX_OFFSET_NE);
+            tmg399x_prox_offset_ne_set(chip, 0);
+    	}
+    }
+    else
+    {
+        tmg399x_prox_offset_ne_set(chip, ret);
+    }
+    
+    return ret;
+}
+
+static int tmg399x_prox_offset_sw_init(struct tmg399x_chip *chip)
+{
+    int ret;
+    if((ret=tmg399x_read_cal_value(PATH_PROX_OFFSET_SW))<0)
+    {
+    	SENSOR_LOG_ERROR("read %s failed\n",PATH_PROX_OFFSET_SW);
+    	ret = tmg399x_write_cal_file(PATH_PROX_OFFSET_SW,0);
+    	if(ret < 0)
+    	{
+    		SENSOR_LOG_ERROR("write %s failed\n",PATH_PROX_OFFSET_SW);
+            tmg399x_prox_offset_sw_set(chip, 0);
+    	}
+    }
+    else
+    {
+        tmg399x_prox_offset_sw_set(chip, ret);
+    }
+
+    return ret;
+}
+
+
+static void tmg399x_prox_offset_init(struct tmg399x_chip *chip)
+{
+    tmg399x_prox_offset_ne_init(chip);
+    tmg399x_prox_offset_sw_init(chip);
+}
+
+static int tmg399x_gesture_offset_n_set(struct tmg399x_chip *chip, int offset)
+{
+    int ret;
+    chip->params.ges_offset_n = offset;
+    chip->pdata->parameters.ges_offset_n = offset;
+    chip->shadow[TMG399X_GES_OFFSET_N] = offset;
+    ret = tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_N, (u8)(offset & 0xff));
+    if (ret<0)
+    {   
+        SENSOR_LOG_ERROR("write gesture_offset_n failed\n");
+    }
+    return ret;
+}
+
+static int tmg399x_gesture_offset_s_set(struct tmg399x_chip *chip, int offset)
+{
+    int ret;
+    chip->params.ges_offset_s = offset;
+    chip->pdata->parameters.ges_offset_s = offset;
+    chip->shadow[TMG399X_GES_OFFSET_S] = offset;
+    ret = tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_S, (u8)(offset & 0xff));
+    if (ret<0)
+    {   
+        SENSOR_LOG_ERROR("write gesture_offset_s failed\n");
+    }
+    return ret;
+}
+
+static int tmg399x_gesture_offset_w_set(struct tmg399x_chip *chip, int offset)
+{
+    int ret;
+    chip->params.ges_offset_w = offset;
+    chip->pdata->parameters.ges_offset_w = offset;
+    chip->shadow[TMG399X_GES_OFFSET_W] = offset;
+    ret = tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_W, (u8)(offset & 0xff));
+    if (ret<0)
+    {   
+        SENSOR_LOG_ERROR("write gesture_offset_w failed\n");
+    }
+    return ret;
+}
+
+static int tmg399x_gesture_offset_e_set(struct tmg399x_chip *chip, int offset)
+{
+    int ret;
+    chip->params.ges_offset_e = offset;
+    chip->pdata->parameters.ges_offset_e = offset;
+    chip->shadow[TMG399X_GES_OFFSET_E] = offset;
+    ret = tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_E, (u8)(offset & 0xff));
+    if (ret<0)
+    {   
+        SENSOR_LOG_ERROR("write gesture_offset_e failed\n");
+    }
+    return ret;
+}
+
+
+static int tmg399x_gesture_offset_n_init(struct tmg399x_chip *chip)
+{
+    int ret;
+    if((ret=tmg399x_read_cal_value(PATH_GESTURE_OFFSET_N))<0)
+    {
+    	SENSOR_LOG_ERROR("read %s failed\n",PATH_GESTURE_OFFSET_N);
+    	ret = tmg399x_write_cal_file(PATH_GESTURE_OFFSET_N,0);
+    	if(ret < 0)
+    	{
+    		SENSOR_LOG_ERROR("write %s failed\n",PATH_GESTURE_OFFSET_N);
+            tmg399x_gesture_offset_n_set(chip, 0);
+    	}
+    }
+    else
+    {
+        tmg399x_gesture_offset_n_set(chip, ret);
+        SENSOR_LOG_ERROR("init %s success\n",PATH_GESTURE_OFFSET_N);
+    }
+
+    return ret;
+}
+
+static int tmg399x_gesture_offset_s_init(struct tmg399x_chip *chip)
+{
+    int ret;
+    if((ret=tmg399x_read_cal_value(PATH_GESTURE_OFFSET_S))<0)
+    {
+    	SENSOR_LOG_ERROR("read %s failed\n",PATH_GESTURE_OFFSET_S);
+    	ret = tmg399x_write_cal_file(PATH_GESTURE_OFFSET_S,0);
+    	if(ret < 0)
+    	{
+    		SENSOR_LOG_ERROR("write %s failed\n",PATH_GESTURE_OFFSET_S);
+            tmg399x_gesture_offset_s_set(chip, 0);
+    	}
+    }
+    else
+    {
+        tmg399x_gesture_offset_s_set(chip, ret);
+        SENSOR_LOG_ERROR("init %s success\n",PATH_GESTURE_OFFSET_S);
+    }
+
+    return ret;
+}
+
+static int tmg399x_gesture_offset_w_init(struct tmg399x_chip *chip)
+{
+    int ret;
+    if((ret=tmg399x_read_cal_value(PATH_GESTURE_OFFSET_W))<0)
+    {
+    	SENSOR_LOG_ERROR("read %s failed\n",PATH_GESTURE_OFFSET_W);
+    	ret = tmg399x_write_cal_file(PATH_GESTURE_OFFSET_W,0);
+    	if(ret < 0)
+    	{
+    		SENSOR_LOG_ERROR("write %s failed\n",PATH_GESTURE_OFFSET_W);
+            tmg399x_gesture_offset_w_set(chip, 0);
+    	}
+    }
+    else
+    {
+        tmg399x_gesture_offset_w_set(chip, ret);
+        SENSOR_LOG_ERROR("init %s success\n",PATH_GESTURE_OFFSET_W);
+    }
+
+    return ret;
+}
+
+static int tmg399x_gesture_offset_e_init(struct tmg399x_chip *chip)
+{
+    int ret;
+    if((ret=tmg399x_read_cal_value(PATH_GESTURE_OFFSET_E))<0)
+    {
+    	SENSOR_LOG_ERROR("read %s failed\n",PATH_GESTURE_OFFSET_E);
+    	ret = tmg399x_write_cal_file(PATH_GESTURE_OFFSET_E,0);
+    	if(ret < 0)
+    	{
+    		SENSOR_LOG_ERROR("write %s failed\n",PATH_GESTURE_OFFSET_E);
+            tmg399x_gesture_offset_e_set(chip, 0);
+    	}
+    }
+    else
+    {
+        tmg399x_gesture_offset_e_set(chip, ret);
+        SENSOR_LOG_ERROR("init %s success\n",PATH_GESTURE_OFFSET_E);
+    }
+
+    return ret;
+}
+
+static void tmg399x_gesture_offset_init(struct tmg399x_chip *chip)
+{
+    tmg399x_gesture_offset_n_init(chip);
+    tmg399x_gesture_offset_s_init(chip);
+    tmg399x_gesture_offset_w_init(chip);
+    tmg399x_gesture_offset_e_init(chip);
+}
+
+static ssize_t tmg399x_prox_init_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	static long value;
+	int ret;
+	ret = kstrtol(buf, 10, &value);
+	if(ret)
+		return -EINVAL;
+	if (value==1)
+    {
+		mutex_lock(&chip->lock);
+        tmg399x_prox_threshold_init(chip);
+        tmg399x_prox_offset_init(chip);
+        tmg399x_prox_uncover_data_init(chip);
+		mutex_unlock(&chip->lock);
+	}
+	else 
+    {
+		SENSOR_LOG_ERROR("ERROR=tmg399x_prox_init_store\n");
+		return -EINVAL;
+	}
+    SENSOR_LOG_ERROR("prox_th_high  = %d\n",chip->params.prox_th_high);
+    SENSOR_LOG_ERROR("prox_th_low   = %d\n",chip->params.prox_th_low);
+	return size;
+}
+
+
+
+static ssize_t tmg399x_prox_threshold_init_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	static long value;
+	int ret;
+	ret = kstrtol(buf, 10, &value);
+	if(ret)
+		return -EINVAL;
+	if (value==1)
+    {
+		mutex_lock(&chip->lock);
+        tmg399x_prox_threshold_init(chip);
+		mutex_unlock(&chip->lock);
+	}
+	else 
+    {
+		SENSOR_LOG_ERROR("ERROR=tmg399x_prox_init_store\n");
+		return -EINVAL;
+	}
+    SENSOR_LOG_ERROR("prox_th_high  = %d\n",chip->params.prox_th_high);
+    SENSOR_LOG_ERROR("prox_th_low   = %d\n",chip->params.prox_th_low);
+	return size;
+}
+
+static ssize_t tmg399x_prox_offset_init_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	static long value;
+	int ret;
+	ret = kstrtol(buf, 10, &value);
+	if(ret)
+		return -EINVAL;
+	if (value==1)
+    {
+		mutex_lock(&chip->lock);
+        tmg399x_prox_offset_init(chip);
+		mutex_unlock(&chip->lock);
+	}
+	else 
+    {
+		SENSOR_LOG_ERROR("ERROR=tmg399x_prox_offset_init\n");
+		return -EINVAL;
+	}
+	return size;
+}
+
+
+static ssize_t tmg399x_gesture_offset_init_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	static long value;
+	int ret;
+	ret = kstrtol(buf, 10, &value);
+	if(ret)
+		return -EINVAL;
+	if (value==1)
+    {
+		mutex_lock(&chip->lock);
+        tmg399x_gesture_offset_init(chip);
+		mutex_unlock(&chip->lock);
+	}
+	else 
+    {
+		SENSOR_LOG_ERROR("ERROR=tmg399x_prox_init_store\n");
+		return -EINVAL;
+	}
+    SENSOR_LOG_ERROR("prox_th_high  = %d\n",chip->params.prox_th_high);
+    SENSOR_LOG_ERROR("prox_th_low   = %d\n",chip->params.prox_th_low);
+	return size;
+}
+
+
+static ssize_t tmg399x_prox_offset_ne_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			chip->params.prox_offset_ne);
+}
+
+static ssize_t tmg399x_prox_offset_ne_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	long offset_ne;
+	int ret;
+	u8 offset = 0;
+
+	ret = kstrtol(buf, 10, &offset_ne);
+	if (ret) {
+		return -EINVAL;
+    }
+	if (offset_ne > 255 || offset_ne < 0) {
+		dev_err(&chip->client->dev, "prox offset range [0, 255]\n");
+		return -EINVAL;
+	}
+    
+    offset = offset_ne;
+	mutex_lock(&chip->lock);
+	ret = tmg399x_i2c_write(chip, TMG399X_PRX_OFFSET_NE, offset);
+	if (!ret) {
+		chip->params.prox_offset_ne = (u8)offset_ne;
+		chip->shadow[TMG399X_PRX_OFFSET_NE] = offset;
+	}
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_prox_offset_sw_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			chip->params.prox_offset_sw);
+}
+
+static ssize_t tmg399x_prox_offset_sw_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	long offset_sw;
+	int ret;
+	u8 offset = 0;
+
+	ret = kstrtol(buf, 10, &offset_sw);
+	if (ret) {
+		return -EINVAL;
+    }
+	if (offset_sw > 255 || offset_sw < 0) {
+		dev_err(&chip->client->dev, "prox offset range [0, 255]\n");
+		return -EINVAL;
+	}
+	
+	offset = offset_sw;
+	mutex_lock(&chip->lock);
+	ret = tmg399x_i2c_write(chip, TMG399X_PRX_OFFSET_SW, offset);
+	if (!ret) {
+		chip->params.prox_offset_sw = (u8)offset_sw;
+		chip->shadow[TMG399X_PRX_OFFSET_SW] = offset;
+	}
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_prox_thres_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	static long value;
+	int rc;
+
+	rc = kstrtol(buf, 10, &value);
+	if (rc)
+		return -EINVAL;
+	if (value==1)
+    {
+   		if( (rc=tmg399x_read_cal_value(PATH_CAL_THRESHOLD))<0)
+        {
+			return -EINVAL;
+		}
+        else
+        {
+            mutex_lock(&chip->lock);
+            chip->prox_manual_calibrate_threshold = rc;
+            chip->params.prox_th_high = rc;
+            chip->params.prox_th_low  = rc - PROX_THRESHOLD_DISTANCE;
+            input_report_rel(chip->p_idev, REL_Y, chip->params.prox_th_high);
+            input_report_rel(chip->p_idev, REL_Z, chip->params.prox_th_low);
+            input_sync(chip->p_idev);
+            mutex_unlock(&chip->lock);
+            SENSOR_LOG_ERROR("prox_th_high  = %d\n",chip->params.prox_th_high);
+            SENSOR_LOG_ERROR("prox_th_low   = %d\n",chip->params.prox_th_low);
+		}
+	}
+	else
+    {		
+		return -EINVAL;
+	}
+	return size;
+}
+
+
+static ssize_t tmg399x_prox_thres_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+
+    SENSOR_LOG_ERROR("prox_th_high  = %d\n",chip->params.prox_th_high);
+    SENSOR_LOG_ERROR("prox_th_low   = %d\n",chip->params.prox_th_low);
+
+	return snprintf(buf, PAGE_SIZE, "prox_th_high  = %d, prox_th_low = %d\n", 
+                                                   chip->params.prox_th_high,
+                                                   chip->params.prox_th_low);
+}
+
+
+static ssize_t tmg399x_gesture_data_safe_range_max_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    int input_data;
+    int ret;
+	ret = kstrtoint(buf, 10, &input_data);
+	if (ret) {
+		return -EINVAL;
+    }
+	if (input_data > 255 || input_data < 0) {
+		dev_err(&chip->client->dev, "prox offset max range [0, 255]\n");
+		return -EINVAL;
+	}
+    
+    chip->gesture_data_safe_range_max = input_data;
+	return size;
+}
+
+
+static ssize_t tmg399x_gesture_data_safe_range_max_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n",chip->gesture_data_safe_range_max);
+}
+
+static ssize_t tmg399x_gesture_data_safe_range_min_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    int input_data;
+    int ret;
+	ret = kstrtoint(buf, 10, &input_data);
+	if (ret) {
+		return -EINVAL;
+    }
+	if (input_data > 255 || input_data < 0) {
+		dev_err(&chip->client->dev, "prox offset min range [0, 255]\n");
+		return -EINVAL;
+	}
+    
+    chip->gesture_data_safe_range_min = input_data;
+	return size;
+}
+
+
+static ssize_t tmg399x_gesture_data_safe_range_min_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n",chip->gesture_data_safe_range_min);
+}
+
+static ssize_t tmg399x_gesture_channel_data_max_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    int input_data;
+    int ret;
+	ret = kstrtoint(buf, 10, &input_data);
+	if (ret) {
+		return -EINVAL;
+    }
+	if (input_data > 255 || input_data < 0) {
+		dev_err(&chip->client->dev, "prox offset min range [0, 255]\n");
+		return -EINVAL;
+	}
+    
+    chip->gesture_data_max = input_data;
+	return size;
+}
+
+
+static ssize_t tmg399x_gesture_channel_data_max_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n",chip->gesture_data_max);
+}
+
+
+
+static ssize_t tmg399x_gesture_offset_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+
+    u8 ges_offset_N = 0;
+    u8 ges_offset_S = 0;
+    u8 ges_offset_W = 0;
+    u8 ges_offset_E = 0;
+
+	mutex_lock(&chip->lock);    
+
+	tmg399x_i2c_read(chip, TMG399X_GES_OFFSET_N, &ges_offset_N);
+	tmg399x_i2c_read(chip, TMG399X_GES_OFFSET_S, &ges_offset_S);
+	tmg399x_i2c_read(chip, TMG399X_GES_OFFSET_W, &ges_offset_W);
+	tmg399x_i2c_read(chip, TMG399X_GES_OFFSET_E, &ges_offset_E);
+
+    SENSOR_LOG_INFO("N = %d\n", (unsigned int)ges_offset_N);
+    SENSOR_LOG_INFO("S = %d\n", (unsigned int)ges_offset_S);
+    SENSOR_LOG_INFO("W = %d\n", (unsigned int)ges_offset_W);
+    SENSOR_LOG_INFO("E = %d\n", (unsigned int)ges_offset_E);
+
+	mutex_unlock(&chip->lock);  
+
+	return sizeof(buf);
+
+//	return snprintf(buf, PAGE_SIZE, "%d\n", chip->params.prox_offset_sw);
+}
+
+//add by zhubing
+static ssize_t tmg399x_gesture_offset_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	long offset;
+	int rc;
+    mutex_lock(&chip->lock);
+    SENSOR_LOG_ERROR("Enter!\n");
+	rc = kstrtol(buf, 10, &offset);
+	if (rc)
+		return -EINVAL;
+
+    SENSOR_LOG_ERROR("offset = %X\n", (unsigned int)offset);
+
+    switch( (offset>>8) & 0x0f)
+    {
+        case 1<<0: // E
+        {            
+            SENSOR_LOG_ERROR("Set E offset = %X\n", (u8)(offset & 0xff));
+            rc = tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_E, (u8)(offset & 0xff));
+            break;
+        }
+
+        case 1<<1: // W
+        {
+            SENSOR_LOG_ERROR("Set W offset = %X\n", (u8)(offset & 0xff));
+            rc = tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_W, (u8)(offset & 0xff));
+            break;
+        }
+
+        case 1<<2: // S
+        {
+            SENSOR_LOG_ERROR("Set S offset = %X\n", (u8)(offset & 0xff));
+            rc = tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_S, (u8)(offset & 0xff));
+            break;
+        }
+
+        case 1<<3: // N
+        {
+            SENSOR_LOG_ERROR("Set N offset = %X\n", (u8)(offset & 0xff));
+            rc = tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_N, (u8)(offset & 0xff));
+            break;
+        }
+
+        default:
+        {
+            
+            SENSOR_LOG_ERROR("error!\n");
+            break;
+        }
+    }
+
+    SENSOR_LOG_ERROR("Exit!\n");
+    mutex_unlock(&chip->lock);
+
+	return size;
+}
+
+static ssize_t tmg399x_gesture_data_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);    
+    u8 ret = 0;
+
+    wait_event_interruptible(gesture_drdy_wq, (atomic_read(&gesture_drdy) == 1));
+
+    mutex_lock(&chip->lock);
+
+    ret = tmg399x_get_ges(chip);
+    if (ret>0)
+    {
+        memcpy(buf, &(chip->gesture_data[0]), ret * sizeof(struct tmg399x_ges_raw_data));
+    }
+
+    tmg399x_i2c_modify(chip, TMG399X_GES_CFG_4, TMG399X_GES_INT_CLR, TMG399X_GES_INT_CLR);
+    
+    atomic_set(&gesture_drdy, 0);
+
+    mutex_unlock(&chip->lock);
+
+	return (sizeof(struct tmg399x_ges_raw_data) * ret);
+}
+
+
+static ssize_t tmg399x_gesture_data_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    struct sGesture_Result Gesture_Result;
+
+    memcpy(&Gesture_Result, buf, sizeof(struct sGesture_Result));
+    
+    if (false==chip->gesture_offset_cal_start)
+    {
+        input_report_rel(chip->g_idev, REL_RX,      Gesture_Result.gesture_style);
+        input_report_rel(chip->g_idev, REL_RY,      Gesture_Result.enter_time);
+        input_report_rel(chip->g_idev, REL_RZ,      Gesture_Result.exit_time);
+        input_report_rel(chip->g_idev, REL_HWHEEL,  Gesture_Result.enter_angle);
+        input_report_rel(chip->g_idev, REL_DIAL,    Gesture_Result.exit_angle);
+        input_sync(chip->g_idev);
+    }
+
+    if (true==chip->ges_debug_enable)
+    {
+        SENSOR_LOG_INFO("gesture_style = %d, enter_time = %ld, exit_time = %ld, enter_angle = %d, exit_angle = %d",
+                                                                                    Gesture_Result.gesture_style,
+                                                                                    Gesture_Result.enter_time,
+                                                                                    Gesture_Result.exit_time,
+                                                                                    Gesture_Result.enter_angle,
+                                                                                    Gesture_Result.exit_angle);
+    }
+	return size;
+}
+
+
+
+static ssize_t tmg399x_prox_mask_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%.2x\n",
+			chip->params.als_prox_cfg3 & 0x0F);
+}
+
+static ssize_t tmg399x_prox_mask_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long prx_mask;
+	int ret;
+
+	ret = kstrtol(buf, 10, &prx_mask);
+	if (ret) {
+		return -EINVAL;
+    }
+	if (prx_mask > 15) {
+		dev_err(&chip->client->dev, "prox mask range [0, 15]\n");
+		return -EINVAL;
+	}
+	if ((prx_mask >> 3) ^ ((prx_mask >> 2) & 0x01) ||
+		((prx_mask >> 1) & 0x01) ^ (prx_mask & 0x01))
+		prx_mask |= PCMP;
+
+	mutex_unlock(&chip->lock);
+	chip->shadow[TMG399X_CONFIG_3] &= 0xD0;
+	chip->shadow[TMG399X_CONFIG_3] |= (u8)prx_mask;
+	chip->params.als_prox_cfg3 = chip->shadow[TMG399X_CONFIG_3];
+	tmg399x_i2c_write(chip, TMG399X_CONFIG_3,
+		chip->shadow[TMG399X_CONFIG_3]);
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_prox_data_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    mutex_lock(&chip->lock);
+    tmg399x_get_prox(chip);
+    mutex_unlock(&chip->lock);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prx_inf.raw);
+}
+
+static ssize_t tmg399x_prox_detected_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    mutex_lock(&chip->lock);
+    tmg399x_get_prox(chip);
+    mutex_unlock(&chip->lock);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prx_inf.detected);
+}
+
+
+static ssize_t tmg399x_prox_calibrate_store(struct device *dev, struct device_attribute *attr, 
+                                            const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    int ret = kstrtouint(buf, 10, &(chip->prox_calibrate_times));
+    if (ret) 
+    {
+        SENSOR_LOG_ERROR("input error\n");
+        return -EINVAL;
+    }
+
+    mutex_lock(&chip->lock);
+    tmg399x_prox_calibrate(chip);
+    mutex_unlock(&chip->lock);
+	return size;
+}
+
+
+
+static ssize_t tmg399x_prox_threshold_cal_start_store(struct device *dev, struct device_attribute *attr, 
+                                            const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned int recv;
+    int ret = kstrtouint(buf, 10, &recv);
+    if (ret) 
+    {
+        SENSOR_LOG_ERROR("input error\n");
+        return -EINVAL;
+    }
+
+    mutex_lock(&chip->lock);
+    if (recv)
+    {
+        chip->prox_threshold_cal_start = true;
+        SENSOR_LOG_INFO("enable prox calibrate\n");
+    }
+    else
+    {
+        chip->prox_threshold_cal_start = false;
+        SENSOR_LOG_INFO("disable prox calibrate\n");
+    }
+    mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_prox_threshold_cal_start_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    SENSOR_LOG_INFO("prox calibrate is %s\n",chip->prox_threshold_cal_start ? "enable" : "disable");
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prox_threshold_cal_start);
+}
+
+static ssize_t tmg399x_prox_offset_cal_start_store(struct device *dev, struct device_attribute *attr, 
+                                            const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned int recv;
+    int ret = kstrtouint(buf, 10, &recv);
+    if (ret) 
+    {
+        SENSOR_LOG_ERROR("input error\n");
+        return -EINVAL;
+    }
+
+    mutex_lock(&chip->lock);
+    if (recv)
+    {
+        chip->prox_offset_cal_start = true;
+        SENSOR_LOG_INFO("enable prox offset calibrate flag\n");
+    }
+    else
+    {
+        chip->prox_offset_cal_start = false;
+        SENSOR_LOG_INFO("disable prox offset calibrate flag\n");
+    }
+    mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_prox_offset_cal_start_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    SENSOR_LOG_INFO("prox calibrate is %s\n",chip->prox_offset_cal_start ? "enable" : "disable");
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prox_offset_cal_start);
+}
+
+
+
+static ssize_t tmg399x_prox_offset_cal_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "NE = %d, SW = %d\n",chip->params.prox_offset_ne,chip->params.prox_offset_sw);
+}
+
+static ssize_t tmg399x_prox_offset_cal_store(struct device *dev, struct device_attribute *attr, 
+                                            const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    int ret = kstrtouint(buf, 10, &(chip->prox_calibrate_times));
+    if (ret) 
+    {
+        SENSOR_LOG_ERROR("input error\n");
+        return -EINVAL;
+    }
+
+    mutex_lock(&chip->lock);
+    schedule_delayed_work(&chip->prox_offset_cal_work, msecs_to_jiffies(0));
+    mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_gesture_offset_cal_start_store(struct device *dev, struct device_attribute *attr, 
+                                            const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned int recv;
+    int ret = kstrtouint(buf, 10, &recv);
+    if (ret) 
+    {
+        SENSOR_LOG_ERROR("input error\n");
+        return -EINVAL;
+    }
+
+    mutex_lock(&chip->lock);
+    if (recv)
+    {
+        chip->gesture_offset_cal_start = true;
+        SENSOR_LOG_INFO("enable gesture offset calibrate flag\n");
+    }
+    else
+    {
+        chip->gesture_offset_cal_start = false;
+        SENSOR_LOG_INFO("disable gesture offset calibrate flag\n");
+    }
+    mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_gesture_offset_cal_start_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    SENSOR_LOG_INFO("prox calibrate is %s\n",chip->gesture_offset_cal_start ? "enable" : "disable");
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->gesture_offset_cal_start);
+}
+
+
+static ssize_t tmg399x_gesture_offset_cal_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "N = %d, S = %d, W = %d, E = %d\n",chip->params.ges_offset_n,
+                                                                       chip->params.ges_offset_s,
+                                                                       chip->params.ges_offset_w,
+                                                                       chip->params.ges_offset_e);
+}
+
+static ssize_t tmg399x_gesture_offset_cal_store(struct device *dev, struct device_attribute *attr, 
+                                            const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    int ret = kstrtouint(buf, 10, &(chip->prox_calibrate_times));
+    if (ret) 
+    {
+        SENSOR_LOG_ERROR("input error\n");
+        return -EINVAL;
+    }
+
+    mutex_lock(&chip->lock);
+    schedule_delayed_work(&chip->gesture_offset_cal_work, msecs_to_jiffies(0));
+    mutex_unlock(&chip->lock);
+	return size;
+}
+
+
+static ssize_t tmg399x_phone_is_sleep_store(struct device *dev, struct device_attribute *attr, 
+                                            const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned int recv;
+    int ret = kstrtouint(buf, 10, &recv);
+    if (ret) 
+    {
+        SENSOR_LOG_ERROR("input error\n");
+        return -EINVAL;
+    }
+
+    mutex_lock(&chip->lock);
+    if (recv==chip->phone_is_sleep)
+    {
+        SENSOR_LOG_INFO("double %s phone_is_sleep\n",recv? "enable" : "false");
+    }
+    else
+    {        
+        chip->phone_is_sleep = recv;
+        SENSOR_LOG_INFO("success %s phone_is_sleep\n",recv? "enable" : "false");
+    }
+    mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_phone_is_sleep_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    SENSOR_LOG_INFO("phone_is_sleep is %s\n",chip->phone_is_sleep? "true" : "false");
+	return snprintf(buf, PAGE_SIZE, "phone_is_sleep %s\n\n", chip->phone_is_sleep? "true" : "false");
+}
+
+static ssize_t tmg399x_prox_wakelock_store(struct device *dev, struct device_attribute *attr, 
+                                            const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned int recv;
+    int ret = kstrtouint(buf, 10, &recv);
+    if (ret) 
+    {
+        SENSOR_LOG_ERROR("input error\n");
+        return -EINVAL;
+    }
+
+    mutex_lock(&chip->lock);
+    if (recv)
+    {
+        tmg399x_wakelock_ops(&(chip->proximity_wakelock),true);
+    }
+    else
+    {
+        //cancel_delayed_work_sync(&p_global_tmg399x_chip->prox_unwakelock_work);
+        hrtimer_cancel(&p_global_tmg399x_chip->prox_unwakelock_timer);
+        tmg399x_wakelock_ops(&(chip->proximity_wakelock),false);
+    }
+    mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_prox_wakelock_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    SENSOR_LOG_INFO("proximity_wakelock is %s\n",chip->proximity_wakelock.locked ? "true" : "false");
+	return snprintf(buf, PAGE_SIZE, "proximity_wakelock is %s\n",chip->proximity_wakelock.locked ? "true" : "false");
+}
+
+
+static ssize_t tmg399x_lux_table_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	struct lux_segment *s = chip->segment;
+	int i, k;
+
+	for (i = k = 0; i < chip->segment_num; i++)
+		k += snprintf(buf + k, PAGE_SIZE - k,
+				"%d:%d,%d,%d,%d,%d,%d\n", i,
+				s[i].d_factor,
+				s[i].r_coef,
+				s[i].g_coef,
+				s[i].b_coef,
+				s[i].ct_coef,
+				s[i].ct_offset
+				);
+	return k;
+}
+
+static ssize_t tmg399x_lux_table_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	int i;
+	u32 d_factor, r_coef, g_coef, b_coef, ct_coef, ct_offset;
+
+	if (7 != sscanf(buf, "%10d:%10d,%10d,%10d,%10d,%10d,%10d",
+		&i, &d_factor, &r_coef, &g_coef, &b_coef, &ct_coef, &ct_offset))
+		return -EINVAL;
+	if (i >= chip->segment_num)
+		return -EINVAL;
+	mutex_lock(&chip->lock);
+	chip->segment[i].d_factor = d_factor;
+	chip->segment[i].r_coef = r_coef;
+	chip->segment[i].g_coef = g_coef;
+	chip->segment[i].b_coef = b_coef;
+	chip->segment[i].ct_coef = ct_coef;
+	chip->segment[i].ct_offset = ct_offset;
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_als_deltaP_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE,
+			"%d (in %%)\n", chip->params.als_deltaP);
+}
+
+static ssize_t tmg399x_als_deltaP_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	unsigned long deltaP;
+	int ret;
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+
+	ret = kstrtoul(buf, 10, &deltaP);
+	if (ret || deltaP > 100) 
+    {
+		return -EINVAL;
+    }
+	mutex_lock(&chip->lock);
+	chip->params.als_deltaP = deltaP;
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_auto_gain_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%s\n",
+				chip->als_gain_auto ? "auto" : "manual");
+}
+
+static ssize_t tmg399x_auto_gain_enable_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	bool value;
+
+	if (strtobool(buf, &value))
+		return -EINVAL;
+	mutex_lock(&chip->lock);
+
+	if (value)
+		chip->als_gain_auto = true;
+	else
+		chip->als_gain_auto = false;
+
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_device_als_lux(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	mutex_lock(&chip->lock);
+	tmg399x_get_als(chip);
+	tmg399x_get_lux(chip);
+	mutex_unlock(&chip->lock);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_inf.lux);
+}
+
+static ssize_t tmg399x_als_red_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+		{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_inf.red_raw);
+}
+
+static ssize_t tmg399x_als_green_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_inf.green_raw);
+}
+
+static ssize_t tmg399x_als_blue_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_inf.blue_raw);
+}
+
+static ssize_t tmg399x_als_clear_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_inf.clear_raw);
+}
+
+static ssize_t tmg399x_als_cct_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	mutex_lock(&chip->lock);
+	tmg399x_read_all(chip);
+	tmg399x_get_als(chip);
+	tmg399x_get_lux(chip);
+	mutex_unlock(&chip->lock);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_inf.cct);
+}
+
+
+
+static ssize_t tmg399x_set_reg_addr(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    reg_addr = val;
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t tmg399x_get_reg_addr(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+   
+    SENSOR_LOG_ERROR("enter\n");
+    SENSOR_LOG_ERROR("reg_addr = 0x%02X\n",reg_addr);
+	return strlen(buf);
+    SENSOR_LOG_ERROR("exit\n");
+
+}
+
+
+static ssize_t tmg399x_set_reg_data(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    mutex_lock(&p_global_tmg399x_chip->lock);
+
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (100==reg_addr)
+    {
+        SENSOR_LOG_ERROR("reg addr error!\n");
+    }
+    else
+    {
+        if ((ret = (i2c_smbus_write_byte_data(p_global_tmg399x_chip->client, reg_addr, val))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write reg\n");
+        }   
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+    mutex_unlock(&p_global_tmg399x_chip->lock);
+
+	return size;
+}
+
+
+static ssize_t tmg399x_get_reg_data(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    int i;
+
+    mutex_lock(&p_global_tmg399x_chip->lock);
+
+    if (1 == reg_addr)
+    {
+        for (i=0x80; i<=0xFF; i++)
+        {
+            i2c_smbus_write_byte(p_global_tmg399x_chip->client, i);
+            SENSOR_LOG_ERROR("reg[0x%02X] = 0x%02X",i,i2c_smbus_read_byte(p_global_tmg399x_chip->client));
+        }
+    }   
+    else
+    {
+        i2c_smbus_write_byte(p_global_tmg399x_chip->client, reg_addr);
+        SENSOR_LOG_ERROR("reg[0x%02X] = 0x%02X",reg_addr,i2c_smbus_read_byte(p_global_tmg399x_chip->client)); 
+    }
+
+    mutex_unlock(&p_global_tmg399x_chip->lock);
+
+	return strlen(buf);
+}
+
+
+static ssize_t tmg399x_irq_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    SENSOR_LOG_ERROR("irq_enabled  = %d\n",p_global_tmg399x_chip->irq_enabled );
+	return snprintf(buf, PAGE_SIZE, "irq_enabled  = %d\n",p_global_tmg399x_chip->irq_enabled );
+}
+
+static ssize_t tmg399x_irq_store(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (val)
+    {
+        tmg399x_irq_enable(true, true);
+    }
+    else
+    {
+        tmg399x_irq_enable(false, true);
+    }
+ 
+	return size;
+}
+
+
+static ssize_t tmg399x_irq_clear(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+
+    SENSOR_LOG_ERROR("enter\n");
+
+    mutex_lock(&p_global_tmg399x_chip->lock);
+
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (1==val)
+    {
+        SENSOR_LOG_ERROR("CLEAR ALS INT!\n");
+        tmg399x_irq_clr(p_global_tmg399x_chip, TMG399X_CMD_ALS_INT_CLR);
+    }
+    else
+    {
+        if (2==val)
+        {
+            SENSOR_LOG_ERROR("CLEAR PROX INT!\n");
+            tmg399x_irq_clr(p_global_tmg399x_chip, TMG399X_CMD_PROX_INT_CLR);
+        }
+        else
+        {
+            if (3==val)
+            {
+                SENSOR_LOG_ERROR("CLEAR GESTURE INT!\n");
+                tmg399x_i2c_modify(p_global_tmg399x_chip, TMG399X_GES_CFG_4, TMG399X_GES_INT_CLR, TMG399X_GES_INT_CLR);
+            }
+            else
+            {
+                if (4==val)
+                {
+                    SENSOR_LOG_ERROR("CLEAR ALL INT!\n");
+                    tmg399x_irq_clr(p_global_tmg399x_chip, TMG399X_CMD_NON_GES_INT_CLR);
+                }
+            }
+        }
+    }
+
+    mutex_unlock(&p_global_tmg399x_chip->lock);
+
+    SENSOR_LOG_ERROR("exit\n");
+
+	return size;
+}
+
+
+static ssize_t tmg399x_set_ges_enter_thres(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+
+    SENSOR_LOG_ERROR("enter\n");
+
+    mutex_lock(&p_global_tmg399x_chip->lock);
+
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    tmg399x_data.parameters.ges_entry_th = (val & 0xff);
+	p_global_tmg399x_chip->shadow[TMG399X_GES_ENTH]  = p_global_tmg399x_chip->params.ges_entry_th;
+	tmg399x_i2c_write(p_global_tmg399x_chip, TMG399X_GES_ENTH, p_global_tmg399x_chip->shadow[TMG399X_GES_ENTH]);
+
+    mutex_unlock(&p_global_tmg399x_chip->lock);
+
+    SENSOR_LOG_ERROR("exit\n");
+
+	return size;
+}
+
+
+static ssize_t tmg399x_get_ges_enter_thres(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    SENSOR_LOG_ERROR("enter\n");
+
+    mutex_lock(&p_global_tmg399x_chip->lock);
+    
+    SENSOR_LOG_ERROR("ges_entry_th = %d\n",tmg399x_data.parameters.ges_entry_th);
+
+    mutex_unlock(&p_global_tmg399x_chip->lock);
+
+    SENSOR_LOG_ERROR("exit\n");
+
+	return strlen(buf);
+}
+
+static ssize_t tmg399x_set_ges_exit_thres(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+
+    SENSOR_LOG_ERROR("enter\n");
+
+    mutex_lock(&p_global_tmg399x_chip->lock);
+
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    tmg399x_data.parameters.ges_exit_th = (val & 0xff);
+	p_global_tmg399x_chip->shadow[TMG399X_GES_EXTH]  = p_global_tmg399x_chip->params.ges_exit_th;
+	tmg399x_i2c_write(p_global_tmg399x_chip, TMG399X_GES_EXTH, p_global_tmg399x_chip->shadow[TMG399X_GES_EXTH]);
+
+    mutex_unlock(&p_global_tmg399x_chip->lock);
+
+    SENSOR_LOG_ERROR("exit\n");
+
+	return size;
+}
+
+
+static ssize_t tmg399x_get_ges_exit_thres(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    SENSOR_LOG_ERROR("enter\n");
+
+    mutex_lock(&p_global_tmg399x_chip->lock);
+    
+    SENSOR_LOG_ERROR("ges_exit_th = %d\n",tmg399x_data.parameters.ges_exit_th);
+
+    mutex_unlock(&p_global_tmg399x_chip->lock);
+
+    SENSOR_LOG_ERROR("exit\n");
+
+	return strlen(buf);
+}
+
+static ssize_t tmg399x_set_ges_start(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+
+    mutex_lock(&p_global_tmg399x_chip->lock);
+
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (val)
+    {
+        p_global_tmg399x_chip->gesture_start = true;
+    }
+    else
+    {
+        p_global_tmg399x_chip->gesture_start = false;
+    }
+    mutex_unlock(&p_global_tmg399x_chip->lock);
+
+	return size;
+}
+
+static ssize_t tmg399x_prox_threshold_high_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev); 
+
+	if (NULL!=chip)
+    {
+        return sprintf(buf, "%d", chip->params.prox_th_high);
+    }
+    else
+    {       
+        sprintf(buf, "chip->params.prox_th_high is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t tmg399x_prox_threshold_high_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	static long value;
+	int rc;
+
+	rc = kstrtol(buf, 10, &value);
+	if (rc)
+		return -EINVAL;
+
+    chip->params.prox_th_high = (u8)(value&0xff);
+
+	mutex_lock(&chip->lock);
+	chip->shadow[TMG399X_PRX_THRES_HIGH] = chip->params.prox_th_high;
+    /*
+	tmg399x_i2c_write(chip, TMG399X_PRX_THRES_HIGH, chip->shadow[TMG399X_PRX_THRES_HIGH]);
+	*/
+    mutex_unlock(&chip->lock);
+
+    SENSOR_LOG_ERROR("prox_th_high = %d\n",chip->params.prox_th_high);
+
+	return size;
+}
+
+
+
+static ssize_t tmg399x_prox_threshold_low_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev); 
+
+	if (NULL!=chip)
+    {
+        return sprintf(buf, "%d", chip->params.prox_th_low);
+    }
+    else
+    {       
+        sprintf(buf, "chip->params.prox_th_low is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t tmg399x_prox_threshold_low_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	static long value;
+	int rc;
+
+	rc = kstrtol(buf, 10, &value);
+	if (rc)
+		return -EINVAL;
+
+    chip->params.prox_th_low = (u8)(value&0xff);
+
+	mutex_lock(&chip->lock);
+	chip->shadow[TMG399X_PRX_THRES_LOW] = chip->params.prox_th_low;
+    /*
+	tmg399x_i2c_write(chip, TMG399X_PRX_THRES_LOW, chip->shadow[TMG399X_PRX_THRES_HIGH]);
+	*/
+    mutex_unlock(&chip->lock);
+
+    SENSOR_LOG_ERROR("prox_th_low = %d\n",chip->params.prox_th_low);
+
+	return size;
+}
+
+static int tmg399x_prox_offset_calculate(int data, int target)
+{
+    int offset;
+
+    if (data > PROX_OFFSET_CAL_THRESHOLD)
+    {
+        return PROX_OFFSET_CAL_ABILITY_MAX;
+    }
+
+    if (data > target)
+    {
+        offset = (data - target) * PROX_OFFSET_CAL_PER_BIT;
+    }
+    else
+    {
+        offset = (target - data) * PROX_OFFSET_CAL_PER_BIT + 128;
+    }
+
+    return offset;
+}
+
+static void tmg399x_prox_offset_cal_prepare(struct tmg399x_chip *chip)
+{
+    if (false == (chip->prx_enabled))
+    {
+       tmg399x_prox_enable(chip, false);
+       mdelay(50);
+       tmg399x_prox_enable(chip, true);
+    }
+    else
+    {        
+       tmg399x_prox_enable(chip, true);
+    }
+
+    chip->shadow[TMG399X_CONTROL] &= ~(TMG399X_EN_PRX_IRQ);
+    tmg399x_update_enable_reg(chip);
+
+    tmg399x_i2c_write(chip, TMG399X_PRX_OFFSET_NE, 0);
+    tmg399x_i2c_write(chip, TMG399X_PRX_OFFSET_SW, 0);
+}
+
+static int tmg399x_prox_uncover_data_get(struct tmg399x_chip *chip)
+{
+    int prox_sum = 0;
+    u8  i = 0;
+    u8  j = 0;
+    int ret = 0;
+ 
+    //set to get all chanel prox data
+    tmg399x_i2c_write(chip, TMG399X_CONFIG_3, 0x00);
+    mdelay(50);
+    for (i = 0; i < PROX_OFFSET_CAL_BUFFER_SIZE/5; i++) 
+    {
+       tmg399x_read_prox_data(chip);
+       if (chip->shadow[TMG399X_PRX_CHAN] > 0)
+       {
+           prox_sum += chip->shadow[TMG399X_PRX_CHAN];
+           j++;
+       }
+
+       SENSOR_LOG_ERROR("prox data = %d\n",chip->shadow[TMG399X_PRX_CHAN]);
+       mdelay(PROX_OFFSET_CAL_GETDATA_DELAY);
+    }
+   
+    if (0==j)
+    {
+        ret = -1;
+        goto prox_uncover_data_get_error;
+    }
+
+    chip->prox_uncover_data = prox_sum / j;
+    chip->prox_thres_hi_min = chip->prox_uncover_data + PROX_THRESHOLD_SAFE_DISTANCE + PROX_THRESHOLD_DISTANCE;
+    SENSOR_LOG_ERROR("prox_uncover_data = %d, prox_thres_hi_min = %d\n",chip->prox_uncover_data,chip->prox_thres_hi_min);    
+    tmg399x_write_cal_file(PATH_PROX_UNCOVER_DATA, chip->prox_uncover_data);
+
+    return 0;
+ 
+prox_uncover_data_get_error:
+    return ret;
+}
+
+static int tmg399x_prox_offset_cal_ne_process(struct tmg399x_chip *chip)
+{
+    int prox_sum = 0;
+    int prox_mean = 0;
+    u8  i = 0;
+    u8  j = 0;
+    int ret = 0;
+    int prox_offset_ne = 0;
+    
+    //cal prox NE chanel
+    tmg399x_i2c_write(chip, TMG399X_CONFIG_3, 0x06);
+    mdelay(50);
+    for (i = 0; i < PROX_OFFSET_CAL_BUFFER_SIZE; i++) 
+    {
+       tmg399x_read_prox_data(chip);
+       if (chip->shadow[TMG399X_PRX_CHAN] > 0)
+       {
+           prox_sum += chip->shadow[TMG399X_PRX_CHAN];
+           j++;
+       }
+
+       SENSOR_LOG_ERROR("prox data NE = %d\n",chip->shadow[TMG399X_PRX_CHAN]);
+       mdelay(PROX_OFFSET_CAL_GETDATA_DELAY);
+    }
+    
+    if (0==j)
+    {
+        ret = -1;
+        goto prox_offset_cal_ne_buffer_error;
+    }
+
+    prox_mean = prox_sum / j;
+    SENSOR_LOG_ERROR("prox data ne mean = %d\n",prox_mean);
+    prox_offset_ne = tmg399x_prox_offset_calculate(prox_mean, PROX_DATA_TARGET);
+
+    ret = tmg399x_i2c_write(chip, TMG399X_PRX_OFFSET_NE, prox_offset_ne);
+    if (!ret)
+    {
+       chip->params.prox_offset_ne = prox_offset_ne;
+       chip->shadow[TMG399X_PRX_OFFSET_NE] = prox_offset_ne;
+       SENSOR_LOG_ERROR("prox offset NE = %d\n",chip->params.prox_offset_ne);
+       tmg399x_write_cal_file(PATH_PROX_OFFSET_NE, prox_offset_ne);
+    }
+
+    return 0;
+    
+prox_offset_cal_ne_buffer_error:
+    return ret;
+}
+
+static int tmg399x_prox_offset_cal_sw_process(struct tmg399x_chip *chip)
+{
+    int prox_sum = 0;
+    int prox_mean = 0;
+    u8  i = 0;
+    u8  j = 0;
+    int ret = 0;
+    int prox_offset_sw = 0;
+  
+    //cal prox SW chanel
+    tmg399x_i2c_write(chip, TMG399X_CONFIG_3, 0x09);
+    mdelay(50);
+    for (i = 0; i < PROX_OFFSET_CAL_BUFFER_SIZE; i++) 
+    {
+        tmg399x_read_prox_data(chip);   
+
+        if (chip->shadow[TMG399X_PRX_CHAN]>0)
+        {
+            prox_sum += chip->shadow[TMG399X_PRX_CHAN];
+            j++;
+        }
+
+        SENSOR_LOG_ERROR("prox data SW = %d\n",chip->shadow[TMG399X_PRX_CHAN]);
+        mdelay(PROX_OFFSET_CAL_GETDATA_DELAY);
+    }
+
+    if (0==j)
+    {
+        goto prox_offset_cal_sw_buffer_error;
+    }
+
+    prox_mean = prox_sum / j;
+    SENSOR_LOG_ERROR("prox data sw mean = %d\n",prox_mean);
+    prox_offset_sw = tmg399x_prox_offset_calculate(prox_mean, PROX_DATA_TARGET);
+
+	ret = tmg399x_i2c_write(chip, TMG399X_PRX_OFFSET_SW, prox_offset_sw);
+	if (!ret) 
+    {
+		chip->params.prox_offset_sw = prox_offset_sw;
+		chip->shadow[TMG399X_PRX_OFFSET_SW] = prox_offset_sw;
+        SENSOR_LOG_ERROR("prox offset SW = %d\n",chip->params.prox_offset_sw);
+        tmg399x_write_cal_file(PATH_PROX_OFFSET_SW, prox_offset_sw);
+	}
+
+    return 0;
+
+prox_offset_cal_sw_buffer_error:
+    return ret;
+}
+
+static int tmg399x_prox_offset_cal_process(struct tmg399x_chip *chip)
+{
+    int ret;
+    
+    ret = tmg399x_prox_offset_cal_ne_process(chip);
+    if (ret<0)
+    {
+        SENSOR_LOG_ERROR("prox cal ne channel failed\n");
+        goto tmg399x_prox_offset_cal_process_failed;
+    }
+    else
+    {
+        SENSOR_LOG_INFO("prox cal ne channel success\n");
+    }
+
+    ret = tmg399x_prox_offset_cal_sw_process(chip);
+    if (ret<0)
+    {
+        SENSOR_LOG_ERROR("prox cal sw channel failed\n");
+        goto tmg399x_prox_offset_cal_process_failed;
+    }
+    else
+    {
+        SENSOR_LOG_INFO("prox cal sw channel success\n");
+    }
+
+    ret = tmg399x_prox_uncover_data_get(chip);
+    if (ret<0)
+    {
+        SENSOR_LOG_ERROR("prox_uncover_data get failed\n");
+        goto tmg399x_prox_offset_cal_process_failed;
+    }
+    else
+    {
+        SENSOR_LOG_INFO("prox_uncover_data get success\n");
+    }
+
+    return 0;
+
+tmg399x_prox_offset_cal_process_failed:
+    return ret;
+}
+
+static void tmg399x_prox_offset_cal_finish(struct tmg399x_chip *chip)
+{
+    tmg399x_i2c_write(chip, TMG399X_CONFIG_3, 0x00);
+
+    if (true == (chip->prx_enabled))
+    {
+        tmg399x_prox_enable(chip, true);
+    }
+    else
+    {
+        tmg399x_prox_enable(chip, false);
+    }
+}
+
+static int tmg399x_prox_offset_cal(struct tmg399x_chip *chip)
+{
+    int ret = 0;
+    chip->prox_offset_cal_result = false;
+
+    tmg399x_prox_offset_cal_prepare(chip);
+
+    mdelay(50);
+
+    ret = tmg399x_prox_offset_cal_process(chip);
+    
+    if (ret>=0)
+    {
+        chip->gesture_offset_cal_result = true;
+    }
+
+    tmg399x_prox_offset_cal_finish(chip);
+    
+    return ret;
+}
+
+static int tmg399x_gesture_offset_calculate(int data, int target)
+{
+    int offset;
+
+    if (data > GESTURE_OFFSET_CAL_THRESHOLD)
+    {
+        return GESTURE_OFFSET_CAL_ABILITY_MAX;
+    }
+
+    if (data > target)
+    {
+        offset = (data - target) * GESTURE_OFFSET_CAL_PER_BIT;
+    }
+    else
+    {
+        offset = (target - data) * GESTURE_OFFSET_CAL_PER_BIT + 128;
+    }
+
+    return offset;
+}
+
+
+static void tmg399x_gesture_offset_cal_prepare(struct tmg399x_chip *chip)
+{
+    if (false == (chip->ges_enabled))
+    {
+        tmg399x_ges_enable(chip, false);
+        mdelay(50);
+        tmg399x_ges_enable(chip, true);
+    }
+    else
+    {   
+        tmg399x_ges_enable(chip, true);
+    }
+
+    chip->light_poll_time = AMS_ALS_POLL_DELAY_SLOW;
+    tmg399x_als_atime_set(AMS_ALS_ATIME_SHORT);
+    chip->shadow[TMG399X_GES_CFG_4] &= (~(TMG399X_GES_EN_IRQ));
+    tmg399x_update_enable_reg(chip);
+
+    tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_N, 0);
+    tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_S, 0);
+    tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_W, 0);
+    tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_E, 0);
+}
+
+static int tmg399x_gesture_offset_cal_process(struct tmg399x_chip *chip)
+{
+    int gesture_sum_n = 0;
+    int gesture_sum_s = 0;
+    int gesture_sum_w = 0;
+    int gesture_sum_e = 0;
+
+    int gesture_mean_n = 0;
+    int gesture_mean_s = 0;
+    int gesture_mean_w = 0;
+    int gesture_mean_e = 0;
+
+    int gesture_offset_n = 0;
+    int gesture_offset_s = 0;
+    int gesture_offset_w = 0;
+    int gesture_offset_e = 0;
+
+    u8  i = 0;
+    u8  j = 0;
+    int ret = 0; 
+   
+    for (i = 0; i < GESTURE_OFFSET_CAL_BUFFER_SIZE; i++) 
+    {
+        ret = tmg399x_get_ges(chip);
+        if (((chip->gesture_data[0].north>0)&&(chip->gesture_data[0].north<=255))&&
+            ((chip->gesture_data[0].south>0)&&(chip->gesture_data[0].south<=255))&&
+            ((chip->gesture_data[0].west>0)&&(chip->gesture_data[0].west<=255))&&
+            ((chip->gesture_data[0].east>0)&&(chip->gesture_data[0].east<=255))) 
+        {
+            gesture_sum_n += chip->gesture_data[0].north;
+            gesture_sum_s += chip->gesture_data[0].south;
+            gesture_sum_w += chip->gesture_data[0].west;
+            gesture_sum_e += chip->gesture_data[0].east;
+            j++;
+        }
+
+        SENSOR_LOG_ERROR("gesture data N=%d,S=%d,W=%d,E=%d\n",chip->gesture_data[0].north,
+                                                              chip->gesture_data[0].south,
+                                                              chip->gesture_data[0].west,
+                                                              chip->gesture_data[0].east);
+
+        mdelay(GESTURE_OFFSET_CAL_GETDATA_DELAY);
+    }
+    
+    if (0==j)
+    {
+        ret = -1;
+        goto gesture_offset_cal_failed;
+    }
+
+    gesture_mean_n = gesture_sum_n / j;
+    gesture_mean_s = gesture_sum_s / j;
+    gesture_mean_w = gesture_sum_w / j;
+    gesture_mean_e = gesture_sum_e / j;
+
+    SENSOR_LOG_ERROR("gesture_mean_n = %d\n", gesture_mean_n);
+    SENSOR_LOG_ERROR("gesture_mean_s = %d\n", gesture_mean_s);
+    SENSOR_LOG_ERROR("gesture_mean_w = %d\n", gesture_mean_w);
+    SENSOR_LOG_ERROR("gesture_mean_e = %d\n", gesture_mean_e);
+
+    gesture_offset_n = tmg399x_gesture_offset_calculate(gesture_mean_n, GESTURE_DATA_TARGET);
+    gesture_offset_s = tmg399x_gesture_offset_calculate(gesture_mean_s, GESTURE_DATA_TARGET);
+    gesture_offset_w = tmg399x_gesture_offset_calculate(gesture_mean_w, GESTURE_DATA_TARGET);
+    gesture_offset_e = tmg399x_gesture_offset_calculate(gesture_mean_e, GESTURE_DATA_TARGET);
+
+    chip->params.ges_offset_n = gesture_offset_n;
+    chip->pdata->parameters.ges_offset_n = gesture_offset_n;
+    chip->shadow[TMG399X_GES_OFFSET_N] = gesture_offset_n;
+
+    chip->params.ges_offset_s = gesture_offset_s;
+    chip->pdata->parameters.ges_offset_s = gesture_offset_s;
+    chip->shadow[TMG399X_GES_OFFSET_S] = gesture_offset_s;
+
+    chip->params.ges_offset_w = gesture_offset_w;
+    chip->pdata->parameters.ges_offset_w = gesture_offset_w;
+    chip->shadow[TMG399X_GES_OFFSET_W] = gesture_offset_w;
+
+    chip->params.ges_offset_e = gesture_offset_e;
+    chip->pdata->parameters.ges_offset_e = gesture_offset_e;
+    chip->shadow[TMG399X_GES_OFFSET_E] = gesture_offset_e;
+
+    tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_N, (u8)(gesture_offset_n & 0xff));
+    tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_S, (u8)(gesture_offset_s & 0xff));
+    tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_W, (u8)(gesture_offset_w & 0xff));
+    tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_E, (u8)(gesture_offset_e & 0xff));
+
+    SENSOR_LOG_ERROR("Set N offset = %d\n", gesture_offset_n);
+    SENSOR_LOG_ERROR("Set S offset = %d\n", gesture_offset_s);
+    SENSOR_LOG_ERROR("Set W offset = %d\n", gesture_offset_w);
+    SENSOR_LOG_ERROR("Set E offset = %d\n", gesture_offset_e);
+
+    tmg399x_write_cal_file(PATH_GESTURE_OFFSET_N, (u8)(gesture_offset_n & 0xff));
+    tmg399x_write_cal_file(PATH_GESTURE_OFFSET_S, (u8)(gesture_offset_s & 0xff));
+    tmg399x_write_cal_file(PATH_GESTURE_OFFSET_W, (u8)(gesture_offset_w & 0xff));
+    tmg399x_write_cal_file(PATH_GESTURE_OFFSET_E, (u8)(gesture_offset_e & 0xff));
+
+    return 0;
+
+gesture_offset_cal_failed:
+    return ret;
+}
+
+static void tmg399x_gesture_offset_cal_finish(struct tmg399x_chip *chip)
+{
+    if (true == (chip->ges_enabled))
+    {
+        tmg399x_ges_enable(chip, false);
+        tmg399x_ges_enable(chip, true);
+    }
+    else
+    {   
+        tmg399x_ges_enable(chip, false);
+    }
+}
+
+static int tmg399x_gesture_offset_cal(struct tmg399x_chip *chip)
+{
+    int ret = 0;
+    chip->gesture_offset_cal_result = false;
+
+    tmg399x_gesture_offset_cal_prepare(chip);
+    
+    mdelay(50);
+
+    ret = tmg399x_gesture_offset_cal_process(chip);
+
+    if (ret>=0)
+    {
+        chip->gesture_offset_cal_result = true;
+    }
+
+    tmg399x_gesture_offset_cal_finish(chip);
+    
+    return ret;
+}
+
+
+
+static struct device_attribute attrs_prox[] = {
+    __ATTR(chip_name,                       0640,   tmg399x_chip_name_show,                 NULL), 
+	__ATTR(enable,                          0640,   tmg399x_prox_enable_show,               tmg399x_prox_enable_store),
+    __ATTR(prox_init,                       0640,   NULL,                                   tmg399x_prox_init_store),
+	__ATTR(prox_threshold_init,             0640,   NULL,                                   tmg399x_prox_threshold_init_store),
+    __ATTR(prox_offset_init,                0640,   NULL,                                   tmg399x_prox_offset_init_store),
+	__ATTR(prox_persist,                    0640,   tmg399x_prox_persist_show,              tmg399x_prox_persist_store),
+	__ATTR(prx_pulse_length,                0640,   tmg399x_prox_pulse_len_show,            tmg399x_prox_pulse_len_store),
+	__ATTR(prox_pulse_count,                0640,   tmg399x_prox_pulse_cnt_show,	        tmg399x_prox_pulse_cnt_store),
+	__ATTR(prox_gain,                       0640,   tmg399x_prox_gain_show,	                tmg399x_prox_gain_store),
+	__ATTR(prox_led_drive,                  0640,   tmg399x_prox_led_drive_show,            tmg399x_prox_led_drive_store),
+	__ATTR(prox_led_boost,                  0640,   tmg399x_led_boost_show,	                tmg399x_led_boost_store),
+	__ATTR(prox_sat_irq_en,                 0640,   tmg399x_sat_irq_en_show,                tmg399x_sat_irq_en_store),
+	__ATTR(prox_offset_ne,                  0640,   tmg399x_prox_offset_ne_show,            tmg399x_prox_offset_ne_store),
+	__ATTR(prox_offset_sw,                  0640,   tmg399x_prox_offset_sw_show,            tmg399x_prox_offset_sw_store),
+	__ATTR(prox_mask,                       0640,   tmg399x_prox_mask_show,                 tmg399x_prox_mask_store),
+	__ATTR(prox_data,                       0640,   tmg399x_prox_data_show,                 NULL),
+	__ATTR(prox_detect,                     0640,   tmg399x_prox_detected_show,             NULL),
+    __ATTR(prox_calibrate,                  0640,   NULL,                                   tmg399x_prox_calibrate_store), 
+    __ATTR(prox_threshold_cal_start,        0640,   tmg399x_prox_threshold_cal_start_show,  tmg399x_prox_threshold_cal_start_store),
+    __ATTR(prox_calibrate_start,            0640,   tmg399x_prox_threshold_cal_start_show,  tmg399x_prox_threshold_cal_start_store),
+    __ATTR(prox_offset_cal_start,           0640,   tmg399x_prox_offset_cal_start_show,     tmg399x_prox_offset_cal_start_store),
+    __ATTR(prox_offset_cal,                 0640,   tmg399x_prox_offset_cal_show,           tmg399x_prox_offset_cal_store),
+    __ATTR(prox_calibrate_result,           0640,   tmg399x_prox_calibrate_result_show,     NULL), 
+    __ATTR(prox_thres,                      0640,   tmg399x_prox_thres_show,                tmg399x_prox_thres_store),
+    __ATTR(prox_debug,                      0640,   tmg399x_prox_debug_show,                tmg399x_prox_debug_store),
+    __ATTR(prox_phone_is_sleep,             0640,   tmg399x_phone_is_sleep_show,            tmg399x_phone_is_sleep_store),
+    __ATTR(prox_wakelock,                   0640,   tmg399x_prox_wakelock_show,             tmg399x_prox_wakelock_store),
+    __ATTR(prox_thres_max,                  0644,   tmg399x_prox_thres_hi_max,              NULL), 
+    __ATTR(prox_thres_min,                  0644,   tmg399x_prox_thres_hi_min,              NULL),
+    __ATTR(prox_data_safe_range_max,        0644,   tmg399x_prox_data_safa_range_max_show,  tmg399x_prox_data_safa_range_max_store), 
+    __ATTR(prox_data_safe_range_min,        0644,   tmg399x_prox_data_safa_range_min_show,  tmg399x_prox_data_safa_range_min_store), 
+    __ATTR(prox_data_max,                   0640,   tmg399x_prox_data_max_show,             tmg399x_prox_data_max_store),
+    __ATTR(prox_manual_calibrate_threshold, 0644,   tmg399x_manual_calibrate_threshold,     NULL), 
+    __ATTR(tmg_irq,                         0640,   tmg399x_irq_show,                       tmg399x_irq_store),
+    __ATTR(tmg_reg_addr,                    0640,   tmg399x_get_reg_addr,                   tmg399x_set_reg_addr),
+    __ATTR(tmg_reg_data,                    0640,   tmg399x_get_reg_data,                   tmg399x_set_reg_data),
+    __ATTR(tmg_clear_irq,                   0640,   NULL,                                   tmg399x_irq_clear),
+    __ATTR(prox_threshold_high,             0644,   tmg399x_prox_threshold_high_show,       tmg399x_prox_threshold_high_store),
+    __ATTR(prox_threshold_low,              0644,   tmg399x_prox_threshold_low_show,        tmg399x_prox_threshold_low_store),
+};
+
+
+static struct device_attribute attrs_gesture[] = {
+    __ATTR(chip_name,                   0640,   tmg399x_chip_name_show,                     NULL),
+	__ATTR(enable,                      0640,   tmg399x_ges_enable_show,                    tmg399x_ges_enable_store),
+    __ATTR(gesture_offset_init,         0640,   NULL,                                       tmg399x_gesture_offset_init_store),
+	__ATTR(gesture_pulse_length,        0640,   tmg399x_ges_pulse_len_show,                 tmg399x_ges_pulse_len_store),
+	__ATTR(gesture_pulse_count,         0640,   tmg399x_ges_pulse_cnt_show,	                tmg399x_ges_pulse_cnt_store),
+	__ATTR(gesture_gain,                0640,   tmg399x_ges_gain_show,	                    tmg399x_ges_gain_store),
+    __ATTR(gesture_data,                0640,   tmg399x_gesture_data_show,                  tmg399x_gesture_data_store),
+    __ATTR(gesture_offset,              0640,   tmg399x_gesture_offset_show,                tmg399x_gesture_offset_store),
+    __ATTR(gesture_channel_data_max,    0640,   tmg399x_gesture_channel_data_max_show,      tmg399x_gesture_channel_data_max_store),
+    __ATTR(gesture_data_safe_range_max, 0640,   tmg399x_gesture_data_safe_range_max_show,   tmg399x_gesture_data_safe_range_max_store),
+    __ATTR(gesture_data_safe_range_min, 0640,   tmg399x_gesture_data_safe_range_min_show,   tmg399x_gesture_data_safe_range_min_store),
+    __ATTR(gesture_offset_cal,          0640,   tmg399x_gesture_offset_cal_show,            tmg399x_gesture_offset_cal_store),
+    __ATTR(gesture_offset_cal_start,    0640,   tmg399x_gesture_offset_cal_start_show,      tmg399x_gesture_offset_cal_start_store),
+    __ATTR(gesture_enter_thres,         0640,   tmg399x_get_ges_enter_thres,                tmg399x_set_ges_enter_thres),
+    __ATTR(gesture_exit_thres,          0640,   tmg399x_get_ges_exit_thres,                 tmg399x_set_ges_exit_thres),
+    __ATTR(gesture_start_flag,          0640,   NULL,                                       tmg399x_set_ges_start),
+    __ATTR(gesture_debug,               0640,   tmg399x_ges_debug_show,                     tmg399x_ges_debug_store),
+    __ATTR(led_boost,                   0640,   tmg399x_led_boost_show,                     tmg399x_led_boost_store),
+    __ATTR(reg_addr,                    0640,   tmg399x_get_reg_addr,                       tmg399x_set_reg_addr),
+    __ATTR(reg_data,                    0640,   tmg399x_get_reg_data,                       tmg399x_set_reg_data),
+    __ATTR(clear_irq,                   0640,   NULL,                                       tmg399x_irq_clear),
+};
+
+
+static struct device_attribute attrs_light[] = {
+    __ATTR(chip_name,               0640,   tmg399x_chip_name_show,              NULL), 
+	__ATTR(enable,                  0640,   tmg399x_als_enable_show,             tmg399x_als_enable_store),
+    __ATTR(delay,                   0640,   tmg399x_als_poll_time_show,          tmg399x_als_poll_time_store),
+	__ATTR(light_wait_time_en,      0640,   tmg399x_wait_enable_show,            tmg399x_wait_enable_store),
+	__ATTR(light_Itime,             0640,   tmg399x_als_itime_show,              tmg399x_als_itime_store),
+	__ATTR(light_wait_time,         0640,   tmg399x_wait_time_show,              tmg399x_wait_time_store),
+	__ATTR(light_persist,           0640,   tmg399x_als_persist_show,            tmg399x_als_persist_store),
+	__ATTR(light_light_gain,        0640,   tmg399x_als_gain_show,               tmg399x_als_gain_store),
+	__ATTR(light_lux_table,         0640,   tmg399x_lux_table_show,              tmg399x_lux_table_store),
+	__ATTR(light_thresh_deltaP,     0640,   tmg399x_als_deltaP_show,             tmg399x_als_deltaP_store),
+	__ATTR(light_auto_gain,         0640,   tmg399x_auto_gain_enable_show,       tmg399x_auto_gain_enable_store),
+	__ATTR(light_lux,               0640,   tmg399x_device_als_lux,              NULL),
+	__ATTR(light_red,               0640,   tmg399x_als_red_show,                NULL),
+	__ATTR(light_green,             0640,   tmg399x_als_green_show,              NULL),
+	__ATTR(light_blue,              0640,   tmg399x_als_blue_show,               NULL),
+	__ATTR(light_clear,             0640,   tmg399x_als_clear_show,              NULL),
+	__ATTR(light_cct,               0640,   tmg399x_als_cct_show,                NULL),
+    __ATTR(light_debug,             0640,   tmg399x_light_debug_show,            tmg399x_light_debug_store),
+};
+
+int tmg399x_read_cal_value(char *file_path)
+{
+    struct file *file_p;
+    int vfs_read_retval = 0;
+    mm_segment_t old_fs; 
+    char read_buf[32];
+    unsigned short read_value;
+
+    if (NULL==file_path)
+    {
+        SENSOR_LOG_ERROR("file_path is NULL\n");
+        goto error;
+    }
+
+    memset(read_buf, 0, 32);
+
+    file_p = filp_open(file_path, O_RDONLY , 0);
+    if (IS_ERR(file_p))
+    {
+        SENSOR_LOG_ERROR("[open file <%s>failed]\n",file_path);
+        goto error;
+    }
+
+    old_fs = get_fs();
+    set_fs(KERNEL_DS);
+    
+    vfs_read_retval = vfs_read(file_p, (char*)read_buf, 16, &file_p->f_pos);
+    if (vfs_read_retval < 0)
+    {
+        SENSOR_LOG_ERROR("[read file <%s>failed]\n",file_path);
+        goto error;
+    }
+
+    set_fs(old_fs);
+    filp_close(file_p, NULL);
+
+    if (kstrtou16(read_buf, 10, &read_value) < 0)
+    {
+        SENSOR_LOG_ERROR("[kstrtou16 %s failed]\n",read_buf);
+        goto error;
+    }
+    
+    SENSOR_LOG_ERROR("[the content of %s is %s]\n", file_path, read_buf);
+
+    return read_value;
+
+error:
+    return -1;
+}
+
+int tmg399x_write_cal_file(char *file_path,unsigned int value)
+{
+    struct file *file_p;
+    char write_buf[10];
+	 mm_segment_t old_fs; 
+    int vfs_write_retval=0;
+    if (NULL==file_path)
+    {
+        SENSOR_LOG_ERROR("file_path is NULL\n");
+    }
+    memset(write_buf, 0, sizeof(write_buf));
+    sprintf(write_buf, "%d\n", value);
+    file_p = filp_open(file_path, O_CREAT|O_RDWR , 0665);
+    if (IS_ERR(file_p))
+    {
+        SENSOR_LOG_ERROR("[open file <%s>failed]\n",file_path);
+        goto error;
+    }
+    old_fs = get_fs();
+    set_fs(KERNEL_DS);
+    
+    vfs_write_retval = vfs_write(file_p, (char*)write_buf, sizeof(write_buf), &file_p->f_pos);
+    if (vfs_write_retval < 0)
+    {
+        SENSOR_LOG_ERROR("[write file <%s>failed]\n",file_path);
+        goto error;
+    }
+
+    set_fs(old_fs);
+    filp_close(file_p, NULL);
+
+
+    return 1;
+
+error:
+    return -1;
+}
+
+static int create_sysfs_interfaces_prox(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attrs_prox); i++)
+		if (device_create_file(dev, attrs_prox + i))
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attrs_prox + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static int create_sysfs_interfaces_light(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attrs_light); i++)
+		if (device_create_file(dev, attrs_light + i))
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attrs_light + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static int create_sysfs_interfaces_gesture(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attrs_gesture); i++)
+		if (device_create_file(dev, attrs_gesture + i))
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attrs_gesture + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static int tmg399x_check_chip_ready(struct tmg399x_chip *chip)
+{
+	u8 id, rev;
+    return tmg399x_get_id(chip, &id, &rev);
+}
+
+static int tmg399x_wait_chip_ready(struct tmg399x_chip *chip)
+{
+    int i = 0;
+    msleep(50);
+    for (i=1; i<100; i++)
+    {
+        if (tmg399x_check_chip_ready(chip) < 0)
+        {
+            msleep(10);
+        }
+        else
+        {
+            SENSOR_LOG_INFO("retry %d times\n",(i-1));
+            return 0;
+        }
+    }
+
+    SENSOR_LOG_INFO("retry times out \n");
+    return -1;
+}
+
+
+static void tmg399x_input_far_event(struct tmg399x_chip *chip)
+{
+    input_report_rel(chip->p_idev, REL_X, 250);
+    input_sync(chip->p_idev);
+}
+
+static void tmg399x_report_prox(struct tmg399x_chip *chip)
+{
+	if (chip->p_idev) 
+    {
+        if (chip->prox_threshold_cal_start || chip->prox_offset_cal_start)
+        {
+            input_report_rel(chip->p_idev, REL_MISC, chip->prx_inf.raw);
+        }
+        else
+        {
+            input_report_rel(chip->p_idev, REL_X, chip->prx_inf.raw);
+            SENSOR_LOG_INFO("data = %d, high = %d, low = %d",chip->prx_inf.raw,chip->params.prox_th_high, chip->params.prox_th_low);
+        }
+		input_sync(chip->p_idev);
+	}
+}
+
+static int tmg399x_check_and_report(struct tmg399x_chip *chip)
+{   
+	u8 status;
+	
+    tmg399x_i2c_read(chip, TMG399X_STATUS, &chip->shadow[TMG399X_STATUS]);
+	status = chip->shadow[TMG399X_STATUS];
+
+    if (true == chip->prx_enabled)
+    {
+        tmg399x_read_prox_data(chip);
+        if (tmg399x_get_prox(chip))
+        {
+            tmg399x_report_prox(chip);
+        }
+        tmg399x_irq_clr(chip, TMG399X_CMD_PROX_INT_CLR);
+    }
+
+    if ((status & (TMG399X_ST_GES_IRQ)) == (TMG399X_ST_GES_IRQ)) 
+    {
+        atomic_set(&gesture_drdy, 1);
+        wake_up(&gesture_drdy_wq);
+    }
+    
+	return 0;
+}
+
+static void tmg399x_irq_work(struct work_struct *work)
+{
+	struct tmg399x_chip *chip = container_of(work, struct tmg399x_chip, irq_work);
+    mutex_lock(&chip->lock);
+    if (true == chip->wakeup_from_sleep)
+    {        
+        chip->wakeup_from_sleep = false;
+        SENSOR_LOG_INFO(" wakeup_from_sleep = true\n");
+        if (tmg399x_wait_chip_ready(chip) < 0)
+        {
+            tmg399x_input_far_event(chip);
+        }
+    }
+	tmg399x_check_and_report(chip);
+	hrtimer_cancel(&p_global_tmg399x_chip->prox_unwakelock_timer);
+	p_global_tmg399x_chip->irq_work_status = false;
+	//SENSOR_LOG_INFO("########  tmg399x_irq_work enter   hrtimer_start #########\n");
+
+	hrtimer_start(&p_global_tmg399x_chip->prox_unwakelock_timer, ktime_set(3, 0), HRTIMER_MODE_REL);
+
+	//schedule_delayed_work(&p_global_tmg399x_chip->prox_unwakelock_work, msecs_to_jiffies(1000));
+	
+    tmg399x_irq_enable(true, true);
+    mutex_unlock(&chip->lock);
+};
+
+static irqreturn_t tmg399x_irq(int irq, void *handle)
+{
+	struct tmg399x_chip *chip = handle;
+    chip->irq_work_status =true;
+    tmg399x_irq_enable(false, false);
+    if (true == chip->prx_enabled)
+    {
+        tmg399x_wakelock_ops(&(chip->proximity_wakelock),true);
+	}
+    if (0==schedule_work(&chip->irq_work))
+    {
+        SENSOR_LOG_INFO("schedule_work failed!\n");
+    }
+	return IRQ_HANDLED;
+}
+
+static int tmg399x_set_segment_table(struct tmg399x_chip *chip,
+		struct lux_segment *segment, int seg_num)
+{
+	int i;
+	struct device *dev = &chip->client->dev;
+
+	chip->seg_num_max = chip->pdata->segment_num ?
+			chip->pdata->segment_num : ARRAY_SIZE(segment_default);
+
+	if (!chip->segment) 
+    {
+		dev_info(dev, "%s: allocating segment table\n", __func__);
+		chip->segment = kzalloc(sizeof(*chip->segment) *
+				chip->seg_num_max, GFP_KERNEL);
+		if (!chip->segment) {
+			dev_err(dev, "%s: no memory!\n", __func__);
+			return -ENOMEM;
+		}
+	}
+	if (seg_num > chip->seg_num_max) {
+		dev_warn(dev, "%s: %d segment requested, %d applied\n",
+				__func__, seg_num, chip->seg_num_max);
+		chip->segment_num = chip->seg_num_max;
+	} else {
+		chip->segment_num = seg_num;
+	}
+	memcpy(chip->segment, segment,
+			chip->segment_num * sizeof(*chip->segment));
+	dev_info(dev, "%s: %d segment requested, %d applied\n", __func__,
+			seg_num, chip->seg_num_max);
+	for (i = 0; i < chip->segment_num; i++)
+		dev_info(dev,
+		"seg %d: d_factor %d, r_coef %d, g_coef %d, b_coef %d, ct_coef %d ct_offset %d\n",
+		i, chip->segment[i].d_factor, chip->segment[i].r_coef,
+		chip->segment[i].g_coef, chip->segment[i].b_coef,
+		chip->segment[i].ct_coef, chip->segment[i].ct_offset);
+	return 0;
+}
+
+static void tmg399x_set_defaults(struct tmg399x_chip *chip)
+{
+	struct device *dev = &chip->client->dev;
+
+	if (chip->pdata) {
+		dev_info(dev, "%s: Loading pltform data\n", __func__);
+		chip->params.als_time = chip->pdata->parameters.als_time;
+		chip->params.als_gain = chip->pdata->parameters.als_gain;
+		chip->params.als_deltaP = chip->pdata->parameters.als_deltaP;
+		chip->params.wait_time = chip->pdata->parameters.wait_time;
+		chip->params.prox_th_low = chip->pdata->parameters.prox_th_low;
+		chip->params.prox_th_high = chip->pdata->parameters.prox_th_high;
+		chip->params.persist = chip->pdata->parameters.persist;
+		chip->params.als_prox_cfg1 = chip->pdata->parameters.als_prox_cfg1;
+		chip->params.prox_pulse = chip->pdata->parameters.prox_pulse;
+		chip->params.prox_gain = chip->pdata->parameters.prox_gain;
+		chip->params.ldrive = chip->pdata->parameters.ldrive;
+		chip->params.als_prox_cfg2 = chip->pdata->parameters.als_prox_cfg2;
+		chip->params.prox_offset_ne = chip->pdata->parameters.prox_offset_ne;
+		chip->params.prox_offset_sw = chip->pdata->parameters.prox_offset_sw;
+		chip->params.als_prox_cfg3 = chip->pdata->parameters.als_prox_cfg3;
+	} else {
+		dev_info(dev, "%s: use defaults\n", __func__);
+		chip->params.als_time = param_default.als_time;
+		chip->params.als_gain = param_default.als_gain;
+		chip->params.als_deltaP = param_default.als_deltaP;
+		chip->params.wait_time = param_default.wait_time;
+		chip->params.prox_th_low = param_default.prox_th_low;
+		chip->params.prox_th_high = param_default.prox_th_high;
+		chip->params.persist = param_default.persist;
+		chip->params.als_prox_cfg1 = param_default.als_prox_cfg1;
+		chip->params.prox_pulse = param_default.prox_pulse;
+		chip->params.prox_gain = param_default.prox_gain;
+		chip->params.ldrive = param_default.ldrive;
+		chip->params.als_prox_cfg2 = param_default.als_prox_cfg2;
+		chip->params.prox_offset_ne = param_default.prox_offset_ne;
+		chip->params.prox_offset_sw = param_default.prox_offset_sw;
+		chip->params.als_prox_cfg3 = param_default.als_prox_cfg3;
+	}
+
+	chip->als_gain_auto = true;
+
+	/* Initial proximity threshold */
+	chip->shadow[TMG399X_PRX_THRES_LOW] = 0;//chip->params.prox_th_low;
+	chip->shadow[TMG399X_PRX_THRES_HIGH] = chip->params.prox_th_high;
+	tmg399x_i2c_write(chip, TMG399X_PRX_THRES_LOW, chip->shadow[TMG399X_PRX_THRES_LOW]);
+	tmg399x_i2c_write(chip, TMG399X_PRX_THRES_HIGH, chip->shadow[TMG399X_PRX_THRES_HIGH]);
+			
+	chip->shadow[TMG399X_ALS_TIME]      = chip->params.als_time;
+	chip->shadow[TMG399X_WAIT_TIME]     = chip->params.wait_time;
+	chip->shadow[TMG399X_PERSISTENCE]   = chip->params.persist;
+	chip->shadow[TMG399X_CONFIG_1]      = chip->params.als_prox_cfg1;	
+	chip->shadow[TMG399X_PRX_PULSE]     = chip->params.prox_pulse;
+	chip->shadow[TMG399X_GAIN]          = chip->params.als_gain | chip->params.prox_gain | chip->params.ldrive;
+	chip->shadow[TMG399X_CONFIG_2]      = chip->params.als_prox_cfg2;
+	chip->shadow[TMG399X_PRX_OFFSET_NE] = chip->params.prox_offset_ne;
+	chip->shadow[TMG399X_PRX_OFFSET_SW] = chip->params.prox_offset_sw;
+	chip->shadow[TMG399X_CONFIG_3]      = chip->params.als_prox_cfg3;
+}
+
+static int tmg399x_get_id(struct tmg399x_chip *chip, u8 *id, u8 *rev)
+{
+	int ret;
+	ret = tmg399x_i2c_read(chip, TMG399X_REVID, rev);
+	ret |= tmg399x_i2c_read(chip, TMG399X_CHIPID, id);
+	return ret;
+}
+
+static int tmg399x_add_sysfs_interfaces(struct device *dev,
+	struct device_attribute *a, int size)
+{
+	int i;
+	for (i = 0; i < size; i++)
+		if (device_create_file(dev, a + i))
+			goto undo;
+	return 0;
+undo:
+	for (; i >= 0 ; i--)
+		device_remove_file(dev, a + i);
+	dev_err(dev, "%s: failed to create sysfs interface\n", __func__);
+	return -ENODEV;
+}
+
+static void tmg399x_remove_sysfs_interfaces(struct device *dev,
+	struct device_attribute *a, int size)
+{
+	int i;
+	for (i = 0; i < size; i++)
+		device_remove_file(dev, a + i);
+}
+
+static void tmg399x_als_poll_work_func(struct work_struct *work)
+{
+    int ret = 0;
+    u8 temp = 0;
+
+    if (p_global_tmg399x_chip->gesture_start)
+    {
+        if (true == p_global_tmg399x_chip->als_enabled)
+        {
+    	    schedule_delayed_work(&p_global_tmg399x_chip->als_poll_work, msecs_to_jiffies(p_global_tmg399x_chip->light_poll_time));
+        }
+        return;
+    }
+
+    mutex_lock(&p_global_tmg399x_chip->lock);
+
+    if ((true==p_global_tmg399x_chip->ges_enabled) && (false==p_global_tmg399x_chip->prx_enabled))
+    {
+    
+        ret = tmg399x_i2c_read(p_global_tmg399x_chip, TMG399X_CONTROL, &temp);
+
+        temp &= ~TMG399X_EN_GES;
+	    ret = tmg399x_i2c_write(p_global_tmg399x_chip, TMG399X_CONTROL, temp);
+
+        msleep(10);
+        
+        ret = tmg399x_i2c_read(p_global_tmg399x_chip, TMG399X_CONTROL, &temp);
+
+        temp |= TMG399X_EN_GES;
+	    ret = tmg399x_i2c_write(p_global_tmg399x_chip, TMG399X_CONTROL, temp);
+
+
+	    ret = tmg399x_i2c_read(p_global_tmg399x_chip, TMG399X_GES_CFG_4, &temp);
+	    temp |= 0x01;
+	    ret = tmg399x_i2c_write(p_global_tmg399x_chip, TMG399X_GES_CFG_4, temp);
+    }
+
+	tmg399x_read_rgb_data(p_global_tmg399x_chip);
+    tmg399x_get_als(p_global_tmg399x_chip);
+	tmg399x_get_lux(p_global_tmg399x_chip);
+    if (p_global_tmg399x_chip->light_debug_enable)
+    {
+        SENSOR_LOG_INFO("R = %d, G = %d, B = %d, C = %d, Lux = %d cct = %d",
+                                                                p_global_tmg399x_chip->als_inf.red_raw,
+                                                                p_global_tmg399x_chip->als_inf.green_raw,
+                                                                p_global_tmg399x_chip->als_inf.blue_raw,
+                                                                p_global_tmg399x_chip->als_inf.clear_raw,
+                                                                p_global_tmg399x_chip->als_inf.lux,
+                                                                p_global_tmg399x_chip->als_inf.cct);
+    }
+
+    if (p_global_tmg399x_chip->als_inf.lux>10000)
+    {
+        p_global_tmg399x_chip->als_inf.lux = 10000;
+    }
+    input_report_rel(p_global_tmg399x_chip->a_idev, REL_X, (p_global_tmg399x_chip->als_inf.lux + 1));
+    input_report_rel(p_global_tmg399x_chip->a_idev, REL_Y, p_global_tmg399x_chip->als_inf.cct);
+    input_sync(p_global_tmg399x_chip->a_idev);
+
+    if (true == p_global_tmg399x_chip->als_enabled)
+    {
+	    schedule_delayed_work(&p_global_tmg399x_chip->als_poll_work, msecs_to_jiffies(p_global_tmg399x_chip->light_poll_time));
+    }
+
+    mutex_unlock(&p_global_tmg399x_chip->lock);
+}
+
+static void tmg399x_prox_thres_cal_work_func(struct work_struct *work)
+{
+    tmg399x_prox_calibrate(p_global_tmg399x_chip);
+}
+
+static void tmg399x_prox_offset_cal_work_func(struct work_struct *work)
+{
+    tmg399x_prox_offset_cal(p_global_tmg399x_chip);
+}
+
+
+static void tmg399x_gesture_offset_cal_work_func(struct work_struct *work)
+{
+    tmg399x_gesture_offset_cal(p_global_tmg399x_chip);
+}
+
+static enum hrtimer_restart tmg399x_unwakelock_work_func(struct hrtimer *timer)
+{ 
+
+   SENSOR_LOG_INFO("########  in  tmg399x_prox_unwakelock_timer_func #########\n");
+   if (false == p_global_tmg399x_chip->irq_work_status )
+   tmg399x_wakelock_ops(&(p_global_tmg399x_chip->proximity_wakelock),false);
+
+   return HRTIMER_NORESTART;
+}
+
+
+
+
+static int __devinit tmg399x_probe(struct i2c_client *client, const struct i2c_device_id *idp)
+{
+	int i, ret;
+	u8 id, rev;
+	struct device *dev = &client->dev;
+	static struct tmg399x_chip *chip;
+	struct tmg399x_i2c_platform_data *pdata = &tmg399x_data;
+
+	bool powered = 0;
+    dev->platform_data = &tmg399x_data;
+
+	if (!i2c_check_functionality(client->adapter,
+			I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_err(dev, "%s: i2c smbus byte data unsupported\n", __func__);
+		ret = -EOPNOTSUPP;
+		goto init_failed;
+	}
+	if (!pdata) {
+		dev_err(dev, "%s: platform data required\n", __func__);
+		ret = -EINVAL;
+		goto init_failed;
+	}
+
+	if (!(pdata->prox_name || pdata->als_name) || client->irq < 0) {
+		dev_err(dev, "%s: no reason to run.\n", __func__);
+		ret = -EINVAL;
+		goto init_failed;
+	}
+
+	if (pdata->platform_init) {
+		ret = pdata->platform_init();
+		if (ret)
+			goto init_failed;
+	}
+	if (pdata->platform_power) {
+		ret = pdata->platform_power(dev, POWER_ON);
+		if (ret) {
+			dev_err(dev, "%s: pltf power on failed\n", __func__);
+			goto pon_failed;
+		}
+		powered = true;
+		mdelay(10);
+	}
+	chip = kzalloc(sizeof(struct tmg399x_chip), GFP_KERNEL);
+	if (!chip) {
+		ret = -ENOMEM;
+		goto malloc_failed;
+	}
+
+	chip->client = client;
+	chip->pdata = pdata;
+	i2c_set_clientdata(client, chip);
+
+    tmg399x_chip_data_init(chip);
+
+    tmg399x_parse_dt(chip);
+
+    p_global_tmg399x_chip = chip;
+
+	chip->seg_num_max = chip->pdata->segment_num ?
+			chip->pdata->segment_num : ARRAY_SIZE(segment_default);
+	if (chip->pdata->segment)
+		ret = tmg399x_set_segment_table(chip, chip->pdata->segment,
+			chip->pdata->segment_num);
+	else
+		ret =  tmg399x_set_segment_table(chip, segment_default,
+			ARRAY_SIZE(segment_default));
+	if (ret)
+		goto set_segment_failed;
+
+	ret = tmg399x_get_id(chip, &id, &rev);
+	if (ret < 0)
+		dev_err(&chip->client->dev,
+			"%s: failed to get tmg399x id\n",
+			__func__);
+
+	dev_info(dev, "%s: device id:%02x device rev:%02x\n", __func__,
+				id, rev);
+
+	for (i = 0; i < ARRAY_SIZE(tmg399x_ids); i++) 
+    {
+		if (id == tmg399x_ids[i])
+        {
+            SENSOR_LOG_INFO("id = %d\n",id);
+            if (i>=1)
+            {
+                i = 1;
+            }
+			break;
+        }
+	}
+
+	if (i < ARRAY_SIZE(tmg399x_names)) 
+    {
+		dev_info(dev, "%s: '%s rev. %d' detected\n", __func__, tmg399x_names[i], rev);
+		chip->device_index = i;
+	} 
+    else 
+    {
+		dev_err(dev, "%s: not supported chip id\n", __func__);
+		ret = -EOPNOTSUPP;
+		goto id_failed;
+	}
+
+	mutex_init(&chip->lock);
+    wake_lock_init(&chip->proximity_wakelock.lock, WAKE_LOCK_SUSPEND, (chip->proximity_wakelock).name);
+
+	tmg399x_set_defaults(chip);
+	ret = tmg399x_flush_regs(chip);
+	if (ret)
+		goto flush_regs_failed;
+	if (pdata->platform_power) {
+		pdata->platform_power(dev, POWER_OFF);
+		powered = false;
+		chip->unpowered = true;
+	}
+
+	if (!pdata->prox_name)
+		goto bypass_prox_idev;
+	chip->p_idev = input_allocate_device();
+	if (!chip->p_idev) {
+		dev_err(dev, "%s: no memory for input_dev '%s'\n",
+				__func__, pdata->prox_name);
+		ret = -ENODEV;
+		goto input_p_alloc_failed;
+	}
+	chip->p_idev->name = pdata->prox_name;
+	chip->p_idev->id.bustype = BUS_I2C;
+
+
+    // for prox
+    set_bit(EV_REL,     chip->p_idev->evbit);
+    set_bit(REL_X,      chip->p_idev->relbit);
+    set_bit(REL_Y,      chip->p_idev->relbit);
+    set_bit(REL_Z,      chip->p_idev->relbit);
+    set_bit(REL_MISC,   chip->p_idev->relbit);
+
+    // for ges
+    set_bit(REL_RX,     chip->p_idev->relbit);  //gesture style
+    set_bit(REL_RY,     chip->p_idev->relbit);  //gesture enter time
+    set_bit(REL_RZ,     chip->p_idev->relbit);  //gesture exit time
+    set_bit(REL_HWHEEL, chip->p_idev->relbit);  //gesture enter angle
+    set_bit(REL_DIAL,   chip->p_idev->relbit);  //gesture exit angle
+
+     
+	dev_set_drvdata(&chip->p_idev->dev, chip);
+	ret = input_register_device(chip->p_idev);
+	if (ret) {
+		input_free_device(chip->p_idev);
+		dev_err(dev, "%s: cant register input '%s'\n",
+				__func__, pdata->prox_name);
+		goto input_p_register_failed;
+	}
+   
+	ret = tmg399x_add_sysfs_interfaces(&chip->p_idev->dev,
+			attrs_prox, ARRAY_SIZE(attrs_prox));
+    if (ret)
+		goto input_p_sysfs_failed;
+
+bypass_prox_idev:
+
+	if (!pdata->als_name)
+		goto bypass_als_idev;
+	chip->a_idev = input_allocate_device();
+	if (!chip->a_idev) {
+		dev_err(dev, "%s: no memory for input_dev '%s'\n",
+				__func__, pdata->als_name);
+		ret = -ENODEV;
+		goto input_a_alloc_failed;
+	}
+	chip->a_idev->name = pdata->als_name;
+	chip->a_idev->id.bustype = BUS_I2C;
+
+    set_bit(EV_REL, chip->a_idev->evbit);
+    set_bit(REL_X,  chip->a_idev->relbit);
+    set_bit(REL_Y,  chip->a_idev->relbit);
+
+	dev_set_drvdata(&chip->a_idev->dev, chip);
+	ret = input_register_device(chip->a_idev);
+	if (ret) {
+		input_free_device(chip->a_idev);
+		dev_err(dev, "%s: cant register input '%s'\n",
+				__func__, pdata->prox_name);
+		goto input_a_register_failed;
+	}
+	ret = tmg399x_add_sysfs_interfaces(&chip->a_idev->dev,
+			attrs_light, ARRAY_SIZE(attrs_light));
+	if (ret)
+		goto input_a_sysfs_failed;
+
+bypass_als_idev:
+
+	if (!pdata->ges_name)
+		goto bypass_ges_idev;
+	chip->g_idev = input_allocate_device();
+	if (!chip->g_idev) {
+		dev_err(dev, "%s: no memory for input_dev '%s'\n",
+				__func__, pdata->ges_name);
+		ret = -ENODEV;
+		goto input_g_alloc_failed;
+	}
+	chip->g_idev->name = pdata->ges_name;
+	chip->g_idev->id.bustype = BUS_I2C;
+
+    // for ges
+    set_bit(EV_REL,     chip->g_idev->evbit);
+    set_bit(REL_RX,     chip->g_idev->relbit);  //gesture style
+    set_bit(REL_RY,     chip->g_idev->relbit);  //gesture enter time
+    set_bit(REL_RZ,     chip->g_idev->relbit);  //gesture exit  time
+    set_bit(REL_HWHEEL, chip->g_idev->relbit);  //gesture enter angle
+    set_bit(REL_DIAL,   chip->g_idev->relbit);  //gesture exit  angle
+
+    set_bit(REL_X,      chip->g_idev->relbit);  //gesture chanle data n
+    set_bit(REL_Y,      chip->g_idev->relbit);  //gesture chanle data s
+    set_bit(REL_Z,      chip->g_idev->relbit);  //gesture chanle data w
+    set_bit(REL_WHEEL,  chip->g_idev->relbit);  //gesture chanle data e  
+
+
+	dev_set_drvdata(&chip->g_idev->dev, chip);
+	ret = input_register_device(chip->g_idev);
+	if (ret) {
+		input_free_device(chip->g_idev);
+		dev_err(dev, "%s: cant register input '%s'\n",
+				__func__, pdata->ges_name);
+		goto input_g_register_failed;
+	}
+	ret = tmg399x_add_sysfs_interfaces(&chip->g_idev->dev,
+			attrs_gesture, ARRAY_SIZE(attrs_gesture));
+	if (ret)
+		goto input_g_sysfs_failed;
+bypass_ges_idev:
+
+    ret = gpio_request(chip->irq_pin_num, "irq-als-prox-ges");
+	if (ret)    
+    {
+        SENSOR_LOG_INFO("gpio %d is busy and then to free it\n",chip->irq_pin_num);
+        
+        gpio_free(chip->irq_pin_num);
+        ret = gpio_request(chip->irq_pin_num, "tmg3993");
+        if (ret) 
+        {
+            SENSOR_LOG_INFO("gpio %d is busy and then to free it\n",chip->irq_pin_num);
+            return ret;
+        }
+	}
+    
+    ret = gpio_tlmm_config(GPIO_CFG(chip->irq_pin_num, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+
+    client->irq = gpio_to_irq(chip->irq_pin_num);///ztemt
+    SENSOR_LOG_INFO("client->irq = %d\n",client->irq);
+	INIT_WORK(&chip->irq_work, tmg399x_irq_work);
+	ret = request_threaded_irq(client->irq, NULL, &tmg399x_irq, IRQF_TRIGGER_FALLING | IRQF_ONESHOT, "als-prox-ges", chip);
+	if (ret) {
+		dev_info(dev, "Failed to request irq %d\n", client->irq);
+		goto irq_register_fail;
+	}
+
+    INIT_DELAYED_WORK(&chip->als_poll_work, tmg399x_als_poll_work_func);
+    INIT_DELAYED_WORK(&chip->prox_thres_cal_work, tmg399x_prox_thres_cal_work_func);
+    INIT_DELAYED_WORK(&chip->prox_offset_cal_work, tmg399x_prox_offset_cal_work_func);
+    INIT_DELAYED_WORK(&chip->gesture_offset_cal_work, tmg399x_gesture_offset_cal_work_func);
+
+    hrtimer_init(&chip->prox_unwakelock_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    chip->prox_unwakelock_timer.function = tmg399x_unwakelock_work_func;
+
+	init_waitqueue_head(&gesture_drdy_wq);
+	atomic_set(&gesture_drdy, 0);
+    chip->light_poll_time = AMS_ALS_POLL_DELAY_FAST;
+
+    proximity_class = class_create(THIS_MODULE, "proximity");
+    light_class     = class_create(THIS_MODULE, "light");
+    gesture_class   = class_create(THIS_MODULE, "gesture");
+
+    chip->proximity_dev = device_create(proximity_class, NULL, tmg399x_proximity_dev_t, &tmg399x_driver ,"proximity");
+    if (IS_ERR(chip->proximity_dev)) 
+    {
+       ret = PTR_ERR(chip->proximity_dev);
+       goto create_proximity_dev_failed;
+    }
+
+    chip->light_dev= device_create(light_class, NULL, tmg399x_light_dev_t, &tmg399x_driver ,"light");
+    if (IS_ERR(chip->light_dev)) 
+    {
+       ret = PTR_ERR(chip->light_dev);
+       goto create_light_dev_failed;
+    }
+
+    chip->gesture_dev = device_create(gesture_class, NULL, tmg399x_gesture_dev_t, &tmg399x_driver ,"gesture");
+    if (IS_ERR(chip->gesture_dev)) 
+    {
+       ret = PTR_ERR(chip->gesture_dev);
+       goto create_gesture_dev_failed;
+    }
+
+	dev_set_drvdata(chip->proximity_dev, chip);
+	dev_set_drvdata(chip->light_dev, chip);
+	dev_set_drvdata(chip->gesture_dev, chip);
+
+    create_sysfs_interfaces_prox(chip->proximity_dev);
+    create_sysfs_interfaces_light(chip->light_dev);
+    create_sysfs_interfaces_gesture(chip->gesture_dev);
+
+    tmg399x_irq_enable(false, true);
+
+	SENSOR_LOG_INFO("Probe ok.\n");
+	return 0;
+
+create_proximity_dev_failed:
+    chip->proximity_dev = NULL;
+    class_destroy(proximity_class);
+
+create_light_dev_failed:
+    chip->proximity_dev = NULL;
+    chip->light_dev     = NULL;
+    class_destroy(proximity_class);
+    class_destroy(proximity_class);
+
+create_gesture_dev_failed:
+    chip->proximity_dev = NULL;
+    chip->light_dev     = NULL;
+    chip->gesture_dev     = NULL;
+    class_destroy(proximity_class);
+    class_destroy(light_class);
+    class_destroy(gesture_class);
+
+
+irq_register_fail:
+    if (chip->a_idev) {
+            tmg399x_remove_sysfs_interfaces(&chip->g_idev->dev,attrs_gesture, ARRAY_SIZE(attrs_gesture));
+input_g_sysfs_failed:
+            input_unregister_device(chip->g_idev);
+input_g_register_failed:
+            input_free_device(chip->g_idev);
+        }
+input_g_alloc_failed:
+
+	if (chip->a_idev) {
+		tmg399x_remove_sysfs_interfaces(&chip->a_idev->dev,attrs_light, ARRAY_SIZE(attrs_light));
+input_a_sysfs_failed:
+		input_unregister_device(chip->a_idev);
+input_a_register_failed:
+		input_free_device(chip->a_idev);
+	}
+input_a_alloc_failed:
+	if (chip->p_idev) {
+		tmg399x_remove_sysfs_interfaces(&chip->p_idev->dev, attrs_prox, ARRAY_SIZE(attrs_prox));
+input_p_sysfs_failed:
+		input_unregister_device(chip->p_idev);
+input_p_register_failed:
+		input_free_device(chip->p_idev);
+	}	
+input_p_alloc_failed:
+flush_regs_failed:
+id_failed:
+	kfree(chip->segment);
+set_segment_failed:
+	i2c_set_clientdata(client, NULL);
+	kfree(chip);
+malloc_failed:
+	if (powered && pdata->platform_power)
+		pdata->platform_power(dev, POWER_OFF);
+pon_failed:
+	if (pdata->platform_teardown)
+		pdata->platform_teardown(dev);
+init_failed:
+	SENSOR_LOG_INFO("Probe failed.\n");
+	return ret;
+}
+
+static int tmg399x_prox_calibrate(struct tmg399x_chip *chip)
+{
+    int prox_sum = 0, prox_mean = 0, prox_max = 0,prox_min = 0;
+    u8  i = 0 ;
+    int ret = 0;
+    struct tmg399x_prox_info *prox_cal_info = NULL;
+    chip->prox_calibrate_result = false;
+
+    prox_cal_info = kmalloc(sizeof(struct tmg399x_prox_info) * (chip->prox_calibrate_times), GFP_KERNEL); 
+    if (NULL == prox_cal_info)
+    {
+        SENSOR_LOG_ERROR("malloc prox_cal_info failed\n");
+        ret = -1;
+        goto prox_calibrate_failed;
+    }
+
+    memset(prox_cal_info, 0, sizeof(struct tmg399x_prox_info) * (chip->prox_calibrate_times));
+
+    if (false == (chip->prx_enabled))
+    {
+        chip->shadow[TMG399X_CONTROL] |= (TMG399X_EN_PWR_ON | TMG399X_EN_PRX|TMG399X_EN_WAIT);
+        ret = tmg399x_update_enable_reg(chip);
+        if (ret < 0)
+        {
+            
+            SENSOR_LOG_ERROR("enable prox failed\n");
+            kfree(prox_cal_info);
+            goto prox_calibrate_failed;
+        }    
+        chip->light_poll_time = AMS_ALS_POLL_DELAY_SLOW;
+        tmg399x_als_atime_set(AMS_ALS_ATIME_SHORT);
+    }
+	
+    mdelay(20);
+
+	for (i = 0; i < chip->prox_calibrate_times; i++) 
+    {
+        tmg399x_read_prox_data(chip);   
+        prox_cal_info[i].raw = chip->shadow[TMG399X_PRX_CHAN];
+		prox_sum += prox_cal_info[i].raw;
+
+		if (prox_cal_info[i].raw> prox_max)
+        {
+		    	prox_max = prox_cal_info[i].raw;
+		}
+        if (prox_cal_info[i].raw < prox_min)
+		{
+   	        prox_min = prox_cal_info[i].raw;
+        }
+
+        SENSOR_LOG_ERROR("prox data = %d\n",prox_cal_info[i].raw);
+
+	    mdelay(30);
+	}
+             
+    prox_mean = prox_sum/chip->prox_calibrate_times;
+				
+    if (prox_max <= 50)
+    {
+
+		chip->params.prox_th_high = prox_mean + 110;
+		chip->params.prox_th_low  = prox_mean + 30;
+    }
+	  else
+	 {
+        if (prox_max > 170)
+        {
+    		chip->params.prox_th_high = 250;
+    		chip->params.prox_th_low  = 230;
+        }
+        else
+        {
+    		chip->params.prox_th_high = prox_mean +50;
+    		chip->params.prox_th_low  = prox_mean +30;
+        }        
+	}
+
+	SENSOR_LOG_ERROR("chip->params.prox_th_high = %d\n",chip->params.prox_th_high );
+	SENSOR_LOG_ERROR("chip->params.prox_th_low  = %d\n",chip->params.prox_th_low);
+
+    chip->shadow[TMG399X_PRX_THRES_HIGH] = chip->params.prox_th_high;
+    chip->shadow[TMG399X_PRX_THRES_LOW]  = chip->params.prox_th_low;
+
+    input_report_rel(chip->p_idev, REL_Y, chip->params.prox_th_high);
+    input_report_rel(chip->p_idev, REL_Z, chip->params.prox_th_low);
+	input_sync(chip->p_idev);
+    
+    if (true == (chip->prx_enabled))
+    {
+        tmg399x_prox_enable(chip, true);
+    }
+    else
+    {
+        tmg399x_prox_enable(chip, false);
+    }
+    
+    kfree(prox_cal_info);
+    chip->prox_calibrate_result = true;
+    return 0;
+
+prox_calibrate_failed:
+    return ret;
+}
+
+
+
+static int __devexit tmg399x_remove(struct i2c_client *client)
+{
+	struct tmg399x_chip *chip = i2c_get_clientdata(client);
+	mutex_lock(&chip->lock);
+	free_irq(client->irq, chip);
+	if (chip->a_idev) {
+		tmg399x_remove_sysfs_interfaces(&chip->a_idev->dev,
+			attrs_light, ARRAY_SIZE(attrs_light));
+		input_unregister_device(chip->a_idev);
+	}
+	if (chip->p_idev) {
+		tmg399x_remove_sysfs_interfaces(&chip->p_idev->dev,
+			attrs_prox, ARRAY_SIZE(attrs_prox));
+		input_unregister_device(chip->p_idev);
+	}
+	if (chip->pdata->platform_teardown)
+		chip->pdata->platform_teardown(&client->dev);
+	i2c_set_clientdata(client, NULL);
+	kfree(chip->segment);
+	kfree(chip);
+	mutex_unlock(&chip->lock);
+	return 0;
+}
+
+static int __init tmg399x_init(void)
+{
+#ifdef CONFIG_ZTEMT_SENSORS_ALS_PS_AUTO_DETECT
+    return 0;
+#else
+    return i2c_add_driver(&tmg399x_driver);
+#endif
+}
+
+static void __exit tmg399x_exit(void)
+{
+	i2c_del_driver(&tmg399x_driver);
+}
+
+module_init(tmg399x_init);
+module_exit(tmg399x_exit);
+
+MODULE_AUTHOR("J. August Brenner<jon.brenner@ams.com>");
+MODULE_AUTHOR("Byron Shi<byron.shi@ams.com>");
+MODULE_DESCRIPTION("AMS-TAOS tmg3992/3 Ambient, Proximity, Gesture sensor driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/i2c/busses/i2c-qup.c b/drivers/i2c/busses/i2c-qup.c
old mode 100644
new mode 100755
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
old mode 100644
new mode 100755
index 1e08169..bd761a3
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -11,6 +11,9 @@ menuconfig INPUT_TOUCHSCREEN
 
 if INPUT_TOUCHSCREEN
 
+source "drivers/input/touchscreen/cyttsp4/Kconfig"
+source "drivers/input/touchscreen/synaptics_dsx/Kconfig"
+
 config TOUCHSCREEN_88PM860X
 	tristate "Marvell 88PM860x touchscreen"
 	depends on MFD_88PM860X
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
old mode 100644
new mode 100755
index dc3bbe0..9833935
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -6,6 +6,9 @@
 
 wm97xx-ts-y := wm97xx-core.o
 
+obj-$(CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX) += synaptics_dsx/
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_TMA463)        += cyttsp4/
+
 obj-$(CONFIG_TOUCHSCREEN_88PM860X)	+= 88pm860x-ts.o
 obj-$(CONFIG_TOUCHSCREEN_AD7877)	+= ad7877.o
 obj-$(CONFIG_TOUCHSCREEN_AD7879)	+= ad7879.o
@@ -84,3 +87,4 @@ obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI4_DEV)	+= synaptics_rmi_dev.o
 obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_FW_UPDATE) 	+= synaptics_fw_update.o
 obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4)		+= synaptics_i2c_rmi4.o
 obj-$(CONFIG_TOUCHSCREEN_GT9XX)		+= gt9xx/
+
diff --git a/drivers/input/touchscreen/cyttsp4/Kconfig b/drivers/input/touchscreen/cyttsp4/Kconfig
new file mode 100755
index 0000000..b984399
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/Kconfig
@@ -0,0 +1,224 @@
+menuconfig TOUCHSCREEN_CYPRESS_TMA463
+	tristate "TOUCHSCREEN_CYPRESS_TMA463"
+	help
+	  Say Y here, and a list of supported touchscreens will be displayed.
+	  This option doesn't affect the kernel.
+
+	  If unsure, say Y.
+
+if TOUCHSCREEN_CYPRESS_TMA463
+
+choice
+	prompt "Cypress TTSP Screen Size of the Module"
+
+config CYTTSP4_5P5_INCH_OTG_GW
+	bool "5.5 inch OTG TP"
+	help
+	  This option enables support Cypress TTSP 5.5 inch TP.
+	  
+config CYTTSP4_5P0_INCH_OTG_GW
+	bool "5.0 inch OTG TP"
+	help
+	  This option enables support Cypress TTSP 5.0 inch TP.
+	
+config CYTTSP4_4P7_INCH_OTG_GW
+	bool "4.7 inch OTG TP"
+	help
+	  This option enables support Cypress TTSP 4.7 inch TP.	
+endchoice
+
+config CYPRESS_CYTTSP4_BUS
+	bool "Cypress TTSP core bus"
+	default n
+	help
+	  This option enables support Cypress TTSP core bus.
+	  This support is needed for various device and drivers
+	  using Cypress TrueTouch(TM) Standard Product
+	  protocol.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4
+	tristate "Cypress TrueTouch Gen4 Touchscreen Driver"
+	default y
+	depends on CYPRESS_CYTTSP4_BUS
+
+	help
+	  Core driver for Cypress TrueTouch(tm) Standard Product
+	  Geneartion4 touchscreen controllers.
+
+	  Say Y here if you have a Cypress Gen4 touchscreen.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_DEBUG
+	bool "Enable debug output"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default n
+	help
+	  Enable Debug output for Cypress TrueTouch(tm)
+	  Standard Product Generation4 drivers set.
+
+	  Say Y here to enable debug output.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_VDEBUG
+	bool "Enable verbose debug output"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_DEBUG
+	default n
+	help
+	  Enable Verbose Debug output for Cypress TrueTouch(tm)
+	  Standard Product Generation4 drivers set.
+
+	  Say Y here to enable verbose debug output.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_I2C
+	tristate "Cypress TrueTouch Gen4 I2C"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default y
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  I2C bus interface.
+
+	  Say Y here to enable I2C bus interface to TTSP
+	  touchscreen controller.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_SPI
+	tristate "Cypress TrueTouch Gen4 SPI"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default n
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  SPI bus interface.
+
+	  Say Y here to enable SPI bus interface to TTSP
+	  touchscreen controller.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_MT_A
+	tristate "Cypress TrueTouch Gen4 MultiTouch Protocol A"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default n
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  MutliTouch Protocol A support.
+
+	  Say Y here to enable MutiTouch touch reporting
+	  using protocol A.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_MT_B
+	tristate "Cypress TrueTouch Gen4 MultiTouch Protocol B"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default y
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  MutliTouch Protocol B support.
+
+	  Say Y here to enable MutiTouch touch reporting
+	  using protocol B.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_BUTTON
+	tristate "Cypress TrueTouch Gen4 MultiTouch CapSense Button"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default n
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  CapSense driver.
+
+	  Say Y here to enable CapSense reporting.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_PROXIMITY
+	tristate "Cypress TrueTouch Gen4 Proximity"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default m
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  Proximity driver.
+
+	  Say Y here to enable proximity reporting.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS
+	tristate "Cypress TrueTouch Gen4 MultiTouch Device Access"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default n
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  Device access module.
+
+	  This modules adds an interface to access touchscreen
+	  controller using driver sysfs nodes.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS_API
+	bool "Enable Device Access kernel API"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS
+	default n
+	help
+	  Say Y here to enable Device access kernel API.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_TEST_DEVICE_ACCESS_API
+	tristate "Simple Test module for Device Access kernel API"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS_API
+	default n
+	help
+	  Say Y here to enable test module for Device access kernel API.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_LOADER
+	tristate "Cypress TrueTouch Gen4 MultiTouch Loader"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default n
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  FW Loader module.
+
+	  This module enables support for Firmware upgrade.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+	bool "FW upgrade from header file"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_LOADER
+	default n
+	help
+	  Include Cypress TrueTouch(tm) Standard Product
+	  Generation4 device Firmware into driver.
+
+	  Need proper header file for this.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+	bool "FW upgrade from binary file"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_LOADER
+	default n
+	help
+	  Include Cypress TrueTouch(tm) Standard Product
+	  Generation4 device Firmware into kernel itself.
+
+	  This should be enabled for manual FW upgrade.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_TTCONFIG_UPGRADE
+	bool "TT Configuration upgrade from header file"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_LOADER
+	default n
+	help
+	  Include Cypress TrueTouch(tm) Standard Product
+	  Generation4 device TrueTouch Configuration into
+	  kernel itself.
+
+	  Need proper header file for this.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE
+	bool "TT Configuration upgrade via SysFs"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_LOADER
+	default n
+	help
+	  Provides a SysFs interface to upgrade TrueTouch
+	  Configuration with a binary configuration file.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_DEBUG_MODULE
+	tristate "Cypress TrueTouch Gen4 MultiTouch Debug Module"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default n
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  Debug module.
+
+	  This module adds support for verbose printing touch
+	  information.
+
+endif
diff --git a/drivers/input/touchscreen/cyttsp4/Makefile b/drivers/input/touchscreen/cyttsp4/Makefile
new file mode 100755
index 0000000..abd39bb
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/Makefile
@@ -0,0 +1,57 @@
+#
+# Makefile for the touchscreen drivers.
+#
+
+# Each configuration option enables a list of files.
+
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_TMA463) += zte_ctp.o
+obj-$(CONFIG_CYPRESS_CYTTSP4_BUS) += cyttsp4_bus.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4)	+= cyttsp4_core.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_I2C)	+= cyttsp4_i2c.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_SPI)	+= cyttsp4_spi.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MT_A)	+= cyttsp4_mt_a.o
+cyttsp4_mt_a-y := cyttsp4_mta.o cyttsp4_mt_common.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MT_B)	+= cyttsp4_mt_b.o
+cyttsp4_mt_b-y := cyttsp4_mtb.o cyttsp4_mt_common.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BUTTON)	+= cyttsp4_btn.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PROXIMITY)	+= cyttsp4_proximity.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS)	+= cyttsp4_device_access.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_TEST_DEVICE_ACCESS_API)	+= cyttsp4_test_device_access_api.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_LOADER)	+= cyttsp4_loader.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEBUG_MODULE)	+= cyttsp4_debug.o
+
+ifeq ($(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEBUG),y)
+CFLAGS_cyttsp4_bus.o += -DDEBUG
+CFLAGS_cyttsp4_core.o += -DDEBUG
+CFLAGS_cyttsp4_i2c.o += -DDEBUG
+CFLAGS_cyttsp4_spi.o += -DDEBUG
+CFLAGS_cyttsp4_mta.o += -DDEBUG
+CFLAGS_cyttsp4_mtb.o += -DDEBUG
+CFLAGS_cyttsp4_mt_a.o += -DDEBUG
+CFLAGS_cyttsp4_mt_b.o += -DDEBUG
+CFLAGS_cyttsp4_mt_common.o += -DDEBUG
+CFLAGS_cyttsp4_btn.o += -DDEBUG
+CFLAGS_cyttsp4_proximity.o += -DDEBUG
+CFLAGS_cyttsp4_device_access.o += -DDEBUG
+CFLAGS_cyttsp4_loader.o += -DDEBUG
+CFLAGS_cyttsp4_debug.o += -DDEBUG
+endif
+
+ifeq ($(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_VDEBUG),y)
+CFLAGS_cyttsp4_bus.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_core.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_i2c.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_spi.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_mta.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_mtb.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_mt_a.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_mt_b.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_mt_common.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_btn.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_proximity.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_device_access.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_loader.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_debug.o += -DVERBOSE_DEBUG
+endif
+
+ 
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_btn.c b/drivers/input/touchscreen/cyttsp4/cyttsp4_btn.c
new file mode 100755
index 0000000..be72c33
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_btn.c
@@ -0,0 +1,527 @@
+/*
+ * cyttsp4_btn.c
+ * Cypress TrueTouch(TM) Standard Product V4 CapSense touch reports module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include "cyttsp4_bus.h"
+
+#include <linux/delay.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/limits.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+
+#include "cyttsp4_btn.h"
+#include "cyttsp4_core.h"
+#include "cyttsp4_regs.h"
+
+struct cyttsp4_btn_data {
+	struct cyttsp4_device *ttsp;
+	struct cyttsp4_btn_platform_data *pdata;
+	struct cyttsp4_sysinfo *si;
+	struct input_dev *input;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend es;
+#endif
+	struct mutex report_lock;
+	bool is_suspended;
+	bool input_device_registered;
+	char phys[NAME_MAX];
+	u8 pr_buf[CY_MAX_PRBUF_SIZE];
+};
+
+
+static inline void cyttsp4_btn_key_action(struct cyttsp4_btn_data *bd,
+	int btn_no, int btn_state)
+{
+	struct device *dev = &bd->ttsp->dev;
+	struct cyttsp4_sysinfo *si = bd->si;
+
+	if (!si->btn[btn_no].enabled ||
+			si->btn[btn_no].state == btn_state)
+		return;
+
+	si->btn[btn_no].state = btn_state;
+	input_report_key(bd->input, si->btn[btn_no].key_code, btn_state);
+	input_sync(bd->input);
+
+	dev_dbg(dev, "%s: btn=%d key_code=%d %s\n", __func__,
+		btn_no, si->btn[btn_no].key_code,
+		btn_state == CY_BTN_PRESSED ?
+			"PRESSED" : "RELEASED");
+}
+
+static void cyttsp4_get_btn_touches(struct cyttsp4_btn_data *bd)
+{
+	struct cyttsp4_sysinfo *si = bd->si;
+	int num_btn_regs = si->si_ofs.num_btn_regs;
+	int num_btns = si->si_ofs.num_btns;
+	int cur_reg;
+	int cur_reg_val;
+	int cur_btn;
+	int cur_btn_state;
+	int i;
+
+	for (cur_btn = 0, cur_reg = 0; cur_reg < num_btn_regs; cur_reg++) {
+		cur_reg_val = si->xy_mode[si->si_ofs.rep_ofs + 2 + cur_reg];
+
+		for (i = 0; i < CY_NUM_BTN_PER_REG && cur_btn < num_btns;
+				i++, cur_btn++) {
+			/* Get current button state */
+			cur_btn_state = cur_reg_val &
+					((1 << CY_BITS_PER_BTN) - 1);
+			/* Shift reg value for next iteration */
+			cur_reg_val >>= CY_BITS_PER_BTN;
+
+			cyttsp4_btn_key_action(bd, cur_btn, cur_btn_state);
+		}
+	}
+}
+
+static void cyttsp4_btn_lift_all(struct cyttsp4_btn_data *bd)
+{
+	struct cyttsp4_sysinfo *si = bd->si;
+	int i;
+
+	if (!si || si->si_ofs.num_btns == 0)
+		return;
+
+	for (i = 0; i < si->si_ofs.num_btns; i++)
+		cyttsp4_btn_key_action(bd, i, CY_BTN_RELEASED);
+}
+
+#ifdef VERBOSE_DEBUG
+static void cyttsp4_log_btn_data(struct cyttsp4_btn_data *bd)
+{
+	struct device *dev = &bd->ttsp->dev;
+	struct cyttsp4_sysinfo *si = bd->si;
+	int cur;
+	int t;
+
+	for (cur = 0; cur < si->si_ofs.num_btns; cur++) {
+		bd->pr_buf[0] = 0;
+		snprintf(bd->pr_buf, CY_MAX_PRBUF_SIZE, "btn_rec[%d]=0x", cur);
+		for (t = 0; t < si->si_ofs.btn_rec_size; t++)
+			snprintf(bd->pr_buf, CY_MAX_PRBUF_SIZE, "%s%02X",
+				bd->pr_buf, si->btn_rec_data
+				[(cur * si->si_ofs.btn_rec_size) + t]);
+
+		dev_vdbg(dev, "%s: %s\n", __func__, bd->pr_buf);
+	}
+	return;
+}
+#endif
+
+/* read xy_data for all current CapSense button touches */
+static int cyttsp4_xy_worker(struct cyttsp4_btn_data *bd)
+{
+	struct device *dev = &bd->ttsp->dev;
+	struct cyttsp4_sysinfo *si = bd->si;
+	u8 rep_stat = si->xy_mode[si->si_ofs.rep_ofs + 1];
+#ifdef VERBOSE_DEBUG
+	int rc;
+#endif
+
+	/* rep_data for bad packet check */
+	if (IS_BAD_PKT(rep_stat)) {
+		dev_dbg(dev, "%s: Invalid buffer detected\n", __func__);
+		return 0;
+	}
+
+	/* extract button press/release touch information */
+	if (si->si_ofs.num_btns > 0) {
+		cyttsp4_get_btn_touches(bd);
+#ifdef VERBOSE_DEBUG
+		/* read button diff data */
+		rc = cyttsp4_read(bd->ttsp, CY_MODE_OPERATIONAL,
+				si->si_ofs.tt_stat_ofs + 1 +
+				si->si_ofs.max_tchs * si->si_ofs.tch_rec_size,
+				si->btn_rec_data,
+				si->si_ofs.num_btns * si->si_ofs.btn_rec_size);
+		if (rc < 0) {
+			dev_err(dev, "%s: read fail on button regs r=%d\n",
+					__func__, rc);
+			return 0;
+		}
+
+		/* log button press/release touch information */
+		cyttsp4_log_btn_data(bd);
+#endif
+	}
+
+	dev_vdbg(dev, "%s: done\n", __func__);
+
+	return 0;
+}
+
+static int cyttsp4_btn_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_btn_data *bd = dev_get_drvdata(dev);
+	int rc = 0;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	mutex_lock(&bd->report_lock);
+	if (!bd->is_suspended) {
+		/* core handles handshake */
+		rc = cyttsp4_xy_worker(bd);
+	} else {
+		dev_vdbg(dev, "%s: Ignoring report while suspended\n",
+			__func__);
+	}
+	mutex_unlock(&bd->report_lock);
+	if (rc < 0)
+		dev_err(dev, "%s: xy_worker error r=%d\n", __func__, rc);
+
+	return rc;
+}
+
+static int cyttsp4_startup_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_btn_data *bd = dev_get_drvdata(dev);
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	mutex_lock(&bd->report_lock);
+	cyttsp4_btn_lift_all(bd);
+	mutex_unlock(&bd->report_lock);
+
+	return 0;
+}
+
+static int cyttsp4_btn_open(struct input_dev *input)
+{
+	struct device *dev = input->dev.parent;
+	struct cyttsp4_device *ttsp =
+		container_of(dev, struct cyttsp4_device, dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	pm_runtime_get(dev);
+
+	dev_vdbg(dev, "%s: setup subscriptions\n", __func__);
+
+	/* set up touch call back */
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_btn_attention, CY_MODE_OPERATIONAL);
+
+	/* set up startup call back */
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_startup_attention, 0);
+
+	return 0;
+}
+
+static void cyttsp4_btn_close(struct input_dev *input)
+{
+	struct device *dev = input->dev.parent;
+	struct cyttsp4_device *ttsp =
+		container_of(dev, struct cyttsp4_device, dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_btn_attention, CY_MODE_OPERATIONAL);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_startup_attention, 0);
+
+	pm_runtime_put(dev);
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void cyttsp4_btn_early_suspend(struct early_suspend *h)
+{
+	struct cyttsp4_btn_data *bd =
+		container_of(h, struct cyttsp4_btn_data, es);
+	struct device *dev = &bd->ttsp->dev;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+#ifndef CONFIG_PM_RUNTIME
+	mutex_lock(&bd->report_lock);
+	bd->is_suspended = true;
+	cyttsp4_btn_lift_all(bd);
+	mutex_unlock(&bd->report_lock);
+#endif
+
+	pm_runtime_put(dev);
+}
+
+static void cyttsp4_btn_late_resume(struct early_suspend *h)
+{
+	struct cyttsp4_btn_data *bd =
+		container_of(h, struct cyttsp4_btn_data, es);
+	struct device *dev = &bd->ttsp->dev;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+#ifndef CONFIG_PM_RUNTIME
+	mutex_lock(&bd->report_lock);
+	bd->is_suspended = false;
+	mutex_unlock(&bd->report_lock);
+#endif
+
+	pm_runtime_get(dev);
+}
+#endif
+
+#ifdef CONFIG_PM_RUNTIME
+static int cyttsp4_btn_suspend(struct device *dev)
+{
+	struct cyttsp4_btn_data *bd = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&bd->report_lock);
+	bd->is_suspended = true;
+	cyttsp4_btn_lift_all(bd);
+	mutex_unlock(&bd->report_lock);
+
+	return 0;
+}
+
+static int cyttsp4_btn_resume(struct device *dev)
+{
+	struct cyttsp4_btn_data *bd = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&bd->report_lock);
+	bd->is_suspended = false;
+	mutex_unlock(&bd->report_lock);
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops cyttsp4_btn_pm_ops = {
+	SET_RUNTIME_PM_OPS(cyttsp4_btn_suspend, cyttsp4_btn_resume, NULL)
+};
+
+static int cyttsp4_setup_input_device(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_btn_data *bd = dev_get_drvdata(dev);
+	int i;
+	int rc;
+
+	dev_vdbg(dev, "%s: Initialize event signals\n", __func__);
+	__set_bit(EV_KEY, bd->input->evbit);
+	for (i = 0; i < bd->si->si_ofs.num_btns; i++)
+		__set_bit(bd->si->btn[i].key_code, bd->input->keybit);
+
+	rc = input_register_device(bd->input);
+	if (rc < 0)
+		dev_err(dev, "%s: Error, failed register input device r=%d\n",
+			__func__, rc);
+	else
+		bd->input_device_registered = true;
+
+	return rc;
+}
+
+static int cyttsp4_setup_input_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_btn_data *bd = dev_get_drvdata(dev);
+	int rc;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	bd->si = cyttsp4_request_sysinfo(ttsp);
+	if (!bd->si)
+		return -1;
+
+	rc = cyttsp4_setup_input_device(ttsp);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_setup_input_attention, 0);
+
+	return rc;
+}
+
+static int cyttsp4_btn_probe(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_btn_data *bd;
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_btn_platform_data *pdata = dev_get_platdata(dev);
+	int rc = 0;
+
+	dev_dbg(dev, "%s\n", __func__);
+	dev_dbg(dev, "%s: debug on\n", __func__);
+	dev_vdbg(dev, "%s: verbose debug on\n", __func__);
+
+	if (pdata == NULL) {
+		dev_err(dev, "%s: Missing platform data\n", __func__);
+		rc = -ENODEV;
+		goto error_no_pdata;
+	}
+
+	bd = kzalloc(sizeof(*bd), GFP_KERNEL);
+	if (bd == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto error_alloc_data_failed;
+	}
+
+	mutex_init(&bd->report_lock);
+	bd->ttsp = ttsp;
+	bd->pdata = pdata;
+	dev_set_drvdata(dev, bd);
+	/* Create the input device and register it. */
+	dev_vdbg(dev, "%s: Create the input device and register it\n",
+		__func__);
+	bd->input = input_allocate_device();
+	if (bd->input == NULL) {
+		dev_err(dev, "%s: Error, failed to allocate input device\n",
+			__func__);
+		rc = -ENOSYS;
+		goto error_alloc_failed;
+	}
+
+	bd->input->name = ttsp->name;
+	scnprintf(bd->phys, sizeof(bd->phys)-1, "%s", dev_name(dev));
+	bd->input->phys = bd->phys;
+	bd->input->dev.parent = &bd->ttsp->dev;
+	bd->input->open = cyttsp4_btn_open;
+	bd->input->close = cyttsp4_btn_close;
+	input_set_drvdata(bd->input, bd);
+
+	pm_runtime_enable(dev);
+
+	/* get sysinfo */
+	bd->si = cyttsp4_request_sysinfo(ttsp);
+	if (bd->si) {
+		rc = cyttsp4_setup_input_device(ttsp);
+		if (rc)
+			goto error_init_input;
+	} else {
+		dev_err(dev, "%s: Fail get sysinfo pointer from core p=%p\n",
+			__func__, bd->si);
+		cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_input_attention, 0);
+	}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	bd->es.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	bd->es.suspend = cyttsp4_btn_early_suspend;
+	bd->es.resume = cyttsp4_btn_late_resume;
+	register_early_suspend(&bd->es);
+#endif
+
+	dev_dbg(dev, "%s: ok\n", __func__);
+	return 0;
+
+error_init_input:
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+	input_free_device(bd->input);
+error_alloc_failed:
+	dev_set_drvdata(dev, NULL);
+	kfree(bd);
+error_alloc_data_failed:
+error_no_pdata:
+	dev_err(dev, "%s failed.\n", __func__);
+	return rc;
+}
+
+static int cyttsp4_btn_release(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_btn_data *bd = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	/*
+	 * This check is to prevent pm_runtime usage_count drop below zero
+	 * because of removing the module while in suspended state
+	 */
+	if (bd->is_suspended)
+		pm_runtime_get_noresume(dev);
+
+	unregister_early_suspend(&bd->es);
+#endif
+
+	if (bd->input_device_registered) {
+		input_unregister_device(bd->input);
+	} else {
+		input_free_device(bd->input);
+		cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_input_attention, 0);
+	}
+
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+
+	dev_set_drvdata(dev, NULL);
+	kfree(bd);
+	return 0;
+}
+
+static struct cyttsp4_driver cyttsp4_btn_driver = {
+	.probe = cyttsp4_btn_probe,
+	.remove = cyttsp4_btn_release,
+	.driver = {
+		.name = CYTTSP4_BTN_NAME,
+		.bus = &cyttsp4_bus_type,
+		.owner = THIS_MODULE,
+		.pm = &cyttsp4_btn_pm_ops,
+	},
+};
+
+static int __init cyttsp4_btn_init(void)
+{
+	int rc = 0;
+	rc = cyttsp4_register_driver(&cyttsp4_btn_driver);
+	pr_debug("%s: Cypress TTSP MT v4 CapSense BTN (Built %s), rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return rc;
+}
+module_init(cyttsp4_btn_init);
+
+static void __exit cyttsp4_btn_exit(void)
+{
+	cyttsp4_unregister_driver(&cyttsp4_btn_driver);
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_btn_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TTSP 2D multi-touch CapSense BTN driver");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_btn.h b/drivers/input/touchscreen/cyttsp4/cyttsp4_btn.h
new file mode 100755
index 0000000..f78314b
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_btn.h
@@ -0,0 +1,39 @@
+/*
+ * cyttsp4_btn.h
+ * Cypress TrueTouch(TM) Standard Product V4 CapSense touch reports module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_BTN_H
+#define _LINUX_CYTTSP4_BTN_H
+
+#define CYTTSP4_BTN_NAME "cyttsp4_btn"
+
+struct cyttsp4_btn_platform_data {
+	char const *inp_dev_name;
+};
+
+#endif /* _LINUX_CYTTSP4_BTN_H */
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_bus.c b/drivers/input/touchscreen/cyttsp4/cyttsp4_bus.c
new file mode 100755
index 0000000..a718a17
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_bus.c
@@ -0,0 +1,761 @@
+/*
+ * cyttsp4_bus.c
+ * Cypress TrueTouch(TM) Standard Product V4 Bus Driver.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov aleksej.makarov@sonyericsson.com
+ * Modified by: Cypress Semiconductor for complete set of TTSP Bus interfaces.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include "cyttsp4_bus.h"
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/limits.h>
+
+static DEFINE_MUTEX(core_lock);
+static LIST_HEAD(adapter_list);
+static LIST_HEAD(core_dev_list);
+static LIST_HEAD(cyttsp4_dev_list);
+
+struct bus_type cyttsp4_bus_type;
+
+static void cyttsp4_dev_release(struct device *dev)
+{
+	dev_vdbg(dev, "%s: Enter\n", __func__);
+	put_device(dev->parent);
+}
+
+static struct device_type cyttsp4_dev_type = {
+	.release = cyttsp4_dev_release
+};
+
+static struct device_type cyttsp4_core_type = {
+	.release = cyttsp4_dev_release
+};
+
+static int cyttsp4_match_dev(struct device *dev, void *data)
+{
+	return dev == (struct device *)data;
+}
+
+static void cyttsp4_initialize_device(struct cyttsp4_device *dev,
+		struct cyttsp4_device_info const *dev_info)
+{
+	dev->name = dev_info->name;
+	dev->core_id = dev_info->core_id;
+	dev->dev.platform_data = dev_info->platform_data;
+}
+
+static void _cyttsp4_reinitialize_device(struct cyttsp4_device *dev)
+{
+	void *platform_data = dev->dev.platform_data;
+
+	memset(&dev->dev, 0, sizeof(dev->dev));
+	dev->dev.platform_data = platform_data;
+	dev->core = NULL;
+}
+
+static void cyttsp4_initialize_core(struct cyttsp4_core *core,
+		struct cyttsp4_core_info const *core_info)
+{
+	core->name = core_info->name;
+	core->id = core_info->id;
+	core->adap_id = core_info->adap_id;
+	core->dev.platform_data = core_info->platform_data;
+}
+
+static void _cyttsp4_reinitialize_core(struct cyttsp4_core *core)
+{
+	void *platform_data = core->dev.platform_data;
+
+	memset(&core->dev, 0, sizeof(core->dev));
+	core->dev.platform_data = platform_data;
+	core->adap = NULL;
+}
+
+static int _cyttsp4_register_dev(struct cyttsp4_device *pdev,
+		struct cyttsp4_core *core)
+{
+	int ret;
+
+	/* Check if the device is registered with the system */
+	if (bus_find_device(&cyttsp4_bus_type, NULL, &pdev->dev,
+			cyttsp4_match_dev)) {
+		put_device(&pdev->dev);
+		return -EEXIST;
+	}
+
+	pdev->core = core;
+	pdev->dev.parent = get_device(&core->dev);
+	pdev->dev.bus = &cyttsp4_bus_type;
+	pdev->dev.type = &cyttsp4_dev_type;
+	dev_set_name(&pdev->dev, "%s.%s", pdev->name,  core->id);
+
+	ret = device_register(&pdev->dev);
+	dev_dbg(&pdev->dev,
+		"%s: Registering device '%s'. Parent at '%s', err = %d\n",
+		 __func__, dev_name(&pdev->dev),
+		 dev_name(pdev->dev.parent), ret);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to register device, err %d\n",
+			__func__, ret);
+		pdev->core = NULL;
+	}
+	return ret;
+}
+
+static void _cyttsp4_unregister_dev(struct cyttsp4_device *pdev)
+{
+	/* Check if the device is registered with the system */
+	if (!bus_find_device(&cyttsp4_bus_type, NULL, &pdev->dev,
+			cyttsp4_match_dev))
+		return;
+
+	dev_dbg(&pdev->dev, "%s: Unregistering device '%s'.\n",
+		__func__, dev_name(&pdev->dev));
+	/* Put reference taken by bus_find_device() */
+	put_device(&pdev->dev);
+	device_unregister(&pdev->dev);
+}
+
+static int _cyttsp4_register_core(struct cyttsp4_core *pdev,
+		struct cyttsp4_adapter *adap)
+{
+	int ret;
+
+	/* Check if the device is registered with the system */
+	if (bus_find_device(&cyttsp4_bus_type, NULL, &pdev->dev,
+			cyttsp4_match_dev)) {
+		put_device(&pdev->dev);
+		return -EEXIST;
+	}
+
+	pdev->adap = adap;
+	pdev->dev.parent = get_device(adap->dev);
+	pdev->dev.bus = &cyttsp4_bus_type;
+	pdev->dev.type = &cyttsp4_core_type;
+	dev_set_name(&pdev->dev, "%s.%s", pdev->id,  adap->id);
+
+	ret = device_register(&pdev->dev);
+	dev_dbg(&pdev->dev,
+		"%s: Registering device '%s'. Parent at '%s', err = %d\n",
+		 __func__, dev_name(&pdev->dev),
+		 dev_name(pdev->dev.parent), ret);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to register device, err %d\n",
+			__func__, ret);
+		pdev->adap = NULL;
+	}
+	return ret;
+}
+
+static void _cyttsp4_unregister_core(struct cyttsp4_core *pdev)
+{
+	/* Check if the core is registered with the system */
+	if (!bus_find_device(&cyttsp4_bus_type, NULL, &pdev->dev,
+			cyttsp4_match_dev))
+		return;
+
+	dev_dbg(&pdev->dev, "%s: Unregistering core '%s'.\n",
+		__func__, dev_name(&pdev->dev));
+	/* Put reference taken by bus_find_device() */
+	put_device(&pdev->dev);
+	device_unregister(&pdev->dev);
+}
+
+static void _cyttsp4_unregister_and_reinitialize_devices(
+		struct cyttsp4_core *core)
+{
+	struct cyttsp4_device *dev;
+
+	list_for_each_entry(dev, &cyttsp4_dev_list, node)
+		if (dev->core == core) {
+			_cyttsp4_unregister_dev(dev);
+			_cyttsp4_reinitialize_device(dev);
+		}
+}
+
+static struct cyttsp4_adapter *find_adapter(char const *adap_id)
+{
+	struct cyttsp4_adapter *a;
+
+	list_for_each_entry(a, &adapter_list, node)
+		if (!strncmp(a->id, adap_id, NAME_MAX))
+			return a;
+	return NULL;
+}
+
+static struct cyttsp4_core *find_core(char const *core_id)
+{
+	struct cyttsp4_core *d;
+
+	list_for_each_entry(d, &core_dev_list, node)
+		if (!strncmp(d->id, core_id, NAME_MAX))
+			return d;
+	return NULL;
+}
+
+static struct cyttsp4_core *find_core_with_driver(char const *core_id)
+{
+	struct cyttsp4_core *d;
+
+	d = find_core(core_id);
+	if (d && d->dev.driver)
+		return d;
+	return NULL;
+}
+
+static struct cyttsp4_device *find_device(char const *name,
+		char const *core_id)
+{
+	struct cyttsp4_device *d;
+
+	list_for_each_entry(d, &cyttsp4_dev_list, node)
+		if (!strncmp(d->name, name, NAME_MAX) &&
+				!strncmp(d->core_id, core_id, NAME_MAX))
+			return d;
+	return NULL;
+}
+
+static void rescan_devices(struct cyttsp4_core *core)
+{
+	struct cyttsp4_device *d;
+
+	list_for_each_entry(d, &cyttsp4_dev_list, node)
+		if (!d->core && !strncmp(core->id, d->core_id, NAME_MAX))
+			_cyttsp4_register_dev(d, core);
+}
+
+static void rescan_cores(struct cyttsp4_adapter *adap)
+{
+	struct cyttsp4_core *d;
+
+	list_for_each_entry(d, &core_dev_list, node)
+		if (!d->adap && !strncmp(adap->id, d->adap_id, NAME_MAX))
+			_cyttsp4_register_core(d, adap);
+}
+
+static int cyttsp4_check_device_info(
+	struct cyttsp4_device_info const *dev_info)
+{
+	int len;
+
+	if (!dev_info->name)
+		return -EINVAL;
+	if (!dev_info->core_id)
+		return -EINVAL;
+
+	len = strnlen(dev_info->name, NAME_MAX);
+	if (len == 0 || len == NAME_MAX)
+		return -EINVAL;
+
+	len = strnlen(dev_info->core_id, NAME_MAX);
+	if (len == 0 || len == NAME_MAX)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int cyttsp4_check_core_info(
+	struct cyttsp4_core_info const *core_info)
+{
+	int len;
+
+	if (!core_info->name)
+		return -EINVAL;
+	if (!core_info->id)
+		return -EINVAL;
+	if (!core_info->adap_id)
+		return -EINVAL;
+
+	len = strnlen(core_info->name, NAME_MAX);
+	if (len == 0 || len == NAME_MAX)
+		return -EINVAL;
+
+	len = strnlen(core_info->id, NAME_MAX);
+	if (len == 0 || len == NAME_MAX)
+		return -EINVAL;
+
+	len = strnlen(core_info->adap_id, NAME_MAX);
+	if (len == 0 || len == NAME_MAX)
+		return -EINVAL;
+
+	return 0;
+}
+
+int cyttsp4_register_device(struct cyttsp4_device_info const *dev_info)
+{
+	struct cyttsp4_device *dev;
+	struct cyttsp4_core *core;
+	int ret;
+
+	if (!dev_info) {
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	ret = cyttsp4_check_device_info(dev_info);
+	if (ret) {
+		pr_debug("%s: dev_info is invalid\n", __func__);
+		goto fail;
+	}
+
+	mutex_lock(&core_lock);
+	if (find_device(dev_info->name, dev_info->core_id)) {
+		pr_debug("%s: device '%s' with core id '%s' already exists\n",
+			__func__, dev_info->name, dev_info->core_id);
+		ret = -EEXIST;
+		goto fail_unlock;
+	}
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		pr_err("%s: failed to allocate device '%s'\n",
+			__func__, dev_info->name);
+		ret = -ENOMEM;
+		goto fail_unlock;
+	}
+	cyttsp4_initialize_device(dev, dev_info);
+	list_add(&dev->node, &cyttsp4_dev_list);
+	pr_debug("%s: '%s' added to cyttsp4_dev_list\n", __func__, dev->name);
+	core = find_core_with_driver(dev->core_id);
+	if (core)
+		ret = _cyttsp4_register_dev(dev, core);
+fail_unlock:
+	mutex_unlock(&core_lock);
+fail:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_register_device);
+
+int cyttsp4_unregister_device(char const *name, char const *core_id)
+{
+	struct cyttsp4_device *dev;
+	int ret = 0;
+
+	if (!name || !core_id) {
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	mutex_lock(&core_lock);
+	dev = find_device(name, core_id);
+	if (!dev) {
+		pr_err("%s: device '%s' could not be found\n", __func__, name);
+		ret = -ENODEV;
+		goto fail_unlock;
+	}
+	_cyttsp4_unregister_dev(dev);
+	list_del(&dev->node);
+	pr_debug("%s: '%s' removed from cyttsp4_dev_list\n", __func__,
+		dev->name);
+	kfree(dev);
+fail_unlock:
+	mutex_unlock(&core_lock);
+fail:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_unregister_device);
+
+int cyttsp4_register_core_device(struct cyttsp4_core_info const *core_info)
+{
+	struct cyttsp4_core *core;
+	struct cyttsp4_adapter *adap;
+	int ret;
+
+	if (!core_info) {
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	ret = cyttsp4_check_core_info(core_info);
+	if (ret) {
+		pr_debug("%s: core_info is invalid\n", __func__);
+		goto fail;
+	}
+
+	mutex_lock(&core_lock);
+	if (find_core(core_info->id)) {
+		pr_debug("%s: core id '%s' already exists\n",
+				__func__, core_info->id);
+		ret = -EEXIST;
+		goto fail_unlock;
+	}
+	core = kzalloc(sizeof(*core), GFP_KERNEL);
+	if (!core) {
+		pr_err("%s: failed to allocate core device '%s'\n",
+			__func__, core_info->name);
+		ret = -ENOMEM;
+		goto fail_unlock;
+	}
+	cyttsp4_initialize_core(core, core_info);
+	list_add(&core->node, &core_dev_list);
+	pr_debug("%s: '%s' added to core_dev_list\n", __func__, core->name);
+	adap = find_adapter(core->adap_id);
+	if (adap) {
+		pr_debug("%s: adapter for '%s' is '%s'\n", __func__,
+				core->id, dev_name(adap->dev));
+		ret = _cyttsp4_register_core(core, adap);
+		if (!ret)
+			rescan_devices(core);
+	}
+fail_unlock:
+	mutex_unlock(&core_lock);
+fail:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_register_core_device);
+
+int cyttsp4_add_adapter(char const *id, struct cyttsp4_ops const *ops,
+		struct device *parent)
+{
+	int rc = 0;
+	struct cyttsp4_adapter *a;
+
+	if (!parent) {
+		dev_err(parent, "%s: need parent for '%s'\n", __func__, id);
+		return -EINVAL;
+	}
+	mutex_lock(&core_lock);
+	if (find_adapter(id)) {
+		dev_err(parent, "%s: adapter '%s' already exists\n",
+				__func__, id);
+		rc = -EEXIST;
+		goto fail;
+	}
+	a = kzalloc(sizeof(*a), GFP_KERNEL);
+	if (!a) {
+		dev_err(parent, "%s: failed to allocate adapter '%s'\n",
+				__func__, id);
+		rc = -ENOMEM;
+		goto fail;
+	}
+	memcpy(a->id, id, sizeof(a->id));
+	a->id[sizeof(a->id) - 1] = 0;
+	a->read = ops->read;
+	a->write = ops->write;
+	a->dev = parent;
+	list_add(&a->node, &adapter_list);
+	dev_dbg(parent, "%s: '%s' added to adapter_list\n", __func__, id);
+	rescan_cores(a);
+fail:
+	mutex_unlock(&core_lock);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_add_adapter);
+
+int cyttsp4_del_adapter(char const *id)
+{
+	int rc = 0;
+	struct cyttsp4_adapter *adap;
+	struct cyttsp4_core *core;
+
+	mutex_lock(&core_lock);
+	adap = find_adapter(id);
+	if (!adap) {
+		pr_err("%s: adapter '%s' does not exist\n",
+			__func__, id);
+		rc = -ENODEV;
+		goto fail;
+	}
+
+	/* Unregister core and devices linked to this adapter
+	 * This is to prevent core and devices get probed until
+	 * their corresponding adapter is re-added
+	 */
+	list_for_each_entry(core, &core_dev_list, node) {
+		if (core->adap != adap)
+			continue;
+		_cyttsp4_unregister_and_reinitialize_devices(core);
+		_cyttsp4_unregister_core(core);
+		_cyttsp4_reinitialize_core(core);
+	}
+
+	list_del(&adap->node);
+	kfree(adap);
+	pr_debug("%s: '%s' removed from adapter_list\n", __func__, id);
+fail:
+	mutex_unlock(&core_lock);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_del_adapter);
+
+static struct cyttsp4_device *verify_device_type(struct device *dev)
+{
+	return dev->type == &cyttsp4_dev_type ? to_cyttsp4_device(dev) : NULL;
+}
+
+static struct cyttsp4_core *verify_core_type(struct device *dev)
+{
+	return dev->type == &cyttsp4_core_type ? to_cyttsp4_core(dev) : NULL;
+}
+
+static int cyttsp4_device_match(struct device *dev, struct device_driver *drv)
+{
+	struct cyttsp4_device *cyttsp4_dev = verify_device_type(dev);
+	struct cyttsp4_core *cyttsp4_core;
+	int match;
+
+	if (cyttsp4_dev) {
+		match = strncmp(cyttsp4_dev->name, drv->name, NAME_MAX) == 0;
+		goto exit;
+	}
+	cyttsp4_core = verify_core_type(dev);
+	if (cyttsp4_core) {
+		match = strncmp(cyttsp4_core->name, drv->name, NAME_MAX) == 0;
+		goto exit;
+	}
+	match = 0;
+exit:
+	dev_dbg(dev, "%s: %s matching '%s' driver\n", __func__,
+			match ? "is" : "isn't", drv->name);
+	return match;
+}
+
+static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
+			     char *buf)
+{
+	struct cyttsp4_device *cyttsp4_dev = verify_device_type(dev);
+	struct cyttsp4_core *cyttsp4_core;
+
+	char const *name;
+	int len;
+
+	if (cyttsp4_dev) {
+		name = cyttsp4_dev->name;
+		goto exit;
+	}
+	cyttsp4_core = verify_core_type(dev);
+	if (cyttsp4_core) {
+		name = cyttsp4_core->id;
+		goto exit;
+	}
+	name = "none";
+exit:
+	len = snprintf(buf, PAGE_SIZE, "ttsp4:%s\n", name);
+	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
+}
+
+static struct device_attribute cyttsp4_dev_attrs[] = {
+	__ATTR_RO(modalias),
+	__ATTR_NULL,
+};
+
+#ifdef CONFIG_SUSPEND
+static int cyttsp4_pm_suspend(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+
+	dev_dbg(dev, "%s\n", __func__);
+	if (drv && drv->pm && drv->pm->suspend)
+		return drv->pm->suspend(dev);
+	return 0;
+}
+
+static int cyttsp4_pm_resume(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+
+	dev_dbg(dev, "%s\n", __func__);
+	if (drv && drv->pm && drv->pm->resume)
+		return drv->pm->resume(dev);
+	return 0;
+}
+#else /* !CONFIG_SUSPEND */
+#define cyttsp4_pm_suspend		NULL
+#define cyttsp4_pm_resume		NULL
+#endif /* !CONFIG_SUSPEND */
+
+#ifdef CONFIG_PM_RUNTIME
+#define cyttsp4_pm_rt_suspend		pm_generic_runtime_suspend
+#define cyytsp4_pm_rt_resume		pm_generic_runtime_resume
+#define cyytsp4_pm_rt_idle		pm_generic_runtime_idle
+#else /* !CONFIG_PM_RUNTIME */
+#define cyttsp4_pm_rt_suspend		NULL
+#define cyytsp4_pm_rt_resume		NULL
+#define cyytsp4_pm_rt_idle		NULL
+#endif /* !CONFIG_PM_RUNTIME */
+
+static const struct dev_pm_ops cyttsp4_dev_pm_ops = {
+	.suspend = cyttsp4_pm_suspend,
+	.resume = cyttsp4_pm_resume,
+	.runtime_suspend = cyttsp4_pm_rt_suspend,
+	.runtime_resume = cyytsp4_pm_rt_resume,
+	.runtime_idle = cyytsp4_pm_rt_idle,
+};
+
+struct bus_type cyttsp4_bus_type = {
+	.name		= "ttsp4",
+	.dev_attrs	= cyttsp4_dev_attrs,
+	.match		= cyttsp4_device_match,
+	.uevent		= NULL,
+	.pm		= &cyttsp4_dev_pm_ops,
+};
+EXPORT_SYMBOL_GPL(cyttsp4_bus_type);
+
+static int cyttsp4_drv_remove(struct device *_dev)
+{
+	struct cyttsp4_driver *drv = to_cyttsp4_driver(_dev->driver);
+	struct cyttsp4_device *dev = to_cyttsp4_device(_dev);
+	struct cyttsp4_core *core = dev->core;
+	int ret;
+
+	ret = drv->remove(dev);
+	/* Decrease usage count of the core driver */
+	module_put(core->dev.driver->owner);
+	return ret;
+}
+
+static int cyttsp4_core_drv_remove(struct device *_dev)
+{
+	struct cyttsp4_core_driver *drv = to_cyttsp4_core_driver(_dev->driver);
+	struct cyttsp4_core *core = to_cyttsp4_core(_dev);
+	struct cyttsp4_adapter *adap = core->adap;
+	int ret;
+
+	ret = drv->remove(core);
+	/* Decrease usage count of the adapter driver */
+	module_put(adap->dev->driver->owner);
+
+	mutex_lock(&core_lock);
+	/* Unregister devices linked to this core
+	 * This is to prevent devices get probed until
+	 * their corresponding core driver is re-added
+	 */
+	_cyttsp4_unregister_and_reinitialize_devices(core);
+	mutex_unlock(&core_lock);
+
+	return ret;
+}
+
+static int cyttsp4_drv_probe(struct device *_dev)
+{
+	struct cyttsp4_driver *drv = to_cyttsp4_driver(_dev->driver);
+	struct cyttsp4_device *dev = to_cyttsp4_device(_dev);
+	struct cyttsp4_core *core = dev->core;
+	int rc;
+
+	if (!core || !core->dev.driver)
+		return -ENODEV;
+
+	/* Increase usage count of the core driver*/
+	__module_get(core->dev.driver->owner);
+
+	rc = drv->probe(dev);
+	if (rc)
+		module_put(core->dev.driver->owner);
+	dev_dbg(_dev, "%s: for %s = %d\n", __func__, dev->name, rc);
+	return rc;
+}
+
+static int cyttsp4_core_drv_probe(struct device *_dev)
+{
+	struct cyttsp4_core_driver *drv = to_cyttsp4_core_driver(_dev->driver);
+	struct cyttsp4_core *dev = to_cyttsp4_core(_dev);
+	struct cyttsp4_adapter *adap = dev->adap;
+	int rc;
+
+	if (!adap || !adap->dev->driver)
+		return -ENODEV;
+
+	/* Increase usage count of the adapter driver*/
+	__module_get(adap->dev->driver->owner);
+
+	rc = drv->probe(dev);
+	dev_dbg(_dev, "%s: for %s = %d\n", __func__, dev->name, rc);
+	if (!rc)
+		rescan_devices(dev);
+	else
+		module_put(adap->dev->driver->owner);
+	return rc;
+}
+
+int cyttsp4_register_driver(struct cyttsp4_driver *drv)
+{
+	int ret;
+
+	drv->driver.bus = &cyttsp4_bus_type;
+	if (drv->probe)
+		drv->driver.probe = cyttsp4_drv_probe;
+	if (drv->remove)
+		drv->driver.remove = cyttsp4_drv_remove;
+	ret = driver_register(&drv->driver);
+	pr_debug("%s: '%s' returned %d\n", __func__, drv->driver.name, ret);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_register_driver);
+
+int cyttsp4_register_core_driver(struct cyttsp4_core_driver *drv)
+{
+	int ret;
+
+	drv->driver.bus = &cyttsp4_bus_type;
+	if (drv->probe)
+		drv->driver.probe = cyttsp4_core_drv_probe;
+	if (drv->remove)
+		drv->driver.remove = cyttsp4_core_drv_remove;
+	ret = driver_register(&drv->driver);
+	pr_debug("%s: '%s' returned %d\n", __func__, drv->driver.name, ret);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_register_core_driver);
+
+void cyttsp4_unregister_driver(struct cyttsp4_driver *drv)
+{
+	driver_unregister(&drv->driver);
+}
+EXPORT_SYMBOL_GPL(cyttsp4_unregister_driver);
+
+void cyttsp4_unregister_core_driver(struct cyttsp4_core_driver *drv)
+{
+	driver_unregister(&drv->driver);
+}
+EXPORT_SYMBOL_GPL(cyttsp4_unregister_core_driver);
+
+static int __init cyttsp4_bus_init(void)
+{
+	int error;
+	error =  bus_register(&cyttsp4_bus_type);
+	if (error)
+		pr_err("%s: error %d\n", __func__, error);
+	else
+		pr_debug("%s: ok\n", __func__);
+	return error;
+}
+
+static void __exit cyttsp4_bus_exit(void)
+{
+	pr_debug("%s: ok\n", __func__);
+}
+
+subsys_initcall(cyttsp4_bus_init);
+module_exit(cyttsp4_bus_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Aleksej Makarov <aleksej.makarov@sonyericsson.com>");
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_bus.h b/drivers/input/touchscreen/cyttsp4/cyttsp4_bus.h
new file mode 100755
index 0000000..a67e3cb
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_bus.h
@@ -0,0 +1,346 @@
+/*
+ * cyttsp4_bus.h
+ * Cypress TrueTouch(TM) Standard Product V4 Bus Driver.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ * Modified by: Cypress Semiconductor to add device functions
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_BUS_H
+#define _LINUX_CYTTSP4_BUS_H
+
+#include <linux/device.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/limits.h>
+
+
+extern struct bus_type cyttsp4_bus_type;
+
+struct cyttsp4_driver;
+struct cyttsp4_device;
+struct cyttsp4_adapter;
+
+enum cyttsp4_atten_type {
+	CY_ATTEN_IRQ,
+	CY_ATTEN_STARTUP,
+	CY_ATTEN_EXCLUSIVE,
+	CY_ATTEN_WAKE,
+	CY_ATTEN_NUM_ATTEN,
+};
+
+typedef int (*cyttsp4_atten_func) (struct cyttsp4_device *);
+
+struct cyttsp4_ops {
+	int (*write)(struct cyttsp4_adapter *dev, u16 addr,
+		const void *buf, int size, int max_xfer);
+	int (*read)(struct cyttsp4_adapter *dev, u16 addr, void *buf,
+		int size, int max_xfer);
+};
+
+struct cyttsp4_adapter {
+	struct list_head node;
+	char id[NAME_MAX];
+	struct device *dev;
+	int (*write)(struct cyttsp4_adapter *dev, u16 addr,
+		const void *buf, int size, int max_xfer);
+	int (*read)(struct cyttsp4_adapter *dev, u16 addr, void *buf,
+		int size, int max_xfer);
+};
+#define to_cyttsp4_adapter(d) container_of(d, struct cyttsp4_adapter, dev)
+
+struct cyttsp4_core_info {
+	char const *name;
+	char const *id;
+	char const *adap_id;
+	void *platform_data;
+};
+
+struct cyttsp4_core {
+	struct list_head node;
+	char const *name;
+	char const *id;
+	char const *adap_id;
+	struct device dev;
+	struct cyttsp4_adapter *adap;
+};
+#define to_cyttsp4_core(d) container_of(d, struct cyttsp4_core, dev)
+
+struct cyttsp4_device_info {
+	char const *name;
+	char const *core_id;
+	void *platform_data;
+};
+
+struct cyttsp4_device {
+	struct list_head node;
+	char const *name;
+	char const *core_id;
+	struct device dev;
+	struct cyttsp4_core *core;
+};
+#define to_cyttsp4_device(d) container_of(d, struct cyttsp4_device, dev)
+
+struct cyttsp4_core_driver {
+	struct device_driver driver;
+	int (*probe)(struct cyttsp4_core *core);
+	int (*remove)(struct cyttsp4_core *core);
+	int (*subscribe_attention)(struct cyttsp4_device *ttsp,
+				enum cyttsp4_atten_type type,
+				cyttsp4_atten_func func,
+				int flags);
+	int (*unsubscribe_attention)(struct cyttsp4_device *ttsp,
+				enum cyttsp4_atten_type type,
+				cyttsp4_atten_func func,
+				int flags);
+	int (*request_exclusive)(struct cyttsp4_device *ttsp, int timeout_ms);
+	int (*release_exclusive)(struct cyttsp4_device *ttsp);
+	int (*request_reset)(struct cyttsp4_device *ttsp);
+	int (*request_restart)(struct cyttsp4_device *ttsp, bool wait);
+	int (*request_set_mode)(struct cyttsp4_device *ttsp, int mode);
+	struct cyttsp4_sysinfo *(*request_sysinfo)(struct cyttsp4_device *ttsp);
+	struct cyttsp4_loader_platform_data
+		*(*request_loader_pdata)(struct cyttsp4_device *ttsp);
+	int (*request_handshake)(struct cyttsp4_device *ttsp, u8 mode);
+	int (*request_exec_cmd)(struct cyttsp4_device *ttsp, u8 mode,
+			u8 *cmd_buf, size_t cmd_size, u8 *return_buf,
+			size_t return_buf_size, int timeout_ms);
+	int (*request_stop_wd)(struct cyttsp4_device *ttsp);
+	int (*request_toggle_lowpower)(struct cyttsp4_device *ttsp, u8 mode);
+	int (*request_config_row_size)(struct cyttsp4_device *ttsp,
+			u16 *config_row_size);
+	int (*request_write_config)(struct cyttsp4_device *ttsp, u8 ebid,
+			u16 offset, u8 *data, u16 length);
+	int (*request_enable_scan_type)(struct cyttsp4_device *ttsp,
+			u8 scan_type);
+	int (*request_disable_scan_type)(struct cyttsp4_device *ttsp,
+			u8 scan_type);
+	const u8 *(*get_security_key)(struct cyttsp4_device *ttsp, int *size);
+	void (*get_touch_record)(struct cyttsp4_device *ttsp, int rec_no,
+			int *rec_abs);
+	int (*write)(struct cyttsp4_device *ttsp, int mode,
+		u16 addr, const void *buf, int size);
+	int (*read)(struct cyttsp4_device *ttsp, int mode,
+		u16 addr, void *buf, int size);
+};
+#define to_cyttsp4_core_driver(d) \
+	container_of(d, struct cyttsp4_core_driver, driver)
+
+struct cyttsp4_driver {
+	struct device_driver driver;
+	int (*probe)(struct cyttsp4_device *dev);
+	int (*remove)(struct cyttsp4_device *fev);
+};
+#define to_cyttsp4_driver(d) container_of(d, struct cyttsp4_driver, driver)
+
+extern int cyttsp4_register_driver(struct cyttsp4_driver *drv);
+extern void cyttsp4_unregister_driver(struct cyttsp4_driver *drv);
+
+extern int cyttsp4_register_core_driver(struct cyttsp4_core_driver *drv);
+extern void cyttsp4_unregister_core_driver(struct cyttsp4_core_driver *drv);
+
+extern int cyttsp4_register_device(struct cyttsp4_device_info const *dev_info);
+extern int cyttsp4_unregister_device(char const *name, char const *core_id);
+
+extern int cyttsp4_register_core_device(
+		struct cyttsp4_core_info const *core_info);
+
+extern int cyttsp4_add_adapter(char const *id, struct cyttsp4_ops const *ops,
+		struct device *parent);
+
+extern int cyttsp4_del_adapter(char const *id);
+
+static inline int cyttsp4_read(struct cyttsp4_device *ttsp, int mode, u16 addr,
+		void *buf, int size)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->read(ttsp, mode, addr, buf, size);
+}
+
+static inline int cyttsp4_write(struct cyttsp4_device *ttsp, int mode, u16 addr,
+		const void *buf, int size)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->write(ttsp, mode, addr, buf, size);
+}
+
+static inline int cyttsp4_subscribe_attention(struct cyttsp4_device *ttsp,
+		enum cyttsp4_atten_type type, cyttsp4_atten_func func,
+		int flags)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->subscribe_attention(ttsp, type, func, flags);
+}
+
+static inline int cyttsp4_unsubscribe_attention(struct cyttsp4_device *ttsp,
+		enum cyttsp4_atten_type type, cyttsp4_atten_func func,
+		int flags)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->unsubscribe_attention(ttsp, type, func, flags);
+}
+
+static inline int cyttsp4_request_exclusive(struct cyttsp4_device *ttsp,
+		int timeout_ms)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_exclusive(ttsp, timeout_ms);
+}
+
+static inline int cyttsp4_release_exclusive(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->release_exclusive(ttsp);
+}
+
+static inline int cyttsp4_request_reset(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_reset(ttsp);
+}
+
+static inline int cyttsp4_request_restart(struct cyttsp4_device *ttsp,
+		bool wait)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_restart(ttsp, wait);
+}
+
+static inline int cyttsp4_request_set_mode(struct cyttsp4_device *ttsp,
+		int mode)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_set_mode(ttsp, mode);
+}
+
+static inline struct cyttsp4_sysinfo *cyttsp4_request_sysinfo(
+		struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_sysinfo(ttsp);
+}
+
+static inline struct cyttsp4_loader_platform_data *cyttsp4_request_loader_pdata(
+		struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_loader_pdata(ttsp);
+}
+
+static inline int cyttsp4_request_handshake(struct cyttsp4_device *ttsp,
+		u8 mode)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_handshake(ttsp, mode);
+}
+
+static inline int cyttsp4_request_exec_cmd(struct cyttsp4_device *ttsp,
+		u8 mode, u8 *cmd_buf, size_t cmd_size, u8 *return_buf,
+		size_t return_buf_size, int timeout_ms)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_exec_cmd(ttsp, mode, cmd_buf, cmd_size, return_buf,
+			return_buf_size, timeout_ms);
+}
+
+static inline int cyttsp4_request_stop_wd(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_stop_wd(ttsp);
+}
+
+static inline int cyttsp4_request_toggle_lowpower(struct cyttsp4_device *ttsp,
+		u8 mode)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_toggle_lowpower(ttsp, mode);
+}
+
+static inline int cyttsp4_request_config_row_size(struct cyttsp4_device *ttsp,
+		u16 *config_row_size)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_config_row_size(ttsp, config_row_size);
+}
+
+static inline int cyttsp4_request_write_config(struct cyttsp4_device *ttsp,
+		u8 ebid, u16 offset, u8 *data, u16 length)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_write_config(ttsp, ebid, offset, data, length);
+}
+
+static inline int cyttsp4_request_enable_scan_type(struct cyttsp4_device *ttsp,
+		u8 scan_type)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_enable_scan_type(ttsp, scan_type);
+}
+
+static inline int cyttsp4_request_disable_scan_type(struct cyttsp4_device *ttsp,
+		u8 scan_type)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_disable_scan_type(ttsp, scan_type);
+}
+
+static inline const u8 *cyttsp4_get_security_key(struct cyttsp4_device *ttsp,
+		int *size)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->get_security_key(ttsp, size);
+}
+
+static inline void cyttsp4_get_touch_record(struct cyttsp4_device *ttsp,
+		int rec_no, int *rec_abs)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	d->get_touch_record(ttsp, rec_no, rec_abs);
+}
+#endif /* _LINUX_CYTTSP4_BUS_H */
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_core.c b/drivers/input/touchscreen/cyttsp4/cyttsp4_core.c
new file mode 100755
index 0000000..be71127
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_core.c
@@ -0,0 +1,4187 @@
+/*
+ * cyttsp4_core.c
+ * Cypress TrueTouch(TM) Standard Product V4 Core driver module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ * Modified by: Cypress Semiconductor to add device functions
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include "cyttsp4_bus.h"
+
+#include <asm/unaligned.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/limits.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/of_gpio.h>
+
+#include "cyttsp4_core.h"
+#include "cyttsp4_regs.h"
+#if defined(CONFIG_FB)
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+#include <linux/earlysuspend.h>
+#endif
+
+#define ZTEMT_TP_WAKEUP_GESTURE_FUNCTION	0		//add by luochangyang
+
+#define CY_CORE_REQUEST_EXCLUSIVE_TIMEOUT	500
+#define CY_CORE_SLEEP_REQUEST_EXCLUSIVE_TIMEOUT	5000
+#define CY_CORE_MODE_CHANGE_TIMEOUT		3000//1000
+#define CY_CORE_RESET_AND_WAIT_TIMEOUT  500
+#define CY_CORE_WAKEUP_TIMEOUT			50
+#define CY_CORE_BL_HOST_SYNC_BYTE       0xFF
+#define CY_CORE_STARTUP_RETRY_COUNT		3
+
+#define IS_DEEP_SLEEP_CONFIGURED(x) \
+		((x) == 0 || (x) == 0xFF)
+
+#define IS_TMO(t)	((t) == 0)
+
+#define PUT_FIELD16(si, val, addr) \
+do { \
+	if (IS_LITTLEENDIAN((si)->si_ptrs.cydata->device_info)) \
+		put_unaligned_le16(val, addr); \
+	else \
+		put_unaligned_be16(val, addr); \
+} while (0)
+
+#define GET_FIELD16(si, addr) \
+({ \
+	u16 __val; \
+	if (IS_LITTLEENDIAN((si)->si_ptrs.cydata->device_info)) \
+		__val = get_unaligned_le16(addr); \
+	else \
+		__val = get_unaligned_be16(addr); \
+	__val; \
+})
+
+#define RETRY_OR_EXIT(retry_cnt, retry_label, exit_label) \
+do { \
+	if (retry_cnt) \
+		goto retry_label; \
+	goto exit_label; \
+} while (0)
+
+static const u8 security_key[] = {
+	0xA5, 0x01, 0x02, 0x03, 0xFF, 0xFE, 0xFD, 0x5A
+};
+
+static const u8 ldr_exit[] = {
+	0xFF, 0x01, 0x3B, 0x00, 0x00, 0x4F, 0x6D, 0x17
+};
+
+static const u8 ldr_err_app[] = {
+	0x01, 0x02, 0x00, 0x00, 0x55, 0xDD, 0x17
+};
+
+MODULE_FIRMWARE(CY_FW_FILE_NAME);
+
+const char *cy_driver_core_name = CYTTSP4_CORE_NAME;
+const char *cy_driver_core_version = CY_DRIVER_VERSION;
+const char *cy_driver_core_date = CY_DRIVER_DATE;
+
+enum cyttsp4_sleep_state {
+	SS_SLEEP_OFF,
+	SS_SLEEP_ON,
+	SS_SLEEPING,
+	SS_WAKING,
+};
+
+enum cyttsp4_startup_state {
+	STARTUP_NONE,
+	STARTUP_QUEUED,
+	STARTUP_RUNNING,
+};
+
+struct cyttsp4_core_data {
+	struct device *dev;
+	struct cyttsp4_core *core;
+	struct list_head atten_list[CY_ATTEN_NUM_ATTEN];
+	struct mutex system_lock;
+	struct mutex adap_lock;
+	enum cyttsp4_mode mode;
+	enum cyttsp4_sleep_state sleep_state;
+	enum cyttsp4_startup_state startup_state;
+	int int_status;
+	int cmd_toggle;
+	spinlock_t spinlock;
+	struct cyttsp4_core_platform_data *pdata;
+	wait_queue_head_t wait_q;
+	int irq;
+	struct work_struct startup_work;
+	struct cyttsp4_sysinfo sysinfo;
+	void *exclusive_dev;
+	int exclusive_waits;
+	atomic_t ignore_irq;
+	bool irq_enabled;
+	bool irq_wake;
+	bool wake_initiated_by_device;
+	bool invalid_touch_app;
+	int max_xfer;
+	int apa_mc_en;
+	int glove_en;
+	int stylus_en;
+	int proximity_en;
+	u8 default_scantype;
+	u8 easy_wakeup_gesture;
+	unsigned int active_refresh_cycle_ms;
+	u8 heartbeat_count;
+#ifdef VERBOSE_DEBUG
+	u8 pr_buf[CY_MAX_PRBUF_SIZE];
+#endif
+	struct work_struct watchdog_work;
+	struct timer_list watchdog_timer;
+	/* ZTEMT Added by luochangyang, 2013/07/10 */
+#if defined(CONFIG_FB)
+    struct notifier_block fb_notif;
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	struct early_suspend es;
+#endif/* ZTEMT END */
+};
+
+struct atten_node {
+	struct list_head node;
+	int (*func)(struct cyttsp4_device *);
+	struct cyttsp4_device *ttsp;
+	int mode;
+};
+
+static int _cyttsp4_put_device_into_deep_sleep(struct cyttsp4_core_data *cd,
+		u8 hst_mode_reg);
+/*** ZTEMT Added by luochangyang, 2013/10/29 ***/
+static int _cyttsp4_put_device_into_easy_wakeup(struct cyttsp4_core_data *cd);
+/***ZTEMT END***/
+
+static inline size_t merge_bytes(u8 high, u8 low)
+{
+	return (high << 8) + low;
+}
+
+#ifdef VERBOSE_DEBUG
+void cyttsp4_pr_buf(struct device *dev, u8 *pr_buf, u8 *dptr, int size,
+		const char *data_name)
+{
+	int i, k;
+	const char fmt[] = "%02X ";
+	int max;
+
+	if (!size)
+		return;
+
+	max = (CY_MAX_PRBUF_SIZE - 1) - sizeof(CY_PR_TRUNCATED);
+
+	pr_buf[0] = 0;
+	for (i = k = 0; i < size && k < max; i++, k += 3)
+		scnprintf(pr_buf + k, CY_MAX_PRBUF_SIZE, fmt, dptr[i]);
+
+	dev_vdbg(dev, "%s:  %s[0..%d]=%s%s\n", __func__, data_name, size - 1,
+			pr_buf, size <= max ? "" : CY_PR_TRUNCATED);
+}
+EXPORT_SYMBOL_GPL(cyttsp4_pr_buf);
+#endif
+
+static inline int cyttsp4_adap_read(struct cyttsp4_core_data *cd, u16 addr,
+		void *buf, int size)
+{
+	return cd->core->adap->read(cd->core->adap, addr, buf, size,
+			cd->max_xfer);
+}
+
+static inline int cyttsp4_adap_write(struct cyttsp4_core_data *cd, u16 addr,
+		const void *buf, int size)
+{
+	return cd->core->adap->write(cd->core->adap, addr, buf, size,
+			cd->max_xfer);
+}
+
+/* cyttsp4_platform_detect_read()
+ *
+ * This function is passed to platform detect
+ * function to perform a read operation
+ */
+static int cyttsp4_platform_detect_read(struct device *dev, u16 addr,
+		void *buf, int size)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	return cd->core->adap->read(cd->core->adap, addr, buf, size,
+			cd->max_xfer);
+}
+
+static u16 cyttsp4_calc_partial_app_crc(const u8 *data, int size, u16 crc)
+{
+	int i, j;
+
+	for (i = 0; i < size; i++) {
+		crc ^= ((u16)data[i] << 8);
+		for (j = 8; j > 0; j--)
+			if (crc & 0x8000)
+				crc = (crc << 1) ^ 0x1021;
+			else
+				crc <<= 1;
+	}
+
+	return crc;
+}
+
+static inline u16 cyttsp4_calc_app_crc(const u8 *data, int size)
+{
+	return cyttsp4_calc_partial_app_crc(data, size, 0xFFFF);
+}
+
+static const u8 *cyttsp4_get_security_key_(struct cyttsp4_device *ttsp,
+		int *size)
+{
+	if (size)
+		*size = sizeof(security_key);
+
+	return security_key;
+}
+
+static inline void cyttsp4_get_touch_axis(struct cyttsp4_core_data *cd,
+		int *axis, int size, int max, u8 *xy_data, int bofs)
+{
+	int nbyte;
+	int next;
+
+	for (nbyte = 0, *axis = 0, next = 0; nbyte < size; nbyte++) {
+		dev_vdbg(cd->dev,
+			"%s: *axis=%02X(%d) size=%d max=%08X xy_data=%p"
+			" xy_data[%d]=%02X(%d) bofs=%d\n",
+			__func__, *axis, *axis, size, max, xy_data, next,
+			xy_data[next], xy_data[next], bofs);
+		*axis = (*axis * 256) + (xy_data[next] >> bofs);
+		next++;
+	}
+
+	*axis &= max - 1;
+
+	dev_vdbg(cd->dev,
+		"%s: *axis=%02X(%d) size=%d max=%08X xy_data=%p"
+		" xy_data[%d]=%02X(%d)\n",
+		__func__, *axis, *axis, size, max, xy_data, next,
+		xy_data[next], xy_data[next]);
+}
+
+/*
+ * cyttsp4_get_touch_record_()
+ *
+ * Fills touch info for a touch record specified by rec_no
+ * Should only be called in Operational mode IRQ attention and
+ * rec_no should be less than the number of current touch records
+ */
+static void cyttsp4_get_touch_record_(struct cyttsp4_device *ttsp,
+		int rec_no, int *rec_abs)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	struct device *dev = cd->dev;
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	u8 *xy_data = si->xy_data + (rec_no * si->si_ofs.tch_rec_size);
+	enum cyttsp4_tch_abs abs;
+
+	memset(rec_abs, 0, CY_TCH_NUM_ABS * sizeof(int));
+	for (abs = CY_TCH_X; abs < CY_TCH_NUM_ABS; abs++) {
+		cyttsp4_get_touch_axis(cd, &rec_abs[abs],
+			si->si_ofs.tch_abs[abs].size,
+			si->si_ofs.tch_abs[abs].max,
+			xy_data + si->si_ofs.tch_abs[abs].ofs,
+			si->si_ofs.tch_abs[abs].bofs);
+		dev_vdbg(dev, "%s: get %s=%04X(%d)\n", __func__,
+			cyttsp4_tch_abs_string[abs],
+			rec_abs[abs], rec_abs[abs]);
+	}
+}
+
+static int cyttsp4_load_status_and_touch_regs(struct cyttsp4_core_data *cd,
+		bool optimize)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	struct device *dev = cd->dev;
+	int first_read_len;
+	int second_read_off;
+	int num_read_rec;
+	u8 num_cur_rec;
+	u8 hst_mode;
+	u8 rep_len;
+	u8 rep_stat;
+	u8 tt_stat;
+	int rc;
+
+	if (!si->xy_mode) {
+		dev_err(cd->dev, "%s: NULL xy_mode pointer\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	first_read_len = si->si_ofs.rep_hdr_size;
+	/* Read one touch record additionally */
+	if (optimize)
+		first_read_len += si->si_ofs.tch_rec_size;
+
+	rc = cyttsp4_adap_read(cd, si->si_ofs.rep_ofs,
+			&si->xy_mode[si->si_ofs.rep_ofs], first_read_len);
+	if (rc < 0) {
+		dev_err(dev, "%s: fail read mode regs r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	/* print xy data */
+	cyttsp4_pr_buf(dev, cd->pr_buf, si->xy_mode,
+		si->si_ofs.mode_size, "xy_mode");
+
+	hst_mode = si->xy_mode[CY_REG_BASE];
+	rep_len = si->xy_mode[si->si_ofs.rep_ofs];
+	rep_stat = si->xy_mode[si->si_ofs.rep_ofs + 1];
+	tt_stat = si->xy_mode[si->si_ofs.tt_stat_ofs];
+	dev_vdbg(dev, "%s: %s%02X %s%d %s%02X %s%02X\n", __func__,
+		"hst_mode=", hst_mode, "rep_len=", rep_len,
+		"rep_stat=", rep_stat, "tt_stat=", tt_stat);
+
+	num_cur_rec = GET_NUM_TOUCH_RECORDS(tt_stat);
+	dev_vdbg(dev, "%s: num_cur_rec=%d\n", __func__, num_cur_rec);
+
+	if (rep_len == 0 && num_cur_rec > 0) {
+		dev_err(dev, "%s: report length error rep_len=%d num_rec=%d\n",
+			__func__, rep_len, num_cur_rec);
+		return -EIO;
+	}
+
+	num_read_rec = num_cur_rec;
+	second_read_off = si->si_ofs.tt_stat_ofs + 1;
+	if (optimize) {
+		num_read_rec--;
+		second_read_off += si->si_ofs.tch_rec_size;
+	}
+
+	if (num_read_rec <= 0)
+		goto exit_print;
+
+	rc = cyttsp4_adap_read(cd, second_read_off,
+			&si->xy_mode[second_read_off],
+			num_read_rec * si->si_ofs.tch_rec_size);
+	if (rc < 0) {
+		dev_err(dev, "%s: read fail on touch regs r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+exit_print:
+	/* print xy data */
+	cyttsp4_pr_buf(dev, cd->pr_buf, si->xy_data,
+		num_cur_rec * si->si_ofs.tch_rec_size, "xy_data");
+
+	return 0;
+}
+
+static int cyttsp4_handshake(struct cyttsp4_core_data *cd, u8 mode)
+{
+	u8 cmd = mode ^ CY_HST_TOGGLE;
+	int rc;
+
+	if (mode & CY_HST_MODE_CHANGE) {
+		dev_err(cd->dev, "%s: Host mode change bit set, NO handshake\n",
+				__func__);
+		return 0;
+	}
+
+	rc = cyttsp4_adap_write(cd, CY_REG_BASE, &cmd, sizeof(cmd));
+	if (rc < 0)
+		dev_err(cd->dev, "%s: bus write fail on handshake (ret=%d)\n",
+				__func__, rc);
+
+	return rc;
+}
+
+static int cyttsp4_toggle_low_power_(struct cyttsp4_core_data *cd, u8 mode)
+{
+	u8 cmd = mode ^ CY_HST_LOWPOW;
+
+	int rc = cyttsp4_adap_write(cd, CY_REG_BASE, &cmd, sizeof(cmd));
+	if (rc < 0)
+		dev_err(cd->dev,
+			"%s: bus write fail on toggle low power (ret=%d)\n",
+			__func__, rc);
+	return rc;
+}
+
+static int cyttsp4_toggle_low_power(struct cyttsp4_core_data *cd, u8 mode)
+{
+	int rc;
+
+	mutex_lock(&cd->system_lock);
+	rc = cyttsp4_toggle_low_power_(cd, mode);
+	mutex_unlock(&cd->system_lock);
+
+	return rc;
+}
+
+static int cyttsp4_hw_soft_reset_(struct cyttsp4_core_data *cd)
+{
+	u8 cmd = CY_HST_RESET;
+
+	int rc = cyttsp4_adap_write(cd, CY_REG_BASE, &cmd, sizeof(cmd));
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: FAILED to execute SOFT reset\n",
+				__func__);
+		return rc;
+	}
+	dev_dbg(cd->dev, "%s: execute SOFT reset\n", __func__);
+	return 0;
+}
+
+static int cyttsp4_hw_soft_reset(struct cyttsp4_core_data *cd)
+{
+	int rc;
+
+	mutex_lock(&cd->system_lock);
+	rc = cyttsp4_hw_soft_reset_(cd);
+	mutex_unlock(&cd->system_lock);
+
+	return rc;
+}
+
+static int cyttsp4_hw_hard_reset_(struct cyttsp4_core_data *cd)
+{
+	if (cd->pdata->xres) {
+		cd->pdata->xres(cd->pdata, cd->dev);
+		dev_dbg(cd->dev, "%s: execute HARD reset\n", __func__);
+		return 0;
+	}
+	dev_err(cd->dev, "%s: FAILED to execute HARD reset\n", __func__);
+	return -ENOSYS;
+}
+
+static int cyttsp4_hw_hard_reset(struct cyttsp4_core_data *cd)
+{
+	int rc;
+
+	mutex_lock(&cd->system_lock);
+	rc = cyttsp4_hw_hard_reset_(cd);
+	mutex_unlock(&cd->system_lock);
+
+	return rc;
+}
+
+static int cyttsp4_hw_reset_(struct cyttsp4_core_data *cd)
+{
+	int rc = cyttsp4_hw_hard_reset_(cd);
+	if (rc == -ENOSYS)
+		rc = cyttsp4_hw_soft_reset_(cd);
+	return rc;
+}
+
+static inline int cyttsp4_bits_2_bytes(int nbits, int *max)
+{
+	*max = 1 << nbits;
+	return (nbits + 7) / 8;
+}
+
+static int cyttsp4_si_data_offsets(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	int rc = cyttsp4_adap_read(cd, CY_REG_BASE, &si->si_data,
+				   sizeof(si->si_data));
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail read sysinfo data offsets r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	/* Print sysinfo data offsets */
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf, (u8 *)&si->si_data,
+		       sizeof(si->si_data), "sysinfo_data_offsets");
+
+	/* convert sysinfo data offset bytes into integers */
+
+	si->si_ofs.map_sz = merge_bytes(si->si_data.map_szh,
+			si->si_data.map_szl);
+	si->si_ofs.map_sz = merge_bytes(si->si_data.map_szh,
+			si->si_data.map_szl);
+	si->si_ofs.cydata_ofs = merge_bytes(si->si_data.cydata_ofsh,
+			si->si_data.cydata_ofsl);
+	si->si_ofs.test_ofs = merge_bytes(si->si_data.test_ofsh,
+			si->si_data.test_ofsl);
+	si->si_ofs.pcfg_ofs = merge_bytes(si->si_data.pcfg_ofsh,
+			si->si_data.pcfg_ofsl);
+	si->si_ofs.opcfg_ofs = merge_bytes(si->si_data.opcfg_ofsh,
+			si->si_data.opcfg_ofsl);
+	si->si_ofs.ddata_ofs = merge_bytes(si->si_data.ddata_ofsh,
+			si->si_data.ddata_ofsl);
+	si->si_ofs.mdata_ofs = merge_bytes(si->si_data.mdata_ofsh,
+			si->si_data.mdata_ofsl);
+	return rc;
+}
+
+static int cyttsp4_si_get_cydata(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	int read_offset;
+	int mfgid_sz, calc_mfgid_sz;
+	void *p;
+	int rc;
+    struct cyttsp4_cydata *cydata;//add by luochangyang
+
+	si->si_ofs.cydata_size = si->si_ofs.test_ofs - si->si_ofs.cydata_ofs;
+	dev_dbg(cd->dev, "%s: cydata size: %d\n", __func__,
+			si->si_ofs.cydata_size);
+
+	if (si->si_ofs.cydata_size <= 0)
+		return -EINVAL;
+
+	p = krealloc(si->si_ptrs.cydata, si->si_ofs.cydata_size, GFP_KERNEL);
+	if (p == NULL) {
+		dev_err(cd->dev, "%s: fail alloc cydata memory\n", __func__);
+		return -ENOMEM;
+	}
+	si->si_ptrs.cydata = p;
+
+	read_offset = si->si_ofs.cydata_ofs;
+
+	/* Read the CYDA registers up to MFGID field */
+	rc = cyttsp4_adap_read(cd, read_offset, si->si_ptrs.cydata,
+			offsetof(struct cyttsp4_cydata, mfgid_sz)
+			+ sizeof(si->si_ptrs.cydata->mfgid_sz));
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail read cydata r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	/* Check MFGID size */
+	mfgid_sz = si->si_ptrs.cydata->mfgid_sz;
+	calc_mfgid_sz = si->si_ofs.cydata_size - sizeof(struct cyttsp4_cydata);
+	if (mfgid_sz != calc_mfgid_sz) {
+		dev_err(cd->dev, "%s: mismatch in MFGID size, reported:%d calculated:%d\n",
+			__func__, mfgid_sz, calc_mfgid_sz);
+		return -EINVAL;
+	}
+
+	read_offset += offsetof(struct cyttsp4_cydata, mfgid_sz)
+			+ sizeof(si->si_ptrs.cydata->mfgid_sz);
+
+	/* Read the CYDA registers for MFGID field */
+	rc = cyttsp4_adap_read(cd, read_offset, si->si_ptrs.cydata->mfg_id,
+			si->si_ptrs.cydata->mfgid_sz);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail read cydata r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	read_offset += si->si_ptrs.cydata->mfgid_sz;
+
+	/* Read the rest of the CYDA registers */
+	rc = cyttsp4_adap_read(cd, read_offset, &si->si_ptrs.cydata->cyito_idh,
+			sizeof(struct cyttsp4_cydata)
+			- offsetof(struct cyttsp4_cydata, cyito_idh));
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail read cydata r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+    /*** ZTEMT Added by luochangyang, 2013/04/08 ***/    
+	cydata = cd->sysinfo.si_ptrs.cydata;
+	dev_dbg(cd->dev, 
+		"%s: 0x%04X\n"
+		"%s: 0x%04X\n"
+		"%s: 0x%02X 0x%02X\n"
+		"%s: 0x%02X\n"
+		"%s: 0x%02X\n"
+		"%s: 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\n"
+		"%s: 0x%04X\n"
+		"%s: 0x%02X\n"
+		"%s: 0x%02X\n",
+		"CYTTSP4 FW VER (in TP)",cd->sysinfo.fw_ver,
+		"CYTTSP4 FW VER (in Driver)",cd->sysinfo.fw_ver_new,
+		"TrueTouch Product ID", cydata->ttpidh, cydata->ttpidl,
+		"Firmware Major Version", cydata->fw_ver_major,
+		"Firmware Minor Version", cydata->fw_ver_minor,
+		"Revision Control Number", cydata->revctrl[0],
+		cydata->revctrl[1], cydata->revctrl[2], cydata->revctrl[3],
+		cydata->revctrl[4], cydata->revctrl[5], cydata->revctrl[6],
+		cydata->revctrl[7],
+		"TrueTouch Config Version", cd->sysinfo.ttconfig.version,
+		"Bootloader Major Version", cydata->blver_major,
+		"Bootloader Minor Version", cydata->blver_minor);
+    /***ZTEMT END***/
+
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf, (u8 *)si->si_ptrs.cydata,
+		si->si_ofs.cydata_size - mfgid_sz, "sysinfo_cydata");
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf, si->si_ptrs.cydata->mfg_id,
+		mfgid_sz, "sysinfo_cydata_mfgid");
+	return rc;
+}
+
+static int cyttsp4_si_get_test_data(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	void *p;
+	int rc;
+
+	si->si_ofs.test_size = si->si_ofs.pcfg_ofs - si->si_ofs.test_ofs;
+
+	if (si->si_ofs.test_size <= 0)
+		return -EINVAL;
+
+	p = krealloc(si->si_ptrs.test, si->si_ofs.test_size, GFP_KERNEL);
+	if (p == NULL) {
+		dev_err(cd->dev, "%s: fail alloc test memory\n", __func__);
+		return -ENOMEM;
+	}
+	si->si_ptrs.test = p;
+
+	rc = cyttsp4_adap_read(cd, si->si_ofs.test_ofs, si->si_ptrs.test,
+			si->si_ofs.test_size);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail read test data r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf,
+		       (u8 *)si->si_ptrs.test, si->si_ofs.test_size,
+		       "sysinfo_test_data");
+	if (si->si_ptrs.test->post_codel &
+	    CY_POST_CODEL_WDG_RST)
+		dev_info(cd->dev, "%s: %s codel=%02X\n",
+			 __func__, "Reset was a WATCHDOG RESET",
+			 si->si_ptrs.test->post_codel);
+
+	if (!(si->si_ptrs.test->post_codel &
+	      CY_POST_CODEL_CFG_DATA_CRC_FAIL))
+		dev_info(cd->dev, "%s: %s codel=%02X\n", __func__,
+			 "Config Data CRC FAIL",
+			 si->si_ptrs.test->post_codel);
+
+	if (!(si->si_ptrs.test->post_codel &
+	      CY_POST_CODEL_PANEL_TEST_FAIL))
+		dev_info(cd->dev, "%s: %s codel=%02X\n",
+			 __func__, "PANEL TEST FAIL",
+			 si->si_ptrs.test->post_codel);
+
+	dev_dbg(cd->dev, "%s: SCANNING is %s codel=%02X\n",
+		 __func__, si->si_ptrs.test->post_codel & 0x08 ?
+		 "ENABLED" : "DISABLED",
+		 si->si_ptrs.test->post_codel);
+	return rc;
+}
+
+static int cyttsp4_si_get_pcfg_data(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	void *p;
+	int rc;
+
+	dev_vdbg(cd->dev, "%s: get pcfg data\n", __func__);
+	si->si_ofs.pcfg_size = si->si_ofs.opcfg_ofs - si->si_ofs.pcfg_ofs;
+
+	if (si->si_ofs.pcfg_size <= 0)
+		return -EINVAL;
+
+	p = krealloc(si->si_ptrs.pcfg, si->si_ofs.pcfg_size, GFP_KERNEL);
+	if (p == NULL) {
+		rc = -ENOMEM;
+		dev_err(cd->dev, "%s: fail alloc pcfg memory r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+	si->si_ptrs.pcfg = p;
+
+	rc = cyttsp4_adap_read(cd, si->si_ofs.pcfg_ofs, si->si_ptrs.pcfg,
+			si->si_ofs.pcfg_size);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail read pcfg data r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	si->si_ofs.max_x = merge_bytes((si->si_ptrs.pcfg->res_xh
+			& CY_PCFG_RESOLUTION_X_MASK), si->si_ptrs.pcfg->res_xl);
+	si->si_ofs.x_origin = !!(si->si_ptrs.pcfg->res_xh
+			& CY_PCFG_ORIGIN_X_MASK);
+	si->si_ofs.max_y = merge_bytes((si->si_ptrs.pcfg->res_yh
+			& CY_PCFG_RESOLUTION_Y_MASK), si->si_ptrs.pcfg->res_yl);
+	si->si_ofs.y_origin = !!(si->si_ptrs.pcfg->res_yh
+			& CY_PCFG_ORIGIN_Y_MASK);
+	si->si_ofs.max_p = merge_bytes(si->si_ptrs.pcfg->max_zh,
+			si->si_ptrs.pcfg->max_zl);
+
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf,
+		       (u8 *)si->si_ptrs.pcfg,
+		       si->si_ofs.pcfg_size, "sysinfo_pcfg_data");
+	return rc;
+}
+
+static int cyttsp4_si_get_opcfg_data(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	int i;
+	enum cyttsp4_tch_abs abs;
+	void *p;
+	int rc;
+
+	dev_vdbg(cd->dev, "%s: get opcfg data\n", __func__);
+	si->si_ofs.opcfg_size = si->si_ofs.ddata_ofs - si->si_ofs.opcfg_ofs;
+
+	if (si->si_ofs.opcfg_size <= 0)
+		return -EINVAL;
+
+	p = krealloc(si->si_ptrs.opcfg, si->si_ofs.opcfg_size, GFP_KERNEL);
+	if (p == NULL) {
+		dev_err(cd->dev, "%s: fail alloc opcfg memory\n", __func__);
+		rc = -ENOMEM;
+		goto cyttsp4_si_get_opcfg_data_exit;
+	}
+	si->si_ptrs.opcfg = p;
+
+	rc = cyttsp4_adap_read(cd, si->si_ofs.opcfg_ofs, si->si_ptrs.opcfg,
+			si->si_ofs.opcfg_size);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail read opcfg data r=%d\n",
+			__func__, rc);
+		goto cyttsp4_si_get_opcfg_data_exit;
+	}
+	si->si_ofs.cmd_ofs = si->si_ptrs.opcfg->cmd_ofs;
+	si->si_ofs.rep_ofs = si->si_ptrs.opcfg->rep_ofs;
+	si->si_ofs.rep_sz = (si->si_ptrs.opcfg->rep_szh * 256) +
+		si->si_ptrs.opcfg->rep_szl;
+	si->si_ofs.num_btns = si->si_ptrs.opcfg->num_btns;
+	si->si_ofs.num_btn_regs = (si->si_ofs.num_btns +
+		CY_NUM_BTN_PER_REG - 1) / CY_NUM_BTN_PER_REG;
+	si->si_ofs.tt_stat_ofs = si->si_ptrs.opcfg->tt_stat_ofs;
+	si->si_ofs.obj_cfg0 = si->si_ptrs.opcfg->obj_cfg0;
+	si->si_ofs.max_tchs = si->si_ptrs.opcfg->max_tchs &
+		CY_BYTE_OFS_MASK;
+	si->si_ofs.tch_rec_size = si->si_ptrs.opcfg->tch_rec_size &
+		CY_BYTE_OFS_MASK;
+
+	/* Get the old touch fields */
+	for (abs = CY_TCH_X; abs < CY_NUM_TCH_FIELDS; abs++) {
+		si->si_ofs.tch_abs[abs].ofs =
+			si->si_ptrs.opcfg->tch_rec_old[abs].loc &
+			CY_BYTE_OFS_MASK;
+		si->si_ofs.tch_abs[abs].size =
+			cyttsp4_bits_2_bytes
+			(si->si_ptrs.opcfg->tch_rec_old[abs].size,
+			&si->si_ofs.tch_abs[abs].max);
+		si->si_ofs.tch_abs[abs].bofs =
+			(si->si_ptrs.opcfg->tch_rec_old[abs].loc &
+			CY_BOFS_MASK) >> CY_BOFS_SHIFT;
+	}
+
+	/* button fields */
+	si->si_ofs.btn_rec_size = si->si_ptrs.opcfg->btn_rec_size;
+	si->si_ofs.btn_diff_ofs = si->si_ptrs.opcfg->btn_diff_ofs;
+	si->si_ofs.btn_diff_size = si->si_ptrs.opcfg->btn_diff_size;
+
+	if (IS_TTSP_VER_GE(si, 2, 3)) {
+		/* Get the extended touch fields */
+		for (i = 0; i < CY_NUM_EXT_TCH_FIELDS; abs++, i++) {
+			si->si_ofs.tch_abs[abs].ofs =
+				si->si_ptrs.opcfg->tch_rec_new[i].loc &
+				CY_BYTE_OFS_MASK;
+			si->si_ofs.tch_abs[abs].size =
+				cyttsp4_bits_2_bytes
+				(si->si_ptrs.opcfg->tch_rec_new[i].size,
+				&si->si_ofs.tch_abs[abs].max);
+			si->si_ofs.tch_abs[abs].bofs =
+				(si->si_ptrs.opcfg->tch_rec_new[i].loc
+				& CY_BOFS_MASK) >> CY_BOFS_SHIFT;
+		}
+	}
+
+	if (IS_TTSP_VER_GE(si, 2, 4)) {
+		si->si_ofs.noise_data_ofs = si->si_ptrs.opcfg->noise_data_ofs;
+		si->si_ofs.noise_data_sz = si->si_ptrs.opcfg->noise_data_sz;
+	}
+
+	for (abs = 0; abs < CY_TCH_NUM_ABS; abs++) {
+		dev_dbg(cd->dev, "%s: tch_rec_%s\n", __func__,
+			cyttsp4_tch_abs_string[abs]);
+		dev_dbg(cd->dev, "%s:     ofs =%2d\n", __func__,
+			si->si_ofs.tch_abs[abs].ofs);
+		dev_dbg(cd->dev, "%s:     siz =%2d\n", __func__,
+			si->si_ofs.tch_abs[abs].size);
+		dev_dbg(cd->dev, "%s:     max =%2d\n", __func__,
+			si->si_ofs.tch_abs[abs].max);
+		dev_dbg(cd->dev, "%s:     bofs=%2d\n", __func__,
+			si->si_ofs.tch_abs[abs].bofs);
+	}
+
+	si->si_ofs.mode_size = si->si_ofs.tt_stat_ofs + 1;
+	si->si_ofs.data_size = si->si_ofs.max_tchs *
+		si->si_ptrs.opcfg->tch_rec_size;
+	si->si_ofs.rep_hdr_size = si->si_ofs.mode_size - si->si_ofs.rep_ofs;
+
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf, (u8 *)si->si_ptrs.opcfg,
+		si->si_ofs.opcfg_size, "sysinfo_opcfg_data");
+
+cyttsp4_si_get_opcfg_data_exit:
+	return rc;
+}
+
+static int cyttsp4_si_get_ddata(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	void *p;
+	int rc;
+
+	dev_vdbg(cd->dev, "%s: get ddata data\n", __func__);
+	si->si_ofs.ddata_size = si->si_ofs.mdata_ofs - si->si_ofs.ddata_ofs;
+
+	if (si->si_ofs.ddata_size <= 0)
+		return -EINVAL;
+
+	p = krealloc(si->si_ptrs.ddata, si->si_ofs.ddata_size, GFP_KERNEL);
+	if (p == NULL) {
+		dev_err(cd->dev, "%s: fail alloc ddata memory\n", __func__);
+		return -ENOMEM;
+	}
+	si->si_ptrs.ddata = p;
+
+	rc = cyttsp4_adap_read(cd, si->si_ofs.ddata_ofs, si->si_ptrs.ddata,
+			si->si_ofs.ddata_size);
+	if (rc < 0)
+		dev_err(cd->dev, "%s: fail read ddata data r=%d\n",
+			__func__, rc);
+	else
+		cyttsp4_pr_buf(cd->dev, cd->pr_buf,
+			       (u8 *)si->si_ptrs.ddata,
+			       si->si_ofs.ddata_size, "sysinfo_ddata");
+	return rc;
+}
+
+static int cyttsp4_si_get_mdata(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	void *p;
+	int rc;
+
+	dev_vdbg(cd->dev, "%s: get mdata data\n", __func__);
+	si->si_ofs.mdata_size = si->si_ofs.map_sz - si->si_ofs.mdata_ofs;
+
+	if (si->si_ofs.mdata_size <= 0)
+		return -EINVAL;
+
+	p = krealloc(si->si_ptrs.mdata, si->si_ofs.mdata_size, GFP_KERNEL);
+	if (p == NULL) {
+		dev_err(cd->dev, "%s: fail alloc mdata memory\n", __func__);
+		return -ENOMEM;
+	}
+	si->si_ptrs.mdata = p;
+
+	rc = cyttsp4_adap_read(cd, si->si_ofs.mdata_ofs, si->si_ptrs.mdata,
+			si->si_ofs.mdata_size);
+	if (rc < 0)
+		dev_err(cd->dev, "%s: fail read mdata data r=%d\n",
+			__func__, rc);
+	else
+		cyttsp4_pr_buf(cd->dev, cd->pr_buf,
+			       (u8 *)si->si_ptrs.mdata,
+			       si->si_ofs.mdata_size, "sysinfo_mdata");
+	return rc;
+}
+
+static int cyttsp4_si_get_btn_data(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	int btn;
+	int num_defined_keys;
+	u16 *key_table;
+	void *p;
+	int rc = 0;
+
+	dev_vdbg(cd->dev, "%s: get btn data\n", __func__);
+
+	if (!si->si_ofs.num_btns) {
+		si->si_ofs.btn_keys_size = 0;
+		kfree(si->btn);
+		si->btn = NULL;
+		return rc;
+	}
+
+	si->si_ofs.btn_keys_size = si->si_ofs.num_btns *
+		sizeof(struct cyttsp4_btn);
+
+	if (si->si_ofs.btn_keys_size <= 0)
+		return -EINVAL;
+
+	p = krealloc(si->btn, si->si_ofs.btn_keys_size, GFP_KERNEL|__GFP_ZERO);
+	if (p == NULL) {
+		dev_err(cd->dev, "%s: %s\n", __func__,
+			"fail alloc btn_keys memory");
+		return -ENOMEM;
+	}
+	si->btn = p;
+
+	if (cd->pdata->sett[CY_IC_GRPNUM_BTN_KEYS] == NULL)
+		num_defined_keys = 0;
+	else if (cd->pdata->sett[CY_IC_GRPNUM_BTN_KEYS]->data == NULL)
+		num_defined_keys = 0;
+	else
+		num_defined_keys = cd->pdata->sett[CY_IC_GRPNUM_BTN_KEYS]->size;
+
+	for (btn = 0; btn < si->si_ofs.num_btns
+			&& btn < num_defined_keys; btn++) {
+		key_table = (u16 *)cd->pdata->sett[CY_IC_GRPNUM_BTN_KEYS]->data;
+		si->btn[btn].key_code = key_table[btn];
+		si->btn[btn].state = CY_BTN_RELEASED;
+		si->btn[btn].enabled = true;
+	}
+	for (; btn < si->si_ofs.num_btns; btn++) {
+		si->btn[btn].key_code = KEY_RESERVED;
+		si->btn[btn].state = CY_BTN_RELEASED;
+		si->btn[btn].enabled = true;
+	}
+
+	return rc;
+}
+
+static int cyttsp4_si_get_op_data_ptrs(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	void *p;
+	int size;
+
+	p = krealloc(si->xy_mode, si->si_ofs.mode_size +
+			si->si_ofs.data_size, GFP_KERNEL|__GFP_ZERO);
+	if (p == NULL)
+		return -ENOMEM;
+	si->xy_mode = p;
+	si->xy_data = &si->xy_mode[si->si_ofs.tt_stat_ofs + 1];
+
+	size = si->si_ofs.btn_rec_size * si->si_ofs.num_btns;
+	if (!size)
+		return 0;
+
+	p = krealloc(si->btn_rec_data, size, GFP_KERNEL|__GFP_ZERO);
+	if (p == NULL)
+		return -ENOMEM;
+	si->btn_rec_data = p;
+
+	return 0;
+}
+
+static void cyttsp4_si_put_log_data(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	dev_dbg(cd->dev, "%s: cydata_ofs =%4d siz=%4d\n", __func__,
+		si->si_ofs.cydata_ofs, si->si_ofs.cydata_size);
+	dev_dbg(cd->dev, "%s: test_ofs   =%4d siz=%4d\n", __func__,
+		si->si_ofs.test_ofs, si->si_ofs.test_size);
+	dev_dbg(cd->dev, "%s: pcfg_ofs   =%4d siz=%4d\n", __func__,
+		si->si_ofs.pcfg_ofs, si->si_ofs.pcfg_size);
+	dev_dbg(cd->dev, "%s: opcfg_ofs  =%4d siz=%4d\n", __func__,
+		si->si_ofs.opcfg_ofs, si->si_ofs.opcfg_size);
+	dev_dbg(cd->dev, "%s: ddata_ofs  =%4d siz=%4d\n", __func__,
+		si->si_ofs.ddata_ofs, si->si_ofs.ddata_size);
+	dev_dbg(cd->dev, "%s: mdata_ofs  =%4d siz=%4d\n", __func__,
+		si->si_ofs.mdata_ofs, si->si_ofs.mdata_size);
+
+	dev_dbg(cd->dev, "%s: cmd_ofs       =%4d\n", __func__,
+		si->si_ofs.cmd_ofs);
+	dev_dbg(cd->dev, "%s: rep_ofs       =%4d\n", __func__,
+		si->si_ofs.rep_ofs);
+	dev_dbg(cd->dev, "%s: rep_sz        =%4d\n", __func__,
+		si->si_ofs.rep_sz);
+	dev_dbg(cd->dev, "%s: num_btns      =%4d\n", __func__,
+		si->si_ofs.num_btns);
+	dev_dbg(cd->dev, "%s: num_btn_regs  =%4d\n", __func__,
+		si->si_ofs.num_btn_regs);
+	dev_dbg(cd->dev, "%s: tt_stat_ofs   =%4d\n", __func__,
+		si->si_ofs.tt_stat_ofs);
+	dev_dbg(cd->dev, "%s: tch_rec_size   =%4d\n", __func__,
+		si->si_ofs.tch_rec_size);
+	dev_dbg(cd->dev, "%s: max_tchs      =%4d\n", __func__,
+		si->si_ofs.max_tchs);
+	dev_dbg(cd->dev, "%s: mode_size     =%4d\n", __func__,
+		si->si_ofs.mode_size);
+	dev_dbg(cd->dev, "%s: data_size     =%4d\n", __func__,
+		si->si_ofs.data_size);
+	dev_dbg(cd->dev, "%s: rep_hdr_size  =%4d\n", __func__,
+		si->si_ofs.rep_hdr_size);
+	dev_dbg(cd->dev, "%s: map_sz        =%4d\n", __func__,
+		si->si_ofs.map_sz);
+
+	dev_dbg(cd->dev, "%s: btn_rec_size   =%2d\n", __func__,
+		si->si_ofs.btn_rec_size);
+	dev_dbg(cd->dev, "%s: btn_diff_ofs  =%2d\n", __func__,
+		si->si_ofs.btn_diff_ofs);
+	dev_dbg(cd->dev, "%s: btn_diff_size  =%2d\n", __func__,
+		si->si_ofs.btn_diff_size);
+
+	dev_dbg(cd->dev, "%s: max_x    = 0x%04X (%d)\n", __func__,
+		si->si_ofs.max_x, si->si_ofs.max_x);
+	dev_dbg(cd->dev, "%s: x_origin = %d (%s)\n", __func__,
+		si->si_ofs.x_origin,
+		si->si_ofs.x_origin == CY_NORMAL_ORIGIN ?
+		"left corner" : "right corner");
+	dev_dbg(cd->dev, "%s: max_y    = 0x%04X (%d)\n", __func__,
+		si->si_ofs.max_y, si->si_ofs.max_y);
+	dev_dbg(cd->dev, "%s: y_origin = %d (%s)\n", __func__,
+		si->si_ofs.y_origin,
+		si->si_ofs.y_origin == CY_NORMAL_ORIGIN ?
+		"upper corner" : "lower corner");
+	dev_dbg(cd->dev, "%s: max_p    = 0x%04X (%d)\n", __func__,
+		si->si_ofs.max_p, si->si_ofs.max_p);
+
+	dev_dbg(cd->dev, "%s: xy_mode=%p xy_data=%p\n", __func__,
+		si->xy_mode, si->xy_data);
+}
+
+/* ZTEMT Added by LiuYongfeng, 2012/11/6 */
+static int cyttsp4_get_fw_ver(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	char reg_val[4];
+	int i;
+	int rc;
+
+    /*Get firmware version*/
+	rc = cyttsp4_adap_read(cd, CY_REG_CYITO_VERH, &si->fw_ver, sizeof(si->fw_ver));
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail read fw_ver offsets r=%d\n",
+			__func__, rc);
+	}
+    /*revert high 8 bits and low 8 bits*/
+    si->fw_ver = ((si->fw_ver) << 8) + ((si->fw_ver) >> 8);
+
+	/*get x &  y resolution*/
+	for(i = CY_REG_RES_XH; i<= CY_REG_RES_YL; i++) {
+		rc = cyttsp4_adap_read(cd, i, &reg_val[i-CY_REG_RES_XH],
+					   sizeof(reg_val[i-CY_REG_RES_XH]));
+		if (rc < 0) {
+			dev_err(cd->dev, "%s: fail read resolution offsets r=%d\n",
+			__func__, rc);
+		}
+	}
+	si->x_res = reg_val[0]*256 + reg_val[1];
+	si->y_res = reg_val[2]*256 + reg_val[3];
+	dev_dbg(cd->dev, "%s resolution %dx%d\n",__func__,si->x_res,si->y_res);
+
+	si->update_flag = cd->pdata->check_version(si);
+	dev_info(cd->dev, "%s: FW in TP:0x%04X  FW in driver:0x%04X, update_flag:%d\n", 
+        __func__, si->fw_ver, si->fw_ver_new, si->update_flag);
+	return rc;
+}
+/* ZTEMT END */
+
+static int cyttsp4_get_sysinfo_regs(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	int rc;
+
+	/* ZTEMT Added by LiuYongfeng, 2012/11/7 */
+	rc = cyttsp4_get_fw_ver(cd);/*read fw version*/
+	if (rc < 0)
+		return rc;
+	/* ZTEMT END */ 
+
+	rc = cyttsp4_si_data_offsets(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_cydata(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_test_data(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_pcfg_data(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_opcfg_data(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_ddata(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_mdata(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_btn_data(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_op_data_ptrs(cd);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get_op_data\n",
+			__func__);
+		return rc;
+	}
+
+	cyttsp4_si_put_log_data(cd);
+
+	/* provide flow control handshake */
+	rc = cyttsp4_handshake(cd, si->si_data.hst_mode);
+	if (rc < 0)
+		dev_err(cd->dev, "%s: handshake fail on sysinfo reg\n",
+			__func__);
+
+	mutex_lock(&cd->system_lock);
+	si->ready = true;
+	mutex_unlock(&cd->system_lock);
+	return rc;
+}
+
+static void cyttsp4_queue_startup_(struct cyttsp4_core_data *cd)
+{
+	if (cd->startup_state == STARTUP_NONE) {
+		cd->startup_state = STARTUP_QUEUED;
+		schedule_work(&cd->startup_work);
+		dev_dbg(cd->dev, "%s: cyttsp4_startup queued\n", __func__);
+	} else {
+		dev_dbg(cd->dev, "%s: startup_state = %d\n", __func__,
+			cd->startup_state);
+	}
+}
+
+static void cyttsp4_queue_startup(struct cyttsp4_core_data *cd)
+{
+	dev_vdbg(cd->dev, "%s: enter\n", __func__);
+	mutex_lock(&cd->system_lock);
+	cyttsp4_queue_startup_(cd);
+	mutex_unlock(&cd->system_lock);
+}
+
+static void call_atten_cb(struct cyttsp4_core_data *cd,
+		enum cyttsp4_atten_type type, int mode)
+{
+	struct atten_node *atten, *atten_n;
+
+	dev_vdbg(cd->dev, "%s: check list type=%d mode=%d\n",
+		__func__, type, mode);
+	spin_lock(&cd->spinlock);
+	list_for_each_entry_safe(atten, atten_n,
+			&cd->atten_list[type], node) {
+		if (!mode || atten->mode & mode) {
+			spin_unlock(&cd->spinlock);
+			dev_vdbg(cd->dev, "%s: attention for '%s'", __func__,
+				dev_name(&atten->ttsp->dev));
+			atten->func(atten->ttsp);
+			spin_lock(&cd->spinlock);
+		}
+	}
+	spin_unlock(&cd->spinlock);
+}
+
+static irqreturn_t cyttsp4_hard_irq(int irq, void *handle)
+{
+	struct cyttsp4_core_data *cd = handle;
+
+	/*
+	 * Check whether this IRQ should be ignored (external)
+	 * This should be the very first thing to check since
+	 * ignore_irq may be set for a very short period of time
+	 */
+	if (atomic_read(&cd->ignore_irq)) {
+		dev_vdbg(cd->dev, "%s: Ignoring IRQ\n", __func__);
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t cyttsp4_irq(int irq, void *handle)
+{
+	struct cyttsp4_core_data *cd = handle;
+	struct device *dev = cd->dev;
+	enum cyttsp4_mode cur_mode;
+	u8 cmd_ofs = cd->sysinfo.si_ofs.cmd_ofs;
+	bool command_complete = false;
+	u8 mode[3];
+	int rc;
+	u8 cat_masked_cmd;
+
+	dev_dbg(dev, "%s int:0x%x\n", __func__, cd->int_status);
+
+	mutex_lock(&cd->system_lock);
+
+	rc = cyttsp4_adap_read(cd, CY_REG_BASE, mode, sizeof(mode));
+	if (rc) {
+		dev_err(cd->dev, "%s: Fail read adapter r=%d\n", __func__, rc);
+		goto cyttsp4_irq_exit;
+	}
+	dev_vdbg(dev, "%s mode[0-2]:0x%X 0x%X 0x%X\n", __func__,
+			mode[0], mode[1], mode[2]);
+
+    /*Check for false bootloader interrupt Add by luochangyang 2013.04.10*/
+    if (unlikely(mode[0] == CY_CORE_BL_HOST_SYNC_BYTE) 
+        && unlikely(cd->mode == CY_MODE_BOOTLOADER))
+    {
+		dev_err(cd->dev, "%s: False interrupt in bootloader mode\n", __func__);
+		goto cyttsp4_irq_exit;
+    }
+    /*END*/
+    
+	if (IS_BOOTLOADER(mode[0], mode[1])) {
+		cur_mode = CY_MODE_BOOTLOADER;
+		dev_vdbg(dev, "%s: bl running\n", __func__);
+		call_atten_cb(cd, CY_ATTEN_IRQ, cur_mode);
+
+		/* switch to bootloader */
+		if (cd->mode != CY_MODE_BOOTLOADER)
+			dev_dbg(dev, "%s: restart switch to bl m=%d -> m=%d\n",
+			__func__, cd->mode, cur_mode);
+
+		/* catch operation->bl glitch */
+		if (cd->mode != CY_MODE_BOOTLOADER
+				&& cd->mode != CY_MODE_UNKNOWN) {
+			/* Incase startup_state do not let startup_() */
+			cd->mode = CY_MODE_UNKNOWN;
+			cyttsp4_queue_startup_(cd);
+			goto cyttsp4_irq_exit;
+		}
+
+		/* Recover if stuck in bootloader idle mode */
+		if (cd->mode == CY_MODE_BOOTLOADER) {
+			if (IS_BOOTLOADER_IDLE(mode[0], mode[1])) {
+				if (cd->heartbeat_count > 3) {
+					cd->heartbeat_count = 0;
+					cyttsp4_queue_startup_(cd);
+					goto cyttsp4_irq_exit;
+				}
+				cd->heartbeat_count++;
+			}
+		}
+
+		cd->mode = cur_mode;
+		/* Signal bootloader heartbeat heard */
+		wake_up(&cd->wait_q);
+		goto cyttsp4_irq_exit;
+	}
+
+	switch (mode[0] & CY_HST_DEVICE_MODE) {
+	case CY_HST_OPERATE:
+		cur_mode = CY_MODE_OPERATIONAL;
+		dev_vdbg(dev, "%s: operational\n", __func__);
+		break;
+	case CY_HST_CAT:
+		cur_mode = CY_MODE_CAT;
+		/* set the start sensor mode state. */
+		cat_masked_cmd = mode[2] & CY_CMD_MASK;
+
+		/* Get the Debug info for the interrupt. */
+		if (cat_masked_cmd != CY_CMD_CAT_NULL &&
+				cat_masked_cmd !=
+					CY_CMD_CAT_RETRIEVE_PANEL_SCAN &&
+				cat_masked_cmd != CY_CMD_CAT_EXEC_PANEL_SCAN)
+			dev_dbg(cd->dev,
+				"%s: cyttsp4_CaT_IRQ=%02X %02X %02X\n",
+				__func__, mode[0], mode[1], mode[2]);
+		dev_vdbg(dev, "%s: CaT\n", __func__);
+		break;
+	case CY_HST_SYSINFO:
+		cur_mode = CY_MODE_SYSINFO;
+		dev_vdbg(dev, "%s: sysinfo\n", __func__);
+		break;
+	default:
+		cur_mode = CY_MODE_UNKNOWN;
+		dev_err(dev, "%s: unknown HST mode 0x%02X\n", __func__,
+			mode[0]);
+		break;
+	}
+
+	/* Check whether this IRQ should be ignored (internal) */
+	if (cd->int_status & CY_INT_IGNORE) {
+		if (IS_DEEP_SLEEP_CONFIGURED(cd->easy_wakeup_gesture)) {
+			/* Put device back to sleep on premature wakeup */
+			dev_dbg(dev, "%s: Put device back to sleep\n",
+				__func__);
+			_cyttsp4_put_device_into_deep_sleep(cd, mode[0]);
+			goto cyttsp4_irq_exit;
+		}
+
+		/* Check for Wait for Event command */
+		if ((mode[cmd_ofs] & CY_CMD_MASK) == CY_CMD_OP_WAIT_FOR_EVENT
+				&& mode[cmd_ofs] & CY_CMD_COMPLETE) {
+			/*** ZTEMT Modify  by luochangyang, 2013/10/29 ***/
+            #if 0
+			cd->wake_initiated_by_device = 1;
+            #else
+			call_atten_cb(cd, CY_ATTEN_WAKE, 0);
+            dev_info(dev, "%s:  call_atten_cb  wake_initiated_by_device = %d\n",
+				__func__, cd->wake_initiated_by_device);
+            _cyttsp4_put_device_into_easy_wakeup(cd);
+            #endif
+            /***ZTEMT END***/
+            
+			goto cyttsp4_irq_handshake;
+		}
+	}
+
+	/* Check for wake up interrupt */
+	if (cd->int_status & CY_INT_AWAKE) {
+		cd->int_status &= ~CY_INT_AWAKE;
+		wake_up(&cd->wait_q);
+		dev_vdbg(dev, "%s: Received wake up interrupt\n", __func__);
+		goto cyttsp4_irq_handshake;
+	}
+
+	/* Expecting mode change interrupt */
+	if ((cd->int_status & CY_INT_MODE_CHANGE)
+			&& (mode[0] & CY_HST_MODE_CHANGE) == 0) {
+		cd->int_status &= ~CY_INT_MODE_CHANGE;
+		dev_dbg(dev, "%s: finish mode switch m=%d -> m=%d\n",
+				__func__, cd->mode, cur_mode);
+		cd->mode = cur_mode;
+		wake_up(&cd->wait_q);
+		goto cyttsp4_irq_handshake;
+	}
+
+	/* compare current core mode to current device mode */
+	dev_vdbg(dev, "%s: cd->mode=%d cur_mode=%d\n",
+			__func__, cd->mode, cur_mode);
+	if ((mode[0] & CY_HST_MODE_CHANGE) == 0 && cd->mode != cur_mode) {
+		/* Unexpected mode change occurred */
+		dev_err(dev, "%s %d->%d 0x%x\n", __func__, cd->mode,
+				cur_mode, cd->int_status);
+		dev_vdbg(dev, "%s: Unexpected mode change, startup\n",
+				__func__);
+		cyttsp4_queue_startup_(cd);
+		goto cyttsp4_irq_exit;
+	}
+
+	/* Expecting command complete interrupt */
+	dev_vdbg(dev, "%s: command byte:0x%x, toggle:0x%x\n",
+			__func__, mode[cmd_ofs], cd->cmd_toggle);
+	if ((cd->int_status & CY_INT_EXEC_CMD)
+			&& mode[cmd_ofs] & CY_CMD_COMPLETE) {
+		command_complete = true;
+		cd->int_status &= ~CY_INT_EXEC_CMD;
+		dev_vdbg(dev, "%s: Received command complete interrupt\n",
+				__func__);
+		wake_up(&cd->wait_q);
+		/*
+		 * It is possible to receive a single interrupt for
+		* command complete and touch/button status report.
+		* Continue processing for a possible status report.
+		*/
+	}
+
+	/* Copy the mode registers */
+	if (cd->sysinfo.xy_mode)
+		memcpy(cd->sysinfo.xy_mode, mode, sizeof(mode));
+
+	/* This should be status report, read status and touch regs */
+	if (cd->mode == CY_MODE_OPERATIONAL) {
+		dev_vdbg(dev, "%s: Read status and touch registers\n",
+			__func__);
+		rc = cyttsp4_load_status_and_touch_regs(cd, !command_complete);
+		if (rc < 0)
+			dev_err(dev, "%s: fail read mode/touch regs r=%d\n",
+				__func__, rc);
+	}
+
+	/* attention IRQ */
+	call_atten_cb(cd, CY_ATTEN_IRQ, cd->mode);
+
+cyttsp4_irq_handshake:
+	/* handshake the event */
+	dev_vdbg(dev, "%s: Handshake mode=0x%02X r=%d\n",
+			__func__, mode[0], rc);
+	rc = cyttsp4_handshake(cd, mode[0]);
+	if (rc < 0)
+		dev_err(dev, "%s: Fail handshake mode=0x%02X r=%d\n",
+				__func__, mode[0], rc);
+
+	/*
+	 * a non-zero udelay period is required for using
+	 * IRQF_TRIGGER_LOW in order to delay until the
+	 * device completes isr deassert
+	 */
+	udelay(cd->pdata->level_irq_udelay);
+
+cyttsp4_irq_exit:
+	mutex_unlock(&cd->system_lock);
+	dev_vdbg(dev, "%s: irq done\n", __func__);
+	return IRQ_HANDLED;
+}
+
+static void cyttsp4_start_wd_timer(struct cyttsp4_core_data *cd)
+{
+	if (!CY_WATCHDOG_TIMEOUT)
+		return;
+
+	mod_timer(&cd->watchdog_timer, jiffies +
+			msecs_to_jiffies(CY_WATCHDOG_TIMEOUT));
+}
+
+static void cyttsp4_stop_wd_timer(struct cyttsp4_core_data *cd)
+{
+	if (!CY_WATCHDOG_TIMEOUT)
+		return;
+
+	/*
+	 * Ensure we wait until the watchdog timer
+	 * running on a different CPU finishes
+	 */
+	del_timer_sync(&cd->watchdog_timer);
+	cancel_work_sync(&cd->watchdog_work);
+	del_timer_sync(&cd->watchdog_timer);
+}
+
+static void cyttsp4_watchdog_timer(unsigned long handle)
+{
+	struct cyttsp4_core_data *cd = (struct cyttsp4_core_data *)handle;
+
+	dev_vdbg(cd->dev, "%s: Timer triggered\n", __func__);
+
+	if (!cd)
+		return;
+
+	if (!work_pending(&cd->watchdog_work))
+		schedule_work(&cd->watchdog_work);
+
+	return;
+}
+
+static int cyttsp4_write_(struct cyttsp4_device *ttsp, int mode, u16 addr,
+	const void *buf, int size)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	int rc = 0;
+
+	mutex_lock(&cd->adap_lock);
+	if (mode != cd->mode) {
+		dev_dbg(dev, "%s: %s (having %x while %x requested)\n",
+			__func__, "attempt to write in missing mode",
+			cd->mode, mode);
+		rc = -EACCES;
+		goto exit;
+	}
+	rc = cyttsp4_adap_write(cd, addr, buf, size);
+exit:
+	mutex_unlock(&cd->adap_lock);
+	return rc;
+}
+
+static int cyttsp4_read_(struct cyttsp4_device *ttsp, int mode, u16 addr,
+	void *buf, int size)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	int rc = 0;
+
+	mutex_lock(&cd->adap_lock);
+	if (mode != cd->mode) {
+		dev_dbg(dev, "%s: %s (having %x while %x requested)\n",
+			__func__, "attempt to read in missing mode",
+			cd->mode, mode);
+		rc = -EACCES;
+		goto exit;
+	}
+	rc = cyttsp4_adap_read(cd, addr, buf, size);
+exit:
+	mutex_unlock(&cd->adap_lock);
+	return rc;
+}
+
+static int cyttsp4_subscribe_attention_(struct cyttsp4_device *ttsp,
+	enum cyttsp4_atten_type type,
+	int (*func)(struct cyttsp4_device *), int mode)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	struct atten_node *atten, *atten_new;
+
+	atten_new = kzalloc(sizeof(*atten_new), GFP_KERNEL);
+	if (!atten_new) {
+		dev_err(cd->dev, "%s: Fail alloc atten node\n", __func__);
+		return -ENOMEM;
+	}
+
+	dev_dbg(cd->dev, "%s from '%s'\n", __func__, dev_name(cd->dev));
+
+	spin_lock(&cd->spinlock);
+	list_for_each_entry(atten, &cd->atten_list[type], node) {
+		if (atten->ttsp == ttsp && atten->mode == mode) {
+			spin_unlock(&cd->spinlock);
+			kfree(atten_new);
+			dev_vdbg(cd->dev, "%s: %s=%p %s=%d\n",
+				 __func__,
+				 "already subscribed attention",
+				 ttsp, "mode", mode);
+
+			return 0;
+		}
+	}
+
+	atten_new->ttsp = ttsp;
+	atten_new->mode = mode;
+	atten_new->func = func;
+
+	list_add(&atten_new->node, &cd->atten_list[type]);
+	spin_unlock(&cd->spinlock);
+
+	return 0;
+}
+
+static int cyttsp4_unsubscribe_attention_(struct cyttsp4_device *ttsp,
+	enum cyttsp4_atten_type type, int (*func)(struct cyttsp4_device *),
+	int mode)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	struct atten_node *atten, *atten_n;
+
+	spin_lock(&cd->spinlock);
+	list_for_each_entry_safe(atten, atten_n, &cd->atten_list[type], node) {
+		if (atten->ttsp == ttsp && atten->mode == mode) {
+			list_del(&atten->node);
+			spin_unlock(&cd->spinlock);
+			kfree(atten);
+			dev_vdbg(cd->dev, "%s: %s=%p %s=%d\n",
+				__func__,
+				"unsub for atten->ttsp", atten->ttsp,
+				"atten->mode", atten->mode);
+			return 0;
+		}
+	}
+	spin_unlock(&cd->spinlock);
+
+	return -ENODEV;
+}
+
+static int request_exclusive(struct cyttsp4_core_data *cd, void *ownptr,
+		int timeout_ms)
+{
+	int t = msecs_to_jiffies(timeout_ms);
+	bool with_timeout = (timeout_ms != 0);
+
+	mutex_lock(&cd->system_lock);
+	if (!cd->exclusive_dev && cd->exclusive_waits == 0) {
+		cd->exclusive_dev = ownptr;
+		goto exit;
+	}
+
+	cd->exclusive_waits++;
+wait:
+	mutex_unlock(&cd->system_lock);
+	if (with_timeout) {
+		t = wait_event_timeout(cd->wait_q, !cd->exclusive_dev, t);
+		if (IS_TMO(t)) {
+			dev_err(cd->dev, "%s: tmo waiting exclusive access\n",
+				__func__);
+			mutex_lock(&cd->system_lock);
+			cd->exclusive_waits--;
+			mutex_unlock(&cd->system_lock);
+			return -ETIME;
+		}
+	} else {
+		wait_event(cd->wait_q, !cd->exclusive_dev);
+	}
+	mutex_lock(&cd->system_lock);
+	if (cd->exclusive_dev)
+		goto wait;
+	cd->exclusive_dev = ownptr;
+	cd->exclusive_waits--;
+exit:
+	mutex_unlock(&cd->system_lock);
+	dev_vdbg(cd->dev, "%s: request_exclusive ok=%p\n",
+		__func__, ownptr);
+
+	return 0;
+}
+
+static int cyttsp4_request_exclusive_(struct cyttsp4_device *ttsp,
+		int timeout_ms)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	return request_exclusive(cd, (void *)ttsp, timeout_ms);
+}
+
+/*
+ * returns error if was not owned
+ */
+static int release_exclusive(struct cyttsp4_core_data *cd, void *ownptr)
+{
+	mutex_lock(&cd->system_lock);
+	if (cd->exclusive_dev != ownptr) {
+		mutex_unlock(&cd->system_lock);
+		return -EINVAL;
+	}
+
+	dev_vdbg(cd->dev, "%s: exclusive_dev %p freed\n",
+		__func__, cd->exclusive_dev);
+	cd->exclusive_dev = NULL;
+	wake_up(&cd->wait_q);
+	mutex_unlock(&cd->system_lock);
+	return 0;
+}
+
+static int cyttsp4_release_exclusive_(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	return release_exclusive(cd, (void *)ttsp);
+}
+
+static int cyttsp4_wait_bl_heartbeat(struct cyttsp4_core_data *cd)
+{
+	long t;
+	int rc = 0;
+
+	/* wait heartbeat */
+	dev_vdbg(cd->dev, "%s: wait heartbeat...\n", __func__);
+	t = wait_event_timeout(cd->wait_q, cd->mode == CY_MODE_BOOTLOADER,
+			msecs_to_jiffies(CY_CORE_RESET_AND_WAIT_TIMEOUT));
+	if (IS_TMO(t)) {
+		dev_err(cd->dev, "%s: tmo waiting bl heartbeat cd->mode=%d\n",
+			__func__, cd->mode);
+		rc = -ETIME;
+	}
+
+	return rc;
+}
+
+static int cyttsp4_wait_sysinfo_mode(struct cyttsp4_core_data *cd)
+{
+	long t;
+
+	dev_vdbg(cd->dev, "%s: wait sysinfo...\n", __func__);
+
+	t = wait_event_timeout(cd->wait_q, cd->mode == CY_MODE_SYSINFO,
+			msecs_to_jiffies(CY_CORE_MODE_CHANGE_TIMEOUT));
+	if (IS_TMO(t)) {
+		dev_err(cd->dev, "%s: tmo waiting exit bl cd->mode=%d\n",
+			__func__, cd->mode);
+		mutex_lock(&cd->system_lock);
+		cd->int_status &= ~CY_INT_MODE_CHANGE;
+		mutex_unlock(&cd->system_lock);
+		return -ETIME;
+	}
+
+	return 0;
+}
+
+static int cyttsp4_reset_and_wait(struct cyttsp4_core_data *cd)
+{
+	int rc;
+
+	/* reset hardware */
+	mutex_lock(&cd->system_lock);
+	dev_dbg(cd->dev, "%s: reset hw...\n", __func__);
+	rc = cyttsp4_hw_reset_(cd);
+	cd->mode = CY_MODE_UNKNOWN;
+	mutex_unlock(&cd->system_lock);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: %s adap='%s' r=%d\n", __func__,
+			"Fail hw reset", cd->core->adap->id, rc);
+		return rc;
+	}
+
+	return cyttsp4_wait_bl_heartbeat(cd);
+}
+
+/*
+ * returns err if refused or timeout; block until mode change complete
+ * bit is set (mode change interrupt)
+ */
+static int set_mode(struct cyttsp4_core_data *cd, int new_mode)
+{
+	u8 new_dev_mode;
+	u8 mode;
+	long t;
+	int rc;
+
+	switch (new_mode) {
+	case CY_MODE_OPERATIONAL:
+		new_dev_mode = CY_HST_OPERATE;
+		break;
+	case CY_MODE_SYSINFO:
+		new_dev_mode = CY_HST_SYSINFO;
+		break;
+	case CY_MODE_CAT:
+		new_dev_mode = CY_HST_CAT;
+		break;
+	default:
+		dev_err(cd->dev, "%s: invalid mode: %02X(%d)\n",
+			__func__, new_mode, new_mode);
+		return -EINVAL;
+	}
+
+	/* change mode */
+	dev_dbg(cd->dev, "%s: %s=%p new_dev_mode=%02X new_mode=%d\n",
+			__func__, "have exclusive", cd->exclusive_dev,
+			new_dev_mode, new_mode);
+
+	mutex_lock(&cd->system_lock);
+	rc = cyttsp4_adap_read(cd, CY_REG_BASE, &mode, sizeof(mode));
+	if (rc < 0) {
+		mutex_unlock(&cd->system_lock);
+		dev_err(cd->dev, "%s: Fail read mode r=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+	/* Clear device mode bits and set to new mode */
+	mode &= ~CY_HST_DEVICE_MODE;
+	mode |= new_dev_mode | CY_HST_MODE_CHANGE;
+
+	cd->int_status |= CY_INT_MODE_CHANGE;
+	rc = cyttsp4_adap_write(cd, CY_REG_BASE, &mode, sizeof(mode));
+	mutex_unlock(&cd->system_lock);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: Fail write mode change r=%d\n",
+				__func__, rc);
+		goto exit;
+	}
+
+	/* wait for mode change done interrupt */
+	t = wait_event_timeout(cd->wait_q,
+			(cd->int_status & CY_INT_MODE_CHANGE) == 0,
+			msecs_to_jiffies(CY_CORE_MODE_CHANGE_TIMEOUT));
+	dev_dbg(cd->dev, "%s: back from wait t=%ld cd->mode=%d\n",
+			__func__, t, cd->mode);
+
+	if (IS_TMO(t)) {
+		dev_err(cd->dev, "%s: %s\n", __func__,
+				"tmo waiting mode change");
+		mutex_lock(&cd->system_lock);
+		cd->int_status &= ~CY_INT_MODE_CHANGE;
+		mutex_unlock(&cd->system_lock);
+		rc = -EINVAL;
+	}
+
+exit:
+	return rc;
+}
+
+/*
+ * returns err if refused or timeout(core uses fixed timeout period) occurs;
+ * blocks until ISR occurs
+ */
+static int cyttsp4_request_reset_(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	int rc;
+
+	mutex_lock(&cd->system_lock);
+	cd->sysinfo.ready = false;
+	mutex_unlock(&cd->system_lock);
+
+	rc = cyttsp4_reset_and_wait(cd);
+	if (rc < 0)
+		dev_err(cd->dev, "%s: Error on h/w reset r=%d\n",
+			__func__, rc);
+
+	return rc;
+}
+
+/*
+ * returns err if refused ; if no error then restart has completed
+ * and system is in normal operating mode
+ */
+static int cyttsp4_request_restart_(struct cyttsp4_device *ttsp, bool wait)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+
+	mutex_lock(&cd->system_lock);
+	cd->sysinfo.ready = false;
+	mutex_unlock(&cd->system_lock);
+
+	cyttsp4_queue_startup(cd);
+
+	if (wait)
+		wait_event(cd->wait_q, cd->startup_state == STARTUP_NONE);
+
+	return 0;
+}
+
+static int cyttsp4_request_set_mode_(struct cyttsp4_device *ttsp, int mode)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	int rc;
+
+	rc = set_mode(cd, mode);
+	if (rc < 0)
+		dev_err(cd->dev, "%s: fail set_mode=%02X(%d)\n",
+			__func__, cd->mode, cd->mode);
+
+	return rc;
+}
+
+/*
+ * returns NULL if sysinfo has not been acquired from the device yet
+ */
+static struct cyttsp4_sysinfo *cyttsp4_request_sysinfo_(
+		struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	bool ready;
+
+	mutex_lock(&cd->system_lock);
+	ready = cd->sysinfo.ready;
+	mutex_unlock(&cd->system_lock);
+	if (ready)
+		return &cd->sysinfo;
+
+	return NULL;
+}
+
+static struct cyttsp4_loader_platform_data *cyttsp4_request_loader_pdata_(
+		struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	return cd->pdata->loader_pdata;
+}
+
+static int cyttsp4_request_handshake_(struct cyttsp4_device *ttsp, u8 mode)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	int rc;
+
+	rc = cyttsp4_handshake(cd, mode);
+	if (rc < 0)
+		dev_err(&core->dev, "%s: Fail handshake r=%d\n", __func__, rc);
+
+	return rc;
+}
+
+static int cyttsp4_request_toggle_lowpower_(struct cyttsp4_device *ttsp,
+		u8 mode)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	int rc = cyttsp4_toggle_low_power(cd, mode);
+	if (rc < 0)
+		dev_err(&core->dev, "%s: Fail toggle low power r=%d\n",
+				__func__, rc);
+	return rc;
+}
+
+static int _cyttsp4_wait_cmd_exec(struct cyttsp4_core_data *cd, int timeout_ms)
+{
+	struct device *dev = cd->dev;
+	int rc;
+
+	rc = wait_event_timeout(cd->wait_q,
+			(cd->int_status & CY_INT_EXEC_CMD) == 0,
+			msecs_to_jiffies(timeout_ms));
+	if (IS_TMO(rc)) {
+		dev_err(dev, "%s: Command execution timed out\n",
+				__func__);
+		cd->int_status &= ~CY_INT_EXEC_CMD;
+		return -ETIME;
+	}
+	return 0;
+}
+
+static int _get_cmd_offs(struct cyttsp4_core_data *cd, u8 mode)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	struct device *dev = cd->dev;
+	int cmd_ofs;
+
+	switch (mode) {
+	case CY_MODE_CAT:
+		cmd_ofs = CY_REG_CAT_CMD;
+		break;
+	case CY_MODE_OPERATIONAL:
+		cmd_ofs = si->si_ofs.cmd_ofs;
+		break;
+	default:
+		dev_err(dev, "%s: Unsupported mode %x for exec cmd\n",
+				__func__, mode);
+		return -EACCES;
+	}
+
+	return cmd_ofs;
+}
+
+/*
+ * Send command to device for CAT and OP modes
+ * return negative value on error, 0 on success
+ */
+static int _cyttsp4_exec_cmd(struct cyttsp4_core_data *cd, u8 mode,
+		u8 *cmd_buf, size_t cmd_size)
+{
+	struct device *dev = cd->dev;
+	int cmd_ofs;
+	int cmd_param_ofs;
+	u8 command;
+	u8 *cmd_param_buf;
+	size_t cmd_param_size;
+	int rc;
+
+	if (mode != cd->mode) {
+		dev_err(dev, "%s: %s (having %x while %x requested)\n",
+				__func__, "attempt to exec cmd in missing mode",
+				cd->mode, mode);
+		return -EACCES;
+	}
+
+	cmd_ofs = _get_cmd_offs(cd, mode);
+	if (cmd_ofs < 0)
+		return -EACCES;
+
+	cmd_param_ofs = cmd_ofs + 1;
+	cmd_param_buf = cmd_buf + 1;
+	cmd_param_size = cmd_size - 1;
+
+	/* Check if complete is set, so write new command */
+	rc = cyttsp4_adap_read(cd, cmd_ofs, &command, 1);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on read r=%d\n", __func__, rc);
+		return rc;
+	}
+
+	cd->cmd_toggle = GET_TOGGLE(command);
+	cd->int_status |= CY_INT_EXEC_CMD;
+
+	if ((command & CY_CMD_COMPLETE_MASK) == 0)
+		return -EBUSY;
+
+	/*
+	 * Write new command
+	 * Only update command bits 0:5
+	 * Clear command complete bit & toggle bit
+	 */
+	cmd_buf[0] = cmd_buf[0] & CY_CMD_MASK;
+	/* Write command parameters first */
+	if (cmd_size > 1) {
+		rc = cyttsp4_adap_write(cd, cmd_param_ofs, cmd_param_buf,
+				cmd_param_size);
+		if (rc < 0) {
+			dev_err(dev, "%s: Error on write command parameters r=%d\n",
+				__func__, rc);
+			return rc;
+		}
+	}
+	/* Write the command */
+	rc = cyttsp4_adap_write(cd, cmd_ofs, cmd_buf, 1);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on write command r=%d\n",
+				__func__, rc);
+		return rc;
+	}
+
+	return 0;
+}
+
+static int cyttsp4_exec_cmd(struct cyttsp4_core_data *cd, u8 mode,
+		u8 *cmd_buf, size_t cmd_size, u8 *return_buf,
+		size_t return_buf_size, int timeout_ms)
+{
+	struct device *dev = cd->dev;
+	int cmd_ofs;
+	int cmd_return_ofs;
+	int rc;
+
+	mutex_lock(&cd->system_lock);
+	rc = _cyttsp4_exec_cmd(cd, mode, cmd_buf, cmd_size);
+	mutex_unlock(&cd->system_lock);
+
+	if (rc == -EBUSY) {
+		rc = _cyttsp4_wait_cmd_exec(cd, CY_COMMAND_COMPLETE_TIMEOUT);
+		if (rc)
+			return rc;
+		mutex_lock(&cd->system_lock);
+		rc = _cyttsp4_exec_cmd(cd, mode, cmd_buf, cmd_size);
+		mutex_unlock(&cd->system_lock);
+	}
+
+	if (rc < 0)
+		return rc;
+
+	if (timeout_ms == 0)
+		return 0;
+
+	/*
+	 * Wait command to be completed
+	 */
+	rc = _cyttsp4_wait_cmd_exec(cd, timeout_ms);
+	if (rc < 0)
+		return rc;
+
+	if (return_buf_size == 0 || return_buf == NULL)
+		return 0;
+
+	mutex_lock(&cd->system_lock);
+	cmd_ofs = _get_cmd_offs(cd, mode);
+	mutex_unlock(&cd->system_lock);
+	if (cmd_ofs < 0)
+		return -EACCES;
+
+	cmd_return_ofs = cmd_ofs + 1;
+
+	rc = cyttsp4_adap_read(cd, cmd_return_ofs, return_buf, return_buf_size);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on read 3 r=%d\n", __func__, rc);
+		return rc;
+	}
+
+	return 0;
+}
+
+static int cyttsp4_request_exec_cmd_(struct cyttsp4_device *ttsp, u8 mode,
+		u8 *cmd_buf, size_t cmd_size, u8 *return_buf,
+		size_t return_buf_size, int timeout_ms)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	return cyttsp4_exec_cmd(cd, mode, cmd_buf, cmd_size,
+			return_buf, return_buf_size, timeout_ms);
+}
+
+static int cyttsp4_get_parameter(struct cyttsp4_core_data *cd, u8 param_id,
+		u32 *param_value)
+{
+	u8 command_buf[CY_CMD_OP_GET_PARAM_CMD_SZ];
+	u8 return_buf[CY_CMD_OP_GET_PARAM_RET_SZ];
+	u8 param_size;
+	u8 *value_buf;
+	int rc;
+
+	command_buf[0] = CY_CMD_OP_GET_PARAM;
+	command_buf[1] = param_id;
+	rc = cyttsp4_exec_cmd(cd, CY_MODE_OPERATIONAL,
+			command_buf, CY_CMD_OP_GET_PARAM_CMD_SZ,
+			return_buf, CY_CMD_OP_GET_PARAM_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: Unable to execute get parameter command.\n",
+			__func__);
+		return rc;
+	}
+
+	if (return_buf[0] != param_id) {
+		dev_err(cd->dev, "%s: Fail to execute get parameter command.\n",
+			__func__);
+		return -EIO;
+	}
+
+	param_size = return_buf[1];
+	value_buf = &return_buf[2];
+
+	*param_value = 0;
+	while (param_size--)
+		*param_value += *(value_buf++) << (8 * param_size);
+
+	return 0;
+}
+
+static int cyttsp4_set_parameter(struct cyttsp4_core_data *cd, u8 param_id,
+		u8 param_size, u32 param_value)
+{
+	u8 command_buf[CY_CMD_OP_SET_PARAM_CMD_SZ];
+	u8 return_buf[CY_CMD_OP_SET_PARAM_RET_SZ];
+	int rc;
+
+	command_buf[0] = CY_CMD_OP_SET_PARAM;
+	command_buf[1] = param_id;
+	command_buf[2] = param_size;
+
+	if (param_size == 1) {
+		command_buf[3] = (u8)param_value;
+	} else if (param_size == 2) {
+		command_buf[3] = (u8)(param_value >> 8);
+		command_buf[4] = (u8)param_value;
+	} else if (param_size == 4) {
+		command_buf[3] = (u8)(param_value >> 24);
+		command_buf[4] = (u8)(param_value >> 16);
+		command_buf[5] = (u8)(param_value >> 8);
+		command_buf[6] = (u8)param_value;
+	} else {
+		dev_err(cd->dev, "%s: Invalid parameter size %d\n",
+			__func__, param_size);
+		return -EINVAL;
+	}
+
+	rc = cyttsp4_exec_cmd(cd, CY_MODE_OPERATIONAL,
+			command_buf, 3 + param_size,
+			return_buf, CY_CMD_OP_SET_PARAM_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: Unable to execute set parameter command.\n",
+			__func__);
+		return rc;
+	}
+
+	if (return_buf[0] != param_id || return_buf[1] != param_size) {
+		dev_err(cd->dev, "%s: Fail to execute set parameter command.\n",
+			__func__);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int cyttsp4_get_scantype(struct cyttsp4_core_data *cd, u8 *scantype)
+{
+	int rc;
+	u32 value;
+
+	rc = cyttsp4_get_parameter(cd, CY_RAM_ID_SCAN_TYPE, &value);
+	if (!rc)
+		*scantype = (u8)value;
+
+	return rc;
+}
+
+static int cyttsp4_set_scantype(struct cyttsp4_core_data *cd, u8 scantype)
+{
+	int rc;
+
+	rc = cyttsp4_set_parameter(cd, CY_RAM_ID_SCAN_TYPE, 1, scantype);
+
+	return rc;
+}
+
+static u8 _cyttsp4_generate_new_scantype(struct cyttsp4_core_data *cd)
+{
+	u8 new_scantype = cd->default_scantype;
+
+	if (cd->apa_mc_en)
+		new_scantype |= CY_SCAN_TYPE_APA_MC;
+	if (cd->glove_en)
+		new_scantype |= CY_SCAN_TYPE_GLOVE;
+	if (cd->stylus_en)
+		new_scantype |= CY_SCAN_TYPE_STYLUS;
+	if (cd->proximity_en)
+		new_scantype |= CY_SCAN_TYPE_PROXIMITY;
+
+	return new_scantype;
+}
+
+static int cyttsp4_set_new_scan_type(struct cyttsp4_core_data *cd,
+		u8 scan_type, bool enable)
+{
+	int inc = enable ? 1 : -1;
+	int *en;
+	int rc;
+	u8 new_scantype;
+
+	switch (scan_type) {
+	case CY_ST_GLOVE:
+		en = &cd->glove_en;
+		break;
+	case CY_ST_STYLUS:
+		en = &cd->stylus_en;
+		break;
+	case CY_ST_PROXIMITY:
+		en = &cd->proximity_en;
+		break;
+	case CY_ST_APA_MC:
+		en = &cd->apa_mc_en;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	*en += inc;
+
+	new_scantype = _cyttsp4_generate_new_scantype(cd);
+
+	rc = cyttsp4_set_scantype(cd, new_scantype);
+	if (rc)
+		*en -= inc;
+
+	return rc;
+}
+
+static int cyttsp4_request_enable_scan_type_(struct cyttsp4_device *ttsp,
+		u8 scan_type)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+
+	return cyttsp4_set_new_scan_type(cd, scan_type, true);
+}
+
+static int cyttsp4_request_disable_scan_type_(struct cyttsp4_device *ttsp,
+		u8 scan_type)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+
+	return cyttsp4_set_new_scan_type(cd, scan_type, false);
+}
+
+static int cyttsp4_read_config_block(struct cyttsp4_core_data *cd, u8 ebid,
+		u16 row, u8 *data, u16 length)
+{
+	u8 command_buf[CY_CMD_CAT_READ_CFG_BLK_CMD_SZ];
+	u8 *return_buf;
+	int return_buf_sz;
+	u16 crc;
+	int rc;
+
+	/* Allocate buffer for read config block command response
+	 * Header(5) + Data(length) + CRC(2)
+	 */
+	return_buf_sz = CY_CMD_CAT_READ_CFG_BLK_RET_SZ + length;
+	return_buf = kmalloc(return_buf_sz, GFP_KERNEL);
+	if (!return_buf) {
+		dev_err(cd->dev, "%s: Cannot allocate buffer\n",
+			__func__);
+		rc = -ENOMEM;
+		goto exit;
+	}
+
+	command_buf[0] = CY_CMD_CAT_READ_CFG_BLK;
+	command_buf[1] = HI_BYTE(row);
+	command_buf[2] = LO_BYTE(row);
+	command_buf[3] = HI_BYTE(length);
+	command_buf[4] = LO_BYTE(length);
+	command_buf[5] = ebid;
+
+	rc = cyttsp4_exec_cmd(cd, CY_MODE_CAT,
+			command_buf, CY_CMD_CAT_READ_CFG_BLK_CMD_SZ,
+			return_buf, return_buf_sz,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error executing command r=%d\n",
+			__func__, rc);
+		goto free_buffer;
+	}
+
+	crc = cyttsp4_calc_app_crc(
+		&return_buf[CY_CMD_CAT_READ_CFG_BLK_RET_HDR_SZ], length);
+
+	/* Validate response */
+	if (return_buf[0] != CY_CMD_STATUS_SUCCESS
+			|| return_buf[1] != ebid
+			|| return_buf[2] != HI_BYTE(length)
+			|| return_buf[3] != LO_BYTE(length)
+			|| return_buf[CY_CMD_CAT_READ_CFG_BLK_RET_HDR_SZ
+				+ length] != HI_BYTE(crc)
+			|| return_buf[CY_CMD_CAT_READ_CFG_BLK_RET_HDR_SZ
+				+ length + 1] != LO_BYTE(crc)) {
+		dev_err(cd->dev, "%s: Fail executing command\n",
+				__func__);
+		rc = -EINVAL;
+		goto free_buffer;
+	}
+
+	memcpy(data, &return_buf[CY_CMD_CAT_READ_CFG_BLK_RET_HDR_SZ], length);
+
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf, data, length, "read_config_block");
+
+free_buffer:
+	kfree(return_buf);
+exit:
+	return rc;
+}
+
+static int cyttsp4_write_config_block(struct cyttsp4_core_data *cd, u8 ebid,
+		u16 row, const u8 *data, u16 length)
+{
+	u8 return_buf[CY_CMD_CAT_WRITE_CFG_BLK_RET_SZ];
+	u8 *command_buf;
+	int command_buf_sz;
+	u16 crc;
+	int rc;
+
+	/* Allocate buffer for write config block command
+	 * Header(6) + Data(length) + Security Key(8) + CRC(2)
+	 */
+	command_buf_sz = CY_CMD_CAT_WRITE_CFG_BLK_CMD_SZ + length
+		+ sizeof(security_key);
+	command_buf = kmalloc(command_buf_sz, GFP_KERNEL);
+	if (!command_buf) {
+		dev_err(cd->dev, "%s: Cannot allocate buffer\n",
+			__func__);
+		rc = -ENOMEM;
+		goto exit;
+	}
+
+	crc = cyttsp4_calc_app_crc(data, length);
+
+	command_buf[0] = CY_CMD_CAT_WRITE_CFG_BLK;
+	command_buf[1] = HI_BYTE(row);
+	command_buf[2] = LO_BYTE(row);
+	command_buf[3] = HI_BYTE(length);
+	command_buf[4] = LO_BYTE(length);
+	command_buf[5] = ebid;
+
+	command_buf[CY_CMD_CAT_WRITE_CFG_BLK_CMD_HDR_SZ + length
+		+ sizeof(security_key)] = HI_BYTE(crc);
+	command_buf[CY_CMD_CAT_WRITE_CFG_BLK_CMD_HDR_SZ + 1 + length
+		+ sizeof(security_key)] = LO_BYTE(crc);
+
+	memcpy(&command_buf[CY_CMD_CAT_WRITE_CFG_BLK_CMD_HDR_SZ], data,
+		length);
+	memcpy(&command_buf[CY_CMD_CAT_WRITE_CFG_BLK_CMD_HDR_SZ + length],
+		security_key, sizeof(security_key));
+
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf, command_buf, command_buf_sz,
+		"write_config_block");
+
+	rc = cyttsp4_exec_cmd(cd, CY_MODE_CAT,
+			command_buf, command_buf_sz,
+			return_buf, CY_CMD_CAT_WRITE_CFG_BLK_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error executing command r=%d\n",
+			__func__, rc);
+		goto free_buffer;
+	}
+
+	/* Validate response */
+	if (return_buf[0] != CY_CMD_STATUS_SUCCESS
+			|| return_buf[1] != ebid
+			|| return_buf[2] != HI_BYTE(length)
+			|| return_buf[3] != LO_BYTE(length)) {
+		dev_err(cd->dev, "%s: Fail executing command\n",
+				__func__);
+		rc = -EINVAL;
+		goto free_buffer;
+	}
+
+free_buffer:
+	kfree(command_buf);
+exit:
+	return rc;
+}
+
+static int cyttsp4_get_config_row_size(struct cyttsp4_core_data *cd,
+		u16 *config_row_size)
+{
+	u8 command_buf[CY_CMD_CAT_GET_CFG_ROW_SIZE_CMD_SZ];
+	u8 return_buf[CY_CMD_CAT_GET_CFG_ROW_SIZE_RET_SZ];
+	int rc;
+
+	command_buf[0] = CY_CMD_CAT_GET_CFG_ROW_SZ;
+
+	rc = cyttsp4_exec_cmd(cd, CY_MODE_CAT,
+			command_buf, CY_CMD_CAT_GET_CFG_ROW_SIZE_CMD_SZ,
+			return_buf, CY_CMD_CAT_GET_CFG_ROW_SIZE_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error executing command r=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+	*config_row_size = get_unaligned_be16(&return_buf[0]);
+
+exit:
+	return rc;
+}
+
+static int cyttsp4_request_config_row_size_(struct cyttsp4_device *ttsp,
+		u16 *config_row_size)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+
+	return cyttsp4_get_config_row_size(cd, config_row_size);
+}
+
+static int cyttsp4_verify_config_block_crc(struct cyttsp4_core_data *cd,
+		u8 ebid, u16 *calc_crc, u16 *stored_crc, bool *match)
+{
+	u8 command_buf[CY_CMD_CAT_VERIFY_CFG_BLK_CRC_CMD_SZ];
+	u8 return_buf[CY_CMD_CAT_VERIFY_CFG_BLK_CRC_RET_SZ];
+	int rc;
+
+	command_buf[0] = CY_CMD_CAT_VERIFY_CFG_BLK_CRC;
+	command_buf[1] = ebid;
+
+	rc = cyttsp4_exec_cmd(cd, CY_MODE_CAT,
+			command_buf, CY_CMD_CAT_VERIFY_CFG_BLK_CRC_CMD_SZ,
+			return_buf, CY_CMD_CAT_VERIFY_CFG_BLK_CRC_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error executing command r=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+	*calc_crc = get_unaligned_be16(&return_buf[1]);
+	*stored_crc = get_unaligned_be16(&return_buf[3]);
+	if (match)
+		*match = !return_buf[0];
+exit:
+	return rc;
+}
+
+static int cyttsp4_get_config_block_crc(struct cyttsp4_core_data *cd,
+		u8 ebid, u16 *crc)
+{
+	u8 command_buf[CY_CMD_OP_GET_CFG_BLK_CRC_CMD_SZ];
+	u8 return_buf[CY_CMD_OP_GET_CFG_BLK_CRC_RET_SZ];
+	int rc;
+
+	command_buf[0] = CY_CMD_OP_GET_CRC;
+	command_buf[1] = ebid;
+
+	rc = cyttsp4_exec_cmd(cd, CY_MODE_OPERATIONAL,
+			command_buf, CY_CMD_OP_GET_CFG_BLK_CRC_CMD_SZ,
+			return_buf, CY_CMD_OP_GET_CFG_BLK_CRC_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error executing command r=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+	/* Validate response */
+	if (return_buf[0] != CY_CMD_STATUS_SUCCESS) {
+		dev_err(cd->dev, "%s: Fail executing command\n",
+				__func__);
+		rc = -EINVAL;
+		goto exit;
+	}
+
+	*crc = get_unaligned_be16(&return_buf[1]);
+
+exit:
+	return rc;
+}
+
+static int cyttsp4_get_ttconfig_version(struct cyttsp4_core_data *cd,
+		u16 *version)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	u8 data[CY_TTCONFIG_VERSION_OFFSET + CY_TTCONFIG_VERSION_SIZE];
+	int rc;
+	bool ready;
+
+	mutex_lock(&cd->system_lock);
+	ready = si->ready;
+	mutex_unlock(&cd->system_lock);
+
+	if (!ready) {
+		rc  = -ENODEV;
+		goto exit;
+	}
+
+	rc = cyttsp4_read_config_block(cd, CY_TCH_PARM_EBID,
+			CY_TTCONFIG_VERSION_ROW, data, sizeof(data));
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on read config block\n",
+			__func__);
+		goto exit;
+	}
+
+	*version = GET_FIELD16(si, &data[CY_TTCONFIG_VERSION_OFFSET]);
+
+exit:
+	return rc;
+}
+
+static int cyttsp4_get_config_length(struct cyttsp4_core_data *cd, u8 ebid,
+		u16 *length, u16 *max_length)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	u8 data[CY_CONFIG_LENGTH_INFO_SIZE];
+	int rc;
+	bool ready;
+
+	mutex_lock(&cd->system_lock);
+	ready = si->ready;
+	mutex_unlock(&cd->system_lock);
+
+	if (!ready) {
+		rc  = -ENODEV;
+		goto exit;
+	}
+
+	rc = cyttsp4_read_config_block(cd, ebid, CY_CONFIG_LENGTH_INFO_OFFSET,
+			data, sizeof(data));
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on read config block\n",
+			__func__);
+		goto exit;
+	}
+
+	*length = GET_FIELD16(si, &data[CY_CONFIG_LENGTH_OFFSET]);
+	*max_length = GET_FIELD16(si, &data[CY_CONFIG_MAXLENGTH_OFFSET]);
+
+exit:
+	return rc;
+}
+
+static int cyttsp4_write_config_common(struct cyttsp4_core_data *cd, u8 ebid,
+		u16 offset, u8 *data, u16 length)
+{
+	u16 cur_block, cur_off, end_block, end_off;
+	int copy_len;
+	u16 config_row_size = 0;
+	u8 *row_data = NULL;
+	int rc;
+
+	rc = cyttsp4_get_config_row_size(cd, &config_row_size);
+	if (rc) {
+		dev_err(cd->dev, "%s: Cannot get config row size\n",
+			__func__);
+		goto exit;
+	}
+
+	cur_block = offset / config_row_size;
+	cur_off = offset % config_row_size;
+
+	end_block = (offset + length) / config_row_size;
+	end_off = (offset + length) % config_row_size;
+
+	/* Check whether we need to fetch the whole block first */
+	if (cur_off == 0)
+		goto no_offset;
+
+	row_data = kmalloc(config_row_size, GFP_KERNEL);
+	if (!row_data) {
+		dev_err(cd->dev, "%s: Cannot allocate buffer\n", __func__);
+		rc = -ENOMEM;
+		goto exit;
+	}
+
+	copy_len = (cur_block == end_block) ?
+		length : config_row_size - cur_off;
+
+	/* Read up to current offset, append the new data and write it back */
+	rc = cyttsp4_read_config_block(cd, ebid, cur_block, row_data, cur_off);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on read config block\n", __func__);
+		goto free_row_data;
+	}
+
+	memcpy(&row_data[cur_off], data, copy_len);
+
+	rc = cyttsp4_write_config_block(cd, ebid, cur_block, row_data,
+			cur_off + copy_len);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on initial write config block\n",
+			__func__);
+		goto free_row_data;
+	}
+
+	data += copy_len;
+	cur_off = 0;
+	cur_block++;
+
+no_offset:
+	while (cur_block < end_block) {
+		rc = cyttsp4_write_config_block(cd, ebid, cur_block, data,
+				config_row_size);
+		if (rc) {
+			dev_err(cd->dev, "%s: Error on write config block\n",
+				__func__);
+			goto free_row_data;
+		}
+
+		data += config_row_size;
+		cur_block++;
+	}
+
+	/* Last block */
+	if (cur_block == end_block) {
+		rc = cyttsp4_write_config_block(cd, ebid, end_block, data,
+				end_off);
+		if (rc) {
+			dev_err(cd->dev, "%s: Error on last write config block\n",
+				__func__);
+			goto free_row_data;
+		}
+	}
+
+free_row_data:
+	kfree(row_data);
+exit:
+	return rc;
+}
+
+static int cyttsp4_write_config(struct cyttsp4_core_data *cd, u8 ebid,
+		u16 offset, u8 *data, u16 length) {
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	u16 crc_new, crc_old;
+	u16 crc_offset;
+	u16 conf_len;
+	u8 crc_data[2];
+	int rc;
+	bool ready;
+
+	mutex_lock(&cd->system_lock);
+	ready = si->ready;
+	mutex_unlock(&cd->system_lock);
+
+	if (!ready) {
+		rc  = -ENODEV;
+		goto exit;
+	}
+
+	/* CRC is stored at config max length offset */
+	rc = cyttsp4_get_config_length(cd, ebid, &conf_len, &crc_offset);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on get config length\n",
+			__func__);
+		goto exit;
+	}
+
+	/* Allow CRC update also */
+	if (offset + length > crc_offset + 2) {
+		dev_err(cd->dev, "%s: offset + length exceeds max length(%d)\n",
+			__func__, crc_offset + 2);
+		rc = -EINVAL;
+		goto exit;
+	}
+
+	rc = cyttsp4_write_config_common(cd, ebid, offset, data, length);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on write config\n",
+			__func__);
+		goto exit;
+	}
+
+	/* Verify config block CRC */
+	rc = cyttsp4_verify_config_block_crc(cd, ebid,
+			&crc_new, &crc_old, NULL);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on verify config block crc\n",
+			__func__);
+		goto exit;
+	}
+
+	dev_vdbg(cd->dev, "%s: crc_new:%04X crc_old:%04X\n",
+		__func__, crc_new, crc_old);
+
+	if (crc_new == crc_old) {
+		dev_info(cd->dev, "%s: Calculated crc matches stored crc\n",
+			__func__);
+		goto exit;
+	}
+
+	PUT_FIELD16(si, crc_new, crc_data);
+
+	rc = cyttsp4_write_config_common(cd, ebid, crc_offset, crc_data, 2);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on write config crc\n",
+			__func__);
+		goto exit;
+	}
+
+    dev_info(cd->dev, "%s: Write config success.\n", __func__);
+
+exit:
+	return rc;
+}
+
+static int cyttsp4_request_write_config_(struct cyttsp4_device *ttsp, u8 ebid,
+		u16 offset, u8 *data, u16 length) {
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+
+	return cyttsp4_write_config(cd, ebid, offset, data, length);
+}
+
+#ifdef CYTTSP4_WATCHDOG_NULL_CMD
+static void cyttsp4_watchdog_work(struct work_struct *work)
+{
+	struct cyttsp4_core_data *cd =
+		container_of(work, struct cyttsp4_core_data, watchdog_work);
+	u8 cmd_buf[CY_CMD_OP_NULL_CMD_SZ];
+	bool restart = false;
+	int rc;
+
+	rc = request_exclusive(cd, cd->core, 1);
+	if (rc < 0) {
+		dev_vdbg(cd->dev, "%s: fail get exclusive ex=%p own=%p\n",
+				__func__, cd->exclusive_dev, cd->core);
+		goto exit;
+	}
+
+	cmd_buf[0] = CY_CMD_OP_NULL;
+	rc = cyttsp4_exec_cmd(cd, cd->mode,
+			cmd_buf, CY_CMD_OP_NULL_CMD_SZ,
+			NULL, CY_CMD_OP_NULL_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: Watchdog NULL cmd failed.\n", __func__);
+		restart = true;
+	}
+
+	if (release_exclusive(cd, cd->core) < 0)
+		dev_err(cd->dev, "%s: fail to release exclusive\n", __func__);
+	else
+		dev_vdbg(cd->dev, "%s: pass release exclusive\n", __func__);
+exit:
+	if (restart)
+		cyttsp4_queue_startup(cd);
+	else
+		cyttsp4_start_wd_timer(cd);
+}
+#else
+static void cyttsp4_watchdog_work(struct work_struct *work)
+{
+	struct cyttsp4_core_data *cd =
+		container_of(work, struct cyttsp4_core_data, watchdog_work);
+	u8 mode[2];
+	bool restart = false;
+	int rc;
+
+	if (cd == NULL) {
+		dev_err(cd->dev, "%s: NULL context pointer\n", __func__);
+		return;
+	}
+
+	mutex_lock(&cd->system_lock);
+	rc = cyttsp4_adap_read(cd, CY_REG_BASE, &mode, sizeof(mode));
+	if (rc) {
+		dev_err(cd->dev, "%s: failed to access device r=%d\n",
+			__func__, rc);
+		restart = true;
+		goto exit;
+	}
+
+	if (IS_BOOTLOADER(mode[0], mode[1])) {
+		dev_err(cd->dev, "%s: device found in bootloader mode\n",
+			__func__);
+		restart = true;
+		goto exit;
+	}
+exit:
+	if (restart)
+		cyttsp4_queue_startup_(cd);
+	else
+		cyttsp4_start_wd_timer(cd);
+	mutex_unlock(&cd->system_lock);
+}
+#endif
+
+static int cyttsp4_request_stop_wd_(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	cyttsp4_stop_wd_timer(cd);
+	return 0;
+}
+
+static int _cyttsp4_put_device_into_deep_sleep(struct cyttsp4_core_data *cd,
+		u8 hst_mode_reg)
+{
+	int rc;
+
+	hst_mode_reg |= CY_HST_SLEEP;
+
+	dev_vdbg(cd->dev, "%s: write DEEP SLEEP...\n", __func__);
+	rc = cyttsp4_adap_write(cd, CY_REG_BASE, &hst_mode_reg,
+			sizeof(hst_mode_reg));
+	if (rc) {
+		dev_err(cd->dev, "%s: Fail write adapter r=%d\n", __func__, rc);
+		return -EINVAL;
+	}
+	dev_vdbg(cd->dev, "%s: write DEEP SLEEP succeeded\n", __func__);
+
+	if (cd->pdata->power) {
+		dev_dbg(cd->dev, "%s: Power down HW\n", __func__);
+		rc = cd->pdata->power(cd->pdata, 0, cd->dev, &cd->ignore_irq);
+	} else {
+		dev_dbg(cd->dev, "%s: No power function\n", __func__);
+		rc = 0;
+	}
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: HW Power down fails r=%d\n",
+				__func__, rc);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int _cyttsp4_put_device_into_easy_wakeup(struct cyttsp4_core_data *cd)
+{
+	u8 command_buf[CY_CMD_OP_WAIT_FOR_EVENT_CMD_SZ];
+	int rc;
+
+	if (!IS_TTSP_VER_GE(&cd->sysinfo, 2, 2))
+		return -EINVAL;
+
+	command_buf[0] = CY_CMD_OP_WAIT_FOR_EVENT;
+	command_buf[1] = cd->easy_wakeup_gesture;
+
+	rc = _cyttsp4_exec_cmd(cd, CY_MODE_OPERATIONAL, command_buf,
+			CY_CMD_OP_WAIT_FOR_EVENT_CMD_SZ);
+	cd->int_status &= ~CY_INT_EXEC_CMD;
+	if (rc)
+		dev_err(cd->dev, "%s: Error executing command r=%d\n",
+			__func__, rc);
+
+	return rc;
+}
+
+static int _cyttsp4_wait_for_refresh_cycle(struct cyttsp4_core_data *cd,
+		int cycle)
+{
+	int active_refresh_cycle_ms;
+
+	if (cd->active_refresh_cycle_ms)
+		active_refresh_cycle_ms = cd->active_refresh_cycle_ms;
+	else
+		active_refresh_cycle_ms = 20;
+
+	msleep(cycle * active_refresh_cycle_ms);
+
+	return 0;
+}
+
+static int _cyttsp4_put_device_into_sleep(struct cyttsp4_core_data *cd,
+		u8 hst_mode_reg)
+{
+	int rc;
+
+	if (IS_DEEP_SLEEP_CONFIGURED(cd->easy_wakeup_gesture))
+		rc = _cyttsp4_put_device_into_deep_sleep(cd, hst_mode_reg);
+	else
+		rc = _cyttsp4_put_device_into_easy_wakeup(cd);
+
+	return rc;
+}
+
+static int cyttsp4_core_sleep_(struct cyttsp4_core_data *cd)
+{
+	u8 mode[2];
+	int rc = 0;
+
+	cyttsp4_stop_wd_timer(cd);
+
+	/* Wait until currently running IRQ handler exits and disable IRQ */
+	disable_irq(cd->irq);
+
+	mutex_lock(&cd->system_lock);
+	/* Already in sleep mode? */
+	if (cd->sleep_state == SS_SLEEP_ON)
+		goto exit;
+
+	cd->sleep_state = SS_SLEEPING;
+
+	rc = cyttsp4_adap_read(cd, CY_REG_BASE, &mode, sizeof(mode));
+	if (rc) {
+		dev_err(cd->dev, "%s: Fail read adapter r=%d\n", __func__, rc);
+		goto exit;
+	}
+
+	if (IS_BOOTLOADER(mode[0], mode[1])) {
+		dev_err(cd->dev, "%s: Device in BOOTLADER mode.\n", __func__);
+		rc = -EINVAL;
+		goto exit;
+	}
+
+	/* Deep sleep is only allowed in Operating mode */
+	if (GET_HSTMODE(mode[0]) != CY_HST_OPERATE) {
+		dev_err(cd->dev, "%s: Device is not in Operating mode (%02X)\n",
+			__func__, GET_HSTMODE(mode[0]));
+		mutex_unlock(&cd->system_lock);
+		enable_irq(cd->irq);
+		/* Try switching to Operating mode */
+		rc = set_mode(cd, CY_MODE_OPERATIONAL);
+		disable_irq(cd->irq);
+		mutex_lock(&cd->system_lock);
+		if (rc < 0) {
+			dev_err(cd->dev, "%s: failed to set mode to Operational rc=%d\n",
+				__func__, rc);
+			cyttsp4_queue_startup_(cd);
+			rc = 0;
+			goto exit;
+		}
+
+		/* Get the new host mode register value */
+		rc = cyttsp4_adap_read(cd, CY_REG_BASE, &mode, sizeof(mode));
+		if (rc) {
+			dev_err(cd->dev, "%s: Fail read adapter r=%d\n",
+				__func__, rc);
+			goto exit;
+		}
+	}
+
+	rc = _cyttsp4_put_device_into_sleep(cd, mode[0]);
+
+exit:
+	if (rc) {
+		cd->sleep_state = SS_SLEEP_OFF;
+		cyttsp4_start_wd_timer(cd);
+	} else {
+		cd->sleep_state = SS_SLEEP_ON;
+		cd->int_status |= CY_INT_IGNORE;
+	}
+
+	mutex_unlock(&cd->system_lock);
+	enable_irq(cd->irq);
+
+	return rc;
+}
+
+static int cyttsp4_core_sleep(struct cyttsp4_core_data *cd)
+{
+	int rc;
+
+	rc = request_exclusive(cd, cd->core,
+			CY_CORE_SLEEP_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail get exclusive ex=%p own=%p\n",
+				__func__, cd->exclusive_dev, cd->core);
+		return 0;
+	}
+
+	rc = cyttsp4_core_sleep_(cd);
+
+	if (release_exclusive(cd, cd->core) < 0)
+		dev_err(cd->dev, "%s: fail to release exclusive\n", __func__);
+	else
+		dev_vdbg(cd->dev, "%s: pass release exclusive\n", __func__);
+
+	/* Give time to FW to sleep */
+	_cyttsp4_wait_for_refresh_cycle(cd, 2);
+
+	return rc;
+}
+
+static int _cyttsp4_awake_device_from_deep_sleep(struct cyttsp4_core_data *cd,
+		int timeout_ms)
+{
+	struct device *dev = cd->dev;
+	u8 mode;
+	int t;
+	int rc;
+
+	cd->int_status |= CY_INT_AWAKE;
+
+	if (cd->pdata->power) {
+		/* Wake up using platform power function */
+		dev_dbg(dev, "%s: Power up HW\n", __func__);
+		rc = cd->pdata->power(cd->pdata, 1, dev, &cd->ignore_irq);
+	} else {
+		/* Initiate a read transaction to wake up */
+		rc = cyttsp4_adap_read(cd, CY_REG_BASE, &mode, sizeof(mode));
+	}
+	if (rc < 0) {
+		dev_err(dev, "%s: HW Power up fails r=%d\n", __func__, rc);
+		/* Initiate another read transaction to wake up */
+		rc = cyttsp4_adap_read(cd, CY_REG_BASE, &mode, sizeof(mode));
+	} else
+		dev_vdbg(cd->dev, "%s: HW power up succeeds\n", __func__);
+	mutex_unlock(&cd->system_lock);
+
+	t = wait_event_timeout(cd->wait_q,
+			(cd->int_status & CY_INT_AWAKE) == 0,
+			msecs_to_jiffies(timeout_ms));
+	mutex_lock(&cd->system_lock);
+	if (IS_TMO(t)) {
+		dev_dbg(dev, "%s: TMO waiting for wakeup\n", __func__);
+		cd->int_status &= ~CY_INT_AWAKE;
+		/* Perform a read transaction to check if device is awake */
+		rc = cyttsp4_adap_read(cd, CY_REG_BASE, &mode, sizeof(mode));
+		if (rc < 0 || GET_HSTMODE(mode) != CY_HST_OPERATE) {
+			dev_err(dev, "%s: Queueing startup\n", __func__);
+			/* Try starting up */
+			cyttsp4_queue_startup_(cd);
+		}
+	}
+
+	return rc;
+}
+
+static int _cyttsp4_awake_device(struct cyttsp4_core_data *cd)
+{
+	int timeout_ms;
+
+	if (cd->wake_initiated_by_device) {
+		cd->wake_initiated_by_device = 0;
+		/* To prevent sequential wake/sleep caused by ttsp modules */
+		msleep(20);
+		return 0;
+	}
+
+	if (IS_DEEP_SLEEP_CONFIGURED(cd->easy_wakeup_gesture))
+		timeout_ms = CY_CORE_WAKEUP_TIMEOUT;
+	else
+		timeout_ms = CY_CORE_WAKEUP_TIMEOUT * 4;
+
+	return _cyttsp4_awake_device_from_deep_sleep(cd, timeout_ms);
+}
+
+static int cyttsp4_core_wake_(struct cyttsp4_core_data *cd)
+{
+	int rc;
+
+	/* Already woken? */
+	mutex_lock(&cd->system_lock);
+	if (cd->sleep_state == SS_SLEEP_OFF) {
+		mutex_unlock(&cd->system_lock);
+		return 0;
+	}
+
+	cd->int_status &= ~CY_INT_IGNORE;
+	cd->sleep_state = SS_WAKING;
+
+	rc = _cyttsp4_awake_device(cd);
+
+	cd->sleep_state = SS_SLEEP_OFF;
+	mutex_unlock(&cd->system_lock);
+
+	cyttsp4_start_wd_timer(cd);
+
+	return 0;
+}
+
+static int cyttsp4_core_wake(struct cyttsp4_core_data *cd)
+{
+	int rc;
+
+	rc = request_exclusive(cd, cd->core,
+			CY_CORE_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail get exclusive ex=%p own=%p\n",
+				__func__, cd->exclusive_dev, cd->core);
+		return 0;
+	}
+	rc = cyttsp4_core_wake_(cd);
+
+	if (release_exclusive(cd, cd->core) < 0)
+		dev_err(cd->dev, "%s: fail to release exclusive\n", __func__);
+	else
+		dev_vdbg(cd->dev, "%s: pass release exclusive\n", __func__);
+
+	/* If a startup queued in wake, wait it to finish */
+	wait_event_timeout(cd->wait_q, cd->startup_state == STARTUP_NONE,
+			msecs_to_jiffies(CY_CORE_RESET_AND_WAIT_TIMEOUT));
+
+	return rc;
+}
+
+static int cyttsp4_get_ttconfig_info(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	u16 length, max_length;
+	u16 version = 0;
+	u16 crc = 0;
+	int rc;
+
+	rc = set_mode(cd, CY_MODE_CAT);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to set mode to CAT rc=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	rc = cyttsp4_get_ttconfig_version(cd, &version);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get ttconfig version rc=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	rc = cyttsp4_get_config_length(cd, CY_TCH_PARM_EBID,
+			&length, &max_length);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get ttconfig length rc=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	rc = set_mode(cd, CY_MODE_OPERATIONAL);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to set mode to Operational rc=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	rc = cyttsp4_get_config_block_crc(cd, CY_TCH_PARM_EBID, &crc);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get ttconfig crc rc=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	si->ttconfig.version = version;
+	si->ttconfig.length = length;
+	si->ttconfig.max_length = max_length;
+	si->ttconfig.crc = crc;
+
+	dev_vdbg(cd->dev, "%s: TT Config Version:%04X Length:%d Max Length:%d CRC:%04X\n",
+		__func__, si->ttconfig.version, si->ttconfig.length,
+		si->ttconfig.length, si->ttconfig.crc);
+
+	return 0;
+}
+static int cyttsp4_get_active_refresh_cycle(struct cyttsp4_core_data *cd)
+{
+	int rc;
+	u32 value;
+
+	rc = cyttsp4_get_parameter(cd, CY_RAM_ID_REFRESH_INTERVAL, &value);
+	if (!rc)
+		cd->active_refresh_cycle_ms = (u8)value;
+
+	return rc;
+}
+
+static int cyttsp4_set_initial_scantype(struct cyttsp4_core_data *cd)
+{
+	u8 new_scantype;
+	int rc;
+
+	rc = cyttsp4_get_scantype(cd, &cd->default_scantype);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get scantype rc=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+	/* Disable proximity sensing by default */
+	cd->default_scantype &= ~CY_SCAN_TYPE_PROXIMITY;
+
+	new_scantype = _cyttsp4_generate_new_scantype(cd);
+
+	rc = cyttsp4_set_scantype(cd, new_scantype);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to set scantype rc=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+exit:
+	return rc;
+}
+
+static int cyttsp4_startup_(struct cyttsp4_core_data *cd)
+{
+	int retry = CY_CORE_STARTUP_RETRY_COUNT;
+	int rc;
+	bool detected = false;
+
+	dev_dbg(cd->dev, "%s: enter...\n", __func__);
+
+	cyttsp4_stop_wd_timer(cd);
+
+reset:
+	if (retry != CY_CORE_STARTUP_RETRY_COUNT)
+		dev_dbg(cd->dev, "%s: Retry %d\n", __func__,
+			CY_CORE_STARTUP_RETRY_COUNT - retry);
+
+	/* reset hardware and wait for heartbeat */
+	rc = cyttsp4_reset_and_wait(cd);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: Error on h/w reset r=%d\n", __func__, rc);
+		RETRY_OR_EXIT(retry--, reset, exit);
+	}
+
+	detected = true;
+
+	/* exit bl into sysinfo mode */
+	dev_vdbg(cd->dev, "%s: write exit ldr...\n", __func__);
+	mutex_lock(&cd->system_lock);
+	cd->int_status &= ~CY_INT_IGNORE;
+	cd->int_status |= CY_INT_MODE_CHANGE;
+
+	rc = cyttsp4_adap_write(cd, CY_REG_BASE, (u8 *)ldr_exit,
+			sizeof(ldr_exit));
+	mutex_unlock(&cd->system_lock);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: Fail write adap='%s' r=%d\n",
+			__func__, cd->core->adap->id, rc);
+		RETRY_OR_EXIT(retry--, reset, exit);
+	}
+
+	rc = cyttsp4_wait_sysinfo_mode(cd);
+	if (rc < 0) {
+		u8 buf[sizeof(ldr_err_app)];
+		int rc1;
+
+		/* Check for invalid/corrupted touch application */
+		rc1 = cyttsp4_adap_read(cd, CY_REG_BASE, buf,
+				sizeof(ldr_err_app));
+		if (rc1) {
+			dev_err(cd->dev, "%s: Fail read adap='%s' r=%d\n",
+				__func__, cd->core->adap->id, rc1);
+		} else if (!memcmp(buf, ldr_err_app, sizeof(ldr_err_app))) {
+			dev_err(cd->dev, "%s: Error launching touch application\n",
+				__func__);
+			mutex_lock(&cd->system_lock);
+			cd->invalid_touch_app = true;
+			mutex_unlock(&cd->system_lock);
+			goto exit_no_wd;
+		}
+
+		RETRY_OR_EXIT(retry--, reset, exit);
+	}
+
+	mutex_lock(&cd->system_lock);
+	cd->invalid_touch_app = false;
+	mutex_unlock(&cd->system_lock);
+
+	/* read sysinfo data */
+	dev_vdbg(cd->dev, "%s: get sysinfo regs..\n", __func__);
+	rc = cyttsp4_get_sysinfo_regs(cd);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get sysinfo regs rc=%d\n",
+			__func__, rc);
+		RETRY_OR_EXIT(retry--, reset, exit);
+	}
+
+	rc = set_mode(cd, CY_MODE_OPERATIONAL);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to set mode to operational rc=%d\n",
+			__func__, rc);
+		RETRY_OR_EXIT(retry--, reset, exit);
+	}
+
+	rc = cyttsp4_set_initial_scantype(cd);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get scantype rc=%d\n",
+			__func__, rc);
+		RETRY_OR_EXIT(retry--, reset, exit);
+	}
+
+	rc = cyttsp4_get_ttconfig_info(cd);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get ttconfig info rc=%d\n",
+			__func__, rc);
+		RETRY_OR_EXIT(retry--, reset, exit);
+	}
+
+	rc = cyttsp4_get_active_refresh_cycle(cd);
+	if (rc < 0)
+		dev_err(cd->dev, "%s: failed to get refresh cycle time rc=%d\n",
+			__func__, rc);
+
+	/* attention startup */
+	call_atten_cb(cd, CY_ATTEN_STARTUP, 0);
+
+	/* restore to sleep if was suspended */
+	mutex_lock(&cd->system_lock);
+	if (cd->sleep_state == SS_SLEEP_ON) {
+		cd->sleep_state = SS_SLEEP_OFF;
+		mutex_unlock(&cd->system_lock);
+		/* watchdog is restarted by cyttsp4_core_sleep_() on error */
+		cyttsp4_core_sleep_(cd);
+		goto exit_no_wd;
+	}
+	mutex_unlock(&cd->system_lock);
+
+exit:
+	cyttsp4_start_wd_timer(cd);
+
+exit_no_wd:
+	if (!detected)
+		rc = -ENODEV;
+
+	/* Required for signal to the TTHE */
+	dev_dbg(cd->dev, "%s: cyttsp4_exit startup r=%d...\n", __func__, rc);
+
+	return rc;
+}
+
+static int cyttsp4_startup(struct cyttsp4_core_data *cd)
+{
+	int rc;
+
+	mutex_lock(&cd->system_lock);
+	cd->startup_state = STARTUP_RUNNING;
+	mutex_unlock(&cd->system_lock);
+
+	rc = request_exclusive(cd, cd->core,
+			CY_CORE_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail get exclusive ex=%p own=%p\n",
+				__func__, cd->exclusive_dev, cd->core);
+		goto exit;
+	}
+
+	rc = cyttsp4_startup_(cd);
+
+	if (release_exclusive(cd, cd->core) < 0)
+		/* Don't return fail code, mode is already changed. */
+		dev_err(cd->dev, "%s: fail to release exclusive\n", __func__);
+	else
+		dev_vdbg(cd->dev, "%s: pass release exclusive\n", __func__);
+
+exit:
+	mutex_lock(&cd->system_lock);
+	cd->startup_state = STARTUP_NONE;
+	mutex_unlock(&cd->system_lock);
+
+	/* Wake the waiters for end of startup */
+	wake_up(&cd->wait_q);
+
+	return rc;
+}
+
+static void cyttsp4_startup_work_function(struct work_struct *work)
+{
+	struct cyttsp4_core_data *cd =  container_of(work,
+		struct cyttsp4_core_data, startup_work);
+	int rc;
+
+	/*
+	 * Force clear exclusive access
+	 * startup queue is called for abnormal case,
+	 * and when a this called access can be acquired in other context
+	 */
+	mutex_lock(&cd->system_lock);
+	if (cd->exclusive_dev != cd->core)
+		cd->exclusive_dev = NULL;
+	mutex_unlock(&cd->system_lock);
+	rc = cyttsp4_startup(cd);
+	if (rc < 0)
+		dev_err(cd->dev, "%s: Fail queued startup r=%d\n",
+			__func__, rc);
+}
+
+static void cyttsp4_free_si_ptrs(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+
+	if (!si)
+		return;
+
+	kfree(si->si_ptrs.cydata);
+	kfree(si->si_ptrs.test);
+	kfree(si->si_ptrs.pcfg);
+	kfree(si->si_ptrs.opcfg);
+	kfree(si->si_ptrs.ddata);
+	kfree(si->si_ptrs.mdata);
+	kfree(si->btn);
+	kfree(si->xy_mode);
+	kfree(si->btn_rec_data);
+}
+
+#if defined(CONFIG_PM_RUNTIME)
+static int cyttsp4_core_rt_suspend(struct device *dev)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	int rc;
+
+	rc = cyttsp4_core_sleep(cd);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on sleep\n", __func__);
+		return -EAGAIN;
+	}
+	dev_dbg(dev, "%s\n", __func__);
+	return 0;
+}
+
+static int cyttsp4_core_rt_resume(struct device *dev)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	int rc;
+
+	rc = cyttsp4_core_wake(cd);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on wake\n", __func__);
+		return -EAGAIN;
+	}
+	dev_dbg(dev, "%s\n", __func__);
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_PM_SLEEP)
+static int cyttsp4_core_suspend(struct device *dev)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+
+	if (!(cd->pdata->flags & CY_CORE_FLAG_WAKE_ON_GESTURE))
+		return 0;
+
+	/*
+	 * This will not prevent resume
+	 * Required to prevent interrupts before i2c awake
+	 */
+	disable_irq(cd->irq);
+
+	if (device_may_wakeup(dev)) {
+		dev_dbg(dev, "%s Device MAY wakeup\n", __func__);
+		if (!enable_irq_wake(cd->irq))
+			cd->irq_wake = 1;
+	} else {
+		dev_dbg(dev, "%s Device may NOT wakeup\n", __func__);
+	}
+
+	return 0;
+}
+
+static int cyttsp4_core_resume(struct device *dev)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+
+	if (!(cd->pdata->flags & CY_CORE_FLAG_WAKE_ON_GESTURE))
+		return 0;
+
+	enable_irq(cd->irq);
+
+	if (device_may_wakeup(dev)) {
+		dev_dbg(dev, "%s Device MAY wakeup\n", __func__);
+		if (cd->irq_wake) {
+			disable_irq_wake(cd->irq);
+			cd->irq_wake = 0;
+		}
+	} else {
+		dev_dbg(dev, "%s Device may NOT wakeup\n", __func__);
+	}
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops cyttsp4_core_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(cyttsp4_core_suspend, cyttsp4_core_resume)
+	SET_RUNTIME_PM_OPS(cyttsp4_core_rt_suspend, cyttsp4_core_rt_resume,
+			NULL)
+};
+
+/* ZTEMT Added by luochangyang, 2013/07/10 */
+#if defined(CONFIG_FB)
+static int cyttsp4_fb_notifier_callback(struct notifier_block *self,
+				 unsigned long event, void *data)
+{
+	struct fb_event *evdata = data;
+	struct cyttsp4_core_data *cd =
+		container_of(self, struct cyttsp4_core_data, fb_notif);
+	int *blank;
+    int rc;
+    
+    struct device *dev = cd->dev;
+
+	if (evdata && evdata->data && event == FB_EVENT_BLANK && cd && dev) {
+		blank = evdata->data;
+		if (*blank == FB_BLANK_UNBLANK) {
+			rc = cyttsp4_core_wake(cd);
+        	if (rc < 0) {
+        		dev_err(dev, "%s: Error on wake\n", __func__);
+        	}
+            dev_info(dev, "ztemt %s: Wake!\n", __func__);
+		}
+		else if (*blank == FB_BLANK_POWERDOWN) {
+			rc = cyttsp4_core_sleep(cd);
+        	if (rc < 0) {
+        		dev_err(dev, "%s: Error on sleep\n", __func__);
+        	}
+            dev_info(dev, "ztemt %s: Sleep!\n", __func__);
+		}
+	}
+
+	return 0;
+}
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+/* ZTEMT Added by LiuYongfeng, 2012/10/17 */
+static void cyttsp4_core_early_suspend(struct early_suspend *h)
+{	int rc;
+	struct cyttsp4_core_data *cd = container_of(h, struct cyttsp4_core_data, es);
+	struct device *dev = cd->dev;
+	printk("ztemt %s\n", __func__);
+	rc = cyttsp4_core_sleep(cd);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on sleep\n", __func__);
+	}
+}
+static void cyttsp4_core_late_resume(struct early_suspend *h)
+{	
+	int rc;
+	struct cyttsp4_core_data *cd = container_of(h, struct cyttsp4_core_data, es);
+	struct device *dev = cd->dev;
+	printk("ztemt %s\n", __func__);
+	rc = cyttsp4_core_wake(cd);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on wake\n", __func__);
+	}
+}
+#endif/* ZTEMT END */
+
+/*
+ * Show Firmware version via sysfs
+ */
+static ssize_t cyttsp4_ic_ver_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	struct cyttsp4_cydata *cydata;
+
+	mutex_lock(&cd->system_lock);
+	if (!cd->sysinfo.ready) {
+		if (cd->invalid_touch_app) {
+			mutex_unlock(&cd->system_lock);
+			return snprintf(buf, CY_MAX_PRBUF_SIZE,
+					"Corrupted Touch application!\n");
+		} else {
+			mutex_unlock(&cd->system_lock);
+			return snprintf(buf, CY_MAX_PRBUF_SIZE,
+					"System Information not ready!\n");
+		}
+	}
+	mutex_unlock(&cd->system_lock);
+
+	cydata = cd->sysinfo.si_ptrs.cydata;
+
+	return snprintf(buf, CY_MAX_PRBUF_SIZE,
+		"%s: 0x%04X\n"
+		"%s: 0x%04X\n"
+		"%s: 0x%02X 0x%02X\n"
+		"%s: 0x%02X\n"
+		"%s: 0x%02X\n"
+		"%s: 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\n"
+		"%s: 0x%04X\n"
+		"%s: 0x%02X\n"
+		"%s: 0x%02X\n",
+		"CYTTSP4 FW VER (in   TP  )",cd->sysinfo.fw_ver,
+		"CYTTSP4 FW VER (in Driver)",cd->sysinfo.fw_ver_new,
+		"TrueTouch Product ID", cydata->ttpidh, cydata->ttpidl,
+		"Firmware Major Version", cydata->fw_ver_major,
+		"Firmware Minor Version", cydata->fw_ver_minor,
+		"Revision Control Number", cydata->revctrl[0],
+		cydata->revctrl[1], cydata->revctrl[2], cydata->revctrl[3],
+		cydata->revctrl[4], cydata->revctrl[5], cydata->revctrl[6],
+		cydata->revctrl[7],
+		"TrueTouch Config Version", cd->sysinfo.ttconfig.version,
+		"Bootloader Major Version", cydata->blver_major,
+		"Bootloader Minor Version", cydata->blver_minor);
+}
+
+/*
+ * Show TT Config version via sysfs
+ */
+static ssize_t cyttsp4_ttconfig_ver_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+
+	return snprintf(buf, CY_MAX_PRBUF_SIZE, "0x%04X\n",
+			cd->sysinfo.ttconfig.version);
+}
+
+/*
+ * Show Driver version via sysfs
+ */
+static ssize_t cyttsp4_drv_ver_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, CY_MAX_PRBUF_SIZE,
+		"Driver: %s\nVersion: %s\nDate: %s\n",
+		cy_driver_core_name, cy_driver_core_version,
+		cy_driver_core_date);
+}
+
+/*
+ * HW reset via sysfs
+ */
+static ssize_t cyttsp4_hw_reset_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	int rc = 0;
+
+	rc = cyttsp4_startup(cd);
+	if (rc < 0)
+		dev_err(dev, "%s: HW reset failed r=%d\n",
+			__func__, rc);
+
+	return size;
+}
+
+/*
+ * Show IRQ status via sysfs
+ */
+static ssize_t cyttsp4_hw_irq_stat_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	int retval;
+
+	if (cd->pdata->irq_stat) {
+		retval = cd->pdata->irq_stat(cd->pdata, dev);
+		switch (retval) {
+		case 0:
+			return snprintf(buf, CY_MAX_PRBUF_SIZE,
+				"Interrupt line is LOW.\n");
+		case 1:
+			return snprintf(buf, CY_MAX_PRBUF_SIZE,
+				"Interrupt line is HIGH.\n");
+		default:
+			return snprintf(buf, CY_MAX_PRBUF_SIZE,
+				"Function irq_stat() returned %d.\n", retval);
+		}
+	}
+
+	return snprintf(buf, CY_MAX_PRBUF_SIZE,
+		"Function irq_stat() undefined.\n");
+}
+
+/*
+ * Show IRQ enable/disable status via sysfs
+ */
+static ssize_t cyttsp4_drv_irq_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	ssize_t ret;
+
+	mutex_lock(&cd->system_lock);
+	if (cd->irq_enabled)
+		ret = snprintf(buf, CY_MAX_PRBUF_SIZE,
+			"Driver interrupt is ENABLED\n");
+	else
+		ret = snprintf(buf, CY_MAX_PRBUF_SIZE,
+			"Driver interrupt is DISABLED\n");
+	mutex_unlock(&cd->system_lock);
+
+	return ret;
+}
+
+/*
+ * Enable/disable IRQ via sysfs
+ */
+static ssize_t cyttsp4_drv_irq_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	unsigned long value;
+	int retval;
+
+	retval = kstrtoul(buf, 10, &value);
+	if (retval < 0) {
+		dev_err(dev, "%s: Invalid value\n", __func__);
+		goto cyttsp4_drv_irq_store_error_exit;
+	}
+
+	mutex_lock(&cd->system_lock);
+	switch (value) {
+	case 0:
+		if (cd->irq_enabled) {
+			cd->irq_enabled = false;
+			/* Disable IRQ */
+			disable_irq_nosync(cd->irq);
+			dev_info(dev, "%s: Driver IRQ now disabled\n",
+				__func__);
+		} else
+			dev_info(dev, "%s: Driver IRQ already disabled\n",
+				__func__);
+		break;
+
+	case 1:
+		if (cd->irq_enabled == false) {
+			cd->irq_enabled = true;
+			/* Enable IRQ */
+			enable_irq(cd->irq);
+			dev_info(dev, "%s: Driver IRQ now enabled\n",
+				__func__);
+		} else
+			dev_info(dev, "%s: Driver IRQ already enabled\n",
+				__func__);
+		break;
+
+	default:
+		dev_err(dev, "%s: Invalid value\n", __func__);
+	}
+	mutex_unlock(&(cd->system_lock));
+
+cyttsp4_drv_irq_store_error_exit:
+
+	return size;
+}
+
+/*
+ * Debugging options via sysfs
+ */
+static ssize_t cyttsp4_drv_debug_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	unsigned long value = 0;
+	int rc = 0;
+
+	rc = kstrtoul(buf, 10, &value);
+	if (rc < 0) {
+		dev_err(dev, "%s: Invalid value\n", __func__);
+		goto cyttsp4_drv_debug_store_exit;
+	}
+
+	switch (value) {
+	case CY_DBG_SUSPEND:
+		dev_info(dev, "%s: SUSPEND (cd=%p)\n", __func__, cd);
+		rc = cyttsp4_core_sleep(cd);
+		if (rc)
+			dev_err(dev, "%s: Suspend failed rc=%d\n",
+				__func__, rc);
+		else
+			dev_info(dev, "%s: Suspend succeeded\n", __func__);
+		break;
+
+	case CY_DBG_RESUME:
+		dev_info(dev, "%s: RESUME (cd=%p)\n", __func__, cd);
+		rc = cyttsp4_core_wake(cd);
+		if (rc)
+			dev_err(dev, "%s: Resume failed rc=%d\n",
+				__func__, rc);
+		else
+			dev_info(dev, "%s: Resume succeeded\n", __func__);
+		break;
+	case CY_DBG_SOFT_RESET:
+		dev_info(dev, "%s: SOFT RESET (cd=%p)\n", __func__, cd);
+		rc = cyttsp4_hw_soft_reset(cd);
+		break;
+	case CY_DBG_RESET:
+		dev_info(dev, "%s: HARD RESET (cd=%p)\n", __func__, cd);
+		rc = cyttsp4_hw_hard_reset(cd);
+		break;
+	default:
+		dev_err(dev, "%s: Invalid value\n", __func__);
+	}
+
+cyttsp4_drv_debug_store_exit:
+	return size;
+}
+
+/*
+ * Show system status on deep sleep status via sysfs
+ */
+static ssize_t cyttsp4_sleep_status_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	ssize_t ret;
+
+	mutex_lock(&cd->system_lock);
+	if (cd->sleep_state == SS_SLEEP_ON)
+		ret = snprintf(buf, CY_MAX_PRBUF_SIZE,
+				"Deep Sleep is ENABLED\n");
+	else
+		ret = snprintf(buf, CY_MAX_PRBUF_SIZE,
+				"Deep Sleep is DISABLED\n");
+	mutex_unlock(&cd->system_lock);
+
+	return ret;
+}
+
+#if ZTEMT_TP_WAKEUP_GESTURE_FUNCTION
+static ssize_t cyttsp4_easy_wakeup_gesture_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	ssize_t ret;
+
+	mutex_lock(&cd->system_lock);
+	ret = snprintf(buf, CY_MAX_PRBUF_SIZE, "0x%02X\n",
+			cd->easy_wakeup_gesture);
+	mutex_unlock(&cd->system_lock);
+	return ret;
+}
+
+static ssize_t cyttsp4_easy_wakeup_gesture_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	unsigned long value;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &value);
+	if (ret < 0)
+		return ret;
+
+	if (value > 0xFF && value < 0)
+		return -EINVAL;
+
+	pm_runtime_get_sync(dev);
+
+	mutex_lock(&cd->system_lock);
+	if (cd->sysinfo.ready && IS_TTSP_VER_GE(&cd->sysinfo, 2, 2))
+		cd->easy_wakeup_gesture = (u8)value;
+	else
+		ret = -ENODEV;
+	mutex_unlock(&cd->system_lock);
+
+	pm_runtime_put(dev);
+
+	if (ret)
+		return ret;
+
+	return size;
+}
+#endif
+
+static struct device_attribute attributes[] = {
+	__ATTR(ic_ver, S_IRUGO, cyttsp4_ic_ver_show, NULL),
+	__ATTR(ttconfig_ver, S_IRUGO, cyttsp4_ttconfig_ver_show, NULL),
+	__ATTR(drv_ver, S_IRUGO, cyttsp4_drv_ver_show, NULL),
+	__ATTR(hw_reset, S_IWUSR, NULL, cyttsp4_hw_reset_store),
+	__ATTR(hw_irq_stat, S_IRUSR, cyttsp4_hw_irq_stat_show, NULL),
+	__ATTR(drv_irq, S_IRUSR | S_IWUSR, cyttsp4_drv_irq_show,
+		cyttsp4_drv_irq_store),
+	__ATTR(drv_debug, S_IWUSR, NULL, cyttsp4_drv_debug_store),
+	__ATTR(sleep_status, S_IRUSR, cyttsp4_sleep_status_show, NULL),
+#if ZTEMT_TP_WAKEUP_GESTURE_FUNCTION
+	__ATTR(easy_wakeup_gesture, 0660,
+		cyttsp4_easy_wakeup_gesture_show,
+		cyttsp4_easy_wakeup_gesture_store),
+#endif
+};
+
+static int add_sysfs_interfaces(struct cyttsp4_core_data *cd,
+		struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto undo;
+
+	return 0;
+undo:
+	for (i--; i >= 0 ; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s: failed to create sysfs interface\n", __func__);
+	return -ENODEV;
+}
+
+static void remove_sysfs_interfaces(struct cyttsp4_core_data *cd,
+		struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+}
+
+#if 0
+/*luochangyang 2014/05/04*/
+static int cyttsp4_core_parse_dt(struct device * dev,
+		struct cyttsp4_core_platform_data * pdata)
+{
+	struct device_node *np = dev->of_node; 
+
+	/* reset, irq gpio info */
+ 	pdata->rst_gpio = of_get_named_gpio(np, "cypress,reset-gpio", 0);
+	pdata->irq_gpio = of_get_named_gpio(np, "cypress,irq-gpio", 0);
+    
+    return 0;
+}
+/*luochangyang END*/
+#endif
+
+static int cyttsp4_core_probe(struct cyttsp4_core *core)
+{
+	struct cyttsp4_core_data *cd;
+	struct device *dev = &core->dev;
+	struct cyttsp4_core_platform_data *pdata = dev_get_platdata(dev);
+	enum cyttsp4_atten_type type;
+	unsigned long irq_flags;
+	int rc = 0;
+
+	dev_dbg(dev, "%s: startup\n", __func__);
+	dev_dbg(dev, "%s: debug on\n", __func__);
+	dev_vdbg(dev, "%s: verbose debug on\n", __func__);
+
+	if (pdata == NULL) {
+		dev_err(dev, "%s: Missing platform data\n", __func__);
+		rc = -ENODEV;
+		goto error_no_pdata;
+	}
+
+	/* get context and debug print buffers */
+	cd = kzalloc(sizeof(*cd), GFP_KERNEL);
+	if (cd == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto error_alloc_data;
+	}
+#if 0
+	/*luochangyang 2014/05/04*/
+	cyttsp4_core_parse_dt(dev, pdata);
+	/*luochangyang END*/
+#endif
+	/* Initialize device info */
+	cd->core = core;
+	cd->dev = dev;
+	cd->pdata = pdata;
+	cd->max_xfer = CY_DEFAULT_ADAP_MAX_XFER;
+	if (pdata->max_xfer_len) {
+		if (pdata->max_xfer_len < CY_ADAP_MIN_XFER) {
+			dev_err(dev, "%s: max_xfer_len invalid (min=%d)\n",
+				__func__, CY_ADAP_MIN_XFER);
+			rc = -EINVAL;
+			goto error_alloc_data;
+		}
+		cd->max_xfer = pdata->max_xfer_len;
+		dev_dbg(dev, "%s: max_xfer set to %d\n",
+			__func__, cd->max_xfer);
+	}
+
+    /* Call platform init function */
+  if (cd->pdata->init) {
+        dev_dbg(cd->dev, "%s: Init HW\n", __func__);
+        rc = cd->pdata->init(cd->pdata, 1, cd->dev);
+  } else {
+        dev_info(cd->dev, "%s: No HW INIT function\n", __func__);
+        rc = 0;
+  }
+  if (rc < 0){
+        dev_err(cd->dev, "%s: HW Init fail r=%d\n", __func__, rc);
+        goto error_gpio_irq;
+  }
+
+	/* Initialize mutexes and spinlocks */
+	mutex_init(&cd->system_lock);
+	mutex_init(&cd->adap_lock);
+	spin_lock_init(&cd->spinlock);
+
+	/* Initialize attention lists */
+	for (type = 0; type < CY_ATTEN_NUM_ATTEN; type++)
+		INIT_LIST_HEAD(&cd->atten_list[type]);
+
+	/* Initialize wait queue */
+	init_waitqueue_head(&cd->wait_q);
+
+	/* Initialize works */
+	INIT_WORK(&cd->startup_work, cyttsp4_startup_work_function);
+	INIT_WORK(&cd->watchdog_work, cyttsp4_watchdog_work);
+
+	/* Initialize IRQ */
+	cd->irq = gpio_to_irq(pdata->irq_gpio);
+	if (cd->irq < 0) {
+		rc = -EINVAL;
+        dev_err(cd->dev, "%s: gpio_to_irq fail rc=%d\n", __func__, rc);
+		goto error_gpio_irq;
+	}
+	cd->irq_enabled = true;
+
+	dev_set_drvdata(dev, cd);
+
+
+	/* Call platform detect function */
+	if (cd->pdata->detect) {
+		dev_info(cd->dev, "%s: Detect HW\n", __func__);
+		rc = cd->pdata->detect(cd->pdata, cd->dev,
+				cyttsp4_platform_detect_read);
+		if (rc) {
+			dev_info(cd->dev, "%s: No HW detected\n", __func__);
+			rc = -ENODEV;
+			goto error_detect;
+		}
+	}
+
+	dev_dbg(dev, "%s: initialize threaded irq=%d\n", __func__, cd->irq);
+	if (cd->pdata->level_irq_udelay > 0)
+		/* use level triggered interrupts */
+		irq_flags = IRQF_TRIGGER_LOW | IRQF_ONESHOT;
+	else
+		/* use edge triggered interrupts */
+		irq_flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT;
+
+	rc = request_threaded_irq(cd->irq, cyttsp4_hard_irq, cyttsp4_irq,
+			irq_flags, dev_name(dev), cd);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error, could not request irq\n", __func__);
+		goto error_request_irq;
+	}
+
+	/* Setup watchdog timer */
+	setup_timer(&cd->watchdog_timer, cyttsp4_watchdog_timer,
+		(unsigned long)cd);
+
+	pm_runtime_enable(dev);
+
+	/*
+	 * call startup directly to ensure that the device
+	 * is tested before leaving the probe
+	 */
+	dev_dbg(dev, "%s: call startup\n", __func__);
+
+	pm_runtime_get_sync(dev);
+	rc = cyttsp4_startup(cd);
+	pm_runtime_put(dev);
+
+	/* Do not fail probe if startup fails but the device is detected */
+	if (rc == -ENODEV) {
+		dev_err(cd->dev, "%s: Fail initial startup r=%d\n",
+			__func__, rc);
+		goto error_startup;
+	}
+
+	if (IS_TTSP_VER_GE(&cd->sysinfo, 2, 2))
+		cd->easy_wakeup_gesture = pdata->easy_wakeup_gesture;
+	else
+		cd->easy_wakeup_gesture = 0xFF;
+
+	dev_dbg(dev, "%s: add sysfs interfaces\n", __func__);
+	rc = add_sysfs_interfaces(cd, dev);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error, fail sysfs init\n", __func__);
+		goto error_startup;
+	}
+
+#if ZTEMT_CYPRESS_WAKEUP_GESTURE_DEBUG
+	cd->easy_wakeup_gesture = 1;
+#endif
+
+	device_init_wakeup(dev, 1);
+
+/* ZTEMT Added by luochangyang, 2013/07/10 */
+#if defined(CONFIG_FB)
+        cd->fb_notif.notifier_call = cyttsp4_fb_notifier_callback;
+    
+        rc = fb_register_client(&cd->fb_notif);
+        if (rc) {
+            dev_err(dev, "%s:Unable to register fb_notifier: %d\n", __func__, rc);
+        }
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	/* ZTEMT Added by LiuYongfeng, 2012/10/17 */
+	cd->es.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	cd->es.suspend = cyttsp4_core_early_suspend;
+	cd->es.resume = cyttsp4_core_late_resume;
+	register_early_suspend(&cd->es);
+#endif 
+/* ZTEMT END */
+
+	dev_dbg(dev, "%s: ok\n", __func__);
+	return 0;
+
+error_startup:
+	cancel_work_sync(&cd->startup_work);
+	cyttsp4_stop_wd_timer(cd);
+	pm_runtime_disable(dev);
+	cyttsp4_free_si_ptrs(cd);
+	free_irq(cd->irq, cd);
+error_request_irq:
+error_detect:
+	if (pdata->init)
+		pdata->init(pdata, 0, dev);
+	dev_set_drvdata(dev, NULL);
+error_gpio_irq:
+	kfree(cd);
+error_alloc_data:
+error_no_pdata:
+	dev_err(dev, "%s failed.\n", __func__);
+	return rc;
+}
+
+static int cyttsp4_core_release(struct cyttsp4_core *core)
+{
+	struct device *dev = &core->dev;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	/*
+	 * Suspend the device before freeing the startup_work and stopping
+	 * the watchdog since sleep function restarts watchdog on failure
+	 */
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+
+	cancel_work_sync(&cd->startup_work);
+
+	cyttsp4_stop_wd_timer(cd);
+
+	remove_sysfs_interfaces(cd, dev);
+	free_irq(cd->irq, cd);
+    
+/* ZTEMT Added by luochangyang, 2013/07/10 */
+#if defined(CONFIG_FB)
+	if (fb_unregister_client(&cd->fb_notif))
+		dev_err(dev, "%s: Error occurred while unregistering fb_notifier.\n", __func__);
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+    unregister_early_suspend(&cd->es);
+#endif 
+    /* ZTEMT END */
+    
+	if (cd->pdata->init)
+		cd->pdata->init(cd->pdata, 0, dev);
+	dev_set_drvdata(dev, NULL);
+	cyttsp4_free_si_ptrs(cd);
+	kfree(cd);
+	return 0;
+}
+
+static struct cyttsp4_core_driver cyttsp4_core_driver = {
+	.probe = cyttsp4_core_probe,
+	.remove = cyttsp4_core_release,
+	.subscribe_attention = cyttsp4_subscribe_attention_,
+	.unsubscribe_attention = cyttsp4_unsubscribe_attention_,
+	.request_exclusive = cyttsp4_request_exclusive_,
+	.release_exclusive = cyttsp4_release_exclusive_,
+	.request_reset = cyttsp4_request_reset_,
+	.request_restart = cyttsp4_request_restart_,
+	.request_set_mode = cyttsp4_request_set_mode_,
+	.request_sysinfo = cyttsp4_request_sysinfo_,
+	.request_loader_pdata = cyttsp4_request_loader_pdata_,
+	.request_handshake = cyttsp4_request_handshake_,
+	.request_exec_cmd = cyttsp4_request_exec_cmd_,
+	.request_stop_wd = cyttsp4_request_stop_wd_,
+	.request_toggle_lowpower = cyttsp4_request_toggle_lowpower_,
+	.request_config_row_size = cyttsp4_request_config_row_size_,
+	.request_write_config = cyttsp4_request_write_config_,
+	.request_enable_scan_type = cyttsp4_request_enable_scan_type_,
+	.request_disable_scan_type = cyttsp4_request_disable_scan_type_,
+	.get_security_key = cyttsp4_get_security_key_,
+	.get_touch_record = cyttsp4_get_touch_record_,
+	.write = cyttsp4_write_,
+	.read = cyttsp4_read_,
+	.driver = {
+		.name = CYTTSP4_CORE_NAME,
+		.bus = &cyttsp4_bus_type,
+		.owner = THIS_MODULE,
+		.pm = &cyttsp4_core_pm_ops,
+	},
+};
+
+static int __init cyttsp4_core_init(void)
+{
+	int rc = 0;
+
+	rc = cyttsp4_register_core_driver(&cyttsp4_core_driver);
+	pr_debug("%s: Cypress TTSP v4 core driver (Built %s) rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return rc;
+}
+module_init(cyttsp4_core_init);
+
+static void __exit cyttsp4_core_exit(void)
+{
+	cyttsp4_unregister_core_driver(&cyttsp4_core_driver);
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_core_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard touchscreen core driver");
+MODULE_AUTHOR("Aleksej Makarov <aleksej.makarov@sonyericsson.com>");
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_core.h b/drivers/input/touchscreen/cyttsp4/cyttsp4_core.h
new file mode 100755
index 0000000..bf49471
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_core.h
@@ -0,0 +1,150 @@
+/*
+ * cyttsp4_core.h
+ * Cypress TrueTouch(TM) Standard Product V4 Core driver module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ * Modifed by: Cypress Semiconductor to add touch settings
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_CORE_H
+#define _LINUX_CYTTSP4_CORE_H
+
+#include <linux/stringify.h>
+#include "cyttsp4_regs.h"
+
+#define CYTTSP4_CORE_NAME "cyttsp4_core"
+
+#define CY_DRIVER_NAME TTDA
+#define CY_DRIVER_MAJOR 02
+#define CY_DRIVER_MINOR 03
+
+#define CY_DRIVER_REVCTRL 467394
+
+#define CY_DRIVER_VERSION		    \
+__stringify(CY_DRIVER_NAME)		    \
+"." __stringify(CY_DRIVER_MAJOR)	    \
+"." __stringify(CY_DRIVER_MINOR)	    \
+"." __stringify(CY_DRIVER_REVCTRL)
+
+#define CY_DRIVER_DATE "20130429"	/* YYYYMMDD */
+
+/* x-axis resolution of panel in pixels */
+#define CY_PCFG_RESOLUTION_X_MASK 0x7F
+
+/* y-axis resolution of panel in pixels */
+#define CY_PCFG_RESOLUTION_Y_MASK 0x7F
+
+/* x-axis, 0:origin is on left side of panel, 1: right */
+#define CY_PCFG_ORIGIN_X_MASK 0x80
+
+/* y-axis, 0:origin is on top side of panel, 1: bottom */
+#define CY_PCFG_ORIGIN_Y_MASK 0x80
+
+#define CY_TOUCH_SETTINGS_MAX 32
+#define CY_TOUCH_SETTINGS_PARAM_REGS 6
+
+enum cyttsp4_core_platform_flags {
+	CY_CORE_FLAG_NONE = 0x00,
+	CY_CORE_FLAG_WAKE_ON_GESTURE = 0x01,
+};
+
+enum cyttsp4_core_platform_easy_wakeup_gesture {
+	CY_CORE_EWG_NONE = 0x00,
+	CY_CORE_EWG_TAP_TAP = 0x01,
+	CY_CORE_EWG_TWO_FINGER_SLIDE = 0x02,
+	CY_CORE_EWG_RESERVED = 0x03,
+	CY_CORE_EWG_WAKE_ON_INT_FROM_HOST = 0xFF,
+};
+
+enum cyttsp4_loader_platform_flags {
+	CY_LOADER_FLAG_NONE = 0x00,
+	CY_LOADER_FLAG_CALIBRATE_AFTER_FW_UPGRADE = 0x01,
+	/* Use CONFIG_VER field in TT_CFG to decide TT_CFG update */
+	CY_LOADER_FLAG_CHECK_TTCONFIG_VERSION = 0x02,
+};
+
+struct touch_settings {
+	const uint8_t   *data;
+	uint32_t         size;
+	uint8_t         tag;
+} __packed;
+
+struct cyttsp4_touch_firmware {
+	const uint8_t *img;
+	uint32_t size;
+	const uint8_t *ver;
+	uint8_t vsize;
+} __packed;
+
+struct cyttsp4_touch_config {
+	struct touch_settings *param_regs;
+	struct touch_settings *param_size;
+	const uint8_t *fw_ver;
+	uint8_t fw_vsize;
+};
+
+struct cyttsp4_loader_platform_data {
+	struct cyttsp4_touch_firmware *fw;
+	struct cyttsp4_touch_config *ttconfig;
+	u32 flags;
+} __packed;
+
+typedef int (*cyttsp4_platform_read) (struct device *dev, u16 addr,
+	void *buf, int size);
+
+struct cyttsp4_core_platform_data {
+	int irq_gpio;
+	int rst_gpio;
+	int level_irq_udelay;
+	int max_xfer_len;
+	int (*xres)(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev);
+	int (*init)(struct cyttsp4_core_platform_data *pdata,
+		int on, struct device *dev);
+	int (*power)(struct cyttsp4_core_platform_data *pdata,
+		int on, struct device *dev, atomic_t *ignore_irq);
+	int (*detect)(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev, cyttsp4_platform_read read);
+	int (*irq_stat)(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev);
+	struct touch_settings *sett[CY_TOUCH_SETTINGS_MAX];
+	struct cyttsp4_loader_platform_data *loader_pdata;
+	u32 flags;
+	u8 easy_wakeup_gesture;
+/* ZTEMT Added by LiuYongfeng, 2012/11/19 */
+	int (*check_version)(struct cyttsp4_sysinfo *si);
+/* ZTEMT END */
+};
+
+#ifdef VERBOSE_DEBUG
+extern void cyttsp4_pr_buf(struct device *dev, u8 *pr_buf, u8 *dptr, int size,
+			   const char *data_name);
+#else
+#define cyttsp4_pr_buf(a, b, c, d, e) do { } while (0)
+#endif
+
+#endif /* _LINUX_CYTTSP4_CORE_H */
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_debug.c b/drivers/input/touchscreen/cyttsp4/cyttsp4_debug.c
new file mode 100755
index 0000000..126fb03
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_debug.c
@@ -0,0 +1,608 @@
+/*
+ * cyttsp4_debug.c
+ * Cypress TrueTouch(TM) Standard Product V4 Core driver module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ * Modified by: Cypress Semiconductor to add device functions
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include "cyttsp4_bus.h"
+#include "cyttsp4_core.h"
+
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/limits.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+
+#include "cyttsp4_regs.h"
+
+#define CYTTSP4_DEBUG_NAME "cyttsp4_debug"
+
+enum cyttsp4_monitor_status {
+	CY_MNTR_DISABLED,
+	CY_MNTR_ENABLED,
+};
+
+struct cyttsp4_sensor_monitor {
+	enum cyttsp4_monitor_status mntr_status;
+	u8 sensor_data[150];		/* operational sensor data */
+};
+
+struct cyttsp4_debug_data {
+	struct cyttsp4_device *ttsp;
+	struct cyttsp4_debug_platform_data *pdata;
+	struct cyttsp4_sysinfo *si;
+	uint32_t interrupt_count;
+	uint32_t formated_output;
+	struct mutex sysfs_lock;
+	struct cyttsp4_sensor_monitor monitor;
+	u8 pr_buf[CY_MAX_PRBUF_SIZE];
+};
+
+struct cyttsp4_debug_platform_data {
+	char const *debug_dev_name;
+};
+
+/*
+ * This function provide output of combined xy_mode and xy_data.
+ * Required by TTHE.
+ */
+static void cyttsp4_pr_buf_op_mode(struct device *dev, u8 *pr_buf,
+		struct cyttsp4_sysinfo *si, u8 cur_touch)
+{
+	int i, k;
+	const char fmt[] = "%02X ";
+	int max = (CY_MAX_PRBUF_SIZE - 1) - sizeof(CY_PR_TRUNCATED);
+	int total_size = si->si_ofs.mode_size
+			+ (cur_touch * si->si_ofs.tch_rec_size);
+	u8 num_btns = si->si_ofs.num_btns;
+
+	pr_buf[0] = 0;
+	for (i = k = 0; i < si->si_ofs.mode_size && i < max; i++, k += 3)
+		scnprintf(pr_buf + k, CY_MAX_PRBUF_SIZE, fmt, si->xy_mode[i]);
+
+	for (i = 0; i < (cur_touch * si->si_ofs.tch_rec_size) && i < max;
+			i++, k += 3)
+		scnprintf(pr_buf + k, CY_MAX_PRBUF_SIZE, fmt, si->xy_data[i]);
+
+	if (num_btns) {
+		/* print btn diff data for TTHE */
+		scnprintf(pr_buf + k, CY_MAX_PRBUF_SIZE, "%s", "=");
+		k++;
+		for (i = 0; i < (num_btns * si->si_ofs.btn_rec_size) && i < max;
+				i++, k += 3)
+			scnprintf(pr_buf + k, CY_MAX_PRBUF_SIZE, fmt,
+					si->btn_rec_data[i]);
+		total_size += num_btns * si->si_ofs.btn_rec_size + 1;
+	}
+	//pr_info("%s=%s%s\n", "cyttsp4_OpModeData", pr_buf,
+	//		totalSize <= max ? "" : CY_PR_TRUNCATED);
+}
+
+static void cyttsp4_debug_print(struct device *dev, u8 *pr_buf, u8 *sptr,
+		int size, const char *data_name)
+{
+	int i, j;
+	int elem_size = sizeof("XX ") - 1;
+	int max = (CY_MAX_PRBUF_SIZE - 1) / elem_size;
+	int limit = size < max ? size : max;
+
+	if (limit < 0)
+		limit = 0;
+
+	pr_buf[0] = 0;
+	for (i = j = 0; i < limit; i++, j += elem_size)
+		scnprintf(pr_buf + j, CY_MAX_PRBUF_SIZE - j, "%02X ", sptr[i]);
+
+	//pr_info("%s[0..%d]=%s%s\n", data_name, size - 1, pr_buf,
+	//		size <= max ? "" : CY_PR_TRUNCATED);
+}
+
+static void cyttsp4_debug_formated(struct device *dev, u8 *pr_buf,
+		struct cyttsp4_sysinfo *si, u8 num_cur_rec)
+{
+	u8 mode_size = si->si_ofs.mode_size;
+	u8 rep_len = si->xy_mode[si->si_ofs.rep_ofs];
+	u8 tch_rec_size = si->si_ofs.tch_rec_size;
+	u8 num_btns = si->si_ofs.num_btns;
+	u8 num_btn_regs = (num_btns + CY_NUM_BTN_PER_REG - 1)
+			/ CY_NUM_BTN_PER_REG;
+	u8 num_btn_tch;
+	u8 data_name[] = "touch[99]";
+	int max_print_length = 18;
+	int i;
+
+	/* xy_mode */
+	cyttsp4_debug_print(dev, pr_buf, si->xy_mode, mode_size, "xy_mode");
+
+	/* xy_data */
+	if (rep_len > max_print_length) {
+		//pr_info("xy_data[0..%d]:\n", rep_len);
+		for (i = 0; i < rep_len - max_print_length;
+				i += max_print_length) {
+			cyttsp4_debug_print(dev, pr_buf, si->xy_data + i,
+					max_print_length, " ");
+		}
+		if (rep_len - i)
+			cyttsp4_debug_print(dev, pr_buf, si->xy_data + i,
+					rep_len - i, " ");
+	} else {
+		cyttsp4_debug_print(dev, pr_buf, si->xy_data,
+				rep_len - si->si_ofs.rep_hdr_size, "xy_data");
+	}
+
+	/* touches */
+	for (i = 0; i < num_cur_rec; i++) {
+		scnprintf(data_name, sizeof(data_name) - 1, "touch[%u]", i);
+		cyttsp4_debug_print(dev, pr_buf,
+				si->xy_data + (i * tch_rec_size),
+				tch_rec_size, data_name);
+	}
+
+	/* buttons */
+	if (num_btns) {
+		num_btn_tch = 0;
+		for (i = 0; i < num_btn_regs; i++) {
+			if (si->xy_mode[si->si_ofs.rep_ofs + 2 + i]) {
+				num_btn_tch++;
+				break;
+			}
+		}
+		if (num_btn_tch)
+			cyttsp4_debug_print(dev, pr_buf,
+					&si->xy_mode[si->si_ofs.rep_ofs + 2],
+					num_btn_regs, "button");
+	}
+}
+
+/* read xy_data for all touches for debug */
+static int cyttsp4_xy_worker(struct cyttsp4_debug_data *dd)
+{
+	struct device *dev = &dd->ttsp->dev;
+	struct cyttsp4_sysinfo *si = dd->si;
+	u8 tt_stat = si->xy_mode[si->si_ofs.tt_stat_ofs];
+	u8 num_cur_rec = GET_NUM_TOUCH_RECORDS(tt_stat);
+	uint32_t formated_output;
+	int rc;
+
+	mutex_lock(&dd->sysfs_lock);
+	dd->interrupt_count++;
+	formated_output = dd->formated_output;
+	mutex_unlock(&dd->sysfs_lock);
+
+	/* Read command parameters */
+	rc = cyttsp4_read(dd->ttsp, CY_MODE_OPERATIONAL,
+			si->si_ofs.cmd_ofs + 1,
+			&si->xy_mode[si->si_ofs.cmd_ofs + 1],
+			si->si_ofs.rep_ofs - si->si_ofs.cmd_ofs - 1);
+	if (rc < 0) {
+		dev_err(dev, "%s: read fail on command parameter regs r=%d\n",
+				__func__, rc);
+	}
+
+	if (si->si_ofs.num_btns > 0) {
+		/* read button diff data */
+		rc = cyttsp4_read(dd->ttsp, CY_MODE_OPERATIONAL,
+				/*  replace with btn_diff_ofs when that field
+				 *  becomes supported in the firmware */
+				si->si_ofs.tt_stat_ofs + 1 +
+				si->si_ofs.max_tchs * si->si_ofs.tch_rec_size,
+				si->btn_rec_data,
+				si->si_ofs.num_btns * si->si_ofs.btn_rec_size);
+		if (rc < 0) {
+			dev_err(dev, "%s: read fail on button regs r=%d\n",
+					__func__, rc);
+		}
+	}
+
+	/* Interrupt */
+	//pr_info("Interrupt(%u)\n", dd->interrupt_count);
+
+	if (formated_output)
+		cyttsp4_debug_formated(dev, dd->pr_buf, si, num_cur_rec);
+	else
+		/* print data for TTHE */
+		cyttsp4_pr_buf_op_mode(dev, dd->pr_buf, si, num_cur_rec);
+
+	if (dd->monitor.mntr_status == CY_MNTR_ENABLED) {
+		int offset = (si->si_ofs.max_tchs * si->si_ofs.tch_rec_size)
+				+ (si->si_ofs.num_btns
+					* si->si_ofs.btn_rec_size)
+				+ (si->si_ofs.tt_stat_ofs + 1);
+		rc = cyttsp4_read(dd->ttsp, CY_MODE_OPERATIONAL,
+				offset, &(dd->monitor.sensor_data[0]), 150);
+		if (rc < 0)
+			dev_err(dev, "%s: read fail on sensor monitor regs r=%d\n",
+					__func__, rc);
+		/* print data for the sensor monitor */
+		cyttsp4_debug_print(dev, dd->pr_buf, dd->monitor.sensor_data,
+				150, "cyttsp4_sensor_monitor");
+	}
+
+	//pr_info("\n");
+
+	dev_vdbg(dev, "%s: done\n", __func__);
+
+	return 0;
+}
+
+static int cyttsp4_debug_op_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+	int rc = 0;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	/* core handles handshake */
+	rc = cyttsp4_xy_worker(dd);
+	if (rc < 0)
+		dev_err(dev, "%s: xy_worker error r=%d\n", __func__, rc);
+
+	return rc;
+}
+
+static int cyttsp4_debug_cat_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+	struct cyttsp4_sysinfo *si = dd->si;
+	u8 cat_masked_cmd;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	/* Check for CaT command executed */
+	cat_masked_cmd = si->xy_mode[CY_REG_CAT_CMD] & CY_CMD_MASK;
+	if (cat_masked_cmd == CY_CMD_CAT_START_SENSOR_DATA_MODE) {
+		dev_vdbg(dev, "%s: Sensor data mode enabled\n", __func__);
+		dd->monitor.mntr_status = CY_MNTR_ENABLED;
+	} else if (cat_masked_cmd == CY_CMD_CAT_STOP_SENSOR_DATA_MODE) {
+		dev_vdbg(dev, "%s: Sensor data mode disabled\n", __func__);
+		dd->monitor.mntr_status = CY_MNTR_DISABLED;
+	}
+
+	return 0;
+}
+
+static int cyttsp4_debug_startup_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	dd->monitor.mntr_status = CY_MNTR_DISABLED;
+
+	return 0;
+}
+
+static ssize_t cyttsp4_interrupt_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+	int val;
+
+	mutex_lock(&dd->sysfs_lock);
+	val = dd->interrupt_count;
+	mutex_unlock(&dd->sysfs_lock);
+
+	return scnprintf(buf, CY_MAX_PRBUF_SIZE, "Interrupt Count: %d\n", val);
+}
+
+static ssize_t cyttsp4_interrupt_count_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+	mutex_lock(&dd->sysfs_lock);
+	dd->interrupt_count = 0;
+	mutex_unlock(&dd->sysfs_lock);
+	return size;
+}
+
+static DEVICE_ATTR(int_count, S_IRUSR | S_IWUSR,
+	cyttsp4_interrupt_count_show, cyttsp4_interrupt_count_store);
+
+static ssize_t cyttsp4_formated_output_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+	int val;
+
+	mutex_lock(&dd->sysfs_lock);
+	val = dd->formated_output;
+	mutex_unlock(&dd->sysfs_lock);
+
+	return scnprintf(buf, CY_MAX_PRBUF_SIZE,
+			"Formated debug output: %x\n", val);
+}
+
+static ssize_t cyttsp4_formated_output_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+	unsigned long value;
+	int rc;
+
+	rc = kstrtoul(buf, 10, &value);
+	if (rc < 0) {
+		dev_err(dev, "%s: Invalid value\n", __func__);
+		return size;
+	}
+
+	/* Expecting only 0 or 1 */
+	if (value != 0 && value != 1) {
+		dev_err(dev, "%s: Invalid value %lu\n", __func__, value);
+		return size;
+	}
+
+	mutex_lock(&dd->sysfs_lock);
+	dd->formated_output = value;
+	mutex_unlock(&dd->sysfs_lock);
+	return size;
+}
+
+static DEVICE_ATTR(formated_output, S_IRUSR | S_IWUSR,
+	cyttsp4_formated_output_show, cyttsp4_formated_output_store);
+
+static int cyttsp4_debug_probe(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_debug_data *dd;
+	struct cyttsp4_debug_platform_data *pdata = dev_get_platdata(dev);
+	int rc;
+
+	//dev_info(dev, "%s: startup\n", __func__);
+	dev_dbg(dev, "%s: debug on\n", __func__);
+	dev_vdbg(dev, "%s: verbose debug on\n", __func__);
+
+	/* get context and debug print buffers */
+	dd = kzalloc(sizeof(*dd), GFP_KERNEL);
+	if (dd == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto cyttsp4_debug_probe_alloc_failed;
+	}
+
+	rc = device_create_file(dev, &dev_attr_int_count);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create int_count\n",
+				__func__);
+		goto cyttsp4_debug_probe_create_int_count_failed;
+	}
+
+	rc = device_create_file(dev, &dev_attr_formated_output);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create formated_output\n",
+				__func__);
+		goto cyttsp4_debug_probe_create_formated_failed;
+	}
+
+	mutex_init(&dd->sysfs_lock);
+	dd->ttsp = ttsp;
+	dd->pdata = pdata;
+	dev_set_drvdata(dev, dd);
+
+	pm_runtime_enable(dev);
+
+	dd->si = cyttsp4_request_sysinfo(ttsp);
+	if (dd->si == NULL) {
+		dev_err(dev, "%s: Fail get sysinfo pointer from core\n",
+				__func__);
+		rc = -ENODEV;
+		goto cyttsp4_debug_probe_sysinfo_failed;
+	}
+
+	rc = cyttsp4_subscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_debug_op_attention, CY_MODE_OPERATIONAL);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error, could not subscribe Operating mode attention cb\n",
+				__func__);
+		goto cyttsp4_debug_probe_subscribe_op_failed;
+	}
+
+	rc = cyttsp4_subscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_debug_cat_attention, CY_MODE_CAT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error, could not subscribe CaT mode attention cb\n",
+				__func__);
+		goto cyttsp4_debug_probe_subscribe_cat_failed;
+	}
+
+	rc = cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_debug_startup_attention, 0);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error, could not subscribe startup attention cb\n",
+				__func__);
+		goto cyttsp4_debug_probe_subscribe_startup_failed;
+	}
+	return 0;
+
+cyttsp4_debug_probe_subscribe_startup_failed:
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_debug_cat_attention, CY_MODE_CAT);
+cyttsp4_debug_probe_subscribe_cat_failed:
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_debug_op_attention, CY_MODE_OPERATIONAL);
+cyttsp4_debug_probe_subscribe_op_failed:
+cyttsp4_debug_probe_sysinfo_failed:
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+	dev_set_drvdata(dev, NULL);
+	device_remove_file(dev, &dev_attr_formated_output);
+cyttsp4_debug_probe_create_formated_failed:
+	device_remove_file(dev, &dev_attr_int_count);
+cyttsp4_debug_probe_create_int_count_failed:
+	kfree(dd);
+cyttsp4_debug_probe_alloc_failed:
+	dev_err(dev, "%s failed.\n", __func__);
+	return rc;
+}
+
+static int cyttsp4_debug_release(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+	int rc = 0;
+	dev_dbg(dev, "%s\n", __func__);
+
+	if (dev_get_drvdata(&ttsp->core->dev) == NULL) {
+		dev_err(dev, "%s: Unable to un-subscribe attention\n",
+				__func__);
+		goto cyttsp4_debug_release_exit;
+	}
+
+	/* Unsubscribe from attentions */
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_debug_op_attention, CY_MODE_OPERATIONAL);
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_debug_cat_attention, CY_MODE_CAT);
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_debug_startup_attention, 0);
+
+cyttsp4_debug_release_exit:
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+	device_remove_file(dev, &dev_attr_int_count);
+	dev_set_drvdata(dev, NULL);
+	kfree(dd);
+
+	return rc;
+}
+
+static struct cyttsp4_driver cyttsp4_debug_driver = {
+	.probe = cyttsp4_debug_probe,
+	.remove = cyttsp4_debug_release,
+	.driver = {
+		.name = CYTTSP4_DEBUG_NAME,
+		.bus = &cyttsp4_bus_type,
+		.owner = THIS_MODULE,
+	},
+};
+
+static struct cyttsp4_debug_platform_data
+	_cyttsp4_debug_platform_data = {
+	.debug_dev_name = CYTTSP4_DEBUG_NAME,
+};
+
+static const char cyttsp4_debug_name[] = CYTTSP4_DEBUG_NAME;
+static struct cyttsp4_device_info
+	cyttsp4_debug_infos[CY_MAX_NUM_CORE_DEVS];
+
+static const char *core_ids[CY_MAX_NUM_CORE_DEVS] = {
+	CY_DEFAULT_CORE_ID,
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static int num_core_ids = 1;
+
+//module_param_array(core_ids, charp, &num_core_ids, 0);
+//MODULE_PARM_DESC(core_ids,
+//	"Core id list of cyttsp4 core devices for debug module");
+
+static int __init cyttsp4_debug_init(void)
+{
+	int rc = 0;
+	int i, j;
+
+	/* Check for invalid or duplicate core_ids */
+	for (i = 0; i < num_core_ids; i++) {
+		if (!strlen(core_ids[i])) {
+			pr_err("%s: core_id %d is empty\n",
+				__func__, i+1);
+			return -EINVAL;
+		}
+		for (j = i+1; j < num_core_ids; j++)
+			if (!strcmp(core_ids[i], core_ids[j])) {
+				pr_err("%s: core_ids %d and %d are same\n",
+					__func__, i+1, j+1);
+				return -EINVAL;
+			}
+	}
+
+	for (i = 0; i < num_core_ids; i++) {
+		cyttsp4_debug_infos[i].name = cyttsp4_debug_name;
+		cyttsp4_debug_infos[i].core_id = core_ids[i];
+		cyttsp4_debug_infos[i].platform_data =
+			&_cyttsp4_debug_platform_data;
+		//pr_info("%s: Registering debug device for core_id: %s\n",
+		//	__func__, cyttsp4_debug_infos[i].core_id);
+		rc = cyttsp4_register_device(&cyttsp4_debug_infos[i]);
+		if (rc < 0) {
+			pr_err("%s: Error, failed registering device\n",
+				__func__);
+			goto fail_unregister_devices;
+		}
+	}
+	rc = cyttsp4_register_driver(&cyttsp4_debug_driver);
+	if (rc) {
+		pr_err("%s: Error, failed registering driver\n", __func__);
+		goto fail_unregister_devices;
+	}
+
+	//pr_info("%s: Cypress TTSP Debug (Built %s) rc=%d\n",
+	//	 __func__, CY_DRIVER_DATE, rc);
+	return 0;
+
+fail_unregister_devices:
+	for (i--; i >= 0; i--) {
+		cyttsp4_unregister_device(cyttsp4_debug_infos[i].name,
+			cyttsp4_debug_infos[i].core_id);
+		//pr_info("%s: Unregistering device access device for core_id: %s\n",
+		//	__func__, cyttsp4_debug_infos[i].core_id);
+	}
+	return rc;
+}
+module_init(cyttsp4_debug_init);
+
+static void __exit cyttsp4_debug_exit(void)
+{
+	int i;
+
+	cyttsp4_unregister_driver(&cyttsp4_debug_driver);
+	for (i = 0; i < num_core_ids; i++) {
+		cyttsp4_unregister_device(cyttsp4_debug_infos[i].name,
+			cyttsp4_debug_infos[i].core_id);
+		//pr_info("%s: Unregistering debug device for core_id: %s\n",
+		//	__func__, cyttsp4_debug_infos[i].core_id);
+	}
+	//pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_debug_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard touchscreen debug driver");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_device_access-api.h b/drivers/input/touchscreen/cyttsp4/cyttsp4_device_access-api.h
new file mode 100755
index 0000000..63f3716
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_device_access-api.h
@@ -0,0 +1,56 @@
+/*
+ * cyttsp4_device_access-api.h
+ * Cypress TrueTouch(TM) Standard Product V4 Device Access API module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_DEVICE_ACCESS_API_H
+#define _LINUX_CYTTSP4_DEVICE_ACCESS_API_H
+
+#include <linux/types.h>
+#include <linux/device.h>
+
+#define GRPNUM_OP_COMMAND	1
+#define GRPNUM_TOUCH_CONFIG	6
+
+#define OP_CMD_NULL		0
+#define OP_CMD_GET_PARAMETER	2
+#define OP_CMD_SET_PARAMETER	3
+#define OP_CMD_GET_CONFIG_CRC	5
+
+#define OP_PARAM_ACTIVE_DISTANCE		0x4A
+#define OP_PARAM_SCAN_TYPE			0x4B
+#define OP_PARAM_LOW_POWER_INTERVAL		0x4C
+#define OP_PARAM_REFRESH_INTERVAL		0x4D
+#define OP_PARAM_ACTIVE_MODE_TIMEOUT		0x4E
+#define OP_PARAM_ACTIVE_LOOK_FOR_TOUCH_INTERVAL 0x4F
+
+extern int cyttsp4_device_access_read_command(const char *core_name,
+		int ic_grpnum, int ic_grpoffset, u8 *buf, int buf_size);
+
+extern int cyttsp4_device_access_write_command(const char *core_name,
+		int ic_grpnum, int ic_grpoffset, u8 *buf, int length);
+
+#endif /* _LINUX_CYTTSP4_DEVICE_ACCESS_API_H */
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_device_access.c b/drivers/input/touchscreen/cyttsp4/cyttsp4_device_access.c
new file mode 100755
index 0000000..72241b1
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_device_access.c
@@ -0,0 +1,2335 @@
+/*
+ * cyttsp4_device_access.c
+ * Cypress TrueTouch(TM) Standard Product V4 Device Access module.
+ * Configuration and Test command/status user interface.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include "cyttsp4_bus.h"
+#include "cyttsp4_core.h"
+#include "cyttsp4_mt.h"
+
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/limits.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+#include <linux/workqueue.h>
+#include "cyttsp4_device_access.h"
+#include "cyttsp4_regs.h"
+
+#define CY_MAX_CONFIG_BYTES    256
+#define CY_CMD_INDEX             0
+#define CY_NULL_CMD_INDEX        1
+#define CY_NULL_CMD_MODE_INDEX   2
+#define CY_NULL_CMD_SIZE_INDEX   3
+#define CY_NULL_CMD_SIZEL_INDEX  2
+#define CY_NULL_CMD_SIZEH_INDEX  3
+
+struct heatmap_param {
+	bool scan_start;
+	enum cyttsp4_scan_data_type data_type; /* raw, base, diff */
+	int num_element;
+};
+
+struct cyttsp4_device_access_data {
+	struct cyttsp4_device *ttsp;
+	struct cyttsp4_device_access_platform_data *pdata;
+	struct cyttsp4_sysinfo *si;
+	struct cyttsp4_test_mode_params test;
+	struct mutex sysfs_lock;
+	uint32_t ic_grpnum;
+	uint32_t ic_grpoffset;
+	bool own_exclusive;
+	bool sysfs_nodes_created;
+#ifdef VERBOSE_DEBUG
+	u8 pr_buf[CY_MAX_PRBUF_SIZE];
+#endif
+	wait_queue_head_t wait_q;
+	u8 ic_buf[CY_MAX_PRBUF_SIZE];
+	u8 return_buf[CY_MAX_PRBUF_SIZE];
+	struct heatmap_param heatmap;
+};
+
+/*
+ * Show function prototype.
+ * Returns response length or Linux error code on error.
+ */
+typedef int (*cyttsp4_show_function) (struct device *dev, u8 *ic_buf,
+		size_t length);
+
+/*
+ * Store function prototype.
+ * Returns Linux error code on error.
+ */
+typedef int (*cyttsp4_store_function) (struct device *dev, u8 *ic_buf,
+		size_t length);
+
+/*
+ * grpdata show function to be used by
+ * reserved and not implemented ic group numbers.
+ */
+static int cyttsp4_grpdata_show_void (struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	return -ENOSYS;
+}
+
+/*
+ * grpdata store function to be used by
+ * reserved and not implemented ic group numbers.
+ */
+static int cyttsp4_grpdata_store_void (struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	return -ENOSYS;
+}
+
+/*
+ * SysFs group number entry show function.
+ */
+static ssize_t cyttsp4_ic_grpnum_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int val = 0;
+
+	mutex_lock(&dad->sysfs_lock);
+	val = dad->ic_grpnum;
+	mutex_unlock(&dad->sysfs_lock);
+
+	return scnprintf(buf, CY_MAX_PRBUF_SIZE, "Current Group: %d\n", val);
+}
+
+/*
+ * SysFs group number entry store function.
+ */
+static ssize_t cyttsp4_ic_grpnum_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	unsigned long value;
+	int prev_grpnum;
+	int rc;
+
+	rc = kstrtoul(buf, 10, &value);
+	if (rc < 0) {
+		dev_err(dev, "%s: Invalid value\n", __func__);
+		return size;
+	}
+
+	if (value >= CY_IC_GRPNUM_NUM) {
+		dev_err(dev, "%s: Group %lu does not exist.\n",
+				__func__, value);
+		return size;
+	}
+
+	if (value > 0xFF)
+		value = 0xFF;
+
+	mutex_lock(&dad->sysfs_lock);
+	/*
+	 * Block grpnum change when own_exclusive flag is set
+	 * which means the current grpnum implementation requires
+	 * running exclusively on some consecutive grpdata operations
+	 */
+	if (dad->own_exclusive) {
+		mutex_unlock(&dad->sysfs_lock);
+		dev_err(dev, "%s: own_exclusive\n", __func__);
+		return -EBUSY;
+	}
+	prev_grpnum = dad->ic_grpnum;
+	dad->ic_grpnum = (int) value;
+	mutex_unlock(&dad->sysfs_lock);
+
+	dev_vdbg(dev, "%s: ic_grpnum=%d, return size=%d\n",
+			__func__, (int)value, (int)size);
+	return size;
+}
+
+static DEVICE_ATTR(ic_grpnum, S_IRUSR | S_IWUSR,
+		   cyttsp4_ic_grpnum_show, cyttsp4_ic_grpnum_store);
+
+/*
+ * SysFs group offset entry show function.
+ */
+static ssize_t cyttsp4_ic_grpoffset_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int val = 0;
+
+	mutex_lock(&dad->sysfs_lock);
+	val = dad->ic_grpoffset;
+	mutex_unlock(&dad->sysfs_lock);
+
+	return scnprintf(buf, CY_MAX_PRBUF_SIZE, "Current Offset: %d\n", val);
+}
+
+/*
+ * SysFs group offset entry store function.
+ */
+static ssize_t cyttsp4_ic_grpoffset_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	unsigned long value;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &value);
+	if (ret < 0) {
+		dev_err(dev, "%s: Invalid value\n", __func__);
+		return size;
+	}
+
+	if (value > 0xFFFF)
+		value = 0xFFFF;
+
+	mutex_lock(&dad->sysfs_lock);
+	dad->ic_grpoffset = (int)value;
+	mutex_unlock(&dad->sysfs_lock);
+
+	dev_vdbg(dev, "%s: ic_grpoffset=%d, return size=%d\n", __func__,
+			(int)value, (int)size);
+	return size;
+}
+
+static DEVICE_ATTR(ic_grpoffset, S_IRUSR | S_IWUSR,
+		   cyttsp4_ic_grpoffset_show, cyttsp4_ic_grpoffset_store);
+
+/*
+ * Prints part of communication registers.
+ */
+static int cyttsp4_grpdata_show_registers(struct device *dev, u8 *ic_buf,
+		size_t length, int num_read, int offset, int mode)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc;
+
+	if (dad->ic_grpoffset >= num_read)
+		return -EINVAL;
+
+	num_read -= dad->ic_grpoffset;
+
+	if (length < num_read) {
+		dev_err(dev, "%s: not sufficient buffer req_bug_len=%d, length=%d\n",
+				__func__, num_read, length);
+		return -EINVAL;
+	}
+
+	pm_runtime_get_sync(dev);
+	rc = cyttsp4_read(dad->ttsp, mode, offset + dad->ic_grpoffset, ic_buf,
+			num_read);
+	pm_runtime_put(dev);
+	if (rc < 0)
+		return rc;
+
+	return num_read;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 1.
+ * Prints status register contents of Operational mode registers.
+ */
+static int cyttsp4_grpdata_show_operational_regs(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.rep_ofs - dad->si->si_ofs.cmd_ofs;
+	int i;
+
+	if (dad->ic_grpoffset >= num_read) {
+		dev_err(dev,
+			"%s: ic_grpoffset bigger than command registers, cmd_registers=%d\n",
+			__func__, num_read);
+		return -EINVAL;
+	}
+
+	num_read -= dad->ic_grpoffset;
+
+	if (length < num_read) {
+		dev_err(dev,
+			"%s: not sufficient buffer req_bug_len=%d, length=%d\n",
+			__func__, num_read, length);
+		return -EINVAL;
+	}
+
+	if (dad->ic_grpoffset + num_read > CY_MAX_PRBUF_SIZE) {
+		dev_err(dev,
+			"%s: not sufficient source buffer req_bug_len=%d, length=%d\n",
+			__func__, dad->ic_grpoffset + num_read,
+			CY_MAX_PRBUF_SIZE);
+		return -EINVAL;
+	}
+
+
+	/* cmd result already put into dad->return_buf */
+	for (i = 0; i < num_read; i++)
+		ic_buf[i] = dad->return_buf[dad->ic_grpoffset + i];
+
+	return num_read;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 2.
+ * Prints current contents of the touch registers (full set).
+ */
+static int cyttsp4_grpdata_show_touch_regs(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.rep_sz;
+	int offset = dad->si->si_ofs.rep_ofs;
+
+	return cyttsp4_grpdata_show_registers(dev, ic_buf, length, num_read,
+			offset, CY_MODE_OPERATIONAL);
+}
+
+/*
+ * Prints some content of the system information
+ */
+static int cyttsp4_grpdata_show_sysinfo(struct device *dev, u8 *ic_buf,
+		size_t length, int num_read, int offset)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc = 0, rc2 = 0, rc3 = 0;
+
+	if (dad->ic_grpoffset >= num_read)
+		return -EINVAL;
+
+	num_read -= dad->ic_grpoffset;
+
+	if (length < num_read) {
+		dev_err(dev, "%s: not sufficient buffer req_bug_len=%d, length=%d\n",
+				__func__, num_read, length);
+		return -EINVAL;
+	}
+
+	pm_runtime_get_sync(dev);
+
+	rc = cyttsp4_request_exclusive(dad->ttsp,
+			CY_DA_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_show_sysinfo_err_put;
+	}
+
+	rc = cyttsp4_request_set_mode(dad->ttsp, CY_MODE_SYSINFO);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_show_sysinfo_err_release;
+	}
+
+	rc = cyttsp4_read(dad->ttsp, CY_MODE_SYSINFO,
+			offset + dad->ic_grpoffset,
+			ic_buf, num_read);
+	if (rc < 0)
+		dev_err(dev, "%s: Fail read cmd regs r=%d\n",
+				__func__, rc);
+
+	rc2 = cyttsp4_request_set_mode(dad->ttsp, CY_MODE_OPERATIONAL);
+	if (rc2 < 0)
+		dev_err(dev, "%s: Error on request set mode 2 r=%d\n",
+				__func__, rc2);
+
+cyttsp4_grpdata_show_sysinfo_err_release:
+	rc3 = cyttsp4_release_exclusive(dad->ttsp);
+	if (rc3 < 0)
+		dev_err(dev, "%s: Error on release exclusive r=%d\n",
+				__func__, rc3);
+
+cyttsp4_grpdata_show_sysinfo_err_put:
+	pm_runtime_put(dev);
+
+	if (rc < 0)
+		return rc;
+	if (rc2 < 0)
+		return rc2;
+	if (rc3 < 0)
+		return rc3;
+
+	return num_read;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 3.
+ * Prints content of the system information DATA record.
+ */
+static int cyttsp4_grpdata_show_sysinfo_data_rec(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.cydata_size;
+	int offset = dad->si->si_ofs.cydata_ofs;
+
+	return cyttsp4_grpdata_show_sysinfo(dev, ic_buf, length, num_read,
+			offset);
+}
+
+/*
+ * SysFs grpdata show function implementation of group 4.
+ * Prints content of the system information TEST record.
+ */
+static int cyttsp4_grpdata_show_sysinfo_test_rec(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.test_size;
+	int offset = dad->si->si_ofs.test_ofs;
+
+	return cyttsp4_grpdata_show_sysinfo(dev, ic_buf, length, num_read,
+			offset);
+}
+
+/*
+ * SysFs grpdata show function implementation of group 5.
+ * Prints content of the system information PANEL data.
+ */
+static int cyttsp4_grpdata_show_sysinfo_panel(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.pcfg_size;
+	int offset = dad->si->si_ofs.pcfg_ofs;
+
+	return cyttsp4_grpdata_show_sysinfo(dev, ic_buf, length, num_read,
+			offset);
+}
+
+/*
+ * SysFs grpdata show function implementation of group 6.
+ * Prints contents of the touch parameters a row at a time.
+ */
+static int cyttsp4_grpdata_show_touch_params(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	u8 cmd_buf[CY_CMD_CAT_READ_CFG_BLK_CMD_SZ];
+	int return_buf_size = CY_CMD_CAT_READ_CFG_BLK_RET_SZ;
+	u16 config_row_size;
+	int row_offset;
+	int offset_in_single_row = 0;
+	int rc = 0;
+	int rc2 = 0;
+	int rc3 = 0;
+	int i, j;
+
+	pm_runtime_get_sync(dev);
+
+	rc = cyttsp4_request_exclusive(dad->ttsp,
+			CY_DA_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_show_touch_params_err_put;
+	}
+
+	rc = cyttsp4_request_set_mode(dad->ttsp, CY_MODE_CAT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_show_touch_params_err_release;
+	}
+
+	rc = cyttsp4_request_config_row_size(dad->ttsp, &config_row_size);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request config row size r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_show_touch_params_err_change_mode;
+	}
+
+	/* Perform buffer size check since we have just acquired row size */
+	return_buf_size += config_row_size;
+
+	if (length < return_buf_size) {
+		dev_err(dev, "%s: not sufficient buffer req_buf_len=%d, length=%d\n",
+				__func__, return_buf_size, length);
+		rc = -EINVAL;
+		goto cyttsp4_grpdata_show_touch_params_err_change_mode;
+	}
+
+	row_offset = dad->ic_grpoffset / config_row_size;
+
+	cmd_buf[0] = CY_CMD_CAT_READ_CFG_BLK;
+	cmd_buf[1] = HI_BYTE(row_offset);
+	cmd_buf[2] = LO_BYTE(row_offset);
+	cmd_buf[3] = HI_BYTE(config_row_size);
+	cmd_buf[4] = LO_BYTE(config_row_size);
+	cmd_buf[5] = CY_TCH_PARM_EBID;
+	rc = cyttsp4_request_exec_cmd(dad->ttsp, CY_MODE_CAT,
+			cmd_buf, CY_CMD_CAT_READ_CFG_BLK_CMD_SZ,
+			ic_buf, return_buf_size,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+
+	offset_in_single_row = dad->ic_grpoffset % config_row_size;
+
+	/* Remove Header data from return buffer */
+	for (i = 0, j = CY_CMD_CAT_READ_CFG_BLK_RET_HDR_SZ
+				+ offset_in_single_row;
+			i < (config_row_size - offset_in_single_row);
+			i++, j++)
+		ic_buf[i] = ic_buf[j];
+
+cyttsp4_grpdata_show_touch_params_err_change_mode:
+	rc2 = cyttsp4_request_set_mode(dad->ttsp, CY_MODE_OPERATIONAL);
+	if (rc2 < 0)
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc2);
+
+cyttsp4_grpdata_show_touch_params_err_release:
+	rc3 = cyttsp4_release_exclusive(dad->ttsp);
+	if (rc3 < 0)
+		dev_err(dev, "%s: Error on release exclusive r=%d\n",
+				__func__, rc3);
+
+cyttsp4_grpdata_show_touch_params_err_put:
+	pm_runtime_put(dev);
+
+	if (rc < 0)
+		return rc;
+	if (rc2 < 0)
+		return rc2;
+	if (rc3 < 0)
+		return rc3;
+
+	return config_row_size - offset_in_single_row;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 7.
+ * Prints contents of the touch parameters sizes.
+ */
+static int cyttsp4_grpdata_show_touch_params_sizes(struct device *dev,
+		u8 *ic_buf, size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	struct cyttsp4_core_platform_data *pdata =
+			dev_get_platdata(&dad->ttsp->core->dev);
+	int max_size;
+	int block_start;
+	int block_end;
+	int num_read;
+
+	if (pdata->sett[CY_IC_GRPNUM_TCH_PARM_SIZE] == NULL) {
+		dev_err(dev, "%s: Missing platform data Touch Parameters Sizes table\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	if (pdata->sett[CY_IC_GRPNUM_TCH_PARM_SIZE]->data == NULL) {
+		dev_err(dev, "%s: Missing platform data Touch Parameters Sizes table data\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	max_size = pdata->sett[CY_IC_GRPNUM_TCH_PARM_SIZE]->size;
+	max_size *= sizeof(uint16_t);
+	if (dad->ic_grpoffset >= max_size)
+		return -EINVAL;
+
+	block_start = (dad->ic_grpoffset / CYTTSP4_TCH_PARAM_SIZE_BLK_SZ)
+			* CYTTSP4_TCH_PARAM_SIZE_BLK_SZ;
+	block_end = CYTTSP4_TCH_PARAM_SIZE_BLK_SZ + block_start;
+	if (block_end > max_size)
+		block_end = max_size;
+	num_read = block_end - dad->ic_grpoffset;
+	if (length < num_read) {
+		dev_err(dev, "%s: not sufficient buffer %s=%d, %s=%d\n",
+				__func__, "req_buf_len", num_read, "length",
+				length);
+		return -EINVAL;
+	}
+
+	memcpy(ic_buf, (u8 *)pdata->sett[CY_IC_GRPNUM_TCH_PARM_SIZE]->data
+			+ dad->ic_grpoffset, num_read);
+
+	return num_read;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 10.
+ * Prints content of the system information Operational Configuration data.
+ */
+static int cyttsp4_grpdata_show_sysinfo_opcfg(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.opcfg_size;
+	int offset = dad->si->si_ofs.opcfg_ofs;
+
+	return cyttsp4_grpdata_show_sysinfo(dev, ic_buf, length, num_read,
+			offset);
+}
+
+/*
+ * SysFs grpdata show function implementation of group 11.
+ * Prints content of the system information Design data.
+ */
+static int cyttsp4_grpdata_show_sysinfo_design(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.ddata_size;
+	int offset = dad->si->si_ofs.ddata_ofs;
+
+	return cyttsp4_grpdata_show_sysinfo(dev, ic_buf, length, num_read,
+			offset);
+}
+
+/*
+ * SysFs grpdata show function implementation of group 12.
+ * Prints content of the system information Manufacturing data.
+ */
+static int cyttsp4_grpdata_show_sysinfo_manufacturing(struct device *dev,
+		u8 *ic_buf, size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.mdata_size;
+	int offset = dad->si->si_ofs.mdata_ofs;
+
+	return cyttsp4_grpdata_show_sysinfo(dev, ic_buf, length, num_read,
+			offset);
+}
+
+/*
+ * SysFs grpdata show function implementation of group 13.
+ * Prints status register contents of Configuration and
+ * Test registers.
+ */
+static int cyttsp4_grpdata_show_test_regs(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	u8 mode;
+	int rc = 0;
+	int num_read = 0;
+	int i;
+
+	dev_vdbg(dev, "%s: test.cur_cmd=%d test.cur_mode=%d\n",
+			__func__, dad->test.cur_cmd, dad->test.cur_mode);
+
+	if (dad->test.cur_cmd == CY_CMD_CAT_NULL) {
+		num_read = 1;
+		if (length < num_read) {
+			dev_err(dev, "%s: not sufficient buffer %s=%d, %s=%d\n",
+					__func__, "req_buf_len", num_read,
+					"length", length);
+			return -EINVAL;
+		}
+
+		dev_vdbg(dev, "%s: GRP=TEST_REGS: NULL CMD: host_mode=%02X\n",
+				__func__, ic_buf[0]);
+		pm_runtime_get_sync(dev);
+		rc = cyttsp4_read(dad->ttsp,
+				dad->test.cur_mode == CY_TEST_MODE_CAT ?
+					CY_MODE_CAT : CY_MODE_OPERATIONAL,
+				CY_REG_BASE, &mode, sizeof(mode));
+		pm_runtime_put(dev);
+		if (rc < 0) {
+			ic_buf[0] = 0xFF;
+			dev_err(dev, "%s: failed to read host mode r=%d\n",
+					__func__, rc);
+		} else {
+			ic_buf[0] = mode;
+		}
+	} else if (dad->test.cur_mode == CY_TEST_MODE_CAT) {
+		num_read = dad->test.cur_status_size;
+		if (length < num_read) {
+			dev_err(dev, "%s: not sufficient buffer %s=%d, %s=%d\n",
+					__func__, "req_buf_len", num_read,
+					"length", length);
+			return -EINVAL;
+		}
+		if (dad->ic_grpoffset + num_read > CY_MAX_PRBUF_SIZE) {
+			dev_err(dev,
+				"%s: not sufficient source buffer req_bug_len=%d, length=%d\n",
+				__func__, dad->ic_grpoffset + num_read,
+				CY_MAX_PRBUF_SIZE);
+			return -EINVAL;
+		}
+
+		dev_vdbg(dev, "%s: GRP=TEST_REGS: num_rd=%d at ofs=%d + grpofs=%d\n",
+				__func__, num_read, dad->si->si_ofs.cmd_ofs,
+				dad->ic_grpoffset);
+
+		/* cmd result already put into dad->return_buf */
+		for (i = 0; i < num_read; i++)
+			ic_buf[i] = dad->return_buf[dad->ic_grpoffset + i];
+	} else {
+		dev_err(dev, "%s: Not in Config/Test mode\n", __func__);
+	}
+
+	return num_read;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 14.
+ * Prints CapSense button keycodes.
+ */
+static int cyttsp4_grpdata_show_btn_keycodes(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	struct cyttsp4_btn *btn = dad->si->btn;
+	int num_btns = dad->si->si_ofs.num_btns - dad->ic_grpoffset;
+	int n;
+
+	if (num_btns <= 0 || btn == NULL || length < num_btns)
+		return -EINVAL;
+
+	for (n = 0; n < num_btns; n++)
+		ic_buf[n] = (u8) btn[dad->ic_grpoffset + n].key_code;
+
+	return n;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 15.
+ * Prints status register contents of Configuration and
+ * Test registers.
+ */
+static int cyttsp4_grpdata_show_tthe_test_regs(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc = 0;
+	int num_read = 0;
+
+	dev_vdbg(dev, "%s: test.cur_cmd=%d test.cur_mode=%d\n",
+			__func__, dad->test.cur_cmd, dad->test.cur_mode);
+
+	if (dad->test.cur_cmd == CY_CMD_CAT_NULL) {
+		num_read = dad->test.cur_status_size;
+		if (length < num_read) {
+			dev_err(dev, "%s: not sufficient buffer %s=%d, %s=%d\n",
+					__func__, "req_buf_len", num_read,
+					"length", length);
+			return -EINVAL;
+		}
+
+		dev_vdbg(dev, "%s: GRP=TEST_REGS: NULL CMD: host_mode=%02X\n",
+				__func__, ic_buf[0]);
+		rc = cyttsp4_read(dad->ttsp,
+				(dad->test.cur_mode == CY_TEST_MODE_CAT)
+					? CY_MODE_CAT :
+				(dad->test.cur_mode == CY_TEST_MODE_SYSINFO)
+					? CY_MODE_SYSINFO : CY_MODE_OPERATIONAL,
+				CY_REG_BASE, ic_buf, num_read);
+		if (rc < 0) {
+			ic_buf[0] = 0xFF;
+			dev_err(dev, "%s: failed to read host mode r=%d\n",
+					__func__, rc);
+		}
+	} else if (dad->test.cur_mode == CY_TEST_MODE_CAT
+			|| dad->test.cur_mode == CY_TEST_MODE_SYSINFO) {
+		num_read = dad->test.cur_status_size;
+		if (length < num_read) {
+			dev_err(dev, "%s: not sufficient buffer %s=%d, %s=%d\n",
+					__func__, "req_buf_len", num_read,
+					"length", length);
+			return -EINVAL;
+		}
+		dev_vdbg(dev, "%s: GRP=TEST_REGS: num_rd=%d at ofs=%d + grpofs=%d\n",
+				__func__, num_read, dad->si->si_ofs.cmd_ofs,
+				dad->ic_grpoffset);
+		rc = cyttsp4_read(dad->ttsp,
+				(dad->test.cur_mode == CY_TEST_MODE_CAT)
+					? CY_MODE_CAT : CY_MODE_SYSINFO,
+				CY_REG_BASE, ic_buf, num_read);
+		if (rc < 0)
+			return rc;
+	} else {
+		dev_err(dev, "%s: In unsupported mode\n", __func__);
+	}
+
+	return num_read;
+}
+
+static cyttsp4_show_function
+		cyttsp4_grpdata_show_functions[CY_IC_GRPNUM_NUM] = {
+	[CY_IC_GRPNUM_RESERVED] = cyttsp4_grpdata_show_void,
+	[CY_IC_GRPNUM_CMD_REGS] = cyttsp4_grpdata_show_operational_regs,
+	[CY_IC_GRPNUM_TCH_REP] = cyttsp4_grpdata_show_touch_regs,
+	[CY_IC_GRPNUM_DATA_REC] = cyttsp4_grpdata_show_sysinfo_data_rec,
+	[CY_IC_GRPNUM_TEST_REC] = cyttsp4_grpdata_show_sysinfo_test_rec,
+	[CY_IC_GRPNUM_PCFG_REC] = cyttsp4_grpdata_show_sysinfo_panel,
+	[CY_IC_GRPNUM_TCH_PARM_VAL] = cyttsp4_grpdata_show_touch_params,
+	[CY_IC_GRPNUM_TCH_PARM_SIZE] = cyttsp4_grpdata_show_touch_params_sizes,
+	[CY_IC_GRPNUM_RESERVED1] = cyttsp4_grpdata_show_void,
+	[CY_IC_GRPNUM_RESERVED2] = cyttsp4_grpdata_show_void,
+	[CY_IC_GRPNUM_OPCFG_REC] = cyttsp4_grpdata_show_sysinfo_opcfg,
+	[CY_IC_GRPNUM_DDATA_REC] = cyttsp4_grpdata_show_sysinfo_design,
+	[CY_IC_GRPNUM_MDATA_REC] = cyttsp4_grpdata_show_sysinfo_manufacturing,
+	[CY_IC_GRPNUM_TEST_REGS] = cyttsp4_grpdata_show_test_regs,
+	[CY_IC_GRPNUM_BTN_KEYS] = cyttsp4_grpdata_show_btn_keycodes,
+	[CY_IC_GRPNUM_TTHE_REGS] = cyttsp4_grpdata_show_tthe_test_regs,
+};
+
+static ssize_t cyttsp4_ic_grpdata_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int i;
+	ssize_t num_read;
+	int index;
+
+	mutex_lock(&dad->sysfs_lock);
+	dev_vdbg(dev, "%s: grpnum=%d grpoffset=%u\n",
+			__func__, dad->ic_grpnum, dad->ic_grpoffset);
+
+	index = scnprintf(buf, CY_MAX_PRBUF_SIZE,
+			"Group %d, Offset %u:\n", dad->ic_grpnum,
+			dad->ic_grpoffset);
+
+	num_read = cyttsp4_grpdata_show_functions[dad->ic_grpnum] (dev,
+			dad->ic_buf, CY_MAX_PRBUF_SIZE);
+	if (num_read < 0) {
+		index = num_read;
+		if (num_read == -ENOSYS) {
+			dev_err(dev, "%s: Group %d is not implemented.\n",
+				__func__, dad->ic_grpnum);
+			goto cyttsp4_ic_grpdata_show_error;
+		}
+		dev_err(dev, "%s: Cannot read Group %d Data.\n",
+				__func__, dad->ic_grpnum);
+		goto cyttsp4_ic_grpdata_show_error;
+	}
+
+	for (i = 0; i < num_read; i++) {
+		index += scnprintf(buf + index, CY_MAX_PRBUF_SIZE - index,
+				"0x%02X\n", dad->ic_buf[i]);
+	}
+
+	index += scnprintf(buf + index, CY_MAX_PRBUF_SIZE - index,
+			"(%d bytes)\n", num_read);
+
+cyttsp4_ic_grpdata_show_error:
+	mutex_unlock(&dad->sysfs_lock);
+	return index;
+}
+
+static int _cyttsp4_cmd_handshake(struct cyttsp4_device_access_data *dad)
+{
+	struct device *dev = &dad->ttsp->dev;
+	u8 mode;
+	int rc;
+
+	rc = cyttsp4_read(dad->ttsp, CY_MODE_CAT,
+			CY_REG_BASE, &mode, sizeof(mode));
+	if (rc < 0) {
+		dev_err(dev, "%s: Fail read host mode r=%d\n", __func__, rc);
+		return rc;
+	}
+
+	rc = cyttsp4_request_handshake(dad->ttsp, mode);
+	if (rc < 0)
+		dev_err(dev, "%s: Fail cmd handshake r=%d\n", __func__, rc);
+
+	return rc;
+}
+
+static int _cyttsp4_cmd_toggle_lowpower(struct cyttsp4_device_access_data *dad)
+{
+	struct device *dev = &dad->ttsp->dev;
+	u8 mode;
+	int rc = cyttsp4_read(dad->ttsp,
+			(dad->test.cur_mode == CY_TEST_MODE_CAT)
+				? CY_MODE_CAT : CY_MODE_OPERATIONAL,
+			CY_REG_BASE, &mode, sizeof(mode));
+	if (rc < 0) {
+		dev_err(dev, "%s: Fail read host mode r=%d\n",
+				__func__, rc);
+		return rc;
+	}
+
+	rc = cyttsp4_request_toggle_lowpower(dad->ttsp, mode);
+	if (rc < 0)
+		dev_err(dev, "%s: Fail cmd handshake r=%d\n",
+				__func__, rc);
+	return rc;
+}
+
+static int cyttsp4_test_cmd_mode(struct cyttsp4_device_access_data *dad,
+		u8 *ic_buf, size_t length)
+{
+	struct device *dev = &dad->ttsp->dev;
+	int rc = -ENOSYS;
+	u8 mode;
+
+	if (length < CY_NULL_CMD_MODE_INDEX + 1)  {
+		dev_err(dev, "%s: %s length=%d\n", __func__,
+				"Buffer length is not valid", length);
+		return -EINVAL;
+	}
+	mode = ic_buf[CY_NULL_CMD_MODE_INDEX];
+
+	if (mode == CY_HST_CAT) {
+		pm_runtime_get_sync(dev);
+		rc = cyttsp4_request_exclusive(dad->ttsp,
+				CY_DA_REQUEST_EXCLUSIVE_TIMEOUT);
+		if (rc < 0) {
+			dev_err(dev, "%s: Fail rqst exclusive r=%d\n",
+					__func__, rc);
+			pm_runtime_put(dev);
+			goto cyttsp4_test_cmd_mode_exit;
+		}
+		rc = cyttsp4_request_set_mode(dad->ttsp, CY_MODE_CAT);
+		if (rc < 0) {
+			dev_err(dev, "%s: Fail rqst set mode=%02X r=%d\n",
+					__func__, mode, rc);
+			rc = cyttsp4_release_exclusive(dad->ttsp);
+			if (rc < 0)
+				dev_err(dev, "%s: %s r=%d\n", __func__,
+						"Fail release exclusive", rc);
+			pm_runtime_put(dev);
+			goto cyttsp4_test_cmd_mode_exit;
+		}
+		dad->test.cur_mode = CY_TEST_MODE_CAT;
+		dad->own_exclusive = true;
+		dev_vdbg(dev, "%s: %s=%d %s=%02X %s=%d(CaT)\n", __func__,
+				"own_exclusive", dad->own_exclusive == true,
+				"mode", mode, "test.cur_mode",
+				dad->test.cur_mode);
+	} else if (mode == CY_HST_OPERATE) {
+		if (dad->own_exclusive) {
+			rc = cyttsp4_request_set_mode(dad->ttsp,
+					CY_MODE_OPERATIONAL);
+			if (rc < 0)
+				dev_err(dev, "%s: %s=%02X r=%d\n", __func__,
+						"Fail rqst set mode", mode, rc);
+				/* continue anyway */
+
+			rc = cyttsp4_release_exclusive(dad->ttsp);
+			if (rc < 0) {
+				dev_err(dev, "%s: %s r=%d\n", __func__,
+						"Fail release exclusive", rc);
+				/* continue anyway */
+				rc = 0;
+			}
+			dad->test.cur_mode = CY_TEST_MODE_NORMAL_OP;
+			dad->own_exclusive = false;
+			pm_runtime_put(dev);
+			dev_vdbg(dev, "%s: %s=%d %s=%02X %s=%d(Operate)\n",
+					__func__, "own_exclusive",
+					dad->own_exclusive == true,
+					"mode", mode,
+					"test.cur_mode", dad->test.cur_mode);
+		} else
+			dev_vdbg(dev, "%s: %s mode=%02X(Operate)\n", __func__,
+					"do not own exclusive; cannot switch",
+					mode);
+	} else
+		dev_vdbg(dev, "%s: unsupported mode switch=%02X\n",
+				__func__, mode);
+
+cyttsp4_test_cmd_mode_exit:
+	return rc;
+}
+
+static int cyttsp4_test_tthe_cmd_mode(struct cyttsp4_device_access_data *dad,
+		u8 *ic_buf, size_t length)
+{
+	struct device *dev = &dad->ttsp->dev;
+	int rc = -ENOSYS;
+	u8 mode;
+	enum cyttsp4_test_mode test_mode;
+	int new_mode;
+
+	if (length < CY_NULL_CMD_MODE_INDEX + 1)  {
+		dev_err(dev, "%s: %s length=%d\n", __func__,
+				"Buffer length is not valid", length);
+		return -EINVAL;
+	}
+	mode = ic_buf[CY_NULL_CMD_MODE_INDEX];
+
+	switch (mode) {
+	case CY_HST_CAT:
+		new_mode = CY_MODE_CAT;
+		test_mode = CY_TEST_MODE_CAT;
+		break;
+	case CY_HST_OPERATE:
+		new_mode = CY_MODE_OPERATIONAL;
+		test_mode = CY_TEST_MODE_NORMAL_OP;
+		break;
+	case CY_HST_SYSINFO:
+		new_mode = CY_MODE_SYSINFO;
+		test_mode = CY_TEST_MODE_SYSINFO;
+		break;
+	default:
+		dev_vdbg(dev, "%s: unsupported mode switch=%02X\n",
+				__func__, mode);
+		goto cyttsp4_test_tthe_cmd_mode_exit;
+	}
+
+	rc = cyttsp4_request_exclusive(dad->ttsp,
+			CY_DA_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Fail rqst exclusive r=%d\n", __func__, rc);
+		goto cyttsp4_test_tthe_cmd_mode_exit;
+	}
+	rc = cyttsp4_request_set_mode(dad->ttsp, new_mode);
+	if (rc < 0)
+		dev_err(dev, "%s: Fail rqst set mode=%02X r=%d\n",
+				__func__, mode, rc);
+	rc = cyttsp4_release_exclusive(dad->ttsp);
+	if (rc < 0) {
+		dev_err(dev, "%s: %s r=%d\n", __func__,
+				"Fail release exclusive", rc);
+		if (mode == CY_HST_OPERATE)
+			rc = 0;
+		else
+			goto cyttsp4_test_tthe_cmd_mode_exit;
+	}
+	dad->test.cur_mode = test_mode;
+	dev_vdbg(dev, "%s: %s=%d %s=%02X %s=%d\n", __func__,
+			"own_exclusive", dad->own_exclusive == true,
+			"mode", mode,
+			"test.cur_mode", dad->test.cur_mode);
+
+cyttsp4_test_tthe_cmd_mode_exit:
+	return rc;
+}
+
+/*
+ * SysFs grpdata store function implementation of group 1.
+ * Stores to command and parameter registers of Operational mode.
+ */
+static int cyttsp4_grpdata_store_operational_regs(struct device *dev,
+		u8 *ic_buf, size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	size_t cmd_ofs = dad->si->si_ofs.cmd_ofs;
+	int num_read = dad->si->si_ofs.rep_ofs - dad->si->si_ofs.cmd_ofs;
+	u8 *return_buf = dad->return_buf;
+	int rc, rc2 = 0;
+
+	if ((cmd_ofs + length) > dad->si->si_ofs.rep_ofs) {
+		dev_err(dev, "%s: %s length=%d\n", __func__,
+				"Buffer length is not valid", length);
+		return -EINVAL;
+	}
+
+	pm_runtime_get_sync(dev);
+
+	rc = cyttsp4_request_exclusive(dad->ttsp,
+			CY_DA_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_store_operational_regs_err_put;
+	}
+
+	return_buf[0] = ic_buf[0];
+	rc = cyttsp4_request_exec_cmd(dad->ttsp, CY_MODE_OPERATIONAL,
+			ic_buf, length,
+			return_buf + 1, num_read,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc < 0)
+		dev_err(dev, "%s: Fail to execute cmd r=%d\n", __func__, rc);
+
+	rc2 = cyttsp4_release_exclusive(dad->ttsp);
+	if (rc2 < 0)
+		dev_err(dev, "%s: Error on release exclusive r=%d\n",
+				__func__, rc2);
+
+cyttsp4_grpdata_store_operational_regs_err_put:
+	pm_runtime_put(dev);
+
+	if (rc < 0)
+		return rc;
+	if (rc2 < 0)
+		return rc2;
+
+	return rc;
+}
+
+/*
+ * SysFs store function of Test Regs group.
+ */
+static int cyttsp4_grpdata_store_test_regs(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc;
+	u8 *return_buf = dad->return_buf;
+
+	/* Caller function guaranties, length is not bigger than ic_buf size */
+	if (length < CY_CMD_INDEX + 1) {
+		dev_err(dev, "%s: %s length=%d\n", __func__,
+				"Buffer length is not valid", length);
+		return -EINVAL;
+	}
+
+	dad->test.cur_cmd = ic_buf[CY_CMD_INDEX];
+	if (dad->test.cur_cmd == CY_CMD_CAT_NULL) {
+		if (length < CY_NULL_CMD_INDEX + 1) {
+			dev_err(dev, "%s: %s length=%d\n", __func__,
+					"Buffer length is not valid", length);
+			return -EINVAL;
+		}
+		dev_vdbg(dev, "%s: test-cur_cmd=%d null-cmd=%d\n", __func__,
+				dad->test.cur_cmd, ic_buf[CY_NULL_CMD_INDEX]);
+		switch (ic_buf[CY_NULL_CMD_INDEX]) {
+		case CY_NULL_CMD_NULL:
+			dev_err(dev, "%s: empty NULL cmd\n", __func__);
+			break;
+		case CY_NULL_CMD_MODE:
+			if (length < CY_NULL_CMD_MODE_INDEX + 1) {
+				dev_err(dev, "%s: %s length=%d\n", __func__,
+						"Buffer length is not valid",
+						length);
+				return -EINVAL;
+			}
+			dev_vdbg(dev, "%s: Set cmd mode=%02X\n", __func__,
+					ic_buf[CY_NULL_CMD_MODE_INDEX]);
+			cyttsp4_test_cmd_mode(dad, ic_buf, length);
+			break;
+		case CY_NULL_CMD_STATUS_SIZE:
+			if (length < CY_NULL_CMD_SIZE_INDEX + 1) {
+				dev_err(dev, "%s: %s length=%d\n", __func__,
+						"Buffer length is not valid",
+						length);
+				return -EINVAL;
+			}
+			dad->test.cur_status_size =
+				ic_buf[CY_NULL_CMD_SIZEL_INDEX]
+				+ (ic_buf[CY_NULL_CMD_SIZEH_INDEX] << 8);
+			dev_vdbg(dev, "%s: test-cur_status_size=%d\n",
+					__func__, dad->test.cur_status_size);
+			break;
+		case CY_NULL_CMD_HANDSHAKE:
+			dev_vdbg(dev, "%s: try null cmd handshake\n",
+					__func__);
+			rc = _cyttsp4_cmd_handshake(dad);
+			if (rc < 0)
+				dev_err(dev, "%s: %s r=%d\n", __func__,
+						"Fail test cmd handshake", rc);
+		default:
+			break;
+		}
+	} else {
+		dev_dbg(dev, "%s: TEST CMD=0x%02X length=%d %s%d\n",
+				__func__, ic_buf[0], length, "cmd_ofs+grpofs=",
+				dad->ic_grpoffset + dad->si->si_ofs.cmd_ofs);
+		cyttsp4_pr_buf(dev, dad->pr_buf, ic_buf, length, "test_cmd");
+		return_buf[0] = ic_buf[0]; /* Save cmd byte to return_buf */
+		rc = cyttsp4_request_exec_cmd(dad->ttsp, CY_MODE_CAT,
+				ic_buf, length,
+				return_buf + 1, dad->test.cur_status_size,
+				max(CY_COMMAND_COMPLETE_TIMEOUT,
+					CY_CALIBRATE_COMPLETE_TIMEOUT));
+		if (rc < 0)
+			dev_err(dev, "%s: Fail to execute cmd r=%d\n",
+					__func__, rc);
+	}
+	return 0;
+}
+
+/*
+ * SysFs store function of Test Regs group.
+ */
+static int cyttsp4_grpdata_store_tthe_test_regs(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc;
+
+	/* Caller function guaranties, length is not bigger than ic_buf size */
+	if (length < CY_CMD_INDEX + 1) {
+		dev_err(dev, "%s: %s length=%d\n", __func__,
+				"Buffer length is not valid", length);
+		return -EINVAL;
+	}
+
+	dad->test.cur_cmd = ic_buf[CY_CMD_INDEX];
+	if (dad->test.cur_cmd == CY_CMD_CAT_NULL) {
+		if (length < CY_NULL_CMD_INDEX + 1) {
+			dev_err(dev, "%s: %s length=%d\n", __func__,
+					"Buffer length is not valid", length);
+			return -EINVAL;
+		}
+		dev_vdbg(dev, "%s: test-cur_cmd=%d null-cmd=%d\n", __func__,
+				dad->test.cur_cmd, ic_buf[CY_NULL_CMD_INDEX]);
+		switch (ic_buf[CY_NULL_CMD_INDEX]) {
+		case CY_NULL_CMD_NULL:
+			dev_err(dev, "%s: empty NULL cmd\n", __func__);
+			break;
+		case CY_NULL_CMD_MODE:
+			if (length < CY_NULL_CMD_MODE_INDEX + 1) {
+				dev_err(dev, "%s: %s length=%d\n", __func__,
+						"Buffer length is not valid",
+						length);
+				return -EINVAL;
+			}
+			dev_vdbg(dev, "%s: Set cmd mode=%02X\n", __func__,
+					ic_buf[CY_NULL_CMD_MODE_INDEX]);
+			cyttsp4_test_tthe_cmd_mode(dad, ic_buf, length);
+			break;
+		case CY_NULL_CMD_STATUS_SIZE:
+			if (length < CY_NULL_CMD_SIZE_INDEX + 1) {
+				dev_err(dev, "%s: %s length=%d\n", __func__,
+						"Buffer length is not valid",
+						length);
+				return -EINVAL;
+			}
+			dad->test.cur_status_size =
+				ic_buf[CY_NULL_CMD_SIZEL_INDEX]
+				+ (ic_buf[CY_NULL_CMD_SIZEH_INDEX] << 8);
+			dev_vdbg(dev, "%s: test-cur_status_size=%d\n",
+					__func__, dad->test.cur_status_size);
+			break;
+		case CY_NULL_CMD_HANDSHAKE:
+			dev_vdbg(dev, "%s: try null cmd handshake\n",
+					__func__);
+			rc = _cyttsp4_cmd_handshake(dad);
+			if (rc < 0)
+				dev_err(dev, "%s: %s r=%d\n", __func__,
+						"Fail test cmd handshake", rc);
+		case CY_NULL_CMD_LOW_POWER:
+			dev_vdbg(dev, "%s: try null cmd low power\n", __func__);
+			rc = _cyttsp4_cmd_toggle_lowpower(dad);
+			if (rc < 0)
+				dev_err(dev, "%s: %s r=%d\n", __func__,
+					"Fail test cmd toggle low power", rc);
+		default:
+			break;
+		}
+	} else {
+		dev_dbg(dev, "%s: TEST CMD=0x%02X length=%d %s%d\n",
+				__func__, ic_buf[0], length, "cmd_ofs+grpofs=",
+				dad->ic_grpoffset + dad->si->si_ofs.cmd_ofs);
+		cyttsp4_pr_buf(dev, dad->pr_buf, ic_buf, length, "test_cmd");
+		/* Support Operating mode command. */
+		/* Write command parameters first */
+		if (length > 1) {
+			rc = cyttsp4_write(dad->ttsp,
+				(dad->test.cur_mode == CY_TEST_MODE_CAT)
+					?  CY_MODE_CAT : CY_MODE_OPERATIONAL,
+				dad->ic_grpoffset + dad->si->si_ofs.cmd_ofs
+					+ 1, ic_buf + 1, length - 1);
+			if (rc < 0) {
+				dev_err(dev, "%s: Fail write cmd param regs r=%d\n",
+					__func__, rc);
+				return 0;
+			}
+		}
+		/* Write command */
+		rc = cyttsp4_write(dad->ttsp,
+				(dad->test.cur_mode == CY_TEST_MODE_CAT)
+					?  CY_MODE_CAT : CY_MODE_OPERATIONAL,
+				dad->ic_grpoffset + dad->si->si_ofs.cmd_ofs,
+				ic_buf, 1);
+		if (rc < 0)
+			dev_err(dev, "%s: Fail write cmd reg r=%d\n",
+					__func__, rc);
+	}
+	return 0;
+}
+
+/*
+ * SysFs grpdata store function implementation of group 6.
+ * Stores the contents of the touch parameters.
+ */
+static int cyttsp4_grpdata_store_touch_params(struct device *dev,
+		u8 *ic_buf, size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc = 0, rc2 = 0, rc3 = 0;
+
+	pm_runtime_get_sync(dev);
+
+	rc = cyttsp4_request_exclusive(dad->ttsp,
+			CY_DA_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_store_touch_params_err_put;
+	}
+
+	rc = cyttsp4_request_set_mode(dad->ttsp, CY_MODE_CAT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_store_touch_params_err_release;
+	}
+
+	rc = cyttsp4_request_write_config(dad->ttsp, CY_TCH_PARM_EBID,
+			dad->ic_grpoffset, ic_buf, length);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request write config r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_store_touch_params_err_change_mode;
+	}
+
+cyttsp4_grpdata_store_touch_params_err_change_mode:
+	rc2 = cyttsp4_request_set_mode(dad->ttsp, CY_MODE_OPERATIONAL);
+	if (rc2 < 0)
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc2);
+
+cyttsp4_grpdata_store_touch_params_err_release:
+	rc3 = cyttsp4_release_exclusive(dad->ttsp);
+	if (rc3 < 0)
+		dev_err(dev, "%s: Error on release exclusive r=%d\n",
+				__func__, rc3);
+
+cyttsp4_grpdata_store_touch_params_err_put:
+	pm_runtime_put(dev);
+
+	if (rc == 0)
+		cyttsp4_request_restart(dad->ttsp, true);
+	else
+		return rc;
+	if (rc2 < 0)
+		return rc2;
+	if (rc3 < 0)
+		return rc3;
+
+	return rc;
+}
+
+/*
+ * Gets user input from sysfs and parse it
+ * return size of parsed output buffer
+ */
+static int cyttsp4_ic_parse_input(struct device *dev, const char *buf,
+		size_t buf_size, u8 *ic_buf, size_t ic_buf_size)
+{
+	const char *pbuf = buf;
+	unsigned long value;
+	char scan_buf[CYTTSP4_INPUT_ELEM_SZ];
+	int i = 0;
+	int j;
+	int last = 0;
+	int ret;
+
+	dev_dbg(dev, "%s: pbuf=%p buf=%p size=%d %s=%d buf=%s\n", __func__,
+			pbuf, buf, (int) buf_size, "scan buf size",
+			CYTTSP4_INPUT_ELEM_SZ, buf);
+
+	while (pbuf <= (buf + buf_size)) {
+		if (i >= CY_MAX_CONFIG_BYTES) {
+			dev_err(dev, "%s: %s size=%d max=%d\n", __func__,
+					"Max cmd size exceeded", i,
+					CY_MAX_CONFIG_BYTES);
+			return -EINVAL;
+		}
+		if (i >= ic_buf_size) {
+			dev_err(dev, "%s: %s size=%d buf_size=%d\n", __func__,
+					"Buffer size exceeded", i, ic_buf_size);
+			return -EINVAL;
+		}
+		while (((*pbuf == ' ') || (*pbuf == ','))
+				&& (pbuf < (buf + buf_size))) {
+			last = *pbuf;
+			pbuf++;
+		}
+
+		if (pbuf >= (buf + buf_size))
+			break;
+
+		memset(scan_buf, 0, CYTTSP4_INPUT_ELEM_SZ);
+		if ((last == ',') && (*pbuf == ',')) {
+			dev_err(dev, "%s: %s \",,\" not allowed.\n", __func__,
+					"Invalid data format.");
+			return -EINVAL;
+		}
+		for (j = 0; j < (CYTTSP4_INPUT_ELEM_SZ - 1)
+				&& (pbuf < (buf + buf_size))
+				&& (*pbuf != ' ')
+				&& (*pbuf != ','); j++) {
+			last = *pbuf;
+			scan_buf[j] = *pbuf++;
+		}
+
+		ret = kstrtoul(scan_buf, 16, &value);
+		if (ret < 0) {
+			dev_err(dev, "%s: %s '%s' %s%s i=%d r=%d\n", __func__,
+					"Invalid data format. ", scan_buf,
+					"Use \"0xHH,...,0xHH\"", " instead.",
+					i, ret);
+			return ret;
+		}
+
+		ic_buf[i] = value;
+		i++;
+	}
+
+	return i;
+}
+
+/*
+ * SysFs store functions of each group member.
+ */
+static cyttsp4_store_function
+		cyttsp4_grpdata_store_functions[CY_IC_GRPNUM_NUM] = {
+	[CY_IC_GRPNUM_RESERVED] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_CMD_REGS] = cyttsp4_grpdata_store_operational_regs,
+	[CY_IC_GRPNUM_TCH_REP] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_DATA_REC] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_TEST_REC] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_PCFG_REC] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_TCH_PARM_VAL] = cyttsp4_grpdata_store_touch_params,
+	[CY_IC_GRPNUM_TCH_PARM_SIZE] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_RESERVED1] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_RESERVED2] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_OPCFG_REC] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_DDATA_REC] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_MDATA_REC] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_TEST_REGS] = cyttsp4_grpdata_store_test_regs,
+	[CY_IC_GRPNUM_BTN_KEYS] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_TTHE_REGS] = cyttsp4_grpdata_store_tthe_test_regs,
+};
+
+static ssize_t cyttsp4_ic_grpdata_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	ssize_t length;
+	int rc;
+
+	mutex_lock(&dad->sysfs_lock);
+	length = cyttsp4_ic_parse_input(dev, buf, size, dad->ic_buf,
+			CY_MAX_PRBUF_SIZE);
+	if (length <= 0) {
+		dev_err(dev, "%s: %s Group Data store\n", __func__,
+				"Malformed input for");
+		goto cyttsp4_ic_grpdata_store_exit;
+	}
+
+	dev_vdbg(dev, "%s: grpnum=%d grpoffset=%u\n",
+			__func__, dad->ic_grpnum, dad->ic_grpoffset);
+
+	if (dad->ic_grpnum >= CY_IC_GRPNUM_NUM) {
+		dev_err(dev, "%s: Group %d does not exist.\n",
+				__func__, dad->ic_grpnum);
+		goto cyttsp4_ic_grpdata_store_exit;
+	}
+
+	/* write ic_buf to log */
+	cyttsp4_pr_buf(dev, dad->pr_buf, dad->ic_buf, length, "ic_buf");
+
+	/* Call relevant store handler. */
+	rc = cyttsp4_grpdata_store_functions[dad->ic_grpnum] (dev, dad->ic_buf,
+			length);
+	if (rc < 0)
+		dev_err(dev, "%s: Failed to store for grpmun=%d.\n",
+				__func__, dad->ic_grpnum);
+
+cyttsp4_ic_grpdata_store_exit:
+	mutex_unlock(&dad->sysfs_lock);
+	dev_vdbg(dev, "%s: return size=%d\n", __func__, size);
+	return size;
+}
+
+static DEVICE_ATTR(ic_grpdata, S_IRUSR | S_IWUSR,
+	cyttsp4_ic_grpdata_show, cyttsp4_ic_grpdata_store);
+
+/*** ZTEMT Added by luochangyang, 2013/10/28 ***/
+static ssize_t cyttsp4_ic_grpdetect_judge(struct device *dev, int address,
+        int length)
+{
+    struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+    int i = 0;
+
+	for (i = 0; i < address + length; i++) {
+        dev_vdbg(dev, "%s: dad->ic_buf[%d] = 0x%x\n",
+			__func__, i, dad->ic_buf[i]);
+	}
+
+    for (i = 0; i < length; i++) {
+        if (dad->ic_buf[address + i] == 0) {
+            dev_err(dev, "%s: dad->ic_buf[%d] = 0x%x length = %d\n", 
+                __func__, i, dad->ic_buf[address + i], length);
+
+            return 1;
+        }
+	}
+
+    return 0;
+}
+
+static ssize_t cyttsp4_ic_grpdetect_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+    int index;
+    int retval = 0;
+
+    dev_vdbg(dev, "%s: grpnum=%d grpoffset=%u\n",
+			__func__, dad->ic_grpnum, dad->ic_grpoffset);
+    
+    /*1. Read status and verify proper mode switch*/
+    cyttsp4_ic_grpnum_store(dev, attr, "13", 3);
+    cyttsp4_ic_grpoffset_store(dev, attr, "0", 2);
+    cyttsp4_ic_grpdata_store(dev, attr, "0x00,0x02,0x01,0x00", 20);
+    cyttsp4_ic_grpdata_store(dev, attr, "0x00,0x01,0x20", 15);
+    index = cyttsp4_ic_grpdata_show(dev, attr, buf);
+    dev_vdbg(dev, "%s: %s index=%d\n", __func__, buf, index);
+
+    /*2. Read status and verify command complete; verify shorts test is successful*/
+    index = 0;
+    cyttsp4_ic_grpdata_store(dev, attr, "0x00,0x02,0x07,0x00", 20);
+    cyttsp4_ic_grpdata_store(dev, attr, "0x10,0x00,0x00,0x00,0x01,0x00", 30);
+    index = cyttsp4_ic_grpdata_show(dev, attr, buf);
+    dev_vdbg(dev, "%s: %s index=%d\n", __func__, buf, index);
+
+    retval = cyttsp4_ic_grpdetect_judge(dev, 6, 1);
+    if (retval == 1) {
+        dev_err(dev, "%s: Grpdata is open.\n", __func__);
+        goto exit;
+    }
+    
+    /*3. Send Null command to set status size to 0x95*/
+    index = 0;
+    cyttsp4_ic_grpdata_store(dev, attr, "0x00,0x02,0x95,0x00", 20);
+    cyttsp4_ic_grpdata_store(dev, attr, "0x10,0x00,0x01,0x00,0x8F,0x00", 30);
+    index = cyttsp4_ic_grpdata_show(dev, attr, buf);
+    dev_vdbg(dev, "%s: %s index=%d\n", __func__, buf, index);
+
+    retval = cyttsp4_ic_grpdetect_judge(dev, 6, 143);
+    if (retval == 1) {
+        dev_err(dev, "%s: Grpdata is open.\n", __func__);
+        goto exit;
+    }
+
+    /*4. Send Null command to set status size to 6*/
+    index = 0;
+    cyttsp4_ic_grpdata_store(dev, attr, "0x00,0x02,0x76,0x00", 20);
+    cyttsp4_ic_grpdata_store(dev, attr, "0x10,0x00,0x90,0x00,0x8F,0x00", 30);
+    index = cyttsp4_ic_grpdata_show(dev, attr, buf);
+    dev_vdbg(dev, "%s: %s index=%d\n", __func__, buf, index);
+
+    retval = cyttsp4_ic_grpdetect_judge(dev, 6, 113);
+    if (retval == 1) {
+        dev_err(dev, "%s: Grpdata is open.\n", __func__);
+        goto exit;
+    }
+
+    /*5. Send Null command to set status size to 6*/
+    index = 0;
+    cyttsp4_ic_grpdata_store(dev, attr, "0x00,0x02,0x2B,0x00", 20);
+    cyttsp4_ic_grpdata_store(dev, attr, "0x10,0x00,0x00,0x00,0x25,0x01", 30);
+    index = cyttsp4_ic_grpdata_show(dev, attr, buf);
+    dev_vdbg(dev, "%s: %s index=%d\n", __func__, buf, index);
+
+    retval = cyttsp4_ic_grpdetect_judge(dev, 6, 37);
+    if (retval == 1) {
+        dev_err(dev, "%s: Grpdata is open.\n", __func__);
+        goto exit;
+    }
+	
+	dev_info(dev, "%s: Sensor detect success.\n", __func__);
+exit:
+
+    /*6. Send Null command to do command handshake*/
+    index = 0;
+    cyttsp4_ic_grpdata_store(dev, attr, "0x00,0x03", 10);
+    cyttsp4_ic_grpdata_store(dev, attr, "0x00,0x02,0x01,0x00", 20);
+    /*Send Null command to set mode to operational mode*/
+    cyttsp4_ic_grpdata_store(dev, attr, "0x00,0x01,0x00", 15);
+    /*Read status and confirm operational mode*/
+    index = cyttsp4_ic_grpdata_show(dev, attr, buf);
+    dev_vdbg(dev, "%s: %s index=%d\n", __func__, buf, index);
+
+    return snprintf(buf, PAGE_SIZE, "%d\n", retval);
+}
+
+static DEVICE_ATTR(ic_grpdetect, S_IRUGO,	cyttsp4_ic_grpdetect_show, NULL);
+/***ZTEMT END***/
+
+/*
+ * Execute scan command
+ */
+static int _cyttsp4_exec_scan_cmd(struct device *dev)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	u8 cmd_buf[CY_CMD_CAT_EXECUTE_PANEL_SCAN_CMD_SZ];
+	u8 return_buf[CY_CMD_CAT_EXECUTE_PANEL_SCAN_RET_SZ];
+
+	cmd_buf[0] = CY_CMD_CAT_EXEC_PANEL_SCAN;
+
+	return cyttsp4_request_exec_cmd(dad->ttsp, CY_MODE_CAT,
+			cmd_buf, CY_CMD_CAT_EXECUTE_PANEL_SCAN_CMD_SZ,
+			return_buf, CY_CMD_CAT_EXECUTE_PANEL_SCAN_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+}
+
+/*
+ * Retrieve panel data command
+ */
+static int _cyttsp4_ret_scan_data_cmd(struct device *dev, int read_offset,
+		int num_element, u8 data_type, u8 *return_buf)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	u8 cmd_buf[CY_CMD_CAT_RETRIEVE_PANEL_SCAN_CMD_SZ];
+
+	cmd_buf[0] = CY_CMD_CAT_RETRIEVE_PANEL_SCAN;
+	cmd_buf[1] = HI_BYTE(read_offset);
+	cmd_buf[2] = LO_BYTE(read_offset);
+	cmd_buf[3] = HI_BYTE(num_element);
+	cmd_buf[4] = LO_BYTE(num_element);
+	cmd_buf[5] = data_type;
+
+	return cyttsp4_request_exec_cmd(dad->ttsp, CY_MODE_CAT,
+			cmd_buf, CY_CMD_CAT_RETRIEVE_PANEL_SCAN_CMD_SZ,
+			return_buf, CY_CMD_CAT_RETRIEVE_PANEL_SCAN_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+}
+
+/*
+ * SysFs grpdata show function implementation of group 6.
+ * Prints contents of the touch parameters a row at a time.
+ */
+static ssize_t cyttsp4_get_panel_data_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	u8 return_buf[CY_CMD_CAT_RETRIEVE_PANEL_SCAN_RET_SZ];
+
+	int rc = 0;
+	int rc1 = 0;
+	int data_idx = 0;
+	int i = 0;
+	int print_idx = -1;
+	u8 cmd_param_ofs = dad->si->si_ofs.cmd_ofs + 1;
+	int read_byte = CY_CMD_CAT_RETRIEVE_PANEL_SCAN_RET_SZ + cmd_param_ofs;
+	int left_over_element = dad->heatmap.num_element;
+	int read_element_offset = CY_CMD_IN_DATA_OFFSET_VALUE;
+	int returned_element;
+	u8 element_start_offset = cmd_param_ofs
+		+ CY_CMD_CAT_RETRIEVE_PANEL_SCAN_RET_SZ;
+
+
+	rc = cyttsp4_request_exclusive(dad->ttsp,
+			CY_DA_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto cyttsp4_get_panel_data_show_err_release;
+	}
+
+	if (dad->heatmap.scan_start)	{
+		/* Start scan */
+		rc = _cyttsp4_exec_scan_cmd(dev);
+		if (rc < 0) {
+			dev_err(dev, "%s: Error on _cyttsp4_exec_scan_cmd()\n",
+				__func__);
+			goto cyttsp4_get_panel_data_show_err_release;
+		}
+	}
+
+	/* retrieve scan data */
+	rc = _cyttsp4_ret_scan_data_cmd(dev, read_element_offset,
+			left_over_element, dad->heatmap.data_type, return_buf);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on _cyttsp4_ret_scan_data_cmd(), offset=%d num_element:%d\n",
+			__func__, read_element_offset, left_over_element);
+		goto cyttsp4_get_panel_data_show_err_release;
+	}
+	if (return_buf[CY_CMD_OUT_STATUS_OFFSET] != CY_CMD_STATUS_SUCCESS) {
+		dev_err(dev, "%s: Fail on _cyttsp4_ret_scan_data_cmd(), offset=%d num_element:%d\n",
+			__func__, read_element_offset, left_over_element);
+		goto cyttsp4_get_panel_data_show_err_release;
+	}
+
+	returned_element = return_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_H] * 256
+		+ return_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_L];
+
+	dev_dbg(dev, "%s: _cyttsp4_ret_scan_data_cmd(): num_element:%d\n",
+		__func__, returned_element);
+
+	/* read data */
+	read_byte += returned_element *
+			(return_buf[CY_CMD_RET_PNL_OUT_DATA_FORMAT_OFFS] &
+				CY_CMD_RET_PANEL_ELMNT_SZ_MASK);
+
+	rc = cyttsp4_read(dad->ttsp, CY_MODE_CAT, 0, dad->ic_buf, read_byte);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on read r=%d\n", __func__, rc);
+		goto cyttsp4_get_panel_data_show_err_release;
+	}
+
+	left_over_element = dad->heatmap.num_element - returned_element;
+	read_element_offset = returned_element;
+	data_idx = read_byte;
+
+	while (left_over_element > 0) {
+		/* get the data */
+		rc = _cyttsp4_ret_scan_data_cmd(dev, read_element_offset,
+				left_over_element, dad->heatmap.data_type,
+				return_buf);
+		if (rc < 0) {
+			dev_err(dev, "%s: Error %d  on _cyttsp4_ret_scan_data_cmd(), offset=%d num_element:%d\n",
+				__func__, rc, read_element_offset,
+				left_over_element);
+			goto cyttsp4_get_panel_data_show_err_release;
+		}
+		if (return_buf[CY_CMD_OUT_STATUS_OFFSET]
+				!= CY_CMD_STATUS_SUCCESS) {
+			dev_err(dev, "%s: Fail on _cyttsp4_ret_scan_data_cmd(), offset=%d num_element:%d\n",
+				__func__, read_element_offset,
+				left_over_element);
+			goto cyttsp4_get_panel_data_show_err_release;
+		}
+
+		returned_element =
+			return_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_H] * 256
+			+ return_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_L];
+
+		dev_dbg(dev, "%s: _cyttsp4_ret_scan_data_cmd(): num_element:%d\n",
+			__func__, returned_element);
+
+		/* Check if we requested more elements than the device has */
+		if (returned_element == 0) {
+			dev_dbg(dev, "%s: returned_element=0, left_over_element=%d\n",
+				__func__, left_over_element);
+			break;
+		}
+
+		/* DO read */
+		read_byte = returned_element *
+			(return_buf[CY_CMD_RET_PNL_OUT_DATA_FORMAT_OFFS]
+				& CY_CMD_RET_PANEL_ELMNT_SZ_MASK);
+
+		rc = cyttsp4_read(dad->ttsp, CY_MODE_CAT,
+				element_start_offset,
+				dad->ic_buf + data_idx,
+				read_byte);
+		if (rc < 0) {
+			dev_err(dev, "%s: Error on read r=%d\n", __func__, rc);
+			goto cyttsp4_get_panel_data_show_err_release;
+		}
+
+		/* Update element status */
+		left_over_element -= returned_element;
+		read_element_offset += returned_element;
+		data_idx += read_byte;
+
+	}
+	/* update on the buffer */
+	dad->ic_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_H + cmd_param_ofs] =
+		HI_BYTE(read_element_offset);
+	dad->ic_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_L + cmd_param_ofs] =
+		LO_BYTE(read_element_offset);
+
+cyttsp4_get_panel_data_show_err_release:
+	rc1 = cyttsp4_release_exclusive(dad->ttsp);
+	if (rc1 < 0) {
+		dev_err(dev, "%s: Error on release exclusive r=%d\n",
+				__func__, rc1);
+		goto cyttsp4_get_panel_data_show_err_sysfs;
+	}
+
+	if (rc < 0)
+		goto cyttsp4_get_panel_data_show_err_sysfs;
+
+	print_idx = 0;
+	print_idx += scnprintf(buf, CY_MAX_PRBUF_SIZE, "CY_DATA:");
+	for (i = 0; i < data_idx; i++) {
+		print_idx += scnprintf(buf + print_idx,
+				CY_MAX_PRBUF_SIZE - print_idx,
+				"%02X ", dad->ic_buf[i]);
+	}
+	print_idx += scnprintf(buf + print_idx, CY_MAX_PRBUF_SIZE - print_idx,
+			":(%d bytes)\n", data_idx);
+
+cyttsp4_get_panel_data_show_err_sysfs:
+	return print_idx;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 6.
+ * Prints contents of the touch parameters a row at a time.
+ */
+static int cyttsp4_get_panel_data_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	ssize_t length;
+
+	mutex_lock(&dad->sysfs_lock);
+
+	length = cyttsp4_ic_parse_input(dev, buf, size, dad->ic_buf,
+			CY_MAX_PRBUF_SIZE);
+	if (length <= 0) {
+		dev_err(dev, "%s: %s Group Data store\n", __func__,
+				"Malformed input for");
+		goto cyttsp4_get_panel_data_store_exit;
+	}
+
+	dev_vdbg(dev, "%s: grpnum=%d grpoffset=%u\n",
+			__func__, dad->ic_grpnum, dad->ic_grpoffset);
+
+	if (dad->ic_grpnum >= CY_IC_GRPNUM_NUM) {
+		dev_err(dev, "%s: Group %d does not exist.\n",
+				__func__, dad->ic_grpnum);
+		goto cyttsp4_get_panel_data_store_exit;
+	}
+
+	pm_runtime_get_sync(dev);
+	/*update parameter value */
+	dad->heatmap.num_element = dad->ic_buf[4] + (dad->ic_buf[3] * 256);
+	dad->heatmap.data_type = dad->ic_buf[5];
+
+	if (dad->ic_buf[6] > 0)
+		dad->heatmap.scan_start = true;
+	else
+		dad->heatmap.scan_start = false;
+	pm_runtime_put(dev);
+
+cyttsp4_get_panel_data_store_exit:
+	mutex_unlock(&dad->sysfs_lock);
+	dev_vdbg(dev, "%s: return size=%d\n", __func__, size);
+	return size;
+}
+
+static DEVICE_ATTR(get_panel_data, S_IRUSR | S_IWUSR,
+	cyttsp4_get_panel_data_show, cyttsp4_get_panel_data_store);
+
+#ifdef CONFIG_PM_SLEEP
+static int cyttsp4_device_access_suspend(struct device *dev)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	if (!mutex_trylock(&dad->sysfs_lock))
+		return -EBUSY;
+
+	mutex_unlock(&dad->sysfs_lock);
+	return 0;
+}
+
+static int cyttsp4_device_access_resume(struct device *dev)
+{
+	dev_dbg(dev, "%s\n", __func__);
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops cyttsp4_device_access_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(cyttsp4_device_access_suspend,
+			cyttsp4_device_access_resume)
+};
+
+static int cyttsp4_setup_sysfs(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc = 0;
+
+	rc = device_create_file(dev, &dev_attr_ic_grpnum);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create ic_grpnum\n",
+				__func__);
+		goto exit;
+	}
+
+	rc = device_create_file(dev, &dev_attr_ic_grpoffset);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create ic_grpoffset\n",
+				__func__);
+		goto unregister_grpnum;
+	}
+
+	rc = device_create_file(dev, &dev_attr_ic_grpdata);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create ic_grpdata\n",
+				__func__);
+		goto unregister_grpoffset;
+	}
+    
+    /*** ZTEMT Added by luochangyang, 2013/10/28 ***/
+    rc = device_create_file(dev, &dev_attr_ic_grpdetect);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create ic_grpdetect\n",
+				__func__);
+		goto unregister_grpdata;
+	}
+    /***ZTEMT END***/
+
+	rc = device_create_file(dev, &dev_attr_get_panel_data);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create get_panel_data\n",
+				__func__);
+		goto unregister_grpdetect;
+	}
+
+	dad->sysfs_nodes_created = true;
+	return rc;
+    
+/*** ZTEMT Added by luochangyang, 2013/10/28 ***/
+unregister_grpdetect:
+    device_remove_file(dev, &dev_attr_ic_grpdetect);
+/***ZTEMT END***/
+
+unregister_grpdata:
+	device_remove_file(dev, &dev_attr_ic_grpdata);
+unregister_grpoffset:
+	device_remove_file(dev, &dev_attr_ic_grpoffset);
+unregister_grpnum:
+	device_remove_file(dev, &dev_attr_ic_grpnum);
+exit:
+	return rc;
+}
+
+static int cyttsp4_setup_sysfs_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc = 0;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	dad->si = cyttsp4_request_sysinfo(ttsp);
+	if (!dad->si)
+		return -1;
+
+	rc = cyttsp4_setup_sysfs(ttsp);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_setup_sysfs_attention, 0);
+
+	return rc;
+
+}
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS_API
+static struct cyttsp4_device *device_access_devices[CY_MAX_NUM_CORE_DEVS];
+static DEFINE_MUTEX(device_access_devices_lock);
+
+static void insert_da_device(struct cyttsp4_device *ttsp)
+{
+	int i;
+
+	mutex_lock(&device_access_devices_lock);
+	for (i = 0; i < ARRAY_SIZE(device_access_devices); i++)
+		if (!device_access_devices[i]) {
+			device_access_devices[i] = ttsp;
+			goto exit;
+		}
+exit:
+	mutex_unlock(&device_access_devices_lock);
+}
+
+static void remove_da_device(struct cyttsp4_device *ttsp)
+{
+	int i;
+
+	mutex_lock(&device_access_devices_lock);
+	for (i = 0; i < ARRAY_SIZE(device_access_devices); i++)
+		if (device_access_devices[i] == ttsp) {
+			device_access_devices[i] = NULL;
+			goto exit;
+		}
+exit:
+	mutex_unlock(&device_access_devices_lock);
+}
+
+static struct cyttsp4_device *_find_da_device(const char *core_name)
+{
+	char ttsp_name[64];
+	int i;
+
+	scnprintf(ttsp_name, 64, "%s.%s", CYTTSP4_DEVICE_ACCESS_NAME,
+			core_name);
+
+	for (i = 0; i < ARRAY_SIZE(device_access_devices); i++) {
+		struct cyttsp4_device *ttsp = device_access_devices[i];
+		if (!ttsp || strncmp(dev_name(&ttsp->dev), ttsp_name, 64))
+			continue;
+
+		return ttsp;
+	}
+
+	return NULL;
+}
+
+int cyttsp4_device_access_read_command(const char *core_name, int ic_grpnum,
+		int ic_grpoffset, u8 *buf, int buf_size)
+{
+	struct cyttsp4_device_access_data *dad;
+	struct cyttsp4_device *ttsp;
+	struct device *dev;
+	int prev_grpnum;
+	int rc;
+
+	might_sleep();
+
+	/* Validate ic_grpnum */
+	if (ic_grpnum >= CY_IC_GRPNUM_NUM) {
+		pr_err("%s: Group %d does not exist.\n", __func__, ic_grpnum);
+		return -EINVAL;
+	}
+
+	/* Validate ic_grpoffset */
+	if (ic_grpoffset > 0xFFFF) {
+		pr_err("%s: Offset %d invalid.\n", __func__, ic_grpoffset);
+		return -EINVAL;
+	}
+
+	if (!core_name)
+		core_name = CY_DEFAULT_CORE_ID;
+
+	mutex_lock(&device_access_devices_lock);
+	/* Find device */
+	ttsp = _find_da_device(core_name);
+	if (!ttsp) {
+		pr_err("%s: No device.\n", __func__);
+		rc = -ENODEV;
+		goto exit_unlock_da;
+	}
+
+	dev = &ttsp->dev;
+	dad = dev_get_drvdata(dev);
+
+	/* Check sysinfo */
+	if (!dad->si) {
+		pr_err("%s: No sysinfo.\n", __func__);
+		rc = -ENODEV;
+		goto exit_unlock_da;
+	}
+
+	mutex_lock(&dad->sysfs_lock);
+	/*
+	 * Block grpnum change when own_exclusive flag is set
+	 * which means the current grpnum implementation requires
+	 * running exclusively on some consecutive grpdata operations
+	 */
+	if (dad->own_exclusive && dad->ic_grpnum != ic_grpnum) {
+		dev_err(dev, "%s: own_exclusive\n", __func__);
+		rc = -EBUSY;
+		goto exit;
+	}
+
+	prev_grpnum = dad->ic_grpnum;
+	dad->ic_grpnum = ic_grpnum;
+	dad->ic_grpoffset = ic_grpoffset;
+
+	rc = cyttsp4_grpdata_show_functions[dad->ic_grpnum] (dev,
+			buf, buf_size);
+
+exit:
+	mutex_unlock(&dad->sysfs_lock);
+exit_unlock_da:
+	mutex_unlock(&device_access_devices_lock);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_device_access_read_command);
+
+int cyttsp4_device_access_write_command(const char *core_name, int ic_grpnum,
+		int ic_grpoffset, u8 *buf, int length)
+{
+	struct cyttsp4_device_access_data *dad;
+	struct cyttsp4_device *ttsp;
+	struct device *dev;
+	int prev_grpnum;
+	int rc;
+
+	might_sleep();
+
+	/* Validate ic_grpnum */
+	if (ic_grpnum >= CY_IC_GRPNUM_NUM) {
+		pr_err("%s: Group %d does not exist.\n", __func__, ic_grpnum);
+		return -EINVAL;
+	}
+
+	/* Validate ic_grpoffset */
+	if (ic_grpoffset > 0xFFFF) {
+		pr_err("%s: Offset %d invalid.\n", __func__, ic_grpoffset);
+		return -EINVAL;
+	}
+
+	if (!core_name)
+		core_name = CY_DEFAULT_CORE_ID;
+
+	mutex_lock(&device_access_devices_lock);
+	/* Find device */
+	ttsp = _find_da_device(core_name);
+	if (!ttsp) {
+		pr_err("%s: No device.\n", __func__);
+		rc = -ENODEV;
+		goto exit_unlock_da;
+	}
+
+	dev = &ttsp->dev;
+	dad = dev_get_drvdata(dev);
+
+	/* Check sysinfo */
+	if (!dad->si) {
+		pr_err("%s: No sysinfo.\n", __func__);
+		rc = -ENODEV;
+		goto exit_unlock_da;
+	}
+
+	mutex_lock(&dad->sysfs_lock);
+	/*
+	 * Block grpnum change when own_exclusive flag is set
+	 * which means the current grpnum implementation requires
+	 * running exclusively on some consecutive grpdata operations
+	 */
+	if (dad->own_exclusive && dad->ic_grpnum != ic_grpnum) {
+		dev_err(dev, "%s: own_exclusive\n", __func__);
+		rc = -EBUSY;
+		goto exit;
+	}
+
+	prev_grpnum = dad->ic_grpnum;
+	dad->ic_grpnum = ic_grpnum;
+	dad->ic_grpoffset = ic_grpoffset;
+
+	/* write ic_buf to log */
+	cyttsp4_pr_buf(dev, dad->pr_buf, buf, length, "ic_buf");
+
+	/* Call relevant store handler. */
+	rc = cyttsp4_grpdata_store_functions[dad->ic_grpnum] (dev, buf,
+			length);
+	if (rc < 0)
+		dev_err(dev, "%s: Failed to store for grpmun=%d.\n",
+				__func__, dad->ic_grpnum);
+
+exit:
+	mutex_unlock(&dad->sysfs_lock);
+exit_unlock_da:
+	mutex_unlock(&device_access_devices_lock);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_device_access_write_command);
+#endif
+
+static int cyttsp4_device_access_probe(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_device_access_data *dad;
+	struct cyttsp4_device_access_platform_data *pdata =
+			dev_get_platdata(dev);
+	int rc = 0;
+
+	dev_dbg(dev, "%s\n", __func__);
+	dev_dbg(dev, "%s: debug on\n", __func__);
+	dev_vdbg(dev, "%s: verbose debug on\n", __func__);
+
+	dad = kzalloc(sizeof(*dad), GFP_KERNEL);
+	if (dad == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto cyttsp4_device_access_probe_data_failed;
+	}
+
+	mutex_init(&dad->sysfs_lock);
+	init_waitqueue_head(&dad->wait_q);
+	dad->ttsp = ttsp;
+	dad->pdata = pdata;
+	dad->ic_grpnum = CY_IC_GRPNUM_TCH_REP;
+	dad->test.cur_cmd = -1;
+	dad->heatmap.num_element = 200;
+	dev_set_drvdata(dev, dad);
+
+	pm_runtime_enable(dev);
+
+	/* get sysinfo */
+	dad->si = cyttsp4_request_sysinfo(ttsp);
+	if (dad->si) {
+		rc = cyttsp4_setup_sysfs(ttsp);
+		if (rc)
+			goto cyttsp4_device_access_setup_sysfs_failed;
+	} else {
+		dev_err(dev, "%s: Fail get sysinfo pointer from core p=%p\n",
+				__func__, dad->si);
+		cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_sysfs_attention, 0);
+	}
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS_API
+	insert_da_device(ttsp);
+#endif
+	dev_dbg(dev, "%s: ok\n", __func__);
+	return 0;
+
+ cyttsp4_device_access_setup_sysfs_failed:
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+	dev_set_drvdata(dev, NULL);
+	kfree(dad);
+ cyttsp4_device_access_probe_data_failed:
+	dev_err(dev, "%s failed.\n", __func__);
+	return rc;
+}
+
+static int cyttsp4_device_access_release(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	u8 ic_buf[CY_NULL_CMD_MODE_INDEX + 1];
+	dev_dbg(dev, "%s\n", __func__);
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS_API
+	remove_da_device(ttsp);
+#endif
+
+	if (dad->own_exclusive) {
+		dev_err(dev, "%s: Can't unload in CAT mode. First switch back to Operational mode\n"
+				, __func__);
+		ic_buf[CY_NULL_CMD_MODE_INDEX] = CY_HST_OPERATE;
+		cyttsp4_test_cmd_mode(dad, ic_buf, CY_NULL_CMD_MODE_INDEX + 1);
+	}
+
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+
+	if (dad->sysfs_nodes_created) {
+		device_remove_file(dev, &dev_attr_ic_grpnum);
+		device_remove_file(dev, &dev_attr_ic_grpoffset);
+		device_remove_file(dev, &dev_attr_ic_grpdata);
+		device_remove_file(dev, &dev_attr_get_panel_data);
+	} else {
+		cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_sysfs_attention, 0);
+	}
+
+	dev_set_drvdata(dev, NULL);
+	kfree(dad);
+	return 0;
+}
+
+static struct cyttsp4_driver cyttsp4_device_access_driver = {
+	.probe = cyttsp4_device_access_probe,
+	.remove = cyttsp4_device_access_release,
+	.driver = {
+		.name = CYTTSP4_DEVICE_ACCESS_NAME,
+		.bus = &cyttsp4_bus_type,
+		.owner = THIS_MODULE,
+		.pm = &cyttsp4_device_access_pm_ops,
+	},
+};
+
+static struct cyttsp4_device_access_platform_data
+	_cyttsp4_device_access_platform_data = {
+	.device_access_dev_name = CYTTSP4_DEVICE_ACCESS_NAME,
+};
+
+static const char cyttsp4_device_access_name[] = CYTTSP4_DEVICE_ACCESS_NAME;
+static struct cyttsp4_device_info
+	cyttsp4_device_access_infos[CY_MAX_NUM_CORE_DEVS];
+
+static const char *core_ids[CY_MAX_NUM_CORE_DEVS] = {
+	CY_DEFAULT_CORE_ID,
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static int num_core_ids = 1;
+
+//module_param_array(core_ids, charp, &num_core_ids, 0);
+//MODULE_PARM_DESC(core_ids,
+//	"Core id list of cyttsp4 core devices for device access module");
+
+static int __init cyttsp4_device_access_init(void)
+{
+	int rc = 0;
+	int i, j;
+
+	/* Check for invalid or duplicate core_ids */
+	for (i = 0; i < num_core_ids; i++) {
+		if (!strlen(core_ids[i])) {
+			pr_err("%s: core_id %d is empty\n",
+				__func__, i+1);
+			return -EINVAL;
+		}
+		for (j = i+1; j < num_core_ids; j++)
+			if (!strcmp(core_ids[i], core_ids[j])) {
+				pr_err("%s: core_ids %d and %d are same\n",
+					__func__, i+1, j+1);
+				return -EINVAL;
+			}
+	}
+
+	for (i = 0; i < num_core_ids; i++) {
+		cyttsp4_device_access_infos[i].name =
+			cyttsp4_device_access_name;
+		cyttsp4_device_access_infos[i].core_id = core_ids[i];
+		cyttsp4_device_access_infos[i].platform_data =
+			&_cyttsp4_device_access_platform_data;
+		pr_debug("%s: Registering device access device for core_id: %s\n",
+			__func__, cyttsp4_device_access_infos[i].core_id);
+		rc = cyttsp4_register_device(&cyttsp4_device_access_infos[i]);
+		if (rc < 0) {
+			pr_err("%s: Error, failed registering device\n",
+				__func__);
+			goto fail_unregister_devices;
+		}
+	}
+	rc = cyttsp4_register_driver(&cyttsp4_device_access_driver);
+	if (rc) {
+		pr_err("%s: Error, failed registering driver\n", __func__);
+		goto fail_unregister_devices;
+	}
+
+	pr_debug("%s: Cypress TTSP Device Access (Built %s) rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return 0;
+
+fail_unregister_devices:
+	for (i--; i >= 0; i--) {
+		cyttsp4_unregister_device(cyttsp4_device_access_infos[i].name,
+			cyttsp4_device_access_infos[i].core_id);
+		pr_info("%s: Unregistering device access device for core_id: %s\n",
+			__func__, cyttsp4_device_access_infos[i].core_id);
+	}
+	return rc;
+}
+module_init(cyttsp4_device_access_init);
+
+static void __exit cyttsp4_device_access_exit(void)
+{
+	int i;
+
+	cyttsp4_unregister_driver(&cyttsp4_device_access_driver);
+	for (i = 0; i < num_core_ids; i++) {
+		cyttsp4_unregister_device(cyttsp4_device_access_infos[i].name,
+			cyttsp4_device_access_infos[i].core_id);
+		pr_info("%s: Unregistering device access device for core_id: %s\n",
+			__func__, cyttsp4_device_access_infos[i].core_id);
+	}
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_device_access_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard Product Device Access Driver");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_device_access.h b/drivers/input/touchscreen/cyttsp4/cyttsp4_device_access.h
new file mode 100755
index 0000000..0ad1a88
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_device_access.h
@@ -0,0 +1,67 @@
+/*
+ * cyttsp4_device_access.h
+ * Cypress TrueTouch(TM) Standard Product V4 Device Access module.
+ * Configuration and Test command/status user interface.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_DEVICE_ACCESS_H
+#define _LINUX_CYTTSP4_DEVICE_ACCESS_H
+
+#define CYTTSP4_DEVICE_ACCESS_NAME "cyttsp4_device_access"
+
+#define CYTTSP4_INPUT_ELEM_SZ (sizeof("0xHH") + 1)
+#define CYTTSP4_TCH_PARAM_SIZE_BLK_SZ 128
+
+/* Timeout values in ms. */
+#define CY_DA_REQUEST_EXCLUSIVE_TIMEOUT	500
+
+struct cyttsp4_device_access_platform_data {
+	char const *device_access_dev_name;
+};
+
+#define CY_CMD_IN_DATA_OFFSET_VALUE 0
+
+#define CY_CMD_OUT_STATUS_OFFSET 0
+#define CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_H 2
+#define CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_L 3
+#define CY_CMD_RET_PNL_OUT_DATA_FORMAT_OFFS 4
+
+#define CY_CMD_RET_PANEL_ELMNT_SZ_MASK 0x07
+
+enum cyttsp4_scan_data_type {
+	CY_MUT_RAW,
+	CY_MUT_BASE,
+	CY_MUT_DIFF,
+	CY_SELF_RAW,
+	CY_SELF_BASE,
+	CY_SELF_DIFF,
+	CY_BAL_RAW,
+	CY_BAL_BASE,
+	CY_BAL_DIFF,
+};
+
+#endif /* _LINUX_CYTTSP4_DEVICE_ACCESS_H */
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_i2c.c b/drivers/input/touchscreen/cyttsp4/cyttsp4_i2c.c
new file mode 100755
index 0000000..8693407
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_i2c.c
@@ -0,0 +1,392 @@
+/*
+ * cyttsp4_i2c.c
+ * Cypress TrueTouch(TM) Standard Product V4 I2C Driver module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ * Modified by: Cypress Semiconductor for test with device
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include "cyttsp4_bus.h"
+#include "cyttsp4_core.h"
+#include "cyttsp4_i2c.h"
+
+#include <linux/delay.h>
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+/*** ZTEMT Added by luochangyang, 2013/03/27 ***/
+#ifdef CONFIG_OF
+#include <linux/err.h>
+#include <linux/of_gpio.h>
+#include <linux/regulator/consumer.h>
+#endif
+
+#define CY_I2C_DATA_SIZE  (3 * 256)
+
+struct cyttsp4_i2c {
+	struct i2c_client *client;
+	u8 wr_buf[CY_I2C_DATA_SIZE];
+	struct mutex lock;
+};
+
+static int cyttsp4_i2c_read_block_data(struct cyttsp4_i2c *ts_i2c, u16 addr,
+		int length, void *values, int max_xfer)
+{
+	int rc = -EINVAL;
+	int trans_len;
+	u8 client_addr;
+	u8 addr_lo;
+	struct i2c_msg msgs[2];
+
+	while (length > 0) {
+		client_addr = ts_i2c->client->addr | ((addr >> 8) & 0x1);
+		addr_lo = addr & 0xFF;
+		trans_len = min(length, max_xfer);
+
+		memset(msgs, 0, sizeof(msgs));
+		msgs[0].addr = client_addr;
+		msgs[0].flags = 0;
+		msgs[0].len = 1;
+		msgs[0].buf = &addr_lo;
+
+		msgs[1].addr = client_addr;
+		msgs[1].flags = I2C_M_RD;
+		msgs[1].len = trans_len;
+		msgs[1].buf = values;
+
+		rc = i2c_transfer(ts_i2c->client->adapter, msgs, 2);
+		if (rc != 2)
+			goto exit;
+
+		length -= trans_len;
+		values += trans_len;
+		addr += trans_len;
+	}
+
+exit:
+	return (rc < 0) ? rc : rc != ARRAY_SIZE(msgs) ? -EIO : 0;
+}
+
+static int cyttsp4_i2c_write_block_data(struct cyttsp4_i2c *ts_i2c, u16 addr,
+		int length, const void *values, int max_xfer)
+{
+	int rc = -EINVAL;
+	u8 client_addr;
+	u8 addr_lo;
+	int trans_len;
+	struct i2c_msg msg;
+
+	if (sizeof(ts_i2c->wr_buf) < (length + 1))
+		return -ENOMEM;
+
+	while (length > 0) {
+		client_addr = ts_i2c->client->addr | ((addr >> 8) & 0x1);
+		addr_lo = addr & 0xFF;
+		trans_len = min(length, max_xfer);
+
+		memset(&msg, 0, sizeof(msg));
+		msg.addr = client_addr;
+		msg.flags = 0;
+		msg.len = trans_len + 1;
+		msg.buf = ts_i2c->wr_buf;
+
+		ts_i2c->wr_buf[0] = addr_lo;
+		memcpy(&ts_i2c->wr_buf[1], values, trans_len);
+
+		/* write data */
+		rc = i2c_transfer(ts_i2c->client->adapter, &msg, 1);
+		if (rc != 1)
+			goto exit;
+
+		length -= trans_len;
+		values += trans_len;
+		addr += trans_len;
+	}
+
+exit:
+	return (rc < 0) ? rc : rc != 1 ? -EIO : 0;
+}
+
+static int cyttsp4_i2c_write(struct cyttsp4_adapter *adap, u16 addr,
+	const void *buf, int size, int max_xfer)
+{
+	struct cyttsp4_i2c *ts = dev_get_drvdata(adap->dev);
+	int rc;
+
+	pm_runtime_get_noresume(adap->dev);
+	mutex_lock(&ts->lock);
+	rc = cyttsp4_i2c_write_block_data(ts, addr, size, buf, max_xfer);
+	mutex_unlock(&ts->lock);
+	pm_runtime_put_noidle(adap->dev);
+
+	return rc;
+}
+
+static int cyttsp4_i2c_read(struct cyttsp4_adapter *adap, u16 addr,
+	void *buf, int size, int max_xfer)
+{
+	struct cyttsp4_i2c *ts = dev_get_drvdata(adap->dev);
+	int rc;
+
+	pm_runtime_get_noresume(adap->dev);
+	mutex_lock(&ts->lock);
+	rc = cyttsp4_i2c_read_block_data(ts, addr, size, buf, max_xfer);
+	mutex_unlock(&ts->lock);
+	pm_runtime_put_noidle(adap->dev);
+
+	return rc;
+}
+
+/*** ZTEMT Added by luochangyang, 2013/03/27 ***/
+#ifdef CONFIG_OF
+static int reg_set_optimum_mode_check(struct regulator *reg, int load_uA)
+{
+	return (regulator_count_voltages(reg) > 0) ?
+		regulator_set_optimum_mode(reg, load_uA) : 0;
+}
+
+static int cyttsp4_power_on(struct device *dev)
+{
+	int rc;
+	static struct regulator *vcc_ana;
+	static struct regulator *vcc_i2c;
+
+	vcc_ana = regulator_get(dev, "vdd_ana");
+	if (IS_ERR(vcc_ana))
+	{
+		rc = PTR_ERR(vcc_ana);
+		dev_err(dev, "Regulator get failed vcc_ana rc=%d\n", rc);
+		return rc;
+	}
+
+	if (regulator_count_voltages(vcc_ana) > 0)
+	{
+		rc = regulator_set_voltage(vcc_ana, 2850000, 2850000);
+		if (rc)
+		{
+			dev_err(dev, "Regulator set ana vtg failed rc=%d\n", rc);
+			goto error_set_vtg_vcc_ana;
+		}
+	}
+	
+	rc = reg_set_optimum_mode_check(vcc_ana, 15000);
+	if (rc < 0)
+	{
+		dev_err(dev, "Regulator vcc_ana set_opt failed rc=%d\n", rc);
+		return rc;
+	}
+	
+	rc = regulator_enable(vcc_ana);
+	if (rc)
+	{
+		dev_err(dev, "Regulator vcc_ana enable failed rc=%d\n", rc);
+		goto error_reg_en_vcc_ana;
+	}
+	
+	vcc_i2c = regulator_get(dev, "vcc_i2c");
+	if (IS_ERR(vcc_i2c))
+	{
+		rc = PTR_ERR(vcc_i2c);
+		dev_err(dev, "Regulator get failed rc=%d\n", rc);
+		goto error_reg_opt_vcc_dig;
+	}
+
+	rc = regulator_enable(vcc_i2c);
+	if (rc)
+	{
+		dev_err(dev, "Regulator vcc_i2c enable failed rc=%d\n", rc);
+		goto error_reg_en_vcc_i2c;
+	}
+
+	msleep(100);
+	
+	return 0;
+
+error_reg_en_vcc_i2c:
+	reg_set_optimum_mode_check(vcc_i2c, 0);
+error_reg_opt_vcc_dig:
+	regulator_disable(vcc_ana);
+error_reg_en_vcc_ana:
+	reg_set_optimum_mode_check(vcc_ana, 0);
+error_set_vtg_vcc_ana:
+	regulator_put(vcc_ana);
+	return rc;
+}
+
+static int cyttsp4_parse_dt(struct device *dev)
+{
+	struct device_node *np = dev->of_node; 
+    int rst_gpio = 0;
+    int irq_gpio = 0;
+
+	/* reset, irq gpio info */
+	rst_gpio = of_get_named_gpio(np, "cypress,reset-gpio", 0);
+	irq_gpio = of_get_named_gpio(np, "cypress,irq-gpio", 0);
+    
+    return 0;
+}
+#endif
+
+static struct cyttsp4_ops ops = {
+	.write = cyttsp4_i2c_write,
+	.read = cyttsp4_i2c_read,
+};
+
+static int __devinit cyttsp4_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *i2c_id)
+{
+	struct cyttsp4_i2c *ts_i2c;
+	struct device *dev = &client->dev;
+	char const *adap_id = dev_get_platdata(dev);
+	char const *id;
+	int rc;
+
+	dev_dbg(dev, "%s: Starting %s probe...\n", __func__, CYTTSP4_I2C_NAME);
+
+	dev_dbg(dev, "%s: debug on\n", __func__);
+	dev_vdbg(dev, "%s: verbose debug on\n", __func__);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(dev, "%s: fail check I2C functionality\n", __func__);
+		rc = -EIO;
+		goto error_alloc_data_failed;
+	}
+
+	ts_i2c = kzalloc(sizeof(struct cyttsp4_i2c), GFP_KERNEL);
+	if (ts_i2c == NULL) {
+		dev_err(dev, "%s: Error, kzalloc.\n", __func__);
+		rc = -ENOMEM;
+		goto error_alloc_data_failed;
+	}
+    
+/*** ZTEMT Added by luochangyang, 2013/03/27 ***/
+#ifdef CONFIG_OF
+	if (client->dev.of_node) {
+		rc = cyttsp4_parse_dt(&client->dev);
+		if (rc)
+			return rc;
+	} else
+		dev_err(dev, "%s: no client->dev.of_node.\n", __func__);
+    
+    cyttsp4_power_on(&client->dev);
+#endif
+
+	mutex_init(&ts_i2c->lock);
+	ts_i2c->client = client;
+	client->dev.bus = &i2c_bus_type;
+	i2c_set_clientdata(client, ts_i2c);
+	dev_set_drvdata(&client->dev, ts_i2c);
+
+	if (adap_id)
+		id = adap_id;
+	else
+		id = CYTTSP4_I2C_NAME;
+
+	dev_dbg(dev, "%s: add adap='%s' (CYTTSP4_I2C_NAME=%s)\n", __func__, id,
+		CYTTSP4_I2C_NAME);
+
+	pm_runtime_enable(&client->dev);
+
+	rc = cyttsp4_add_adapter(id, &ops, dev);
+	if (rc) {
+		dev_err(dev, "%s: Error on probe %s\n", __func__,
+			CYTTSP4_I2C_NAME);
+		goto add_adapter_err;
+	}
+
+	dev_dbg(dev, "%s: Successful probe %s\n", __func__, CYTTSP4_I2C_NAME);
+
+	return 0;
+
+add_adapter_err:
+	pm_runtime_disable(&client->dev);
+	dev_set_drvdata(&client->dev, NULL);
+	i2c_set_clientdata(client, NULL);
+	kfree(ts_i2c);
+error_alloc_data_failed:
+	return rc;
+}
+
+/* registered in driver struct */
+static int __devexit cyttsp4_i2c_remove(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct cyttsp4_i2c *ts_i2c = dev_get_drvdata(dev);
+	char const *adap_id = dev_get_platdata(dev);
+	char const *id;
+
+	if (adap_id)
+		id = adap_id;
+	else
+		id = CYTTSP4_I2C_NAME;
+
+	dev_info(dev, "%s\n", __func__);
+	cyttsp4_del_adapter(id);
+	pm_runtime_disable(&client->dev);
+	dev_set_drvdata(&client->dev, NULL);
+	i2c_set_clientdata(client, NULL);
+	kfree(ts_i2c);
+	return 0;
+}
+
+static const struct i2c_device_id cyttsp4_i2c_id[] = {
+	{ CYTTSP4_I2C_NAME, 0 },
+    { }
+};
+
+/*** ZTEMT modify by luochangyang, 2013/03/27 ***/
+#ifdef CONFIG_OF //Open firmware must be defined for dts useage
+static struct of_device_id cyttsp4_match_table[] = {
+	{ .compatible = "cypress,cyttsp4_i2c_adapter",}, //Compatible node must match dts
+    { },
+};
+#else
+#define cyttsp4_match_table NULL
+#endif
+
+static struct i2c_driver cyttsp4_i2c_driver = {
+	.driver = {
+		.name = CYTTSP4_I2C_NAME,
+		.owner = THIS_MODULE,
+        .of_match_table = cyttsp4_match_table,
+	},
+	.probe = cyttsp4_i2c_probe,
+	.remove = __devexit_p(cyttsp4_i2c_remove),
+	.id_table = cyttsp4_i2c_id,
+};
+
+module_i2c_driver(cyttsp4_i2c_driver);
+
+MODULE_ALIAS(CYTTSP4_I2C_NAME);
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard Product (TTSP) I2C driver");
+MODULE_AUTHOR("Cypress");
+MODULE_DEVICE_TABLE(i2c, cyttsp4_i2c_id);
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_i2c.h b/drivers/input/touchscreen/cyttsp4/cyttsp4_i2c.h
new file mode 100755
index 0000000..6bb91fd
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_i2c.h
@@ -0,0 +1,35 @@
+/*
+ * cyttsp4_i2c.h
+ * Cypress TrueTouch(TM) Standard Product V4 I2C driver module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_I2C_H
+#define _LINUX_CYTTSP4_I2C_H
+
+#define CYTTSP4_I2C_NAME "cyttsp4_i2c_adapter"
+
+#endif /* _LINUX_CYTTSP4_I2C_H */
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_loader.c b/drivers/input/touchscreen/cyttsp4/cyttsp4_loader.c
new file mode 100755
index 0000000..98e8121
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_loader.c
@@ -0,0 +1,1996 @@
+/*
+ * cyttsp4_loader.c
+ * Cypress TrueTouch(TM) Standard Product V4 FW loader module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2009-2012 Cypress Semiconductor, Inc.
+ * Copyright (C) 2011 Motorola Mobility, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <asm/unaligned.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/firmware.h>
+#include "cyttsp4_bus.h"
+#include "cyttsp4_core.h"
+#include "cyttsp4_regs.h"
+
+#include <linux/completion.h>//add by yfliu
+
+
+#define CYTTSP4_LOADER_NAME "cyttsp4_loader"
+#define CYTTSP4_AUTO_LOAD_FOR_CORRUPTED_FW 1
+#define CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_USE_FW_BIN_FILE 1//add by liuyongfeng
+#define CY_MAX_NUM_CORE_DEVS				5//add by yfliu
+
+#define CYTTSP4_FW_UPGRADE \
+	(defined(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE) \
+	|| defined(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE))
+
+#define CYTTSP4_TTCONFIG_UPGRADE \
+	(defined(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_TTCONFIG_UPGRADE) \
+	|| defined(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE))
+
+/* Timeout values in ms. */
+#define CY_CMD_TIMEOUT					500
+#define CY_CMD_LDR_INIT_TIMEOUT				10000
+#define CY_LDR_REQUEST_EXCLUSIVE_TIMEOUT		5000
+
+#define CY_CMD_BYTE					1
+#define CY_STATUS_BYTE					1
+#define CY_MAX_STATUS_SIZE				32
+#define CY_START_OF_PACKET				0x01
+#define CY_END_OF_PACKET				0x17
+#define CY_DATA_ROW_SIZE				288
+#define CY_DATA_ROW_SIZE_TMA400				128
+#define CY_PACKET_DATA_LEN				96
+#define CY_MAX_PACKET_LEN				512
+#define CY_COMM_BUSY					0xFF
+#define CY_CMD_BUSY					0xFE
+#define CY_ARRAY_ID_OFFSET				0
+#define CY_ROW_NUM_OFFSET				1
+#define CY_ROW_SIZE_OFFSET				3
+#define CY_ROW_DATA_OFFSET				5
+#define CY_CMD_LDR_HOST_SYNC				0xFF /* tma400 */
+#define CY_CMD_LDR_EXIT					0x3B
+#define CY_CMD_LDR_EXIT_CMD_SIZE			7
+#define CY_CMD_LDR_EXIT_STAT_SIZE			7
+#define CY_CMD_LDR_ENTER				0x38
+#define CY_CMD_LDR_ENTER_CMD_SIZE			7
+#define CY_CMD_LDR_ENTER_STAT_SIZE			15
+#define CY_CMD_LDR_INIT					0x48
+#define CY_CMD_LDR_INIT_CMD_SIZE			15
+#define CY_CMD_LDR_INIT_STAT_SIZE			7
+#define CY_CMD_LDR_ERASE_ROW				0x34
+#define CY_CMD_LDR_ERASE_ROW_CMD_SIZE			10
+#define CY_CMD_LDR_ERASE_ROW_STAT_SIZE			7
+#define CY_CMD_LDR_SEND_DATA				0x37
+#define CY_CMD_LDR_SEND_DATA_CMD_SIZE			4 /* hdr bytes only */
+#define CY_CMD_LDR_SEND_DATA_STAT_SIZE			8
+#define CY_CMD_LDR_PROG_ROW				0x39
+#define CY_CMD_LDR_PROG_ROW_CMD_SIZE			7 /* hdr bytes only */
+#define CY_CMD_LDR_PROG_ROW_STAT_SIZE			7
+#define CY_CMD_LDR_VERIFY_ROW				0x3A
+#define CY_CMD_LDR_VERIFY_ROW_STAT_SIZE			8
+#define CY_CMD_LDR_VERIFY_ROW_CMD_SIZE			10
+#define CY_CMD_LDR_VERIFY_CHKSUM			0x31
+#define CY_CMD_LDR_VERIFY_CHKSUM_CMD_SIZE		7
+#define CY_CMD_LDR_VERIFY_CHKSUM_STAT_SIZE		8
+
+/* ZTEMT Added by LiuYongfeng, 2012/11/21 */
+enum {
+	cyttsp4_calibration_success,
+	cyttsp4_calibration_failed,
+};
+static int g_cali_result = cyttsp4_calibration_failed;
+static int upgrade_flag = 0;
+/* ZTEMT END */
+
+struct cyttsp4_loader_data {
+	struct cyttsp4_device *ttsp;
+	struct cyttsp4_sysinfo *si;
+	u8 status_buf[CY_MAX_STATUS_SIZE];
+	struct completion int_running;
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+	struct completion builtin_bin_fw_complete;
+	int builtin_bin_fw_status;
+#endif
+	struct work_struct fw_and_config_upgrade;
+	struct work_struct calibration_work;
+	struct cyttsp4_loader_platform_data *loader_pdata;
+/* ZTEMT Added by LiuYongfeng, 2013/1/15 */
+	struct completion cyttsp_cali_complete; 
+/* ZTEMT END */
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE
+	struct mutex config_lock;
+	u8 *config_data;
+	int config_size;
+	bool config_loading;
+#endif
+};
+
+struct cyttsp4_dev_id {
+	u32 silicon_id;
+	u8 rev_id;
+	u32 bl_ver;
+};
+
+enum ldr_status {
+	ERROR_SUCCESS = 0,
+	ERROR_COMMAND = 1,
+	ERROR_FLASH_ARRAY = 2,
+	ERROR_PACKET_DATA = 3,
+	ERROR_PACKET_LEN = 4,
+	ERROR_PACKET_CHECKSUM = 5,
+	ERROR_FLASH_PROTECTION = 6,
+	ERROR_FLASH_CHECKSUM = 7,
+	ERROR_VERIFY_IMAGE = 8,
+	ERROR_UKNOWN1 = 9,
+	ERROR_UKNOWN2 = 10,
+	ERROR_UKNOWN3 = 11,
+	ERROR_UKNOWN4 = 12,
+	ERROR_UKNOWN5 = 13,
+	ERROR_UKNOWN6 = 14,
+	ERROR_INVALID_COMMAND = 15,
+	ERROR_INVALID
+};
+
+/*** ZTEMT Modify by luochangyang, 2013/09/29 ***/
+//#if CYTTSP4_FW_UPGRADE || CYTTSP4_TTCONFIG_UPGRADE
+#if CYTTSP4_TTCONFIG_UPGRADE
+/***ZTEMT END***/
+
+/*
+ * return code:
+ * -1: Firmware version compared is older
+ *  0: Firmware version compared is identical
+ *  1: Firmware version compared is newer
+ */
+static int cyttsp4_check_firmware_version(struct cyttsp4_device *ttsp,
+		u32 fw_ver_new, u32 fw_revctrl_new_h, u32 fw_revctrl_new_l)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	u32 fw_ver_img;
+	u32 fw_revctrl_img_h;
+	u32 fw_revctrl_img_l;
+
+	fw_ver_img = data->si->si_ptrs.cydata->fw_ver_major << 8;
+	fw_ver_img += data->si->si_ptrs.cydata->fw_ver_minor;
+
+	dev_dbg(dev, "%s: img vers:0x%04X new vers:0x%04X\n", __func__,
+			fw_ver_img, fw_ver_new);
+
+	if (fw_ver_new > fw_ver_img)
+		return 1;
+
+	if (fw_ver_new < fw_ver_img)
+		return -1;
+
+	fw_revctrl_img_h = be32_to_cpu(
+		*(u32 *)(data->si->si_ptrs.cydata->revctrl + 0));
+
+	dev_dbg(dev, "%s: img revctrl_h:0x%04X new revctrl_h:0x%04X\n",
+			__func__, fw_revctrl_img_h, fw_revctrl_new_h);
+
+	if (fw_revctrl_new_h > fw_revctrl_img_h)
+		return 1;
+
+	if (fw_revctrl_new_h < fw_revctrl_img_h)
+		return -1;
+
+	fw_revctrl_img_l = be32_to_cpu(
+		*(u32 *)(data->si->si_ptrs.cydata->revctrl + 4));
+
+	dev_dbg(dev, "%s: img revctrl_l:0x%04X new revctrl_l:0x%04X\n",
+			__func__, fw_revctrl_img_l, fw_revctrl_new_l);
+
+	if (fw_revctrl_new_l > fw_revctrl_img_l)
+		return 1;
+
+	if (fw_revctrl_new_l < fw_revctrl_img_l)
+		return -1;
+
+	return 0;
+}
+#endif /* CYTTSP4_FW_UPGRADE || CYTTSP4_TTCONFIG_UPGRADE */
+
+
+#if CYTTSP4_FW_UPGRADE
+static u16 _cyttsp4_compute_crc(struct cyttsp4_device *ttsp, u8 *buf, int size)
+{
+	u16 crc = 0xffff;
+	u16 tmp;
+	int i;
+
+	if (size == 0)
+		crc = ~crc;
+	else {
+
+		do {
+			for (i = 0, tmp = 0x00ff & *buf++; i < 8;
+				i++, tmp >>= 1) {
+				if ((crc & 0x0001) ^ (tmp & 0x0001))
+					crc = (crc >> 1) ^ 0x8408;
+				else
+					crc >>= 1;
+			}
+		} while (--size);
+
+		crc = ~crc;
+		tmp = crc;
+		crc = (crc << 8) | (tmp >> 8 & 0xFF);
+	}
+
+	return crc;
+}
+
+static u16 _cyttsp4_get_short(u8 *buf)
+{
+	return ((u16)(*buf) << 8) + *(buf+1);
+}
+
+static u8 *_cyttsp4_get_row(struct cyttsp4_device *ttsp,
+			    u8 *row_buf, u8 *image_buf, int size)
+{
+	memcpy(row_buf, image_buf, size);
+	image_buf = image_buf + size;
+	return image_buf;
+}
+
+static int _cyttsp4_get_status(struct cyttsp4_device *ttsp,
+			       u8 *buf, int size, unsigned long timeout_ms)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+
+	unsigned long uretval;
+	int tries;
+	int retval = 0;
+
+	if (timeout_ms != 0) {
+		/* wait until status ready interrupt or timeout occurs */
+		uretval = wait_for_completion_timeout(
+			&data->int_running, msecs_to_jiffies(timeout_ms));
+
+		/* TODO: Reconsider purpose of having retries here */
+		for (tries = 0; tries < 2; tries++) {
+			retval = cyttsp4_read(ttsp, CY_MODE_BOOTLOADER,
+					      CY_REG_BASE, buf, size);
+			/*
+			 * retry if bus read error or
+			 * status byte shows not ready
+			 */
+			if (buf[1] == CY_COMM_BUSY || buf[1] == CY_CMD_BUSY)
+				msleep(20); /* TODO: Constant if code kept */
+			else
+				break;
+		}
+		dev_vdbg(dev,
+			"%s: tries=%d ret=%d status=%02X\n",
+			__func__, tries, retval, buf[1]);
+	}
+
+	return retval;
+}
+
+static int _cyttsp4_send_cmd(struct cyttsp4_device *ttsp, const u8 *cmd_buf,
+			     int cmd_size, u8 *stat_ret, size_t num_stat_byte,
+			     size_t status_size, unsigned long timeout_ms)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+
+	u8 *status_buf = data->status_buf;
+	int retval = 0;
+
+	if (cmd_buf == NULL)
+		goto _cyttsp4_send_cmd_exit;
+
+	if (cmd_size == 0)
+		goto _cyttsp4_send_cmd_exit;
+
+	if (timeout_ms > 0)
+		INIT_COMPLETION(data->int_running);
+	retval = cyttsp4_write(ttsp, CY_MODE_BOOTLOADER,
+			       CY_REG_BASE, cmd_buf, cmd_size);
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: Fail writing command=%02X\n",
+			__func__, cmd_buf[CY_CMD_BYTE]);
+		goto _cyttsp4_send_cmd_exit;
+	}
+
+	if (timeout_ms > 0) {
+		memset(status_buf, 0, sizeof(data->status_buf));
+		retval = _cyttsp4_get_status(ttsp, status_buf,
+			status_size, timeout_ms);
+		if (retval < 0 || status_buf[0] != CY_START_OF_PACKET) {
+			dev_err(dev,
+				"%s: Error getting status r=%d"
+				" status_buf[0]=%02X\n",
+				__func__, retval, status_buf[0]);
+			if (!(retval < 0))
+				retval = -EIO;
+			goto _cyttsp4_send_cmd_exit;
+		} else {
+			if (status_buf[CY_STATUS_BYTE] != ERROR_SUCCESS) {
+				dev_err(dev,
+					"%s: Status=0x%02X error\n",
+					__func__, status_buf[CY_STATUS_BYTE]);
+				retval = -EIO;
+			} else if (stat_ret != NULL) {
+				if (num_stat_byte < status_size)
+					*stat_ret = status_buf[num_stat_byte];
+				else
+					*stat_ret = 0;
+			}
+		}
+	} else {
+		if (stat_ret != NULL)
+			*stat_ret = ERROR_SUCCESS;
+	}
+
+_cyttsp4_send_cmd_exit:
+	return retval;
+}
+
+static int _cyttsp4_ldr_enter(struct cyttsp4_device *ttsp,
+		struct cyttsp4_dev_id *dev_id)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+
+	u16 crc = 0;
+	int i = 0;
+	size_t cmd_size = 0;
+	u8 *status_buf = &data->status_buf[0];
+	u8 status = 0;
+	int retval;
+	/* +1 for TMA400 host sync byte */
+	u8 ldr_enter_cmd[CY_CMD_LDR_ENTER_CMD_SIZE+1];
+	memset(status_buf, 0, sizeof(data->status_buf));
+	dev_id->bl_ver = 0;
+	dev_id->rev_id = 0;
+	dev_id->silicon_id = 0;
+
+	ldr_enter_cmd[i++] = CY_CMD_LDR_HOST_SYNC;
+	ldr_enter_cmd[i++] = CY_START_OF_PACKET;
+	ldr_enter_cmd[i++] = CY_CMD_LDR_ENTER;
+	ldr_enter_cmd[i++] = 0x00;	/* data len lsb */
+	ldr_enter_cmd[i++] = 0x00;	/* data len msb */
+	crc = _cyttsp4_compute_crc(ttsp, &ldr_enter_cmd[1], i - 1);
+	cmd_size = sizeof(ldr_enter_cmd);
+	ldr_enter_cmd[i++] = (u8)crc;
+	ldr_enter_cmd[i++] = (u8)(crc >> 8);
+	ldr_enter_cmd[i++] = CY_END_OF_PACKET;
+
+	INIT_COMPLETION(data->int_running);
+
+	retval = cyttsp4_write(ttsp, CY_MODE_BOOTLOADER,
+		CY_REG_BASE, ldr_enter_cmd, cmd_size);
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: write block failed %d\n", __func__, retval);
+		return retval;
+	}
+	retval = _cyttsp4_get_status(ttsp, status_buf,
+		CY_CMD_LDR_ENTER_STAT_SIZE, CY_CMD_TIMEOUT);
+
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: Fail get status to Enter Loader command r=%d\n",
+			__func__, retval);
+		return retval;
+	}
+	status = status_buf[CY_STATUS_BYTE];
+	if (status == ERROR_SUCCESS) {
+		dev_id->bl_ver =
+			status_buf[11] << 16 |
+			status_buf[10] <<  8 |
+			status_buf[9] <<  0;
+		dev_id->rev_id =
+			status_buf[8] <<  0;
+		dev_id->silicon_id =
+			status_buf[7] << 24 |
+			status_buf[6] << 16 |
+			status_buf[5] <<  8 |
+			status_buf[4] <<  0;
+		retval = 0;
+	} else
+		retval = -EIO;
+	dev_vdbg(dev,
+		 "%s: status=%d "
+		 "bl_ver=%08X rev_id=%02X silicon_id=%08X\n",
+		 __func__, status,
+		 dev_id->bl_ver, dev_id->rev_id, dev_id->silicon_id);
+
+	return retval;
+}
+
+static int _cyttsp4_ldr_init(struct cyttsp4_device *ttsp)
+{
+	u16 crc;
+	int i = 0;
+	int retval = 0;
+	const u8 *cyttsp4_security_key;
+	int key_size;
+	/* +1 for TMA400 host sync byte */
+	u8 ldr_init_cmd[CY_CMD_LDR_INIT_CMD_SIZE+1];
+
+	cyttsp4_security_key = cyttsp4_get_security_key(ttsp, &key_size);
+
+	ldr_init_cmd[i++] = CY_CMD_LDR_HOST_SYNC;
+	ldr_init_cmd[i++] = CY_START_OF_PACKET;
+	ldr_init_cmd[i++] = CY_CMD_LDR_INIT;
+	ldr_init_cmd[i++] = 0x08;	/* data len lsb */
+	ldr_init_cmd[i++] = 0x00;	/* data len msb */
+	memcpy(&ldr_init_cmd[i], cyttsp4_security_key,
+			key_size);
+	i += key_size;
+	crc = _cyttsp4_compute_crc(ttsp, &ldr_init_cmd[1], i - 1);
+	ldr_init_cmd[i++] = (u8)crc;
+	ldr_init_cmd[i++] = (u8)(crc >> 8);
+	ldr_init_cmd[i++] = CY_END_OF_PACKET;
+
+	retval = _cyttsp4_send_cmd(ttsp, ldr_init_cmd, i, NULL, 0,
+				   CY_CMD_LDR_INIT_STAT_SIZE,
+				   CY_CMD_LDR_INIT_TIMEOUT);
+	if (retval < 0) {
+		dev_err(&ttsp->dev,
+			"%s: Fail ldr init r=%d\n",
+			__func__, retval);
+	}
+
+	return retval;
+}
+
+struct cyttsp4_hex_image {
+	u8 array_id;
+	u16 row_num;
+	u16 row_size;
+	u8 row_data[CY_DATA_ROW_SIZE];
+} __packed;
+
+static int _cyttsp4_ldr_parse_row(struct cyttsp4_device *ttsp, u8 *row_buf,
+	struct cyttsp4_hex_image *row_image)
+{
+	int retval = 0;
+
+	row_image->array_id = row_buf[CY_ARRAY_ID_OFFSET];
+	row_image->row_num = _cyttsp4_get_short(&row_buf[CY_ROW_NUM_OFFSET]);
+	row_image->row_size = _cyttsp4_get_short(&row_buf[CY_ROW_SIZE_OFFSET]);
+
+	if (row_image->row_size > ARRAY_SIZE(row_image->row_data)) {
+		dev_err(&ttsp->dev,
+			"%s: row data buffer overflow\n", __func__);
+		retval = -EOVERFLOW;
+		goto cyttsp4_ldr_parse_row_exit;
+	}
+
+	memcpy(row_image->row_data, &row_buf[CY_ROW_DATA_OFFSET],
+	       row_image->row_size);
+cyttsp4_ldr_parse_row_exit:
+	return retval;
+}
+
+static int _cyttsp4_ldr_prog_row(struct cyttsp4_device *ttsp,
+				 struct cyttsp4_hex_image *row_image)
+{
+	u16 crc;
+	int next;
+	int data;
+	int row_data;
+	u16 row_sum;
+	size_t data_len;
+	int retval = 0;
+
+	u8 *cmd = kzalloc(CY_MAX_PACKET_LEN, GFP_KERNEL);
+
+	if (cmd != NULL) {
+		row_data = 0;
+		row_sum = 0;
+		next = 0;
+		cmd[next++] = CY_CMD_LDR_HOST_SYNC;
+		cmd[next++] = CY_START_OF_PACKET;
+		cmd[next++] = CY_CMD_LDR_PROG_ROW;
+		/*
+		 * include array id size and row id size in CY_PACKET_DATA_LEN
+		 */
+		data_len = CY_DATA_ROW_SIZE_TMA400;
+		cmd[next++] = (u8)(data_len+3);
+		cmd[next++] = (u8)((data_len+3) >> 8);
+		cmd[next++] = row_image->array_id;
+		cmd[next++] = (u8)row_image->row_num;
+		cmd[next++] = (u8)(row_image->row_num >> 8);
+
+		for (data = 0;
+			data < data_len; data++) {
+			cmd[next] = row_image->row_data[row_data++];
+			row_sum += cmd[next];
+			next++;
+		}
+
+		crc = _cyttsp4_compute_crc(ttsp, &cmd[1], next - 1);
+		cmd[next++] = (u8)crc;
+		cmd[next++] = (u8)(crc >> 8);
+		cmd[next++] = CY_END_OF_PACKET;
+
+		retval = _cyttsp4_send_cmd(ttsp, cmd, next, NULL, 0,
+					   CY_CMD_LDR_PROG_ROW_STAT_SIZE,
+					   CY_CMD_TIMEOUT);
+
+		if (retval < 0) {
+			dev_err(&ttsp->dev,
+				"%s: prog row=%d fail r=%d\n",
+				__func__, row_image->row_num, retval);
+			goto cyttsp4_ldr_prog_row_exit;
+		}
+
+	} else {
+		dev_err(&ttsp->dev,
+			"%s prog row error - cmd buf is NULL\n", __func__);
+		retval = -EIO;
+	}
+
+cyttsp4_ldr_prog_row_exit:
+	kfree(cmd);
+	return retval;
+}
+
+static int _cyttsp4_ldr_verify_row(struct cyttsp4_device *ttsp,
+	struct cyttsp4_hex_image *row_image)
+{
+	u16 crc = 0;
+	int i = 0;
+	u8 verify_checksum;
+	int retval = 0;
+	/* +1 for TMA400 host sync byte */
+	u8 ldr_verify_row_cmd[CY_CMD_LDR_VERIFY_ROW_CMD_SIZE+1];
+
+	ldr_verify_row_cmd[i++] = CY_CMD_LDR_HOST_SYNC;
+	ldr_verify_row_cmd[i++] = CY_START_OF_PACKET;
+	ldr_verify_row_cmd[i++] = CY_CMD_LDR_VERIFY_ROW;
+	ldr_verify_row_cmd[i++] = 0x03;	/* data len lsb */
+	ldr_verify_row_cmd[i++] = 0x00;	/* data len msb */
+	ldr_verify_row_cmd[i++] = row_image->array_id;
+	ldr_verify_row_cmd[i++] = (u8)row_image->row_num;
+	ldr_verify_row_cmd[i++] = (u8)(row_image->row_num >> 8);
+	crc = _cyttsp4_compute_crc(ttsp, &ldr_verify_row_cmd[1], i - 1);
+	ldr_verify_row_cmd[i++] = (u8)crc;
+	ldr_verify_row_cmd[i++] = (u8)(crc >> 8);
+	ldr_verify_row_cmd[i++] = CY_END_OF_PACKET;
+
+	retval = _cyttsp4_send_cmd(ttsp, ldr_verify_row_cmd, i,
+				   &verify_checksum, 4,
+				   CY_CMD_LDR_VERIFY_ROW_STAT_SIZE,
+				   CY_CMD_TIMEOUT);
+
+	if (retval < 0) {
+		dev_err(&ttsp->dev,
+			"%s: verify row=%d fail r=%d\n",
+			__func__, row_image->row_num, retval);
+	}
+
+	return retval;
+}
+
+static int _cyttsp4_ldr_verify_chksum(struct cyttsp4_device *ttsp,
+	u8 *app_chksum)
+{
+	u16 crc = 0;
+	int i = 0;
+	int retval = 0;
+	/* +1 for TMA400 host sync byte */
+	u8 ldr_verify_chksum_cmd[CY_CMD_LDR_VERIFY_CHKSUM_CMD_SIZE+1];
+
+	ldr_verify_chksum_cmd[i++] = CY_CMD_LDR_HOST_SYNC;
+	ldr_verify_chksum_cmd[i++] = CY_START_OF_PACKET;
+	ldr_verify_chksum_cmd[i++] = CY_CMD_LDR_VERIFY_CHKSUM;
+	ldr_verify_chksum_cmd[i++] = 0x00;	/* data len lsb */
+	ldr_verify_chksum_cmd[i++] = 0x00;	/* data len msb */
+	crc = _cyttsp4_compute_crc(ttsp, &ldr_verify_chksum_cmd[1], i - 1);
+	ldr_verify_chksum_cmd[i++] = (u8)crc;
+	ldr_verify_chksum_cmd[i++] = (u8)(crc >> 8);
+	ldr_verify_chksum_cmd[i++] = CY_END_OF_PACKET;
+
+	retval = _cyttsp4_send_cmd(ttsp, ldr_verify_chksum_cmd, i,
+				   app_chksum, 4,
+				   CY_CMD_LDR_VERIFY_CHKSUM_STAT_SIZE,
+				   CY_CMD_TIMEOUT);
+
+	if (retval < 0) {
+		dev_err(&ttsp->dev,
+			"%s: verify checksum fail r=%d\n",
+			__func__, retval);
+	}
+
+	return retval;
+}
+
+/* Constructs loader exit command and sends via _cyttsp4_send_cmd() */
+static int _cyttsp4_ldr_exit(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	u16 crc = 0;
+	int i = 0;
+	int retval;
+	/* +1 for TMA400 host sync byte */
+	u8 ldr_exit_cmd[CY_CMD_LDR_EXIT_CMD_SIZE+1];
+
+	ldr_exit_cmd[i++] = CY_CMD_LDR_HOST_SYNC;
+	ldr_exit_cmd[i++] = CY_START_OF_PACKET;
+	ldr_exit_cmd[i++] = CY_CMD_LDR_EXIT;
+	ldr_exit_cmd[i++] = 0x00;	/* data len lsb */
+	ldr_exit_cmd[i++] = 0x00;	/* data len msb */
+	crc = _cyttsp4_compute_crc(ttsp, &ldr_exit_cmd[1], i - 1);
+	ldr_exit_cmd[i++] = (u8)crc;
+	ldr_exit_cmd[i++] = (u8)(crc >> 8);
+	ldr_exit_cmd[i++] = CY_END_OF_PACKET;
+
+	retval = _cyttsp4_send_cmd(ttsp, ldr_exit_cmd, i, NULL, 0,
+				   CY_CMD_LDR_EXIT_STAT_SIZE, 0);
+
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: BL Loader exit fail r=%d\n",
+			__func__, retval);
+	}
+
+	dev_vdbg(dev,
+		"%s: Exit BL Loader r=%d\n", __func__, retval);
+
+	return retval;
+}
+
+static int _cyttsp4_load_app(struct cyttsp4_device *ttsp, const u8 *fw,
+			     int fw_size)
+{
+	struct device *dev = &ttsp->dev;
+	u8 *p;
+	int ret;
+	int retval;	/* need separate return value at exit stage */
+	struct cyttsp4_dev_id *file_id = NULL;
+	struct cyttsp4_dev_id *dev_id = NULL;
+	struct cyttsp4_hex_image *row_image = NULL;
+	u8 app_chksum;
+
+	u8 *row_buf = NULL;
+	/* Prevent loading if TMA ver not defined. */
+	size_t image_rec_size = fw_size + 1;
+	size_t row_buf_size = 1024 > CY_MAX_PRBUF_SIZE ?
+		1024 : CY_MAX_PRBUF_SIZE;
+	int row_count = 0;
+
+	image_rec_size = CY_DATA_ROW_SIZE_TMA400 +
+		(sizeof(struct cyttsp4_hex_image) - CY_DATA_ROW_SIZE);
+	if (fw_size % image_rec_size != 0) {
+		dev_err(dev,
+			"%s: Firmware image is misaligned\n", __func__);
+		retval = -EINVAL;
+		goto _cyttsp4_load_app_exit;
+	}
+
+	dev_dbg(dev, "%s: start load app\n", __func__);
+    upgrade_flag++;
+
+	row_buf = kzalloc(row_buf_size, GFP_KERNEL);
+	row_image = kzalloc(sizeof(struct cyttsp4_hex_image), GFP_KERNEL);
+	file_id = kzalloc(sizeof(struct cyttsp4_dev_id), GFP_KERNEL);
+	dev_id = kzalloc(sizeof(struct cyttsp4_dev_id), GFP_KERNEL);
+	if (row_buf == NULL || row_image == NULL ||
+	    file_id == NULL || dev_id == NULL) {
+		dev_err(dev,
+			"%s: Unable to alloc row buffers(%p %p %p %p)\n",
+			__func__, row_buf, row_image, file_id, dev_id);
+		retval = -ENOMEM;
+		goto _cyttsp4_load_app_exit;
+	}
+
+	cyttsp4_request_stop_wd(ttsp);
+
+	p = (u8 *)fw;
+	/* Enter Loader and return Silicon ID and Rev */
+
+	retval = cyttsp4_request_reset(ttsp);
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: Fail reset device r=%d\n", __func__, retval);
+		goto _cyttsp4_load_app_exit;
+	}
+
+	dev_dbg(dev, "%s: Send BL Loader Enter\n", __func__);
+
+	retval = _cyttsp4_ldr_enter(ttsp, dev_id);
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: Error cannot start Loader (ret=%d)\n",
+			__func__, retval);
+		goto _cyttsp4_load_app_exit;
+	}
+
+	dev_vdbg(dev,
+		"%s: dev: silicon id=%08X rev=%02X bl=%08X\n",
+		__func__, dev_id->silicon_id,
+		dev_id->rev_id, dev_id->bl_ver);
+
+	udelay(1000);
+	retval = _cyttsp4_ldr_init(ttsp);
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: Error cannot init Loader (ret=%d)\n",
+			__func__, retval);
+		goto _cyttsp4_load_app_exit;
+	}
+
+	dev_dbg(dev, "%s: Send BL Loader Blocks\n", __func__);
+
+	while (p < (fw + fw_size)) {
+		/* Get row */
+		dev_dbg(dev,
+			"%s: read row=%d\n", __func__, ++row_count);
+		memset(row_buf, 0, row_buf_size);
+		p = _cyttsp4_get_row(ttsp, row_buf, p, image_rec_size);
+
+		/* Parse row */
+		dev_dbg(dev,
+			"%s: p=%p buf=%p buf[0]=%02X\n", __func__,
+			p, row_buf, row_buf[0]);
+		retval = _cyttsp4_ldr_parse_row(ttsp, row_buf, row_image);
+		dev_dbg(dev,
+			"%s: array_id=%02X row_num=%04X(%d)"
+				" row_size=%04X(%d)\n", __func__,
+			row_image->array_id,
+			row_image->row_num, row_image->row_num,
+			row_image->row_size, row_image->row_size);
+		if (retval < 0) {
+			dev_err(dev,
+			"%s: Parse Row Error "
+				"(a=%d r=%d ret=%d\n",
+				__func__, row_image->array_id,
+				row_image->row_num,
+				retval);
+			goto bl_exit;
+		} else {
+			dev_vdbg(dev,
+				"%s: Parse Row "
+				"(a=%d r=%d ret=%d\n",
+				__func__, row_image->array_id,
+				row_image->row_num, retval);
+		}
+
+		/* program row */
+		retval = _cyttsp4_ldr_prog_row(ttsp, row_image);
+		if (retval < 0) {
+			dev_err(dev,
+			"%s: Program Row Error "
+				"(array=%d row=%d ret=%d)\n",
+				__func__, row_image->array_id,
+				row_image->row_num, retval);
+			goto _cyttsp4_load_app_exit;
+		}
+
+		/* verify row */
+		retval = _cyttsp4_ldr_verify_row(ttsp, row_image);
+		if (retval < 0) {
+			dev_err(dev,
+			"%s: Verify Row Error "
+				"(array=%d row=%d ret=%d)\n",
+				__func__, row_image->array_id,
+				row_image->row_num, retval);
+			goto _cyttsp4_load_app_exit;
+		}
+
+		dev_vdbg(dev,
+			"%s: array=%d row_cnt=%d row_num=%04X\n",
+			__func__, row_image->array_id, row_count,
+			row_image->row_num);
+	}
+
+	/* verify app checksum */
+	retval = _cyttsp4_ldr_verify_chksum(ttsp, &app_chksum);
+	dev_dbg(dev,
+		"%s: Application Checksum = %02X r=%d\n",
+		__func__, app_chksum, retval);
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: ldr_verify_chksum fail r=%d\n", __func__, retval);
+		retval = 0;
+	}
+
+    dev_info(dev, "%s: Load firmware success.\n", __func__);
+
+	/* exit loader */
+bl_exit:
+	dev_dbg(dev,
+			"%s: Send BL Loader Terminate\n", __func__);
+	ret = _cyttsp4_ldr_exit(ttsp);
+	if (ret) {
+		dev_err(dev,
+			"%s: Error on exit Loader (ret=%d)\n",
+			__func__, ret);
+		retval = ret;
+	}
+
+_cyttsp4_load_app_exit:
+	kfree(row_buf);
+	kfree(row_image);
+	kfree(file_id);
+	kfree(dev_id);
+	return retval;
+}
+
+static void cyttsp4_fw_calibrate(struct work_struct *calibration_work)
+{
+	struct cyttsp4_loader_data *data = container_of(calibration_work,
+			struct cyttsp4_loader_data, calibration_work);
+	struct cyttsp4_device *ttsp = data->ttsp;
+	struct device *dev = &ttsp->dev;
+	u8 cmd_buf[CY_CMD_CAT_CALIBRATE_IDAC_CMD_SZ];
+	u8 return_buf[CY_CMD_CAT_CALIBRATE_IDAC_RET_SZ];
+	int rc;
+	g_cali_result = cyttsp4_calibration_failed;
+	dev_info(dev, "%s calibration Start\n", __func__);
+
+	pm_runtime_get_sync(dev);
+
+	dev_vdbg(dev, "%s: Requesting exclusive\n", __func__);
+	rc = cyttsp4_request_exclusive(ttsp, CY_LDR_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto exit;
+	}
+
+	dev_vdbg(dev, "%s: Requesting mode change to CAT\n", __func__);
+	rc = cyttsp4_request_set_mode(ttsp, CY_MODE_CAT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc);
+		goto exit_release;
+	}
+
+	cmd_buf[0] = CY_CMD_CAT_CALIBRATE_IDACS;
+	cmd_buf[1] = 0x00; /* Mutual Capacitance Screen */
+	rc = cyttsp4_request_exec_cmd(ttsp, CY_MODE_CAT,
+			cmd_buf, CY_CMD_CAT_CALIBRATE_IDAC_CMD_SZ,
+			return_buf, CY_CMD_CAT_CALIBRATE_IDAC_RET_SZ,
+			CY_CALIBRATE_COMPLETE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Unable to execute calibrate command.\n",
+			__func__);
+		goto exit_setmode;
+	}
+	if (return_buf[0] != CY_CMD_STATUS_SUCCESS) {
+		dev_err(dev, "%s: calibrate command unsuccessful\n", __func__);
+		goto exit_setmode;
+	}
+
+	cmd_buf[1] = 0x01; /* Mutual Capacitance Button */
+	rc = cyttsp4_request_exec_cmd(ttsp, CY_MODE_CAT,
+			cmd_buf, CY_CMD_CAT_CALIBRATE_IDAC_CMD_SZ,
+			return_buf, CY_CMD_CAT_CALIBRATE_IDAC_RET_SZ,
+			CY_CALIBRATE_COMPLETE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Unable to execute calibrate command.\n",
+			__func__);
+		goto exit_setmode;
+	}
+	if (return_buf[0] != CY_CMD_STATUS_SUCCESS) {
+		dev_err(dev, "%s: calibrate command unsuccessful\n", __func__);
+		goto exit_setmode;
+	}
+
+	cmd_buf[1] = 0x02; /* Self Capacitance */
+	rc = cyttsp4_request_exec_cmd(ttsp, CY_MODE_CAT,
+			cmd_buf, CY_CMD_CAT_CALIBRATE_IDAC_CMD_SZ,
+			return_buf, CY_CMD_CAT_CALIBRATE_IDAC_RET_SZ,
+			CY_CALIBRATE_COMPLETE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Unable to execute calibrate command.\n",
+			__func__);
+		goto exit_setmode;
+	}
+	if (return_buf[0] != CY_CMD_STATUS_SUCCESS) {
+		dev_err(dev, "%s: calibrate command unsuccessful\n", __func__);
+		goto exit_setmode;
+	}
+	g_cali_result = cyttsp4_calibration_success;
+exit_setmode:
+	rc = cyttsp4_request_set_mode(ttsp, CY_MODE_OPERATIONAL);
+	if (rc < 0)
+		dev_err(dev, "%s: Error on request set mode 2 r=%d\n",
+				__func__, rc);
+
+exit_release:
+	rc = cyttsp4_release_exclusive(ttsp);
+	if (rc < 0)
+		dev_err(dev, "%s: Error on release exclusive r=%d\n",
+				__func__, rc);
+
+exit:
+	pm_runtime_put(dev);
+	if (g_cali_result == cyttsp4_calibration_success) {        
+		dev_info(dev, "%s calibration success. End\n", __func__);
+	}else {
+		g_cali_result = cyttsp4_calibration_failed;
+		dev_info(dev, "%s calibration failed\n", __func__);
+	}
+	complete(&data->cyttsp_cali_complete);
+}
+
+static int cyttsp4_fw_calibration_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	int rc = 0;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	schedule_work(&data->calibration_work);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_fw_calibration_attention, CY_MODE_OPERATIONAL);
+
+	return rc;
+}
+
+static int cyttsp4_upgrade_firmware(struct cyttsp4_device *ttsp,
+		const u8 *fw_img, int fw_size)
+{
+	struct device *dev = &ttsp->dev;
+	//struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	int rc;
+
+	pm_runtime_get_sync(dev);
+
+	rc = cyttsp4_request_exclusive(ttsp, CY_LDR_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0)
+		goto exit;
+
+	rc = _cyttsp4_load_app(ttsp, fw_img, fw_size);
+	if (rc < 0) {
+		dev_err(dev, "%s: Firmware update failed with error code %d\n",
+			__func__, rc);
+	} //else if (data->loader_pdata &&
+	  //  	(data->loader_pdata->flags &
+	  //		CY_LOADER_FLAG_CALIBRATE_AFTER_FW_UPGRADE)) {
+	else {
+		/* set up call back for startup */
+		dev_vdbg(dev, "%s: Adding callback for calibration\n",
+			__func__);
+		rc = cyttsp4_subscribe_attention(ttsp, CY_ATTEN_IRQ,
+				cyttsp4_fw_calibration_attention, CY_MODE_OPERATIONAL);
+		if (rc) {
+			dev_err(dev, "%s: Failed adding callback for calibration\n",
+				__func__);
+			dev_err(dev, "%s: No calibration will be performed\n",
+				__func__);
+			rc = 0;
+		}
+	}
+
+	cyttsp4_release_exclusive(ttsp);
+	cyttsp4_request_restart(ttsp, false);
+
+exit:
+	pm_runtime_put(dev);
+	return rc;
+}
+
+static int cyttsp4_loader_attention(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_loader_data *data = dev_get_drvdata(&ttsp->dev);
+	complete(&data->int_running);
+	return 0;
+}
+#endif /* CYTTSP4_FW_UPGRADE */
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+static int cyttsp4_check_firmware_version_platform(struct cyttsp4_device *ttsp,
+		struct cyttsp4_touch_firmware *fw)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	u32 fw_ver_new;
+	u32 fw_revctrl_new_h;
+	u32 fw_revctrl_new_l;
+	int upgrade;
+
+	if (!data->si) {
+		dev_info(dev, "%s: No firmware infomation found, device FW may be corrupted\n",
+			__func__);
+		return CYTTSP4_AUTO_LOAD_FOR_CORRUPTED_FW;
+	}
+
+	fw_ver_new = get_unaligned_be16(fw->ver + 2);
+	fw_revctrl_new_h = get_unaligned_be32(fw->ver + 4);
+	fw_revctrl_new_l = get_unaligned_be32(fw->ver + 8);
+
+	upgrade = cyttsp4_check_firmware_version(ttsp, fw_ver_new,
+			fw_revctrl_new_h, fw_revctrl_new_l);
+
+	if (upgrade > 0)
+		return 1;
+
+	return 0;
+}
+
+static int upgrade_firmware_from_platform(struct cyttsp4_device *ttsp,
+		bool forced)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	struct cyttsp4_touch_firmware *fw;
+	int rc = -ENOSYS;
+	int upgrade;
+
+	if (data->loader_pdata == NULL) {
+		dev_err(dev, "%s: No loader platform data\n", __func__);
+		return rc;
+	}
+
+	fw = data->loader_pdata->fw;
+	if (fw == NULL || fw->img == NULL || fw->size == 0) {
+		dev_err(dev, "%s: No platform firmware\n", __func__);
+		return rc;
+	}
+
+	if (fw->ver == NULL || fw->vsize == 0) {
+		dev_err(dev, "%s: No platform firmware version\n",
+			__func__);
+		return rc;
+	}
+
+	if (forced)
+		upgrade = forced;
+	else
+		upgrade = cyttsp4_check_firmware_version_platform(ttsp, fw);
+
+	if (upgrade)
+		return cyttsp4_upgrade_firmware(ttsp, fw->img, fw->size);
+
+	return rc;
+}
+#endif /* CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE */
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+static void _cyttsp4_firmware_cont(const struct firmware *fw, void *context)
+{
+	struct cyttsp4_device *ttsp = context;
+	struct device *dev = &ttsp->dev;
+	u8 header_size = 0;
+
+	if (fw == NULL)
+		goto cyttsp4_firmware_cont_exit;
+
+	if (fw->data == NULL || fw->size == 0) {
+		dev_err(dev,
+			"%s: No firmware received\n", __func__);
+		goto cyttsp4_firmware_cont_release_exit;
+	}
+
+	header_size = fw->data[0];
+	if (header_size >= (fw->size + 1)) {
+		dev_err(dev,
+			"%s: Firmware format is invalid\n", __func__);
+		goto cyttsp4_firmware_cont_release_exit;
+	}
+
+	cyttsp4_upgrade_firmware(ttsp, &(fw->data[header_size + 1]),
+		fw->size - (header_size + 1));
+
+cyttsp4_firmware_cont_release_exit:
+	release_firmware(fw);
+
+cyttsp4_firmware_cont_exit:
+	return;
+}
+
+#if 0
+static int cyttsp4_check_firmware_version_builtin(struct cyttsp4_device *ttsp,
+		const struct firmware *fw)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	u32 fw_ver_new;
+	u32 fw_revctrl_new_h;
+	u32 fw_revctrl_new_l;
+	int upgrade;
+
+	if (!data->si) {
+		dev_info(dev, "%s: No firmware infomation found, device FW may be corrupted\n",
+			__func__);
+		return CYTTSP4_AUTO_LOAD_FOR_CORRUPTED_FW;
+	}
+
+	fw_ver_new = get_unaligned_be16(fw->data + 3);
+	fw_revctrl_new_h = get_unaligned_be32(fw->data + 5);
+	fw_revctrl_new_l = get_unaligned_be32(fw->data + 9);
+
+	upgrade = cyttsp4_check_firmware_version(ttsp, fw_ver_new,
+			fw_revctrl_new_h, fw_revctrl_new_l);
+
+	if (upgrade > 0)
+		return 1;
+
+	return 0;
+}
+#else
+/* ZTEMT Added by luochangyang, 2013/05/28 */
+static int ztemt_cyttsp4_check_firmware_version_builtin(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+    
+	if (data == NULL) {
+		dev_err(dev, "%s: NULL data received\n", __func__);
+		return 0;
+	}
+	
+    if (!data->si) {
+        dev_info(dev, "%s: No firmware infomation found, device FW may be corrupted\n",
+            __func__);
+        return CYTTSP4_AUTO_LOAD_FOR_CORRUPTED_FW;
+    }
+    
+    if (data->si->update_flag == 0) {//equal
+		dev_dbg(dev, "%s: FW Image is equal, will NOT upgrade\n", __func__);
+		return 0;
+    }
+	else if (data->si->update_flag > 0) {//fw is old, need to upgrade
+		dev_info(dev,"%s update_flag = %d, will upgrade\n",__func__,data->si->update_flag);
+		return 1;
+	}
+	else {//fw is newer, no need to upgrade
+		dev_info(dev,"%s update_flag = %d, will NOT upgrade\n",__func__,data->si->update_flag);
+		return 0;
+	}
+}
+/* ZTEMT END */
+#endif
+
+static void _cyttsp4_firmware_cont_builtin(const struct firmware *fw,
+		void *context)
+{
+	struct cyttsp4_device *ttsp = context;
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	int upgrade;
+
+	if (fw == NULL) {
+		dev_info(dev, "%s: No builtin firmware\n", __func__);
+		goto _cyttsp4_firmware_cont_builtin_exit;
+	}
+
+	if (fw->data == NULL || fw->size == 0) {
+		dev_err(dev, "%s: Invalid builtin firmware\n", __func__);
+		goto _cyttsp4_firmware_cont_builtin_exit;
+	}
+
+	dev_dbg(dev, "%s: Found firmware\n", __func__);
+
+    /* ZTEMT Modify by luochangyang, 2013/05/28 */
+	//upgrade = cyttsp4_check_firmware_version_builtin(ttsp, fw);
+    upgrade = ztemt_cyttsp4_check_firmware_version_builtin(ttsp);
+    /* ZTEMT END */
+	if (upgrade) {
+		_cyttsp4_firmware_cont(fw, ttsp);
+		data->builtin_bin_fw_status = 0;
+		complete(&data->builtin_bin_fw_complete);
+		return;
+	}
+
+_cyttsp4_firmware_cont_builtin_exit:
+	release_firmware(fw);
+
+	data->builtin_bin_fw_status = -EINVAL;
+	complete(&data->builtin_bin_fw_complete);
+}
+
+static int upgrade_firmware_from_class(struct cyttsp4_device *ttsp)
+{
+	int retval;
+
+	dev_vdbg(&ttsp->dev, "%s: Enabling firmware class loader\n", __func__);
+
+	retval = request_firmware_nowait(THIS_MODULE, FW_ACTION_NOHOTPLUG, "",
+			&ttsp->dev, GFP_KERNEL, ttsp, _cyttsp4_firmware_cont);
+	if (retval < 0) {
+		dev_err(&ttsp->dev, "%s: Fail request firmware class file load\n",
+			__func__);
+		return retval;
+	}
+
+	return 0;
+}
+
+static int upgrade_firmware_from_builtin(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	int retval;
+
+	dev_vdbg(dev, "%s: Enabling firmware class loader built-in\n",
+		__func__);
+
+	retval = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
+			CY_FW_FILE_NAME, dev, GFP_KERNEL, ttsp,
+			_cyttsp4_firmware_cont_builtin);
+	if (retval < 0) {
+		dev_err(dev, "%s: Fail request firmware class file load\n",
+			__func__);
+		return retval;
+	}
+
+	/* wait until FW binary upgrade finishes */
+	wait_for_completion(&data->builtin_bin_fw_complete);
+
+	return data->builtin_bin_fw_status;
+}
+#endif /* CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE */
+
+#if CYTTSP4_TTCONFIG_UPGRADE
+static int cyttsp4_upgrade_ttconfig(struct cyttsp4_device *ttsp,
+		const u8 *ttconfig_data, int ttconfig_size)
+{
+	struct device *dev = &ttsp->dev;
+	int rc, rc2;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	pm_runtime_get_sync(dev);
+
+	dev_vdbg(dev, "%s: Requesting exclusive\n", __func__);
+	rc = cyttsp4_request_exclusive(ttsp, CY_LDR_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto exit;
+	}
+
+	dev_vdbg(dev, "%s: Requesting mode change to CAT\n", __func__);
+	rc = cyttsp4_request_set_mode(ttsp, CY_MODE_CAT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc);
+		goto exit_release;
+	}
+
+	rc = cyttsp4_request_write_config(ttsp, CY_TCH_PARM_EBID,
+			0, (u8 *)ttconfig_data, ttconfig_size);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request write config r=%d\n",
+				__func__, rc);
+		goto exit_setmode;
+	}
+
+exit_setmode:
+	rc2 = cyttsp4_request_set_mode(ttsp, CY_MODE_OPERATIONAL);
+	if (rc2 < 0)
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc2);
+
+exit_release:
+	rc2 = cyttsp4_release_exclusive(ttsp);
+	if (rc < 0)
+		dev_err(dev, "%s: Error on release exclusive r=%d\n",
+				__func__, rc2);
+
+exit:
+	if (!rc)
+		cyttsp4_request_restart(ttsp, true);
+
+	pm_runtime_put(dev);
+
+	return rc;
+}
+#endif /* CYTTSP4_TTCONFIG_UPGRADE */
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_TTCONFIG_UPGRADE
+static int cyttsp4_get_ttconfig_crc(struct cyttsp4_device *ttsp,
+		const u8 *ttconfig_data, int ttconfig_size, u16 *crc)
+{
+	u16 crc_loc;
+
+	crc_loc = get_unaligned_le16(&ttconfig_data[2]);
+	if (ttconfig_size < crc_loc + 2)
+		return -EINVAL;
+
+	*crc = get_unaligned_le16(&ttconfig_data[crc_loc]);
+
+	return 0;
+}
+
+static int cyttsp4_get_ttconfig_version(struct cyttsp4_device *ttsp,
+		const u8 *ttconfig_data, int ttconfig_size, u16 *version)
+{
+	if (ttconfig_size < CY_TTCONFIG_VERSION_OFFSET
+			+ CY_TTCONFIG_VERSION_SIZE)
+		return -EINVAL;
+
+	*version = get_unaligned_le16(
+		&ttconfig_data[CY_TTCONFIG_VERSION_OFFSET]);
+
+	return 0;
+}
+
+static int cyttsp4_check_ttconfig_version(struct cyttsp4_device *ttsp,
+		const u8 *ttconfig_data, int ttconfig_size)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	int rc;
+
+	if (!data->si)
+		return 0;
+
+	/* Check if device POST config CRC test failed */
+	if (!(data->si->si_ptrs.test->post_codel &
+			CY_POST_CODEL_CFG_DATA_CRC_FAIL)) {
+		dev_info(dev, "%s: Config CRC invalid, will upgrade\n",
+			__func__);
+		return 1;
+	}
+
+	/* Check for config version */
+	if (data->loader_pdata->flags &
+			CY_LOADER_FLAG_CHECK_TTCONFIG_VERSION) {
+		u16 cfg_ver_new;
+
+		rc = cyttsp4_get_ttconfig_version(ttsp, ttconfig_data,
+				ttconfig_size, &cfg_ver_new);
+		if (rc)
+			return 0;
+
+		dev_dbg(dev, "%s: img_ver:0x%04X new_ver:0x%04X\n",
+			__func__, data->si->ttconfig.version, cfg_ver_new);
+
+		/* Check if config version is newer */
+		if (cfg_ver_new > data->si->ttconfig.version) {
+			dev_dbg(dev, "%s: Config version newer, will upgrade\n",
+				__func__);
+			return 1;
+		}
+
+		dev_dbg(dev, "%s: Config version is identical or older, will NOT upgrade\n",
+			__func__);
+	/* Check for config CRC */
+	} else {
+		u16 cfg_crc_new;
+
+		rc = cyttsp4_get_ttconfig_crc(ttsp, ttconfig_data,
+				ttconfig_size, &cfg_crc_new);
+		if (rc)
+			return 0;
+
+		dev_dbg(dev, "%s: img_crc:0x%04X new_crc:0x%04X\n",
+			__func__, data->si->ttconfig.crc, cfg_crc_new);
+
+		/* Check if config CRC different. */
+		if (cfg_crc_new != data->si->ttconfig.crc) {
+			dev_dbg(dev, "%s: Config CRC different, will upgrade\n",
+				__func__);
+			return 1;
+		}
+
+		dev_dbg(dev, "%s: Config CRC equal, will NOT upgrade\n",
+			__func__);
+	}
+
+	return 0;
+}
+
+static int cyttsp4_check_ttconfig_version_platform(struct cyttsp4_device *ttsp,
+		struct cyttsp4_touch_config *ttconfig)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	u32 fw_ver_config;
+	u32 fw_revctrl_config_h;
+	u32 fw_revctrl_config_l;
+
+	if (!data->si) {
+		dev_info(dev, "%s: No firmware infomation found, device FW may be corrupted\n",
+			__func__);
+		return 0;
+	}
+
+	fw_ver_config = get_unaligned_be16(ttconfig->fw_ver + 2);
+	fw_revctrl_config_h = get_unaligned_be32(ttconfig->fw_ver + 4);
+	fw_revctrl_config_l = get_unaligned_be32(ttconfig->fw_ver + 8);
+
+	/* FW versions should match */
+	if (cyttsp4_check_firmware_version(ttsp, fw_ver_config,
+			fw_revctrl_config_h, fw_revctrl_config_l)) {
+		dev_err(dev, "%s: FW versions mismatch\n", __func__);
+		return 0;
+	}
+
+	return cyttsp4_check_ttconfig_version(ttsp, ttconfig->param_regs->data,
+			ttconfig->param_regs->size);
+}
+
+static int upgrade_ttconfig_from_platform(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	struct cyttsp4_touch_config *ttconfig;
+	struct touch_settings *param_regs;
+	struct cyttsp4_touch_fw;
+	int rc = -ENOSYS;
+	int upgrade;
+
+	if (data->loader_pdata == NULL) {
+		dev_info(dev, "%s: No loader platform data\n", __func__);
+		return rc;
+	}
+
+	ttconfig = data->loader_pdata->ttconfig;
+	if (ttconfig == NULL) {
+		dev_info(dev, "%s: No ttconfig data\n", __func__);
+		return rc;
+	}
+
+	param_regs = ttconfig->param_regs;
+	if (param_regs == NULL) {
+		dev_info(dev, "%s: No touch parameters\n", __func__);
+		return rc;
+	}
+
+	if (param_regs->data == NULL || param_regs->size == 0) {
+		dev_info(dev, "%s: Invalid touch parameters\n", __func__);
+		return rc;
+	}
+
+	if (ttconfig->fw_ver == NULL || ttconfig->fw_vsize == 0) {
+		dev_info(dev, "%s: Invalid FW version for touch parameters\n",
+			__func__);
+		return rc;
+	}
+
+	upgrade = cyttsp4_check_ttconfig_version_platform(ttsp, ttconfig);
+	if (upgrade)
+		return cyttsp4_upgrade_ttconfig(ttsp, param_regs->data,
+				param_regs->size);
+
+	return rc;
+}
+#endif /* CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_TTCONFIG_UPGRADE */
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE
+static ssize_t cyttsp4_config_data_write(struct file *filp,
+		struct kobject *kobj, struct bin_attribute *bin_attr,
+		char *buf, loff_t offset, size_t count)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	u8 *p;
+
+	dev_vdbg(dev, "%s: offset:%lld count:%d\n", __func__, offset, count);
+
+	mutex_lock(&data->config_lock);
+
+	if (!data->config_loading) {
+		mutex_unlock(&data->config_lock);
+		return -ENODEV;
+	}
+
+	p = krealloc(data->config_data, offset + count, GFP_KERNEL);
+	if (!p) {
+		kfree(data->config_data);
+		data->config_data = NULL;
+		data->config_size = 0;
+		data->config_loading = false;
+		mutex_unlock(&data->config_lock);
+		return -ENOMEM;
+	}
+	data->config_data = p;
+
+	memcpy(&data->config_data[offset], buf, count);
+	data->config_size += count;
+
+	mutex_unlock(&data->config_lock);
+
+	return count;
+}
+
+static struct bin_attribute bin_attr_config_data = {
+	.attr = {
+		.name = "config_data",
+		.mode = S_IWUSR,
+	},
+	.size = 0,
+	.write = cyttsp4_config_data_write,
+};
+
+static ssize_t cyttsp4_config_loading_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	bool config_loading;
+
+	mutex_lock(&data->config_lock);
+	config_loading = data->config_loading;
+	mutex_unlock(&data->config_lock);
+
+	return sprintf(buf, "%d\n", config_loading);
+}
+
+static int cyttsp4_verify_ttconfig_binary(struct cyttsp4_device *ttsp,
+		u8 *bin_config_data, int bin_config_size, u8 **start, int *len)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	int header_size;
+	u16 config_size;
+	u16 max_config_size;
+	u32 fw_ver_config;
+	u32 fw_revctrl_config_h;
+	u32 fw_revctrl_config_l;
+
+	if (!data->si) {
+		dev_err(dev, "%s: No firmware infomation found, device FW may be corrupted\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	/*
+	 * We need 11 bytes for FW version control info and at
+	 * least 6 bytes in config (Length + Max Length + CRC)
+	 */
+	header_size = bin_config_data[0] + 1;
+	if (header_size < 11 || header_size >= bin_config_size - 6) {
+		dev_err(dev, "%s: Invalid header size %d\n", __func__,
+			header_size);
+		return -EINVAL;
+	}
+
+	fw_ver_config = get_unaligned_be16(&bin_config_data[1]);
+	fw_revctrl_config_h = get_unaligned_be32(&bin_config_data[3]);
+	fw_revctrl_config_l = get_unaligned_be32(&bin_config_data[7]);
+
+	/* FW versions should match */
+	if (cyttsp4_check_firmware_version(ttsp, fw_ver_config,
+			fw_revctrl_config_h, fw_revctrl_config_l)) {
+		dev_err(dev, "%s: FW versions mismatch\n", __func__);
+		return -EINVAL;
+	}
+
+	config_size = get_unaligned_le16(&bin_config_data[header_size]);
+	max_config_size =
+		get_unaligned_le16(&bin_config_data[header_size + 2]);
+	/* Perform a simple size check (2 bytes for CRC) */
+	if (config_size != bin_config_size - header_size - 2) {
+		dev_err(dev, "%s: Config size invalid\n", __func__);
+		return -EINVAL;
+	}
+	/* Perform a size check against device config length */
+	if (config_size != data->si->ttconfig.length
+			|| max_config_size != data->si->ttconfig.max_length) {
+		dev_err(dev, "%s: Config size mismatch\n", __func__);
+		return -EINVAL;
+	}
+
+	*start = &bin_config_data[header_size];
+	*len = bin_config_size - header_size;
+
+	return 0;
+}
+
+/*
+ * 1: Start loading TT Config
+ * 0: End loading TT Config and perform upgrade
+ *-1: Exit loading
+ */
+static ssize_t cyttsp4_config_loading_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	long value;
+	u8 *start;
+	int length;
+	int rc;
+
+	rc = kstrtol(buf, 10, &value);
+	if (rc < 0 || value < -1 || value > 1) {
+		dev_err(dev, "%s: Invalid value\n", __func__);
+		return size;
+	}
+
+	mutex_lock(&data->config_lock);
+
+	if (value == 1)
+		data->config_loading = true;
+	else if (value == -1)
+		data->config_loading = false;
+	else if (value == 0 && data->config_loading) {
+		data->config_loading = false;
+		if (data->config_size == 0) {
+			dev_err(dev, "%s: No config data\n", __func__);
+			goto exit_free;
+		}
+
+		rc = cyttsp4_verify_ttconfig_binary(data->ttsp,
+				data->config_data, data->config_size,
+				&start, &length);
+		if (rc)
+			goto exit_free;
+
+		rc = cyttsp4_upgrade_ttconfig(data->ttsp, start, length);
+	}
+
+exit_free:
+	kfree(data->config_data);
+	data->config_data = NULL;
+	data->config_size = 0;
+
+	mutex_unlock(&data->config_lock);
+
+	if (rc)
+		return rc;
+
+	return size;
+}
+
+static DEVICE_ATTR(config_loading, S_IRUSR | S_IWUSR,
+	cyttsp4_config_loading_show, cyttsp4_config_loading_store);
+#endif /* CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE */
+
+static void cyttsp4_fw_and_config_upgrade(
+		struct work_struct *fw_and_config_upgrade)
+{
+	struct cyttsp4_loader_data *data = container_of(fw_and_config_upgrade,
+			struct cyttsp4_loader_data, fw_and_config_upgrade);
+	struct cyttsp4_device *ttsp = data->ttsp;
+	struct device *dev = &ttsp->dev;
+
+	data->si = cyttsp4_request_sysinfo(ttsp);
+	if (data->si == NULL)
+		dev_err(dev, "%s: Fail get sysinfo pointer from core\n",
+			__func__);
+
+#if !CYTTSP4_FW_UPGRADE
+	dev_info(dev, "%s: No FW upgrade method selected!\n", __func__);
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+	if (!upgrade_firmware_from_platform(ttsp, false))
+		return;
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+	if (!upgrade_firmware_from_builtin(ttsp))
+		return;
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_TTCONFIG_UPGRADE
+	if (!upgrade_ttconfig_from_platform(ttsp))
+		return;
+#endif
+}
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+static ssize_t cyttsp4_forced_upgrade_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int rc;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	rc = upgrade_firmware_from_platform(data->ttsp, true);
+	if (rc)
+		return rc;
+	return size;
+}
+
+static DEVICE_ATTR(forced_upgrade, S_IRUSR | S_IWUSR,
+	NULL, cyttsp4_forced_upgrade_store);
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+static ssize_t cyttsp4_manual_upgrade_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	upgrade_firmware_from_class(data->ttsp);
+	return size;
+}
+
+static DEVICE_ATTR(manual_upgrade, S_IRUSR | S_IWUSR,
+	NULL, cyttsp4_manual_upgrade_store);
+#endif
+
+static ssize_t cyttsp4_fw_upgrade_flag_show(struct device *dev, struct device_attribute *attr, char *buf)
+{	
+	return snprintf(buf, PAGE_SIZE,"%d\n",upgrade_flag);
+}
+static DEVICE_ATTR(fw_upgrade_flag, 0664, cyttsp4_fw_upgrade_flag_show, NULL);
+
+static ssize_t cyttsp4_manual_cali_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	INIT_COMPLETION(data->cyttsp_cali_complete);
+	g_cali_result = cyttsp4_calibration_failed;
+	schedule_work(&data->calibration_work);
+	wait_for_completion_timeout(&data->cyttsp_cali_complete, msecs_to_jiffies(7000));
+	return snprintf(buf, PAGE_SIZE,"%d\n",g_cali_result);
+}
+
+static ssize_t cyttsp4_manual_cali_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	schedule_work(&data->calibration_work);
+	return size;
+}
+
+static DEVICE_ATTR(manual_cali, 0664, cyttsp4_manual_cali_show, cyttsp4_manual_cali_store);
+
+static int cyttsp4_loader_probe(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_loader_data *data;
+	struct device *dev = &ttsp->dev;
+	int rc;
+
+	dev_dbg(dev, "%s\n", __func__);
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (data == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto error_alloc_data_failed;
+	}
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+	rc = device_create_file(dev, &dev_attr_forced_upgrade);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create forced_upgrade\n",
+				__func__);
+		goto error_create_forced_upgrade;
+	}
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+	rc = device_create_file(dev, &dev_attr_manual_upgrade);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create manual_upgrade\n",
+				__func__);
+		goto error_create_manual_upgrade;
+	}
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE
+	rc = device_create_file(dev, &dev_attr_config_loading);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create config_loading\n",
+				__func__);
+		goto error_create_config_loading;
+	}
+
+	rc = device_create_bin_file(dev, &bin_attr_config_data);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create config_data\n",
+				__func__);
+		goto error_create_config_data;
+	}
+#endif
+    /* ZTEMT Added by luochangyang, 2013/11/05 */
+    rc = device_create_file(dev, &dev_attr_fw_upgrade_flag);
+    if(rc){
+        dev_err(dev,"%s Error, could not create fw_upgrade_flag\n",
+            __func__);
+        kfree(data);
+        goto error_alloc_data_failed;
+    }
+
+	rc = device_create_file(dev, &dev_attr_manual_cali);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create manual_cali\n",
+				__func__);
+		kfree(data);
+		goto error_alloc_data_failed;
+	}
+    /* ZTEMT END */
+
+	data->loader_pdata = cyttsp4_request_loader_pdata(ttsp);
+	data->ttsp = ttsp;
+	dev_set_drvdata(dev, data);
+	/* ZTEMT Added by LiuYongfeng, 2013/1/15 */
+	init_completion(&(data->cyttsp_cali_complete));
+	/* ZTEMT END */
+	pm_runtime_enable(dev);
+
+#if CYTTSP4_FW_UPGRADE
+	init_completion(&data->int_running);
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+	init_completion(&data->builtin_bin_fw_complete);
+#endif
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_loader_attention, CY_MODE_BOOTLOADER);
+
+	INIT_WORK(&data->calibration_work, cyttsp4_fw_calibrate);
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE
+	mutex_init(&data->config_lock);
+#endif
+	INIT_WORK(&data->fw_and_config_upgrade, cyttsp4_fw_and_config_upgrade);
+	schedule_work(&data->fw_and_config_upgrade);
+
+	dev_dbg(dev, "%s: Successful probe %s\n", __func__, ttsp->name);
+	return 0;
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE
+error_create_config_data:
+	device_remove_file(dev, &dev_attr_config_loading);
+error_create_config_loading:
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+	device_remove_file(dev, &dev_attr_manual_upgrade);
+#endif
+#endif
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+error_create_manual_upgrade:
+#endif
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+	device_remove_file(dev, &dev_attr_forced_upgrade);
+error_create_forced_upgrade:
+#endif
+	kfree(data);
+error_alloc_data_failed:
+	dev_err(dev, "%s failed.\n", __func__);
+	return rc;
+}
+
+static int cyttsp4_loader_release(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	int retval = 0;
+
+	dev_dbg(dev, "%s\n", __func__);
+#if CYTTSP4_FW_UPGRADE
+	retval = cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_loader_attention, CY_MODE_BOOTLOADER);
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: Failed to restart IC with error code %d\n",
+			__func__, retval);
+	}
+#endif
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE
+	device_remove_bin_file(dev, &bin_attr_config_data);
+	device_remove_file(dev, &dev_attr_config_loading);
+	kfree(data->config_data);
+#endif
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+	device_remove_file(dev, &dev_attr_manual_upgrade);
+#endif
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+	device_remove_file(dev, &dev_attr_forced_upgrade);
+#endif
+	dev_set_drvdata(dev, NULL);
+	kfree(data);
+	return retval;
+}
+
+static struct cyttsp4_driver cyttsp4_loader_driver = {
+	.probe = cyttsp4_loader_probe,
+	.remove = cyttsp4_loader_release,
+	.driver = {
+		.name = CYTTSP4_LOADER_NAME,
+		.bus = &cyttsp4_bus_type,
+		.owner = THIS_MODULE,
+	},
+};
+
+static const char cyttsp4_loader_name[] = CYTTSP4_LOADER_NAME;
+static struct cyttsp4_device_info cyttsp4_loader_infos[CY_MAX_NUM_CORE_DEVS];
+
+static const char *core_ids[CY_MAX_NUM_CORE_DEVS] = {
+	CY_DEFAULT_CORE_ID,
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static int num_core_ids = 1;
+
+//module_param_array(core_ids, charp, &num_core_ids, 0);
+//MODULE_PARM_DESC(core_ids,
+//	"Core id list of cyttsp4 core devices for loader module");
+
+static int __init cyttsp4_loader_init(void)
+{
+	int rc = 0;
+	int i, j;
+
+	/* Check for invalid or duplicate core_ids */
+	for (i = 0; i < num_core_ids; i++) {
+		if (!strlen(core_ids[i])) {
+			pr_err("%s: core_id %d is empty\n",
+				__func__, i+1);
+			return -EINVAL;
+		}
+		for (j = i+1; j < num_core_ids; j++)
+			if (!strcmp(core_ids[i], core_ids[j])) {
+				pr_err("%s: core_ids %d and %d are same\n",
+					__func__, i+1, j+1);
+				return -EINVAL;
+			}
+	}
+
+	for (i = 0; i < num_core_ids; i++) {
+		cyttsp4_loader_infos[i].name = cyttsp4_loader_name;
+		cyttsp4_loader_infos[i].core_id = core_ids[i];
+		pr_debug("%s: Registering loader device for core_id: %s\n",
+			__func__, cyttsp4_loader_infos[i].core_id);
+		rc = cyttsp4_register_device(&cyttsp4_loader_infos[i]);
+		if (rc < 0) {
+			pr_err("%s: Error, failed registering device\n",
+				__func__);
+			goto fail_unregister_devices;
+		}
+	}
+	rc = cyttsp4_register_driver(&cyttsp4_loader_driver);
+	if (rc) {
+		pr_err("%s: Error, failed registering driver\n", __func__);
+		goto fail_unregister_devices;
+	}
+
+	pr_debug("%s: Cypress TTSP FW loader (Built %s) rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return 0;
+
+fail_unregister_devices:
+	for (i--; i >= 0; i--) {
+		cyttsp4_unregister_device(cyttsp4_loader_infos[i].name,
+			cyttsp4_loader_infos[i].core_id);
+		pr_info("%s: Unregistering loader device for core_id: %s\n",
+			__func__, cyttsp4_loader_infos[i].core_id);
+	}
+	return rc;
+}
+module_init(cyttsp4_loader_init);
+
+static void __exit cyttsp4_loader_exit(void)
+{
+	int i;
+
+	cyttsp4_unregister_driver(&cyttsp4_loader_driver);
+	for (i = 0; i < num_core_ids; i++) {
+		cyttsp4_unregister_device(cyttsp4_loader_infos[i].name,
+			cyttsp4_loader_infos[i].core_id);
+		pr_info("%s: Unregistering loader device for core_id: %s\n",
+			__func__, cyttsp4_loader_infos[i].core_id);
+	}
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_loader_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard touchscreen FW loader");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_mt.h b/drivers/input/touchscreen/cyttsp4/cyttsp4_mt.h
new file mode 100755
index 0000000..cc91966
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_mt.h
@@ -0,0 +1,84 @@
+/*
+ * cyttsp4_mt.h
+ * Cypress TrueTouch(TM) Standard Product V4 Multi-touch module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_MT_H
+#define _LINUX_CYTTSP4_MT_H
+
+#define CYTTSP4_MT_NAME "cyttsp4_mt"
+
+/* abs settings */
+#define CY_IGNORE_VALUE             0xFFFF
+/* abs signal capabilities offsets in the frameworks array */
+enum cyttsp4_sig_caps {
+	CY_SIGNAL_OST,
+	CY_MIN_OST,
+	CY_MAX_OST,
+	CY_FUZZ_OST,
+	CY_FLAT_OST,
+	CY_NUM_ABS_SET	/* number of signal capability fields */
+};
+
+/* abs axis signal offsets in the framworks array  */
+enum cyttsp4_sig_ost {
+	CY_ABS_X_OST,
+	CY_ABS_Y_OST,
+	CY_ABS_P_OST,
+	CY_ABS_W_OST,
+	CY_ABS_ID_OST,
+	CY_ABS_MAJ_OST,
+	CY_ABS_MIN_OST,
+	CY_ABS_OR_OST,
+	CY_NUM_ABS_OST	/* number of abs signals */
+};
+
+enum cyttsp4_mt_platform_flags {
+	CY_MT_FLAG_NONE = 0x00,
+	CY_MT_FLAG_HOVER = 0x04,
+	CY_MT_FLAG_FLIP = 0x08,
+	CY_MT_FLAG_INV_X = 0x10,
+	CY_MT_FLAG_INV_Y = 0x20,
+	CY_MT_FLAG_VKEYS = 0x40,
+	CY_MT_FLAG_NO_TOUCH_ON_LO = 0x80,
+};
+
+struct touch_framework {
+	const uint16_t  *abs;
+	uint8_t         size;
+	uint8_t         enable_vkeys;
+} __packed;
+
+struct cyttsp4_mt_platform_data {
+	struct touch_framework *frmwrk;
+	unsigned short flags;
+	char const *inp_dev_name;
+	int vkeys_x;
+	int vkeys_y;
+};
+
+#endif /* _LINUX_CYTTSP4_MT_H */
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_mt_common.c b/drivers/input/touchscreen/cyttsp4/cyttsp4_mt_common.c
new file mode 100755
index 0000000..18c8bb8
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_mt_common.c
@@ -0,0 +1,824 @@
+/*
+ * cyttsp4_mt_common.c
+ * Cypress TrueTouch(TM) Standard Product V4 Multi-touch module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include "cyttsp4_mt_common.h"
+
+#if defined(CONFIG_PM_SLEEP) || defined(CONFIG_PM_RUNTIME)
+static int cyttsp4_mt_suspend(struct device *dev);
+static int cyttsp4_mt_resume(struct device *dev);
+#endif
+
+static void cyttsp4_lift_all(struct cyttsp4_mt_data *md)
+{
+	if (!md->si)
+		return;
+
+	if (md->num_prv_rec != 0) {
+		if (md->mt_function.report_slot_liftoff)
+			md->mt_function.report_slot_liftoff(md,
+				md->si->si_ofs.tch_abs[CY_TCH_T].max);
+		input_sync(md->input);
+		md->num_prv_rec = 0;
+	}
+}
+
+static void cyttsp4_mt_process_touch(struct cyttsp4_mt_data *md,
+	struct cyttsp4_touch *touch)
+{
+	struct device *dev = &md->ttsp->dev;
+	int tmp;
+	bool flipped;
+
+	if (md->pdata->flags & CY_MT_FLAG_FLIP) {
+		tmp = touch->abs[CY_TCH_X];
+		touch->abs[CY_TCH_X] = touch->abs[CY_TCH_Y];
+		touch->abs[CY_TCH_Y] = tmp;
+		flipped = true;
+	} else
+		flipped = false;
+
+	if (md->pdata->flags & CY_MT_FLAG_INV_X) {
+		if (flipped)
+			touch->abs[CY_TCH_X] = md->si->si_ofs.max_y -
+				touch->abs[CY_TCH_X];
+		else
+			touch->abs[CY_TCH_X] = md->si->si_ofs.max_x -
+				touch->abs[CY_TCH_X];
+	}
+	if (md->pdata->flags & CY_MT_FLAG_INV_Y) {
+		if (flipped)
+			touch->abs[CY_TCH_Y] = md->si->si_ofs.max_x -
+				touch->abs[CY_TCH_Y];
+		else
+			touch->abs[CY_TCH_Y] = md->si->si_ofs.max_y -
+				touch->abs[CY_TCH_Y];
+	}
+
+	dev_vdbg(dev, "%s: flip=%s inv-x=%s inv-y=%s x=%04X(%d) y=%04X(%d)\n",
+		__func__, flipped ? "true" : "false",
+		md->pdata->flags & CY_MT_FLAG_INV_X ? "true" : "false",
+		md->pdata->flags & CY_MT_FLAG_INV_Y ? "true" : "false",
+		touch->abs[CY_TCH_X], touch->abs[CY_TCH_X],
+		touch->abs[CY_TCH_Y], touch->abs[CY_TCH_Y]);
+}
+
+static void cyttsp4_get_mt_touches(struct cyttsp4_mt_data *md, int num_cur_rec)
+{
+	struct device *dev = &md->ttsp->dev;
+	struct cyttsp4_sysinfo *si = md->si;
+	struct cyttsp4_touch tch;
+	int sig;
+	int i, j, t = 0;
+	int mt_sync_count = 0;
+	DECLARE_BITMAP(ids, max(CY_TMA1036_MAX_TCH, CY_TMA4XX_MAX_TCH));
+
+	bitmap_zero(ids, si->si_ofs.tch_abs[CY_TCH_T].max);
+
+	for (i = 0; i < num_cur_rec; i++) {
+		cyttsp4_get_touch_record(md->ttsp, i, tch.abs);
+
+		/* Discard proximity event */
+		if (tch.abs[CY_TCH_O] == CY_OBJ_PROXIMITY) {
+			dev_dbg(dev, "%s: Discarding proximity event\n",
+				__func__);
+			continue;
+		}
+
+		if ((tch.abs[CY_TCH_T] < md->pdata->frmwrk->abs
+			[(CY_ABS_ID_OST * CY_NUM_ABS_SET) + CY_MIN_OST]) ||
+			(tch.abs[CY_TCH_T] > md->pdata->frmwrk->abs
+			[(CY_ABS_ID_OST * CY_NUM_ABS_SET) + CY_MAX_OST])) {
+			dev_err(dev, "%s: tch=%d -> bad trk_id=%d max_id=%d\n",
+				__func__, i, tch.abs[CY_TCH_T],
+				md->pdata->frmwrk->abs[(CY_ABS_ID_OST *
+				CY_NUM_ABS_SET) + CY_MAX_OST]);
+			if (md->mt_function.input_sync)
+				md->mt_function.input_sync(md->input);
+			mt_sync_count++;
+			continue;
+		}
+
+		/* Process touch */
+		cyttsp4_mt_process_touch(md, &tch);
+
+		/* use 0 based track id's */
+		sig = md->pdata->frmwrk->abs
+			[(CY_ABS_ID_OST * CY_NUM_ABS_SET) + 0];
+		if (sig != CY_IGNORE_VALUE) {
+			t = tch.abs[CY_TCH_T] - md->pdata->frmwrk->abs
+				[(CY_ABS_ID_OST * CY_NUM_ABS_SET) + CY_MIN_OST];
+			if (tch.abs[CY_TCH_E] == CY_EV_LIFTOFF) {
+				dev_dbg(dev, "%s: t=%d e=%d lift-off\n",
+					__func__, t, tch.abs[CY_TCH_E]);
+				goto cyttsp4_get_mt_touches_pr_tch;
+			}
+			if (md->mt_function.input_report)
+				md->mt_function.input_report(md->input, sig,
+					t, tch.abs[CY_TCH_O]);
+			__set_bit(t, ids);
+		}
+
+		/* all devices: position and pressure fields */
+		for (j = 0; j <= CY_ABS_W_OST ; j++) {
+			sig = md->pdata->frmwrk->abs[((CY_ABS_X_OST + j) *
+				CY_NUM_ABS_SET) + 0];
+			if (sig != CY_IGNORE_VALUE)
+				input_report_abs(md->input, sig,
+					tch.abs[CY_TCH_X + j]);
+		}
+		if (IS_TTSP_VER_GE(si, 2, 3)) {
+			/*
+			 * TMA400 size and orientation fields:
+			 * if pressure is non-zero and major touch
+			 * signal is zero, then set major and minor touch
+			 * signals to minimum non-zero value
+			 */
+			if (tch.abs[CY_TCH_P] > 0 && tch.abs[CY_TCH_MAJ] == 0)
+				tch.abs[CY_TCH_MAJ] = tch.abs[CY_TCH_MIN] = 1;
+
+			/* Get the extended touch fields */
+			for (j = 0; j < CY_NUM_EXT_TCH_FIELDS; j++) {
+				sig = md->pdata->frmwrk->abs
+					[((CY_ABS_MAJ_OST + j) *
+					CY_NUM_ABS_SET) + 0];
+				if (sig != CY_IGNORE_VALUE)
+					input_report_abs(md->input, sig,
+						tch.abs[CY_TCH_MAJ + j]);
+			}
+		}
+		if (md->mt_function.input_sync)
+			md->mt_function.input_sync(md->input);
+		mt_sync_count++;
+
+cyttsp4_get_mt_touches_pr_tch:
+		if (IS_TTSP_VER_GE(si, 2, 3))
+			dev_dbg(dev,
+				"%s: t=%d x=%d y=%d z=%d M=%d m=%d o=%d e=%d\n",
+				__func__, t,
+				tch.abs[CY_TCH_X],
+				tch.abs[CY_TCH_Y],
+				tch.abs[CY_TCH_P],
+				tch.abs[CY_TCH_MAJ],
+				tch.abs[CY_TCH_MIN],
+				tch.abs[CY_TCH_OR],
+				tch.abs[CY_TCH_E]);
+		else
+			dev_dbg(dev,
+				"%s: t=%d x=%d y=%d z=%d e=%d\n", __func__,
+				t,
+				tch.abs[CY_TCH_X],
+				tch.abs[CY_TCH_Y],
+				tch.abs[CY_TCH_P],
+				tch.abs[CY_TCH_E]);
+	}
+
+	if (md->mt_function.final_sync)
+		md->mt_function.final_sync(md->input,
+			si->si_ofs.tch_abs[CY_TCH_T].max, mt_sync_count, ids);
+
+	md->num_prv_rec = num_cur_rec;
+	md->prv_tch_type = tch.abs[CY_TCH_O];
+
+	return;
+}
+
+/* read xy_data for all current touches */
+static int cyttsp4_xy_worker(struct cyttsp4_mt_data *md)
+{
+	struct device *dev = &md->ttsp->dev;
+	struct cyttsp4_sysinfo *si = md->si;
+	u8 num_cur_rec;
+	u8 rep_len;
+	u8 rep_stat;
+	u8 tt_stat;
+	int rc = 0;
+#if ZTEMT_CYPRESS_WAKEUP_GESTURE_DEBUG
+#else
+    unsigned long ids = 0;  //Added by luochangyang, 2013/09/25
+#endif
+	/*
+	 * Get event data from cyttsp4 device.
+	 * The event data includes all data
+	 * for all active touches.
+	 * Event data also includes button data
+	 */
+	rep_len = si->xy_mode[si->si_ofs.rep_ofs];
+	rep_stat = si->xy_mode[si->si_ofs.rep_ofs + 1];
+	tt_stat = si->xy_mode[si->si_ofs.tt_stat_ofs];
+
+	num_cur_rec = GET_NUM_TOUCH_RECORDS(tt_stat);
+
+	if (rep_len == 0 && num_cur_rec > 0) {
+		dev_err(dev, "%s: report length error rep_len=%d num_tch=%d\n",
+			__func__, rep_len, num_cur_rec);
+		goto cyttsp4_xy_worker_exit;
+	}
+
+	/* check any error conditions */
+	if (IS_BAD_PKT(rep_stat)) {
+		dev_dbg(dev, "%s: Invalid buffer detected\n", __func__);
+		rc = 0;
+		goto cyttsp4_xy_worker_exit;
+	}
+
+	if (IS_LARGE_AREA(tt_stat)) {
+        dev_dbg(dev, "%s: Large area detected\n", __func__);
+
+        /*** ZTEMT Added by luochangyang, 2013/09/25 ***/
+    	/* For large area event */
+#if ZTEMT_CYPRESS_WAKEUP_GESTURE_DEBUG
+		input_report_key(md->input, KEY_POWER, 1);
+		input_sync(md->input);
+
+		input_report_key(md->input, KEY_POWER, 0);
+		input_sync(md->input);
+#else
+    	if (md->mt_function.input_report)
+    		md->mt_function.input_report(md->input, ABS_MT_TRACKING_ID,
+    			0, CY_OBJ_STANDARD_FINGER);
+
+    	input_report_abs(md->input, ABS_MT_PRESSURE, 300);
+
+    	if (md->mt_function.input_sync)
+    		md->mt_function.input_sync(md->input);
+    	if (md->mt_function.final_sync)
+    		md->mt_function.final_sync(md->input, 0, 1, &ids);
+    	if (md->mt_function.report_slot_liftoff)
+    		md->mt_function.report_slot_liftoff(md, 1);
+    	if (md->mt_function.final_sync)
+    		md->mt_function.final_sync(md->input, 1, 1, &ids);
+#endif
+
+        cyttsp4_lift_all(md);
+        /***ZTEMT END***/
+
+		/* Do not report touch if configured so */
+		if (md->pdata->flags & CY_MT_FLAG_NO_TOUCH_ON_LO)
+			num_cur_rec = 0;
+	}
+
+	if (num_cur_rec > si->si_ofs.max_tchs) {
+		dev_err(dev, "%s: %s (n=%d c=%d)\n", __func__,
+			"too many tch; set to max tch",
+			num_cur_rec, si->si_ofs.max_tchs);
+		num_cur_rec = si->si_ofs.max_tchs;
+	}
+
+	/* extract xy_data for all currently reported touches */
+	dev_vdbg(dev, "%s: extract data num_cur_rec=%d\n", __func__,
+		num_cur_rec);
+	if (num_cur_rec)
+		cyttsp4_get_mt_touches(md, num_cur_rec);
+	else
+		cyttsp4_lift_all(md);
+
+	dev_vdbg(dev, "%s: done\n", __func__);
+	rc = 0;
+
+cyttsp4_xy_worker_exit:
+	return rc;
+}
+
+static void cyttsp4_mt_send_dummy_event(struct cyttsp4_mt_data *md)
+{
+#if ZTEMT_CYPRESS_WAKEUP_GESTURE_DEBUG
+	input_report_key(md->input, KEY_POWER, 1);
+    input_sync(md->input);
+
+    input_report_key(md->input, KEY_POWER, 0);
+    input_sync(md->input);
+#else
+    input_report_key(md->input, KEY_F10, 1);
+    input_sync(md->input);
+
+    input_report_key(md->input, KEY_F10, 0);
+    input_sync(md->input);
+#endif
+#if 0
+	unsigned long ids = 0;
+
+	/* for easy wakeup */
+	if (md->mt_function.input_report)
+		md->mt_function.input_report(md->input, ABS_MT_TRACKING_ID,
+			0, CY_OBJ_STANDARD_FINGER);
+
+	if (md->mt_function.input_sync)
+		md->mt_function.input_sync(md->input);
+	if (md->mt_function.final_sync)
+		md->mt_function.final_sync(md->input, 0, 1, &ids);
+	if (md->mt_function.report_slot_liftoff)
+		md->mt_function.report_slot_liftoff(md, 1);
+	if (md->mt_function.final_sync)
+		md->mt_function.final_sync(md->input, 1, 1, &ids);
+#endif
+}
+
+static int cyttsp4_mt_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+	int rc = 0;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	mutex_lock(&md->report_lock);
+	if (!md->is_suspended) {
+		/* core handles handshake */
+		rc = cyttsp4_xy_worker(md);
+	}
+	mutex_unlock(&md->report_lock);
+	if (rc < 0)
+		dev_err(dev, "%s: xy_worker error r=%d\n", __func__, rc);
+
+	return rc;
+}
+
+static int cyttsp4_mt_wake_attention(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_mt_data *md = dev_get_drvdata(&ttsp->dev);
+
+	mutex_lock(&md->report_lock);
+	cyttsp4_mt_send_dummy_event(md);
+	mutex_unlock(&md->report_lock);
+	return 0;
+}
+
+static int cyttsp4_startup_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+	int rc = 0;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	mutex_lock(&md->report_lock);
+	cyttsp4_lift_all(md);
+	mutex_unlock(&md->report_lock);
+	return rc;
+}
+
+static int cyttsp4_mt_open(struct input_dev *input)
+{
+	struct device *dev = input->dev.parent;
+	struct cyttsp4_device *ttsp =
+		container_of(dev, struct cyttsp4_device, dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	pm_runtime_get(dev);
+
+	dev_vdbg(dev, "%s: setup subscriptions\n", __func__);
+
+	/* set up touch call back */
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_mt_attention, CY_MODE_OPERATIONAL);
+
+	/* set up startup call back */
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_startup_attention, 0);
+
+	/* set up wakeup call back */
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_WAKE,
+		cyttsp4_mt_wake_attention, 0);
+
+	return 0;
+}
+
+static void cyttsp4_mt_close(struct input_dev *input)
+{
+	struct device *dev = input->dev.parent;
+	struct cyttsp4_device *ttsp =
+		container_of(dev, struct cyttsp4_device, dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_mt_attention, CY_MODE_OPERATIONAL);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_startup_attention, 0);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_WAKE,
+		cyttsp4_mt_wake_attention, 0);
+
+	pm_runtime_put(dev);
+}
+
+#if defined CONFIG_HAS_EARLYSUSPEND
+static void cyttsp4_mt_early_suspend(struct early_suspend *h)
+{
+	struct cyttsp4_mt_data *md =
+		container_of(h, struct cyttsp4_mt_data, es);
+	struct device *dev = &md->ttsp->dev;
+
+	cyttsp4_mt_suspend(dev);
+}
+
+static void cyttsp4_mt_late_resume(struct early_suspend *h)
+{
+	struct cyttsp4_mt_data *md =
+		container_of(h, struct cyttsp4_mt_data, es);
+	struct device *dev = &md->ttsp->dev;
+
+	cyttsp4_mt_resume(dev);
+}
+
+
+static void cyttsp4_setup_early_suspend(struct cyttsp4_mt_data *md)
+{
+	md->es.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	md->es.suspend = cyttsp4_mt_early_suspend;
+	md->es.resume = cyttsp4_mt_late_resume;
+
+	register_early_suspend(&md->es);
+}
+
+#elif defined (CONFIG_FB)
+static int cyttsp4_mt_fb_notifier_callback(struct notifier_block *self,
+				unsigned long event, void *data)
+{
+	struct fb_event *evdata = data;
+	int *blank;
+	struct cyttsp4_mt_data *md =
+		container_of(self, struct cyttsp4_mt_data, fb_notif);
+	struct device *dev = &md->ttsp->dev;
+
+    	dev_info(dev, "%s\n", __func__);
+
+	if (evdata && evdata->data && event == FB_EVENT_BLANK &&
+		md && md->ttsp) {
+		blank = evdata->data;
+		if (*blank == FB_BLANK_UNBLANK && md->is_suspended == true)
+			cyttsp4_mt_resume(&(md->ttsp->dev));
+		else if (*blank == FB_BLANK_POWERDOWN)
+			cyttsp4_mt_suspend(&(md->ttsp->dev));
+	}
+
+	return 0;
+}
+static void cyttsp4_setup_early_suspend(struct cyttsp4_mt_data *md)
+{
+	int retval = 0;
+	struct device *dev = &md->ttsp->dev;
+
+    	dev_dbg(dev, "%s\n", __func__);
+	md->fb_notif.notifier_call = cyttsp4_mt_fb_notifier_callback;
+
+	retval = fb_register_client(&md->fb_notif);
+	if (retval)
+		dev_err(&md->ttsp->dev,
+			"Unable to register fb_notifier: %d\n", retval);
+	return;
+}
+
+#else
+
+static void cyttsp4_setup_early_suspend(struct cyttsp4_mt_data *md)
+{
+	return;
+}
+
+#endif
+
+#if defined(CONFIG_PM_SLEEP) || defined(CONFIG_PM_RUNTIME)
+static int cyttsp4_mt_suspend(struct device *dev)
+{
+#ifndef CONFIG_PM_RUNTIME
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+#endif
+
+	dev_dbg(dev, "%s\n", __func__);
+
+#ifndef CONFIG_PM_RUNTIME
+	mutex_lock(&md->report_lock);
+	md->is_suspended = true;
+	cyttsp4_lift_all(md);
+	mutex_unlock(&md->report_lock);
+#endif
+
+	pm_runtime_put(dev);
+	return 0;
+}
+
+static int cyttsp4_mt_rt_suspend(struct device *dev)
+{
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&md->report_lock);
+	md->is_suspended = true;
+	cyttsp4_lift_all(md);
+	mutex_unlock(&md->report_lock);
+
+	return 0;
+}
+
+static int cyttsp4_mt_rt_resume(struct device *dev)
+{
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&md->report_lock);
+	md->is_suspended = false;
+	mutex_unlock(&md->report_lock);
+
+	return 0;
+}
+
+static int cyttsp4_mt_resume(struct device *dev)
+{
+#ifndef CONFIG_PM_RUNTIME
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+#endif
+	dev_dbg(dev, "%s\n", __func__);
+
+#ifndef CONFIG_PM_RUNTIME
+	mutex_lock(&md->report_lock);
+	md->is_suspended = false;
+	mutex_unlock(&md->report_lock);
+#endif
+
+	pm_runtime_get(dev);
+	return 0;
+}
+#endif
+
+#if 0
+static const struct dev_pm_ops cyttsp4_mt_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(cyttsp4_mt_suspend, cyttsp4_mt_resume)
+	SET_RUNTIME_PM_OPS(cyttsp4_mt_suspend, cyttsp4_mt_rt_resume, NULL)
+};
+#endif
+
+#if (!defined(CONFIG_FB) && !defined(CONFIG_HAS_EARLYSUSPEND))
+static const struct dev_pm_ops cyttsp4_mt_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(cyttsp4_mt_suspend, cyttsp4_mt_resume)
+};
+#else
+static const struct dev_pm_ops cyttsp4_mt_pm_ops = {
+	SET_RUNTIME_PM_OPS(cyttsp4_mt_rt_suspend, cyttsp4_mt_rt_resume, NULL)
+};
+#endif
+
+static int cyttsp4_setup_input_device(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+	int signal = CY_IGNORE_VALUE;
+	int max_x, max_y, max_p, min, max;
+	int max_x_tmp, max_y_tmp;
+	int i;
+	int rc;
+
+	dev_vdbg(dev, "%s: Initialize event signals\n", __func__);
+	__set_bit(EV_ABS, md->input->evbit);
+	__set_bit(EV_REL, md->input->evbit);
+	__set_bit(EV_KEY, md->input->evbit);
+#ifdef INPUT_PROP_DIRECT
+	__set_bit(INPUT_PROP_DIRECT, md->input->propbit);
+#endif
+
+    /*** ZTEMT Added by luochangyang, 2013/09/11 ***/
+    __set_bit(KEY_POWER, md->input->keybit);
+    __set_bit(KEY_F10, md->input->keybit);
+    /***ZTEMT END***/
+
+	/* If virtualkeys enabled, don't use all screen */
+	if (md->pdata->flags & CY_MT_FLAG_VKEYS) {
+		max_x_tmp = md->pdata->vkeys_x;
+		max_y_tmp = md->pdata->vkeys_y;
+	} else {
+		max_x_tmp = md->si->si_ofs.max_x;
+		max_y_tmp = md->si->si_ofs.max_y;
+	}
+
+	/* get maximum values from the sysinfo data */
+	if (md->pdata->flags & CY_MT_FLAG_FLIP) {
+		max_x = max_y_tmp - 1;
+		max_y = max_x_tmp - 1;
+	} else {
+		max_x = max_x_tmp - 1;
+		max_y = max_y_tmp - 1;
+	}
+	max_p = md->si->si_ofs.max_p;
+
+	/* set event signal capabilities */
+	for (i = 0; i < (md->pdata->frmwrk->size / CY_NUM_ABS_SET); i++) {
+		signal = md->pdata->frmwrk->abs
+			[(i * CY_NUM_ABS_SET) + CY_SIGNAL_OST];
+		if (signal != CY_IGNORE_VALUE) {
+			__set_bit(signal, md->input->absbit);
+			min = md->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_MIN_OST];
+			max = md->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_MAX_OST];
+			if (i == CY_ABS_ID_OST) {
+				/* shift track ids down to start at 0 */
+				max = max - min;
+				min = min - min;
+			} else if (i == CY_ABS_X_OST)
+				max = max_x;
+			else if (i == CY_ABS_Y_OST)
+				max = max_y;
+			else if (i == CY_ABS_P_OST)
+				max = max_p;
+			input_set_abs_params(md->input, signal, min, max,
+				md->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_FUZZ_OST],
+				md->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_FLAT_OST]);
+			dev_dbg(dev, "%s: register signal=%02X min=%d max=%d\n",
+				__func__, signal, min, max);
+			if (i == CY_ABS_ID_OST && !IS_TTSP_VER_GE(md->si, 2, 3))
+				break;
+		}
+	}
+
+	rc = md->mt_function.input_register_device(md->input,
+			md->si->si_ofs.tch_abs[CY_TCH_T].max);
+	if (rc < 0)
+		dev_err(dev, "%s: Error, failed register input device r=%d\n",
+			__func__, rc);
+	else
+		md->input_device_registered = true;
+
+	return rc;
+}
+
+static int cyttsp4_setup_input_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+	int rc = 0;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	md->si = cyttsp4_request_sysinfo(ttsp);
+	if (!md->si)
+		return -EINVAL;
+
+	rc = cyttsp4_setup_input_device(ttsp);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_setup_input_attention, 0);
+
+	return rc;
+}
+
+static int cyttsp4_mt_release(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	/*
+	 * This check is to prevent pm_runtime usage_count drop below zero
+	 * because of removing the module while in suspended state
+	 */
+	if (md->is_suspended)
+		pm_runtime_get_noresume(dev);
+
+	unregister_early_suspend(&md->es);
+#endif
+
+	if (md->input_device_registered) {
+		input_unregister_device(md->input);
+	} else {
+		input_free_device(md->input);
+		cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_input_attention, 0);
+	}
+
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+
+	dev_set_drvdata(dev, NULL);
+	kfree(md);
+	return 0;
+}
+
+static int cyttsp4_mt_probe(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_mt_data *md;
+	struct cyttsp4_mt_platform_data *pdata = dev_get_platdata(dev);
+	int rc = 0;
+
+	dev_dbg(dev, "%s\n", __func__);
+	dev_dbg(dev, "%s: debug on\n", __func__);
+	dev_vdbg(dev, "%s: verbose debug on\n", __func__);
+
+	if (pdata == NULL) {
+		dev_err(dev, "%s: Missing platform data\n", __func__);
+		rc = -ENODEV;
+		goto error_no_pdata;
+	}
+
+	md = kzalloc(sizeof(*md), GFP_KERNEL);
+	if (md == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto error_alloc_data_failed;
+	}
+
+	cyttsp4_init_function_ptrs(md);
+
+	mutex_init(&md->report_lock);
+	md->prv_tch_type = CY_OBJ_STANDARD_FINGER;
+	md->ttsp = ttsp;
+	md->pdata = pdata;
+	dev_set_drvdata(dev, md);
+	/* Create the input device and register it. */
+	dev_vdbg(dev, "%s: Create the input device and register it\n",
+		__func__);
+	md->input = input_allocate_device();
+	if (md->input == NULL) {
+		dev_err(dev, "%s: Error, failed to allocate input device\n",
+			__func__);
+		rc = -ENOSYS;
+		goto error_alloc_failed;
+	}
+
+	md->input->name = ttsp->name;
+	scnprintf(md->phys, sizeof(md->phys)-1, "%s", dev_name(dev));
+	md->input->phys = md->phys;
+	md->input->dev.parent = &md->ttsp->dev;
+	md->input->open = cyttsp4_mt_open;
+	md->input->close = cyttsp4_mt_close;
+	input_set_drvdata(md->input, md);
+
+	pm_runtime_enable(dev);
+
+	/* get sysinfo */
+	md->si = cyttsp4_request_sysinfo(ttsp);
+	if (md->si) {
+		rc = cyttsp4_setup_input_device(ttsp);
+		if (rc)
+			goto error_init_input;
+	} else {
+		dev_err(dev, "%s: Fail get sysinfo pointer from core p=%p\n",
+			__func__, md->si);
+		cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_input_attention, 0);
+	}
+
+//#ifdef CONFIG_HAS_EARLYSUSPEND
+	cyttsp4_setup_early_suspend(md);
+//#endif
+
+	dev_dbg(dev, "%s: OK\n", __func__);
+	return 0;
+
+error_init_input:
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+	input_free_device(md->input);
+error_alloc_failed:
+	dev_set_drvdata(dev, NULL);
+	kfree(md);
+error_alloc_data_failed:
+error_no_pdata:
+	dev_err(dev, "%s failed.\n", __func__);
+	return rc;
+}
+
+struct cyttsp4_driver cyttsp4_mt_driver = {
+	.probe = cyttsp4_mt_probe,
+	.remove = cyttsp4_mt_release,
+	.driver = {
+		.name = CYTTSP4_MT_NAME,
+		.bus = &cyttsp4_bus_type,
+		.pm = &cyttsp4_mt_pm_ops,
+	},
+};
+
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_mt_common.h b/drivers/input/touchscreen/cyttsp4/cyttsp4_mt_common.h
new file mode 100755
index 0000000..ea50a20
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_mt_common.h
@@ -0,0 +1,90 @@
+/*
+ * cyttsp4_mt_common.h
+ * Cypress TrueTouch(TM) Standard Product V4 Multi-touch module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include "cyttsp4_bus.h"
+
+#include <linux/delay.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/limits.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/notifier.h>
+#include <linux/fb.h>
+
+#include "cyttsp4_core.h"
+#include "cyttsp4_mt.h"
+#include "cyttsp4_regs.h"
+
+struct cyttsp4_mt_data;
+struct cyttsp4_mt_function {
+	int (*mt_release)(struct cyttsp4_device *ttsp);
+	int (*mt_probe)(struct cyttsp4_device *ttsp,
+			struct cyttsp4_mt_data *md);
+	void (*report_slot_liftoff)(struct cyttsp4_mt_data *md, int max_slots);
+	void (*input_sync)(struct input_dev *input);
+	void (*input_report)(struct input_dev *input, int sig, int t,
+			int type);
+	void (*final_sync)(struct input_dev *input, int max_slots,
+			int mt_sync_count, unsigned long *ids);
+	int (*input_register_device)(struct input_dev *input, int max_slots);
+};
+
+struct cyttsp4_mt_data {
+	struct cyttsp4_device *ttsp;
+	struct cyttsp4_mt_platform_data *pdata;
+	struct cyttsp4_sysinfo *si;
+	struct input_dev *input;
+	struct cyttsp4_mt_function mt_function;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend es;
+#endif
+	struct mutex report_lock;
+	bool is_suspended;
+	bool input_device_registered;
+	char phys[NAME_MAX];
+	int num_prv_rec; /* Number of previous touch records */
+	int prv_tch_type;
+#ifdef VERBOSE_DEBUG
+	u8 pr_buf[CY_MAX_PRBUF_SIZE];
+#endif
+	/* The framebuffer notifier block */
+	struct notifier_block fb_notif;
+};
+
+extern void cyttsp4_init_function_ptrs(struct cyttsp4_mt_data *md);
+extern struct cyttsp4_driver cyttsp4_mt_driver;
+
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_mta.c b/drivers/input/touchscreen/cyttsp4/cyttsp4_mta.c
new file mode 100755
index 0000000..9e09dc6
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_mta.c
@@ -0,0 +1,108 @@
+/*
+ * cyttsp4_mta.c
+ * Cypress TrueTouch(TM) Standard Product V4 Multi-touch module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/input.h>
+#include "cyttsp4_core.h"
+
+#include "cyttsp4_mt_common.h"
+
+static void cyttsp4_final_sync(struct input_dev *input, int max_slots,
+		int mt_sync_count, unsigned long *ids)
+{
+	if (mt_sync_count)
+		input_sync(input);
+}
+
+static void cyttsp4_input_sync(struct input_dev *input)
+{
+	input_mt_sync(input);
+}
+
+static void cyttsp4_input_report(struct input_dev *input, int sig,
+		 int t, int type)
+{
+	if (type == CY_OBJ_STANDARD_FINGER || type == CY_OBJ_GLOVE) {
+		input_report_key(input, BTN_TOOL_FINGER, CY_BTN_PRESSED);
+		input_report_key(input, BTN_TOOL_PEN, CY_BTN_RELEASED);
+	} else if (type == CY_OBJ_STYLUS) {
+		input_report_key(input, BTN_TOOL_PEN, CY_BTN_PRESSED);
+		input_report_key(input, BTN_TOOL_FINGER, CY_BTN_RELEASED);
+	}
+	input_report_key(input, BTN_TOUCH, CY_BTN_PRESSED);
+
+	input_report_abs(input, sig, t);
+}
+
+static void cyttsp4_report_slot_liftoff(struct cyttsp4_mt_data *md,
+		int max_slots)
+{
+	input_report_key(md->input, BTN_TOUCH, CY_BTN_RELEASED);
+	input_report_key(md->input, BTN_TOOL_FINGER, CY_BTN_RELEASED);
+	input_report_key(md->input, BTN_TOOL_PEN, CY_BTN_RELEASED);
+
+}
+
+static int cyttsp4_input_register_device(struct input_dev *input, int max_slots)
+{
+	__set_bit(BTN_TOUCH, input->keybit);
+	__set_bit(BTN_TOOL_FINGER, input->keybit);
+	__set_bit(BTN_TOOL_PEN, input->keybit);
+	return input_register_device(input);
+}
+
+void cyttsp4_init_function_ptrs(struct cyttsp4_mt_data *md)
+{
+	md->mt_function.report_slot_liftoff = cyttsp4_report_slot_liftoff;
+	md->mt_function.final_sync = cyttsp4_final_sync;
+	md->mt_function.input_sync = cyttsp4_input_sync;
+	md->mt_function.input_report = cyttsp4_input_report;
+	md->mt_function.input_register_device = cyttsp4_input_register_device;
+}
+
+static int __init cyttsp4_mt_init(void)
+{
+	int rc;
+	cyttsp4_mt_driver.driver.owner = THIS_MODULE;
+	rc = cyttsp4_register_driver(&cyttsp4_mt_driver);
+	pr_info("%s: Cypress TTSP MT v4 multi-touch (Built %s), rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return rc;
+}
+module_init(cyttsp4_mt_init);
+
+static void __exit cyttsp4_mt_exit(void)
+{
+	cyttsp4_unregister_driver(&cyttsp4_mt_driver);
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_mt_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard 2D multi-touch driver");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_mtb.c b/drivers/input/touchscreen/cyttsp4/cyttsp4_mtb.c
new file mode 100755
index 0000000..d78dc43
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_mtb.c
@@ -0,0 +1,125 @@
+/*
+ * cyttsp4_mtb.c
+ * Cypress TrueTouch(TM) Standard Product V4 Multi-touch module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include "cyttsp4_core.h"
+
+#include "cyttsp4_mt_common.h"
+
+static void cyttsp4_final_sync(struct input_dev *input, int max_slots,
+		int mt_sync_count, unsigned long *ids)
+{
+	int t;
+
+	for (t = 0; t < max_slots; t++) {
+		if (test_bit(t, ids))
+			continue;
+		input_mt_slot(input, t);
+		input_mt_report_slot_state(input, MT_TOOL_FINGER, false);
+	}
+
+	input_sync(input);
+}
+
+static void cyttsp4_input_report(struct input_dev *input, int sig,
+		int t, int type)
+{
+	input_mt_slot(input, t);
+    
+    /*** ZTEMT Modify by luochangyang, 2013/11/12 ***/
+    #if 0
+	if (type == CY_OBJ_STANDARD_FINGER || type == CY_OBJ_GLOVE)
+		input_mt_report_slot_state(input, MT_TOOL_FINGER, true);
+	else if (type == CY_OBJ_STYLUS)
+		input_mt_report_slot_state(input, MT_TOOL_PEN, true);
+    #else
+	if (type == CY_OBJ_STANDARD_FINGER)
+		input_mt_report_slot_state(input, MT_TOOL_FINGER, true);
+	else if (type == CY_OBJ_STYLUS)
+		input_mt_report_slot_state(input, MT_TOOL_PEN, true);
+	else
+		input_mt_report_slot_state(input, MT_TOOL_FINGER, true);
+    #endif
+    /***ZTEMT END***/
+}
+
+static void cyttsp4_report_slot_liftoff(struct cyttsp4_mt_data *md,
+		int max_slots)
+{
+	int t;
+
+	if (md->num_prv_rec == 0)
+		return;
+
+	for (t = 0; t < max_slots; t++) {
+		input_mt_slot(md->input, t);
+		input_mt_report_slot_state(md->input,
+			MT_TOOL_FINGER, false);
+	}
+}
+
+static int cyttsp4_input_register_device(struct input_dev *input, int max_slots)
+{	/*Register this Temple Run could not play. luochangyang 2014/05/05*/
+//	input_set_abs_params(input, ABS_MT_TOOL_TYPE, 0, MT_TOOL_MAX, 0, 0);
+
+	input_mt_init_slots(input, max_slots);
+	return input_register_device(input);
+}
+
+void cyttsp4_init_function_ptrs(struct cyttsp4_mt_data *md)
+{
+	md->mt_function.report_slot_liftoff = cyttsp4_report_slot_liftoff;
+	md->mt_function.final_sync = cyttsp4_final_sync;
+	md->mt_function.input_sync = NULL;
+	md->mt_function.input_report = cyttsp4_input_report;
+	md->mt_function.input_register_device = cyttsp4_input_register_device;
+}
+
+static int __init cyttsp4_mt_init(void)
+{
+	int rc;
+	cyttsp4_mt_driver.driver.owner = THIS_MODULE;
+	rc = cyttsp4_register_driver(&cyttsp4_mt_driver);
+	pr_debug("%s: Cypress TTSP MT v4 multi-touch (Built %s), rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return rc;
+}
+module_init(cyttsp4_mt_init);
+
+static void __exit cyttsp4_mt_exit(void)
+{
+	cyttsp4_unregister_driver(&cyttsp4_mt_driver);
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_mt_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard 2D multi-touch driver");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_proximity.c b/drivers/input/touchscreen/cyttsp4/cyttsp4_proximity.c
new file mode 100755
index 0000000..de61bf0
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_proximity.c
@@ -0,0 +1,585 @@
+/*
+ * cyttsp4_proximity.c
+ * Cypress TrueTouch(TM) Standard Product V4 Proximity touch reports module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2013 Cypress Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include "cyttsp4_bus.h"
+
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/limits.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+
+#include "cyttsp4_core.h"
+#include "cyttsp4_mt.h"
+#include "cyttsp4_proximity.h"
+#include "cyttsp4_regs.h"
+
+/* Timeout value in ms. */
+#define CY_PROXIMITY_REQUEST_EXCLUSIVE_TIMEOUT		1000
+
+#define CY_PROXIMITY_ON 0
+#define CY_PROXIMITY_OFF 1
+
+static int cyttsp4_proximity_attention(struct cyttsp4_device *ttsp);
+static int cyttsp4_startup_attention(struct cyttsp4_device *ttsp);
+
+struct cyttsp4_proximity_data {
+	struct cyttsp4_device *ttsp;
+	struct cyttsp4_proximity_platform_data *pdata;
+	struct cyttsp4_sysinfo *si;
+	struct input_dev *input;
+	struct mutex report_lock;
+	struct mutex sysfs_lock;
+	int enable_count;
+	bool is_suspended;
+	bool input_device_registered;
+	char phys[NAME_MAX];
+	u8 pr_buf[CY_MAX_PRBUF_SIZE];
+};
+
+static void cyttsp4_report_proximity(struct cyttsp4_proximity_data *pd,
+	bool on)
+{
+	int val = on ? CY_PROXIMITY_ON : CY_PROXIMITY_OFF;
+
+	input_report_abs(pd->input, ABS_DISTANCE, val);
+	input_sync(pd->input);
+}
+
+static void cyttsp4_get_proximity_touch(struct cyttsp4_proximity_data *pd,
+		int num_cur_rec)
+{
+	struct cyttsp4_touch tch;
+	int i;
+
+	for (i = 0; i < num_cur_rec; i++) {
+		cyttsp4_get_touch_record(pd->ttsp, i, tch.abs);
+
+		/* Check for proximity event */
+		if (tch.abs[CY_TCH_O] == CY_OBJ_PROXIMITY) {
+			if (tch.abs[CY_TCH_E] == CY_EV_TOUCHDOWN)
+				cyttsp4_report_proximity(pd, true);
+			else if (tch.abs[CY_TCH_E] == CY_EV_LIFTOFF)
+				cyttsp4_report_proximity(pd, false);
+			break;
+		}
+	}
+}
+
+/* read xy_data for all current touches */
+static int cyttsp4_xy_worker(struct cyttsp4_proximity_data *pd)
+{
+	struct device *dev = &pd->ttsp->dev;
+	struct cyttsp4_sysinfo *si = pd->si;
+	u8 num_cur_rec;
+	u8 rep_len;
+	u8 rep_stat;
+	u8 tt_stat;
+	int rc = 0;
+
+	/*
+	 * Get event data from cyttsp4 device.
+	 * The event data includes all data
+	 * for all active touches.
+	 * Event data also includes button data
+	 */
+	rep_len = si->xy_mode[si->si_ofs.rep_ofs];
+	rep_stat = si->xy_mode[si->si_ofs.rep_ofs + 1];
+	tt_stat = si->xy_mode[si->si_ofs.tt_stat_ofs];
+
+	num_cur_rec = GET_NUM_TOUCH_RECORDS(tt_stat);
+
+	if (rep_len == 0 && num_cur_rec > 0) {
+		dev_err(dev, "%s: report length error rep_len=%d num_rec=%d\n",
+			__func__, rep_len, num_cur_rec);
+		goto cyttsp4_xy_worker_exit;
+	}
+
+	/* check any error conditions */
+	if (IS_BAD_PKT(rep_stat)) {
+		dev_dbg(dev, "%s: Invalid buffer detected\n", __func__);
+		rc = 0;
+		goto cyttsp4_xy_worker_exit;
+	}
+
+	if (IS_LARGE_AREA(tt_stat))
+		dev_dbg(dev, "%s: Large area detected\n", __func__);
+
+	if (num_cur_rec > si->si_ofs.max_tchs) {
+		dev_err(dev, "%s: %s (n=%d c=%d)\n", __func__,
+			"too many tch; set to max tch",
+			num_cur_rec, si->si_ofs.max_tchs);
+		num_cur_rec = si->si_ofs.max_tchs;
+	}
+
+	/* extract xy_data for all currently reported touches */
+	dev_vdbg(dev, "%s: extract data num_cur_rec=%d\n", __func__,
+		num_cur_rec);
+	if (num_cur_rec)
+		cyttsp4_get_proximity_touch(pd, num_cur_rec);
+	else
+		cyttsp4_report_proximity(pd, false);
+
+	dev_vdbg(dev, "%s: done\n", __func__);
+	rc = 0;
+
+cyttsp4_xy_worker_exit:
+	return rc;
+}
+
+static int _cyttsp4_proximity_enable(struct cyttsp4_proximity_data *pd)
+{
+	struct cyttsp4_device *ttsp = pd->ttsp;
+	struct device *dev = &ttsp->dev;
+	int rc = 0;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	/* We use pm_runtime_get_sync to activate
+	 * the core device until it is disabled back
+	 */
+	pm_runtime_get_sync(dev);
+
+	rc = cyttsp4_request_exclusive(ttsp,
+			CY_PROXIMITY_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto exit;
+	}
+
+	rc = cyttsp4_request_enable_scan_type(ttsp, CY_ST_PROXIMITY);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request enable proximity scantype r=%d\n",
+				__func__, rc);
+		goto exit_release;
+	}
+
+	dev_vdbg(dev, "%s: setup subscriptions\n", __func__);
+
+	/* set up touch call back */
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_proximity_attention, CY_MODE_OPERATIONAL);
+
+	/* set up startup call back */
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_startup_attention, 0);
+
+exit_release:
+	cyttsp4_release_exclusive(ttsp);
+exit:
+	return rc;
+}
+
+static int _cyttsp4_proximity_disable(struct cyttsp4_proximity_data *pd,
+		bool force)
+{
+	struct cyttsp4_device *ttsp = pd->ttsp;
+	struct device *dev = &ttsp->dev;
+	int rc = 0;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	rc = cyttsp4_request_exclusive(ttsp,
+			CY_PROXIMITY_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto exit;
+	}
+
+	rc = cyttsp4_request_disable_scan_type(ttsp, CY_ST_PROXIMITY);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request disable proximity scan r=%d\n",
+				__func__, rc);
+		goto exit_release;
+	}
+
+exit_release:
+	cyttsp4_release_exclusive(ttsp);
+
+exit:
+	if (!rc || force) {
+		cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+			cyttsp4_proximity_attention, CY_MODE_OPERATIONAL);
+
+		cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_startup_attention, 0);
+
+		pm_runtime_put(dev);
+	}
+
+	return rc;
+}
+
+static ssize_t cyttsp4_proximity_enable_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+	int val = 0;
+
+	mutex_lock(&pd->sysfs_lock);
+	val = pd->enable_count;
+	mutex_unlock(&pd->sysfs_lock);
+
+	return scnprintf(buf, CY_MAX_PRBUF_SIZE, "%d\n", val);
+}
+
+static ssize_t cyttsp4_proximity_enable_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+	unsigned long value;
+	int rc;
+
+	rc = kstrtoul(buf, 10, &value);
+	if (rc < 0 || (value != 0 && value != 1)) {
+		dev_err(dev, "%s: Invalid value\n", __func__);
+		return -EINVAL;
+	}
+
+	mutex_lock(&pd->sysfs_lock);
+	if (value) {
+		if (pd->enable_count++) {
+			dev_vdbg(dev, "%s: '%s' already enabled\n", __func__,
+				pd->ttsp->name);
+		} else {
+			rc = _cyttsp4_proximity_enable(pd);
+			if (rc)
+				pd->enable_count--;
+		}
+	} else {
+		if (--pd->enable_count) {
+			if (pd->enable_count < 0) {
+				dev_err(dev, "%s: '%s' unbalanced disable\n",
+					__func__, pd->ttsp->name);
+				pd->enable_count = 0;
+			}
+		} else {
+			rc = _cyttsp4_proximity_disable(pd, false);
+			if (rc)
+				pd->enable_count++;
+		}
+	}
+	mutex_unlock(&pd->sysfs_lock);
+
+	if (rc)
+		return rc;
+
+	return size;
+}
+
+static DEVICE_ATTR(enable, S_IRUSR | S_IWUSR,
+		cyttsp4_proximity_enable_show,
+		cyttsp4_proximity_enable_store);
+
+static int cyttsp4_proximity_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+	int rc = 0;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	mutex_lock(&pd->report_lock);
+	if (!pd->is_suspended) {
+		/* core handles handshake */
+		rc = cyttsp4_xy_worker(pd);
+	} else {
+		dev_vdbg(dev, "%s: Ignoring report while suspended\n",
+			__func__);
+	}
+	mutex_unlock(&pd->report_lock);
+	if (rc < 0)
+		dev_err(dev, "%s: xy_worker error r=%d\n", __func__, rc);
+
+	return rc;
+}
+
+static int cyttsp4_startup_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	mutex_lock(&pd->report_lock);
+	cyttsp4_report_proximity(pd, false);
+	mutex_unlock(&pd->report_lock);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_RUNTIME
+static int cyttsp4_proximity_suspend(struct device *dev)
+{
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&pd->report_lock);
+	pd->is_suspended = true;
+	cyttsp4_report_proximity(pd, false);
+	mutex_unlock(&pd->report_lock);
+
+	return 0;
+}
+
+static int cyttsp4_proximity_resume(struct device *dev)
+{
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&pd->report_lock);
+	pd->is_suspended = false;
+	mutex_unlock(&pd->report_lock);
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops cyttsp4_proximity_pm_ops = {
+	SET_RUNTIME_PM_OPS(cyttsp4_proximity_suspend,
+		cyttsp4_proximity_resume, NULL)
+};
+
+static int cyttsp4_setup_input_device_and_sysfs(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+	int signal = CY_IGNORE_VALUE;
+	int min, max;
+	int i;
+	int rc;
+
+	rc = device_create_file(dev, &dev_attr_enable);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create enable\n",
+				__func__);
+		goto exit;
+	}
+
+	dev_vdbg(dev, "%s: Initialize event signals\n", __func__);
+
+	__set_bit(EV_ABS, pd->input->evbit);
+
+	for (i = 0; i < (pd->pdata->frmwrk->size / CY_NUM_ABS_SET); i++) {
+		signal = pd->pdata->frmwrk->abs
+			[(i * CY_NUM_ABS_SET) + CY_SIGNAL_OST];
+		if (signal != CY_IGNORE_VALUE) {
+			min = pd->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_MIN_OST];
+			max = pd->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_MAX_OST];
+			input_set_abs_params(pd->input, signal, min, max,
+				pd->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_FUZZ_OST],
+				pd->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_FLAT_OST]);
+		}
+	}
+
+	rc = input_register_device(pd->input);
+	if (rc) {
+		dev_err(dev, "%s: Error, failed register input device r=%d\n",
+			__func__, rc);
+		goto unregister_enable;
+	}
+
+	pd->input_device_registered = true;
+	return rc;
+
+unregister_enable:
+	device_remove_file(dev, &dev_attr_enable);
+exit:
+	return rc;
+}
+
+static int cyttsp4_setup_input_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+	int rc;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	pd->si = cyttsp4_request_sysinfo(ttsp);
+	if (!pd->si)
+		return -EINVAL;
+
+	rc = cyttsp4_setup_input_device_and_sysfs(ttsp);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_setup_input_attention, 0);
+
+	return rc;
+}
+
+static int cyttsp4_proximity_probe(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_proximity_data *pd;
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_proximity_platform_data *pdata = dev_get_platdata(dev);
+	int rc = 0;
+
+	dev_dbg(dev, "%s\n", __func__);
+	dev_dbg(dev, "%s: debug on\n", __func__);
+	dev_vdbg(dev, "%s: verbose debug on\n", __func__);
+
+	if (pdata == NULL) {
+		dev_err(dev, "%s: Missing platform data\n", __func__);
+		rc = -ENODEV;
+		goto error_no_pdata;
+	}
+
+	pd = kzalloc(sizeof(*pd), GFP_KERNEL);
+	if (pd == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto error_alloc_data_failed;
+	}
+
+	mutex_init(&pd->report_lock);
+	mutex_init(&pd->sysfs_lock);
+	pd->ttsp = ttsp;
+	pd->pdata = pdata;
+	dev_set_drvdata(dev, pd);
+	/* Create the input device and register it. */
+	dev_vdbg(dev, "%s: Create the input device and register it\n",
+		__func__);
+	pd->input = input_allocate_device();
+	if (pd->input == NULL) {
+		dev_err(dev, "%s: Error, failed to allocate input device\n",
+			__func__);
+		rc = -ENOSYS;
+		goto error_alloc_failed;
+	}
+
+	pd->input->name = ttsp->name;
+	scnprintf(pd->phys, sizeof(pd->phys)-1, "%s", dev_name(dev));
+	pd->input->phys = pd->phys;
+	pd->input->dev.parent = &pd->ttsp->dev;
+	input_set_drvdata(pd->input, pd);
+
+	pm_runtime_enable(dev);
+
+	/* get sysinfo */
+	pd->si = cyttsp4_request_sysinfo(ttsp);
+	if (pd->si) {
+		rc = cyttsp4_setup_input_device_and_sysfs(ttsp);
+		if (rc)
+			goto error_init_input;
+	} else {
+		dev_err(dev, "%s: Fail get sysinfo pointer from core p=%p\n",
+			__func__, pd->si);
+		cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_input_attention, 0);
+	}
+
+	dev_dbg(dev, "%s: ok\n", __func__);
+	return 0;
+
+error_init_input:
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+	input_free_device(pd->input);
+error_alloc_failed:
+	dev_set_drvdata(dev, NULL);
+	kfree(pd);
+error_alloc_data_failed:
+error_no_pdata:
+	dev_err(dev, "%s failed.\n", __func__);
+	return rc;
+}
+
+static int cyttsp4_proximity_release(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	if (pd->input_device_registered) {
+		/* Disable proximity sensing */
+		mutex_lock(&pd->sysfs_lock);
+		if (pd->enable_count)
+			_cyttsp4_proximity_disable(pd, true);
+		mutex_unlock(&pd->sysfs_lock);
+		device_remove_file(dev, &dev_attr_enable);
+		input_unregister_device(pd->input);
+	} else {
+		input_free_device(pd->input);
+		cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_input_attention, 0);
+	}
+
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+
+	dev_set_drvdata(dev, NULL);
+	kfree(pd);
+	return 0;
+}
+
+static struct cyttsp4_driver cyttsp4_proximity_driver = {
+	.probe = cyttsp4_proximity_probe,
+	.remove = cyttsp4_proximity_release,
+	.driver = {
+		.name = CYTTSP4_PROXIMITY_NAME,
+		.bus = &cyttsp4_bus_type,
+		.owner = THIS_MODULE,
+		.pm = &cyttsp4_proximity_pm_ops,
+	},
+};
+
+static int __init cyttsp4_proximity_init(void)
+{
+	int rc = 0;
+	rc = cyttsp4_register_driver(&cyttsp4_proximity_driver);
+	pr_debug("%s: Cypress TTSP MT v4 Proximity (Built %s), rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return rc;
+}
+module_init(cyttsp4_proximity_init);
+
+static void __exit cyttsp4_proximity_exit(void)
+{
+	cyttsp4_unregister_driver(&cyttsp4_proximity_driver);
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_proximity_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TTSP Proximity driver");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_proximity.h b/drivers/input/touchscreen/cyttsp4/cyttsp4_proximity.h
new file mode 100755
index 0000000..d0bcaad
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_proximity.h
@@ -0,0 +1,42 @@
+/*
+ * cyttsp4_proximity.h
+ * Cypress TrueTouch(TM) Standard Product V4 Proximity touch reports module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_PROXIMITY_H
+#define _LINUX_CYTTSP4_PROXIMITY_H
+
+#include "cyttsp4_mt.h"
+
+#define CYTTSP4_PROXIMITY_NAME "cyttsp4_proximity"
+
+struct cyttsp4_proximity_platform_data {
+	struct touch_framework *frmwrk;
+	char const *inp_dev_name;
+};
+
+#endif /* _LINUX_CYTTSP4_PROXIMITY_H */
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_regs.h b/drivers/input/touchscreen/cyttsp4/cyttsp4_regs.h
new file mode 100755
index 0000000..cde9297
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_regs.h
@@ -0,0 +1,594 @@
+/*
+ * cyttsp4_regs.h
+ * Cypress TrueTouch(TM) Standard Product V4 registers.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ * Modified by: Cypress Semiconductor to add test modes and commands
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _CYTTSP4_REGS_H
+#define _CYTTSP4_REGS_H
+
+#define CY_FW_FILE_NAME "cyttsp4_fw.bin"
+
+#define CY_DEFAULT_ADAP_MAX_XFER	512
+#define CY_ADAP_MIN_XFER		140
+
+#define CY_MAX_PRBUF_SIZE           PIPE_BUF
+#define CY_PR_TRUNCATED             " truncated..."
+
+#define CY_DEFAULT_CORE_ID          "main_ttsp_core"
+#define CY_MAX_NUM_CORE_DEVS        5
+
+#define CY_TMA1036_MAX_TCH          0x0E
+#define CY_TMA4XX_MAX_TCH           0x1E
+#define CY_REG_CYITO_VERH			0x2d//add by luochangyang
+#define CY_REG_CYITO_VERL			0x2e//yfliu
+#define CY_REG_RES_XH				0x3a
+#define CY_REG_RES_XL				0x3b
+#define CY_REG_RES_YH				0x3c
+#define CY_REG_RES_YL				0x3d
+
+#define IS_BOOTLOADER(hst_mode, reset_detect) \
+		((hst_mode) & 0x01 || (reset_detect) != 0)
+#define IS_BOOTLOADER_IDLE(hst_mode, reset_detect) \
+		((hst_mode) & 0x01 && (reset_detect) & 0x01)
+
+#define GET_HSTMODE(reg)		((reg & 0x70) >> 4)
+#define GET_TOGGLE(reg)			((reg & 0x80) >> 7)
+
+#define IS_LITTLEENDIAN(reg)		((reg & 0x01) == 1)
+#define GET_PANELID(reg)		(reg & 0x07)
+
+#define HI_BYTE(x)			(u8)(((x) >> 8) & 0xFF)
+#define LO_BYTE(x)			(u8)((x) & 0xFF)
+
+#define CY_REG_BASE			0x00
+#define CY_NUM_REVCTRL			8
+#define CY_NUM_DDATA			32
+#define CY_NUM_MDATA			64
+
+#define CY_REG_CAT_CMD			2
+#define CY_CMD_COMPLETE_MASK		(1 << 6)
+#define CY_CMD_MASK			0x3F
+
+#define CY_TTCONFIG_VERSION_OFFSET	8
+#define CY_TTCONFIG_VERSION_SIZE	2
+#define CY_TTCONFIG_VERSION_ROW		0
+
+#define CY_CONFIG_LENGTH_INFO_OFFSET	0
+#define CY_CONFIG_LENGTH_INFO_SIZE	4
+#define CY_CONFIG_LENGTH_OFFSET		0
+#define CY_CONFIG_LENGTH_SIZE		2
+#define CY_CONFIG_MAXLENGTH_OFFSET	2
+#define CY_CONFIG_MAXLENGTH_SIZE	2
+
+enum cyttsp4_ic_ebid {
+	CY_TCH_PARM_EBID,
+	CY_MDATA_EBID,
+	CY_DDATA_EBID,
+	CY_EBID_NUM,
+};
+
+/* touch record system information offset masks and shifts */
+#define CY_BYTE_OFS_MASK		0x1F
+#define CY_BOFS_MASK			0xE0
+#define CY_BOFS_SHIFT			5
+
+/* helpers */
+#define GET_NUM_TOUCH_RECORDS(x)	((x) & 0x1F)
+#define IS_LARGE_AREA(x)		((x) & 0x20)
+#define IS_BAD_PKT(x)			((x) & 0x20)
+#define IS_TTSP_VER_GE(p, maj, min) \
+		((p)->si_ptrs.cydata == NULL ? \
+		0 : \
+		((p)->si_ptrs.cydata->ttsp_ver_major < (maj) ? \
+			0 : \
+			((p)->si_ptrs.cydata->ttsp_ver_minor < (min) ? \
+				0 : \
+				1)))
+
+/* Timeout in ms. */
+#define CY_COMMAND_COMPLETE_TIMEOUT	500
+#define CY_CALIBRATE_COMPLETE_TIMEOUT	5000
+#define CY_WATCHDOG_TIMEOUT		1000
+
+/* drv_debug commands */
+#define CY_DBG_SUSPEND			4
+#define CY_DBG_RESUME			5
+#define CY_DBG_SOFT_RESET		97
+#define CY_DBG_RESET			98
+
+/* scan types */
+#define CY_SCAN_TYPE_GLOVE		0x8
+#define CY_SCAN_TYPE_STYLUS		0x10
+#define CY_SCAN_TYPE_PROXIMITY		0x40
+#define CY_SCAN_TYPE_APA_MC		0x80
+
+#define ZTEMT_CYPRESS_WAKEUP_GESTURE_DEBUG    0  //Added by luochangyang, for palm sleep  2013/12/16
+
+enum cyttsp4_hst_mode_bits {
+	CY_HST_TOGGLE      = (1 << 7),
+	CY_HST_MODE_CHANGE = (1 << 3),
+	CY_HST_DEVICE_MODE = (7 << 4),
+	CY_HST_OPERATE     = (0 << 4),
+	CY_HST_SYSINFO     = (1 << 4),
+	CY_HST_CAT         = (2 << 4),
+	CY_HST_LOWPOW      = (1 << 2),
+	CY_HST_SLEEP       = (1 << 1),
+	CY_HST_RESET       = (1 << 0),
+};
+
+enum cyttsp_cmd_bits {
+	CY_CMD_COMPLETE    = (1 << 6),
+};
+
+enum cyttsp4_cmd_cat {
+	CY_CMD_CAT_NULL,
+	CY_CMD_CAT_RESERVED_1,
+	CY_CMD_CAT_GET_CFG_ROW_SZ,
+	CY_CMD_CAT_READ_CFG_BLK,
+	CY_CMD_CAT_WRITE_CFG_BLK,
+	CY_CMD_CAT_RESERVED_2,
+	CY_CMD_CAT_LOAD_SELF_TEST_DATA,
+	CY_CMD_CAT_RUN_SELF_TEST,
+	CY_CMD_CAT_GET_SELF_TEST_RESULT,
+	CY_CMD_CAT_CALIBRATE_IDACS,
+	CY_CMD_CAT_INIT_BASELINES,
+	CY_CMD_CAT_EXEC_PANEL_SCAN,
+	CY_CMD_CAT_RETRIEVE_PANEL_SCAN,
+	CY_CMD_CAT_START_SENSOR_DATA_MODE,
+	CY_CMD_CAT_STOP_SENSOR_DATA_MODE,
+	CY_CMD_CAT_INT_PIN_MODE,
+	CY_CMD_CAT_RETRIEVE_DATA_STRUCTURE,
+	CY_CMD_CAT_VERIFY_CFG_BLK_CRC,
+	CY_CMD_CAT_RESERVED_N,
+};
+
+enum cyttsp4_cmd_op {
+	CY_CMD_OP_NULL,
+	CY_CMD_OP_RESERVED_1,
+	CY_CMD_OP_GET_PARAM,
+	CY_CMD_OP_SET_PARAM,
+	CY_CMD_OP_RESERVED_2,
+	CY_CMD_OP_GET_CRC,
+	CY_CMD_OP_WAIT_FOR_EVENT,
+};
+
+enum cyttsp4_cmd_status {
+	CY_CMD_STATUS_SUCCESS,
+	CY_CMD_STATUS_FAILURE,
+};
+
+/* Operational Mode Command Sizes */
+/* NULL Command */
+#define CY_CMD_OP_NULL_CMD_SZ			1
+#define CY_CMD_OP_NULL_RET_SZ			0
+/* Get Parameter */
+#define CY_CMD_OP_GET_PARAM_CMD_SZ		2
+#define CY_CMD_OP_GET_PARAM_RET_SZ		6
+/* Set Parameter */
+#define CY_CMD_OP_SET_PARAM_CMD_SZ		7
+#define CY_CMD_OP_SET_PARAM_RET_SZ		2
+/* Get Config Block CRC */
+#define CY_CMD_OP_GET_CFG_BLK_CRC_CMD_SZ	2
+#define CY_CMD_OP_GET_CFG_BLK_CRC_RET_SZ	3
+/* Wait For Event */
+#define CY_CMD_OP_WAIT_FOR_EVENT_CMD_SZ		2
+
+/* CaT Mode Command Sizes */
+/* NULL Command */
+#define CY_CMD_CAT_NULL_CMD_SZ			1
+#define CY_CMD_CAT_NULL_RET_SZ			0
+/* Get Config Row Size */
+#define CY_CMD_CAT_GET_CFG_ROW_SIZE_CMD_SZ	1
+#define CY_CMD_CAT_GET_CFG_ROW_SIZE_RET_SZ	2
+/* Read Config Block */
+#define CY_CMD_CAT_READ_CFG_BLK_CMD_SZ		6
+#define CY_CMD_CAT_READ_CFG_BLK_RET_SZ		7 /* + Data */
+#define CY_CMD_CAT_READ_CFG_BLK_RET_HDR_SZ	5
+/* Write Config Block */
+#define CY_CMD_CAT_WRITE_CFG_BLK_CMD_SZ		8 /* + Data + Security Key */
+#define CY_CMD_CAT_WRITE_CFG_BLK_RET_SZ		5
+#define CY_CMD_CAT_WRITE_CFG_BLK_CMD_HDR_SZ	6
+/* Load Self-Test Data */
+#define CY_CMD_CAT_LOAD_SELFTEST_DATA_CMD_SZ	6
+#define CY_CMD_CAT_LOAD_SELFTEST_DATA_RET_SZ	5 /* + Data */
+/* Run Self-Test */
+#define CY_CMD_CAT_RUN_SELFTEST_CMD_SZ		2
+#define CY_CMD_CAT_RUN_SELFTEST_RET_SZ		3
+/* Calibrate IDACs */
+#define CY_CMD_CAT_CALIBRATE_IDAC_CMD_SZ	2
+#define CY_CMD_CAT_CALIBRATE_IDAC_RET_SZ	1
+/* Get Self-Test Results */
+#define CY_CMD_CAT_GET_SELFTEST_RES_CMD_SZ	6
+#define CY_CMD_CAT_GET_SELFTEST_RES_RET_SZ	5 /* + Data */
+/* Initialize Baselines */
+#define CY_CMD_CAT_INIT_BASELINE_CMD_SZ		2
+#define CY_CMD_CAT_INIT_BASELINE_RET_SZ		1
+/* Execute Panel Scan */
+#define CY_CMD_CAT_EXECUTE_PANEL_SCAN_CMD_SZ	1
+#define CY_CMD_CAT_EXECUTE_PANEL_SCAN_RET_SZ	1
+/* Retrieve Panel Scan */
+#define CY_CMD_CAT_RETRIEVE_PANEL_SCAN_CMD_SZ	6
+#define CY_CMD_CAT_RETRIEVE_PANEL_SCAN_RET_SZ	5 /* + Data */
+/* Start Sensor Data Mode */
+#define CY_CMD_CAT_START_SENSOR_MODE_CMD_SZ	1 /* + Data */
+#define CY_CMD_CAT_START_SENSOR_MODE_RET_SZ	0 /* + Data */
+/* Stop Sensor Data Mode */
+#define CY_CMD_CAT_STOP_SENSOR_MODE_CMD_SZ	1
+#define CY_CMD_CAT_STOP_SENSOR_MODE_RET_SZ	0
+/* Interrupt Pin Override */
+#define CY_CMD_CAT_INT_PIN_OVERRIDE_CMD_SZ	2
+#define CY_CMD_CAT_INT_PIN_OVERRIDE_RET_SZ	1
+/* Retrieve Data Structure */
+#define CY_CMD_CAT_RETRIEVE_DATA_STRUCT_CMD_SZ	6
+#define CY_CMD_CAT_RETRIEVE_DATA_STRUCT_RET_SZ	5 /* + Data */
+/* Verify Config Block CRC */
+#define CY_CMD_CAT_VERIFY_CFG_BLK_CRC_CMD_SZ	2
+#define CY_CMD_CAT_VERIFY_CFG_BLK_CRC_RET_SZ	5
+
+#define CY_RAM_ID_ACTIVE_DISTANCE		0x4A
+#define CY_RAM_ID_SCAN_TYPE			0x4B
+#define CY_RAM_ID_LOW_POWER_INTERVAL		0x4C
+#define CY_RAM_ID_REFRESH_INTERVAL		0x4D
+#define CY_RAM_ID_ACTIVE_MODE_TIMEOUT		0x4E
+#define CY_RAM_ID_ACTIVE_LFT_INTERVAL		0x4F
+#define CY_RAM_ID_ACTIVE_DISTANCE2		0x50
+#define CY_RAM_ID_CHARGER_STATUS		0x51
+#define CY_RAM_ID_IMO_TRIM_VALUE		0x52
+#define CY_RAM_ID_FINGER_THRESHOLH		0x93
+#define CY_RAM_ID_DETECT_AREA_MARGIN_X		0x58
+#define CY_RAM_ID_DETECT_AREA_MARGIN_Y		0x59
+#define CY_RAM_ID_GRIP_XEDGE_A			0x70
+#define CY_RAM_ID_GRIP_XEDGE_B			0x71
+#define CY_RAM_ID_GRIP_XEXC_A			0x72
+#define CY_RAM_ID_GRIP_XEXC_B			0x73
+#define CY_RAM_ID_GRIP_YEDGE_A			0x74
+#define CY_RAM_ID_GRIP_YEDGE_B			0x75
+#define CY_RAM_ID_GRIP_YEXC_A			0x76
+#define CY_RAM_ID_GRIP_YEXC_B			0x77
+#define CY_RAM_ID_GRIP_FIRST_EXC		0x78
+#define CY_RAM_ID_GRIP_EXC_EDGE_ORIGIN		0x79
+#define CY_RAM_ID_PROX_ACTIVE_DIST_Z_VALUE	0x9B
+
+enum cyttsp4_scan_type {
+	CY_ST_APA_MC,
+	CY_ST_GLOVE,
+	CY_ST_STYLUS,
+	CY_ST_PROXIMITY,
+};
+
+enum cyttsp4_mode {
+	CY_MODE_UNKNOWN      = 0,
+	CY_MODE_BOOTLOADER   = (1 << 1),
+	CY_MODE_OPERATIONAL  = (1 << 2),
+	CY_MODE_SYSINFO      = (1 << 3),
+	CY_MODE_CAT          = (1 << 4),
+	CY_MODE_STARTUP      = (1 << 5),
+	CY_MODE_LOADER       = (1 << 6),
+	CY_MODE_CHANGE_MODE  = (1 << 7),
+	CY_MODE_CHANGED      = (1 << 8),
+	CY_MODE_CMD_COMPLETE = (1 << 9),
+};
+
+enum cyttsp4_int_state {
+	CY_INT_NONE,
+	CY_INT_IGNORE      = (1 << 0),
+	CY_INT_MODE_CHANGE = (1 << 1),
+	CY_INT_EXEC_CMD    = (1 << 2),
+	CY_INT_AWAKE       = (1 << 3),
+};
+
+enum cyttsp4_ic_grpnum {
+	CY_IC_GRPNUM_RESERVED,
+	CY_IC_GRPNUM_CMD_REGS,
+	CY_IC_GRPNUM_TCH_REP,
+	CY_IC_GRPNUM_DATA_REC,
+	CY_IC_GRPNUM_TEST_REC,
+	CY_IC_GRPNUM_PCFG_REC,
+	CY_IC_GRPNUM_TCH_PARM_VAL,
+	CY_IC_GRPNUM_TCH_PARM_SIZE,
+	CY_IC_GRPNUM_RESERVED1,
+	CY_IC_GRPNUM_RESERVED2,
+	CY_IC_GRPNUM_OPCFG_REC,
+	CY_IC_GRPNUM_DDATA_REC,
+	CY_IC_GRPNUM_MDATA_REC,
+	CY_IC_GRPNUM_TEST_REGS,
+	CY_IC_GRPNUM_BTN_KEYS,
+	CY_IC_GRPNUM_TTHE_REGS,
+	CY_IC_GRPNUM_NUM
+};
+
+#define CY_VKEYS_X			720
+#define CY_VKEYS_Y			1280
+
+enum cyttsp4_event_id {
+	CY_EV_NO_EVENT,
+	CY_EV_TOUCHDOWN,
+	CY_EV_MOVE,		/* significant displacement (> act dist) */
+	CY_EV_LIFTOFF,		/* record reports last position */
+};
+
+enum cyttsp4_object_id {
+	CY_OBJ_STANDARD_FINGER = 0,
+	CY_OBJ_PROXIMITY       = 1,
+	CY_OBJ_STYLUS          = 2,
+	CY_OBJ_GLOVE           = 4,
+};
+
+#define CY_POST_CODEL_WDG_RST           0x01
+#define CY_POST_CODEL_CFG_DATA_CRC_FAIL 0x02
+#define CY_POST_CODEL_PANEL_TEST_FAIL   0x04
+
+/* test mode NULL command driver codes */
+enum cyttsp4_null_test_cmd_code {
+	CY_NULL_CMD_NULL,
+	CY_NULL_CMD_MODE,
+	CY_NULL_CMD_STATUS_SIZE,
+	CY_NULL_CMD_HANDSHAKE,
+	CY_NULL_CMD_LOW_POWER,
+};
+
+enum cyttsp4_test_mode {
+	CY_TEST_MODE_NORMAL_OP,		/* Send touch data to OS; normal op */
+	CY_TEST_MODE_CAT,		/* Configuration and Test */
+	CY_TEST_MODE_SYSINFO,		/* System information mode */
+	CY_TEST_MODE_CLOSED_UNIT,	/* Send scan data to sysfs */
+};
+
+struct cyttsp4_test_mode_params {
+	int cur_mode;
+	int cur_cmd;
+	size_t cur_status_size;
+};
+
+/* GEN4/SOLO Operational interface definitions */
+/* TTSP System Information interface definitions */
+struct cyttsp4_cydata {
+	u8 ttpidh;
+	u8 ttpidl;
+	u8 fw_ver_major;
+	u8 fw_ver_minor;
+	u8 revctrl[CY_NUM_REVCTRL];
+	u8 blver_major;
+	u8 blver_minor;
+	u8 jtag_si_id3;
+	u8 jtag_si_id2;
+	u8 jtag_si_id1;
+	u8 jtag_si_id0;
+	u8 mfgid_sz;
+	u8 cyito_idh;
+	u8 cyito_idl;
+	u8 cyito_verh;
+	u8 cyito_verl;
+	u8 ttsp_ver_major;
+	u8 ttsp_ver_minor;
+	u8 device_info;
+	u8 mfg_id[];
+} __packed;
+
+struct cyttsp4_test {
+	u8 post_codeh;
+	u8 post_codel;
+} __packed;
+
+struct cyttsp4_pcfg {
+	u8 electrodes_x;
+	u8 electrodes_y;
+	u8 len_xh;
+	u8 len_xl;
+	u8 len_yh;
+	u8 len_yl;
+	u8 res_xh;
+	u8 res_xl;
+	u8 res_yh;
+	u8 res_yl;
+	u8 max_zh;
+	u8 max_zl;
+	u8 panel_info0;
+} __packed;
+
+enum cyttsp4_tch_abs {	/* for ordering within the extracted touch data array */
+	CY_TCH_X,	/* X */
+	CY_TCH_Y,	/* Y */
+	CY_TCH_P,	/* P (Z) */
+	CY_TCH_T,	/* TOUCH ID */
+	CY_TCH_E,	/* EVENT ID */
+	CY_TCH_O,	/* OBJECT ID */
+	CY_TCH_W,	/* SIZE */
+	CY_TCH_MAJ,	/* TOUCH_MAJOR */
+	CY_TCH_MIN,	/* TOUCH_MINOR */
+	CY_TCH_OR,	/* ORIENTATION */
+	CY_TCH_NUM_ABS
+};
+
+static const char * const cyttsp4_tch_abs_string[] = {
+	[CY_TCH_X]	= "X",
+	[CY_TCH_Y]	= "Y",
+	[CY_TCH_P]	= "P",
+	[CY_TCH_T]	= "T",
+	[CY_TCH_E]	= "E",
+	[CY_TCH_O]	= "O",
+	[CY_TCH_W]	= "W",
+	[CY_TCH_MAJ]	= "MAJ",
+	[CY_TCH_MIN]	= "MIN",
+	[CY_TCH_OR]	= "OR",
+	[CY_TCH_NUM_ABS] = "INVALID"
+};
+
+#define CY_NUM_TCH_FIELDS		7
+#define CY_NUM_EXT_TCH_FIELDS		3
+
+struct cyttsp4_tch_rec_params {
+	u8 loc;
+	u8 size;
+} __packed;
+
+struct cyttsp4_opcfg {
+	u8 cmd_ofs;
+	u8 rep_ofs;
+	u8 rep_szh;
+	u8 rep_szl;
+	u8 num_btns;
+	u8 tt_stat_ofs;
+	u8 obj_cfg0;
+	u8 max_tchs;
+	u8 tch_rec_size;
+	struct cyttsp4_tch_rec_params tch_rec_old[CY_NUM_TCH_FIELDS];
+	u8 btn_rec_size;/* btn record size (in bytes) */
+	u8 btn_diff_ofs;/* btn data loc ,diff counts, (Op-Mode byte ofs) */
+	u8 btn_diff_size;/* btn size of diff counts (in bits) */
+	struct cyttsp4_tch_rec_params tch_rec_new[CY_NUM_EXT_TCH_FIELDS];
+	u8 noise_data_ofs;
+	u8 noise_data_sz;
+} __packed;
+
+struct cyttsp4_sysinfo_data {
+	u8 hst_mode;
+	u8 reserved;
+	u8 map_szh;
+	u8 map_szl;
+	u8 cydata_ofsh;
+	u8 cydata_ofsl;
+	u8 test_ofsh;
+	u8 test_ofsl;
+	u8 pcfg_ofsh;
+	u8 pcfg_ofsl;
+	u8 opcfg_ofsh;
+	u8 opcfg_ofsl;
+	u8 ddata_ofsh;
+	u8 ddata_ofsl;
+	u8 mdata_ofsh;
+	u8 mdata_ofsl;
+} __packed;
+
+struct cyttsp4_sysinfo_ptr {
+	struct cyttsp4_cydata *cydata;
+	struct cyttsp4_test *test;
+	struct cyttsp4_pcfg *pcfg;
+	struct cyttsp4_opcfg *opcfg;
+	struct cyttsp4_ddata *ddata;
+	struct cyttsp4_mdata *mdata;
+} __packed;
+
+struct cyttsp4_touch {
+	int abs[CY_TCH_NUM_ABS];
+};
+
+struct cyttsp4_tch_abs_params {
+	size_t ofs;	/* abs byte offset */
+	size_t size;	/* size in bits */
+	size_t max;	/* max value */
+	size_t bofs;	/* bit offset */
+};
+
+#define CY_NORMAL_ORIGIN		0	/* upper, left corner */
+#define CY_INVERT_ORIGIN		1	/* lower, right corner */
+
+struct cyttsp4_sysinfo_ofs {
+	size_t chip_type;
+	size_t cmd_ofs;
+	size_t rep_ofs;
+	size_t rep_sz;
+	size_t num_btns;
+	size_t num_btn_regs;	/* ceil(num_btns/4) */
+	size_t tt_stat_ofs;
+	size_t tch_rec_size;
+	size_t obj_cfg0;
+	size_t max_tchs;
+	size_t mode_size;
+	size_t data_size;
+	size_t rep_hdr_size;
+	size_t map_sz;
+	size_t max_x;
+	size_t x_origin;	/* left or right corner */
+	size_t max_y;
+	size_t y_origin;	/* upper or lower corner */
+	size_t max_p;
+	size_t cydata_ofs;
+	size_t test_ofs;
+	size_t pcfg_ofs;
+	size_t opcfg_ofs;
+	size_t ddata_ofs;
+	size_t mdata_ofs;
+	size_t cydata_size;
+	size_t test_size;
+	size_t pcfg_size;
+	size_t opcfg_size;
+	size_t ddata_size;
+	size_t mdata_size;
+	size_t btn_keys_size;
+	struct cyttsp4_tch_abs_params tch_abs[CY_TCH_NUM_ABS];
+	size_t btn_rec_size; /* btn record size (in bytes) */
+	size_t btn_diff_ofs;/* btn data loc ,diff counts, (Op-Mode byte ofs) */
+	size_t btn_diff_size;/* btn size of diff counts (in bits) */
+	size_t noise_data_ofs;
+	size_t noise_data_sz;
+};
+
+/* button to keycode support */
+#define CY_NUM_BTN_PER_REG		4
+#define CY_BITS_PER_BTN			2
+
+enum cyttsp4_btn_state {
+	CY_BTN_RELEASED = 0,
+	CY_BTN_PRESSED = 1,
+	CY_BTN_NUM_STATE
+};
+
+struct cyttsp4_btn {
+	bool enabled;
+	int state;	/* CY_BTN_PRESSED, CY_BTN_RELEASED */
+	int key_code;
+};
+
+struct cyttsp4_ttconfig {
+	u16 version;
+	u16 length;
+	u16 max_length;
+	u16 crc;
+};
+
+struct cyttsp4_sysinfo {
+	bool ready;
+	struct cyttsp4_sysinfo_data si_data;
+	struct cyttsp4_sysinfo_ptr si_ptrs;
+	struct cyttsp4_sysinfo_ofs si_ofs;
+	struct cyttsp4_ttconfig ttconfig;
+	struct cyttsp4_btn *btn;	/* button states */
+	u8 *btn_rec_data;		/* button diff count data */
+	u8 *xy_mode;			/* operational mode and status regs */
+	u8 *xy_data;			/* operational touch regs */
+	u16 fw_ver;				/*version of fw read from CY_REG_CYITO_VERH*/
+	u16 fw_ver_new;
+	int update_flag;		/*fw update flag 1: fw is too old, -1:fw is newer, no need to upgrade, 0: equal*/
+	u16 x_res;
+	u16 y_res;
+};
+
+#endif /* _CYTTSP4_REGS_H */
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_spi.c b/drivers/input/touchscreen/cyttsp4/cyttsp4_spi.c
new file mode 100755
index 0000000..5ad55e3b
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_spi.c
@@ -0,0 +1,443 @@
+/*
+ * cyttsp4_spi.c
+ * Cypress TrueTouch(TM) Standard Product V4 SPI Driver module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ * Modified by: Cypress Semiconductor for test with device
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+#include <linux/delay.h>
+#include <linux/mutex.h>
+#include <linux/pm_runtime.h>
+#include <linux/hrtimer.h>
+#include "cyttsp4_bus.h"
+#include "cyttsp4_core.h"
+#include "cyttsp4_spi.h"
+
+#define CY_SPI_WR_OP		0x00 /* r/~w */
+#define CY_SPI_RD_OP		0x01
+#define CY_SPI_A8_BIT		0x02
+#define CY_SPI_WR_HEADER_BYTES	2
+#define CY_SPI_RD_HEADER_BYTES	1
+#define CY_SPI_SYNC_BYTE	0
+#define CY_SPI_SYNC_ACK		0x62 /* from TRM *A protocol */
+#define CY_SPI_DATA_SIZE	(3 * 256)
+#define CY_SPI_BITS_PER_WORD	8
+#define CY_SPI_NUM_RETRY	3
+
+#define CY_SPI_MAX_HEADER_BYTES	\
+		max(CY_SPI_WR_HEADER_BYTES, CY_SPI_RD_HEADER_BYTES)
+
+struct cyttsp4_spi {
+	struct spi_device *client;
+	struct mutex lock;
+};
+
+static void _cyttsp4_spi_pr_buf(struct cyttsp4_spi *ts_spi, u8 *buf,
+			int size, char const *info)
+{
+#ifdef VERBOSE_DEBUG
+	static char b[CY_SPI_DATA_SIZE * 3 + 1];
+	unsigned i, k;
+
+	for (i = k = 0; i < size; i++, k += 3)
+		snprintf(b + k, sizeof(b) - k, "%02x ", buf[i]);
+	dev_dbg(&ts_spi->client->dev, "%s: %s\n", info, b);
+#endif
+}
+
+static int cyttsp4_spi_xfer(u8 op, struct cyttsp4_spi *ts,
+			u16 reg, u8 *buf, int length)
+{
+	struct device *dev = &ts->client->dev;
+	struct spi_message msg;
+	struct spi_transfer xfer[2];
+	u8 wr_hdr_buf[CY_SPI_MAX_HEADER_BYTES];
+	u8 rd_hdr_buf[CY_SPI_MAX_HEADER_BYTES];
+	int rc;
+
+	memset(wr_hdr_buf, 0, CY_SPI_MAX_HEADER_BYTES);
+	memset(rd_hdr_buf, 0, CY_SPI_MAX_HEADER_BYTES);
+	memset(xfer, 0, sizeof(xfer));
+
+	spi_message_init(&msg);
+
+	/* Header buffer */
+	xfer[0].tx_buf = wr_hdr_buf;
+	xfer[0].rx_buf = rd_hdr_buf;
+
+	switch (op) {
+	case CY_SPI_WR_OP:
+		if (length + CY_SPI_WR_HEADER_BYTES > CY_SPI_DATA_SIZE) {
+			dev_vdbg(dev,
+				"%s: length+%d=%d is greater than SPI max=%d\n",
+				__func__, CY_SPI_WR_HEADER_BYTES,
+				length + CY_SPI_WR_HEADER_BYTES,
+				CY_SPI_DATA_SIZE);
+			rc = -EINVAL;
+			goto cyttsp4_spi_xfer_exit;
+		}
+
+		/* Header byte 0 */
+		if (reg > 255)
+			wr_hdr_buf[0] = CY_SPI_WR_OP + CY_SPI_A8_BIT;
+		else
+			wr_hdr_buf[0] = CY_SPI_WR_OP;
+
+		/* Header byte 1 */
+		wr_hdr_buf[1] = reg % 256;
+
+		xfer[0].len = CY_SPI_WR_HEADER_BYTES;
+
+		spi_message_add_tail(&xfer[0], &msg);
+
+		/* Data buffer */
+		if (buf) {
+			xfer[1].tx_buf = buf;
+			xfer[1].len = length;
+
+			spi_message_add_tail(&xfer[1], &msg);
+		}
+		break;
+
+	case CY_SPI_RD_OP:
+		if (!buf) {
+			dev_err(dev, "%s: No read buffer\n", __func__);
+			rc = -EINVAL;
+			goto cyttsp4_spi_xfer_exit;
+		}
+
+		if ((length + CY_SPI_RD_HEADER_BYTES) > CY_SPI_DATA_SIZE) {
+			dev_vdbg(dev,
+				"%s: length+%d=%d is greater than SPI max=%d\n",
+				__func__, CY_SPI_RD_HEADER_BYTES,
+				length + CY_SPI_RD_HEADER_BYTES,
+				CY_SPI_DATA_SIZE);
+			rc = -EINVAL;
+			goto cyttsp4_spi_xfer_exit;
+		}
+
+		/* Header byte 0 */
+		wr_hdr_buf[0] = CY_SPI_RD_OP;
+
+		xfer[0].len = CY_SPI_RD_HEADER_BYTES;
+
+		spi_message_add_tail(&xfer[0], &msg);
+
+		/* Data buffer */
+		xfer[1].rx_buf = buf;
+		xfer[1].len = length;
+
+		spi_message_add_tail(&xfer[1], &msg);
+		break;
+
+	default:
+		dev_dbg(dev, "%s: bad op code=%d\n", __func__, op);
+		rc = -EINVAL;
+		goto cyttsp4_spi_xfer_exit;
+	}
+
+	rc = spi_sync(ts->client, &msg);
+	if (rc < 0) {
+		dev_vdbg(dev, "%s: spi_sync() error %d, len=%d, op=%d\n",
+			__func__, rc, xfer[0].len, op);
+		/*
+		 * do not return here since probably a bad ACK sequence
+		 * let the following ACK check handle any errors and
+		 * allow silent retries
+		 */
+	}
+
+	if (rd_hdr_buf[CY_SPI_SYNC_BYTE] != CY_SPI_SYNC_ACK) {
+		/* signal ACK error so silent retry */
+		rc = 1;
+
+		switch (op) {
+		case CY_SPI_WR_OP:
+			_cyttsp4_spi_pr_buf(ts, wr_hdr_buf,
+				CY_SPI_WR_HEADER_BYTES,
+				"spi_wr_buf HEAD");
+			if (buf)
+				_cyttsp4_spi_pr_buf(ts, buf,
+					length, "spi_wr_buf DATA");
+			break;
+
+		case CY_SPI_RD_OP:
+			_cyttsp4_spi_pr_buf(ts, rd_hdr_buf,
+				CY_SPI_RD_HEADER_BYTES, "spi_rd_buf HEAD");
+			_cyttsp4_spi_pr_buf(ts, buf, length,
+				"spi_rd_buf DATA");
+			break;
+
+		default:
+			/*
+			 * should not get here due to error check
+			 * in first switch
+			 */
+			break;
+		}
+	}
+
+cyttsp4_spi_xfer_exit:
+	return rc;
+}
+
+static s32 cyttsp4_spi_read_block_data(struct cyttsp4_spi *ts, u16 addr,
+				int length, void *data, int max_xfer)
+{
+	int rc = -EINVAL;
+	int retry = 0;
+	int trans_len;
+	struct device *dev = &ts->client->dev;
+
+	dev_vdbg(dev, "%s: Enter\n", __func__);
+
+	while (length > 0) {
+		trans_len = min(length, max_xfer);
+
+		/* Write address */
+		rc = cyttsp4_spi_xfer(CY_SPI_WR_OP, ts, addr, NULL, 0);
+		if (rc < 0) {
+			dev_err(dev, "%s: Fail write address r=%d\n",
+				__func__, rc);
+			return rc;
+		}
+
+		/* Read data */
+		rc = cyttsp4_spi_xfer(CY_SPI_RD_OP, ts, addr, data, trans_len);
+		if (rc < 0) {
+			dev_err(dev, "%s: Fail read r=%d\n", __func__, rc);
+			goto exit;
+		} else if (rc > 0) {
+			/* Perform retry or fail */
+			if (retry++ < CY_SPI_NUM_RETRY) {
+				dev_dbg(dev, "%s: ACK error, retry %d\n",
+					__func__, retry);
+				continue;
+			} else {
+				dev_err(dev, "%s: ACK error\n", __func__);
+				rc = -EIO;
+				goto exit;
+			}
+		}
+
+		length -= trans_len;
+		data += trans_len;
+		addr += trans_len;
+	}
+exit:
+	return rc;
+}
+
+static s32 cyttsp4_spi_write_block_data(struct cyttsp4_spi *ts, u16 addr,
+				int length, const void *data, int max_xfer)
+{
+	int rc = -EINVAL;
+	int retry = 0;
+	int trans_len;
+	struct device *dev = &ts->client->dev;
+
+	dev_vdbg(dev, "%s: Enter\n", __func__);
+
+	while (length > 0) {
+		trans_len = min(length, max_xfer);
+
+		rc = cyttsp4_spi_xfer(CY_SPI_WR_OP, ts, addr, (void *)data,
+				trans_len);
+		if (rc < 0) {
+			dev_err(dev, "%s: Fail write r=%d\n", __func__, rc);
+			goto exit;
+		} else if (rc > 0) {
+			/* Perform retry or fail */
+			if (retry++ < CY_SPI_NUM_RETRY) {
+				dev_dbg(dev, "%s: ACK error, retry %d\n",
+					__func__, retry);
+				continue;
+			} else {
+				dev_err(dev, "%s: ACK error\n", __func__);
+				rc = -EIO;
+				goto exit;
+			}
+		}
+
+		length -= trans_len;
+		data += trans_len;
+		addr += trans_len;
+	}
+exit:
+	return rc;
+}
+
+static int cyttsp4_spi_write(struct cyttsp4_adapter *adap, u16 addr,
+		const void *buf, int size, int max_xfer)
+{
+	struct cyttsp4_spi *ts = dev_get_drvdata(adap->dev);
+	int rc;
+
+	pm_runtime_get_noresume(adap->dev);
+	mutex_lock(&ts->lock);
+	rc = cyttsp4_spi_write_block_data(ts, addr, size, buf, max_xfer);
+	mutex_unlock(&ts->lock);
+	pm_runtime_put_noidle(adap->dev);
+
+	return rc;
+}
+
+static int cyttsp4_spi_read(struct cyttsp4_adapter *adap, u16 addr,
+		void *buf, int size, int max_xfer)
+{
+	struct cyttsp4_spi *ts = dev_get_drvdata(adap->dev);
+	int rc;
+
+	pm_runtime_get_noresume(adap->dev);
+	mutex_lock(&ts->lock);
+	rc = cyttsp4_spi_read_block_data(ts, addr, size, buf, max_xfer);
+	mutex_unlock(&ts->lock);
+	pm_runtime_put_noidle(adap->dev);
+
+	return rc;
+}
+
+static struct cyttsp4_ops ops = {
+	.write = cyttsp4_spi_write,
+	.read = cyttsp4_spi_read,
+};
+
+static int __devinit cyttsp4_spi_probe(struct spi_device *spi)
+{
+	struct cyttsp4_spi *ts_spi;
+	int rc = 0;
+	struct device *dev = &spi->dev;
+	char const *adap_id = dev_get_platdata(dev);
+	char const *id;
+
+	dev_dbg(dev, "%s: Probing ...\n", __func__);
+
+	spi->bits_per_word = CY_SPI_BITS_PER_WORD;
+	spi->mode = SPI_MODE_0;
+
+	rc = spi_setup(spi);
+	if (rc < 0) {
+		dev_err(dev, "%s: SPI setup error %d\n", __func__, rc);
+		return rc;
+	}
+
+	ts_spi = kzalloc(sizeof(*ts_spi), GFP_KERNEL);
+	if (ts_spi == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto error_alloc_data_failed;
+	}
+
+	mutex_init(&ts_spi->lock);
+	ts_spi->client = spi;
+	dev_set_drvdata(&spi->dev, ts_spi);
+
+	if (adap_id)
+		id = adap_id;
+	else
+		id = CYTTSP4_SPI_NAME;
+
+	dev_dbg(dev, "%s: add adap='%s' (CYTTSP4_SPI_NAME=%s)\n", __func__, id,
+		CYTTSP4_SPI_NAME);
+
+	pm_runtime_enable(&spi->dev);
+
+	rc = cyttsp4_add_adapter(id, &ops, dev);
+	if (rc) {
+		dev_err(dev, "%s: Error on probe %s\n", __func__,
+			CYTTSP4_SPI_NAME);
+		goto add_adapter_err;
+	}
+
+	dev_info(dev, "%s: Successful prob %s\n", __func__, CYTTSP4_SPI_NAME);
+
+	return 0;
+
+add_adapter_err:
+	pm_runtime_disable(&spi->dev);
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(ts_spi);
+error_alloc_data_failed:
+	return rc;
+}
+
+static int __devexit cyttsp4_spi_remove(struct spi_device *spi)
+{
+	struct device *dev = &spi->dev;
+	struct cyttsp4_spi *ts_spi = dev_get_drvdata(dev);
+	char const *adap_id = dev_get_platdata(dev);
+	char const *id;
+
+	if (adap_id)
+		id = adap_id;
+	else
+		id = CYTTSP4_SPI_NAME;
+
+	dev_info(dev, "%s\n", __func__);
+	cyttsp4_del_adapter(id);
+	pm_runtime_disable(&spi->dev);
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(ts_spi);
+	return 0;
+}
+
+static struct spi_driver cyttsp4_spi_driver = {
+	.driver = {
+		.name = CYTTSP4_SPI_NAME,
+		.bus = &spi_bus_type,
+		.owner = THIS_MODULE,
+	},
+	.probe = cyttsp4_spi_probe,
+	.remove = __devexit_p(cyttsp4_spi_remove),
+};
+
+static int __init cyttsp4_spi_init(void)
+{
+	int err;
+
+	err = spi_register_driver(&cyttsp4_spi_driver);
+	pr_info("%s: Cypress TTSP SPI Touchscreen Driver (Built %s) rc=%d\n",
+		 __func__, CY_DRIVER_DATE, err);
+
+	return err;
+}
+module_init(cyttsp4_spi_init);
+
+static void __exit cyttsp4_spi_exit(void)
+{
+	spi_unregister_driver(&cyttsp4_spi_driver);
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_spi_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard Product SPI driver");
+MODULE_AUTHOR("Aleksej Makarov <aleksej.makarov@sonyericsson.com>");
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_spi.h b/drivers/input/touchscreen/cyttsp4/cyttsp4_spi.h
new file mode 100755
index 0000000..7cd6f6a
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_spi.h
@@ -0,0 +1,37 @@
+/*
+ * cyttsp4_spi.h
+ * Cypress TrueTouch(TM) Standard Product V4 SPI Driver module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ * Copyright (C) 2011 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_SPI_H
+#define _LINUX_CYTTSP4_SPI_H
+
+#define CYTTSP4_SPI_NAME "cyttsp4_spi_adapter"
+
+#endif /* _LINUX_CYTTSP4_SPI_H */
diff --git a/drivers/input/touchscreen/cyttsp4/cyttsp4_test_device_access_api.c b/drivers/input/touchscreen/cyttsp4/cyttsp4_test_device_access_api.c
new file mode 100755
index 0000000..7a82c65
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/cyttsp4_test_device_access_api.c
@@ -0,0 +1,196 @@
+/*
+ * cyttsp4_test_device_access_api.c
+ * Cypress TrueTouch(TM) Standard Product V4 Device Access API test module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2012 Cypress Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/module.h>
+#include "cyttsp4_device_access-api.h"
+
+#define CONFIG_VER_OFFSET	8
+#define CONFIG_VER_SIZE		2
+
+#define BUFFER_SIZE		256
+
+static u8 buffer[BUFFER_SIZE];
+static int active_refresh_interval;
+
+static int __init cyttsp4_test_device_access_api_init(void)
+{
+	u16 config_ver;
+	int i;
+	int j;
+	int value;
+	int rc;
+
+	pr_info("%s: Enter\n", __func__);
+
+	/*
+	 * CASE 1 - Get CONFIG_VER and update it
+	 */
+
+	/*
+	 * Get CONFIG_VER
+	 * Group 6 read requires to fetch from offset to the end of row
+	 * The return buffer should be at least read config block command
+	 * return size + config row size bytes
+	 */
+	rc = cyttsp4_device_access_read_command(NULL,
+			GRPNUM_TOUCH_CONFIG, CONFIG_VER_OFFSET,
+			buffer, BUFFER_SIZE);
+	if (rc < 0) {
+		pr_err("%s: cyttsp4_device_access_read_command failed, rc=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+	pr_info("%s: cyttsp4_device_access_read_command returned %d bytes\n",
+		__func__, rc);
+
+	/* Calculate CONFIG_VER (Little Endian) */
+	config_ver = buffer[0] + (buffer[1] << 8);
+
+	pr_info("%s: Old CONFIG_VER:%04X New CONFIG_VER:%04X\n", __func__,
+		config_ver, config_ver + 1);
+
+	config_ver++;
+
+	/* Store CONFIG_VER (Little Endian) */
+	buffer[0] = config_ver & 0xFF;
+	buffer[1] = config_ver >> 8;
+
+	/*
+	 * Set CONFIG_VER
+	 * Group 6 write supports writing arbitrary number of bytes
+	 */
+	rc = cyttsp4_device_access_write_command(NULL,
+			GRPNUM_TOUCH_CONFIG, CONFIG_VER_OFFSET,
+			buffer, CONFIG_VER_SIZE);
+	if (rc < 0) {
+		pr_err("%s: cyttsp4_device_access_write_command failed, rc=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+	/*
+	 * CASE 2 - Get Operational mode parameters
+	 */
+	for (i = OP_PARAM_ACTIVE_DISTANCE;
+			i <= OP_PARAM_ACTIVE_LOOK_FOR_TOUCH_INTERVAL; i++) {
+		buffer[0] = OP_CMD_GET_PARAMETER;
+		buffer[1] = i;
+
+		rc = cyttsp4_device_access_write_command(NULL,
+				GRPNUM_OP_COMMAND, 0, buffer, 2);
+		if (rc < 0) {
+			pr_err("%s: cyttsp4_device_access_write_command failed, rc=%d\n",
+				__func__, rc);
+			goto exit;
+		}
+
+		/*
+		 * The return buffer should be at least
+		 * number of command data registers + 1
+		 */
+		rc = cyttsp4_device_access_read_command(NULL,
+				GRPNUM_OP_COMMAND, 0, buffer, 7);
+		if (rc < 0) {
+			pr_err("%s: cyttsp4_device_access_read_command failed, rc=%d\n",
+				__func__, rc);
+			goto exit;
+		}
+
+		if (buffer[0] != OP_CMD_GET_PARAMETER || buffer[1] != i) {
+			pr_err("%s: Invalid response\n", __func__);
+			rc = -EINVAL;
+			goto exit;
+		}
+
+		/*
+		 * Get value stored starting at &buffer[3] whose
+		 * size (in bytes) is specified at buffer[2]
+		 */
+		value = 0;
+		j = 0;
+		while (buffer[2]--)
+			value += buffer[3 + j++] << (8 * buffer[2]);
+
+		/* Store Active mode refresh interval to restore */
+		if (i == OP_PARAM_REFRESH_INTERVAL)
+			active_refresh_interval = value;
+
+		pr_info("%s: Parameter %02X: %d\n", __func__, i, value);
+	}
+
+	/*
+	 * CASE 3 - Set Active mode refresh interval to 200 ms
+	 */
+	buffer[0] = OP_CMD_SET_PARAMETER; /* Set Parameter */
+	buffer[1] = OP_PARAM_REFRESH_INTERVAL; /* Refresh Interval parameter */
+	buffer[2] = 1; /* Parameter length - 1 byte */
+	buffer[3] = 200; /* 200 ms */
+
+	rc = cyttsp4_device_access_write_command(NULL,
+			GRPNUM_OP_COMMAND, 0, buffer, 4);
+	if (rc < 0) {
+		pr_err("%s: cyttsp4_device_access_write_command failed, rc=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+exit:
+	return 0;
+}
+module_init(cyttsp4_test_device_access_api_init);
+
+static void __exit cyttsp4_test_device_access_api_exit(void)
+{
+	int rc;
+
+	pr_info("%s: Exit\n", __func__);
+
+	/*
+	 * CASE 4 - Restore Active mode refresh interval to original
+	 */
+	if (active_refresh_interval) {
+		buffer[0] = OP_CMD_SET_PARAMETER; /* Set Parameter */
+		buffer[1] = OP_PARAM_REFRESH_INTERVAL;
+					/* Refresh Interval parameter */
+		buffer[2] = 1; /* Parameter length - 1 byte */
+		buffer[3] = (u8)active_refresh_interval;
+
+		rc = cyttsp4_device_access_write_command(NULL,
+				GRPNUM_OP_COMMAND, 0, buffer, 4);
+		if (rc < 0) {
+			pr_err("%s: cyttsp4_device_access_write_command failed, rc=%d\n",
+				__func__, rc);
+		}
+	}
+}
+module_exit(cyttsp4_test_device_access_api_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard touchscreen device access API tester");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cyttsp4/zte_ctp.c b/drivers/input/touchscreen/cyttsp4/zte_ctp.c
new file mode 100755
index 0000000..4d5821d
--- /dev/null
+++ b/drivers/input/touchscreen/cyttsp4/zte_ctp.c
@@ -0,0 +1,561 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2012, ZTE. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : zte-ctp.c
+  Version        : Initial Draft
+  Author         : LiuYongfeng
+  Created       : 2012/10/6
+  Last Modified :
+  Description   : This is touchscreen driver board file
+  Function List :
+  History       :
+  1.Date        : 2012/10/6
+    Author      : LiuYongfeng
+    Modification: Created file
+
+*****************************************************************************/
+
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/bootmem.h>
+#include <linux/ion.h>
+#include <asm/mach-types.h>
+#include <mach/msm_memtypes.h>
+#include <mach/board.h>
+#include <mach/gpiomux.h>
+#include <mach/ion.h>
+#include <linux/regulator/consumer.h>
+#include <mach/msm_bus_board.h>
+#include <mach/socinfo.h>
+#include <mach/irqs.h>
+
+#include <linux/i2c.h>
+
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_TMA463
+/* cyttsp */
+#include "cyttsp4_bus.h"
+#include "cyttsp4_core.h"
+#include "cyttsp4_btn.h"
+#include "cyttsp4_mt.h"
+#include "cyttsp4_regs.h"
+#include "cyttsp4_proximity.h"
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+#include "cyttsp4_img.h"
+static struct cyttsp4_touch_firmware cyttsp4_firmware = {
+	.img = cyttsp4_img,
+	.size = ARRAY_SIZE(cyttsp4_img),
+	.ver = cyttsp4_ver,
+	.vsize = ARRAY_SIZE(cyttsp4_ver),
+};
+#else
+static struct cyttsp4_touch_firmware cyttsp4_firmware = {
+	.img = NULL,
+	.size = 0,
+	.ver = NULL,
+	.vsize = 0,
+};
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_TTCONFIG_UPGRADE
+static struct touch_settings cyttsp4_sett_param_regs = {
+	.data = (uint8_t *)&cyttsp4_param_regs[0],
+	.size = ARRAY_SIZE(cyttsp4_param_regs),
+	.tag = 0,
+};
+
+static struct touch_settings cyttsp4_sett_param_size = {
+	.data = (uint8_t *)&cyttsp4_param_size[0],
+	.size = ARRAY_SIZE(cyttsp4_param_size),
+	.tag = 0,
+};
+
+static struct cyttsp4_touch_config cyttsp4_ttconfig = {
+	.param_regs = &cyttsp4_sett_param_regs,
+	.param_size = &cyttsp4_sett_param_size,
+	.fw_ver = ttconfig_fw_ver,
+	.fw_vsize = ARRAY_SIZE(ttconfig_fw_ver),
+};
+#else
+static struct cyttsp4_touch_config cyttsp4_ttconfig = {
+	.param_regs = NULL,
+	.param_size = NULL,
+	.fw_ver = NULL,
+	.fw_vsize = 0,
+};
+#endif
+
+static struct cyttsp4_loader_platform_data _cyttsp4_loader_platform_data = {
+	.fw = &cyttsp4_firmware,
+	.ttconfig = &cyttsp4_ttconfig,
+	.flags = CY_LOADER_FLAG_NONE,
+};
+
+#define CYTTSP4_USE_I2C
+/* #define CYTTSP4_USE_SPI */
+
+#ifdef CYTTSP4_USE_I2C
+#define CYTTSP4_I2C_NAME "cyttsp4_i2c_adapter"
+#define CYTTSP4_I2C_TCH_ADR 0x24
+#define CYTTSP4_LDR_TCH_ADR 0x24
+#define CYTTSP4_I2C_IRQ_GPIO 61 /* J6.9, C19, GPMC_AD14/GPIO_38 */
+#define CYTTSP4_I2C_RST_GPIO 60 /* J6.10, D18, GPMC_AD13/GPIO_37 */
+#endif
+
+#ifdef CYTTSP4_USE_SPI
+#define CYTTSP4_SPI_NAME "cyttsp4_spi_adapter"
+/* Change GPIO numbers when using I2C and SPI at the same time
+ * Following is possible alternative:
+ * IRQ: J6.17, C18, GPMC_AD12/GPIO_36
+ * RST: J6.24, D17, GPMC_AD11/GPIO_35
+ */
+#define CYTTSP4_SPI_IRQ_GPIO 38 /* J6.9, C19, GPMC_AD14/GPIO_38 */
+#define CYTTSP4_SPI_RST_GPIO 37 /* J6.10, D18, GPMC_AD13/GPIO_37 */
+#endif
+
+/* Check GPIO numbers if both I2C and SPI are enabled */
+#if defined(CYTTSP4_USE_I2C) && defined(CYTTSP4_USE_SPI)
+#if CYTTSP4_I2C_IRQ_GPIO == CYTTSP4_SPI_IRQ_GPIO || \
+	CYTTSP4_I2C_RST_GPIO == CYTTSP4_SPI_RST_GPIO
+#error "GPIO numbers should be different when both I2C and SPI are on!"
+#endif
+#endif
+
+#ifdef CONFIG_CYTTSP4_5P5_INCH_OTG_GW //goworld 5.5 inch NX505J
+#define CY_MAXX 1080
+#define CY_MAXY 1920
+#define CYTTSP4_FIRMEARE_VERSION    0x0806
+#endif
+
+#ifdef CONFIG_CYTTSP4_5P0_INCH_OTG_GW //goworld 5 inch otg tp for NX501
+#define CY_MAXX 1080
+#define CY_MAXY 1920
+#define CYTTSP4_FIRMEARE_VERSION    0x030E
+#endif
+
+#ifdef CONFIG_CYTTSP4_4P7_INCH_OTG_GW
+#define CY_MAXX 720
+#define CY_MAXY 1280
+#define CYTTSP4_FIRMEARE_VERSION    0x0000
+#endif
+#define CY_MINX 0
+#define CY_MINY 0
+
+#define CY_ABS_MIN_X CY_MINX
+#define CY_ABS_MIN_Y CY_MINY
+#define CY_ABS_MAX_X CY_MAXX
+#define CY_ABS_MAX_Y CY_MAXY
+#define CY_ABS_MIN_P 0
+#define CY_ABS_MAX_P 255
+#define CY_ABS_MIN_W 0
+#define CY_ABS_MAX_W 255
+#define CY_PROXIMITY_MIN_VAL	0
+#define CY_PROXIMITY_MAX_VAL	1
+
+#define CY_ABS_MIN_T 0
+
+#define CY_ABS_MAX_T 15
+
+#define CY_IGNORE_VALUE 0xFFFF
+
+static int cyttsp4_xres(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev)
+{
+	int rst_gpio = pdata->rst_gpio;
+	int rc = 0;
+	
+	gpio_set_value(rst_gpio, 1);
+	msleep(20);
+	gpio_set_value(rst_gpio, 0);
+	msleep(40);
+	gpio_set_value(rst_gpio, 1);
+	msleep(20);
+	dev_dbg(dev,
+		"%s: RESET CYTTSP gpio=%d r=%d\n", __func__,
+		pdata->rst_gpio, rc);
+	return rc;
+}
+
+static int cyttsp4_init(struct cyttsp4_core_platform_data *pdata,
+		int on, struct device *dev)
+{
+	int rst_gpio = pdata->rst_gpio;
+	int irq_gpio = pdata->irq_gpio;
+	int rc = 0;
+
+	if (!pdata) {
+		printk("%s NULL Pointer detected!\n",__func__);
+		WARN_ON(1);
+		return -EINVAL;
+	}
+	
+	if (on) {
+        rc = gpio_request(rst_gpio, "CYTTSP4_I2C_RST_GPIO");
+		if (rc < 0) {
+			pr_err("Failed request CYTTSP4_I2C_RST_GPIO.\n");
+			return rc;
+		}
+		gpio_tlmm_config(GPIO_CFG(rst_gpio, 0, GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA),GPIO_CFG_ENABLE);
+		gpio_set_value(rst_gpio,1);
+        
+		rc = gpio_request(irq_gpio, "CYTTSP4_I2C_IRQ_GPIO");
+		if (rc < 0) {
+			pr_err("Failed request CYTTSP4_I2C_IRQ_GPIO.\n");
+			return rc;
+		}
+		gpio_tlmm_config(GPIO_CFG(irq_gpio, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_10MA),GPIO_CFG_ENABLE);
+		
+	}else {
+		gpio_free(rst_gpio);
+		gpio_free(irq_gpio);
+	}
+
+	dev_dbg(dev,
+		"%s: INIT CYTTSP RST gpio=%d and IRQ gpio=%d r=%d\n",
+		__func__, rst_gpio, irq_gpio, rc);
+	return rc;
+}
+
+static int cyttsp4_wakeup(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev, atomic_t *ignore_irq)
+{
+	int irq_gpio = pdata->irq_gpio;
+	int rc = 0;
+
+	if (ignore_irq)
+		atomic_set(ignore_irq, 1);
+	rc = gpio_direction_output(irq_gpio, 0);
+	if (rc < 0) {
+		if (ignore_irq)
+			atomic_set(ignore_irq, 0);
+		dev_err(dev,
+			"%s: Fail set output gpio=%d\n",
+			__func__, irq_gpio);
+		goto wakeup_failed;
+	} else {
+		msleep(2);
+		rc = gpio_direction_input(irq_gpio);
+		if (ignore_irq)
+			atomic_set(ignore_irq, 0);
+		if (rc < 0) {
+			dev_err(dev,
+				"%s: Fail set input gpio=%d\n",
+				__func__, irq_gpio);
+			goto wakeup_failed;
+		}
+	}
+	return rc;
+wakeup_failed:
+	dev_err(dev,
+	"%s: WAKEUP CYTTSP failed, gpio=%d r=%d\n", __func__,
+	irq_gpio, rc);
+	return rc;
+}
+
+static int cyttsp4_sleep(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev, atomic_t *ignore_irq)
+{
+	return 0;
+}
+
+static int cyttsp4_power(struct cyttsp4_core_platform_data *pdata,
+		int on, struct device *dev, atomic_t *ignore_irq)
+{
+	if (on)
+		return cyttsp4_wakeup(pdata, dev, ignore_irq);
+
+	return cyttsp4_sleep(pdata, dev, ignore_irq);
+}
+
+static int cyttsp4_irq_stat(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev)
+{
+	return gpio_get_value(pdata->irq_gpio);
+}
+
+#ifdef CYTTSP4_DETECT_HW
+static int cyttsp4_detect(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev, cyttsp4_platform_read read)
+{
+	int retry = 3;
+	int rc;
+	char buf[1];
+
+	while (retry--) {
+		/* Perform reset, wait for 100 ms and perform read */
+		dev_vdbg(dev, "%s: Performing a reset\n", __func__);
+		pdata->xres(pdata, dev);
+		msleep(100);
+		rc = read(dev, 0, buf, 1);
+		if (!rc)
+			return 0;
+
+		dev_vdbg(dev, "%s: Read unsuccessful, try=%d\n",
+			__func__, 3 - retry);
+	}
+
+	return rc;
+}
+#endif
+
+static int cyttsp_check_version(struct cyttsp4_sysinfo *si)
+{
+    u16 fw_ver;
+    u16 fw_ver_new;
+    
+	if (!si) {
+		printk("%s NULL Pointer detected!\n",__func__);
+		WARN_ON(1);
+		return -EINVAL;
+	}
+    
+    si->fw_ver_new = CYTTSP4_FIRMEARE_VERSION;
+#if 0
+	/*Discard 0x0309 0x030A 0x030C,back to 0x0308 */
+	if (si->fw_ver == 0x0309 || si->fw_ver == 0x030A || \
+		si->fw_ver == 0x030C|| si->fw_ver == 0x030D)
+		return 1;
+#endif
+	fw_ver = si->fw_ver & 0x000F; 
+    fw_ver_new = si->fw_ver_new & 0x000F;
+
+	if ((si->fw_ver >> 4) == (si->fw_ver_new >> 4)) {
+        if (fw_ver_new  == fw_ver) {/*equal*/
+        	return 0;
+    	}
+        else if (fw_ver_new > fw_ver) {
+    		return 1;
+    	}
+        else {
+    	    return -1;
+        }
+	}
+    else
+    {
+		printk("%s: FW didn't match, will NOT upgarde!\n", __func__);
+		return -1;
+    }
+}
+
+
+/* Button to keycode conversion */
+static u16 cyttsp4_btn_keys[] = {
+	/* use this table to map buttons to keycodes (see input.h) */
+	KEY_MENU, 		/*139*/
+	KEY_HOME,		/*102*/
+	KEY_BACK,		/*158*/
+//	KEY_HOME,		/* 102 */
+//	KEY_MENU,		/* 139 */
+//	KEY_BACK,		/* 158 */
+//	KEY_SEARCH,		/* 217 */
+	KEY_VOLUMEDOWN,		/* 114 */
+	KEY_VOLUMEUP,		/* 115 */
+	KEY_CAMERA,		/* 212 */
+	KEY_POWER		/* 116 */
+};
+
+static struct touch_settings cyttsp4_sett_btn_keys = {
+	.data = (uint8_t *)&cyttsp4_btn_keys[0],
+	.size = ARRAY_SIZE(cyttsp4_btn_keys),
+	.tag = 0,
+};
+
+static struct cyttsp4_core_platform_data _cyttsp4_core_platform_data = {
+	.irq_gpio = CYTTSP4_I2C_IRQ_GPIO,
+	.rst_gpio = CYTTSP4_I2C_RST_GPIO,
+	.xres = cyttsp4_xres,
+	.init = cyttsp4_init,
+	.power = cyttsp4_power,
+#ifdef CYTTSP4_DETECT_HW
+	.detect = cyttsp4_detect,
+#endif
+	.irq_stat = cyttsp4_irq_stat,
+	.check_version = cyttsp_check_version,
+	.sett = {
+		NULL,	/* Reserved */
+		NULL,	/* Command Registers */
+		NULL,	/* Touch Report */
+		NULL,	/* Cypress Data Record */
+		NULL,	/* Test Record */
+		NULL,	/* Panel Configuration Record */
+		NULL,	/* &cyttsp4_sett_param_regs, */
+		NULL,	/* &cyttsp4_sett_param_size, */
+		NULL,	/* Reserved */
+		NULL,	/* Reserved */
+		NULL,	/* Operational Configuration Record */
+		NULL, /* &cyttsp4_sett_ddata, *//* Design Data Record */
+		NULL, /* &cyttsp4_sett_mdata, *//* Manufacturing Data Record */
+		NULL,	/* Config and Test Registers */
+		&cyttsp4_sett_btn_keys,	/* button-to-keycode table */
+	},
+	.loader_pdata = &_cyttsp4_loader_platform_data,
+	.flags = CY_CORE_FLAG_WAKE_ON_GESTURE,
+	.easy_wakeup_gesture = CY_CORE_EWG_NONE,
+//	.easy_wakeup_gesture = CY_CORE_EWG_TAP_TAP,
+	/* ZTEMT Modify by luochangyang 2013.08.08
+	.easy_wakeup_gesture = CY_CORE_EWG_TAP_TAP
+		| CY_CORE_EWG_TWO_FINGER_SLIDE,
+      */
+};
+
+static struct cyttsp4_core_info cyttsp4_core_info __initdata = {
+	.name = CYTTSP4_CORE_NAME,
+	.id = "main_ttsp_core",
+	.adap_id = CYTTSP4_I2C_NAME,
+	.platform_data = &_cyttsp4_core_platform_data,
+};
+
+static const uint16_t cyttsp4_abs[] = {
+	ABS_MT_POSITION_X, CY_ABS_MIN_X, CY_ABS_MAX_X, 0, 0,
+	ABS_MT_POSITION_Y, CY_ABS_MIN_Y, CY_ABS_MAX_Y, 0, 0,
+	ABS_MT_PRESSURE, CY_ABS_MIN_P, CY_ABS_MAX_P, 0, 0,
+	CY_IGNORE_VALUE, CY_ABS_MIN_W, CY_ABS_MAX_W, 0, 0,
+	ABS_MT_TRACKING_ID, CY_ABS_MIN_T, CY_ABS_MAX_T, 0, 0,
+	ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0,
+	ABS_MT_TOUCH_MINOR, 0, 255, 0, 0,
+	ABS_MT_ORIENTATION, -128, 127, 0, 0,
+};
+
+struct touch_framework cyttsp4_framework = {
+	.abs = (uint16_t *)&cyttsp4_abs[0],
+	.size = ARRAY_SIZE(cyttsp4_abs),
+	.enable_vkeys = 0,
+};
+
+static struct cyttsp4_mt_platform_data _cyttsp4_mt_platform_data = {
+	.frmwrk = &cyttsp4_framework,
+	.flags = 0x00,//0x38,yfliu
+	.inp_dev_name = CYTTSP4_MT_NAME,
+	.vkeys_x = CY_VKEYS_X,
+	.vkeys_y = CY_VKEYS_Y,
+};
+
+struct cyttsp4_device_info cyttsp4_mt_info __initdata = {
+	.name = CYTTSP4_MT_NAME,
+	.core_id = "main_ttsp_core",
+	.platform_data = &_cyttsp4_mt_platform_data,
+};
+
+static struct cyttsp4_btn_platform_data _cyttsp4_btn_platform_data = {
+	.inp_dev_name = CYTTSP4_BTN_NAME,
+};
+
+struct cyttsp4_device_info cyttsp4_btn_info __initdata = {
+	.name = CYTTSP4_BTN_NAME,
+	.core_id = "main_ttsp_core",
+	.platform_data = &_cyttsp4_btn_platform_data,
+};
+
+static const uint16_t cyttsp4_prox_abs[] = {
+	ABS_DISTANCE, CY_PROXIMITY_MIN_VAL, CY_PROXIMITY_MAX_VAL, 0, 0,
+};
+
+struct touch_framework cyttsp4_prox_framework = {
+	.abs = (uint16_t *)&cyttsp4_prox_abs[0],
+	.size = ARRAY_SIZE(cyttsp4_prox_abs),
+};
+
+static struct cyttsp4_proximity_platform_data
+		_cyttsp4_proximity_platform_data = {
+	.frmwrk = &cyttsp4_prox_framework,
+	.inp_dev_name = CYTTSP4_PROXIMITY_NAME,
+};
+
+struct cyttsp4_device_info cyttsp4_proximity_info __initdata = {
+	.name = CYTTSP4_PROXIMITY_NAME,
+	.core_id = "main_ttsp_core",
+	.platform_data = &_cyttsp4_proximity_platform_data,
+};
+
+#ifdef CYTTSP4_VIRTUAL_KEYS
+static ssize_t cyttps4_virtualkeys_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf,
+		__stringify(EV_KEY) ":"
+		__stringify(KEY_BACK) ":1360:90:160:180"
+		":" __stringify(EV_KEY) ":"
+		__stringify(KEY_MENU) ":1360:270:160:180"
+		":" __stringify(EV_KEY) ":"
+		__stringify(KEY_HOME) ":1360:450:160:180"
+		":" __stringify(EV_KEY) ":"
+		__stringify(KEY_SEARCH) ":1360:630:160:180"
+		"\n");
+}
+
+static struct kobj_attribute cyttsp4_virtualkeys_attr = {
+	.attr = {
+		.name = "virtualkeys.cyttsp4_mt",
+		.mode = S_IRUGO,
+	},
+	.show = &cyttps4_virtualkeys_show,
+};
+
+static struct attribute *cyttsp4_properties_attrs[] = {
+	&cyttsp4_virtualkeys_attr.attr,
+	NULL
+};
+
+static struct attribute_group cyttsp4_properties_attr_group = {
+	.attrs = cyttsp4_properties_attrs,
+};
+#endif
+static int __init cyttsp4_i2c_device_init(void)
+{
+	int ret = 0;
+#ifdef CYTTSP4_VIRTUAL_KEYS
+	struct kobject *properties_kobj;
+#endif
+    pr_debug("%s: Start...\n", __func__);
+
+	/* Register core and devices */
+	cyttsp4_register_core_device(&cyttsp4_core_info);
+    cyttsp4_register_device(&cyttsp4_mt_info);
+    cyttsp4_register_device(&cyttsp4_btn_info);
+    cyttsp4_register_device(&cyttsp4_proximity_info);
+
+#ifdef CYTTSP4_VIRTUAL_KEYS
+	properties_kobj = kobject_create_and_add("board_properties", NULL);
+	if (properties_kobj)
+		ret = sysfs_create_group(properties_kobj,
+				&cyttsp4_properties_attr_group);
+	if (!properties_kobj || ret)
+		pr_err("%s: failed to create board_properties\n", __func__);
+#endif
+    return ret;
+}
+
+#ifndef CONFIG_OF
+static struct i2c_board_info cypress_tma463_ts_i2c_info[] __initdata= {
+	{
+		I2C_BOARD_INFO(CYTTSP4_I2C_NAME, CYTTSP4_I2C_TCH_ADR),
+		.irq = MSM_GPIO_TO_INT(CYTTSP4_I2C_IRQ_GPIO),
+		.platform_data = CYTTSP4_I2C_NAME,
+	},
+};
+#endif
+#endif
+
+static int  __init zte_init_ctp(void)
+{
+	int ret = 0;
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_TMA463
+	ret = cyttsp4_i2c_device_init();
+
+#ifndef CONFIG_OF
+	ret = i2c_register_board_info(2,
+								  cypress_tma463_ts_i2c_info, 
+								  ARRAY_SIZE(cypress_tma463_ts_i2c_info));
+#endif
+#endif
+	return ret;
+}
+
+arch_initcall(zte_init_ctp);
+
diff --git a/drivers/input/touchscreen/synaptics_dsx/Kconfig b/drivers/input/touchscreen/synaptics_dsx/Kconfig
new file mode 100755
index 0000000..021a6fc
--- /dev/null
+++ b/drivers/input/touchscreen/synaptics_dsx/Kconfig
@@ -0,0 +1,108 @@
+#
+# Synaptics DSX touchscreen driver configuration
+#
+menuconfig ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX
+	bool "Synaptics DSX touchscreen"
+	default n
+	help
+	  Say Y here if you have a Synaptics DSX touchscreen connected
+	  to your system.
+
+	  If unsure, say N.
+
+if ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX
+
+choice
+	prompt "Synaptics Touch Screen Size of the Module"
+	
+config ZTEMT_TOUCHSCREEN_SYNAPTICS_S3208
+	bool "S3208 for NX503A NX505J NX40X NX403A"
+	help
+	  This option enables support 5.0 inch otg tp.
+
+config ZTEMT_TOUCHSCREEN_SYNAPTICS_S3208_3keys
+    bool "3 keys for NX505J"
+    depends on ZTEMT_TOUCHSCREEN_SYNAPTICS_S3208
+	
+config ZTEMT_TOUCHSCREEN_SYNAPTICS_S3208_5keys
+    bool "5 keys for NX503A NX40X NX403A"
+    depends on ZTEMT_TOUCHSCREEN_SYNAPTICS_S3208
+
+config ZTEMT_TOUCHSCREEN_SYNAPTICS_S3508
+	bool "S3508 for NX504J NX506J"
+	help
+	  This option enables support 5.5 inch otg tp.
+endchoice
+
+choice
+	default ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_I2C
+	prompt "Synaptics DSX touchscreen bus interface"
+config ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_I2C
+	bool "I2C"
+	depends on I2C
+config ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_SPI
+	bool "SPI"
+	depends on SPI_MASTER
+endchoice
+
+config ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_CORE
+	tristate "Synaptics DSX core driver module"
+	depends on ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_I2C || ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_SPI
+	help
+	  Say Y here to enable basic touch reporting functionalities.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called synaptics_dsx_core.
+
+config ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_RMI_DEV
+	tristate "Synaptics DSX touchscreen RMI device module"
+	depends on ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_CORE
+	help
+	  Say Y here to enable support for direct RMI register access.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called synaptics_dsx_rmi_dev.
+
+config ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_FW_UPDATE
+	tristate "Synaptics DSX touchscreen firmware update module"
+	depends on ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_CORE
+	help
+	  Say Y here to enable support for carrying out firmware update.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called synaptics_dsx_fw_update.
+
+config ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_TEST_REPORTING
+	tristate "Synaptics DSX touchscreen test reporting module"
+	depends on ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_CORE
+	help
+	  Say Y here to enable support for retrieving self-test reports.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called synaptics_dsx_test_reporting.
+
+config ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_PROXIMITY
+	tristate "Synaptics DSX touchscreen proximity module"
+	depends on ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_CORE
+	help
+	  Say Y here to enable support for proximity functionalities.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called synaptics_dsx_proximity.
+
+config ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_DEBUG
+	bool "Enable debug output"
+	depends on ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_CORE
+	default n
+
+endif
diff --git a/drivers/input/touchscreen/synaptics_dsx/Makefile b/drivers/input/touchscreen/synaptics_dsx/Makefile
new file mode 100755
index 0000000..88c54d7
--- /dev/null
+++ b/drivers/input/touchscreen/synaptics_dsx/Makefile
@@ -0,0 +1,22 @@
+#
+# Makefile for the Synaptics DSX touchscreen driver.
+#
+
+# Each configuration option enables a list of files.
+
+obj-$(CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_I2C) += synaptics_dsx_i2c.o
+obj-$(CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_SPI) += synaptics_dsx_spi.o
+obj-$(CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_CORE) += synaptics_dsx_core.o
+obj-$(CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_RMI_DEV) += synaptics_dsx_rmi_dev.o
+obj-$(CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_FW_UPDATE) += synaptics_dsx_fw_update.o
+obj-$(CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_TEST_REPORTING) += synaptics_dsx_test_reporting.o
+obj-$(CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_PROXIMITY) += synaptics_dsx_proximity.o
+
+ifeq ($(CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_DEBUG),y)
+CFLAGS_synaptics_dsx_i2c.o += -DDEBUG
+CFLAGS_synaptics_dsx_core.o += -DDEBUG
+CFLAGS_synaptics_dsx_rmi_dev.o += -DDEBUG
+CFLAGS_synaptics_dsx_fw_update.o += -DDEBUG
+CFLAGS_synaptics_dsx_test_reporting.o += -DDEBUG
+endif
+
diff --git a/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx.h b/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx.h
new file mode 100755
index 0000000..dc6e6be
--- /dev/null
+++ b/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx.h
@@ -0,0 +1,80 @@
+/*
+ * Synaptics DSX touchscreen driver
+ *
+ * Copyright (C) 2012 Synaptics Incorporated
+ *
+ * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
+ * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _SYNAPTICS_DSX_H_
+#define _SYNAPTICS_DSX_H_
+
+#define PLATFORM_DRIVER_NAME "synaptics_dsx"
+#define I2C_DRIVER_NAME "synaptics_dsx_i2c"
+#define SPI_DRIVER_NAME "synaptics_dsx_spi"
+
+/*
+ * struct synaptics_dsx_cap_button_map - 0d button map
+ * @nbuttons: number of 0d buttons
+ * @map: pointer to array of button types
+ */
+struct synaptics_dsx_cap_button_map {
+	unsigned char nbuttons;
+	unsigned char *map;
+};
+
+/*
+ * struct synaptics_dsx_board_data - dsx board data
+ * @x_flip: x flip flag
+ * @y_flip: y flip flag
+ * @irq_gpio: attention interrupt gpio
+ * @power_gpio: power switch gpio
+ * @power_on_state: power switch active state
+ * @reset_gpio: reset gpio
+ * @reset_on_state: reset active state
+ * @irq_flags: irq flags
+ * @panel_x: x-axis resolution of display panel
+ * @panel_y: y-axis resolution of display panel
+ * @power_delay_ms: delay time to wait after power-on
+ * @reset_delay_ms: delay time to wait after reset
+ * @reset_active_ms: reset active time
+ * @byte_delay_us: delay time between two bytes of SPI data
+ * @block_delay_us: delay time between two SPI transfers
+ * @regulator_name: pointer to name of regulator
+ * @gpio_config: pointer to gpio configuration function
+ * @cap_button_map: pointer to 0d button map
+ */
+struct synaptics_dsx_board_data {
+	bool x_flip;
+	bool y_flip;
+	bool swap_axes;
+	int irq_gpio;
+	int power_gpio;
+	int power_on_state;
+	int reset_gpio;
+	int reset_on_state;
+	unsigned long irq_flags;
+	unsigned int panel_x;
+	unsigned int panel_y;
+	unsigned int power_delay_ms;
+	unsigned int reset_delay_ms;
+	unsigned int reset_active_ms;
+	unsigned int byte_delay_us;
+	unsigned int block_delay_us;
+	unsigned char *regulator_name;
+	int (*gpio_config)(int gpio, bool configure, int dir, int state);
+	struct synaptics_dsx_cap_button_map *cap_button_map;
+};
+
+#endif
diff --git a/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_core.c b/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_core.c
new file mode 100755
index 0000000..d6b88e2
--- /dev/null
+++ b/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_core.c
@@ -0,0 +1,3657 @@
+/*
+ * Synaptics DSX touchscreen driver
+ *
+ * Copyright (C) 2012 Synaptics Incorporated
+ *
+ * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
+ * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include "synaptics_dsx.h"
+#include "synaptics_dsx_core.h"
+#ifdef KERNEL_ABOVE_2_6_38
+#include <linux/input/mt.h>
+#endif
+
+#define INPUT_PHYS_NAME "synaptics_dsx/input0"
+
+#ifdef KERNEL_ABOVE_2_6_38
+#define TYPE_B_PROTOCOL
+#endif
+
+#define NO_0D_WHILE_2D
+#define REPORT_2D_Z
+#define REPORT_2D_W
+
+#define F12_DATA_15_WORKAROUND
+
+/*
+#define IGNORE_FN_INIT_FAILURE
+*/
+
+#define RPT_TYPE (1 << 0)
+#define RPT_X_LSB (1 << 1)
+#define RPT_X_MSB (1 << 2)
+#define RPT_Y_LSB (1 << 3)
+#define RPT_Y_MSB (1 << 4)
+#define RPT_Z (1 << 5)
+#define RPT_WX (1 << 6)
+#define RPT_WY (1 << 7)
+#define RPT_DEFAULT (RPT_TYPE | RPT_X_LSB | RPT_X_MSB | RPT_Y_LSB | RPT_Y_MSB)
+
+#define EXP_FN_WORK_DELAY_MS 1000 /* ms */
+#define MAX_F11_TOUCH_WIDTH 15
+
+#define CHECK_STATUS_TIMEOUT_MS 100
+
+#define F01_STD_QUERY_LEN 21
+#define F01_BUID_ID_OFFSET 18
+#define F11_STD_QUERY_LEN 9
+#define F11_STD_CTRL_LEN 10
+#define F11_STD_DATA_LEN 12
+
+#define STATUS_NO_ERROR 0x00
+#define STATUS_RESET_OCCURRED 0x01
+#define STATUS_INVALID_CONFIG 0x02
+#define STATUS_DEVICE_FAILURE 0x03
+#define STATUS_CONFIG_CRC_FAILURE 0x04
+#define STATUS_FIRMWARE_CRC_FAILURE 0x05
+#define STATUS_CRC_IN_PROGRESS 0x06
+
+#define NORMAL_OPERATION (0 << 0)
+#define SENSOR_SLEEP (1 << 0)
+#define NO_SLEEP_OFF (0 << 2)
+#define NO_SLEEP_ON (1 << 2)
+#define CONFIGURED (1 << 7)
+
+#define ZTEMT_TP_WAKEUP_GESTURE_FUNCTION	0		//add by luochangyang
+
+static int synaptics_rmi4_f12_set_enables(struct synaptics_rmi4_data *rmi4_data,
+		unsigned short ctrl28);
+
+static int synaptics_rmi4_free_fingers(struct synaptics_rmi4_data *rmi4_data);
+static int synaptics_rmi4_reinit_device(struct synaptics_rmi4_data *rmi4_data);
+static int synaptics_rmi4_reset_device(struct synaptics_rmi4_data *rmi4_data);
+
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_FB)
+static ssize_t synaptics_rmi4_full_pm_cycle_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_full_pm_cycle_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+#endif
+
+#if defined(CONFIG_FB)
+static int synaptics_rmi4_fb_notifier_callback(struct notifier_block *self,
+				 unsigned long event, void *data);
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+static void synaptics_rmi4_early_suspend(struct early_suspend *h);
+
+static void synaptics_rmi4_late_resume(struct early_suspend *h);
+#endif
+
+/*** ZTEMT Added by luochangyang, 2014/03/19 ***/
+#if ZTEMT_TP_WAKEUP_GESTURE_FUNCTION
+static ssize_t synaptics_wakeup_gesture_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+static ssize_t synaptics_wakeup_gesture_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size);
+#endif
+static ssize_t synaptics_rmi4_f01_reset_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+/***ZTEMT END***/
+
+static int synaptics_rmi4_suspend(struct device *dev);
+
+static int synaptics_rmi4_resume(struct device *dev);
+
+static ssize_t synaptics_rmi4_f01_reset_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t synaptics_rmi4_f01_productinfo_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_f01_buildid_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_f01_flashprog_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_0dbutton_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_0dbutton_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t synaptics_rmi4_suspend_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+struct synaptics_rmi4_f01_device_status {
+	union {
+		struct {
+			unsigned char status_code:4;
+			unsigned char reserved:2;
+			unsigned char flash_prog:1;
+			unsigned char unconfigured:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct synaptics_rmi4_f12_query_5 {
+	union {
+		struct {
+			unsigned char size_of_query6;
+			struct {
+				unsigned char ctrl0_is_present:1;
+				unsigned char ctrl1_is_present:1;
+				unsigned char ctrl2_is_present:1;
+				unsigned char ctrl3_is_present:1;
+				unsigned char ctrl4_is_present:1;
+				unsigned char ctrl5_is_present:1;
+				unsigned char ctrl6_is_present:1;
+				unsigned char ctrl7_is_present:1;
+			} __packed;
+			struct {
+				unsigned char ctrl8_is_present:1;
+				unsigned char ctrl9_is_present:1;
+				unsigned char ctrl10_is_present:1;
+				unsigned char ctrl11_is_present:1;
+				unsigned char ctrl12_is_present:1;
+				unsigned char ctrl13_is_present:1;
+				unsigned char ctrl14_is_present:1;
+				unsigned char ctrl15_is_present:1;
+			} __packed;
+			struct {
+				unsigned char ctrl16_is_present:1;
+				unsigned char ctrl17_is_present:1;
+				unsigned char ctrl18_is_present:1;
+				unsigned char ctrl19_is_present:1;
+				unsigned char ctrl20_is_present:1;
+				unsigned char ctrl21_is_present:1;
+				unsigned char ctrl22_is_present:1;
+				unsigned char ctrl23_is_present:1;
+			} __packed;
+			struct {
+				unsigned char ctrl24_is_present:1;
+				unsigned char ctrl25_is_present:1;
+				unsigned char ctrl26_is_present:1;
+				unsigned char ctrl27_is_present:1;
+				unsigned char ctrl28_is_present:1;
+				unsigned char ctrl29_is_present:1;
+				unsigned char ctrl30_is_present:1;
+				unsigned char ctrl31_is_present:1;
+			} __packed;
+		};
+		unsigned char data[5];
+	};
+};
+
+struct synaptics_rmi4_f12_query_8 {
+	union {
+		struct {
+			unsigned char size_of_query9;
+			struct {
+				unsigned char data0_is_present:1;
+				unsigned char data1_is_present:1;
+				unsigned char data2_is_present:1;
+				unsigned char data3_is_present:1;
+				unsigned char data4_is_present:1;
+				unsigned char data5_is_present:1;
+				unsigned char data6_is_present:1;
+				unsigned char data7_is_present:1;
+			} __packed;
+			struct {
+				unsigned char data8_is_present:1;
+				unsigned char data9_is_present:1;
+				unsigned char data10_is_present:1;
+				unsigned char data11_is_present:1;
+				unsigned char data12_is_present:1;
+				unsigned char data13_is_present:1;
+				unsigned char data14_is_present:1;
+				unsigned char data15_is_present:1;
+			} __packed;
+		};
+		unsigned char data[3];
+	};
+};
+
+struct synaptics_rmi4_f12_ctrl_8 {
+	union {
+		struct {
+			unsigned char max_x_coord_lsb;
+			unsigned char max_x_coord_msb;
+			unsigned char max_y_coord_lsb;
+			unsigned char max_y_coord_msb;
+			unsigned char rx_pitch_lsb;
+			unsigned char rx_pitch_msb;
+			unsigned char tx_pitch_lsb;
+			unsigned char tx_pitch_msb;
+			unsigned char low_rx_clip;
+			unsigned char high_rx_clip;
+			unsigned char low_tx_clip;
+			unsigned char high_tx_clip;
+			unsigned char num_of_rx;
+			unsigned char num_of_tx;
+		};
+		unsigned char data[14];
+	};
+};
+
+struct synaptics_rmi4_f12_ctrl_23 {
+	union {
+		struct {
+			unsigned char obj_type_enable;
+			unsigned char max_reported_objects;
+		};
+		unsigned char data[2];
+	};
+};
+
+struct synaptics_rmi4_f12_finger_data {
+	unsigned char object_type_and_status;
+	unsigned char x_lsb;
+	unsigned char x_msb;
+	unsigned char y_lsb;
+	unsigned char y_msb;
+#ifdef REPORT_2D_Z
+	unsigned char z;
+#endif
+#ifdef REPORT_2D_W
+	unsigned char wx;
+	unsigned char wy;
+#endif
+};
+
+struct synaptics_rmi4_f1a_query {
+	union {
+		struct {
+			unsigned char max_button_count:3;
+			unsigned char reserved:5;
+			unsigned char has_general_control:1;
+			unsigned char has_interrupt_enable:1;
+			unsigned char has_multibutton_select:1;
+			unsigned char has_tx_rx_map:1;
+			unsigned char has_perbutton_threshold:1;
+			unsigned char has_release_threshold:1;
+			unsigned char has_strongestbtn_hysteresis:1;
+			unsigned char has_filter_strength:1;
+		} __packed;
+		unsigned char data[2];
+	};
+};
+
+struct synaptics_rmi4_f1a_control_0 {
+	union {
+		struct {
+			unsigned char multibutton_report:2;
+			unsigned char filter_mode:2;
+			unsigned char reserved:4;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct synaptics_rmi4_f1a_control {
+	struct synaptics_rmi4_f1a_control_0 general_control;
+	unsigned char button_int_enable;
+	unsigned char multi_button;
+	unsigned char *txrx_map;
+	unsigned char *button_threshold;
+	unsigned char button_release_threshold;
+	unsigned char strongest_button_hysteresis;
+	unsigned char filter_strength;
+};
+
+struct synaptics_rmi4_f1a_handle {
+	int button_bitmask_size;
+	unsigned char max_count;
+	unsigned char valid_button_count;
+	unsigned char *button_data_buffer;
+	unsigned char *button_map;
+	struct synaptics_rmi4_f1a_query button_query;
+	struct synaptics_rmi4_f1a_control button_control;
+};
+
+struct synaptics_rmi4_exp_fhandler {
+	struct synaptics_rmi4_exp_fn *exp_fn;
+	bool insert;
+	bool remove;
+	struct list_head link;
+};
+
+struct synaptics_rmi4_exp_fn_data {
+	bool initialized;
+	bool queue_work;
+	struct mutex mutex;
+	struct list_head list;
+	struct delayed_work work;
+	struct workqueue_struct *workqueue;
+	struct synaptics_rmi4_data *rmi4_data;
+};
+
+static struct synaptics_rmi4_exp_fn_data exp_data;
+
+static struct device_attribute attrs[] = {
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_FB)
+	__ATTR(full_pm_cycle, (00664),
+			synaptics_rmi4_full_pm_cycle_show,
+			synaptics_rmi4_full_pm_cycle_store),
+#endif
+	__ATTR(reset, 00664,
+			synaptics_rmi4_f01_reset_show,
+			synaptics_rmi4_f01_reset_store),
+	__ATTR(productinfo, S_IRUGO,
+			synaptics_rmi4_f01_productinfo_show,
+			synaptics_rmi4_store_error),
+	__ATTR(buildid, S_IRUGO,
+			synaptics_rmi4_f01_buildid_show,
+			synaptics_rmi4_store_error),
+#if ZTEMT_TP_WAKEUP_GESTURE_FUNCTION
+    /*** ZTEMT Added by luochangyang, 2014/03/19 ***/
+	__ATTR(wakeup_gesture, 00664,
+			synaptics_wakeup_gesture_show,
+			synaptics_wakeup_gesture_store),
+   	/***ZTEMT END***/
+#endif
+	__ATTR(flashprog, S_IRUGO,
+			synaptics_rmi4_f01_flashprog_show,
+			synaptics_rmi4_store_error),
+	__ATTR(0dbutton, (00664),
+			synaptics_rmi4_0dbutton_show,
+			synaptics_rmi4_0dbutton_store),
+	__ATTR(suspend, 00220,
+			synaptics_rmi4_show_error,
+			synaptics_rmi4_suspend_store),
+};
+
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_FB)
+static ssize_t synaptics_rmi4_full_pm_cycle_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%u\n",
+			rmi4_data->full_pm_cycle);
+}
+
+static ssize_t synaptics_rmi4_full_pm_cycle_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int input;
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+
+	if (sscanf(buf, "%u", &input) != 1)
+		return -EINVAL;
+
+	rmi4_data->full_pm_cycle = input > 0 ? 1 : 0;
+
+	return count;
+}
+#endif
+
+/*luochangyang 2014/03/19*/
+static ssize_t synaptics_rmi4_f01_reset_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int retval;
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+
+	retval = synaptics_rmi4_reset_device(rmi4_data);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to issue reset command, error = %d\n",
+				__func__, retval);
+	}
+
+	return retval;
+}
+/*luochangyang END*/
+
+static ssize_t synaptics_rmi4_f01_reset_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned int reset;
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+
+	if (sscanf(buf, "%u", &reset) != 1)
+		return -EINVAL;
+
+	if (reset != 1)
+		return -EINVAL;
+
+	retval = synaptics_rmi4_reset_device(rmi4_data);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to issue reset command, error = %d\n",
+				__func__, retval);
+		return retval;
+	}
+
+	return count;
+}
+
+static ssize_t synaptics_rmi4_f01_productinfo_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "0x%02x 0x%02x\n",
+			(rmi4_data->rmi4_mod_info.product_info[0]),
+			(rmi4_data->rmi4_mod_info.product_info[1]));
+}
+
+static ssize_t synaptics_rmi4_f01_buildid_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+
+#if 0
+	return snprintf(buf, PAGE_SIZE, "%u\n",
+			rmi4_data->firmware_id);
+#else
+    /*** ZTEMT Modify by luochangyang, 2013/05/02 ***/
+	return snprintf(buf, PAGE_SIZE, "Build ID: %u\n"
+	        "Config ID: 0x%02x 0x%02x 0x%02x 0x%02x\n", rmi4_data->firmware_id, 
+			(rmi4_data->rmi4_mod_info.config_id[0]),
+			(rmi4_data->rmi4_mod_info.config_id[1]),
+			(rmi4_data->rmi4_mod_info.config_id[2]),
+			(rmi4_data->rmi4_mod_info.config_id[3]));
+    /***ZTEMT END***/
+#endif
+}
+
+/*** ZTEMT Added by luochangyang, 2014/03/19 ***/
+#if ZTEMT_TP_WAKEUP_GESTURE_FUNCTION
+static ssize_t synaptics_wakeup_gesture_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+	
+	return snprintf(buf, PAGE_SIZE, "0x%02X\n",	rmi4_data->wakeup_gesture);
+}
+
+static ssize_t synaptics_wakeup_gesture_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+	unsigned long value;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &value);
+	if (ret < 0)
+		return ret;
+
+	if (value > 0xFF && value < 0)
+		return -EINVAL;
+
+	if (value == 0xFF)
+		value = 0;
+
+	rmi4_data->wakeup_gesture = (u8)value;
+	
+	if (ret)
+		return ret;
+
+	return size;
+}
+#endif
+/***ZTEMT END***/
+
+static ssize_t synaptics_rmi4_f01_flashprog_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int retval;
+	struct synaptics_rmi4_f01_device_status device_status;
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			rmi4_data->f01_data_base_addr,
+			device_status.data,
+			sizeof(device_status.data));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read device status, error = %d\n",
+				__func__, retval);
+		return retval;
+	}
+
+	return snprintf(buf, PAGE_SIZE, "%u\n",
+			device_status.flash_prog);
+}
+
+static ssize_t synaptics_rmi4_0dbutton_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%u\n",
+			rmi4_data->button_0d_enabled);
+}
+
+static ssize_t synaptics_rmi4_0dbutton_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned int input;
+	unsigned char ii;
+	unsigned char intr_enable;
+	struct synaptics_rmi4_fn *fhandler;
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+	struct synaptics_rmi4_device_info *rmi;
+
+	rmi = &(rmi4_data->rmi4_mod_info);
+
+	if (sscanf(buf, "%u", &input) != 1)
+		return -EINVAL;
+
+	input = input > 0 ? 1 : 0;
+
+	if (rmi4_data->button_0d_enabled == input)
+		return count;
+
+	if (list_empty(&rmi->support_fn_list))
+		return -ENODEV;
+
+	list_for_each_entry(fhandler, &rmi->support_fn_list, link) {
+		if (fhandler->fn_number == SYNAPTICS_RMI4_F1A) {
+			ii = fhandler->intr_reg_num;
+
+			retval = synaptics_rmi4_reg_read(rmi4_data,
+					rmi4_data->f01_ctrl_base_addr + 1 + ii,
+					&intr_enable,
+					sizeof(intr_enable));
+			if (retval < 0)
+				return retval;
+
+			if (input == 1)
+				intr_enable |= fhandler->intr_mask;
+			else
+				intr_enable &= ~fhandler->intr_mask;
+
+			retval = synaptics_rmi4_reg_write(rmi4_data,
+					rmi4_data->f01_ctrl_base_addr + 1 + ii,
+					&intr_enable,
+					sizeof(intr_enable));
+			if (retval < 0)
+				return retval;
+		}
+	}
+
+	rmi4_data->button_0d_enabled = input;
+
+	return count;
+}
+
+static ssize_t synaptics_rmi4_suspend_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int input;
+
+	if (sscanf(buf, "%u", &input) != 1)
+		return -EINVAL;
+
+	if (input == 1)
+		synaptics_rmi4_suspend(dev);
+	else if (input == 0)
+		synaptics_rmi4_resume(dev);
+	else
+		return -EINVAL;
+
+	return count;
+}
+
+ /**
+ * synaptics_rmi4_f11_abs_report()
+ *
+ * Called by synaptics_rmi4_report_touch() when valid Function $11
+ * finger data has been detected.
+ *
+ * This function reads the Function $11 data registers, determines the
+ * status of each finger supported by the Function, processes any
+ * necessary coordinate manipulation, reports the finger data to
+ * the input subsystem, and returns the number of fingers detected.
+ */
+static int synaptics_rmi4_f11_abs_report(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler)
+{
+	int retval;
+	unsigned char touch_count = 0; /* number of touch points */
+	unsigned char reg_index;
+	unsigned char finger;
+	unsigned char fingers_supported;
+	unsigned char num_of_finger_status_regs;
+	unsigned char finger_shift;
+	unsigned char finger_status;
+	unsigned char data_reg_blk_size;
+	unsigned char finger_status_reg[3];
+	unsigned char data[F11_STD_DATA_LEN];
+	unsigned short data_addr;
+	unsigned short data_offset;
+	int x;
+	int y;
+	int wx;
+	int wy;
+	int temp;
+
+	/*
+	 * The number of finger status registers is determined by the
+	 * maximum number of fingers supported - 2 bits per finger. So
+	 * the number of finger status registers to read is:
+	 * register_count = ceil(max_num_of_fingers / 4)
+	 */
+	fingers_supported = fhandler->num_of_data_points;
+	num_of_finger_status_regs = (fingers_supported + 3) / 4;
+	data_addr = fhandler->full_addr.data_base;
+	data_reg_blk_size = fhandler->size_of_data_register_block;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			data_addr,
+			finger_status_reg,
+			num_of_finger_status_regs);
+	if (retval < 0)
+		return 0;
+	mutex_lock(&(rmi4_data->rmi4_report_mutex));
+
+	for (finger = 0; finger < fingers_supported; finger++) {
+		reg_index = finger / 4;
+		finger_shift = (finger % 4) * 2;
+		finger_status = (finger_status_reg[reg_index] >> finger_shift)
+				& MASK_2BIT;
+
+		/*
+		 * Each 2-bit finger status field represents the following:
+		 * 00 = finger not present
+		 * 01 = finger present and data accurate
+		 * 10 = finger present but data may be inaccurate
+		 * 11 = reserved
+		 */
+#ifdef TYPE_B_PROTOCOL
+		input_mt_slot(rmi4_data->input_dev, finger);
+		input_mt_report_slot_state(rmi4_data->input_dev,
+				MT_TOOL_FINGER, finger_status);
+#endif
+
+		if (finger_status) {
+			data_offset = data_addr +
+					num_of_finger_status_regs +
+					(finger * data_reg_blk_size);
+			retval = synaptics_rmi4_reg_read(rmi4_data,
+					data_offset,
+					data,
+					data_reg_blk_size);
+			if (retval < 0) {
+				touch_count = 0;
+				goto exit;
+			}
+
+			x = (data[0] << 4) | (data[2] & MASK_4BIT);
+			y = (data[1] << 4) | ((data[2] >> 4) & MASK_4BIT);
+			wx = (data[3] & MASK_4BIT);
+			wy = (data[3] >> 4) & MASK_4BIT;
+
+			if (rmi4_data->hw_if->board_data->swap_axes) {
+				temp = x;
+				x = y;
+				y = temp;
+				temp = wx;
+				wx = wy;
+				wy = temp;
+			}
+
+			if (rmi4_data->hw_if->board_data->x_flip)
+				x = rmi4_data->sensor_max_x - x;
+			if (rmi4_data->hw_if->board_data->y_flip)
+				y = rmi4_data->sensor_max_y - y;
+
+			input_report_key(rmi4_data->input_dev,
+					BTN_TOUCH, 1);
+			input_report_key(rmi4_data->input_dev,
+					BTN_TOOL_FINGER, 1);
+			input_report_abs(rmi4_data->input_dev,
+					ABS_MT_POSITION_X, x);
+			input_report_abs(rmi4_data->input_dev,
+					ABS_MT_POSITION_Y, y);
+#ifdef REPORT_2D_W
+			input_report_abs(rmi4_data->input_dev,
+					ABS_MT_TOUCH_MAJOR, max(wx, wy));
+			input_report_abs(rmi4_data->input_dev,
+					ABS_MT_TOUCH_MINOR, min(wx, wy));
+			
+			/*luochangyang for Palm Sleep 2014/06/12*/
+			input_report_abs(rmi4_data->input_dev,
+					ABS_MT_PRESSURE, max(wx, wy));
+			/*luochangyang END*/
+#endif
+#ifndef TYPE_B_PROTOCOL
+			input_mt_sync(rmi4_data->input_dev);
+#endif
+
+			dev_dbg(rmi4_data->pdev->dev.parent,
+					"%s: Finger %d:\n"
+					"status = 0x%02x\n"
+					"x = %d\n"
+					"y = %d\n"
+					"wx = %d\n"
+					"wy = %d\n",
+					__func__, finger,
+					finger_status,
+					x, y, wx, wy);
+
+			touch_count++;
+		}
+	}
+
+	if (touch_count == 0) {
+		input_report_key(rmi4_data->input_dev,
+				BTN_TOUCH, 0);
+		input_report_key(rmi4_data->input_dev,
+				BTN_TOOL_FINGER, 0);
+#ifndef TYPE_B_PROTOCOL
+		input_mt_sync(rmi4_data->input_dev);
+#endif
+	}
+
+	input_sync(rmi4_data->input_dev);
+
+exit:
+	mutex_unlock(&(rmi4_data->rmi4_report_mutex));
+	return touch_count;
+}
+
+ /**
+ * synaptics_rmi4_f12_abs_report()
+ *
+ * Called by synaptics_rmi4_report_touch() when valid Function $12
+ * finger data has been detected.
+ *
+ * This function reads the Function $12 data registers, determines the
+ * status of each finger supported by the Function, processes any
+ * necessary coordinate manipulation, reports the finger data to
+ * the input subsystem, and returns the number of fingers detected.
+ */
+static int synaptics_rmi4_f12_abs_report(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler)
+{
+	int retval;
+	unsigned char touch_count = 0; /* number of touch points */
+	unsigned char finger;
+	unsigned char fingers_to_process;
+	unsigned char finger_status;
+	unsigned char size_of_2d_data;
+	unsigned short data_addr;
+	int x;
+	int y;
+	int wx;
+	int wy;
+	int temp;
+	struct synaptics_rmi4_f12_extra_data *extra_data;
+	struct synaptics_rmi4_f12_finger_data *data;
+	struct synaptics_rmi4_f12_finger_data *finger_data;
+#ifdef F12_DATA_15_WORKAROUND
+	static unsigned char fingers_already_present;
+#endif
+
+	fingers_to_process = fhandler->num_of_data_points;
+	data_addr = fhandler->full_addr.data_base;
+	extra_data = (struct synaptics_rmi4_f12_extra_data *)fhandler->extra;
+	size_of_2d_data = sizeof(struct synaptics_rmi4_f12_finger_data);
+
+
+	/* Determine the total number of fingers to process */
+	if (extra_data->data15_size) {
+		retval = synaptics_rmi4_reg_read(rmi4_data,
+				data_addr + extra_data->data15_offset,
+				extra_data->data15_data,
+				extra_data->data15_size);
+		if (retval < 0)
+			return 0;
+
+		/* Start checking from the highest bit */
+		temp = extra_data->data15_size - 1; /* Highest byte */
+		finger = (fingers_to_process - 1) % 8; /* Highest bit */
+		do {
+			if (extra_data->data15_data[temp] & (1 << finger))
+				break;
+
+			if (finger) {
+				finger--;
+			} else {
+				temp--; /* Move to the next lower byte */
+				finger = 7;
+			}
+
+			fingers_to_process--;
+		} while (fingers_to_process);
+
+		dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Number of fingers to process = %d\n",
+			__func__, fingers_to_process);
+	}
+
+#ifdef F12_DATA_15_WORKAROUND
+	fingers_to_process = max(fingers_to_process, fingers_already_present);
+#endif
+
+	if (!fingers_to_process) {
+		synaptics_rmi4_free_fingers(rmi4_data);
+		return 0;
+	}
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			data_addr + extra_data->data1_offset,
+			(unsigned char *)fhandler->data,
+			fingers_to_process * size_of_2d_data);
+	if (retval < 0)
+		return 0;
+
+	data = (struct synaptics_rmi4_f12_finger_data *)fhandler->data;
+
+	mutex_lock(&(rmi4_data->rmi4_report_mutex));
+	for (finger = 0; finger < fingers_to_process; finger++) {
+		finger_data = data + finger;
+		finger_status = finger_data->object_type_and_status;
+
+		if (finger_status == F12_FINGER_STATUS) {
+#ifdef TYPE_B_PROTOCOL
+			input_mt_slot(rmi4_data->input_dev, finger);
+			input_mt_report_slot_state(rmi4_data->input_dev,
+					MT_TOOL_FINGER, 1);
+#endif
+
+#ifdef F12_DATA_15_WORKAROUND
+			fingers_already_present = finger + 1;
+#endif
+
+			x = (finger_data->x_msb << 8) | (finger_data->x_lsb);
+			y = (finger_data->y_msb << 8) | (finger_data->y_lsb);
+#ifdef REPORT_2D_W
+			wx = finger_data->wx;
+			wy = finger_data->wy;
+#endif
+
+			if (rmi4_data->hw_if->board_data->swap_axes) {
+				temp = x;
+				x = y;
+				y = temp;
+				temp = wx;
+				wx = wy;
+				wy = temp;
+			}
+
+			if (rmi4_data->hw_if->board_data->x_flip)
+				x = rmi4_data->sensor_max_x - x;
+			if (rmi4_data->hw_if->board_data->y_flip)
+				y = rmi4_data->sensor_max_y - y;
+
+			input_report_key(rmi4_data->input_dev,
+					BTN_TOUCH, 1);
+			input_report_key(rmi4_data->input_dev,
+					BTN_TOOL_FINGER, 1);
+			input_report_abs(rmi4_data->input_dev,
+					ABS_MT_POSITION_X, x);
+			input_report_abs(rmi4_data->input_dev,
+					ABS_MT_POSITION_Y, y);
+#ifdef REPORT_2D_W
+			input_report_abs(rmi4_data->input_dev,
+					ABS_MT_TOUCH_MAJOR, max(wx, wy));
+			input_report_abs(rmi4_data->input_dev,
+					ABS_MT_TOUCH_MINOR, min(wx, wy));
+
+			/*luochangyang for Palm Sleep 2014/06/12*/
+			input_report_abs(rmi4_data->input_dev,
+					ABS_MT_PRESSURE, max(wx, wy));
+			/*luochangyang END*/
+#endif
+#ifndef TYPE_B_PROTOCOL
+			input_mt_sync(rmi4_data->input_dev);
+#endif
+
+			dev_dbg(rmi4_data->pdev->dev.parent,
+					"%s: Finger %d:\n"
+					"status = 0x%02x\n"
+					"x = %d\n"
+					"y = %d\n"
+					"wx = %d\n"
+					"wy = %d\n",
+					__func__, finger,
+					finger_status,
+					x, y, wx, wy);
+
+			touch_count++;
+		} else {
+#ifdef TYPE_B_PROTOCOL
+			input_mt_slot(rmi4_data->input_dev, finger);
+			input_mt_report_slot_state(rmi4_data->input_dev,
+					MT_TOOL_FINGER, 0);
+#endif
+		}
+	}
+
+	if (touch_count == 0) {
+		input_report_key(rmi4_data->input_dev,
+				BTN_TOUCH, 0);
+		input_report_key(rmi4_data->input_dev,
+				BTN_TOOL_FINGER, 0);
+#ifndef TYPE_B_PROTOCOL
+		input_mt_sync(rmi4_data->input_dev);
+#endif
+	}
+
+	input_sync(rmi4_data->input_dev);
+	mutex_unlock(&(rmi4_data->rmi4_report_mutex));
+
+	return touch_count;
+}
+
+static void synaptics_rmi4_f1a_report(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler)
+{
+	int retval;
+	unsigned char touch_count = 0;
+	unsigned char button;
+	unsigned char index;
+	unsigned char shift;
+	unsigned char status;
+	unsigned char *data;
+	unsigned short data_addr = fhandler->full_addr.data_base;
+	struct synaptics_rmi4_f1a_handle *f1a = fhandler->data;
+	static unsigned char do_once = 1;
+	static bool current_status[MAX_NUMBER_OF_BUTTONS];
+#ifdef NO_0D_WHILE_2D
+	static bool before_2d_status[MAX_NUMBER_OF_BUTTONS];
+	static bool while_2d_status[MAX_NUMBER_OF_BUTTONS];
+#endif
+
+	if (do_once) {
+		memset(current_status, 0, sizeof(current_status));
+#ifdef NO_0D_WHILE_2D
+		memset(before_2d_status, 0, sizeof(before_2d_status));
+		memset(while_2d_status, 0, sizeof(while_2d_status));
+#endif
+		do_once = 0;
+	}
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			data_addr,
+			f1a->button_data_buffer,
+			f1a->button_bitmask_size);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read button data registers\n",
+				__func__);
+		return;
+	}
+
+	data = f1a->button_data_buffer;
+	mutex_lock(&(rmi4_data->rmi4_report_mutex));
+
+	for (button = 0; button < f1a->valid_button_count; button++) {
+		index = button / 8;
+		shift = button % 8;
+		status = ((data[index] >> shift) & MASK_1BIT);
+
+		if (current_status[button] == status)
+			continue;
+		else
+			current_status[button] = status;
+
+		dev_dbg(rmi4_data->pdev->dev.parent,
+				"%s: Button %d (code %d) ->%d\n",
+				__func__, button,
+				f1a->button_map[button],
+				status);
+#ifdef NO_0D_WHILE_2D
+		if (rmi4_data->fingers_on_2d == false) {
+			if (status == 1) {
+				before_2d_status[button] = 1;
+			} else {
+				if (while_2d_status[button] == 1) {
+					while_2d_status[button] = 0;
+					continue;
+				} else {
+					before_2d_status[button] = 0;
+				}
+			}
+			touch_count++;
+			input_report_key(rmi4_data->input_dev,
+					f1a->button_map[button],
+					status);
+		} else {
+			if (before_2d_status[button] == 1) {
+				before_2d_status[button] = 0;
+				touch_count++;
+				input_report_key(rmi4_data->input_dev,
+						f1a->button_map[button],
+						status);
+			} else {
+				if (status == 1)
+					while_2d_status[button] = 1;
+				else
+					while_2d_status[button] = 0;
+			}
+		}
+#else
+		touch_count++;
+		input_report_key(rmi4_data->input_dev,
+				f1a->button_map[button],
+				status);
+#endif
+	}
+
+	if (touch_count)
+		input_sync(rmi4_data->input_dev);
+
+	mutex_unlock(&(rmi4_data->rmi4_report_mutex));
+	return;
+}
+
+ /**
+ * synaptics_rmi4_report_touch()
+ *
+ * Called by synaptics_rmi4_sensor_report().
+ *
+ * This function calls the appropriate finger data reporting function
+ * based on the function handler it receives and returns the number of
+ * fingers detected.
+ */
+static void synaptics_rmi4_report_touch(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler)
+{
+	unsigned char touch_count_2d;
+
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Function %02x reporting\n",
+			__func__, fhandler->fn_number);
+
+	switch (fhandler->fn_number) {
+	case SYNAPTICS_RMI4_F11:
+		touch_count_2d = synaptics_rmi4_f11_abs_report(rmi4_data,
+				fhandler);
+
+		if (touch_count_2d)
+			rmi4_data->fingers_on_2d = true;
+		else
+			rmi4_data->fingers_on_2d = false;
+		break;
+	case SYNAPTICS_RMI4_F12:
+		touch_count_2d = synaptics_rmi4_f12_abs_report(rmi4_data,
+				fhandler);
+
+		if (touch_count_2d)
+			rmi4_data->fingers_on_2d = true;
+		else
+			rmi4_data->fingers_on_2d = false;
+		break;
+	case SYNAPTICS_RMI4_F1A:
+		synaptics_rmi4_f1a_report(rmi4_data, fhandler);
+		break;
+	default:
+		break;
+	}
+
+	return;
+}
+
+ /**
+ * synaptics_rmi4_sensor_report()
+ *
+ * Called by synaptics_rmi4_irq().
+ *
+ * This function determines the interrupt source(s) from the sensor
+ * and calls synaptics_rmi4_report_touch() with the appropriate
+ * function handler for each function with valid data inputs.
+ */
+static void synaptics_rmi4_sensor_report(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	/*** ZTEMT Added by luochangyang, 2014/03/19 ***/
+#if ZTEMT_SYNAPTICS_PALM_SLEEP
+	int fingers = 0;
+	unsigned char object_type[80];
+#endif
+#ifdef CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_S3508
+	unsigned char interrupt_status;
+#endif
+	unsigned char gesture_type;
+	/***ZTEMT END***/
+	unsigned char data[MAX_INTR_REGISTERS + 1];
+	unsigned char *intr = &data[1];
+	struct synaptics_rmi4_f01_device_status status;
+	struct synaptics_rmi4_fn *fhandler;
+	struct synaptics_rmi4_exp_fhandler *exp_fhandler;
+	struct synaptics_rmi4_device_info *rmi;
+
+	rmi = &(rmi4_data->rmi4_mod_info);
+	
+	/*
+	 * Get interrupt status information from F01 Data1 register to
+	 * determine the source(s) that are flagging the interrupt.
+	 */
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			rmi4_data->f01_data_base_addr,
+			data,
+			rmi4_data->num_of_intr_regs + 1);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read interrupt status\n",
+				__func__);
+		return;
+	}
+
+    /*** ZTEMT Added by luochangyang, 2014/03/19 ***/
+    /*The function of palm to sleep*/
+#if ZTEMT_SYNAPTICS_PALM_SLEEP
+    if (!rmi4_data->sensor_sleep && rmi4_data->fw_update == 0) {	
+#if defined CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_S3208
+		retval = synaptics_rmi4_reg_read(rmi4_data,
+    				0x004A,
+    				&object_type[0],
+    				sizeof(object_type[0]));
+#elif defined CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_S3508
+        retval = synaptics_rmi4_reg_read(rmi4_data,
+    				0x0005,
+    				&interrupt_status,
+    				sizeof(interrupt_status));
+    	if (retval < 0) {
+    		dev_err(rmi4_data->pdev->dev.parent,
+    				"%s: Failed to read interrupt_status\n",
+    				__func__);
+    		return;
+    	}
+		
+        retval = synaptics_rmi4_reg_read(rmi4_data,
+    				0x0006,
+    				object_type,
+    				sizeof(object_type));
+#endif
+    	if (retval < 0) {
+    		dev_err(rmi4_data->pdev->dev.parent,
+    				"%s: Failed to read extended_status\n",
+    				__func__);
+    		return;
+    	}
+
+		dev_dbg(rmi4_data->pdev->dev.parent,
+				"%s: 0006 object_type %d %d %d %d %d %d %d %d %d %d\n",
+				__func__, object_type[0], object_type[8], object_type[16], 
+				object_type[24], object_type[32], object_type[40],
+				object_type[48], object_type[56], object_type[64], 
+				object_type[72]);
+
+#if defined CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_S3208
+		if (object_type[0] & 0x02)
+#elif defined CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_S3508
+        if (0x03 == object_type[0] || 0x03 == object_type[8] ||
+			0x03 == object_type[16] || 0x03 == object_type[24] ||
+			0x03 == object_type[32] || 0x03 == object_type[40] ||
+			0x03 == object_type[48] || 0x03 == object_type[56] ||
+			0x03 == object_type[64] || 0x03 == object_type[72])
+#endif
+		{
+			dev_dbg(rmi4_data->pdev->dev.parent, "%s: Have a palm.   %d_%d\n",	
+				__func__, fingers, fingers);
+#if ZTEMT_SYNAPTICS_DEBUG
+			input_report_key(rmi4_data->input_dev, KEY_POWER, 1);
+			input_sync(rmi4_data->input_dev);
+
+			input_report_key(rmi4_data->input_dev, KEY_POWER, 0);
+			input_sync(rmi4_data->input_dev);
+#else
+			/* For large area event */
+			input_mt_slot(rmi4_data->input_dev, 0);
+            input_mt_report_slot_state(rmi4_data->input_dev, MT_TOOL_FINGER, true);
+            input_report_abs(rmi4_data->input_dev, ABS_MT_PRESSURE, 1000);
+            input_sync(rmi4_data->input_dev);
+
+            /* Release all finger */
+        	for (fingers = 0; fingers < 10; fingers++) {
+        		input_mt_slot(rmi4_data->input_dev, fingers);
+        		input_mt_report_slot_state(rmi4_data->input_dev, MT_TOOL_FINGER, false);
+        	}
+            input_sync(rmi4_data->input_dev);
+#endif
+            return;
+        }
+    }
+#endif
+
+    if (rmi4_data->sensor_sleep && rmi4_data->wakeup_gesture) {
+#if defined CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_S3208
+		retval = synaptics_rmi4_reg_read(rmi4_data,
+		    		rmi4_data->f01_ctrl_base_addr + 5,
+	    			&gesture_type,
+	    			sizeof(gesture_type));
+		/*gesture_type is report_mode in S3208*/
+#elif defined CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_S3508
+		retval = synaptics_rmi4_reg_read(rmi4_data,
+    				0x0005,
+    				&interrupt_status,
+    				sizeof(interrupt_status));
+    	if (retval < 0) {
+    		dev_err(rmi4_data->pdev->dev.parent,
+    				"%s: Failed to read extended_status\n",
+    				__func__);
+    		return;
+    	}
+		
+		retval = synaptics_rmi4_reg_read(rmi4_data,
+					0x0007,
+					&gesture_type,
+					sizeof(gesture_type));
+#endif
+
+		if (retval < 0) {
+			dev_err(&(rmi4_data->input_dev->dev),
+					"%s: Failed to read gesture_type\n",
+					__func__);
+			return;
+		}
+		
+		dev_dbg(rmi4_data->pdev->dev.parent,
+				"%s: 0007 gesture_type %d \n", __func__, gesture_type);
+		
+#if defined CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_S3208
+		if (0x04 == (gesture_type & 0x07))
+#elif defined CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_S3508
+		if (0x02 == gesture_type)
+#endif
+		{
+#if ZTEMT_SYNAPTICS_DEBUG
+			input_report_key(rmi4_data->input_dev, KEY_POWER, 1);
+			input_sync(rmi4_data->input_dev);
+
+			input_report_key(rmi4_data->input_dev, KEY_POWER, 0);
+			input_sync(rmi4_data->input_dev);
+#else
+			input_report_key(rmi4_data->input_dev, KEY_F10, 1);
+			input_sync(rmi4_data->input_dev);
+
+			input_report_key(rmi4_data->input_dev, KEY_F10, 0);
+			input_sync(rmi4_data->input_dev);
+#endif
+
+			return;
+        }
+    }
+    /***ZTEMT END***/
+
+	status.data[0] = data[0];
+	if (status.unconfigured && !status.flash_prog) {
+		pr_notice("%s: spontaneous reset detected\n", __func__);
+		retval = synaptics_rmi4_reinit_device(rmi4_data);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to reinit device\n",
+					__func__);
+		}
+		return;
+	}
+
+	/*
+	 * Traverse the function handler list and service the source(s)
+	 * of the interrupt accordingly.
+	 */
+	if (!list_empty(&rmi->support_fn_list)) {
+		list_for_each_entry(fhandler, &rmi->support_fn_list, link) {
+			if (fhandler->num_of_data_sources) {
+				if (fhandler->intr_mask &
+						intr[fhandler->intr_reg_num]) {
+					synaptics_rmi4_report_touch(rmi4_data,
+							fhandler);
+				}
+			}
+		}
+	}
+
+	mutex_lock(&exp_data.mutex);
+	if (!list_empty(&exp_data.list)) {
+		list_for_each_entry(exp_fhandler, &exp_data.list, link) {
+			if (!exp_fhandler->insert &&
+					!exp_fhandler->remove &&
+					(exp_fhandler->exp_fn->attn != NULL))
+				exp_fhandler->exp_fn->attn(rmi4_data, intr[0]);
+		}
+	}
+	mutex_unlock(&exp_data.mutex);
+
+	return;
+}
+
+ /**
+ * synaptics_rmi4_irq()
+ *
+ * Called by the kernel when an interrupt occurs (when the sensor
+ * asserts the attention irq).
+ *
+ * This function is the ISR thread and handles the acquisition
+ * and the reporting of finger data when the presence of fingers
+ * is detected.
+ */
+static irqreturn_t synaptics_rmi4_irq(int irq, void *data)
+{
+	struct synaptics_rmi4_data *rmi4_data = data;
+
+	if (!rmi4_data->touch_stopped)
+		synaptics_rmi4_sensor_report(rmi4_data);
+
+	return IRQ_HANDLED;
+}
+
+ /**
+ * synaptics_rmi4_irq_enable()
+ *
+ * Called by synaptics_rmi4_probe() and the power management functions
+ * in this driver and also exported to other expansion Function modules
+ * such as rmi_dev.
+ *
+ * This function handles the enabling and disabling of the attention
+ * irq including the setting up of the ISR thread.
+ */
+static int synaptics_rmi4_irq_enable(struct synaptics_rmi4_data *rmi4_data,
+		bool enable)
+{
+	int retval = 0;
+	unsigned char intr_status[MAX_INTR_REGISTERS];
+	const struct synaptics_dsx_board_data *bdata =
+			rmi4_data->hw_if->board_data;
+
+	if (enable) {
+		if (rmi4_data->irq_enabled)
+			return retval;
+
+		/* Clear interrupts first */
+		retval = synaptics_rmi4_reg_read(rmi4_data,
+				rmi4_data->f01_data_base_addr + 1,
+				intr_status,
+				rmi4_data->num_of_intr_regs);
+		if (retval < 0)
+			return retval;
+
+		retval = request_threaded_irq(rmi4_data->irq, NULL,
+				synaptics_rmi4_irq, bdata->irq_flags,
+				PLATFORM_DRIVER_NAME, rmi4_data);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to create irq thread\n",
+					__func__);
+			return retval;
+		}
+
+		rmi4_data->irq_enabled = true;
+	} else {
+		if (rmi4_data->irq_enabled) {
+			disable_irq(rmi4_data->irq);
+			free_irq(rmi4_data->irq, rmi4_data);
+			rmi4_data->irq_enabled = false;
+		}
+	}
+
+	return retval;
+}
+
+static void synaptics_rmi4_set_intr_mask(struct synaptics_rmi4_fn *fhandler,
+		struct synaptics_rmi4_fn_desc *fd,
+		unsigned int intr_count)
+{
+	unsigned char ii;
+	unsigned char intr_offset;
+
+	fhandler->intr_reg_num = (intr_count + 7) / 8;
+	if (fhandler->intr_reg_num != 0)
+		fhandler->intr_reg_num -= 1;
+
+	/* Set an enable bit for each data source */
+	intr_offset = intr_count % 8;
+	fhandler->intr_mask = 0;
+	for (ii = intr_offset;
+			ii < ((fd->intr_src_count & MASK_3BIT) +
+			intr_offset);
+			ii++)
+		fhandler->intr_mask |= 1 << ii;
+
+	return;
+}
+
+static int synaptics_rmi4_f01_init(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler,
+		struct synaptics_rmi4_fn_desc *fd,
+		unsigned int intr_count)
+{
+	fhandler->fn_number = fd->fn_number;
+	fhandler->num_of_data_sources = fd->intr_src_count;
+	fhandler->data = NULL;
+	fhandler->extra = NULL;
+
+	synaptics_rmi4_set_intr_mask(fhandler, fd, intr_count);
+
+	rmi4_data->f01_query_base_addr = fd->query_base_addr;
+	rmi4_data->f01_ctrl_base_addr = fd->ctrl_base_addr;
+	rmi4_data->f01_data_base_addr = fd->data_base_addr;
+	rmi4_data->f01_cmd_base_addr = fd->cmd_base_addr;
+
+	return 0;
+}
+
+ /**
+ * synaptics_rmi4_f11_init()
+ *
+ * Called by synaptics_rmi4_query_device().
+ *
+ * This funtion parses information from the Function 11 registers
+ * and determines the number of fingers supported, x and y data ranges,
+ * offset to the associated interrupt status register, interrupt bit
+ * mask, and gathers finger data acquisition capabilities from the query
+ * registers.
+ */
+static int synaptics_rmi4_f11_init(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler,
+		struct synaptics_rmi4_fn_desc *fd,
+		unsigned int intr_count)
+{
+	int retval;
+	unsigned char abs_data_size;
+	unsigned char abs_data_blk_size;
+	unsigned char query[F11_STD_QUERY_LEN];
+	unsigned char control[F11_STD_CTRL_LEN];
+
+	fhandler->fn_number = fd->fn_number;
+	fhandler->num_of_data_sources = fd->intr_src_count;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			fhandler->full_addr.query_base,
+			query,
+			sizeof(query));
+	if (retval < 0)
+		return retval;
+
+	/* Maximum number of fingers supported */
+	if ((query[1] & MASK_3BIT) <= 4)
+		fhandler->num_of_data_points = (query[1] & MASK_3BIT) + 1;
+	else if ((query[1] & MASK_3BIT) == 5)
+		fhandler->num_of_data_points = 10;
+
+	rmi4_data->num_of_fingers = fhandler->num_of_data_points;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			fhandler->full_addr.ctrl_base,
+			control,
+			sizeof(control));
+	if (retval < 0)
+		return retval;
+
+	/* Maximum x and y */
+	rmi4_data->sensor_max_x = ((control[6] & MASK_8BIT) << 0) |
+			((control[7] & MASK_4BIT) << 8);
+	rmi4_data->sensor_max_y = ((control[8] & MASK_8BIT) << 0) |
+			((control[9] & MASK_4BIT) << 8);
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Function %02x max x = %d max y = %d\n",
+			__func__, fhandler->fn_number,
+			rmi4_data->sensor_max_x,
+			rmi4_data->sensor_max_y);
+
+	rmi4_data->max_touch_width = MAX_F11_TOUCH_WIDTH;
+
+	synaptics_rmi4_set_intr_mask(fhandler, fd, intr_count);
+
+	abs_data_size = query[5] & MASK_2BIT;
+	abs_data_blk_size = 3 + (2 * (abs_data_size == 0 ? 1 : 0));
+	fhandler->size_of_data_register_block = abs_data_blk_size;
+	fhandler->data = NULL;
+	fhandler->extra = NULL;
+
+	return retval;
+}
+
+static int synaptics_rmi4_f12_set_enables(struct synaptics_rmi4_data *rmi4_data,
+		unsigned short ctrl28)
+{
+	int retval;
+	static unsigned short ctrl_28_address;
+
+	if (ctrl28)
+		ctrl_28_address = ctrl28;
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			ctrl_28_address,
+			&rmi4_data->report_enable,
+			sizeof(rmi4_data->report_enable));
+	if (retval < 0)
+		return retval;
+
+	return retval;
+}
+
+ /**
+ * synaptics_rmi4_f12_init()
+ *
+ * Called by synaptics_rmi4_query_device().
+ *
+ * This funtion parses information from the Function 12 registers and
+ * determines the number of fingers supported, offset to the data1
+ * register, x and y data ranges, offset to the associated interrupt
+ * status register, interrupt bit mask, and allocates memory resources
+ * for finger data acquisition.
+ */
+static int synaptics_rmi4_f12_init(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler,
+		struct synaptics_rmi4_fn_desc *fd,
+		unsigned int intr_count)
+{
+	int retval;
+	unsigned char size_of_2d_data;
+	unsigned char size_of_query8;
+	unsigned char ctrl_8_offset;
+	unsigned char ctrl_23_offset;
+	unsigned char ctrl_28_offset;
+	unsigned char num_of_fingers;
+	struct synaptics_rmi4_f12_extra_data *extra_data;
+	struct synaptics_rmi4_f12_query_5 query_5;
+	struct synaptics_rmi4_f12_query_8 query_8;
+	struct synaptics_rmi4_f12_ctrl_8 ctrl_8;
+	struct synaptics_rmi4_f12_ctrl_23 ctrl_23;
+
+	fhandler->fn_number = fd->fn_number;
+	fhandler->num_of_data_sources = fd->intr_src_count;
+	fhandler->extra = kmalloc(sizeof(*extra_data), GFP_KERNEL);
+	extra_data = (struct synaptics_rmi4_f12_extra_data *)fhandler->extra;
+	size_of_2d_data = sizeof(struct synaptics_rmi4_f12_finger_data);
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			fhandler->full_addr.query_base + 5,
+			query_5.data,
+			sizeof(query_5.data));
+	if (retval < 0)
+		return retval;
+
+	ctrl_8_offset = query_5.ctrl0_is_present +
+			query_5.ctrl1_is_present +
+			query_5.ctrl2_is_present +
+			query_5.ctrl3_is_present +
+			query_5.ctrl4_is_present +
+			query_5.ctrl5_is_present +
+			query_5.ctrl6_is_present +
+			query_5.ctrl7_is_present;
+
+	ctrl_23_offset = ctrl_8_offset +
+			query_5.ctrl8_is_present +
+			query_5.ctrl9_is_present +
+			query_5.ctrl10_is_present +
+			query_5.ctrl11_is_present +
+			query_5.ctrl12_is_present +
+			query_5.ctrl13_is_present +
+			query_5.ctrl14_is_present +
+			query_5.ctrl15_is_present +
+			query_5.ctrl16_is_present +
+			query_5.ctrl17_is_present +
+			query_5.ctrl18_is_present +
+			query_5.ctrl19_is_present +
+			query_5.ctrl20_is_present +
+			query_5.ctrl21_is_present +
+			query_5.ctrl22_is_present;
+
+	ctrl_28_offset = ctrl_23_offset +
+			query_5.ctrl23_is_present +
+			query_5.ctrl24_is_present +
+			query_5.ctrl25_is_present +
+			query_5.ctrl26_is_present +
+			query_5.ctrl27_is_present;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			fhandler->full_addr.ctrl_base + ctrl_23_offset,
+			ctrl_23.data,
+			sizeof(ctrl_23.data));
+	if (retval < 0)
+		return retval;
+
+	/* Maximum number of fingers supported */
+	fhandler->num_of_data_points = min(ctrl_23.max_reported_objects,
+			(unsigned char)F12_FINGERS_TO_SUPPORT);
+
+	num_of_fingers = fhandler->num_of_data_points;
+	rmi4_data->num_of_fingers = num_of_fingers;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			fhandler->full_addr.query_base + 7,
+			&size_of_query8,
+			sizeof(size_of_query8));
+	if (retval < 0)
+		return retval;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			fhandler->full_addr.query_base + 8,
+			query_8.data,
+			size_of_query8);
+	if (retval < 0)
+		return retval;
+
+	/* Determine the presence of the Data0 register */
+	extra_data->data1_offset = query_8.data0_is_present;
+
+	if ((size_of_query8 >= 3) && (query_8.data15_is_present)) {
+		extra_data->data15_offset = query_8.data0_is_present +
+				query_8.data1_is_present +
+				query_8.data2_is_present +
+				query_8.data3_is_present +
+				query_8.data4_is_present +
+				query_8.data5_is_present +
+				query_8.data6_is_present +
+				query_8.data7_is_present +
+				query_8.data8_is_present +
+				query_8.data9_is_present +
+				query_8.data10_is_present +
+				query_8.data11_is_present +
+				query_8.data12_is_present +
+				query_8.data13_is_present +
+				query_8.data14_is_present;
+		extra_data->data15_size = (num_of_fingers + 7) / 8;
+	} else {
+		extra_data->data15_size = 0;
+	}
+
+	rmi4_data->report_enable = RPT_DEFAULT;
+#ifdef REPORT_2D_Z
+	rmi4_data->report_enable |= RPT_Z;
+#endif
+#ifdef REPORT_2D_W
+	rmi4_data->report_enable |= (RPT_WX | RPT_WY);
+#endif
+
+	retval = synaptics_rmi4_f12_set_enables(rmi4_data,
+			fhandler->full_addr.ctrl_base + ctrl_28_offset);
+	if (retval < 0)
+		return retval;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			fhandler->full_addr.ctrl_base + ctrl_8_offset,
+			ctrl_8.data,
+			sizeof(ctrl_8.data));
+	if (retval < 0)
+		return retval;
+
+	/* Maximum x and y */
+	rmi4_data->sensor_max_x =
+			((unsigned short)ctrl_8.max_x_coord_lsb << 0) |
+			((unsigned short)ctrl_8.max_x_coord_msb << 8);
+	rmi4_data->sensor_max_y =
+			((unsigned short)ctrl_8.max_y_coord_lsb << 0) |
+			((unsigned short)ctrl_8.max_y_coord_msb << 8);
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Function %02x max x = %d max y = %d\n",
+			__func__, fhandler->fn_number,
+			rmi4_data->sensor_max_x,
+			rmi4_data->sensor_max_y);
+
+	rmi4_data->num_of_rx = ctrl_8.num_of_rx;
+	rmi4_data->num_of_tx = ctrl_8.num_of_tx;
+	rmi4_data->max_touch_width = max(rmi4_data->num_of_rx,
+			rmi4_data->num_of_tx);
+
+	synaptics_rmi4_set_intr_mask(fhandler, fd, intr_count);
+
+	/* Allocate memory for finger data storage space */
+	fhandler->data_size = num_of_fingers * size_of_2d_data;
+	fhandler->data = kmalloc(fhandler->data_size, GFP_KERNEL);
+
+	return retval;
+}
+
+static int synaptics_rmi4_f1a_alloc_mem(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler)
+{
+	int retval;
+	struct synaptics_rmi4_f1a_handle *f1a;
+
+	f1a = kzalloc(sizeof(*f1a), GFP_KERNEL);
+	if (!f1a) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to alloc mem for function handle\n",
+				__func__);
+		return -ENOMEM;
+	}
+
+	fhandler->data = (void *)f1a;
+	fhandler->extra = NULL;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			fhandler->full_addr.query_base,
+			f1a->button_query.data,
+			sizeof(f1a->button_query.data));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read query registers\n",
+				__func__);
+		return retval;
+	}
+
+	f1a->max_count = f1a->button_query.max_button_count + 1;
+
+	f1a->button_control.txrx_map = kzalloc(f1a->max_count * 2, GFP_KERNEL);
+	if (!f1a->button_control.txrx_map) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to alloc mem for tx rx mapping\n",
+				__func__);
+		return -ENOMEM;
+	}
+
+	f1a->button_bitmask_size = (f1a->max_count + 7) / 8;
+
+	f1a->button_data_buffer = kcalloc(f1a->button_bitmask_size,
+			sizeof(*(f1a->button_data_buffer)), GFP_KERNEL);
+	if (!f1a->button_data_buffer) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to alloc mem for data buffer\n",
+				__func__);
+		return -ENOMEM;
+	}
+
+	f1a->button_map = kcalloc(f1a->max_count,
+			sizeof(*(f1a->button_map)), GFP_KERNEL);
+	if (!f1a->button_map) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to alloc mem for button map\n",
+				__func__);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int synaptics_rmi4_f1a_button_map(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler)
+{
+	int retval;
+	unsigned char ii;
+	unsigned char mapping_offset = 0;
+	struct synaptics_rmi4_f1a_handle *f1a = fhandler->data;
+	const struct synaptics_dsx_board_data *bdata =
+			rmi4_data->hw_if->board_data;
+
+	mapping_offset = f1a->button_query.has_general_control +
+			f1a->button_query.has_interrupt_enable +
+			f1a->button_query.has_multibutton_select;
+
+	if (f1a->button_query.has_tx_rx_map) {
+		retval = synaptics_rmi4_reg_read(rmi4_data,
+				fhandler->full_addr.ctrl_base + mapping_offset,
+				f1a->button_control.txrx_map,
+				sizeof(f1a->button_control.txrx_map));
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to read tx rx mapping\n",
+					__func__);
+			return retval;
+		}
+
+		rmi4_data->button_txrx_mapping = f1a->button_control.txrx_map;
+	}
+
+	if (!bdata->cap_button_map) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: cap_button_map is NULL in board file\n",
+				__func__);
+		return -ENODEV;
+	} else if (!bdata->cap_button_map->map) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Button map is missing in board file\n",
+				__func__);
+		return -ENODEV;
+	} else {
+		if (bdata->cap_button_map->nbuttons != f1a->max_count) {
+			f1a->valid_button_count = min(f1a->max_count,
+					bdata->cap_button_map->nbuttons);
+		} else {
+			f1a->valid_button_count = f1a->max_count;
+		}
+
+		for (ii = 0; ii < f1a->valid_button_count; ii++)
+			f1a->button_map[ii] = bdata->cap_button_map->map[ii];
+	}
+
+	return 0;
+}
+
+static void synaptics_rmi4_f1a_kfree(struct synaptics_rmi4_fn *fhandler)
+{
+	struct synaptics_rmi4_f1a_handle *f1a = fhandler->data;
+
+	if (f1a) {
+		kfree(f1a->button_control.txrx_map);
+		kfree(f1a->button_data_buffer);
+		kfree(f1a->button_map);
+		kfree(f1a);
+		fhandler->data = NULL;
+	}
+
+	return;
+}
+
+static int synaptics_rmi4_f1a_init(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler,
+		struct synaptics_rmi4_fn_desc *fd,
+		unsigned int intr_count)
+{
+	int retval;
+
+	fhandler->fn_number = fd->fn_number;
+	fhandler->num_of_data_sources = fd->intr_src_count;
+
+	synaptics_rmi4_set_intr_mask(fhandler, fd, intr_count);
+
+	retval = synaptics_rmi4_f1a_alloc_mem(rmi4_data, fhandler);
+	if (retval < 0)
+		goto error_exit;
+
+	retval = synaptics_rmi4_f1a_button_map(rmi4_data, fhandler);
+	if (retval < 0)
+		goto error_exit;
+
+	rmi4_data->button_0d_enabled = 1;
+
+	return 0;
+
+error_exit:
+	synaptics_rmi4_f1a_kfree(fhandler);
+
+	return retval;
+}
+
+static void synaptics_rmi4_empty_fn_list(struct synaptics_rmi4_data *rmi4_data)
+{
+	struct synaptics_rmi4_fn *fhandler;
+	struct synaptics_rmi4_fn *fhandler_temp;
+	struct synaptics_rmi4_device_info *rmi;
+
+	rmi = &(rmi4_data->rmi4_mod_info);
+
+	if (!list_empty(&rmi->support_fn_list)) {
+		list_for_each_entry_safe(fhandler,
+				fhandler_temp,
+				&rmi->support_fn_list,
+				link) {
+			if (fhandler->fn_number == SYNAPTICS_RMI4_F1A) {
+				synaptics_rmi4_f1a_kfree(fhandler);
+			} else {
+				kfree(fhandler->extra);
+				kfree(fhandler->data);
+			}
+			list_del(&fhandler->link);
+			kfree(fhandler);
+		}
+	}
+	INIT_LIST_HEAD(&rmi->support_fn_list);
+
+	return;
+}
+
+static int synaptics_rmi4_check_status(struct synaptics_rmi4_data *rmi4_data,
+		bool *was_in_bl_mode)
+{
+	int retval;
+	int timeout = CHECK_STATUS_TIMEOUT_MS;
+	unsigned char command = 0x01;
+	unsigned char intr_status;
+	struct synaptics_rmi4_f01_device_status status;
+
+	/* Do a device reset first */
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			rmi4_data->f01_cmd_base_addr,
+			&command,
+			sizeof(command));
+	if (retval < 0)
+		return retval;
+
+	msleep(rmi4_data->hw_if->board_data->reset_delay_ms);
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			rmi4_data->f01_data_base_addr,
+			status.data,
+			sizeof(status.data));
+	if (retval < 0)
+		return retval;
+
+	while (status.status_code == STATUS_CRC_IN_PROGRESS) {
+		if (timeout > 0)
+			msleep(20);
+		else
+			return -1;
+
+		retval = synaptics_rmi4_reg_read(rmi4_data,
+				rmi4_data->f01_data_base_addr,
+				status.data,
+				sizeof(status.data));
+		if (retval < 0)
+			return retval;
+
+		timeout -= 20;
+	}
+
+	if (timeout != CHECK_STATUS_TIMEOUT_MS)
+		*was_in_bl_mode = true;
+
+	if (status.flash_prog == 1) {
+		rmi4_data->flash_prog_mode = true;
+		pr_notice("%s: In flash prog mode, status = 0x%02x\n",
+				__func__,
+				status.status_code);
+	} else {
+		rmi4_data->flash_prog_mode = false;
+	}
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			rmi4_data->f01_data_base_addr + 1,
+			&intr_status,
+			sizeof(intr_status));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read interrupt status\n",
+				__func__);
+		return retval;
+	}
+
+	return 0;
+}
+
+static void synaptics_rmi4_set_configured(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	unsigned char device_ctrl;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			rmi4_data->f01_ctrl_base_addr,
+			&device_ctrl,
+			sizeof(device_ctrl));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to set configured\n",
+				__func__);
+		return;
+	}
+
+	rmi4_data->no_sleep_setting = device_ctrl & NO_SLEEP_ON;
+	device_ctrl |= CONFIGURED;
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			rmi4_data->f01_ctrl_base_addr,
+			&device_ctrl,
+			sizeof(device_ctrl));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to set configured\n",
+				__func__);
+	}
+
+	return;
+}
+
+static int synaptics_rmi4_alloc_fh(struct synaptics_rmi4_fn **fhandler,
+		struct synaptics_rmi4_fn_desc *rmi_fd, int page_number)
+{
+	*fhandler = kmalloc(sizeof(**fhandler), GFP_KERNEL);
+	if (!(*fhandler))
+		return -ENOMEM;
+
+	(*fhandler)->full_addr.data_base =
+			(rmi_fd->data_base_addr |
+			(page_number << 8));
+	(*fhandler)->full_addr.ctrl_base =
+			(rmi_fd->ctrl_base_addr |
+			(page_number << 8));
+	(*fhandler)->full_addr.cmd_base =
+			(rmi_fd->cmd_base_addr |
+			(page_number << 8));
+	(*fhandler)->full_addr.query_base =
+			(rmi_fd->query_base_addr |
+			(page_number << 8));
+
+	return 0;
+}
+
+ /**
+ * synaptics_rmi4_query_device()
+ *
+ * Called by synaptics_rmi4_probe().
+ *
+ * This funtion scans the page description table, records the offsets
+ * to the register types of Function $01, sets up the function handlers
+ * for Function $11 and Function $12, determines the number of interrupt
+ * sources from the sensor, adds valid Functions with data inputs to the
+ * Function linked list, parses information from the query registers of
+ * Function $01, and enables the interrupt sources from the valid Functions
+ * with data inputs.
+ */
+static int synaptics_rmi4_query_device(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	unsigned char ii;
+	unsigned char page_number;
+	unsigned char intr_count;
+	unsigned char f01_query[F01_STD_QUERY_LEN];
+	unsigned short pdt_entry_addr;
+	unsigned short intr_addr;
+	bool f01found;
+	bool was_in_bl_mode;
+	struct synaptics_rmi4_fn_desc rmi_fd;
+	struct synaptics_rmi4_fn *fhandler;
+	struct synaptics_rmi4_device_info *rmi;
+
+	rmi = &(rmi4_data->rmi4_mod_info);
+
+rescan_pdt:
+	f01found = false;
+	was_in_bl_mode = false;
+	intr_count = 0;
+	INIT_LIST_HEAD(&rmi->support_fn_list);
+
+	/* Scan the page description tables of the pages to service */
+	for (page_number = 0; page_number < PAGES_TO_SERVICE; page_number++) {
+		for (pdt_entry_addr = PDT_START; pdt_entry_addr > PDT_END;
+				pdt_entry_addr -= PDT_ENTRY_SIZE) {
+			pdt_entry_addr |= (page_number << 8);
+
+			retval = synaptics_rmi4_reg_read(rmi4_data,
+					pdt_entry_addr,
+					(unsigned char *)&rmi_fd,
+					sizeof(rmi_fd));
+			if (retval < 0)
+				return retval;
+
+			pdt_entry_addr &= ~(MASK_8BIT << 8);
+
+			fhandler = NULL;
+
+			if (rmi_fd.fn_number == 0) {
+				dev_dbg(rmi4_data->pdev->dev.parent,
+						"%s: Reached end of PDT\n",
+						__func__);
+				break;
+			}
+
+			dev_dbg(rmi4_data->pdev->dev.parent,
+					"%s: F%02x found (page %d)\n",
+					__func__, rmi_fd.fn_number,
+					page_number);
+
+			switch (rmi_fd.fn_number) {
+			case SYNAPTICS_RMI4_F01:
+				if (rmi_fd.intr_src_count == 0)
+					break;
+
+				f01found = true;
+
+				retval = synaptics_rmi4_alloc_fh(&fhandler,
+						&rmi_fd, page_number);
+				if (retval < 0) {
+					dev_err(rmi4_data->pdev->dev.parent,
+							"%s: Failed to alloc for F%d\n",
+							__func__,
+							rmi_fd.fn_number);
+					return retval;
+				}
+
+				retval = synaptics_rmi4_f01_init(rmi4_data,
+						fhandler, &rmi_fd, intr_count);
+				if (retval < 0)
+					return retval;
+
+				retval = synaptics_rmi4_check_status(rmi4_data,
+						&was_in_bl_mode);
+				if (retval < 0) {
+					dev_err(rmi4_data->pdev->dev.parent,
+							"%s: Failed to check status\n",
+							__func__);
+					return retval;
+				}
+
+				if (was_in_bl_mode) {
+					kfree(fhandler);
+					fhandler = NULL;
+					goto rescan_pdt;
+				}
+
+				if (rmi4_data->flash_prog_mode)
+					goto flash_prog_mode;
+
+				break;
+			case SYNAPTICS_RMI4_F11:
+				if (rmi_fd.intr_src_count == 0)
+					break;
+
+				retval = synaptics_rmi4_alloc_fh(&fhandler,
+						&rmi_fd, page_number);
+				if (retval < 0) {
+					dev_err(rmi4_data->pdev->dev.parent,
+							"%s: Failed to alloc for F%d\n",
+							__func__,
+							rmi_fd.fn_number);
+					return retval;
+				}
+
+				retval = synaptics_rmi4_f11_init(rmi4_data,
+						fhandler, &rmi_fd, intr_count);
+				if (retval < 0)
+					return retval;
+				break;
+			case SYNAPTICS_RMI4_F12:
+				if (rmi_fd.intr_src_count == 0)
+					break;
+
+				retval = synaptics_rmi4_alloc_fh(&fhandler,
+						&rmi_fd, page_number);
+				if (retval < 0) {
+					dev_err(rmi4_data->pdev->dev.parent,
+							"%s: Failed to alloc for F%d\n",
+							__func__,
+							rmi_fd.fn_number);
+					return retval;
+				}
+
+				retval = synaptics_rmi4_f12_init(rmi4_data,
+						fhandler, &rmi_fd, intr_count);
+				if (retval < 0)
+					return retval;
+				break;
+			case SYNAPTICS_RMI4_F1A:
+				if (rmi_fd.intr_src_count == 0)
+					break;
+
+				retval = synaptics_rmi4_alloc_fh(&fhandler,
+						&rmi_fd, page_number);
+				if (retval < 0) {
+					dev_err(rmi4_data->pdev->dev.parent,
+							"%s: Failed to alloc for F%d\n",
+							__func__,
+							rmi_fd.fn_number);
+					return retval;
+				}
+
+				retval = synaptics_rmi4_f1a_init(rmi4_data,
+						fhandler, &rmi_fd, intr_count);
+				if (retval < 0) {
+#ifdef IGNORE_FN_INIT_FAILURE
+					kfree(fhandler);
+					fhandler = NULL;
+#else
+					return retval;
+#endif
+				}
+				break;
+			}
+
+			/* Accumulate the interrupt count */
+			intr_count += (rmi_fd.intr_src_count & MASK_3BIT);
+
+			if (fhandler && rmi_fd.intr_src_count) {
+				list_add_tail(&fhandler->link,
+						&rmi->support_fn_list);
+			}
+		}
+	}
+
+	if (!f01found) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to find F01\n",
+				__func__);
+		return -EINVAL;
+	}
+
+flash_prog_mode:
+	rmi4_data->num_of_intr_regs = (intr_count + 7) / 8;
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Number of interrupt registers = %d\n",
+			__func__, rmi4_data->num_of_intr_regs);
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			rmi4_data->f01_query_base_addr,
+			f01_query,
+			sizeof(f01_query));
+	if (retval < 0)
+		return retval;
+
+	/* RMI Version 4.0 currently supported */
+	rmi->version_major = 4;
+	rmi->version_minor = 0;
+
+	rmi->manufacturer_id = f01_query[0];
+	rmi->product_props = f01_query[1];
+	rmi->product_info[0] = f01_query[2] & MASK_7BIT;
+	rmi->product_info[1] = f01_query[3] & MASK_7BIT;
+	rmi->date_code[0] = f01_query[4] & MASK_5BIT;
+	rmi->date_code[1] = f01_query[5] & MASK_4BIT;
+	rmi->date_code[2] = f01_query[6] & MASK_5BIT;
+	rmi->tester_id = ((f01_query[7] & MASK_7BIT) << 8) |
+			(f01_query[8] & MASK_7BIT);
+	rmi->serial_number = ((f01_query[9] & MASK_7BIT) << 8) |
+			(f01_query[10] & MASK_7BIT);
+	memcpy(rmi->product_id_string, &f01_query[11], 10);
+
+	if (rmi->manufacturer_id != 1) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Non-Synaptics device found, manufacturer ID = %d\n",
+				__func__, rmi->manufacturer_id);
+	}
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			rmi4_data->f01_query_base_addr + F01_BUID_ID_OFFSET,
+			rmi->build_id,
+			sizeof(rmi->build_id));
+	if (retval < 0)
+		return retval;
+
+	rmi4_data->firmware_id = (unsigned int)rmi->build_id[0] +
+			(unsigned int)rmi->build_id[1] * 0x100 +
+			(unsigned int)rmi->build_id[2] * 0x10000;
+
+    /*** ZTEMT Added by luochangyang, 2013/12/25 ***/
+	if (rmi4_data->firmware_id == (1544396)) {//NX504J
+		retval = synaptics_rmi4_reg_read(rmi4_data, 0x0A, rmi->config_id, sizeof(rmi->config_id));
+	} else if (rmi4_data->firmware_id == (1562749)) {//NX503A NX403A
+        retval = synaptics_rmi4_reg_read(rmi4_data, 0x56, rmi->config_id, sizeof(rmi->config_id));
+    } else {
+        retval = synaptics_rmi4_reg_read(rmi4_data, 0x59, rmi->config_id, sizeof(rmi->config_id));
+    }
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read firmware config id (code %d)\n",
+				__func__, retval);
+		return retval;
+	}
+    /***ZTEMT END***/
+
+	memset(rmi4_data->intr_mask, 0x00, sizeof(rmi4_data->intr_mask));
+
+	/*
+	 * Map out the interrupt bit masks for the interrupt sources
+	 * from the registered function handlers.
+	 */
+	if (!list_empty(&rmi->support_fn_list)) {
+		list_for_each_entry(fhandler, &rmi->support_fn_list, link) {
+			if (fhandler->num_of_data_sources) {
+				rmi4_data->intr_mask[fhandler->intr_reg_num] |=
+						fhandler->intr_mask;
+			}
+		}
+	}
+
+	/* Enable the interrupt sources */
+	for (ii = 0; ii < rmi4_data->num_of_intr_regs; ii++) {
+		if (rmi4_data->intr_mask[ii] != 0x00) {
+			dev_dbg(rmi4_data->pdev->dev.parent,
+					"%s: Interrupt enable mask %d = 0x%02x\n",
+					__func__, ii, rmi4_data->intr_mask[ii]);
+			intr_addr = rmi4_data->f01_ctrl_base_addr + 1 + ii;
+			retval = synaptics_rmi4_reg_write(rmi4_data,
+					intr_addr,
+					&(rmi4_data->intr_mask[ii]),
+					sizeof(rmi4_data->intr_mask[ii]));
+			if (retval < 0)
+				return retval;
+		}
+	}
+
+	synaptics_rmi4_set_configured(rmi4_data);
+
+	return 0;
+}
+
+static void synaptics_rmi4_set_params(struct synaptics_rmi4_data *rmi4_data)
+{
+	unsigned char ii;
+	struct synaptics_rmi4_f1a_handle *f1a;
+	struct synaptics_rmi4_fn *fhandler;
+	struct synaptics_rmi4_device_info *rmi;
+
+	rmi = &(rmi4_data->rmi4_mod_info);
+
+	input_set_abs_params(rmi4_data->input_dev,
+			ABS_MT_POSITION_X, 0,
+			rmi4_data->sensor_max_x, 0, 0);
+	input_set_abs_params(rmi4_data->input_dev,
+			ABS_MT_POSITION_Y, 0,
+			rmi4_data->sensor_max_y, 0, 0);
+#ifdef REPORT_2D_W
+	input_set_abs_params(rmi4_data->input_dev,
+			ABS_MT_TOUCH_MAJOR, 0,
+			rmi4_data->max_touch_width, 0, 0);
+	input_set_abs_params(rmi4_data->input_dev,
+			ABS_MT_TOUCH_MINOR, 0,
+			rmi4_data->max_touch_width, 0, 0);
+	
+	/*luochangyang for Palm Sleep 2014/06/12*/
+	input_set_abs_params(rmi4_data->input_dev,
+			ABS_MT_PRESSURE, 0, 255, 0, 0);
+	/*luochangyang END*/
+#endif
+
+#ifdef TYPE_B_PROTOCOL
+	input_mt_init_slots(rmi4_data->input_dev,
+			rmi4_data->num_of_fingers);
+#endif
+
+	f1a = NULL;
+	if (!list_empty(&rmi->support_fn_list)) {
+		list_for_each_entry(fhandler, &rmi->support_fn_list, link) {
+			if (fhandler->fn_number == SYNAPTICS_RMI4_F1A)
+				f1a = fhandler->data;
+		}
+	}
+
+	if (f1a) {
+		for (ii = 0; ii < f1a->valid_button_count; ii++) {
+			set_bit(f1a->button_map[ii],
+					rmi4_data->input_dev->keybit);
+			input_set_capability(rmi4_data->input_dev,
+					EV_KEY, f1a->button_map[ii]);
+		}
+	}
+
+	return;
+}
+
+static int synaptics_rmi4_set_input_dev(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	int temp;
+
+	rmi4_data->input_dev = input_allocate_device();
+	if (rmi4_data->input_dev == NULL) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to allocate input device\n",
+				__func__);
+		retval = -ENOMEM;
+		goto err_input_device;
+	}
+
+	retval = synaptics_rmi4_query_device(rmi4_data);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to query device\n",
+				__func__);
+		goto err_query_device;
+	}
+
+	rmi4_data->input_dev->name = PLATFORM_DRIVER_NAME;
+	rmi4_data->input_dev->phys = INPUT_PHYS_NAME;
+	rmi4_data->input_dev->id.product = SYNAPTICS_DSX_DRIVER_PRODUCT;
+	rmi4_data->input_dev->id.version = SYNAPTICS_DSX_DRIVER_VERSION;
+	rmi4_data->input_dev->dev.parent = rmi4_data->pdev->dev.parent;
+	input_set_drvdata(rmi4_data->input_dev, rmi4_data);
+
+	set_bit(EV_SYN, rmi4_data->input_dev->evbit);
+	set_bit(EV_KEY, rmi4_data->input_dev->evbit);
+	set_bit(EV_ABS, rmi4_data->input_dev->evbit);
+	set_bit(BTN_TOUCH, rmi4_data->input_dev->keybit);
+	set_bit(BTN_TOOL_FINGER, rmi4_data->input_dev->keybit);
+#ifdef INPUT_PROP_DIRECT
+	set_bit(INPUT_PROP_DIRECT, rmi4_data->input_dev->propbit);
+#endif
+	/*luochangyang 2014/03/19*/	
+    set_bit(KEY_POWER, rmi4_data->input_dev->keybit);
+    set_bit(KEY_F10, rmi4_data->input_dev->keybit);
+	/*luochangyang END*/
+
+	if (rmi4_data->hw_if->board_data->swap_axes) {
+		temp = rmi4_data->sensor_max_x;
+		rmi4_data->sensor_max_x = rmi4_data->sensor_max_y;
+		rmi4_data->sensor_max_y = temp;
+	}
+
+	synaptics_rmi4_set_params(rmi4_data);
+
+	retval = input_register_device(rmi4_data->input_dev);
+	if (retval) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to register input device\n",
+				__func__);
+		goto err_register_input;
+	}
+
+	return 0;
+
+err_register_input:
+err_query_device:
+	synaptics_rmi4_empty_fn_list(rmi4_data);
+	input_free_device(rmi4_data->input_dev);
+
+err_input_device:
+	return retval;
+}
+
+static int synaptics_rmi4_set_gpio(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	int power_on;
+	int reset_on;
+	const struct synaptics_dsx_board_data *bdata =
+			rmi4_data->hw_if->board_data;
+
+	power_on = bdata->power_on_state;
+	reset_on = bdata->reset_on_state;
+
+	retval = bdata->gpio_config(
+			bdata->irq_gpio,
+			true, 0, 0);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to configure attention GPIO\n",
+				__func__);
+		goto err_gpio_irq;
+	}
+
+	if (bdata->power_gpio >= 0) {
+		retval = bdata->gpio_config(
+				bdata->power_gpio,
+				true, 1, !power_on);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to configure power GPIO\n",
+					__func__);
+			goto err_gpio_power;
+		}
+	}
+
+	if (bdata->reset_gpio >= 0) {
+		retval = bdata->gpio_config(
+				bdata->reset_gpio,
+				true, 1, !reset_on);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to configure reset GPIO\n",
+					__func__);
+			goto err_gpio_reset;
+		}
+	}
+
+	if (bdata->power_gpio >= 0) {
+		gpio_set_value(bdata->power_gpio, power_on);
+		msleep(bdata->power_delay_ms);
+	}
+
+	if (bdata->reset_gpio >= 0) {
+		gpio_set_value(bdata->reset_gpio, reset_on);
+		msleep(bdata->reset_active_ms);
+		gpio_set_value(bdata->reset_gpio, !reset_on);
+		msleep(bdata->reset_delay_ms);
+	}
+
+	return 0;
+
+err_gpio_reset:
+	if (bdata->power_gpio >= 0) {
+		bdata->gpio_config(
+				bdata->power_gpio,
+				false, 0, 0);
+	}
+
+err_gpio_power:
+	bdata->gpio_config(
+			bdata->irq_gpio,
+			false, 0, 0);
+
+err_gpio_irq:
+	return retval;
+}
+
+static int synaptics_rmi4_free_fingers(struct synaptics_rmi4_data *rmi4_data)
+{
+	unsigned char ii;
+	mutex_lock(&(rmi4_data->rmi4_report_mutex));
+
+#ifdef TYPE_B_PROTOCOL
+	for (ii = 0; ii < rmi4_data->num_of_fingers; ii++) {
+		input_mt_slot(rmi4_data->input_dev, ii);
+		input_mt_report_slot_state(rmi4_data->input_dev,
+				MT_TOOL_FINGER, 0);
+	}
+#endif
+	input_report_key(rmi4_data->input_dev,
+			BTN_TOUCH, 0);
+	input_report_key(rmi4_data->input_dev,
+			BTN_TOOL_FINGER, 0);
+#ifndef TYPE_B_PROTOCOL
+	input_mt_sync(rmi4_data->input_dev);
+#endif
+	input_sync(rmi4_data->input_dev);
+
+	mutex_unlock(&(rmi4_data->rmi4_report_mutex));
+	rmi4_data->fingers_on_2d = false;
+
+	return 0;
+}
+
+static int synaptics_rmi4_reinit_device(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	unsigned char ii;
+	unsigned short intr_addr;
+	struct synaptics_rmi4_fn *fhandler;
+	struct synaptics_rmi4_exp_fhandler *exp_fhandler;
+	struct synaptics_rmi4_device_info *rmi;
+
+	rmi = &(rmi4_data->rmi4_mod_info);
+
+	mutex_lock(&(rmi4_data->rmi4_reset_mutex));
+
+	synaptics_rmi4_free_fingers(rmi4_data);
+
+	if (!list_empty(&rmi->support_fn_list)) {
+		list_for_each_entry(fhandler, &rmi->support_fn_list, link) {
+			if (fhandler->fn_number == SYNAPTICS_RMI4_F12) {
+				synaptics_rmi4_f12_set_enables(rmi4_data, 0);
+				break;
+			}
+		}
+	}
+
+	for (ii = 0; ii < rmi4_data->num_of_intr_regs; ii++) {
+		if (rmi4_data->intr_mask[ii] != 0x00) {
+			dev_dbg(rmi4_data->pdev->dev.parent,
+					"%s: Interrupt enable mask %d = 0x%02x\n",
+					__func__, ii, rmi4_data->intr_mask[ii]);
+			intr_addr = rmi4_data->f01_ctrl_base_addr + 1 + ii;
+			retval = synaptics_rmi4_reg_write(rmi4_data,
+					intr_addr,
+					&(rmi4_data->intr_mask[ii]),
+					sizeof(rmi4_data->intr_mask[ii]));
+			if (retval < 0)
+				goto exit;
+		}
+	}
+
+	mutex_lock(&exp_data.mutex);
+	if (!list_empty(&exp_data.list)) {
+		list_for_each_entry(exp_fhandler, &exp_data.list, link)
+			if (exp_fhandler->exp_fn->reinit != NULL)
+				exp_fhandler->exp_fn->reinit(rmi4_data);
+	}
+	mutex_unlock(&exp_data.mutex);
+
+	synaptics_rmi4_set_configured(rmi4_data);
+
+	retval = 0;
+
+exit:
+	mutex_unlock(&(rmi4_data->rmi4_reset_mutex));
+	return retval;
+}
+
+static int synaptics_rmi4_reset_device(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	int temp;
+	unsigned char command = 0x01;
+	struct synaptics_rmi4_exp_fhandler *exp_fhandler;
+
+	mutex_lock(&(rmi4_data->rmi4_reset_mutex));
+
+	rmi4_data->touch_stopped = true;
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			rmi4_data->f01_cmd_base_addr,
+			&command,
+			sizeof(command));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to issue reset command, error = %d\n",
+				__func__, retval);
+		mutex_unlock(&(rmi4_data->rmi4_reset_mutex));
+		return retval;
+	}
+
+	msleep(rmi4_data->hw_if->board_data->reset_delay_ms);
+
+	synaptics_rmi4_free_fingers(rmi4_data);
+
+	synaptics_rmi4_empty_fn_list(rmi4_data);
+
+	retval = synaptics_rmi4_query_device(rmi4_data);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to query device\n",
+				__func__);
+		mutex_unlock(&(rmi4_data->rmi4_reset_mutex));
+		return retval;
+	}
+
+	if (rmi4_data->hw_if->board_data->swap_axes) {
+		temp = rmi4_data->sensor_max_x;
+		rmi4_data->sensor_max_x = rmi4_data->sensor_max_y;
+		rmi4_data->sensor_max_y = temp;
+	}
+
+	synaptics_rmi4_set_params(rmi4_data);
+
+	mutex_lock(&exp_data.mutex);
+	if (!list_empty(&exp_data.list)) {
+		list_for_each_entry(exp_fhandler, &exp_data.list, link)
+			if (exp_fhandler->exp_fn->reset != NULL)
+				exp_fhandler->exp_fn->reset(rmi4_data);
+	}
+	mutex_unlock(&exp_data.mutex);
+
+	rmi4_data->touch_stopped = false;
+
+	mutex_unlock(&(rmi4_data->rmi4_reset_mutex));
+
+	return 0;
+}
+
+/**
+* synaptics_rmi4_exp_fn_work()
+*
+* Called by the kernel at the scheduled time.
+*
+* This function is a work thread that checks for the insertion and
+* removal of other expansion Function modules such as rmi_dev and calls
+* their initialization and removal callback functions accordingly.
+*/
+static void synaptics_rmi4_exp_fn_work(struct work_struct *work)
+{
+	int retval;
+	struct synaptics_rmi4_exp_fhandler *exp_fhandler;
+	struct synaptics_rmi4_exp_fhandler *exp_fhandler_temp;
+	struct synaptics_rmi4_data *rmi4_data = exp_data.rmi4_data;
+
+	mutex_lock(&exp_data.mutex);
+	if (!list_empty(&exp_data.list)) {
+		list_for_each_entry_safe(exp_fhandler,
+				exp_fhandler_temp,
+				&exp_data.list,
+				link) {
+			if ((exp_fhandler->exp_fn->init != NULL) &&
+					exp_fhandler->insert) {
+				retval = exp_fhandler->exp_fn->init(rmi4_data);
+				if (retval < 0) {
+					list_del(&exp_fhandler->link);
+					kfree(exp_fhandler);
+				} else {
+					exp_fhandler->insert = false;
+				}
+			} else if ((exp_fhandler->exp_fn->remove != NULL) &&
+					exp_fhandler->remove) {
+				exp_fhandler->exp_fn->remove(rmi4_data);
+				list_del(&exp_fhandler->link);
+				kfree(exp_fhandler);
+			}
+		}
+	}
+	mutex_unlock(&exp_data.mutex);
+
+	return;
+}
+
+/**
+* synaptics_rmi4_new_function()
+*
+* Called by other expansion Function modules in their module init and
+* module exit functions.
+*
+* This function is used by other expansion Function modules such as
+* rmi_dev to register themselves with the driver by providing their
+* initialization and removal callback function pointers so that they
+* can be inserted or removed dynamically at module init and exit times,
+* respectively.
+*/
+void synaptics_rmi4_new_function(struct synaptics_rmi4_exp_fn *exp_fn,
+		bool insert)
+{
+	struct synaptics_rmi4_exp_fhandler *exp_fhandler;
+
+	if (!exp_data.initialized) {
+		mutex_init(&exp_data.mutex);
+		INIT_LIST_HEAD(&exp_data.list);
+		exp_data.initialized = true;
+	}
+
+	mutex_lock(&exp_data.mutex);
+	if (insert) {
+		exp_fhandler = kzalloc(sizeof(*exp_fhandler), GFP_KERNEL);
+		if (!exp_fhandler) {
+			pr_err("%s: Failed to alloc mem for expansion function\n",
+					__func__);
+			goto exit;
+		}
+		exp_fhandler->exp_fn = exp_fn;
+		exp_fhandler->insert = true;
+		exp_fhandler->remove = false;
+		list_add_tail(&exp_fhandler->link, &exp_data.list);
+	} else if (!list_empty(&exp_data.list)) {
+		list_for_each_entry(exp_fhandler, &exp_data.list, link) {
+			if (exp_fhandler->exp_fn->fn_type == exp_fn->fn_type) {
+				exp_fhandler->insert = false;
+				exp_fhandler->remove = true;
+				goto exit;
+			}
+		}
+	}
+
+exit:
+	mutex_unlock(&exp_data.mutex);
+
+	if (exp_data.queue_work) {
+		queue_delayed_work(exp_data.workqueue,
+				&exp_data.work,
+				msecs_to_jiffies(EXP_FN_WORK_DELAY_MS));
+	}
+
+	return;
+}
+EXPORT_SYMBOL(synaptics_rmi4_new_function);
+
+ /**
+ * synaptics_rmi4_probe()
+ *
+ * Called by the kernel when an association with an I2C device of the
+ * same name is made (after doing i2c_add_driver).
+ *
+ * This funtion allocates and initializes the resources for the driver
+ * as an input driver, turns on the power to the sensor, queries the
+ * sensor for its supported Functions and characteristics, registers
+ * the driver to the input subsystem, sets up the interrupt, handles
+ * the registration of the early_suspend and late_resume functions,
+ * and creates a work queue for detection of other expansion Function
+ * modules.
+ */
+static int __devinit synaptics_rmi4_probe(struct platform_device *pdev)
+{
+	int retval;
+	unsigned char attr_count;
+	struct synaptics_rmi4_data *rmi4_data;
+	const struct synaptics_dsx_hw_interface *hw_if;
+	const struct synaptics_dsx_board_data *bdata;
+
+	hw_if = pdev->dev.platform_data;
+	if (!hw_if) {
+		dev_err(&pdev->dev,
+				"%s: No hardware interface found\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	bdata = hw_if->board_data;
+	if (!bdata) {
+		dev_err(&pdev->dev,
+				"%s: No board data found\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	rmi4_data = kzalloc(sizeof(*rmi4_data), GFP_KERNEL);
+	if (!rmi4_data) {
+		dev_err(&pdev->dev,
+				"%s: Failed to alloc mem for rmi4_data\n",
+				__func__);
+		return -ENOMEM;
+	}
+
+/*** ZTEMT Modify by luochangyang, 2013/12/20 ***/
+#if 0
+	if (*bdata->regulator_name != 0x00) {
+		rmi4_data->regulator = regulator_get(&pdev->dev, bdata->regulator_name);
+		if (IS_ERR(rmi4_data->regulator)) {
+			dev_err(&pdev->dev,
+					"%s: Failed to get regulator\n",
+					__func__);
+			retval = PTR_ERR(rmi4_data->regulator);
+			goto err_regulator;
+		}
+		regulator_enable(rmi4_data->regulator);
+		msleep(bdata->power_delay_ms);
+	}
+#else
+#ifdef CONFIG_OF
+    rmi4_data->regulator_vcc = regulator_get(pdev->dev.parent, "vcc_i2c");
+    if (IS_ERR(rmi4_data->regulator_vcc))
+    {
+        retval = PTR_ERR(rmi4_data->regulator_vcc);
+        dev_err(&pdev->dev, "Regulator get vcc_i2c failed rc=%d\n", retval);
+        goto err_regulator;
+    }
+
+    retval = regulator_enable(rmi4_data->regulator_vcc);
+    if (retval)
+    {
+        dev_err(&pdev->dev, "Regulator vcc_i2c enable failed rc=%d\n", retval);
+        goto err_regulator;
+    }
+    
+    rmi4_data->regulator = regulator_get(pdev->dev.parent, "vdd_ana");
+#else
+    rmi4_data->regulator = regulator_get(&pdev->dev, "pm8941_l18");
+#endif
+    
+    if (IS_ERR(rmi4_data->regulator)) {
+        dev_err(&pdev->dev,
+                "%s: Failed to get regulator pm8941_l18\n",
+                __func__);
+        retval = PTR_ERR(rmi4_data->regulator);
+        goto err_regulator;
+    }
+    
+    retval = regulator_set_voltage(rmi4_data->regulator, 2850000, 2850000);
+    if (retval) {
+        pr_err("set_voltage rmi4_data->regulator failed, rc=%d\n", retval);
+        goto err_regulator;
+    }
+
+    regulator_enable(rmi4_data->regulator);
+    msleep(bdata->power_delay_ms);
+ #endif
+ /***ZTEMT END***/
+
+	rmi4_data->pdev = pdev;
+	rmi4_data->current_page = MASK_8BIT;
+	rmi4_data->hw_if = hw_if;
+	rmi4_data->touch_stopped = false;
+	rmi4_data->sensor_sleep = false;
+	rmi4_data->irq_enabled = false;
+	rmi4_data->fingers_on_2d = false;
+    /*** ZTEMT Added by luochangyang, 2013/11/19 ***/
+#if ZTEMT_SYNAPTICS_DEBUG
+    rmi4_data->wakeup_gesture = true;
+#else
+    rmi4_data->wakeup_gesture = false;
+#endif
+    /***ZTEMT END***/
+
+	rmi4_data->irq_enable = synaptics_rmi4_irq_enable;
+	rmi4_data->reset_device = synaptics_rmi4_reset_device;
+
+	mutex_init(&(rmi4_data->rmi4_io_ctrl_mutex));
+	mutex_init(&(rmi4_data->rmi4_reset_mutex));
+	mutex_init(&(rmi4_data->rmi4_report_mutex));
+
+	platform_set_drvdata(pdev, rmi4_data);
+
+	if (bdata->gpio_config) {
+		retval = synaptics_rmi4_set_gpio(rmi4_data);
+		if (retval < 0) {
+			dev_err(&pdev->dev,
+					"%s: Failed to set up GPIO's\n",
+					__func__);
+			goto err_set_gpio;
+		}
+	}
+
+	retval = synaptics_rmi4_set_input_dev(rmi4_data);
+	if (retval < 0) {
+		dev_err(&pdev->dev,
+				"%s: Failed to set up input device\n",
+				__func__);
+		goto err_set_input_dev;
+	}
+
+/* ZTEMT Added by luochangyang, 2013/12/25 */
+#if defined(CONFIG_FB)
+    rmi4_data->fb_notif.notifier_call = synaptics_rmi4_fb_notifier_callback;
+
+    retval = fb_register_client(&rmi4_data->fb_notif);
+    if (retval) {
+        dev_err(&pdev->dev, "%s:Unable to register fb_notifier: %d\n", __func__, retval);
+    }
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+/*ZTEMT END*/
+	rmi4_data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	rmi4_data->early_suspend.suspend = synaptics_rmi4_early_suspend;
+	rmi4_data->early_suspend.resume = synaptics_rmi4_late_resume;
+	register_early_suspend(&rmi4_data->early_suspend);
+#endif
+
+	rmi4_data->irq = gpio_to_irq(bdata->irq_gpio);
+
+	retval = synaptics_rmi4_irq_enable(rmi4_data, true);
+	if (retval < 0) {
+		dev_err(&pdev->dev,
+				"%s: Failed to enable attention interrupt\n",
+				__func__);
+		goto err_enable_irq;
+	}
+
+	if (!exp_data.initialized) {
+		mutex_init(&exp_data.mutex);
+		INIT_LIST_HEAD(&exp_data.list);
+		exp_data.initialized = true;
+	}
+
+	exp_data.workqueue = create_singlethread_workqueue("dsx_exp_workqueue");
+	INIT_DELAYED_WORK(&exp_data.work, synaptics_rmi4_exp_fn_work);
+	exp_data.rmi4_data = rmi4_data;
+	exp_data.queue_work = true;
+	queue_delayed_work(exp_data.workqueue,
+			&exp_data.work,
+			msecs_to_jiffies(EXP_FN_WORK_DELAY_MS));
+
+	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++) {
+		retval = sysfs_create_file(&rmi4_data->input_dev->dev.kobj,
+				&attrs[attr_count].attr);
+		if (retval < 0) {
+			dev_err(&pdev->dev,
+					"%s: Failed to create sysfs attributes\n",
+					__func__);
+			goto err_sysfs;
+		}
+	}
+
+    /*** ZTEMT Added by luochangyang, 2014/03/19 ***/
+	device_init_wakeup(&pdev->dev, 1);
+    /***ZTEMT END***/
+
+	return retval;
+
+err_sysfs:
+	for (attr_count--; attr_count >= 0; attr_count--) {
+		sysfs_remove_file(&rmi4_data->input_dev->dev.kobj,
+				&attrs[attr_count].attr);
+	}
+
+	cancel_delayed_work_sync(&exp_data.work);
+	flush_workqueue(exp_data.workqueue);
+	destroy_workqueue(exp_data.workqueue);
+
+	synaptics_rmi4_irq_enable(rmi4_data, false);
+
+err_enable_irq:
+/*** ZTEMT Added by luochangyang, 2013/12/25 ***/
+#if defined(CONFIG_FB)
+    if (fb_unregister_client(&rmi4_data->fb_notif))
+        dev_err(&pdev->dev, "Error occurred while unregistering fb_notifier.\n");
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+    unregister_early_suspend(&rmi4_data->early_suspend);
+#endif
+/***ZTEMT END***/
+
+	synaptics_rmi4_empty_fn_list(rmi4_data);
+	input_unregister_device(rmi4_data->input_dev);
+	rmi4_data->input_dev = NULL;
+
+err_set_input_dev:
+	if (bdata->gpio_config) {
+		bdata->gpio_config(
+				bdata->irq_gpio,
+				false, 0, 0);
+
+		if (bdata->reset_gpio >= 0) {
+			bdata->gpio_config(
+					bdata->reset_gpio,
+					false, 0, 0);
+		}
+
+		if (bdata->power_gpio >= 0) {
+			bdata->gpio_config(
+					bdata->power_gpio,
+					false, 0, 0);
+		}
+	}
+
+err_set_gpio:
+	if (rmi4_data->regulator) {
+		regulator_disable(rmi4_data->regulator);
+		regulator_put(rmi4_data->regulator);
+	}
+
+err_regulator:
+	kfree(rmi4_data);
+
+	return retval;
+}
+
+ /**
+ * synaptics_rmi4_remove()
+ *
+ * Called by the kernel when the association with an I2C device of the
+ * same name is broken (when the driver is unloaded).
+ *
+ * This funtion terminates the work queue, stops sensor data acquisition,
+ * frees the interrupt, unregisters the driver from the input subsystem,
+ * turns off the power to the sensor, and frees other allocated resources.
+ */
+static int __devexit synaptics_rmi4_remove(struct platform_device *pdev)
+{
+	unsigned char attr_count;
+	struct synaptics_rmi4_data *rmi4_data = platform_get_drvdata(pdev);
+	const struct synaptics_dsx_board_data *bdata =
+			rmi4_data->hw_if->board_data;
+
+	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++) {
+		sysfs_remove_file(&rmi4_data->input_dev->dev.kobj,
+				&attrs[attr_count].attr);
+	}
+
+	cancel_delayed_work_sync(&exp_data.work);
+	flush_workqueue(exp_data.workqueue);
+	destroy_workqueue(exp_data.workqueue);
+
+	synaptics_rmi4_irq_enable(rmi4_data, false);
+
+/*** ZTEMT Added by luochangyang, 2013/12/25 ***/
+#if defined(CONFIG_FB)
+    if (fb_unregister_client(&rmi4_data->fb_notif))
+        dev_err(&pdev->dev, "Error occurred while unregistering fb_notifier.\n");
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+    unregister_early_suspend(&rmi4_data->early_suspend);
+#endif
+/***ZTEMT END***/
+
+	synaptics_rmi4_empty_fn_list(rmi4_data);
+	input_unregister_device(rmi4_data->input_dev);
+	rmi4_data->input_dev = NULL;
+
+	if (bdata->gpio_config) {
+		bdata->gpio_config(
+				bdata->irq_gpio,
+				false, 0, 0);
+
+		if (bdata->reset_gpio >= 0) {
+			bdata->gpio_config(
+					bdata->reset_gpio,
+					false, 0, 0);
+		}
+
+		if (bdata->power_gpio >= 0) {
+			bdata->gpio_config(
+					bdata->power_gpio,
+					false, 0, 0);
+		}
+	}
+
+	if (rmi4_data->regulator) {
+		regulator_disable(rmi4_data->regulator);
+		regulator_put(rmi4_data->regulator);
+	}
+
+	kfree(rmi4_data);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+ /**
+ * synaptics_rmi4_sensor_sleep()
+ *
+ * Called by synaptics_rmi4_early_suspend() and synaptics_rmi4_suspend().
+ *
+ * This function stops finger data acquisition and puts the sensor to sleep.
+ */
+static void synaptics_rmi4_sensor_sleep(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	unsigned char device_ctrl;
+    /*** ZTEMT Added by luochangyang, 2014/03/19 ***/
+    unsigned char report_mode[3];
+	
+	if (!(rmi4_data->sensor_sleep) && rmi4_data->wakeup_gesture) {
+		
+#if defined CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_S3208
+		retval = synaptics_rmi4_reg_read(rmi4_data,
+				rmi4_data->f01_ctrl_base_addr + 5,
+				&report_mode[0],
+				sizeof(report_mode[0]));
+#elif defined CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_S3508
+		retval = synaptics_rmi4_reg_read(rmi4_data,
+				0x001A,
+				report_mode,
+				sizeof(report_mode));
+#endif
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to change report mode\n", __func__);
+			rmi4_data->sensor_sleep = false;
+			return;
+		}
+
+		dev_dbg(rmi4_data->pdev->dev.parent,
+				"%s: 0x001A report_mode %d %d %d \n", __func__, 
+				report_mode[0], report_mode[1], report_mode[2]);
+
+#if defined CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_S3208
+		report_mode[0] |= 0x04;
+
+		retval = synaptics_rmi4_reg_write(rmi4_data,
+				rmi4_data->f01_ctrl_base_addr + 5,
+				&report_mode[0],
+				sizeof(report_mode[0]));
+#elif defined CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_S3508
+		report_mode[0] = 0x00;
+		report_mode[1] = 0x00;
+		report_mode[2] = 0x02;
+		
+		retval = synaptics_rmi4_reg_write(rmi4_data,
+				0x001A,
+				report_mode,
+				sizeof(report_mode));
+#endif
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to change report mode\n",
+					__func__);
+			rmi4_data->sensor_sleep = false;
+			return;
+		} else {
+			rmi4_data->sensor_sleep = true;
+		}
+		
+		return;
+	}
+	/***ZTEMT END***/
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			rmi4_data->f01_ctrl_base_addr,
+			&device_ctrl,
+			sizeof(device_ctrl));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to enter sleep mode\n",
+				__func__);
+		rmi4_data->sensor_sleep = false;
+		return;
+	}
+
+	device_ctrl = (device_ctrl & ~MASK_3BIT);
+	device_ctrl = (device_ctrl | NO_SLEEP_OFF | SENSOR_SLEEP);
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			rmi4_data->f01_ctrl_base_addr,
+			&device_ctrl,
+			sizeof(device_ctrl));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to enter sleep mode\n",
+				__func__);
+		rmi4_data->sensor_sleep = false;
+		return;
+	} else {
+		rmi4_data->sensor_sleep = true;
+	}
+
+	return;
+}
+
+ /**
+ * synaptics_rmi4_sensor_wake()
+ *
+ * Called by synaptics_rmi4_resume() and synaptics_rmi4_late_resume().
+ *
+ * This function wakes the sensor from sleep.
+ */
+static void synaptics_rmi4_sensor_wake(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	unsigned char device_ctrl;
+	unsigned char no_sleep_setting = rmi4_data->no_sleep_setting;
+
+    /*** ZTEMT Added by luochangyang, 2013/11/19 ***/
+    unsigned char report_mode[3];
+	
+	if (rmi4_data->sensor_sleep && rmi4_data->wakeup_gesture) {
+#if defined CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_S3208
+		retval = synaptics_rmi4_reg_read(rmi4_data,
+				rmi4_data->f01_ctrl_base_addr + 5,
+				&report_mode[0],
+				sizeof(report_mode[0]));
+#elif defined CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_S3508
+		retval = synaptics_rmi4_reg_read(rmi4_data,
+				0x001A,
+				report_mode,
+				sizeof(report_mode));
+#endif
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to change report mode\n",
+					__func__);
+			rmi4_data->sensor_sleep = true;
+			return;
+		}
+
+		dev_dbg(rmi4_data->pdev->dev.parent,
+				"%s: 0x001A report_mode %d %d %d \n", __func__, 
+				report_mode[0], report_mode[1], report_mode[2]);
+		
+#if defined CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_S3208
+		report_mode[0] &= 0xF8;
+
+		retval = synaptics_rmi4_reg_write(rmi4_data,
+				rmi4_data->f01_ctrl_base_addr + 5,
+				&report_mode[0],
+				sizeof(report_mode[0]));
+#elif defined CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_S3508
+		report_mode[0] = 0x00;
+		report_mode[1] = 0x00;
+		report_mode[2] = 0x00;
+		
+		retval = synaptics_rmi4_reg_write(rmi4_data,
+				0x001A,
+				report_mode,
+				sizeof(report_mode));
+#endif
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to change report mode\n",
+					__func__);
+			rmi4_data->sensor_sleep = true;
+			return;
+		} else {
+			rmi4_data->sensor_sleep = false;
+		}
+		
+		return;
+	}
+	/***ZTEMT END***/
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			rmi4_data->f01_ctrl_base_addr,
+			&device_ctrl,
+			sizeof(device_ctrl));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to wake from sleep mode\n",
+				__func__);
+		rmi4_data->sensor_sleep = true;
+		return;
+	}
+
+	device_ctrl = (device_ctrl & ~MASK_3BIT);
+	device_ctrl = (device_ctrl | no_sleep_setting | NORMAL_OPERATION);
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			rmi4_data->f01_ctrl_base_addr,
+			&device_ctrl,
+			sizeof(device_ctrl));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to wake from sleep mode\n",
+				__func__);
+		rmi4_data->sensor_sleep = true;
+		return;
+	} else {
+		rmi4_data->sensor_sleep = false;
+	}
+	return;
+}
+
+/*** ZTEMT Added by luochangyang, 2013/12/25 ***/
+#if defined(CONFIG_FB) || defined(CONFIG_HAS_EARLYSUSPEND)
+static int synaptics_rmi4_ztemt_sleep(struct synaptics_rmi4_data *rmi4_data)
+{
+	struct synaptics_rmi4_exp_fhandler *exp_fhandler;
+    
+	if (rmi4_data->stay_awake) {
+		rmi4_data->staying_awake = true;
+		return 0;
+	} else {
+		rmi4_data->staying_awake = false;
+	}
+	
+    /*** ZTEMT luochangyang, 2014/03/19 ***/
+    if (!(rmi4_data->wakeup_gesture)) {
+		rmi4_data->touch_stopped = true;
+		synaptics_rmi4_irq_enable(rmi4_data, false);
+	}
+    /***ZTEMT END***/
+	
+	synaptics_rmi4_sensor_sleep(rmi4_data);
+	synaptics_rmi4_free_fingers(rmi4_data);
+
+	mutex_lock(&exp_data.mutex);
+	if (!list_empty(&exp_data.list)) {
+		list_for_each_entry(exp_fhandler, &exp_data.list, link)
+			if (exp_fhandler->exp_fn->early_suspend != NULL)
+				exp_fhandler->exp_fn->early_suspend(rmi4_data);
+	}
+	mutex_unlock(&exp_data.mutex);
+
+	if (rmi4_data->full_pm_cycle)
+		synaptics_rmi4_suspend(&(rmi4_data->input_dev->dev));
+
+    return 0;
+}
+
+
+static int synaptics_rmi4_ztemt_wake(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	struct synaptics_rmi4_exp_fhandler *exp_fhandler;
+    
+	if (rmi4_data->staying_awake)
+		return 0;
+
+	if (rmi4_data->full_pm_cycle)
+		synaptics_rmi4_resume(&(rmi4_data->input_dev->dev));
+
+	if (rmi4_data->sensor_sleep == true) {
+		synaptics_rmi4_sensor_wake(rmi4_data);
+	    /*** ZTEMT Added by luochangyang, 2014/03/19 ***/
+	    if (!(rmi4_data->wakeup_gesture)) {
+			synaptics_rmi4_irq_enable(rmi4_data, true);
+	    }
+	    /***ZTEMT END***/
+		retval = synaptics_rmi4_reinit_device(rmi4_data);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to reinit device\n",
+					__func__);
+		}
+	}
+
+	mutex_lock(&exp_data.mutex);
+	if (!list_empty(&exp_data.list)) {
+		list_for_each_entry(exp_fhandler, &exp_data.list, link)
+			if (exp_fhandler->exp_fn->late_resume != NULL)
+				exp_fhandler->exp_fn->late_resume(rmi4_data);
+	}
+	mutex_unlock(&exp_data.mutex);
+
+	rmi4_data->touch_stopped = false;
+/*modify by LiXin for updating FW*/
+    if(rmi4_data->fw_update) 
+        return 0; 
+    
+    retval = synaptics_rmi4_reset_device(rmi4_data);
+    if (retval < 0) {
+         dev_err(rmi4_data->pdev->dev.parent,
+         "%s: Failed to issue reset command, error = %d\n",
+         __func__, retval);
+    }
+    dev_dbg(rmi4_data->pdev->dev.parent,
+            "%s: synaptics_rmi4_reset_device  \n", __func__);
+/*ZTEMT END*/
+    return 0;
+}
+/***ZTEMT END***/
+#endif
+
+#if defined(CONFIG_FB)
+static int synaptics_rmi4_fb_notifier_callback(struct notifier_block *self,
+				 unsigned long event, void *data)
+{
+	struct fb_event *evdata = data;
+	int *blank;
+	struct synaptics_rmi4_data *rmi4_data =
+		container_of(self, struct synaptics_rmi4_data, fb_notif);
+
+	if (evdata && evdata->data && rmi4_data && 
+        rmi4_data->input_dev && (event == FB_EVENT_BLANK)) {
+
+		blank = evdata->data;
+		if (*blank == FB_BLANK_UNBLANK) {
+            synaptics_rmi4_ztemt_wake(rmi4_data);
+            dev_info(&(rmi4_data->input_dev->dev), "ztemt %s: Wake!\n", __func__);
+		}
+		else if (*blank == FB_BLANK_POWERDOWN) {
+            synaptics_rmi4_ztemt_sleep(rmi4_data);
+            dev_info(&(rmi4_data->input_dev->dev), "ztemt %s: Sleep!\n", __func__);
+		}
+	}
+
+	return 0;
+}
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+ /**
+ * synaptics_rmi4_early_suspend()
+ *
+ * Called by the kernel during the early suspend phase when the system
+ * enters suspend.
+ *
+ * This function calls synaptics_rmi4_sensor_sleep() to stop finger
+ * data acquisition and put the sensor to sleep.
+ */
+static void synaptics_rmi4_early_suspend(struct early_suspend *h)
+{
+	struct synaptics_rmi4_data *rmi4_data =
+			container_of(h, struct synaptics_rmi4_data,
+			early_suspend);
+
+    synaptics_rmi4_ztemt_sleep(rmi4_data);
+    dev_info(&(rmi4_data->input_dev->dev), "ztemt %s: Sleep!\n", __func__);
+
+	return;
+}
+
+ /**
+ * synaptics_rmi4_late_resume()
+ *
+ * Called by the kernel during the late resume phase when the system
+ * wakes up from suspend.
+ *
+ * This function goes through the sensor wake process if the system wakes
+ * up from early suspend (without going into suspend).
+ */
+static void synaptics_rmi4_late_resume(struct early_suspend *h)
+{
+	struct synaptics_rmi4_data *rmi4_data =
+			container_of(h, struct synaptics_rmi4_data,
+			early_suspend);
+
+    synaptics_rmi4_ztemt_wake(rmi4_data);
+    dev_info(&(rmi4_data->input_dev->dev), "ztemt %s: Wake!\n", __func__);
+
+	return;
+}
+#endif
+
+ /**
+ * synaptics_rmi4_suspend()
+ *
+ * Called by the kernel during the suspend phase when the system
+ * enters suspend.
+ *
+ * This function stops finger data acquisition and puts the sensor to
+ * sleep (if not already done so during the early suspend phase),
+ * disables the interrupt, and turns off the power to the sensor.
+ */
+static int synaptics_rmi4_suspend(struct device *dev)
+{
+	struct synaptics_rmi4_exp_fhandler *exp_fhandler;
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+
+	if (rmi4_data->staying_awake)
+		return 0;
+
+	if (!rmi4_data->sensor_sleep) {
+		rmi4_data->touch_stopped = true;
+		synaptics_rmi4_irq_enable(rmi4_data, false);
+		synaptics_rmi4_sensor_sleep(rmi4_data);
+		synaptics_rmi4_free_fingers(rmi4_data);
+	}
+
+	mutex_lock(&exp_data.mutex);
+	if (!list_empty(&exp_data.list)) {
+		list_for_each_entry(exp_fhandler, &exp_data.list, link)
+			if (exp_fhandler->exp_fn->suspend != NULL)
+				exp_fhandler->exp_fn->suspend(rmi4_data);
+	}
+	mutex_unlock(&exp_data.mutex);
+
+	if ((!rmi4_data->wakeup_gesture) && rmi4_data->regulator)	//luochangyang 2014/03/19
+		regulator_disable(rmi4_data->regulator);
+
+	return 0;
+}
+
+ /**
+ * synaptics_rmi4_resume()
+ *
+ * Called by the kernel during the resume phase when the system
+ * wakes up from suspend.
+ *
+ * This function turns on the power to the sensor, wakes the sensor
+ * from sleep, enables the interrupt, and starts finger data
+ * acquisition.
+ */
+static int synaptics_rmi4_resume(struct device *dev)
+{
+	int retval;
+	struct synaptics_rmi4_exp_fhandler *exp_fhandler;
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+	const struct synaptics_dsx_board_data *bdata =
+			rmi4_data->hw_if->board_data;
+
+	if (rmi4_data->staying_awake)
+		return 0;
+	
+	if ((!rmi4_data->wakeup_gesture) && rmi4_data->regulator) {	//luochangyang 2014/03/19
+		regulator_enable(rmi4_data->regulator);
+		msleep(bdata->reset_delay_ms);
+		rmi4_data->current_page = MASK_8BIT;
+	}
+
+	synaptics_rmi4_sensor_wake(rmi4_data);
+	synaptics_rmi4_irq_enable(rmi4_data, true);
+	retval = synaptics_rmi4_reinit_device(rmi4_data);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to reinit device\n",
+				__func__);
+		return retval;
+	}
+
+	mutex_lock(&exp_data.mutex);
+	if (!list_empty(&exp_data.list)) {
+		list_for_each_entry(exp_fhandler, &exp_data.list, link)
+			if (exp_fhandler->exp_fn->resume != NULL)
+				exp_fhandler->exp_fn->resume(rmi4_data);
+	}
+	mutex_unlock(&exp_data.mutex);
+
+	rmi4_data->touch_stopped = false;
+
+	return 0;
+}
+
+/*** ZTEMT Added by luochangyang, 2014/03/19 ***/
+#if defined(CONFIG_PM_SLEEP)
+ static int synaptics_wakeup_gesture_suspend(struct device *dev)
+ {
+	 struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+ 
+	 if (!(rmi4_data->wakeup_gesture))
+		 return 0;
+ 
+	 /*
+	  * This will not prevent resume
+	  * Required to prevent interrupts before i2c awake
+	  */
+	 disable_irq(rmi4_data->irq);
+ 
+	 if (device_may_wakeup(dev)) {
+		 dev_dbg(dev, "%s Device MAY wakeup\n", __func__);
+		 if (!enable_irq_wake(rmi4_data->irq))
+			 rmi4_data->irq_wake = 1;
+	 } else {
+		 dev_dbg(dev, "%s Device may NOT wakeup\n", __func__);
+	 }
+ 
+	 return 0;
+ }
+ 
+ static int synaptics_wakeup_gesture_resume(struct device *dev)
+ {
+	 struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+ 
+	 if (!(rmi4_data->wakeup_gesture))
+		 return 0;
+	 
+	 enable_irq(rmi4_data->irq);
+ 
+	 if (device_may_wakeup(dev)) {
+		 dev_dbg(dev, "%s Device MAY wakeup\n", __func__);
+		 if (rmi4_data->irq_wake) {
+			 disable_irq_wake(rmi4_data->irq);
+			 rmi4_data->irq_wake = 0;
+		 }
+	 } else {
+		 dev_dbg(dev, "%s Device may NOT wakeup\n", __func__);
+	 }
+ 
+	 return 0;
+ }
+#endif
+ /***ZTEMT END***/
+
+static const struct dev_pm_ops synaptics_rmi4_dev_pm_ops = {
+/*** ZTEMT Modify by luochangyang, 2014/03/19 ***/
+#if ZTEMT_SYNAPTICS_WAKEUP_GESTURE
+	SET_SYSTEM_SLEEP_PM_OPS(synaptics_wakeup_gesture_suspend, synaptics_wakeup_gesture_resume)
+	SET_RUNTIME_PM_OPS(synaptics_rmi4_suspend, synaptics_rmi4_resume, NULL)
+#else
+	.suspend = synaptics_rmi4_suspend,
+	.resume  = synaptics_rmi4_resume,
+#endif
+/***ZTEMT END***/
+};
+#endif
+
+static struct platform_driver synaptics_rmi4_driver = {
+	.driver = {
+		.name = PLATFORM_DRIVER_NAME,
+		.owner = THIS_MODULE,
+#ifdef CONFIG_PM
+		.pm = &synaptics_rmi4_dev_pm_ops,
+#endif
+	},
+	.probe = synaptics_rmi4_probe,
+	.remove = __devexit_p(synaptics_rmi4_remove),
+};
+
+ /**
+ * synaptics_rmi4_init()
+ *
+ * Called by the kernel during do_initcalls (if built-in)
+ * or when the driver is loaded (if a module).
+ *
+ * This function registers the driver to the I2C subsystem.
+ *
+ */
+static int __init synaptics_rmi4_init(void)
+{
+	int retval;
+
+	retval = synaptics_rmi4_bus_init();
+	if (retval)
+		return retval;
+
+	return platform_driver_register(&synaptics_rmi4_driver);
+}
+
+ /**
+ * synaptics_rmi4_exit()
+ *
+ * Called by the kernel when the driver is unloaded.
+ *
+ * This funtion unregisters the driver from the I2C subsystem.
+ *
+ */
+static void __exit synaptics_rmi4_exit(void)
+{
+	platform_driver_unregister(&synaptics_rmi4_driver);
+
+	synaptics_rmi4_bus_exit();
+
+	return;
+}
+
+module_init(synaptics_rmi4_init);
+module_exit(synaptics_rmi4_exit);
+
+MODULE_AUTHOR("Synaptics, Inc.");
+MODULE_DESCRIPTION("Synaptics DSX I2C Touch Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_core.h b/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_core.h
new file mode 100755
index 0000000..334ccfc
--- /dev/null
+++ b/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_core.h
@@ -0,0 +1,357 @@
+/*
+ * Synaptics DSX touchscreen driver
+ *
+ * Copyright (C) 2012 Synaptics Incorporated
+ *
+ * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
+ * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef _SYNAPTICS_DSX_RMI4_H_
+#define _SYNAPTICS_DSX_RMI4_H_
+
+#define SYNAPTICS_DS4 (1 << 0)
+#define SYNAPTICS_DS5 (1 << 1)
+#define SYNAPTICS_DSX_DRIVER_PRODUCT (SYNAPTICS_DS4 | SYNAPTICS_DS5)
+#define SYNAPTICS_DSX_DRIVER_VERSION 0x2001
+
+#include <linux/version.h>
+
+/*** ZTEMT Added by luochangyang, 2013/11/29 ***/
+#if defined(CONFIG_FB)
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+#include <linux/earlysuspend.h>
+#endif
+#define ZTEMT_SYNAPTICS_WAKEUP_GESTURE	1
+#define ZTEMT_SYNAPTICS_PALM_SLEEP		1	//Added by luochangyang, for palm sleep  2014/03/19
+#define ZTEMT_SYNAPTICS_DEBUG			0
+/***ZTEMT END***/
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 38))
+#define KERNEL_ABOVE_2_6_38
+#endif
+
+#ifdef KERNEL_ABOVE_2_6_38
+#define sstrtoul(...) kstrtoul(__VA_ARGS__)
+#else
+#define sstrtoul(...) strict_strtoul(__VA_ARGS__)
+#endif
+
+#define PDT_PROPS (0X00EF)
+#define PDT_START (0x00E9)
+#define PDT_END (0x00D0)
+#define PDT_ENTRY_SIZE (0x0006)
+#define PAGES_TO_SERVICE (10)
+#define PAGE_SELECT_LEN (2)
+#define ADDRESS_WORD_LEN (2)
+
+#define SYNAPTICS_RMI4_F01 (0x01)
+#define SYNAPTICS_RMI4_F11 (0x11)
+#define SYNAPTICS_RMI4_F12 (0x12)
+#define SYNAPTICS_RMI4_F1A (0x1a)
+#define SYNAPTICS_RMI4_F34 (0x34)
+#define SYNAPTICS_RMI4_F51 (0x51)
+#define SYNAPTICS_RMI4_F54 (0x54)
+#define SYNAPTICS_RMI4_F55 (0x55)
+
+#define SYNAPTICS_RMI4_PRODUCT_INFO_SIZE 2
+#define SYNAPTICS_RMI4_DATE_CODE_SIZE 3
+#define SYNAPTICS_RMI4_PRODUCT_ID_SIZE 10
+#define SYNAPTICS_RMI4_BUILD_ID_SIZE 3
+
+#define F12_FINGERS_TO_SUPPORT 10
+#define F12_NO_OBJECT_STATUS 0x00
+#define F12_FINGER_STATUS 0x01
+#define F12_STYLUS_STATUS 0x02
+#define F12_PALM_STATUS 0x03
+#define F12_HOVERING_FINGER_STATUS 0x05
+#define F12_GLOVED_FINGER_STATUS 0x06
+
+#define MAX_NUMBER_OF_BUTTONS 4
+#define MAX_INTR_REGISTERS 4
+
+#define MASK_16BIT 0xFFFF
+#define MASK_8BIT 0xFF
+#define MASK_7BIT 0x7F
+#define MASK_6BIT 0x3F
+#define MASK_5BIT 0x1F
+#define MASK_4BIT 0x0F
+#define MASK_3BIT 0x07
+#define MASK_2BIT 0x03
+#define MASK_1BIT 0x01
+
+enum exp_fn {
+	RMI_DEV = 0,
+	RMI_F54,
+	RMI_FW_UPDATER,
+	RMI_PROXIMITY,
+	RMI_ACTIVE_PEN,
+	RMI_LAST,
+};
+
+struct synaptics_dsx_hw_interface {
+	const struct synaptics_dsx_board_data *board_data;
+	const struct synaptics_dsx_bus_access *bus_access;
+};
+
+/*
+ * struct synaptics_rmi4_fn_desc - function descriptor fields in PDT
+ * @query_base_addr: base address for query registers
+ * @cmd_base_addr: base address for command registers
+ * @ctrl_base_addr: base address for control registers
+ * @data_base_addr: base address for data registers
+ * @intr_src_count: number of interrupt sources
+ * @fn_number: function number
+ */
+struct synaptics_rmi4_fn_desc {
+	unsigned char query_base_addr;
+	unsigned char cmd_base_addr;
+	unsigned char ctrl_base_addr;
+	unsigned char data_base_addr;
+	unsigned char intr_src_count;
+	unsigned char fn_number;
+};
+
+/*
+ * synaptics_rmi4_fn_full_addr - full 16-bit base addresses
+ * @query_base: 16-bit base address for query registers
+ * @cmd_base: 16-bit base address for data registers
+ * @ctrl_base: 16-bit base address for command registers
+ * @data_base: 16-bit base address for control registers
+ */
+struct synaptics_rmi4_fn_full_addr {
+	unsigned short query_base;
+	unsigned short cmd_base;
+	unsigned short ctrl_base;
+	unsigned short data_base;
+};
+
+struct synaptics_rmi4_f12_extra_data {
+	unsigned char data1_offset;
+	unsigned char data15_offset;
+	unsigned char data15_size;
+	unsigned char data15_data[(F12_FINGERS_TO_SUPPORT + 7) / 8];
+};
+
+/*
+ * struct synaptics_rmi4_fn - function handler data structure
+ * @fn_number: function number
+ * @num_of_data_sources: number of data sources
+ * @num_of_data_points: maximum number of fingers supported
+ * @size_of_data_register_block: data register block size
+ * @intr_reg_num: index to associated interrupt register
+ * @intr_mask: interrupt mask
+ * @full_addr: full 16-bit base addresses of function registers
+ * @link: linked list for function handlers
+ * @data_size: size of private data
+ * @data: pointer to private data
+ */
+struct synaptics_rmi4_fn {
+	unsigned char fn_number;
+	unsigned char num_of_data_sources;
+	unsigned char num_of_data_points;
+	unsigned char size_of_data_register_block;
+	unsigned char intr_reg_num;
+	unsigned char intr_mask;
+	struct synaptics_rmi4_fn_full_addr full_addr;
+	struct list_head link;
+	int data_size;
+	void *data;
+	void *extra;
+};
+
+/*
+ * struct synaptics_rmi4_device_info - device information
+ * @version_major: rmi protocol major version number
+ * @version_minor: rmi protocol minor version number
+ * @manufacturer_id: manufacturer id
+ * @product_props: product properties information
+ * @product_info: product info array
+ * @date_code: device manufacture date
+ * @tester_id: tester id array
+ * @serial_number: device serial number
+ * @product_id_string: device product id
+ * @support_fn_list: linked list for function handlers
+ */
+struct synaptics_rmi4_device_info {
+	unsigned int version_major;
+	unsigned int version_minor;
+	unsigned char manufacturer_id;
+	unsigned char product_props;
+	unsigned char product_info[SYNAPTICS_RMI4_PRODUCT_INFO_SIZE];
+	unsigned char date_code[SYNAPTICS_RMI4_DATE_CODE_SIZE];
+	unsigned short tester_id;
+	unsigned short serial_number;
+	unsigned char product_id_string[SYNAPTICS_RMI4_PRODUCT_ID_SIZE + 1];
+	unsigned char build_id[SYNAPTICS_RMI4_BUILD_ID_SIZE];
+	unsigned char config_id[4];     //Added by luochangyang, 2013/12/25
+	struct list_head support_fn_list;
+};
+
+/*
+ * struct synaptics_rmi4_data - rmi4 device instance data
+ * @pdev: pointer to platform device
+ * @input_dev: pointer to associated input device
+ * @hw_if: pointer to hardware interface data
+ * @rmi4_mod_info: device information
+ * @regulator: pointer to associated regulator
+ * @rmi4_io_ctrl_mutex: mutex for i2c i/o control
+ * @early_suspend: instance to support early suspend power management
+ * @current_page: current page in sensor to acess
+ * @button_0d_enabled: flag for 0d button support
+ * @full_pm_cycle: flag for full power management cycle in early suspend stage
+ * @num_of_intr_regs: number of interrupt registers
+ * @f01_query_base_addr: query base address for f01
+ * @f01_cmd_base_addr: command base address for f01
+ * @f01_ctrl_base_addr: control base address for f01
+ * @f01_data_base_addr: data base address for f01
+ * @irq: attention interrupt
+ * @sensor_max_x: sensor maximum x value
+ * @sensor_max_y: sensor maximum y value
+ * @irq_enabled: flag for indicating interrupt enable status
+ * @fingers_on_2d: flag to indicate presence of fingers in 2d area
+ * @sensor_sleep: flag to indicate sleep state of sensor
+ * @wait: wait queue for touch data polling in interrupt thread
+ * @irq_enable: pointer to irq enable function
+ */
+struct synaptics_rmi4_data {
+	struct platform_device *pdev;
+	struct input_dev *input_dev;
+	const struct synaptics_dsx_hw_interface *hw_if;
+	struct synaptics_rmi4_device_info rmi4_mod_info;
+	struct regulator *regulator;
+	struct regulator *regulator_vcc;    //Added by luochangyang, 2013/12/19
+	struct mutex rmi4_reset_mutex;
+	struct mutex rmi4_report_mutex;
+	struct mutex rmi4_io_ctrl_mutex;
+/* ZTEMT Added by luochangyang, 2013/12/25 */
+#if defined(CONFIG_FB)
+    struct notifier_block fb_notif;
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+/***ZTEMT END***/
+	struct early_suspend early_suspend;
+#endif
+	unsigned char current_page;
+	unsigned char button_0d_enabled;
+	unsigned char full_pm_cycle;
+	unsigned char num_of_rx;
+	unsigned char num_of_tx;
+	unsigned char num_of_fingers;
+	unsigned char max_touch_width;
+	unsigned char report_enable;
+	unsigned char no_sleep_setting;
+	unsigned char intr_mask[MAX_INTR_REGISTERS];
+	unsigned char *button_txrx_mapping;
+	unsigned short num_of_intr_regs;
+	unsigned short f01_query_base_addr;
+	unsigned short f01_cmd_base_addr;
+	unsigned short f01_ctrl_base_addr;
+	unsigned short f01_data_base_addr;
+	unsigned int firmware_id;
+	int irq;
+	int sensor_max_x;
+	int sensor_max_y;
+	bool flash_prog_mode;
+	bool irq_enabled;
+	bool touch_stopped;
+	bool fingers_on_2d;
+	bool sensor_sleep;
+	bool stay_awake;
+	bool staying_awake;
+    /*** ZTEMT Added by luochangyang, 2014/03/19 ***/
+    bool irq_wake;
+    bool wakeup_gesture;
+    bool fw_update;
+    /***ZTEMT END***/
+	int (*irq_enable)(struct synaptics_rmi4_data *rmi4_data, bool enable);
+	int (*reset_device)(struct synaptics_rmi4_data *rmi4_data);
+};
+
+struct synaptics_dsx_bus_access {
+	unsigned char type;
+	int (*read)(struct synaptics_rmi4_data *rmi4_data, unsigned short addr,
+		unsigned char *data, unsigned short length);
+	int (*write)(struct synaptics_rmi4_data *rmi4_data, unsigned short addr,
+		unsigned char *data, unsigned short length);
+};
+
+struct synaptics_rmi4_exp_fn {
+	enum exp_fn fn_type;
+	int (*init)(struct synaptics_rmi4_data *rmi4_data);
+	void (*remove)(struct synaptics_rmi4_data *rmi4_data);
+	void (*reset)(struct synaptics_rmi4_data *rmi4_data);
+	void (*reinit)(struct synaptics_rmi4_data *rmi4_data);
+	void (*early_suspend)(struct synaptics_rmi4_data *rmi4_data);
+	void (*suspend)(struct synaptics_rmi4_data *rmi4_data);
+	void (*resume)(struct synaptics_rmi4_data *rmi4_data);
+	void (*late_resume)(struct synaptics_rmi4_data *rmi4_data);
+	void (*attn)(struct synaptics_rmi4_data *rmi4_data,
+			unsigned char intr_mask);
+};
+
+int synaptics_rmi4_bus_init(void);
+
+void synaptics_rmi4_bus_exit(void);
+
+void synaptics_rmi4_new_function(struct synaptics_rmi4_exp_fn *exp_fn_module,
+		bool insert);
+
+int synaptics_fw_updater(unsigned char *fw_data);
+
+static inline int synaptics_rmi4_reg_read(
+		struct synaptics_rmi4_data *rmi4_data,
+		unsigned short addr,
+		unsigned char *data,
+		unsigned short len)
+{
+	return rmi4_data->hw_if->bus_access->read(rmi4_data, addr, data, len);
+}
+
+static inline int synaptics_rmi4_reg_write(
+		struct synaptics_rmi4_data *rmi4_data,
+		unsigned short addr,
+		unsigned char *data,
+		unsigned short len)
+{
+	return rmi4_data->hw_if->bus_access->write(rmi4_data, addr, data, len);
+}
+
+static inline ssize_t synaptics_rmi4_show_error(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	dev_warn(dev, "%s Attempted to read from write-only attribute %s\n",
+			__func__, attr->attr.name);
+	return -EPERM;
+}
+
+static inline ssize_t synaptics_rmi4_store_error(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	dev_warn(dev, "%s Attempted to write to read-only attribute %s\n",
+			__func__, attr->attr.name);
+	return -EPERM;
+}
+
+static inline void batohs(unsigned short *dest, unsigned char *src)
+{
+	*dest = src[1] * 0x100 + src[0];
+}
+
+static inline void hstoba(unsigned char *dest, unsigned short src)
+{
+	dest[0] = src % 0x100;
+	dest[1] = src / 0x100;
+}
+
+#endif
diff --git a/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_fw_update.c b/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_fw_update.c
new file mode 100755
index 0000000..ce13b2a
--- /dev/null
+++ b/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_fw_update.c
@@ -0,0 +1,1865 @@
+/*
+ * Synaptics DSX touchscreen driver
+ *
+ * Copyright (C) 2012 Synaptics Incorporated
+ *
+ * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
+ * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/firmware.h>
+#include <linux/platform_device.h>
+#include "synaptics_dsx.h"
+#include "synaptics_dsx_core.h"
+
+#define FW_IMAGE_NAME "startup_fw_update.img"
+#define DO_STARTUP_FW_UPDATE
+#define STARTUP_FW_UPDATE_DELAY_MS 1000 /* ms */
+#define FORCE_UPDATE false
+#define DO_LOCKDOWN false
+
+#define MAX_IMAGE_NAME_LEN 256
+#define MAX_FIRMWARE_ID_LEN 10
+
+#define LOCKDOWN_OFFSET 0xb0
+#define FW_IMAGE_OFFSET 0x100
+
+#define BOOTLOADER_ID_OFFSET 0
+#define BLOCK_NUMBER_OFFSET 0
+
+#define V5_PROPERTIES_OFFSET 2
+#define V5_BLOCK_SIZE_OFFSET 3
+#define V5_BLOCK_COUNT_OFFSET 5
+#define V5_BLOCK_DATA_OFFSET 2
+
+#define V6_PROPERTIES_OFFSET 1
+#define V6_BLOCK_SIZE_OFFSET 2
+#define V6_BLOCK_COUNT_OFFSET 3
+#define V6_BLOCK_DATA_OFFSET 1
+#define V6_FLASH_COMMAND_OFFSET 2
+#define V6_FLASH_STATUS_OFFSET 3
+
+#define LOCKDOWN_BLOCK_COUNT 5
+
+#define REG_MAP (1 << 0)
+#define UNLOCKED (1 << 1)
+#define HAS_CONFIG_ID (1 << 2)
+#define HAS_PERM_CONFIG (1 << 3)
+#define HAS_BL_CONFIG (1 << 4)
+#define HAS_DISP_CONFIG (1 << 5)
+#define HAS_CTRL1 (1 << 6)
+
+#define UI_CONFIG_AREA 0x00
+#define PERM_CONFIG_AREA 0x01
+#define BL_CONFIG_AREA 0x02
+#define DISP_CONFIG_AREA 0x03
+
+#define CMD_WRITE_FW_BLOCK 0x2
+#define CMD_ERASE_ALL 0x3
+#define CMD_WRITE_LOCKDOWN_BLOCK 0x4
+#define CMD_READ_CONFIG_BLOCK 0x5
+#define CMD_WRITE_CONFIG_BLOCK 0x6
+#define CMD_ERASE_CONFIG 0x7
+#define CMD_ERASE_BL_CONFIG 0x9
+#define CMD_ERASE_DISP_CONFIG 0xa
+#define CMD_ENABLE_FLASH_PROG 0xf
+
+#define SLEEP_MODE_NORMAL (0x00)
+#define SLEEP_MODE_SENSOR_SLEEP (0x01)
+#define SLEEP_MODE_RESERVED0 (0x02)
+#define SLEEP_MODE_RESERVED1 (0x03)
+
+#define ENABLE_WAIT_MS (1 * 1000)
+#define WRITE_WAIT_MS (3 * 1000)
+#define ERASE_WAIT_MS (5 * 1000)
+
+#define MIN_SLEEP_TIME_US 50
+#define MAX_SLEEP_TIME_US 100
+
+static ssize_t fwu_sysfs_show_image(struct file *data_file,
+		struct kobject *kobj, struct bin_attribute *attributes,
+		char *buf, loff_t pos, size_t count);
+
+static ssize_t fwu_sysfs_store_image(struct file *data_file,
+		struct kobject *kobj, struct bin_attribute *attributes,
+		char *buf, loff_t pos, size_t count);
+
+static ssize_t fwu_sysfs_do_reflash_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t fwu_sysfs_write_config_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t fwu_sysfs_read_config_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t fwu_sysfs_config_area_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t fwu_sysfs_image_name_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t fwu_sysfs_image_size_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t fwu_sysfs_block_size_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t fwu_sysfs_firmware_block_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t fwu_sysfs_configuration_block_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t fwu_sysfs_perm_config_block_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t fwu_sysfs_bl_config_block_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t fwu_sysfs_disp_config_block_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+enum bl_version {
+	V5 = 5,
+	V6 = 6,
+};
+
+enum flash_area {
+	NONE,
+	UI_FIRMWARE,
+	CONFIG_AREA,
+};
+
+enum update_mode {
+	NORMAL = 1,
+	FORCE = 2,
+	LOCKDOWN = 8,
+};
+
+struct image_header {
+	/* 0x00 - 0x0f */
+	unsigned char checksum[4];
+	unsigned char reserved_04;
+	unsigned char reserved_05;
+	unsigned char options_firmware_id:1;
+	unsigned char options_contain_bootloader:1;
+	unsigned char options_reserved:6;
+	unsigned char bootloader_version;
+	unsigned char firmware_size[4];
+	unsigned char config_size[4];
+	/* 0x10 - 0x1f */
+	unsigned char product_id[SYNAPTICS_RMI4_PRODUCT_ID_SIZE];
+	unsigned char package_id[2];
+	unsigned char package_id_revision[2];
+	unsigned char product_info[SYNAPTICS_RMI4_PRODUCT_INFO_SIZE];
+	/* 0x20 - 0x2f */
+	unsigned char reserved_20_2f[16];
+	/* 0x30 - 0x3f */
+	unsigned char ds_id[16];
+	/* 0x40 - 0x4f */
+	unsigned char ds_info[10];
+	unsigned char reserved_4a_4f[6];
+	/* 0x50 - 0x53 */
+	unsigned char firmware_id[4];
+};
+
+struct image_header_data {
+	bool contains_firmware_id;
+	unsigned int firmware_id;
+	unsigned int checksum;
+	unsigned int firmware_size;
+	unsigned int config_size;
+	unsigned char bootloader_version;
+	unsigned char product_id[SYNAPTICS_RMI4_PRODUCT_ID_SIZE + 1];
+	unsigned char product_info[SYNAPTICS_RMI4_PRODUCT_INFO_SIZE];
+};
+
+struct pdt_properties {
+	union {
+		struct {
+			unsigned char reserved_1:6;
+			unsigned char has_bsr:1;
+			unsigned char reserved_2:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f01_device_status {
+	union {
+		struct {
+			unsigned char status_code:4;
+			unsigned char reserved:2;
+			unsigned char flash_prog:1;
+			unsigned char unconfigured:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f01_device_control {
+	union {
+		struct {
+			unsigned char sleep_mode:2;
+			unsigned char nosleep:1;
+			unsigned char reserved:2;
+			unsigned char charger_connected:1;
+			unsigned char report_rate:1;
+			unsigned char configured:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct synaptics_rmi4_fwu_handle {
+	enum bl_version bl_version;
+	bool initialized;
+	bool program_enabled;
+	bool has_perm_config;
+	bool has_bl_config;
+	bool has_disp_config;
+	bool force_update;
+	bool in_flash_prog_mode;
+	bool do_lockdown;
+	unsigned int data_pos;
+	unsigned int image_size;
+	unsigned char *image_name;
+	unsigned char *ext_data_source;
+	unsigned char *read_config_buf;
+	unsigned char intr_mask;
+	unsigned char command;
+	unsigned char bootloader_id[2];
+	unsigned char flash_properties;
+	unsigned char flash_status;
+	unsigned char productinfo1;
+	unsigned char productinfo2;
+	unsigned char properties_off;
+	unsigned char blk_size_off;
+	unsigned char blk_count_off;
+	unsigned char blk_data_off;
+	unsigned char flash_cmd_off;
+	unsigned char flash_status_off;
+	unsigned short block_size;
+	unsigned short fw_block_count;
+	unsigned short config_block_count;
+	unsigned short lockdown_block_count;
+	unsigned short perm_config_block_count;
+	unsigned short bl_config_block_count;
+	unsigned short disp_config_block_count;
+	unsigned short config_size;
+	unsigned short config_area;
+	char product_id[SYNAPTICS_RMI4_PRODUCT_ID_SIZE + 1];
+	const unsigned char *firmware_data;
+	const unsigned char *config_data;
+	const unsigned char *lockdown_data;
+	struct workqueue_struct *fwu_workqueue;
+	struct delayed_work fwu_work;
+	struct synaptics_rmi4_fn_desc f34_fd;
+	struct synaptics_rmi4_data *rmi4_data;
+};
+
+static struct bin_attribute dev_attr_data = {
+	.attr = {
+		.name = "data",
+		.mode = (00664),
+	},
+	.size = 0,
+	.read = fwu_sysfs_show_image,
+	.write = fwu_sysfs_store_image,
+};
+
+static struct device_attribute attrs[] = {
+	__ATTR(doreflash, 00220,
+			synaptics_rmi4_show_error,
+			fwu_sysfs_do_reflash_store),
+	__ATTR(writeconfig, 00220,
+			synaptics_rmi4_show_error,
+			fwu_sysfs_write_config_store),
+	__ATTR(readconfig, 00220,
+			synaptics_rmi4_show_error,
+			fwu_sysfs_read_config_store),
+	__ATTR(configarea, 00220,
+			synaptics_rmi4_show_error,
+			fwu_sysfs_config_area_store),
+	__ATTR(imagename, 00220,
+			synaptics_rmi4_show_error,
+			fwu_sysfs_image_name_store),
+	__ATTR(imagesize, 00220,
+			synaptics_rmi4_show_error,
+			fwu_sysfs_image_size_store),
+	__ATTR(blocksize, S_IRUGO,
+			fwu_sysfs_block_size_show,
+			synaptics_rmi4_store_error),
+	__ATTR(fwblockcount, S_IRUGO,
+			fwu_sysfs_firmware_block_count_show,
+			synaptics_rmi4_store_error),
+	__ATTR(configblockcount, S_IRUGO,
+			fwu_sysfs_configuration_block_count_show,
+			synaptics_rmi4_store_error),
+	__ATTR(permconfigblockcount, S_IRUGO,
+			fwu_sysfs_perm_config_block_count_show,
+			synaptics_rmi4_store_error),
+	__ATTR(blconfigblockcount, S_IRUGO,
+			fwu_sysfs_bl_config_block_count_show,
+			synaptics_rmi4_store_error),
+	__ATTR(dispconfigblockcount, S_IRUGO,
+			fwu_sysfs_disp_config_block_count_show,
+			synaptics_rmi4_store_error),
+};
+
+static struct synaptics_rmi4_fwu_handle *fwu;
+
+DECLARE_COMPLETION(fwu_remove_complete);
+
+static unsigned int extract_uint_le(const unsigned char *ptr)
+{
+	return (unsigned int)ptr[0] +
+			(unsigned int)ptr[1] * 0x100 +
+			(unsigned int)ptr[2] * 0x10000 +
+			(unsigned int)ptr[3] * 0x1000000;
+}
+
+static unsigned int extract_uint_be(const unsigned char *ptr)
+{
+	return (unsigned int)ptr[3] +
+			(unsigned int)ptr[2] * 0x100 +
+			(unsigned int)ptr[1] * 0x10000 +
+			(unsigned int)ptr[0] * 0x1000000;
+}
+
+static void parse_header(struct image_header_data *header,
+		const unsigned char *fw_image)
+{
+	struct image_header *data = (struct image_header *)fw_image;
+
+	header->checksum = extract_uint_le(data->checksum);
+
+	header->bootloader_version = data->bootloader_version;
+
+	header->firmware_size = extract_uint_le(data->firmware_size);
+
+	header->config_size = extract_uint_le(data->config_size);
+
+	memcpy(header->product_id, data->product_id, sizeof(data->product_id));
+	header->product_id[sizeof(data->product_id)] = 0;
+
+	memcpy(header->product_info, data->product_info,
+			sizeof(data->product_info));
+
+	header->contains_firmware_id = data->options_firmware_id;
+	if (header->contains_firmware_id)
+		header->firmware_id = extract_uint_le(data->firmware_id);
+
+	return;
+}
+
+static int fwu_read_f01_device_status(struct f01_device_status *status)
+{
+	int retval;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			rmi4_data->f01_data_base_addr,
+			status->data,
+			sizeof(status->data));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read F01 device status\n",
+				__func__);
+		return retval;
+	}
+
+	return 0;
+}
+
+static int fwu_read_f34_queries(void)
+{
+	int retval;
+	unsigned char count;
+	unsigned char buf[10];
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			fwu->f34_fd.query_base_addr + BOOTLOADER_ID_OFFSET,
+			fwu->bootloader_id,
+			sizeof(fwu->bootloader_id));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read bootloader ID\n",
+				__func__);
+		return retval;
+	}
+
+	if (fwu->bootloader_id[1] == '5') {
+		fwu->bl_version = V5;
+	} else if (fwu->bootloader_id[1] == '6') {
+		fwu->bl_version = V6;
+	} else {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Unrecognized bootloader version\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	if (fwu->bl_version == V5) {
+		fwu->properties_off = V5_PROPERTIES_OFFSET;
+		fwu->blk_size_off = V5_BLOCK_SIZE_OFFSET;
+		fwu->blk_count_off = V5_BLOCK_COUNT_OFFSET;
+		fwu->blk_data_off = V5_BLOCK_DATA_OFFSET;
+	} else if (fwu->bl_version == V6) {
+		fwu->properties_off = V6_PROPERTIES_OFFSET;
+		fwu->blk_size_off = V6_BLOCK_SIZE_OFFSET;
+		fwu->blk_count_off = V6_BLOCK_COUNT_OFFSET;
+		fwu->blk_data_off = V6_BLOCK_DATA_OFFSET;
+	}
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			fwu->f34_fd.query_base_addr + fwu->properties_off,
+			&fwu->flash_properties,
+			sizeof(fwu->flash_properties));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read flash properties\n",
+				__func__);
+		return retval;
+	}
+
+	count = 4;
+
+	if (fwu->flash_properties & HAS_PERM_CONFIG) {
+		fwu->has_perm_config = 1;
+		count += 2;
+	}
+
+	if (fwu->flash_properties & HAS_BL_CONFIG) {
+		fwu->has_bl_config = 1;
+		count += 2;
+	}
+
+	if (fwu->flash_properties & HAS_DISP_CONFIG) {
+		fwu->has_disp_config = 1;
+		count += 2;
+	}
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			fwu->f34_fd.query_base_addr + fwu->blk_size_off,
+			buf,
+			2);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read block size info\n",
+				__func__);
+		return retval;
+	}
+
+	batohs(&fwu->block_size, &(buf[0]));
+
+	if (fwu->bl_version == V5) {
+		fwu->flash_cmd_off = fwu->blk_data_off + fwu->block_size;
+		fwu->flash_status_off = fwu->flash_cmd_off;
+	} else if (fwu->bl_version == V6) {
+		fwu->flash_cmd_off = V6_FLASH_COMMAND_OFFSET;
+		fwu->flash_status_off = V6_FLASH_STATUS_OFFSET;
+	}
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			fwu->f34_fd.query_base_addr + fwu->blk_count_off,
+			buf,
+			count);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read block count info\n",
+				__func__);
+		return retval;
+	}
+
+	batohs(&fwu->fw_block_count, &(buf[0]));
+	batohs(&fwu->config_block_count, &(buf[2]));
+
+	count = 4;
+
+	if (fwu->has_perm_config) {
+		batohs(&fwu->perm_config_block_count, &(buf[count]));
+		count += 2;
+	}
+
+	if (fwu->has_bl_config) {
+		batohs(&fwu->bl_config_block_count, &(buf[count]));
+		count += 2;
+	}
+
+	if (fwu->has_disp_config)
+		batohs(&fwu->disp_config_block_count, &(buf[count]));
+
+	return 0;
+}
+
+static int fwu_read_f34_flash_status(void)
+{
+	int retval;
+	unsigned char status;
+	unsigned char command;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			fwu->f34_fd.data_base_addr + fwu->flash_status_off,
+			&status,
+			sizeof(status));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read flash status\n",
+				__func__);
+		return retval;
+	}
+
+	fwu->program_enabled = status >> 7;
+
+	if (fwu->bl_version == V5)
+		fwu->flash_status = (status >> 4) & MASK_3BIT;
+	else if (fwu->bl_version == V6)
+		fwu->flash_status = status & MASK_3BIT;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			fwu->f34_fd.data_base_addr + fwu->flash_cmd_off,
+			&command,
+			sizeof(command));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read flash command\n",
+				__func__);
+		return retval;
+	}
+
+	fwu->command = command & MASK_4BIT;
+
+	return 0;
+}
+
+static int fwu_write_f34_command(unsigned char cmd)
+{
+	int retval;
+	unsigned char command = cmd & MASK_4BIT;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	fwu->command = cmd;
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			fwu->f34_fd.data_base_addr + fwu->flash_cmd_off,
+			&command,
+			sizeof(command));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to write command 0x%02x\n",
+				__func__, command);
+		return retval;
+	}
+
+	return 0;
+}
+
+static int fwu_wait_for_idle(int timeout_ms)
+{
+	int count = 0;
+	int timeout_count = ((timeout_ms * 1000) / MAX_SLEEP_TIME_US) + 1;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	do {
+		usleep_range(MIN_SLEEP_TIME_US, MAX_SLEEP_TIME_US);
+
+		count++;
+		if (count == timeout_count)
+			fwu_read_f34_flash_status();
+
+		if ((fwu->command == 0x00) && (fwu->flash_status == 0x00))
+			return 0;
+	} while (count < timeout_count);
+
+	dev_err(rmi4_data->pdev->dev.parent,
+			"%s: Timed out waiting for idle status\n",
+			__func__);
+
+	return -ETIMEDOUT;
+}
+
+static enum flash_area fwu_go_nogo(struct image_header_data *header)
+{
+	int retval;
+	enum flash_area flash_area = NONE;
+	unsigned int device_config_id;
+	unsigned int image_config_id;
+	unsigned char config_id[4];
+    #if 0
+	unsigned char index = 0;
+	unsigned int device_fw_id;
+	unsigned long image_fw_id;
+	char *strptr;
+	char *firmware_id;
+    #endif
+    
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	if (fwu->force_update) {
+		flash_area = UI_FIRMWARE;
+		goto exit;
+	}
+
+	/* Update both UI and config if device is in bootloader mode */
+	if (fwu->in_flash_prog_mode) {
+		flash_area = UI_FIRMWARE;
+		goto exit;
+	}
+#if 0
+	/* Get device firmware ID */
+	device_fw_id = rmi4_data->firmware_id;
+	dev_info(rmi4_data->pdev->dev.parent,
+			"%s: Device firmware ID = %d\n",
+			__func__, device_fw_id);
+
+	/* Get image firmware ID */
+	if (header->contains_firmware_id) {
+		image_fw_id = header->firmware_id;
+	} else {
+		strptr = strstr(fwu->image_name, "PR");
+		if (!strptr) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: No valid PR number (PRxxxxxxx) "
+					"found in image file name (%s)\n",
+					__func__, fwu->image_name);
+			flash_area = NONE;
+			goto exit;
+		}
+
+		strptr += 2;
+		firmware_id = kzalloc(MAX_FIRMWARE_ID_LEN, GFP_KERNEL);
+		while (strptr[index] >= '0' && strptr[index] <= '9') {
+			firmware_id[index] = strptr[index];
+			index++;
+		}
+
+		retval = sstrtoul(firmware_id, 10, &image_fw_id);
+		kfree(firmware_id);
+		if (retval) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to obtain image firmware ID\n",
+					__func__);
+			flash_area = NONE;
+			goto exit;
+		}
+	}
+	dev_info(rmi4_data->pdev->dev.parent,
+			"%s: Image firmware ID = %d\n",
+			__func__, (unsigned int)image_fw_id);
+
+	if (image_fw_id > device_fw_id) {
+		flash_area = UI_FIRMWARE;
+		goto exit;
+	} else if (image_fw_id < device_fw_id) {
+		dev_info(rmi4_data->pdev->dev.parent,
+				"%s: Image firmware ID older than device firmware ID\n",
+				__func__);
+		flash_area = NONE;
+		goto exit;
+	}
+#endif
+	/* Get device config ID */
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+				fwu->f34_fd.ctrl_base_addr,
+				config_id,
+				sizeof(config_id));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read device config ID\n",
+				__func__);
+		flash_area = NONE;
+		goto exit;
+	}
+	device_config_id = extract_uint_be(config_id);
+	dev_info(rmi4_data->pdev->dev.parent,
+			"%s: Device config ID = 0x%02x 0x%02x 0x%02x 0x%02x\n",
+			__func__,
+			config_id[0],
+			config_id[1],
+			config_id[2],
+			config_id[3]);
+
+	/* Get image config ID */
+	image_config_id = extract_uint_be(fwu->config_data);
+	dev_info(rmi4_data->pdev->dev.parent,
+			"%s:  Image config ID = 0x%02x 0x%02x 0x%02x 0x%02x\n",
+			__func__,
+			fwu->config_data[0],
+			fwu->config_data[1],
+			fwu->config_data[2],
+			fwu->config_data[3]);
+
+/*** ZTEMT Modify by luochangyang, 2013/12/25 ***/
+	if ((config_id[2] == fwu->config_data[2]) && 
+        (fwu->config_data[3] > config_id[3])) {
+		flash_area = UI_FIRMWARE;
+		goto exit;
+	}
+    else if (config_id[2] != fwu->config_data[2]) {
+        dev_info(rmi4_data->pdev->dev.parent, "%s: Firmware didn't match\n", __func__);
+    }
+
+	flash_area = NONE;
+/***ZTEMT END***/
+
+exit:
+	if (flash_area == NONE) {
+		dev_info(rmi4_data->pdev->dev.parent,
+				"%s: No need to do reflash\n",
+				__func__);
+	} else {
+		dev_info(rmi4_data->pdev->dev.parent,
+				"%s: Updating %s\n",
+				__func__,
+				flash_area == UI_FIRMWARE ?
+				"UI firmware" :
+				"config only");
+	}
+
+	return flash_area;
+}
+
+static int fwu_scan_pdt(void)
+{
+	int retval;
+	unsigned char ii;
+	unsigned char intr_count = 0;
+	unsigned char intr_off;
+	unsigned char intr_src;
+	unsigned short addr;
+	bool f01found = false;
+	bool f34found = false;
+	struct synaptics_rmi4_fn_desc rmi_fd;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	for (addr = PDT_START; addr > PDT_END; addr -= PDT_ENTRY_SIZE) {
+		retval = synaptics_rmi4_reg_read(rmi4_data,
+				addr,
+				(unsigned char *)&rmi_fd,
+				sizeof(rmi_fd));
+		if (retval < 0)
+			return retval;
+
+		if (rmi_fd.fn_number) {
+			dev_dbg(rmi4_data->pdev->dev.parent,
+					"%s: Found F%02x\n",
+					__func__, rmi_fd.fn_number);
+			switch (rmi_fd.fn_number) {
+			case SYNAPTICS_RMI4_F01:
+				f01found = true;
+
+				rmi4_data->f01_query_base_addr =
+						rmi_fd.query_base_addr;
+				rmi4_data->f01_ctrl_base_addr =
+						rmi_fd.ctrl_base_addr;
+				rmi4_data->f01_data_base_addr =
+						rmi_fd.data_base_addr;
+				rmi4_data->f01_cmd_base_addr =
+						rmi_fd.cmd_base_addr;
+				break;
+			case SYNAPTICS_RMI4_F34:
+				f34found = true;
+				fwu->f34_fd.query_base_addr =
+						rmi_fd.query_base_addr;
+				fwu->f34_fd.ctrl_base_addr =
+						rmi_fd.ctrl_base_addr;
+				fwu->f34_fd.data_base_addr =
+						rmi_fd.data_base_addr;
+
+				fwu->intr_mask = 0;
+				intr_src = rmi_fd.intr_src_count;
+				intr_off = intr_count % 8;
+				for (ii = intr_off;
+						ii < ((intr_src & MASK_3BIT) +
+						intr_off);
+						ii++) {
+					fwu->intr_mask |= 1 << ii;
+				}
+				break;
+			}
+		} else {
+			break;
+		}
+
+		intr_count += (rmi_fd.intr_src_count & MASK_3BIT);
+	}
+
+	if (!f01found || !f34found) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to find both F01 and F34\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int fwu_write_blocks(unsigned char *block_ptr, unsigned short block_cnt,
+		unsigned char command)
+{
+	int retval;
+	unsigned char block_offset[] = {0, 0};
+	unsigned short block_num;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	block_offset[1] |= (fwu->config_area << 5);
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			fwu->f34_fd.data_base_addr + BLOCK_NUMBER_OFFSET,
+			block_offset,
+			sizeof(block_offset));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to write to block number registers\n",
+				__func__);
+		return retval;
+	}
+
+	for (block_num = 0; block_num < block_cnt; block_num++) {
+		retval = synaptics_rmi4_reg_write(rmi4_data,
+				fwu->f34_fd.data_base_addr + fwu->blk_data_off,
+				block_ptr,
+				fwu->block_size);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to write block data (block %d)\n",
+					__func__, block_num);
+			return retval;
+		}
+
+		retval = fwu_write_f34_command(command);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to write command for block %d\n",
+					__func__, block_num);
+			return retval;
+		}
+
+		retval = fwu_wait_for_idle(WRITE_WAIT_MS);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to wait for idle status (block %d)\n",
+					__func__, block_num);
+			return retval;
+		}
+
+		block_ptr += fwu->block_size;
+	}
+
+	return 0;
+}
+
+static int fwu_write_firmware(void)
+{
+	return fwu_write_blocks((unsigned char *)fwu->firmware_data,
+		fwu->fw_block_count, CMD_WRITE_FW_BLOCK);
+}
+
+static int fwu_write_configuration(void)
+{
+	return fwu_write_blocks((unsigned char *)fwu->config_data,
+		fwu->config_block_count, CMD_WRITE_CONFIG_BLOCK);
+}
+
+static int fwu_write_lockdown(void)
+{
+	return fwu_write_blocks((unsigned char *)fwu->lockdown_data,
+		fwu->lockdown_block_count, CMD_WRITE_LOCKDOWN_BLOCK);
+}
+
+static int fwu_write_bootloader_id(void)
+{
+	int retval;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			fwu->f34_fd.data_base_addr + fwu->blk_data_off,
+			fwu->bootloader_id,
+			sizeof(fwu->bootloader_id));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to write bootloader ID\n",
+				__func__);
+		return retval;
+	}
+
+	return 0;
+}
+
+static int fwu_enter_flash_prog(void)
+{
+	int retval;
+	struct f01_device_status f01_device_status;
+	struct f01_device_control f01_device_control;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	retval = fwu_write_bootloader_id();
+	if (retval < 0)
+		return retval;
+
+	retval = fwu_write_f34_command(CMD_ENABLE_FLASH_PROG);
+	if (retval < 0)
+		return retval;
+
+	retval = fwu_wait_for_idle(ENABLE_WAIT_MS);
+	if (retval < 0)
+		return retval;
+
+	if (!fwu->program_enabled) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Program enabled bit not set\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	retval = fwu_scan_pdt();
+	if (retval < 0)
+		return retval;
+
+	retval = fwu_read_f01_device_status(&f01_device_status);
+	if (retval < 0)
+		return retval;
+
+	if (!f01_device_status.flash_prog) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Not in flash prog mode\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	retval = fwu_read_f34_queries();
+	if (retval < 0)
+		return retval;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			rmi4_data->f01_ctrl_base_addr,
+			f01_device_control.data,
+			sizeof(f01_device_control.data));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read F01 device control\n",
+				__func__);
+		return retval;
+	}
+
+	f01_device_control.nosleep = true;
+	f01_device_control.sleep_mode = SLEEP_MODE_NORMAL;
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			rmi4_data->f01_ctrl_base_addr,
+			f01_device_control.data,
+			sizeof(f01_device_control.data));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to write F01 device control\n",
+				__func__);
+		return retval;
+	}
+
+	return retval;
+}
+
+static int fwu_do_reflash(void)
+{
+	int retval;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	retval = fwu_enter_flash_prog();
+	if (retval < 0)
+		return retval;
+
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Entered flash prog mode\n",
+			__func__);
+
+	retval = fwu_write_bootloader_id();
+	if (retval < 0)
+		return retval;
+
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Bootloader ID written\n",
+			__func__);
+
+	retval = fwu_write_f34_command(CMD_ERASE_ALL);
+	if (retval < 0)
+		return retval;
+
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Erase all command written\n",
+			__func__);
+
+	retval = fwu_wait_for_idle(ERASE_WAIT_MS);
+	if (retval < 0)
+		return retval;
+
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Idle status detected\n",
+			__func__);
+
+	if (fwu->firmware_data) {
+		retval = fwu_write_firmware();
+		if (retval < 0)
+			return retval;
+		pr_notice("%s: Firmware programmed\n", __func__);
+	}
+
+	if (fwu->config_data) {
+		retval = fwu_write_configuration();
+		if (retval < 0)
+			return retval;
+		pr_notice("%s: Configuration programmed\n", __func__);
+	}
+
+	return retval;
+}
+
+static int fwu_do_write_config(void)
+{
+	int retval;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	retval = fwu_enter_flash_prog();
+	if (retval < 0)
+		return retval;
+
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Entered flash prog mode\n",
+			__func__);
+
+	if (fwu->config_area == PERM_CONFIG_AREA) {
+		fwu->config_block_count = fwu->perm_config_block_count;
+		goto write_config;
+	}
+
+	retval = fwu_write_bootloader_id();
+	if (retval < 0)
+		return retval;
+
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Bootloader ID written\n",
+			__func__);
+
+	switch (fwu->config_area) {
+	case UI_CONFIG_AREA:
+		retval = fwu_write_f34_command(CMD_ERASE_CONFIG);
+		break;
+	case BL_CONFIG_AREA:
+		retval = fwu_write_f34_command(CMD_ERASE_BL_CONFIG);
+		fwu->config_block_count = fwu->bl_config_block_count;
+		break;
+	case DISP_CONFIG_AREA:
+		retval = fwu_write_f34_command(CMD_ERASE_DISP_CONFIG);
+		fwu->config_block_count = fwu->disp_config_block_count;
+		break;
+	}
+	if (retval < 0)
+		return retval;
+
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Erase command written\n",
+			__func__);
+
+	retval = fwu_wait_for_idle(ERASE_WAIT_MS);
+	if (retval < 0)
+		return retval;
+
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Idle status detected\n",
+			__func__);
+
+write_config:
+	retval = fwu_write_configuration();
+	if (retval < 0)
+		return retval;
+
+	pr_notice("%s: Config written\n", __func__);
+
+	return retval;
+}
+
+static int fwu_start_write_config(void)
+{
+	int retval;
+	unsigned short block_count;
+	struct image_header_data header;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	switch (fwu->config_area) {
+	case UI_CONFIG_AREA:
+		block_count = fwu->config_block_count;
+		break;
+	case PERM_CONFIG_AREA:
+		if (!fwu->has_perm_config)
+			return -EINVAL;
+		block_count = fwu->perm_config_block_count;
+		break;
+	case BL_CONFIG_AREA:
+		if (!fwu->has_bl_config)
+			return -EINVAL;
+		block_count = fwu->bl_config_block_count;
+		break;
+	case DISP_CONFIG_AREA:
+		if (!fwu->has_disp_config)
+			return -EINVAL;
+		block_count = fwu->disp_config_block_count;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (fwu->ext_data_source)
+		fwu->config_data = fwu->ext_data_source;
+	else
+		return -EINVAL;
+
+	fwu->config_size = fwu->block_size * block_count;
+
+	/* Jump to the config area if given a packrat image */
+	if ((fwu->config_area == UI_CONFIG_AREA) &&
+			(fwu->config_size != fwu->image_size)) {
+		parse_header(&header, fwu->ext_data_source);
+
+		if (header.config_size) {
+			fwu->config_data = fwu->ext_data_source +
+					FW_IMAGE_OFFSET +
+					header.firmware_size;
+		} else {
+			return -EINVAL;
+		}
+	}
+
+	pr_notice("%s: Start of write config process\n", __func__);
+
+	retval = fwu_do_write_config();
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to write config\n",
+				__func__);
+	}
+
+	rmi4_data->reset_device(rmi4_data);
+
+	pr_notice("%s: End of write config process\n", __func__);
+
+	return retval;
+}
+
+static int fwu_do_read_config(void)
+{
+	int retval;
+	unsigned char block_offset[] = {0, 0};
+	unsigned short block_num;
+	unsigned short block_count;
+	unsigned short index = 0;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	retval = fwu_enter_flash_prog();
+	if (retval < 0)
+		goto exit;
+
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Entered flash prog mode\n",
+			__func__);
+
+	switch (fwu->config_area) {
+	case UI_CONFIG_AREA:
+		block_count = fwu->config_block_count;
+		break;
+	case PERM_CONFIG_AREA:
+		if (!fwu->has_perm_config) {
+			retval = -EINVAL;
+			goto exit;
+		}
+		block_count = fwu->perm_config_block_count;
+		break;
+	case BL_CONFIG_AREA:
+		if (!fwu->has_bl_config) {
+			retval = -EINVAL;
+			goto exit;
+		}
+		block_count = fwu->bl_config_block_count;
+		break;
+	case DISP_CONFIG_AREA:
+		if (!fwu->has_disp_config) {
+			retval = -EINVAL;
+			goto exit;
+		}
+		block_count = fwu->disp_config_block_count;
+		break;
+	default:
+		retval = -EINVAL;
+		goto exit;
+	}
+
+	fwu->config_size = fwu->block_size * block_count;
+
+	kfree(fwu->read_config_buf);
+	fwu->read_config_buf = kzalloc(fwu->config_size, GFP_KERNEL);
+
+	block_offset[1] |= (fwu->config_area << 5);
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			fwu->f34_fd.data_base_addr + BLOCK_NUMBER_OFFSET,
+			block_offset,
+			sizeof(block_offset));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to write to block number registers\n",
+				__func__);
+		goto exit;
+	}
+
+	for (block_num = 0; block_num < block_count; block_num++) {
+		retval = fwu_write_f34_command(CMD_READ_CONFIG_BLOCK);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to write read config command\n",
+					__func__);
+			goto exit;
+		}
+
+		retval = fwu_wait_for_idle(WRITE_WAIT_MS);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to wait for idle status\n",
+					__func__);
+			goto exit;
+		}
+
+		retval = synaptics_rmi4_reg_read(rmi4_data,
+				fwu->f34_fd.data_base_addr + fwu->blk_data_off,
+				&fwu->read_config_buf[index],
+				fwu->block_size);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to read block data (block %d)\n",
+					__func__, block_num);
+			goto exit;
+		}
+
+		index += fwu->block_size;
+	}
+
+exit:
+	rmi4_data->reset_device(rmi4_data);
+
+	return retval;
+}
+
+static int fwu_do_lockdown(void)
+{
+	int retval;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	retval = fwu_enter_flash_prog();
+	if (retval < 0)
+		return retval;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			fwu->f34_fd.query_base_addr + fwu->properties_off,
+			&fwu->flash_properties,
+			sizeof(fwu->flash_properties));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read flash properties\n",
+				__func__);
+		return retval;
+	}
+
+	if ((fwu->flash_properties & UNLOCKED) == 0) {
+		dev_info(rmi4_data->pdev->dev.parent,
+				"%s: Device already locked down\n",
+				__func__);
+		return retval;
+	}
+
+	retval = fwu_write_lockdown();
+	if (retval < 0)
+		return retval;
+
+	pr_notice("%s: Lockdown programmed\n", __func__);
+
+	return retval;
+}
+
+static int fwu_start_reflash(void)
+{
+	int retval = 0;
+	enum flash_area flash_area;
+	struct image_header_data header;
+	struct f01_device_status f01_device_status;
+	const unsigned char *fw_image;
+	const struct firmware *fw_entry = NULL;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	if (rmi4_data->sensor_sleep) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Sensor sleeping\n",
+				__func__);
+		return -ENODEV;
+	}
+
+	rmi4_data->stay_awake = true;
+	/*luochangyang 2014/05/15*/
+	rmi4_data->fw_update = 1;	
+	/*luochangyang END*/
+
+	pr_notice("%s: Start of reflash process\n", __func__);
+
+	if (fwu->ext_data_source) {
+		fw_image = fwu->ext_data_source;
+	} else {
+		strncpy(fwu->image_name, FW_IMAGE_NAME, MAX_IMAGE_NAME_LEN);
+		dev_dbg(rmi4_data->pdev->dev.parent,
+				"%s: Requesting firmware image %s\n",
+				__func__, fwu->image_name);
+
+		retval = request_firmware(&fw_entry, fwu->image_name,
+				rmi4_data->pdev->dev.parent);
+		if (retval != 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Firmware image %s not available\n",
+					__func__, fwu->image_name);
+			retval = -EINVAL;
+			goto exit;
+		}
+
+		dev_dbg(rmi4_data->pdev->dev.parent,
+				"%s: Firmware image size = %d\n",
+				__func__, fw_entry->size);
+
+		fw_image = fw_entry->data;
+	}
+
+	parse_header(&header, fw_image);
+
+	if (fwu->bl_version != header.bootloader_version) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Bootloader version mismatch\n",
+				__func__);
+		retval = -EINVAL;
+		goto exit;
+	}
+
+	retval = fwu_read_f01_device_status(&f01_device_status);
+	if (retval < 0)
+		goto exit;
+
+	if (f01_device_status.flash_prog) {
+		dev_info(rmi4_data->pdev->dev.parent,
+				"%s: In flash prog mode\n",
+				__func__);
+		fwu->in_flash_prog_mode = true;
+	} else {
+		fwu->in_flash_prog_mode = false;
+	}
+
+	if (fwu->do_lockdown) {
+		switch (fwu->bl_version) {
+		case V5:
+		case V6:
+			fwu->lockdown_data = fw_image + LOCKDOWN_OFFSET;
+			fwu->lockdown_block_count = LOCKDOWN_BLOCK_COUNT;
+			retval = fwu_do_lockdown();
+			if (retval < 0) {
+				dev_err(rmi4_data->pdev->dev.parent,
+						"%s: Failed to do lockdown\n",
+						__func__);
+			}
+		default:
+			break;
+		}
+	}
+
+	if (header.firmware_size)
+		fwu->firmware_data = fw_image + FW_IMAGE_OFFSET;
+	if (header.config_size) {
+		fwu->config_data = fw_image + FW_IMAGE_OFFSET +
+				header.firmware_size;
+	}
+
+	flash_area = fwu_go_nogo(&header);
+	switch (flash_area) {
+	case UI_FIRMWARE:
+		retval = fwu_do_reflash();
+		break;
+	case CONFIG_AREA:
+		retval = fwu_do_write_config();
+		break;
+	case NONE:
+	default:
+		goto exit;
+	}
+
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to do reflash\n",
+				__func__);
+	}
+
+exit:
+	/*luochangyang 2014/05/15*/
+	rmi4_data->fw_update = 0;	
+	/*luochangyang END*/
+	rmi4_data->reset_device(rmi4_data);
+
+	if (fw_entry)
+		release_firmware(fw_entry);
+
+	pr_notice("%s: End of reflash process\n", __func__);
+
+	rmi4_data->stay_awake = false;
+
+	return retval;
+}
+
+int synaptics_fw_updater(unsigned char *fw_data)
+{
+	int retval;
+
+	if (!fwu)
+		return -ENODEV;
+
+	if (!fwu->initialized)
+		return -ENODEV;
+
+	fwu->ext_data_source = fw_data;
+	fwu->config_area = UI_CONFIG_AREA;
+
+	retval = fwu_start_reflash();
+
+	return retval;
+}
+EXPORT_SYMBOL(synaptics_fw_updater);
+
+static void fwu_startup_fw_update_work(struct work_struct *work)
+{
+	synaptics_fw_updater(NULL);
+
+	return;
+}
+
+static ssize_t fwu_sysfs_show_image(struct file *data_file,
+		struct kobject *kobj, struct bin_attribute *attributes,
+		char *buf, loff_t pos, size_t count)
+{
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	if (count < fwu->config_size) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Not enough space (%d bytes) in buffer\n",
+				__func__, count);
+		return -EINVAL;
+	}
+
+	memcpy(buf, fwu->read_config_buf, fwu->config_size);
+
+	return fwu->config_size;
+}
+
+static ssize_t fwu_sysfs_store_image(struct file *data_file,
+		struct kobject *kobj, struct bin_attribute *attributes,
+		char *buf, loff_t pos, size_t count)
+{
+	memcpy((void *)(&fwu->ext_data_source[fwu->data_pos]),
+			(const void *)buf,
+			count);
+
+	fwu->data_pos += count;
+
+	return count;
+}
+
+static ssize_t fwu_sysfs_do_reflash_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned int input;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	if (sscanf(buf, "%u", &input) != 1) {
+		retval = -EINVAL;
+		goto exit;
+	}
+
+	if (input & LOCKDOWN) {
+		fwu->do_lockdown = true;
+		input &= ~LOCKDOWN;
+	}
+
+	if ((input != NORMAL) && (input != FORCE)) {
+		retval = -EINVAL;
+		goto exit;
+	}
+
+	if (input == FORCE)
+		fwu->force_update = true;
+
+	retval = synaptics_fw_updater(fwu->ext_data_source);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to do reflash\n",
+				__func__);
+		goto exit;
+	}
+
+	retval = count;
+
+exit:
+	kfree(fwu->ext_data_source);
+	fwu->ext_data_source = NULL;
+	fwu->force_update = FORCE_UPDATE;
+	fwu->do_lockdown = DO_LOCKDOWN;
+	return retval;
+}
+
+static ssize_t fwu_sysfs_write_config_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned int input;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	if (sscanf(buf, "%u", &input) != 1) {
+		retval = -EINVAL;
+		goto exit;
+	}
+
+	if (input != 1) {
+		retval = -EINVAL;
+		goto exit;
+	}
+
+	retval = fwu_start_write_config();
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to write config\n",
+				__func__);
+		goto exit;
+	}
+
+	retval = count;
+
+exit:
+	kfree(fwu->ext_data_source);
+	fwu->ext_data_source = NULL;
+	return retval;
+}
+
+static ssize_t fwu_sysfs_read_config_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned int input;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	if (sscanf(buf, "%u", &input) != 1)
+		return -EINVAL;
+
+	if (input != 1)
+		return -EINVAL;
+
+	retval = fwu_do_read_config();
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read config\n",
+				__func__);
+		return retval;
+	}
+
+	return count;
+}
+
+static ssize_t fwu_sysfs_config_area_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned long config_area;
+
+	retval = sstrtoul(buf, 10, &config_area);
+	if (retval)
+		return retval;
+
+	fwu->config_area = config_area;
+
+	return count;
+}
+
+static ssize_t fwu_sysfs_image_name_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	memcpy(fwu->image_name, buf, count);
+
+	return count;
+}
+
+static ssize_t fwu_sysfs_image_size_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned long size;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	retval = sstrtoul(buf, 10, &size);
+	if (retval)
+		return retval;
+
+	fwu->image_size = size;
+	fwu->data_pos = 0;
+
+	kfree(fwu->ext_data_source);
+	fwu->ext_data_source = kzalloc(fwu->image_size, GFP_KERNEL);
+	if (!fwu->ext_data_source) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to alloc mem for image data\n",
+				__func__);
+		return -ENOMEM;
+	}
+
+	return count;
+}
+
+static ssize_t fwu_sysfs_block_size_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u\n", fwu->block_size);
+}
+
+static ssize_t fwu_sysfs_firmware_block_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u\n", fwu->fw_block_count);
+}
+
+static ssize_t fwu_sysfs_configuration_block_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u\n", fwu->config_block_count);
+}
+
+static ssize_t fwu_sysfs_perm_config_block_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u\n", fwu->perm_config_block_count);
+}
+
+static ssize_t fwu_sysfs_bl_config_block_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u\n", fwu->bl_config_block_count);
+}
+
+static ssize_t fwu_sysfs_disp_config_block_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u\n", fwu->disp_config_block_count);
+}
+
+static void synaptics_rmi4_fwu_attn(struct synaptics_rmi4_data *rmi4_data,
+		unsigned char intr_mask)
+{
+	if (!fwu)
+		return;
+
+	if (fwu->intr_mask & intr_mask)
+		fwu_read_f34_flash_status();
+
+	return;
+}
+
+static int synaptics_rmi4_fwu_init(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	unsigned char attr_count;
+	struct pdt_properties pdt_props;
+
+	fwu = kzalloc(sizeof(*fwu), GFP_KERNEL);
+	if (!fwu) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to alloc mem for fwu\n",
+				__func__);
+		retval = -ENOMEM;
+		goto exit;
+	}
+
+	fwu->image_name = kzalloc(MAX_IMAGE_NAME_LEN, GFP_KERNEL);
+	if (!fwu->image_name) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to alloc mem for image name\n",
+				__func__);
+		retval = -ENOMEM;
+		goto exit_free_fwu;
+	}
+
+	fwu->rmi4_data = rmi4_data;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			PDT_PROPS,
+			pdt_props.data,
+			sizeof(pdt_props.data));
+	if (retval < 0) {
+		dev_dbg(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read PDT properties, assuming 0x00\n",
+				__func__);
+	} else if (pdt_props.has_bsr) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Reflash for LTS not currently supported\n",
+				__func__);
+		retval = -ENODEV;
+		goto exit_free_mem;
+	}
+
+	retval = fwu_scan_pdt();
+	if (retval < 0)
+		goto exit_free_mem;
+
+	fwu->productinfo1 = rmi4_data->rmi4_mod_info.product_info[0];
+	fwu->productinfo2 = rmi4_data->rmi4_mod_info.product_info[1];
+	memcpy(fwu->product_id, rmi4_data->rmi4_mod_info.product_id_string,
+			SYNAPTICS_RMI4_PRODUCT_ID_SIZE);
+	fwu->product_id[SYNAPTICS_RMI4_PRODUCT_ID_SIZE] = 0;
+
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: F01 product info: 0x%04x 0x%04x\n",
+			__func__, fwu->productinfo1, fwu->productinfo2);
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: F01 product ID: %s\n",
+			__func__, fwu->product_id);
+
+	retval = fwu_read_f34_queries();
+	if (retval < 0)
+		goto exit_free_mem;
+
+	fwu->force_update = FORCE_UPDATE;
+	fwu->do_lockdown = DO_LOCKDOWN;
+	fwu->initialized = true;
+
+	retval = sysfs_create_bin_file(&rmi4_data->input_dev->dev.kobj,
+			&dev_attr_data);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to create sysfs bin file\n",
+				__func__);
+		goto exit_free_mem;
+	}
+
+	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++) {
+		retval = sysfs_create_file(&rmi4_data->input_dev->dev.kobj,
+				&attrs[attr_count].attr);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to create sysfs attributes\n",
+					__func__);
+			retval = -ENODEV;
+			goto exit_remove_attrs;
+		}
+	}
+
+#ifdef DO_STARTUP_FW_UPDATE
+	fwu->fwu_workqueue = create_singlethread_workqueue("fwu_workqueue");
+	INIT_DELAYED_WORK(&fwu->fwu_work, fwu_startup_fw_update_work);
+	queue_delayed_work(fwu->fwu_workqueue,
+			&fwu->fwu_work,
+			msecs_to_jiffies(STARTUP_FW_UPDATE_DELAY_MS));
+#endif
+
+	return 0;
+
+exit_remove_attrs:
+	for (attr_count--; attr_count >= 0; attr_count--) {
+		sysfs_remove_file(&rmi4_data->input_dev->dev.kobj,
+				&attrs[attr_count].attr);
+	}
+
+	sysfs_remove_bin_file(&rmi4_data->input_dev->dev.kobj, &dev_attr_data);
+
+exit_free_mem:
+	kfree(fwu->image_name);
+
+exit_free_fwu:
+	kfree(fwu);
+	fwu = NULL;
+
+exit:
+	return retval;
+}
+
+static void synaptics_rmi4_fwu_remove(struct synaptics_rmi4_data *rmi4_data)
+{
+	unsigned char attr_count;
+
+	if (!fwu)
+		goto exit;
+
+	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++) {
+		sysfs_remove_file(&rmi4_data->input_dev->dev.kobj,
+				&attrs[attr_count].attr);
+	}
+
+	sysfs_remove_bin_file(&rmi4_data->input_dev->dev.kobj, &dev_attr_data);
+
+	kfree(fwu->read_config_buf);
+	kfree(fwu->image_name);
+	kfree(fwu);
+	fwu = NULL;
+
+exit:
+	complete(&fwu_remove_complete);
+
+	return;
+}
+
+static struct synaptics_rmi4_exp_fn fwu_module = {
+	.fn_type = RMI_FW_UPDATER,
+	.init = synaptics_rmi4_fwu_init,
+	.remove = synaptics_rmi4_fwu_remove,
+	.reset = NULL,
+	.reinit = NULL,
+	.early_suspend = NULL,
+	.suspend = NULL,
+	.resume = NULL,
+	.late_resume = NULL,
+	.attn = synaptics_rmi4_fwu_attn,
+};
+
+static int __init rmi4_fw_update_module_init(void)
+{
+	synaptics_rmi4_new_function(&fwu_module, true);
+
+	return 0;
+}
+
+static void __exit rmi4_fw_update_module_exit(void)
+{
+	synaptics_rmi4_new_function(&fwu_module, false);
+
+	wait_for_completion(&fwu_remove_complete);
+
+	return;
+}
+
+module_init(rmi4_fw_update_module_init);
+module_exit(rmi4_fw_update_module_exit);
+
+MODULE_AUTHOR("Synaptics, Inc.");
+MODULE_DESCRIPTION("Synaptics DSX FW Update Module");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_i2c.c b/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_i2c.c
new file mode 100755
index 0000000..481c6e4
--- /dev/null
+++ b/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_i2c.c
@@ -0,0 +1,425 @@
+/*
+ * Synaptics DSX touchscreen driver
+ *
+ * Copyright (C) 2012 Synaptics Incorporated
+ *
+ * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
+ * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+
+/*** ZTEMT Added by luochangyang, 2013/12/23 ***/
+#ifdef CONFIG_OF
+#include <linux/err.h>
+#include <linux/of_gpio.h>
+#include <linux/regulator/consumer.h>
+#endif
+/***ZTEMT END***/
+
+#include "synaptics_dsx.h"
+#include "synaptics_dsx_core.h"
+
+#define SYN_I2C_RETRY_TIMES 2   //10  Modify by luochangyang, 2013/12/19
+
+static int synaptics_rmi4_i2c_set_page(struct synaptics_rmi4_data *rmi4_data,
+		unsigned short addr)
+{
+	int retval;
+	unsigned char retry;
+	unsigned char buf[PAGE_SELECT_LEN];
+	unsigned char page;
+	struct i2c_client *i2c = to_i2c_client(rmi4_data->pdev->dev.parent);
+
+	page = ((addr >> 8) & MASK_8BIT);
+	if (page != rmi4_data->current_page) {
+		buf[0] = MASK_8BIT;
+		buf[1] = page;
+		for (retry = 0; retry < SYN_I2C_RETRY_TIMES; retry++) {
+			retval = i2c_master_send(i2c, buf, PAGE_SELECT_LEN);
+			if (retval != PAGE_SELECT_LEN) {
+				dev_err(rmi4_data->pdev->dev.parent,
+						"%s: I2C retry %d\n",
+						__func__, retry + 1);
+				msleep(20);
+			} else {
+				rmi4_data->current_page = page;
+				break;
+			}
+		}
+	} else {
+		retval = PAGE_SELECT_LEN;
+	}
+
+	return retval;
+}
+
+static int synaptics_rmi4_i2c_read(struct synaptics_rmi4_data *rmi4_data,
+		unsigned short addr, unsigned char *data, unsigned short length)
+{
+	int retval;
+	unsigned char retry;
+	unsigned char buf;
+	struct i2c_client *i2c = to_i2c_client(rmi4_data->pdev->dev.parent);
+	struct i2c_msg msg[] = {
+		{
+			.addr = i2c->addr,
+			.flags = 0,
+			.len = 1,
+			.buf = &buf,
+		},
+		{
+			.addr = i2c->addr,
+			.flags = I2C_M_RD,
+			.len = length,
+			.buf = data,
+		},
+	};
+
+	buf = addr & MASK_8BIT;
+
+	mutex_lock(&rmi4_data->rmi4_io_ctrl_mutex);
+
+	retval = synaptics_rmi4_i2c_set_page(rmi4_data, addr);
+	if (retval != PAGE_SELECT_LEN) {
+		retval = -EIO;
+		goto exit;
+	}
+
+	for (retry = 0; retry < SYN_I2C_RETRY_TIMES; retry++) {
+		if (i2c_transfer(i2c->adapter, msg, 2) == 2) {
+			retval = length;
+			break;
+		}
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: I2C retry %d\n",
+				__func__, retry + 1);
+		msleep(20);
+	}
+
+	if (retry == SYN_I2C_RETRY_TIMES) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: I2C read over retry limit\n",
+				__func__);
+		retval = -EIO;
+	}
+
+exit:
+	mutex_unlock(&rmi4_data->rmi4_io_ctrl_mutex);
+
+	return retval;
+}
+
+static int synaptics_rmi4_i2c_write(struct synaptics_rmi4_data *rmi4_data,
+		unsigned short addr, unsigned char *data, unsigned short length)
+{
+	int retval;
+	unsigned char retry;
+	unsigned char buf[length + 1];
+	struct i2c_client *i2c = to_i2c_client(rmi4_data->pdev->dev.parent);
+	struct i2c_msg msg[] = {
+		{
+			.addr = i2c->addr,
+			.flags = 0,
+			.len = length + 1,
+			.buf = buf,
+		}
+	};
+
+	mutex_lock(&rmi4_data->rmi4_io_ctrl_mutex);
+
+	retval = synaptics_rmi4_i2c_set_page(rmi4_data, addr);
+	if (retval != PAGE_SELECT_LEN) {
+		retval = -EIO;
+		goto exit;
+	}
+
+	buf[0] = addr & MASK_8BIT;
+	memcpy(&buf[1], &data[0], length);
+
+	for (retry = 0; retry < SYN_I2C_RETRY_TIMES; retry++) {
+		if (i2c_transfer(i2c->adapter, msg, 1) == 1) {
+			retval = length;
+			break;
+		}
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: I2C retry %d\n",
+				__func__, retry + 1);
+		msleep(20);
+	}
+
+	if (retry == SYN_I2C_RETRY_TIMES) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: I2C write over retry limit\n",
+				__func__);
+		retval = -EIO;
+	}
+
+exit:
+	mutex_unlock(&rmi4_data->rmi4_io_ctrl_mutex);
+
+	return retval;
+}
+
+static struct synaptics_dsx_bus_access bus_access = {
+	.type = BUS_I2C,
+	.read = synaptics_rmi4_i2c_read,
+	.write = synaptics_rmi4_i2c_write,
+};
+
+static struct synaptics_dsx_hw_interface hw_if;
+
+static struct platform_device *synaptics_dsx_i2c_device;
+
+static void synaptics_rmi4_i2c_dev_release(struct device *dev)
+{
+	kfree(synaptics_dsx_i2c_device);
+
+	return;
+}
+
+/*** ZTEMT Added by luochangyang, 2013/11/28 ***/
+#ifdef CONFIG_OF
+static int synaptics_gpio_setup(int gpio, bool configure, int dir, int state)
+{
+	int retval = 0;
+	unsigned char buf[16];
+
+	if (configure) {
+		snprintf(buf, PAGE_SIZE, "dsx_gpio_%u\n", gpio);
+
+		retval = gpio_request(gpio, buf);
+		if (retval) {
+			pr_err("%s: Failed to get gpio %d (code: %d)",
+					__func__, gpio, retval);
+			return retval;
+		}
+
+		if (dir == 0)
+			retval = gpio_direction_input(gpio);
+		else
+			retval = gpio_direction_output(gpio, state);
+		if (retval) {
+			pr_err("%s: Failed to set gpio %d direction",
+					__func__, gpio);
+			return retval;
+		}
+	} else {
+		gpio_free(gpio);
+	}
+
+	return retval;
+}
+
+#if defined CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_S3508
+static unsigned char TM_f1a_button_codes[] = {KEY_MENU, KEY_HOME, KEY_BACK};
+#elif defined CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_S3208_5keys
+static unsigned char TM_f1a_button_codes[] = {KEY_MENU, KEY_MENU, KEY_HOME, KEY_BACK, KEY_BACK};
+#elif defined CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_S3208_3keys
+static unsigned char TM_f1a_button_codes[] = {KEY_MENU, KEY_HOME, KEY_BACK};
+#endif
+
+static struct synaptics_dsx_cap_button_map cap_button_map = {
+	.nbuttons = ARRAY_SIZE(TM_f1a_button_codes),
+	.map = TM_f1a_button_codes,
+};
+
+static int synaptics_parse_dt(struct device *dev, 
+        struct synaptics_dsx_board_data *pdata)
+{
+    int rc;
+    int temp_int;
+    u32 temp_val;
+	struct device_node *np = dev->of_node;
+
+	/* irq gpio info */
+	pdata->irq_gpio = of_get_named_gpio(np, "synaptics,irq-gpio", 0);
+    pdata->irq_flags = IRQF_TRIGGER_FALLING;
+
+    /* reset gpio info */
+	pdata->reset_gpio = of_get_named_gpio(np, "synaptics,reset-gpio", 0);
+    
+    rc = of_property_read_u32(np, "synaptics,reset_on_state", &temp_int);
+    if (rc) {
+        dev_err(dev, "Unable to read synaptics,reset_on_state\n");
+        return rc;
+    } else
+        pdata->reset_on_state = temp_int;
+    rc = of_property_read_u32(np, "synaptics,reset_delay_ms", &temp_val);
+    if (rc) {
+        dev_err(dev, "Unable to read synaptics,reset_delay_ms\n");
+        return rc;
+    } else
+        pdata->reset_delay_ms = temp_val;
+    rc = of_property_read_u32(np, "synaptics,reset_active_ms", &temp_val);
+    if (rc) {
+        dev_err(dev, "Unable to read synaptics,reset_active_ms\n");
+        return rc;
+    } else
+        pdata->reset_active_ms = temp_val;
+
+    if (of_property_read_bool(np, "synaptics,power_gpio") == 1) {
+        rc = of_property_read_u32(np, "synaptics,power_gpio", &temp_int);
+        if (rc) {
+            dev_err(dev, "Unable to read synaptics,power_gpio\n");
+            return rc;
+        } else
+            pdata->power_gpio = temp_int;
+    } else {
+        pdata->power_gpio = -1;
+    }
+    
+    rc = of_property_read_u32(np, "synaptics,power_on_state", &temp_val);
+    if (rc) {
+        dev_err(dev, "Unable to read synaptics,power_on_state\n");
+        return rc;
+    } else
+        pdata->power_on_state = temp_val;
+    rc = of_property_read_u32(np, "synaptics,power_delay_ms", &temp_val);
+    if (rc) {
+        dev_err(dev, "Unable to read synaptics,power_delay_ms\n");
+        return rc;
+    } else
+        pdata->power_delay_ms = temp_val;
+
+    pdata->gpio_config = synaptics_gpio_setup;
+    pdata->cap_button_map = &cap_button_map;
+	
+	return rc;
+}
+#else
+static int synaptics_parse_dt(struct device *dev, 
+        struct synaptics_dsx_board_data *pdata;)
+{
+	return -ENODEV;
+}
+#endif
+/***ZTEMT END***/
+
+static int synaptics_rmi4_i2c_probe(struct i2c_client *client,
+		const struct i2c_device_id *dev_id)
+{
+	int retval;
+    struct synaptics_dsx_board_data *platform_data; //Added by luochangyang, 2013/12/19
+
+	if (!i2c_check_functionality(client->adapter,
+			I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_err(&client->dev,
+				"%s: SMBus byte data commands not supported by host\n",
+				__func__);
+		return -EIO;
+	}
+
+	synaptics_dsx_i2c_device = kzalloc(
+			sizeof(struct platform_device),
+			GFP_KERNEL);
+	if (!synaptics_dsx_i2c_device) {
+		dev_err(&client->dev,
+				"%s: Failed to allocate memory for synaptics_dsx_i2c_device\n",
+				__func__);
+		return -ENOMEM;
+	}
+
+    /*** ZTEMT Added by luochangyang, 2013/12/19 ***/
+    if (client->dev.of_node) {
+        platform_data = devm_kzalloc(&client->dev,
+            sizeof(struct synaptics_dsx_board_data), GFP_KERNEL);
+        if (!platform_data) {
+            dev_err(&client->dev, "Failed to allocate memory\n");
+            return -ENOMEM;
+        }
+
+        retval = synaptics_parse_dt(&client->dev, platform_data);
+        if (retval)
+            return retval;
+
+        hw_if.board_data = platform_data;
+    } else
+        hw_if.board_data = client->dev.platform_data;
+    /***ZTEMT END***/
+	
+	hw_if.bus_access = &bus_access;
+
+	synaptics_dsx_i2c_device->name = PLATFORM_DRIVER_NAME;
+	synaptics_dsx_i2c_device->id = 0;
+	synaptics_dsx_i2c_device->num_resources = 0;
+	synaptics_dsx_i2c_device->dev.parent = &client->dev;
+	synaptics_dsx_i2c_device->dev.platform_data = &hw_if;
+	synaptics_dsx_i2c_device->dev.release = synaptics_rmi4_i2c_dev_release;
+
+	retval = platform_device_register(synaptics_dsx_i2c_device);
+	if (retval) {
+		dev_err(&client->dev,
+				"%s: Failed to register platform device\n",
+				__func__);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int synaptics_rmi4_i2c_remove(struct i2c_client *client)
+{
+	platform_device_unregister(synaptics_dsx_i2c_device);
+
+	return 0;
+}
+
+/*** ZTEMT Added by luochangyang, 2013/12/19 ***/
+static struct of_device_id synaptics_rmi4_i2c_of_match[] = {
+	{ .compatible = "synaptics_dsx_i2c,rmi4", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, synaptics_rmi4_i2c_of_match);
+/***ZTEMT END***/
+
+static const struct i2c_device_id synaptics_rmi4_id_table[] = {
+	{I2C_DRIVER_NAME, 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, synaptics_rmi4_id_table);
+
+static struct i2c_driver synaptics_rmi4_i2c_driver = {
+	.driver = {
+		.name = I2C_DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = synaptics_rmi4_i2c_of_match,
+	},
+	.probe = synaptics_rmi4_i2c_probe,
+	.remove = __devexit_p(synaptics_rmi4_i2c_remove),
+	.id_table = synaptics_rmi4_id_table,
+};
+
+int synaptics_rmi4_bus_init(void)
+{
+	return i2c_add_driver(&synaptics_rmi4_i2c_driver);
+}
+EXPORT_SYMBOL(synaptics_rmi4_bus_init);
+
+void synaptics_rmi4_bus_exit(void)
+{
+	i2c_del_driver(&synaptics_rmi4_i2c_driver);
+
+	return;
+}
+EXPORT_SYMBOL(synaptics_rmi4_bus_exit);
+
+MODULE_AUTHOR("Synaptics, Inc.");
+MODULE_DESCRIPTION("Synaptics DSX I2C Bus Support Module");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_proximity.c b/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_proximity.c
new file mode 100755
index 0000000..a0a62a5
--- /dev/null
+++ b/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_proximity.c
@@ -0,0 +1,671 @@
+/*
+ * Synaptics DSX touchscreen driver
+ *
+ * Copyright (C) 2012 Synaptics Incorporated
+ *
+ * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
+ * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include "synaptics_dsx.h"
+#include "synaptics_dsx_core.h"
+
+#define PROX_PHYS_NAME "synaptics_dsx/input1"
+
+#define HOVER_Z_MAX (255)
+
+#define HOVERING_FINGER_EN (1 << 4)
+
+static ssize_t synaptics_rmi4_hover_finger_en_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_hover_finger_en_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static struct device_attribute attrs[] = {
+	__ATTR(hover_finger_en, (0660),
+			synaptics_rmi4_hover_finger_en_show,
+			synaptics_rmi4_hover_finger_en_store),
+};
+
+struct synaptics_rmi4_f12_query_5 {
+	union {
+		struct {
+			unsigned char size_of_query6;
+			struct {
+				unsigned char ctrl0_is_present:1;
+				unsigned char ctrl1_is_present:1;
+				unsigned char ctrl2_is_present:1;
+				unsigned char ctrl3_is_present:1;
+				unsigned char ctrl4_is_present:1;
+				unsigned char ctrl5_is_present:1;
+				unsigned char ctrl6_is_present:1;
+				unsigned char ctrl7_is_present:1;
+			} __packed;
+			struct {
+				unsigned char ctrl8_is_present:1;
+				unsigned char ctrl9_is_present:1;
+				unsigned char ctrl10_is_present:1;
+				unsigned char ctrl11_is_present:1;
+				unsigned char ctrl12_is_present:1;
+				unsigned char ctrl13_is_present:1;
+				unsigned char ctrl14_is_present:1;
+				unsigned char ctrl15_is_present:1;
+			} __packed;
+			struct {
+				unsigned char ctrl16_is_present:1;
+				unsigned char ctrl17_is_present:1;
+				unsigned char ctrl18_is_present:1;
+				unsigned char ctrl19_is_present:1;
+				unsigned char ctrl20_is_present:1;
+				unsigned char ctrl21_is_present:1;
+				unsigned char ctrl22_is_present:1;
+				unsigned char ctrl23_is_present:1;
+			} __packed;
+		};
+		unsigned char data[4];
+	};
+};
+
+struct synaptics_rmi4_f12_query_8 {
+	union {
+		struct {
+			unsigned char size_of_query9;
+			struct {
+				unsigned char data0_is_present:1;
+				unsigned char data1_is_present:1;
+				unsigned char data2_is_present:1;
+				unsigned char data3_is_present:1;
+				unsigned char data4_is_present:1;
+				unsigned char data5_is_present:1;
+				unsigned char data6_is_present:1;
+				unsigned char data7_is_present:1;
+			} __packed;
+		};
+		unsigned char data[2];
+	};
+};
+
+struct prox_finger_data {
+	union {
+		struct {
+			unsigned char object_type_and_status;
+			unsigned char x_lsb;
+			unsigned char x_msb;
+			unsigned char y_lsb;
+			unsigned char y_msb;
+			unsigned char z;
+		} __packed;
+		unsigned char proximity_data[6];
+	};
+};
+
+struct synaptics_rmi4_prox_handle {
+	bool hover_finger_present;
+	bool hover_finger_en;
+	unsigned char intr_mask;
+	unsigned short query_base_addr;
+	unsigned short control_base_addr;
+	unsigned short data_base_addr;
+	unsigned short command_base_addr;
+	unsigned short hover_finger_en_addr;
+	unsigned short hover_finger_data_addr;
+	struct input_dev *prox_dev;
+	struct prox_finger_data *finger_data;
+	struct synaptics_rmi4_data *rmi4_data;
+};
+
+static struct synaptics_rmi4_prox_handle *prox;
+
+DECLARE_COMPLETION(prox_remove_complete);
+
+static void prox_hover_finger_lift(void)
+{
+	input_report_key(prox->prox_dev, BTN_TOUCH, 0);
+	input_report_key(prox->prox_dev, BTN_TOOL_FINGER, 0);
+	input_sync(prox->prox_dev);
+	prox->hover_finger_present = false;
+
+	return;
+}
+
+static void prox_hover_finger_report(void)
+{
+	int retval;
+	int x;
+	int y;
+	int z;
+	struct prox_finger_data *data;
+	struct synaptics_rmi4_data *rmi4_data = prox->rmi4_data;
+
+	data = prox->finger_data;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			prox->hover_finger_data_addr,
+			data->proximity_data,
+			sizeof(data->proximity_data));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read hovering finger data\n",
+				__func__);
+		return;
+	}
+
+	if (data->object_type_and_status != F12_HOVERING_FINGER_STATUS) {
+		if (prox->hover_finger_present)
+			prox_hover_finger_lift();
+
+		return;
+	}
+
+	x = (data->x_msb << 8) | (data->x_lsb);
+	y = (data->y_msb << 8) | (data->y_lsb);
+	z = HOVER_Z_MAX - data->z;
+
+	input_report_key(prox->prox_dev, BTN_TOUCH, 0);
+	input_report_key(prox->prox_dev, BTN_TOOL_FINGER, 1);
+	input_report_abs(prox->prox_dev, ABS_X, x);
+	input_report_abs(prox->prox_dev, ABS_Y, y);
+	input_report_abs(prox->prox_dev, ABS_DISTANCE, z);
+
+	input_sync(prox->prox_dev);
+
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: x = %d y = %d z = %d\n",
+			__func__, x, y, z);
+
+	prox->hover_finger_present = true;
+
+	return;
+}
+
+static int prox_set_hover_finger_en(void)
+{
+	int retval;
+	unsigned char object_report_enable;
+	struct synaptics_rmi4_data *rmi4_data = prox->rmi4_data;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			prox->hover_finger_en_addr,
+			&object_report_enable,
+			sizeof(object_report_enable));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read from object report enable register\n",
+				__func__);
+		return retval;
+	}
+
+	if (prox->hover_finger_en)
+		object_report_enable |= HOVERING_FINGER_EN;
+	else
+		object_report_enable &= ~HOVERING_FINGER_EN;
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			prox->hover_finger_en_addr,
+			&object_report_enable,
+			sizeof(object_report_enable));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to write to object report enable register\n",
+				__func__);
+		return retval;
+	}
+
+	return 0;
+}
+
+static void prox_set_params(void)
+{
+	input_set_abs_params(prox->prox_dev, ABS_X, 0,
+			prox->rmi4_data->sensor_max_x, 0, 0);
+	input_set_abs_params(prox->prox_dev, ABS_Y, 0,
+			prox->rmi4_data->sensor_max_y, 0, 0);
+	input_set_abs_params(prox->prox_dev, ABS_DISTANCE, 0,
+			HOVER_Z_MAX, 0, 0);
+
+	return;
+}
+
+static int prox_reg_init(void)
+{
+	int retval;
+	unsigned char ctrl_23_offset;
+	unsigned char data_1_offset;
+	struct synaptics_rmi4_f12_query_5 query_5;
+	struct synaptics_rmi4_f12_query_8 query_8;
+	struct synaptics_rmi4_data *rmi4_data = prox->rmi4_data;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			prox->query_base_addr + 5,
+			query_5.data,
+			sizeof(query_5.data));
+	if (retval < 0)
+		return retval;
+
+	ctrl_23_offset = query_5.ctrl0_is_present +
+			query_5.ctrl1_is_present +
+			query_5.ctrl2_is_present +
+			query_5.ctrl3_is_present +
+			query_5.ctrl4_is_present +
+			query_5.ctrl5_is_present +
+			query_5.ctrl6_is_present +
+			query_5.ctrl7_is_present +
+			query_5.ctrl8_is_present +
+			query_5.ctrl9_is_present +
+			query_5.ctrl10_is_present +
+			query_5.ctrl11_is_present +
+			query_5.ctrl12_is_present +
+			query_5.ctrl13_is_present +
+			query_5.ctrl14_is_present +
+			query_5.ctrl15_is_present +
+			query_5.ctrl16_is_present +
+			query_5.ctrl17_is_present +
+			query_5.ctrl18_is_present +
+			query_5.ctrl19_is_present +
+			query_5.ctrl20_is_present +
+			query_5.ctrl21_is_present +
+			query_5.ctrl22_is_present;
+
+	prox->hover_finger_en_addr = prox->control_base_addr + ctrl_23_offset;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			prox->query_base_addr + 8,
+			query_8.data,
+			sizeof(query_8.data));
+	if (retval < 0)
+		return retval;
+
+	data_1_offset = query_8.data0_is_present;
+	prox->hover_finger_data_addr = prox->data_base_addr + data_1_offset;
+
+	return retval;
+}
+
+static int prox_scan_pdt(void)
+{
+	int retval;
+	unsigned char ii;
+	unsigned char page;
+	unsigned char intr_count = 0;
+	unsigned char intr_off;
+	unsigned char intr_src;
+	unsigned short addr;
+	struct synaptics_rmi4_fn_desc fd;
+	struct synaptics_rmi4_data *rmi4_data = prox->rmi4_data;
+
+	for (page = 0; page < PAGES_TO_SERVICE; page++) {
+		for (addr = PDT_START; addr > PDT_END; addr -= PDT_ENTRY_SIZE) {
+			addr |= (page << 8);
+
+			retval = synaptics_rmi4_reg_read(rmi4_data,
+					addr,
+					(unsigned char *)&fd,
+					sizeof(fd));
+			if (retval < 0)
+				return retval;
+
+			addr &= ~(MASK_8BIT << 8);
+
+			if (fd.fn_number) {
+				dev_dbg(rmi4_data->pdev->dev.parent,
+						"%s: Found F%02x\n",
+						__func__, fd.fn_number);
+				switch (fd.fn_number) {
+				case SYNAPTICS_RMI4_F12:
+					goto f12_found;
+					break;
+				}
+			} else {
+				break;
+			}
+
+			intr_count += (fd.intr_src_count & MASK_3BIT);
+		}
+	}
+
+	dev_err(rmi4_data->pdev->dev.parent,
+			"%s: Failed to find F12\n",
+			__func__);
+	return -EINVAL;
+
+f12_found:
+	prox->query_base_addr = fd.query_base_addr | (page << 8);
+	prox->control_base_addr = fd.ctrl_base_addr | (page << 8);
+	prox->data_base_addr = fd.data_base_addr | (page << 8);
+	prox->command_base_addr = fd.cmd_base_addr | (page << 8);
+
+	retval = prox_reg_init();
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to initialize proximity registers\n",
+				__func__);
+		return retval;
+	}
+
+	prox->intr_mask = 0;
+	intr_src = fd.intr_src_count;
+	intr_off = intr_count % 8;
+	for (ii = intr_off;
+			ii < ((intr_src & MASK_3BIT) +
+			intr_off);
+			ii++) {
+		prox->intr_mask |= 1 << ii;
+	}
+
+	rmi4_data->intr_mask[0] |= prox->intr_mask;
+
+	addr = rmi4_data->f01_ctrl_base_addr + 1;
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			addr,
+			&(rmi4_data->intr_mask[0]),
+			sizeof(rmi4_data->intr_mask[0]));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to set interrupt enable bit\n",
+				__func__);
+		return retval;
+	}
+
+	return 0;
+}
+
+static ssize_t synaptics_rmi4_hover_finger_en_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	if (!prox)
+		return -ENODEV;
+
+	return snprintf(buf, PAGE_SIZE, "%u\n",
+			prox->hover_finger_en);
+}
+
+static ssize_t synaptics_rmi4_hover_finger_en_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned int input;
+	struct synaptics_rmi4_data *rmi4_data = prox->rmi4_data;
+
+	if (!prox)
+		return -ENODEV;
+
+	if (sscanf(buf, "%x", &input) != 1)
+		return -EINVAL;
+
+	if (input == 1)
+		prox->hover_finger_en = true;
+	else if (input == 0)
+		prox->hover_finger_en = false;
+	else
+		return -EINVAL;
+
+	retval = prox_set_hover_finger_en();
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to change hovering finger enable setting\n",
+				__func__);
+		return retval;
+	}
+
+	return count;
+}
+
+int synaptics_rmi4_prox_hover_finger_en(bool enable)
+{
+	int retval;
+
+	if (!prox)
+		return -ENODEV;
+
+	prox->hover_finger_en = enable;
+
+	retval = prox_set_hover_finger_en();
+	if (retval < 0)
+		return retval;
+
+	return 0;
+}
+EXPORT_SYMBOL(synaptics_rmi4_prox_hover_finger_en);
+
+static void synaptics_rmi4_prox_attn(struct synaptics_rmi4_data *rmi4_data,
+		unsigned char intr_mask)
+{
+	if (!prox)
+		return;
+
+	if (prox->intr_mask & intr_mask)
+		prox_hover_finger_report();
+
+	return;
+}
+
+static int synaptics_rmi4_prox_init(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	unsigned char attr_count;
+
+	prox = kzalloc(sizeof(*prox), GFP_KERNEL);
+	if (!prox) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to alloc mem for prox\n",
+				__func__);
+		retval = -ENOMEM;
+		goto exit;
+	}
+
+	prox->finger_data = kzalloc(sizeof(*(prox->finger_data)), GFP_KERNEL);
+	if (!prox->finger_data) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to alloc mem for finger_data\n",
+				__func__);
+		retval = -ENOMEM;
+		goto exit_free_prox;
+	}
+
+	prox->rmi4_data = rmi4_data;
+
+	retval = prox_scan_pdt();
+	if (retval < 0)
+		goto exit_free_finger_data;
+
+	prox->hover_finger_en = true;
+
+	retval = prox_set_hover_finger_en();
+	if (retval < 0)
+		return retval;
+
+	prox->prox_dev = input_allocate_device();
+	if (prox->prox_dev == NULL) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to allocate proximity device\n",
+				__func__);
+		retval = -ENOMEM;
+		goto exit_free_finger_data;
+	}
+
+	prox->prox_dev->name = PLATFORM_DRIVER_NAME;
+	prox->prox_dev->phys = PROX_PHYS_NAME;
+	prox->prox_dev->id.product = SYNAPTICS_DSX_DRIVER_PRODUCT;
+	prox->prox_dev->id.version = SYNAPTICS_DSX_DRIVER_VERSION;
+	prox->prox_dev->dev.parent = rmi4_data->pdev->dev.parent;
+	input_set_drvdata(prox->prox_dev, rmi4_data);
+
+	set_bit(EV_KEY, prox->prox_dev->evbit);
+	set_bit(EV_ABS, prox->prox_dev->evbit);
+	set_bit(BTN_TOUCH, prox->prox_dev->keybit);
+	set_bit(BTN_TOOL_FINGER, prox->prox_dev->keybit);
+#ifdef INPUT_PROP_DIRECT
+	set_bit(INPUT_PROP_DIRECT, prox->prox_dev->propbit);
+#endif
+
+	prox_set_params();
+
+	retval = input_register_device(prox->prox_dev);
+	if (retval) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to register proximity device\n",
+				__func__);
+		goto exit_free_input_device;
+	}
+
+	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++) {
+		retval = sysfs_create_file(&rmi4_data->input_dev->dev.kobj,
+				&attrs[attr_count].attr);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to create sysfs attributes\n",
+					__func__);
+			goto exit_free_sysfs;
+		}
+	}
+
+	return 0;
+
+exit_free_sysfs:
+	for (attr_count--; attr_count >= 0; attr_count--) {
+		sysfs_remove_file(&rmi4_data->input_dev->dev.kobj,
+				&attrs[attr_count].attr);
+	}
+
+	input_unregister_device(prox->prox_dev);
+	prox->prox_dev = NULL;
+
+exit_free_input_device:
+	if (prox->prox_dev)
+		input_free_device(prox->prox_dev);
+
+exit_free_finger_data:
+	kfree(prox->finger_data);
+
+exit_free_prox:
+	kfree(prox);
+	prox = NULL;
+
+exit:
+	return retval;
+}
+
+static void synaptics_rmi4_prox_remove(struct synaptics_rmi4_data *rmi4_data)
+{
+	unsigned char attr_count;
+
+	if (!prox)
+		goto exit;
+
+	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++) {
+		sysfs_remove_file(&rmi4_data->input_dev->dev.kobj,
+				&attrs[attr_count].attr);
+	}
+
+	input_unregister_device(prox->prox_dev);
+	kfree(prox->finger_data);
+	kfree(prox);
+	prox = NULL;
+
+exit:
+	complete(&prox_remove_complete);
+
+	return;
+}
+
+static void synaptics_rmi4_prox_reset(struct synaptics_rmi4_data *rmi4_data)
+{
+	if (!prox)
+		return;
+
+	prox_hover_finger_lift();
+
+	prox_scan_pdt();
+
+	prox_set_hover_finger_en();
+
+	prox_set_params();
+
+	return;
+}
+
+static void synaptics_rmi4_prox_reinit(struct synaptics_rmi4_data *rmi4_data)
+{
+	if (!prox)
+		return;
+
+	prox_hover_finger_lift();
+
+	prox_set_hover_finger_en();
+
+	return;
+}
+
+static void synaptics_rmi4_prox_e_suspend(struct synaptics_rmi4_data *rmi4_data)
+{
+	if (!prox)
+		return;
+
+	prox_hover_finger_lift();
+
+	return;
+}
+
+static void synaptics_rmi4_prox_suspend(struct synaptics_rmi4_data *rmi4_data)
+{
+	if (!prox)
+		return;
+
+	prox_hover_finger_lift();
+
+	return;
+}
+
+static struct synaptics_rmi4_exp_fn proximity_module = {
+	.fn_type = RMI_PROXIMITY,
+	.init = synaptics_rmi4_prox_init,
+	.remove = synaptics_rmi4_prox_remove,
+	.reset = synaptics_rmi4_prox_reset,
+	.reinit = synaptics_rmi4_prox_reinit,
+	.early_suspend = synaptics_rmi4_prox_e_suspend,
+	.suspend = synaptics_rmi4_prox_suspend,
+	.resume = NULL,
+	.late_resume = NULL,
+	.attn = synaptics_rmi4_prox_attn,
+};
+
+static int __init rmi4_proximity_module_init(void)
+{
+	synaptics_rmi4_new_function(&proximity_module, true);
+
+	return 0;
+}
+
+static void __exit rmi4_proximity_module_exit(void)
+{
+	synaptics_rmi4_new_function(&proximity_module, false);
+
+	wait_for_completion(&prox_remove_complete);
+
+	return;
+}
+
+module_init(rmi4_proximity_module_init);
+module_exit(rmi4_proximity_module_exit);
+
+MODULE_AUTHOR("Synaptics, Inc.");
+MODULE_DESCRIPTION("Synaptics DSX Proximity Module");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_rmi_dev.c b/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_rmi_dev.c
new file mode 100755
index 0000000..c7a6127
--- /dev/null
+++ b/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_rmi_dev.c
@@ -0,0 +1,781 @@
+/*
+ * Synaptics DSX touchscreen driver
+ *
+ * Copyright (C) 2012 Synaptics Incorporated
+ *
+ * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
+ * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/gpio.h>
+#include <linux/uaccess.h>
+#include <linux/cdev.h>
+#include <linux/platform_device.h>
+#include "synaptics_dsx.h"
+#include "synaptics_dsx_core.h"
+
+#define CHAR_DEVICE_NAME "rmi"
+#define DEVICE_CLASS_NAME "rmidev"
+#define SYSFS_FOLDER_NAME "rmidev"
+#define DEV_NUMBER 1
+#define REG_ADDR_LIMIT 0xFFFF
+
+static ssize_t rmidev_sysfs_data_show(struct file *data_file,
+		struct kobject *kobj, struct bin_attribute *attributes,
+		char *buf, loff_t pos, size_t count);
+
+static ssize_t rmidev_sysfs_data_store(struct file *data_file,
+		struct kobject *kobj, struct bin_attribute *attributes,
+		char *buf, loff_t pos, size_t count);
+
+static ssize_t rmidev_sysfs_open_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t rmidev_sysfs_release_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t rmidev_sysfs_attn_state_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+struct rmidev_handle {
+	dev_t dev_no;
+	struct device dev;
+	struct synaptics_rmi4_data *rmi4_data;
+	struct kobject *sysfs_dir;
+	void *data;
+	bool irq_enabled;
+};
+
+struct rmidev_data {
+	int ref_count;
+	struct cdev main_dev;
+	struct class *device_class;
+	struct mutex file_mutex;
+	struct rmidev_handle *rmi_dev;
+};
+
+static struct bin_attribute attr_data = {
+	.attr = {
+		.name = "data",
+		.mode = (00664),
+	},
+	.size = 0,
+	.read = rmidev_sysfs_data_show,
+	.write = rmidev_sysfs_data_store,
+};
+
+static struct device_attribute attrs[] = {
+	__ATTR(open, 00220,
+			synaptics_rmi4_show_error,
+			rmidev_sysfs_open_store),
+	__ATTR(release, 00220,
+			synaptics_rmi4_show_error,
+			rmidev_sysfs_release_store),
+	__ATTR(attn_state, S_IRUGO,
+			rmidev_sysfs_attn_state_show,
+			synaptics_rmi4_store_error),
+};
+
+static int rmidev_major_num;
+
+static struct class *rmidev_device_class;
+
+static struct rmidev_handle *rmidev;
+
+DECLARE_COMPLETION(rmidev_remove_complete);
+
+static irqreturn_t rmidev_sysfs_irq(int irq, void *data)
+{
+	struct synaptics_rmi4_data *rmi4_data = data;
+
+	sysfs_notify(&rmi4_data->input_dev->dev.kobj,
+			SYSFS_FOLDER_NAME, "attn_state");
+
+	return IRQ_HANDLED;
+}
+
+static int rmidev_sysfs_irq_enable(struct synaptics_rmi4_data *rmi4_data,
+		bool enable)
+{
+	int retval = 0;
+	unsigned char intr_status[MAX_INTR_REGISTERS];
+	unsigned long irq_flags = IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING;
+
+	if (enable) {
+		if (rmidev->irq_enabled)
+			return retval;
+
+		/* Clear interrupts first */
+		retval = synaptics_rmi4_reg_read(rmi4_data,
+				rmi4_data->f01_data_base_addr + 1,
+				intr_status,
+				rmi4_data->num_of_intr_regs);
+		if (retval < 0)
+			return retval;
+
+		retval = request_threaded_irq(rmi4_data->irq, NULL,
+				rmidev_sysfs_irq, irq_flags,
+				"synaptics_dsx_rmidev", rmi4_data);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to create irq thread\n",
+					__func__);
+			return retval;
+		}
+
+		rmidev->irq_enabled = true;
+	} else {
+		if (rmidev->irq_enabled) {
+			disable_irq(rmi4_data->irq);
+			free_irq(rmi4_data->irq, rmi4_data);
+			rmidev->irq_enabled = false;
+		}
+	}
+
+	return retval;
+}
+
+static ssize_t rmidev_sysfs_data_show(struct file *data_file,
+		struct kobject *kobj, struct bin_attribute *attributes,
+		char *buf, loff_t pos, size_t count)
+{
+	int retval;
+	unsigned int length = (unsigned int)count;
+	unsigned short address = (unsigned short)pos;
+	struct synaptics_rmi4_data *rmi4_data = rmidev->rmi4_data;
+
+	if (length > (REG_ADDR_LIMIT - address)) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Out of register map limit\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	if (length) {
+		retval = synaptics_rmi4_reg_read(rmi4_data,
+				address,
+				(unsigned char *)buf,
+				length);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to read data\n",
+					__func__);
+			return retval;
+		}
+	} else {
+		return -EINVAL;
+	}
+
+	return length;
+}
+
+static ssize_t rmidev_sysfs_data_store(struct file *data_file,
+		struct kobject *kobj, struct bin_attribute *attributes,
+		char *buf, loff_t pos, size_t count)
+{
+	int retval;
+	unsigned int length = (unsigned int)count;
+	unsigned short address = (unsigned short)pos;
+	struct synaptics_rmi4_data *rmi4_data = rmidev->rmi4_data;
+
+	if (length > (REG_ADDR_LIMIT - address)) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Out of register map limit\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	if (length) {
+		retval = synaptics_rmi4_reg_write(rmi4_data,
+				address,
+				(unsigned char *)buf,
+				length);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to write data\n",
+					__func__);
+			return retval;
+		}
+	} else {
+		return -EINVAL;
+	}
+
+	return length;
+}
+
+static ssize_t rmidev_sysfs_open_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int input;
+	struct synaptics_rmi4_data *rmi4_data = rmidev->rmi4_data;
+
+	if (sscanf(buf, "%u", &input) != 1)
+		return -EINVAL;
+
+	if (input != 1)
+		return -EINVAL;
+
+	rmi4_data->irq_enable(rmi4_data, false);
+	rmidev_sysfs_irq_enable(rmi4_data, true);
+
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Attention interrupt disabled\n",
+			__func__);
+
+	return count;
+}
+
+static ssize_t rmidev_sysfs_release_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int input;
+	struct synaptics_rmi4_data *rmi4_data = rmidev->rmi4_data;
+
+	if (sscanf(buf, "%u", &input) != 1)
+		return -EINVAL;
+
+	if (input != 1)
+		return -EINVAL;
+
+	rmi4_data->reset_device(rmi4_data);
+
+	rmidev_sysfs_irq_enable(rmi4_data, false);
+	rmi4_data->irq_enable(rmi4_data, true);
+
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Attention interrupt enabled\n",
+			__func__);
+
+	return count;
+}
+
+static ssize_t rmidev_sysfs_attn_state_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int attn_state;
+	struct synaptics_rmi4_data *rmi4_data = rmidev->rmi4_data;
+	const struct synaptics_dsx_board_data *bdata =
+			rmi4_data->hw_if->board_data;
+
+	attn_state = gpio_get_value(bdata->irq_gpio);
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", attn_state);
+}
+
+/*
+ * rmidev_llseek - used to set up register address
+ *
+ * @filp: file structure for seek
+ * @off: offset
+ *   if whence == SEEK_SET,
+ *     high 16 bits: page address
+ *     low 16 bits: register address
+ *   if whence == SEEK_CUR,
+ *     offset from current position
+ *   if whence == SEEK_END,
+ *     offset from end position (0xFFFF)
+ * @whence: SEEK_SET, SEEK_CUR, or SEEK_END
+ */
+static loff_t rmidev_llseek(struct file *filp, loff_t off, int whence)
+{
+	loff_t newpos;
+	struct rmidev_data *dev_data = filp->private_data;
+	struct synaptics_rmi4_data *rmi4_data = rmidev->rmi4_data;
+
+	if (IS_ERR(dev_data)) {
+		pr_err("%s: Pointer of char device data is invalid", __func__);
+		return -EBADF;
+	}
+
+	mutex_lock(&(dev_data->file_mutex));
+
+	switch (whence) {
+	case SEEK_SET:
+		newpos = off;
+		break;
+	case SEEK_CUR:
+		newpos = filp->f_pos + off;
+		break;
+	case SEEK_END:
+		newpos = REG_ADDR_LIMIT + off;
+		break;
+	default:
+		newpos = -EINVAL;
+		goto clean_up;
+	}
+
+	if (newpos < 0 || newpos > REG_ADDR_LIMIT) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: New position 0x%04x is invalid\n",
+				__func__, (unsigned int)newpos);
+		newpos = -EINVAL;
+		goto clean_up;
+	}
+
+	filp->f_pos = newpos;
+
+clean_up:
+	mutex_unlock(&(dev_data->file_mutex));
+
+	return newpos;
+}
+
+/*
+ * rmidev_read: - use to read data from rmi device
+ *
+ * @filp: file structure for read
+ * @buf: user space buffer pointer
+ * @count: number of bytes to read
+ * @f_pos: offset (starting register address)
+ */
+static ssize_t rmidev_read(struct file *filp, char __user *buf,
+		size_t count, loff_t *f_pos)
+{
+	ssize_t retval;
+	unsigned char tmpbuf[count + 1];
+	struct rmidev_data *dev_data = filp->private_data;
+
+	if (IS_ERR(dev_data)) {
+		pr_err("%s: Pointer of char device data is invalid", __func__);
+		return -EBADF;
+	}
+
+	if (count == 0)
+		return 0;
+
+	if (count > (REG_ADDR_LIMIT - *f_pos))
+		count = REG_ADDR_LIMIT - *f_pos;
+
+	mutex_lock(&(dev_data->file_mutex));
+
+	retval = synaptics_rmi4_reg_read(rmidev->rmi4_data,
+			*f_pos,
+			tmpbuf,
+			count);
+	if (retval < 0)
+		goto clean_up;
+
+	if (copy_to_user(buf, tmpbuf, count))
+		retval = -EFAULT;
+	else
+		*f_pos += retval;
+
+clean_up:
+	mutex_unlock(&(dev_data->file_mutex));
+
+	return retval;
+}
+
+/*
+ * rmidev_write: - used to write data to rmi device
+ *
+ * @filep: file structure for write
+ * @buf: user space buffer pointer
+ * @count: number of bytes to write
+ * @f_pos: offset (starting register address)
+ */
+static ssize_t rmidev_write(struct file *filp, const char __user *buf,
+		size_t count, loff_t *f_pos)
+{
+	ssize_t retval;
+	unsigned char tmpbuf[count + 1];
+	struct rmidev_data *dev_data = filp->private_data;
+
+	if (IS_ERR(dev_data)) {
+		pr_err("%s: Pointer of char device data is invalid", __func__);
+		return -EBADF;
+	}
+
+	if (count == 0)
+		return 0;
+
+	if (count > (REG_ADDR_LIMIT - *f_pos))
+		count = REG_ADDR_LIMIT - *f_pos;
+
+	if (copy_from_user(tmpbuf, buf, count))
+		return -EFAULT;
+
+	mutex_lock(&(dev_data->file_mutex));
+
+	retval = synaptics_rmi4_reg_write(rmidev->rmi4_data,
+			*f_pos,
+			tmpbuf,
+			count);
+	if (retval >= 0)
+		*f_pos += retval;
+
+	mutex_unlock(&(dev_data->file_mutex));
+
+	return retval;
+}
+
+/*
+ * rmidev_open: enable access to rmi device
+ * @inp: inode struture
+ * @filp: file structure
+ */
+static int rmidev_open(struct inode *inp, struct file *filp)
+{
+	int retval = 0;
+	struct synaptics_rmi4_data *rmi4_data = rmidev->rmi4_data;
+	struct rmidev_data *dev_data =
+			container_of(inp->i_cdev, struct rmidev_data, main_dev);
+
+	if (!dev_data)
+		return -EACCES;
+
+	filp->private_data = dev_data;
+
+	mutex_lock(&(dev_data->file_mutex));
+
+	rmi4_data->irq_enable(rmi4_data, false);
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Attention interrupt disabled\n",
+			__func__);
+
+	if (dev_data->ref_count < 1)
+		dev_data->ref_count++;
+	else
+		retval = -EACCES;
+
+	mutex_unlock(&(dev_data->file_mutex));
+
+	return retval;
+}
+
+/*
+ * rmidev_release: - release access to rmi device
+ * @inp: inode structure
+ * @filp: file structure
+ */
+static int rmidev_release(struct inode *inp, struct file *filp)
+{
+	struct synaptics_rmi4_data *rmi4_data = rmidev->rmi4_data;
+	struct rmidev_data *dev_data =
+			container_of(inp->i_cdev, struct rmidev_data, main_dev);
+
+	if (!dev_data)
+		return -EACCES;
+
+	rmi4_data->reset_device(rmi4_data);
+
+	mutex_lock(&(dev_data->file_mutex));
+
+	dev_data->ref_count--;
+	if (dev_data->ref_count < 0)
+		dev_data->ref_count = 0;
+
+	rmi4_data->irq_enable(rmi4_data, true);
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Attention interrupt enabled\n",
+			__func__);
+
+	mutex_unlock(&(dev_data->file_mutex));
+
+	return 0;
+}
+
+static const struct file_operations rmidev_fops = {
+	.owner = THIS_MODULE,
+	.llseek = rmidev_llseek,
+	.read = rmidev_read,
+	.write = rmidev_write,
+	.open = rmidev_open,
+	.release = rmidev_release,
+};
+
+static void rmidev_device_cleanup(struct rmidev_data *dev_data)
+{
+	dev_t devno;
+	struct synaptics_rmi4_data *rmi4_data = rmidev->rmi4_data;
+
+	if (dev_data) {
+		devno = dev_data->main_dev.dev;
+
+		if (dev_data->device_class)
+			device_destroy(dev_data->device_class, devno);
+
+		cdev_del(&dev_data->main_dev);
+
+		unregister_chrdev_region(devno, 1);
+
+		dev_dbg(rmi4_data->pdev->dev.parent,
+				"%s: rmidev device removed\n",
+				__func__);
+	}
+
+	return;
+}
+
+static char *rmi_char_devnode(struct device *dev, mode_t *mode)
+{
+	if (!mode)
+		return NULL;
+
+	*mode = (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);
+
+	return kasprintf(GFP_KERNEL, "rmi/%s", dev_name(dev));
+}
+
+static int rmidev_create_device_class(void)
+{
+	rmidev_device_class = class_create(THIS_MODULE, DEVICE_CLASS_NAME);
+
+	if (IS_ERR(rmidev_device_class)) {
+		pr_err("%s: Failed to create /dev/%s\n",
+				__func__, CHAR_DEVICE_NAME);
+		return -ENODEV;
+	}
+
+	rmidev_device_class->devnode = rmi_char_devnode;
+
+	return 0;
+}
+
+static int rmidev_init_device(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	dev_t dev_no;
+	unsigned char attr_count;
+	struct rmidev_data *dev_data;
+	struct device *device_ptr;
+	const struct synaptics_dsx_board_data *bdata =
+				rmi4_data->hw_if->board_data;
+
+	rmidev = kzalloc(sizeof(*rmidev), GFP_KERNEL);
+	if (!rmidev) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to alloc mem for rmidev\n",
+				__func__);
+		retval = -ENOMEM;
+		goto err_rmidev;
+	}
+
+	rmidev->rmi4_data = rmi4_data;
+
+	retval = rmidev_create_device_class();
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to create device class\n",
+				__func__);
+		goto err_device_class;
+	}
+
+	if (rmidev_major_num) {
+		dev_no = MKDEV(rmidev_major_num, DEV_NUMBER);
+		retval = register_chrdev_region(dev_no, 1, CHAR_DEVICE_NAME);
+	} else {
+		retval = alloc_chrdev_region(&dev_no, 0, 1, CHAR_DEVICE_NAME);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to allocate char device region\n",
+					__func__);
+			goto err_device_region;
+		}
+
+		rmidev_major_num = MAJOR(dev_no);
+		dev_dbg(rmi4_data->pdev->dev.parent,
+				"%s: Major number of rmidev = %d\n",
+				__func__, rmidev_major_num);
+	}
+
+	dev_data = kzalloc(sizeof(*dev_data), GFP_KERNEL);
+	if (!dev_data) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to alloc mem for dev_data\n",
+				__func__);
+		retval = -ENOMEM;
+		goto err_dev_data;
+	}
+
+	mutex_init(&dev_data->file_mutex);
+	dev_data->rmi_dev = rmidev;
+	rmidev->data = dev_data;
+
+	cdev_init(&dev_data->main_dev, &rmidev_fops);
+
+	retval = cdev_add(&dev_data->main_dev, dev_no, 1);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to add rmi char device\n",
+				__func__);
+		goto err_char_device;
+	}
+
+	dev_set_name(&rmidev->dev, "rmidev%d", MINOR(dev_no));
+	dev_data->device_class = rmidev_device_class;
+
+	device_ptr = device_create(dev_data->device_class, NULL, dev_no,
+			NULL, CHAR_DEVICE_NAME"%d", MINOR(dev_no));
+	if (IS_ERR(device_ptr)) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to create rmi char device\n",
+				__func__);
+		retval = -ENODEV;
+		goto err_char_device;
+	}
+
+	retval = gpio_export(bdata->irq_gpio, false);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to export attention gpio\n",
+				__func__);
+	} else {
+		retval = gpio_export_link(&(rmi4_data->input_dev->dev),
+				"attn", bdata->irq_gpio);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s Failed to create gpio symlink\n",
+					__func__);
+		} else {
+			dev_dbg(rmi4_data->pdev->dev.parent,
+					"%s: Exported attention gpio %d\n",
+					__func__, bdata->irq_gpio);
+		}
+	}
+
+	rmidev->sysfs_dir = kobject_create_and_add(SYSFS_FOLDER_NAME,
+			&rmi4_data->input_dev->dev.kobj);
+	if (!rmidev->sysfs_dir) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to create sysfs directory\n",
+				__func__);
+		retval = -ENODEV;
+		goto err_sysfs_dir;
+	}
+
+	retval = sysfs_create_bin_file(rmidev->sysfs_dir,
+			&attr_data);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to create sysfs bin file\n",
+				__func__);
+		goto err_sysfs_bin;
+	}
+
+	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++) {
+		retval = sysfs_create_file(rmidev->sysfs_dir,
+				&attrs[attr_count].attr);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to create sysfs attributes\n",
+					__func__);
+			retval = -ENODEV;
+			goto err_sysfs_attrs;
+		}
+	}
+
+	return 0;
+
+err_sysfs_attrs:
+	for (attr_count--; attr_count >= 0; attr_count--)
+		sysfs_remove_file(rmidev->sysfs_dir, &attrs[attr_count].attr);
+
+	sysfs_remove_bin_file(rmidev->sysfs_dir, &attr_data);
+
+err_sysfs_bin:
+	kobject_put(rmidev->sysfs_dir);
+
+err_sysfs_dir:
+err_char_device:
+	rmidev_device_cleanup(dev_data);
+	kfree(dev_data);
+
+err_dev_data:
+	unregister_chrdev_region(dev_no, 1);
+
+err_device_region:
+	class_destroy(rmidev_device_class);
+
+err_device_class:
+	kfree(rmidev);
+	rmidev = NULL;
+
+err_rmidev:
+	return retval;
+}
+
+static void rmidev_remove_device(struct synaptics_rmi4_data *rmi4_data)
+{
+	unsigned char attr_count;
+	struct rmidev_data *dev_data;
+
+	if (!rmidev)
+		goto exit;
+
+	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++)
+		sysfs_remove_file(rmidev->sysfs_dir, &attrs[attr_count].attr);
+
+	sysfs_remove_bin_file(rmidev->sysfs_dir, &attr_data);
+
+	kobject_put(rmidev->sysfs_dir);
+
+	dev_data = rmidev->data;
+	if (dev_data) {
+		rmidev_device_cleanup(dev_data);
+		kfree(dev_data);
+	}
+
+	unregister_chrdev_region(rmidev->dev_no, 1);
+
+	class_destroy(rmidev_device_class);
+
+	kfree(rmidev);
+	rmidev = NULL;
+
+exit:
+	complete(&rmidev_remove_complete);
+
+	return;
+}
+
+static struct synaptics_rmi4_exp_fn rmidev_module = {
+	.fn_type = RMI_DEV,
+	.init = rmidev_init_device,
+	.remove = rmidev_remove_device,
+	.reset = NULL,
+	.reinit = NULL,
+	.early_suspend = NULL,
+	.suspend = NULL,
+	.resume = NULL,
+	.late_resume = NULL,
+	.attn = NULL,
+};
+
+static int __init rmidev_module_init(void)
+{
+	synaptics_rmi4_new_function(&rmidev_module, true);
+
+	return 0;
+}
+
+static void __exit rmidev_module_exit(void)
+{
+	synaptics_rmi4_new_function(&rmidev_module, false);
+
+	wait_for_completion(&rmidev_remove_complete);
+
+	return;
+}
+
+module_init(rmidev_module_init);
+module_exit(rmidev_module_exit);
+
+MODULE_AUTHOR("Synaptics, Inc.");
+MODULE_DESCRIPTION("Synaptics DSX RMI Dev Module");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_spi.c b/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_spi.c
new file mode 100755
index 0000000..a1a9526
--- /dev/null
+++ b/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_spi.c
@@ -0,0 +1,335 @@
+/*
+ * Synaptics DSX touchscreen driver
+ *
+ * Copyright (C) 2012 Synaptics Incorporated
+ *
+ * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
+ * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include "synaptics_dsx.h"
+#include "synaptics_dsx_core.h"
+
+#define SPI_READ 0x80
+#define SPI_WRITE 0x00
+
+static int synaptics_rmi4_spi_set_page(struct synaptics_rmi4_data *rmi4_data,
+		unsigned short addr)
+{
+	int retval;
+	unsigned int index;
+	unsigned int xfer_count = PAGE_SELECT_LEN + 1;
+	unsigned char txbuf[xfer_count];
+	unsigned char page;
+	struct spi_message msg;
+	struct spi_transfer xfers[xfer_count];
+	struct spi_device *spi = to_spi_device(rmi4_data->pdev->dev.parent);
+	const struct synaptics_dsx_board_data *bdata =
+			rmi4_data->hw_if->board_data;
+
+	page = ((addr >> 8) & ~MASK_7BIT);
+	if (page != rmi4_data->current_page) {
+		spi_message_init(&msg);
+
+		txbuf[0] = SPI_WRITE;
+		txbuf[1] = MASK_8BIT;
+		txbuf[2] = page;
+
+		for (index = 0; index < xfer_count; index++) {
+			memset(&xfers[index], 0, sizeof(struct spi_transfer));
+			xfers[index].len = 1;
+			xfers[index].delay_usecs = bdata->byte_delay_us;
+			xfers[index].tx_buf = &txbuf[index];
+			spi_message_add_tail(&xfers[index], &msg);
+		}
+
+		if (bdata->block_delay_us)
+			xfers[index - 1].delay_usecs = bdata->block_delay_us;
+
+		retval = spi_sync(spi, &msg);
+		if (retval == 0) {
+			rmi4_data->current_page = page;
+			retval = PAGE_SELECT_LEN;
+		} else {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to complete SPI transfer, error = %d\n",
+					__func__, retval);
+		}
+	} else {
+		retval = PAGE_SELECT_LEN;
+	}
+
+	return retval;
+}
+
+static int synaptics_rmi4_spi_read(struct synaptics_rmi4_data *rmi4_data,
+		unsigned short addr, unsigned char *data, unsigned short length)
+{
+	int retval;
+	unsigned int index;
+	unsigned int xfer_count = length + ADDRESS_WORD_LEN;
+	unsigned char txbuf[ADDRESS_WORD_LEN];
+	unsigned char *rxbuf = NULL;
+	struct spi_message msg;
+	struct spi_transfer *xfers = NULL;
+	struct spi_device *spi = to_spi_device(rmi4_data->pdev->dev.parent);
+	const struct synaptics_dsx_board_data *bdata =
+			rmi4_data->hw_if->board_data;
+
+	spi_message_init(&msg);
+
+	xfers = kcalloc(xfer_count, sizeof(struct spi_transfer), GFP_KERNEL);
+	if (!xfers) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to allocate memory for xfers\n",
+				__func__);
+		retval = -ENOMEM;
+		goto exit;
+	}
+
+	txbuf[0] = (addr >> 8) | SPI_READ;
+	txbuf[1] = addr & MASK_8BIT;
+
+	rxbuf = kmalloc(length, GFP_KERNEL);
+	if (!rxbuf) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to allocate memory for rxbuf\n",
+				__func__);
+		retval = -ENOMEM;
+		goto exit;
+	}
+
+	mutex_lock(&rmi4_data->rmi4_io_ctrl_mutex);
+
+	retval = synaptics_rmi4_spi_set_page(rmi4_data, addr);
+	if (retval != PAGE_SELECT_LEN) {
+		retval = -EIO;
+		goto exit;
+	}
+
+	for (index = 0; index < xfer_count; index++) {
+		xfers[index].len = 1;
+		xfers[index].delay_usecs = bdata->byte_delay_us;
+		if (index < ADDRESS_WORD_LEN)
+			xfers[index].tx_buf = &txbuf[index];
+		else
+			xfers[index].rx_buf = &rxbuf[index - ADDRESS_WORD_LEN];
+		spi_message_add_tail(&xfers[index], &msg);
+	}
+
+	if (bdata->block_delay_us)
+		xfers[index - 1].delay_usecs = bdata->block_delay_us;
+
+	retval = spi_sync(spi, &msg);
+	if (retval == 0) {
+		retval = length;
+		memcpy(data, rxbuf, length);
+	} else {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to complete SPI transfer, error = %d\n",
+				__func__, retval);
+	}
+
+	mutex_unlock(&rmi4_data->rmi4_io_ctrl_mutex);
+
+exit:
+	kfree(rxbuf);
+	kfree(xfers);
+
+	return retval;
+}
+
+static int synaptics_rmi4_spi_write(struct synaptics_rmi4_data *rmi4_data,
+		unsigned short addr, unsigned char *data, unsigned short length)
+{
+	int retval;
+	unsigned int index;
+	unsigned int xfer_count = length + ADDRESS_WORD_LEN;
+	unsigned char *txbuf = NULL;
+	struct spi_message msg;
+	struct spi_transfer *xfers = NULL;
+	struct spi_device *spi = to_spi_device(rmi4_data->pdev->dev.parent);
+	const struct synaptics_dsx_board_data *bdata =
+			rmi4_data->hw_if->board_data;
+
+	spi_message_init(&msg);
+
+	xfers = kcalloc(xfer_count, sizeof(struct spi_transfer), GFP_KERNEL);
+	if (!xfers) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to allocate memory for xfers\n",
+				__func__);
+		retval = -ENOMEM;
+		goto exit;
+	}
+
+	txbuf = kmalloc(xfer_count, GFP_KERNEL);
+	if (!txbuf) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to allocate memory for txbuf\n",
+				__func__);
+		retval = -ENOMEM;
+		goto exit;
+	}
+
+	txbuf[0] = (addr >> 8) & ~SPI_READ;
+	txbuf[1] = addr & MASK_8BIT;
+	memcpy(&txbuf[ADDRESS_WORD_LEN], data, length);
+
+	mutex_lock(&rmi4_data->rmi4_io_ctrl_mutex);
+
+	retval = synaptics_rmi4_spi_set_page(rmi4_data, addr);
+	if (retval != PAGE_SELECT_LEN) {
+		retval = -EIO;
+		goto exit;
+	}
+
+	for (index = 0; index < xfer_count; index++) {
+		xfers[index].len = 1;
+		xfers[index].delay_usecs = bdata->byte_delay_us;
+		xfers[index].tx_buf = &txbuf[index];
+		spi_message_add_tail(&xfers[index], &msg);
+	}
+
+	if (bdata->block_delay_us)
+		xfers[index - 1].delay_usecs = bdata->block_delay_us;
+
+	retval = spi_sync(spi, &msg);
+	if (retval == 0) {
+		retval = length;
+	} else {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to complete SPI transfer, error = %d\n",
+				__func__, retval);
+	}
+
+	mutex_unlock(&rmi4_data->rmi4_io_ctrl_mutex);
+
+exit:
+	kfree(txbuf);
+	kfree(xfers);
+
+	return retval;
+}
+
+static struct synaptics_dsx_bus_access bus_access = {
+	.type = BUS_SPI,
+	.read = synaptics_rmi4_spi_read,
+	.write = synaptics_rmi4_spi_write,
+};
+
+static struct synaptics_dsx_hw_interface hw_if;
+
+static struct platform_device *synaptics_dsx_spi_device;
+
+static void synaptics_rmi4_spi_dev_release(struct device *dev)
+{
+	kfree(synaptics_dsx_spi_device);
+
+	return;
+}
+
+static int synaptics_rmi4_spi_probe(struct spi_device *spi)
+{
+	int retval;
+
+	if (spi->master->flags & SPI_MASTER_HALF_DUPLEX) {
+		dev_err(&spi->dev,
+				"%s: Full duplex not supported by host\n",
+				__func__);
+		return -EIO;
+	}
+
+	synaptics_dsx_spi_device = kzalloc(
+			sizeof(struct platform_device),
+			GFP_KERNEL);
+	if (!synaptics_dsx_spi_device) {
+		dev_err(&spi->dev,
+				"%s: Failed to allocate memory for synaptics_dsx_spi_device\n",
+				__func__);
+		return -ENOMEM;
+	}
+
+	spi->bits_per_word = 8;
+	spi->mode = SPI_MODE_3;
+
+	retval = spi_setup(spi);
+	if (retval < 0) {
+		dev_err(&spi->dev,
+				"%s: Failed to perform SPI setup\n",
+				__func__);
+		return retval;
+	}
+
+	hw_if.board_data = spi->dev.platform_data;
+	hw_if.bus_access = &bus_access;
+
+	synaptics_dsx_spi_device->name = PLATFORM_DRIVER_NAME;
+	synaptics_dsx_spi_device->id = 0;
+	synaptics_dsx_spi_device->num_resources = 0;
+	synaptics_dsx_spi_device->dev.parent = &spi->dev;
+	synaptics_dsx_spi_device->dev.platform_data = &hw_if;
+	synaptics_dsx_spi_device->dev.release = synaptics_rmi4_spi_dev_release;
+
+	retval = platform_device_register(synaptics_dsx_spi_device);
+	if (retval) {
+		dev_err(&spi->dev,
+				"%s: Failed to register platform device\n",
+				__func__);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int synaptics_rmi4_spi_remove(struct spi_device *spi)
+{
+	platform_device_unregister(synaptics_dsx_spi_device);
+
+	return 0;
+}
+
+static struct spi_driver synaptics_rmi4_spi_driver = {
+	.driver = {
+		.name = SPI_DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+	.probe = synaptics_rmi4_spi_probe,
+	.remove = __devexit_p(synaptics_rmi4_spi_remove),
+};
+
+
+int synaptics_rmi4_bus_init(void)
+{
+	return spi_register_driver(&synaptics_rmi4_spi_driver);
+}
+EXPORT_SYMBOL(synaptics_rmi4_bus_init);
+
+void synaptics_rmi4_bus_exit(void)
+{
+	spi_unregister_driver(&synaptics_rmi4_spi_driver);
+
+	return;
+}
+EXPORT_SYMBOL(synaptics_rmi4_bus_exit);
+
+MODULE_AUTHOR("Synaptics, Inc.");
+MODULE_DESCRIPTION("Synaptics DSX SPI Bus Support Module");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_test_reporting.c b/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_test_reporting.c
new file mode 100755
index 0000000..b885bfe
--- /dev/null
+++ b/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_test_reporting.c
@@ -0,0 +1,3530 @@
+/*
+ * Synaptics DSX touchscreen driver
+ *
+ * Copyright (C) 2012 Synaptics Incorporated
+ *
+ * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
+ * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/ctype.h>
+#include <linux/hrtimer.h>
+#include <linux/platform_device.h>
+#include "synaptics_dsx.h"
+#include "synaptics_dsx_core.h"
+
+#define WATCHDOG_HRTIMER
+#define WATCHDOG_TIMEOUT_S 2
+#define FORCE_TIMEOUT_100MS 10
+#define STATUS_WORK_INTERVAL 20 /* ms */
+
+/*
+#define RAW_HEX
+#define HUMAN_READABLE
+*/
+
+#define STATUS_IDLE 0
+#define STATUS_BUSY 1
+
+#define DATA_REPORT_INDEX_OFFSET 1
+#define DATA_REPORT_DATA_OFFSET 3
+
+#define SENSOR_RX_MAPPING_OFFSET 1
+#define SENSOR_TX_MAPPING_OFFSET 2
+
+#define COMMAND_GET_REPORT 1
+#define COMMAND_FORCE_CAL 2
+#define COMMAND_FORCE_UPDATE 4
+
+#define CONTROL_42_SIZE 2
+#define CONTROL_43_54_SIZE 13
+#define CONTROL_55_56_SIZE 2
+#define CONTROL_58_SIZE 1
+#define CONTROL_59_SIZE 2
+#define CONTROL_60_62_SIZE 3
+#define CONTROL_63_SIZE 1
+#define CONTROL_64_67_SIZE 4
+#define CONTROL_68_73_SIZE 8
+#define CONTROL_74_SIZE 2
+#define CONTROL_76_SIZE 1
+#define CONTROL_77_78_SIZE 2
+#define CONTROL_79_83_SIZE 5
+#define CONTROL_84_85_SIZE 2
+#define CONTROL_86_SIZE 1
+#define CONTROL_87_SIZE 1
+
+#define HIGH_RESISTANCE_DATA_SIZE 6
+#define FULL_RAW_CAP_MIN_MAX_DATA_SIZE 4
+#define TREX_DATA_SIZE 7
+
+#define NO_AUTO_CAL_MASK 0x01
+
+#define concat(a, b) a##b
+
+#define GROUP(_attrs) {\
+	.attrs = _attrs,\
+}
+
+#define attrify(propname) (&dev_attr_##propname.attr)
+
+#define show_prototype(propname)\
+static ssize_t concat(synaptics_rmi4_f54, _##propname##_show)(\
+		struct device *dev,\
+		struct device_attribute *attr,\
+		char *buf);\
+\
+struct device_attribute dev_attr_##propname =\
+		__ATTR(propname, S_IRUGO,\
+		concat(synaptics_rmi4_f54, _##propname##_show),\
+		synaptics_rmi4_store_error);
+
+#define store_prototype(propname)\
+static ssize_t concat(synaptics_rmi4_f54, _##propname##_store)(\
+		struct device *dev,\
+		struct device_attribute *attr,\
+		const char *buf, size_t count);\
+\
+struct device_attribute dev_attr_##propname =\
+		__ATTR(propname, S_IWUSR | S_IWGRP,\
+		synaptics_rmi4_show_error,\
+		concat(synaptics_rmi4_f54, _##propname##_store));
+
+#define show_store_prototype(propname)\
+static ssize_t concat(synaptics_rmi4_f54, _##propname##_show)(\
+		struct device *dev,\
+		struct device_attribute *attr,\
+		char *buf);\
+\
+static ssize_t concat(synaptics_rmi4_f54, _##propname##_store)(\
+		struct device *dev,\
+		struct device_attribute *attr,\
+		const char *buf, size_t count);\
+\
+struct device_attribute dev_attr_##propname =\
+		__ATTR(propname, (S_IRUGO | S_IWUSR | S_IWGRP),\
+		concat(synaptics_rmi4_f54, _##propname##_show),\
+		concat(synaptics_rmi4_f54, _##propname##_store));
+
+#define simple_show_func(rtype, propname, fmt)\
+static ssize_t concat(synaptics_rmi4_f54, _##propname##_show)(\
+		struct device *dev,\
+		struct device_attribute *attr,\
+		char *buf)\
+{\
+	return snprintf(buf, PAGE_SIZE, fmt, f54->rtype.propname);\
+} \
+
+#define simple_show_func_unsigned(rtype, propname)\
+simple_show_func(rtype, propname, "%u\n")
+
+#define show_func(rtype, rgrp, propname, fmt)\
+static ssize_t concat(synaptics_rmi4_f54, _##propname##_show)(\
+		struct device *dev,\
+		struct device_attribute *attr,\
+		char *buf)\
+{\
+	int retval;\
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;\
+\
+	mutex_lock(&f54->rtype##_mutex);\
+\
+	retval = synaptics_rmi4_reg_read(rmi4_data,\
+			f54->rtype.rgrp->address,\
+			f54->rtype.rgrp->data,\
+			sizeof(f54->rtype.rgrp->data));\
+	mutex_unlock(&f54->rtype##_mutex);\
+	if (retval < 0) {\
+		dev_err(rmi4_data->pdev->dev.parent,\
+				"%s: Failed to read " #rtype\
+				" " #rgrp "\n",\
+				__func__);\
+		return retval;\
+	} \
+\
+	return snprintf(buf, PAGE_SIZE, fmt,\
+			f54->rtype.rgrp->propname);\
+} \
+
+#define show_store_func(rtype, rgrp, propname, fmt)\
+show_func(rtype, rgrp, propname, fmt)\
+\
+static ssize_t concat(synaptics_rmi4_f54, _##propname##_store)(\
+		struct device *dev,\
+		struct device_attribute *attr,\
+		const char *buf, size_t count)\
+{\
+	int retval;\
+	unsigned long setting;\
+	unsigned long o_setting;\
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;\
+\
+	retval = sstrtoul(buf, 10, &setting);\
+	if (retval)\
+		return retval;\
+\
+	mutex_lock(&f54->rtype##_mutex);\
+	retval = synaptics_rmi4_reg_read(rmi4_data,\
+			f54->rtype.rgrp->address,\
+			f54->rtype.rgrp->data,\
+			sizeof(f54->rtype.rgrp->data));\
+	if (retval < 0) {\
+		mutex_unlock(&f54->rtype##_mutex);\
+		dev_err(rmi4_data->pdev->dev.parent,\
+				"%s: Failed to read " #rtype\
+				" " #rgrp "\n",\
+				__func__);\
+		return retval;\
+	} \
+\
+	if (f54->rtype.rgrp->propname == setting) {\
+		mutex_unlock(&f54->rtype##_mutex);\
+		return count;\
+	} \
+\
+	o_setting = f54->rtype.rgrp->propname;\
+	f54->rtype.rgrp->propname = setting;\
+\
+	retval = synaptics_rmi4_reg_write(rmi4_data,\
+			f54->rtype.rgrp->address,\
+			f54->rtype.rgrp->data,\
+			sizeof(f54->rtype.rgrp->data));\
+	if (retval < 0) {\
+		dev_err(rmi4_data->pdev->dev.parent,\
+				"%s: Failed to write " #rtype\
+				" " #rgrp "\n",\
+				__func__);\
+		f54->rtype.rgrp->propname = o_setting;\
+		mutex_unlock(&f54->rtype##_mutex);\
+		return retval;\
+	} \
+\
+	mutex_unlock(&f54->rtype##_mutex);\
+	return count;\
+} \
+
+#define show_store_func_unsigned(rtype, rgrp, propname)\
+show_store_func(rtype, rgrp, propname, "%u\n")
+
+#define show_replicated_func(rtype, rgrp, propname, fmt)\
+static ssize_t concat(synaptics_rmi4_f54, _##propname##_show)(\
+		struct device *dev,\
+		struct device_attribute *attr,\
+		char *buf)\
+{\
+	int retval;\
+	int size = 0;\
+	unsigned char ii;\
+	unsigned char length;\
+	unsigned char *temp;\
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;\
+\
+	mutex_lock(&f54->rtype##_mutex);\
+\
+	length = f54->rtype.rgrp->length;\
+\
+	retval = synaptics_rmi4_reg_read(rmi4_data,\
+			f54->rtype.rgrp->address,\
+			(unsigned char *)f54->rtype.rgrp->data,\
+			length);\
+	mutex_unlock(&f54->rtype##_mutex);\
+	if (retval < 0) {\
+		dev_dbg(rmi4_data->pdev->dev.parent,\
+				"%s: Failed to read " #rtype\
+				" " #rgrp "\n",\
+				__func__);\
+	} \
+\
+	temp = buf;\
+\
+	for (ii = 0; ii < length; ii++) {\
+		retval = snprintf(temp, PAGE_SIZE - size, fmt " ",\
+				f54->rtype.rgrp->data[ii].propname);\
+		if (retval < 0) {\
+			dev_err(rmi4_data->pdev->dev.parent,\
+					"%s: Faild to write output\n",\
+					__func__);\
+			return retval;\
+		} \
+		size += retval;\
+		temp += retval;\
+	} \
+\
+	retval = snprintf(temp, PAGE_SIZE - size, "\n");\
+	if (retval < 0) {\
+		dev_err(rmi4_data->pdev->dev.parent,\
+				"%s: Faild to write null terminator\n",\
+				__func__);\
+		return retval;\
+	} \
+\
+	return size + retval;\
+} \
+
+#define show_replicated_func_unsigned(rtype, rgrp, propname)\
+show_replicated_func(rtype, rgrp, propname, "%u")
+
+#define show_store_replicated_func(rtype, rgrp, propname, fmt)\
+show_replicated_func(rtype, rgrp, propname, fmt)\
+\
+static ssize_t concat(synaptics_rmi4_f54, _##propname##_store)(\
+		struct device *dev,\
+		struct device_attribute *attr,\
+		const char *buf, size_t count)\
+{\
+	int retval;\
+	unsigned int setting;\
+	unsigned char ii;\
+	unsigned char length;\
+	const unsigned char *temp;\
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;\
+\
+	mutex_lock(&f54->rtype##_mutex);\
+\
+	length = f54->rtype.rgrp->length;\
+\
+	retval = synaptics_rmi4_reg_read(rmi4_data,\
+			f54->rtype.rgrp->address,\
+			(unsigned char *)f54->rtype.rgrp->data,\
+			length);\
+	if (retval < 0) {\
+		dev_dbg(rmi4_data->pdev->dev.parent,\
+				"%s: Failed to read " #rtype\
+				" " #rgrp "\n",\
+				__func__);\
+	} \
+\
+	temp = buf;\
+\
+	for (ii = 0; ii < length; ii++) {\
+		if (sscanf(temp, fmt, &setting) == 1) {\
+			f54->rtype.rgrp->data[ii].propname = setting;\
+		} else {\
+			retval = synaptics_rmi4_reg_read(rmi4_data,\
+					f54->rtype.rgrp->address,\
+					(unsigned char *)f54->rtype.rgrp->data,\
+					length);\
+			mutex_unlock(&f54->rtype##_mutex);\
+			return -EINVAL;\
+		} \
+\
+		while (*temp != 0) {\
+			temp++;\
+			if (isspace(*(temp - 1)) && !isspace(*temp))\
+				break;\
+		} \
+	} \
+\
+	retval = synaptics_rmi4_reg_write(rmi4_data,\
+			f54->rtype.rgrp->address,\
+			(unsigned char *)f54->rtype.rgrp->data,\
+			length);\
+	mutex_unlock(&f54->rtype##_mutex);\
+	if (retval < 0) {\
+		dev_err(rmi4_data->pdev->dev.parent,\
+				"%s: Failed to write " #rtype\
+				" " #rgrp "\n",\
+				__func__);\
+		return retval;\
+	} \
+\
+	return count;\
+} \
+
+#define show_store_replicated_func_unsigned(rtype, rgrp, propname)\
+show_store_replicated_func(rtype, rgrp, propname, "%u")
+
+enum f54_report_types {
+	F54_8BIT_IMAGE = 1,
+	F54_16BIT_IMAGE = 2,
+	F54_RAW_16BIT_IMAGE = 3,
+	F54_HIGH_RESISTANCE = 4,
+	F54_TX_TO_TX_SHORT = 5,
+	F54_RX_TO_RX1 = 7,
+	F54_TRUE_BASELINE = 9,
+	F54_FULL_RAW_CAP_MIN_MAX = 13,
+	F54_RX_OPENS1 = 14,
+	F54_TX_OPEN = 15,
+	F54_TX_TO_GROUND = 16,
+	F54_RX_TO_RX2 = 17,
+	F54_RX_OPENS2 = 18,
+	F54_FULL_RAW_CAP = 19,
+	F54_FULL_RAW_CAP_RX_COUPLING_COMP = 20,
+	F54_SENSOR_SPEED = 22,
+	F54_ADC_RANGE = 23,
+	F54_TREX_OPENS = 24,
+	F54_TREX_TO_GND = 25,
+	F54_TREX_SHORTS = 26,
+	INVALID_REPORT_TYPE = -1,
+};
+
+struct f54_query {
+	union {
+		struct {
+			/* query 0 */
+			unsigned char num_of_rx_electrodes;
+
+			/* query 1 */
+			unsigned char num_of_tx_electrodes;
+
+			/* query 2 */
+			unsigned char f54_query2_b0__1:2;
+			unsigned char has_baseline:1;
+			unsigned char has_image8:1;
+			unsigned char f54_query2_b4__5:2;
+			unsigned char has_image16:1;
+			unsigned char f54_query2_b7:1;
+
+			/* queries 3.0 and 3.1 */
+			unsigned short clock_rate;
+
+			/* query 4 */
+			unsigned char touch_controller_family;
+
+			/* query 5 */
+			unsigned char has_pixel_touch_threshold_adjustment:1;
+			unsigned char f54_query5_b1__7:7;
+
+			/* query 6 */
+			unsigned char has_sensor_assignment:1;
+			unsigned char has_interference_metric:1;
+			unsigned char has_sense_frequency_control:1;
+			unsigned char has_firmware_noise_mitigation:1;
+			unsigned char has_ctrl11:1;
+			unsigned char has_two_byte_report_rate:1;
+			unsigned char has_one_byte_report_rate:1;
+			unsigned char has_relaxation_control:1;
+
+			/* query 7 */
+			unsigned char curve_compensation_mode:2;
+			unsigned char f54_query7_b2__7:6;
+
+			/* query 8 */
+			unsigned char f54_query8_b0:1;
+			unsigned char has_iir_filter:1;
+			unsigned char has_cmn_removal:1;
+			unsigned char has_cmn_maximum:1;
+			unsigned char has_touch_hysteresis:1;
+			unsigned char has_edge_compensation:1;
+			unsigned char has_per_frequency_noise_control:1;
+			unsigned char has_enhanced_stretch:1;
+
+			/* query 9 */
+			unsigned char has_force_fast_relaxation:1;
+			unsigned char has_multi_metric_state_machine:1;
+			unsigned char has_signal_clarity:1;
+			unsigned char has_variance_metric:1;
+			unsigned char has_0d_relaxation_control:1;
+			unsigned char has_0d_acquisition_control:1;
+			unsigned char has_status:1;
+			unsigned char has_slew_metric:1;
+
+			/* query 10 */
+			unsigned char has_h_blank:1;
+			unsigned char has_v_blank:1;
+			unsigned char has_long_h_blank:1;
+			unsigned char has_startup_fast_relaxation:1;
+			unsigned char has_esd_control:1;
+			unsigned char has_noise_mitigation2:1;
+			unsigned char has_noise_state:1;
+			unsigned char has_energy_ratio_relaxation:1;
+
+			/* query 11 */
+			unsigned char has_excessive_noise_reporting:1;
+			unsigned char has_slew_option:1;
+			unsigned char has_two_overhead_bursts:1;
+			unsigned char has_query13:1;
+			unsigned char has_one_overhead_burst:1;
+			unsigned char f54_query11_b5:1;
+			unsigned char has_ctrl88:1;
+			unsigned char has_query15:1;
+
+			/* query 12 */
+			unsigned char number_of_sensing_frequencies:4;
+			unsigned char f54_query12_b4__7:4;
+
+			/* query 13 */
+			unsigned char has_ctrl86:1;
+			unsigned char has_ctrl87:1;
+			unsigned char has_ctrl87_sub0:1;
+			unsigned char has_ctrl87_sub1:1;
+			unsigned char has_ctrl87_sub2:1;
+			unsigned char has_cidim:1;
+			unsigned char has_noise_mitigation_enhancement:1;
+			unsigned char has_rail_im:1;
+		} __packed;
+		unsigned char data[15];
+	};
+};
+
+struct f54_control_0 {
+	union {
+		struct {
+			unsigned char no_relax:1;
+			unsigned char no_scan:1;
+			unsigned char force_fast_relaxation:1;
+			unsigned char startup_fast_relaxation:1;
+			unsigned char gesture_cancels_sfr:1;
+			unsigned char enable_energy_ratio_relaxation:1;
+			unsigned char excessive_noise_attn_enable:1;
+			unsigned char f54_control0_b7:1;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_1 {
+	union {
+		struct {
+			unsigned char bursts_per_cluster:4;
+			unsigned char f54_ctrl1_b4__7:4;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_2 {
+	union {
+		struct {
+			unsigned short saturation_cap;
+		} __packed;
+		struct {
+			unsigned char data[2];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_3 {
+	union {
+		struct {
+			unsigned char pixel_touch_threshold;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_4__6 {
+	union {
+		struct {
+			/* control 4 */
+			unsigned char rx_feedback_cap:2;
+			unsigned char bias_current:2;
+			unsigned char f54_ctrl4_b4__7:4;
+
+			/* control 5 */
+			unsigned char low_ref_cap:2;
+			unsigned char low_ref_feedback_cap:2;
+			unsigned char low_ref_polarity:1;
+			unsigned char f54_ctrl5_b5__7:3;
+
+			/* control 6 */
+			unsigned char high_ref_cap:2;
+			unsigned char high_ref_feedback_cap:2;
+			unsigned char high_ref_polarity:1;
+			unsigned char f54_ctrl6_b5__7:3;
+		} __packed;
+		struct {
+			unsigned char data[3];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_7 {
+	union {
+		struct {
+			unsigned char cbc_cap:3;
+			unsigned char cbc_polarity:1;
+			unsigned char cbc_tx_carrier_selection:1;
+			unsigned char f54_ctrl7_b5__7:3;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_8__9 {
+	union {
+		struct {
+			/* control 8 */
+			unsigned short integration_duration:10;
+			unsigned short f54_ctrl8_b10__15:6;
+
+			/* control 9 */
+			unsigned char reset_duration;
+		} __packed;
+		struct {
+			unsigned char data[3];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_10 {
+	union {
+		struct {
+			unsigned char noise_sensing_bursts_per_image:4;
+			unsigned char f54_ctrl10_b4__7:4;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_11 {
+	union {
+		struct {
+			unsigned short f54_ctrl11;
+		} __packed;
+		struct {
+			unsigned char data[2];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_12__13 {
+	union {
+		struct {
+			/* control 12 */
+			unsigned char slow_relaxation_rate;
+
+			/* control 13 */
+			unsigned char fast_relaxation_rate;
+		} __packed;
+		struct {
+			unsigned char data[2];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_14 {
+	union {
+		struct {
+			unsigned char rxs_on_xaxis:1;
+			unsigned char curve_comp_on_txs:1;
+			unsigned char f54_ctrl14_b2__7:6;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_15n {
+	unsigned char sensor_rx_assignment;
+};
+
+struct f54_control_15 {
+	struct f54_control_15n *data;
+	unsigned short address;
+	unsigned char length;
+};
+
+struct f54_control_16n {
+	unsigned char sensor_tx_assignment;
+};
+
+struct f54_control_16 {
+	struct f54_control_16n *data;
+	unsigned short address;
+	unsigned char length;
+};
+
+struct f54_control_17n {
+	unsigned char burst_count_b8__10:3;
+	unsigned char disable:1;
+	unsigned char f54_ctrl17_b4:1;
+	unsigned char filter_bandwidth:3;
+};
+
+struct f54_control_17 {
+	struct f54_control_17n *data;
+	unsigned short address;
+	unsigned char length;
+};
+
+struct f54_control_18n {
+	unsigned char burst_count_b0__7;
+};
+
+struct f54_control_18 {
+	struct f54_control_18n *data;
+	unsigned short address;
+	unsigned char length;
+};
+
+struct f54_control_19n {
+	unsigned char stretch_duration;
+};
+
+struct f54_control_19 {
+	struct f54_control_19n *data;
+	unsigned short address;
+	unsigned char length;
+};
+
+struct f54_control_20 {
+	union {
+		struct {
+			unsigned char disable_noise_mitigation:1;
+			unsigned char f54_ctrl20_b1__7:7;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_21 {
+	union {
+		struct {
+			unsigned short freq_shift_noise_threshold;
+		} __packed;
+		struct {
+			unsigned char data[2];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_22__26 {
+	union {
+		struct {
+			/* control 22 */
+			unsigned char f54_ctrl22;
+
+			/* control 23 */
+			unsigned short medium_noise_threshold;
+
+			/* control 24 */
+			unsigned short high_noise_threshold;
+
+			/* control 25 */
+			unsigned char noise_density;
+
+			/* control 26 */
+			unsigned char frame_count;
+		} __packed;
+		struct {
+			unsigned char data[7];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_27 {
+	union {
+		struct {
+			unsigned char iir_filter_coef;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_28 {
+	union {
+		struct {
+			unsigned short quiet_threshold;
+		} __packed;
+		struct {
+			unsigned char data[2];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_29 {
+	union {
+		struct {
+			/* control 29 */
+			unsigned char f54_ctrl29_b0__6:7;
+			unsigned char cmn_filter_disable:1;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_30 {
+	union {
+		struct {
+			unsigned char cmn_filter_max;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_31 {
+	union {
+		struct {
+			unsigned char touch_hysteresis;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_32__35 {
+	union {
+		struct {
+			/* control 32 */
+			unsigned short rx_low_edge_comp;
+
+			/* control 33 */
+			unsigned short rx_high_edge_comp;
+
+			/* control 34 */
+			unsigned short tx_low_edge_comp;
+
+			/* control 35 */
+			unsigned short tx_high_edge_comp;
+		} __packed;
+		struct {
+			unsigned char data[8];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_36n {
+	unsigned char axis1_comp;
+};
+
+struct f54_control_36 {
+	struct f54_control_36n *data;
+	unsigned short address;
+	unsigned char length;
+};
+
+struct f54_control_37n {
+	unsigned char axis2_comp;
+};
+
+struct f54_control_37 {
+	struct f54_control_37n *data;
+	unsigned short address;
+	unsigned char length;
+};
+
+struct f54_control_38n {
+	unsigned char noise_control_1;
+};
+
+struct f54_control_38 {
+	struct f54_control_38n *data;
+	unsigned short address;
+	unsigned char length;
+};
+
+struct f54_control_39n {
+	unsigned char noise_control_2;
+};
+
+struct f54_control_39 {
+	struct f54_control_39n *data;
+	unsigned short address;
+	unsigned char length;
+};
+
+struct f54_control_40n {
+	unsigned char noise_control_3;
+};
+
+struct f54_control_40 {
+	struct f54_control_40n *data;
+	unsigned short address;
+	unsigned char length;
+};
+
+struct f54_control_41 {
+	union {
+		struct {
+			unsigned char no_signal_clarity:1;
+			unsigned char f54_ctrl41_b1__7:7;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_57 {
+	union {
+		struct {
+			unsigned char cbc_cap_0d:3;
+			unsigned char cbc_polarity_0d:1;
+			unsigned char cbc_tx_carrier_selection_0d:1;
+			unsigned char f54_ctrl57_b5__7:3;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_88 {
+	union {
+		struct {
+			unsigned char tx_low_reference_polarity:1;
+			unsigned char tx_high_reference_polarity:1;
+			unsigned char abs_low_reference_polarity:1;
+			unsigned char abs_polarity:1;
+			unsigned char cbc_polarity:1;
+			unsigned char cbc_tx_carrier_selection:1;
+			unsigned char charge_pump_enable:1;
+			unsigned char cbc_abs_auto_servo:1;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control {
+	struct f54_control_0 *reg_0;
+	struct f54_control_1 *reg_1;
+	struct f54_control_2 *reg_2;
+	struct f54_control_3 *reg_3;
+	struct f54_control_4__6 *reg_4__6;
+	struct f54_control_7 *reg_7;
+	struct f54_control_8__9 *reg_8__9;
+	struct f54_control_10 *reg_10;
+	struct f54_control_11 *reg_11;
+	struct f54_control_12__13 *reg_12__13;
+	struct f54_control_14 *reg_14;
+	struct f54_control_15 *reg_15;
+	struct f54_control_16 *reg_16;
+	struct f54_control_17 *reg_17;
+	struct f54_control_18 *reg_18;
+	struct f54_control_19 *reg_19;
+	struct f54_control_20 *reg_20;
+	struct f54_control_21 *reg_21;
+	struct f54_control_22__26 *reg_22__26;
+	struct f54_control_27 *reg_27;
+	struct f54_control_28 *reg_28;
+	struct f54_control_29 *reg_29;
+	struct f54_control_30 *reg_30;
+	struct f54_control_31 *reg_31;
+	struct f54_control_32__35 *reg_32__35;
+	struct f54_control_36 *reg_36;
+	struct f54_control_37 *reg_37;
+	struct f54_control_38 *reg_38;
+	struct f54_control_39 *reg_39;
+	struct f54_control_40 *reg_40;
+	struct f54_control_41 *reg_41;
+	struct f54_control_57 *reg_57;
+	struct f54_control_88 *reg_88;
+};
+
+struct synaptics_rmi4_f54_handle {
+	bool no_auto_cal;
+	unsigned char status;
+	unsigned char intr_mask;
+	unsigned char intr_reg_num;
+	unsigned char rx_assigned;
+	unsigned char tx_assigned;
+	unsigned char *report_data;
+	unsigned short query_base_addr;
+	unsigned short control_base_addr;
+	unsigned short data_base_addr;
+	unsigned short command_base_addr;
+	unsigned short fifoindex;
+	unsigned int report_size;
+	unsigned int data_buffer_size;
+	enum f54_report_types report_type;
+	struct mutex status_mutex;
+	struct mutex data_mutex;
+	struct mutex control_mutex;
+	struct f54_query query;
+	struct f54_control control;
+	struct kobject *attr_dir;
+	struct hrtimer watchdog;
+	struct work_struct timeout_work;
+	struct delayed_work status_work;
+	struct workqueue_struct *status_workqueue;
+	struct synaptics_rmi4_data *rmi4_data;
+};
+
+struct f55_query {
+	union {
+		struct {
+			/* query 0 */
+			unsigned char num_of_rx_electrodes;
+
+			/* query 1 */
+			unsigned char num_of_tx_electrodes;
+
+			/* query 2 */
+			unsigned char has_sensor_assignment:1;
+			unsigned char has_edge_compensation:1;
+			unsigned char curve_compensation_mode:2;
+			unsigned char has_ctrl6:1;
+			unsigned char has_alternate_transmitter_assignment:1;
+			unsigned char has_single_layer_multi_touch:1;
+			unsigned char has_query5:1;
+		} __packed;
+		unsigned char data[3];
+	};
+};
+
+struct synaptics_rmi4_f55_handle {
+	unsigned char *rx_assignment;
+	unsigned char *tx_assignment;
+	unsigned short query_base_addr;
+	unsigned short control_base_addr;
+	unsigned short data_base_addr;
+	unsigned short command_base_addr;
+	struct f55_query query;
+};
+
+//+++duguowei,2014.116
+show_prototype(factory_result)
+//---duguowei,2014.116
+
+show_prototype(status)
+show_prototype(report_size)
+show_store_prototype(no_auto_cal)
+show_store_prototype(report_type)
+show_store_prototype(fifoindex)
+store_prototype(do_preparation)
+store_prototype(get_report)
+store_prototype(force_cal)
+store_prototype(resume_touch)
+show_prototype(num_of_mapped_rx)
+show_prototype(num_of_mapped_tx)
+show_prototype(num_of_rx_electrodes)
+show_prototype(num_of_tx_electrodes)
+show_prototype(has_image16)
+show_prototype(has_image8)
+show_prototype(has_baseline)
+show_prototype(clock_rate)
+show_prototype(touch_controller_family)
+show_prototype(has_pixel_touch_threshold_adjustment)
+show_prototype(has_sensor_assignment)
+show_prototype(has_interference_metric)
+show_prototype(has_sense_frequency_control)
+show_prototype(has_firmware_noise_mitigation)
+show_prototype(has_two_byte_report_rate)
+show_prototype(has_one_byte_report_rate)
+show_prototype(has_relaxation_control)
+show_prototype(curve_compensation_mode)
+show_prototype(has_iir_filter)
+show_prototype(has_cmn_removal)
+show_prototype(has_cmn_maximum)
+show_prototype(has_touch_hysteresis)
+show_prototype(has_edge_compensation)
+show_prototype(has_per_frequency_noise_control)
+show_prototype(has_signal_clarity)
+show_prototype(number_of_sensing_frequencies)
+
+show_store_prototype(no_relax)
+show_store_prototype(no_scan)
+show_store_prototype(bursts_per_cluster)
+show_store_prototype(saturation_cap)
+show_store_prototype(pixel_touch_threshold)
+show_store_prototype(rx_feedback_cap)
+show_store_prototype(low_ref_cap)
+show_store_prototype(low_ref_feedback_cap)
+show_store_prototype(low_ref_polarity)
+show_store_prototype(high_ref_cap)
+show_store_prototype(high_ref_feedback_cap)
+show_store_prototype(high_ref_polarity)
+show_store_prototype(cbc_cap)
+show_store_prototype(cbc_polarity)
+show_store_prototype(cbc_tx_carrier_selection)
+show_store_prototype(integration_duration)
+show_store_prototype(reset_duration)
+show_store_prototype(noise_sensing_bursts_per_image)
+show_store_prototype(slow_relaxation_rate)
+show_store_prototype(fast_relaxation_rate)
+show_store_prototype(rxs_on_xaxis)
+show_store_prototype(curve_comp_on_txs)
+show_prototype(sensor_rx_assignment)
+show_prototype(sensor_tx_assignment)
+show_prototype(burst_count)
+show_prototype(disable)
+show_prototype(filter_bandwidth)
+show_prototype(stretch_duration)
+show_store_prototype(disable_noise_mitigation)
+show_store_prototype(freq_shift_noise_threshold)
+show_store_prototype(medium_noise_threshold)
+show_store_prototype(high_noise_threshold)
+show_store_prototype(noise_density)
+show_store_prototype(frame_count)
+show_store_prototype(iir_filter_coef)
+show_store_prototype(quiet_threshold)
+show_store_prototype(cmn_filter_disable)
+show_store_prototype(cmn_filter_max)
+show_store_prototype(touch_hysteresis)
+show_store_prototype(rx_low_edge_comp)
+show_store_prototype(rx_high_edge_comp)
+show_store_prototype(tx_low_edge_comp)
+show_store_prototype(tx_high_edge_comp)
+show_store_prototype(axis1_comp)
+show_store_prototype(axis2_comp)
+show_prototype(noise_control_1)
+show_prototype(noise_control_2)
+show_prototype(noise_control_3)
+show_store_prototype(no_signal_clarity)
+show_store_prototype(cbc_cap_0d)
+show_store_prototype(cbc_polarity_0d)
+show_store_prototype(cbc_tx_carrier_selection_0d)
+
+static ssize_t synaptics_rmi4_f54_data_read(struct file *data_file,
+		struct kobject *kobj, struct bin_attribute *attributes,
+		char *buf, loff_t pos, size_t count);
+
+static struct attribute *attrs[] = {	
+	//+++duguowei,2014.116
+	attrify(factory_result),
+	//---duguowei,2014.116
+	attrify(status),
+	attrify(report_size),
+	attrify(no_auto_cal),
+	attrify(report_type),
+	attrify(fifoindex),
+	attrify(do_preparation),
+	attrify(get_report),
+	attrify(force_cal),
+	attrify(resume_touch),
+	attrify(num_of_mapped_rx),
+	attrify(num_of_mapped_tx),
+	attrify(num_of_rx_electrodes),
+	attrify(num_of_tx_electrodes),
+	attrify(has_image16),
+	attrify(has_image8),
+	attrify(has_baseline),
+	attrify(clock_rate),
+	attrify(touch_controller_family),
+	attrify(has_pixel_touch_threshold_adjustment),
+	attrify(has_sensor_assignment),
+	attrify(has_interference_metric),
+	attrify(has_sense_frequency_control),
+	attrify(has_firmware_noise_mitigation),
+	attrify(has_two_byte_report_rate),
+	attrify(has_one_byte_report_rate),
+	attrify(has_relaxation_control),
+	attrify(curve_compensation_mode),
+	attrify(has_iir_filter),
+	attrify(has_cmn_removal),
+	attrify(has_cmn_maximum),
+	attrify(has_touch_hysteresis),
+	attrify(has_edge_compensation),
+	attrify(has_per_frequency_noise_control),
+	attrify(has_signal_clarity),
+	attrify(number_of_sensing_frequencies),
+	NULL,
+};
+
+static struct attribute_group attr_group = GROUP(attrs);
+
+static struct attribute *attrs_reg_0[] = {
+	attrify(no_relax),
+	attrify(no_scan),
+	NULL,
+};
+
+static struct attribute *attrs_reg_1[] = {
+	attrify(bursts_per_cluster),
+	NULL,
+};
+
+static struct attribute *attrs_reg_2[] = {
+	attrify(saturation_cap),
+	NULL,
+};
+
+static struct attribute *attrs_reg_3[] = {
+	attrify(pixel_touch_threshold),
+	NULL,
+};
+
+static struct attribute *attrs_reg_4__6[] = {
+	attrify(rx_feedback_cap),
+	attrify(low_ref_cap),
+	attrify(low_ref_feedback_cap),
+	attrify(low_ref_polarity),
+	attrify(high_ref_cap),
+	attrify(high_ref_feedback_cap),
+	attrify(high_ref_polarity),
+	NULL,
+};
+
+static struct attribute *attrs_reg_7[] = {
+	attrify(cbc_cap),
+	attrify(cbc_polarity),
+	attrify(cbc_tx_carrier_selection),
+	NULL,
+};
+
+static struct attribute *attrs_reg_8__9[] = {
+	attrify(integration_duration),
+	attrify(reset_duration),
+	NULL,
+};
+
+static struct attribute *attrs_reg_10[] = {
+	attrify(noise_sensing_bursts_per_image),
+	NULL,
+};
+
+static struct attribute *attrs_reg_11[] = {
+	NULL,
+};
+
+static struct attribute *attrs_reg_12__13[] = {
+	attrify(slow_relaxation_rate),
+	attrify(fast_relaxation_rate),
+	NULL,
+};
+
+static struct attribute *attrs_reg_14__16[] = {
+	attrify(rxs_on_xaxis),
+	attrify(curve_comp_on_txs),
+	attrify(sensor_rx_assignment),
+	attrify(sensor_tx_assignment),
+	NULL,
+};
+
+static struct attribute *attrs_reg_17__19[] = {
+	attrify(burst_count),
+	attrify(disable),
+	attrify(filter_bandwidth),
+	attrify(stretch_duration),
+	NULL,
+};
+
+static struct attribute *attrs_reg_20[] = {
+	attrify(disable_noise_mitigation),
+	NULL,
+};
+
+static struct attribute *attrs_reg_21[] = {
+	attrify(freq_shift_noise_threshold),
+	NULL,
+};
+
+static struct attribute *attrs_reg_22__26[] = {
+	attrify(medium_noise_threshold),
+	attrify(high_noise_threshold),
+	attrify(noise_density),
+	attrify(frame_count),
+	NULL,
+};
+
+static struct attribute *attrs_reg_27[] = {
+	attrify(iir_filter_coef),
+	NULL,
+};
+
+static struct attribute *attrs_reg_28[] = {
+	attrify(quiet_threshold),
+	NULL,
+};
+
+static struct attribute *attrs_reg_29[] = {
+	attrify(cmn_filter_disable),
+	NULL,
+};
+
+static struct attribute *attrs_reg_30[] = {
+	attrify(cmn_filter_max),
+	NULL,
+};
+
+static struct attribute *attrs_reg_31[] = {
+	attrify(touch_hysteresis),
+	NULL,
+};
+
+static struct attribute *attrs_reg_32__35[] = {
+	attrify(rx_low_edge_comp),
+	attrify(rx_high_edge_comp),
+	attrify(tx_low_edge_comp),
+	attrify(tx_high_edge_comp),
+	NULL,
+};
+
+static struct attribute *attrs_reg_36[] = {
+	attrify(axis1_comp),
+	NULL,
+};
+
+static struct attribute *attrs_reg_37[] = {
+	attrify(axis2_comp),
+	NULL,
+};
+
+static struct attribute *attrs_reg_38__40[] = {
+	attrify(noise_control_1),
+	attrify(noise_control_2),
+	attrify(noise_control_3),
+	NULL,
+};
+
+static struct attribute *attrs_reg_41[] = {
+	attrify(no_signal_clarity),
+	NULL,
+};
+
+static struct attribute *attrs_reg_57[] = {
+	attrify(cbc_cap_0d),
+	attrify(cbc_polarity_0d),
+	attrify(cbc_tx_carrier_selection_0d),
+	NULL,
+};
+
+static struct attribute_group attrs_ctrl_regs[] = {
+	GROUP(attrs_reg_0),
+	GROUP(attrs_reg_1),
+	GROUP(attrs_reg_2),
+	GROUP(attrs_reg_3),
+	GROUP(attrs_reg_4__6),
+	GROUP(attrs_reg_7),
+	GROUP(attrs_reg_8__9),
+	GROUP(attrs_reg_10),
+	GROUP(attrs_reg_11),
+	GROUP(attrs_reg_12__13),
+	GROUP(attrs_reg_14__16),
+	GROUP(attrs_reg_17__19),
+	GROUP(attrs_reg_20),
+	GROUP(attrs_reg_21),
+	GROUP(attrs_reg_22__26),
+	GROUP(attrs_reg_27),
+	GROUP(attrs_reg_28),
+	GROUP(attrs_reg_29),
+	GROUP(attrs_reg_30),
+	GROUP(attrs_reg_31),
+	GROUP(attrs_reg_32__35),
+	GROUP(attrs_reg_36),
+	GROUP(attrs_reg_37),
+	GROUP(attrs_reg_38__40),
+	GROUP(attrs_reg_41),
+	GROUP(attrs_reg_57),
+};
+
+static bool attrs_ctrl_regs_exist[ARRAY_SIZE(attrs_ctrl_regs)];
+
+static struct bin_attribute dev_report_data = {
+	.attr = {
+		.name = "report_data",
+		.mode = S_IRUGO,
+	},
+	.size = 0,
+	.read = synaptics_rmi4_f54_data_read,
+};
+
+static struct synaptics_rmi4_f54_handle *f54;
+static struct synaptics_rmi4_f55_handle *f55;
+
+DECLARE_COMPLETION(f54_remove_complete);
+
+static bool is_report_type_valid(enum f54_report_types report_type)
+{
+	switch (report_type) {
+	case F54_8BIT_IMAGE:
+	case F54_16BIT_IMAGE:
+	case F54_RAW_16BIT_IMAGE:
+	case F54_HIGH_RESISTANCE:
+	case F54_TX_TO_TX_SHORT:
+	case F54_RX_TO_RX1:
+	case F54_TRUE_BASELINE:
+	case F54_FULL_RAW_CAP_MIN_MAX:
+	case F54_RX_OPENS1:
+	case F54_TX_OPEN:
+	case F54_TX_TO_GROUND:
+	case F54_RX_TO_RX2:
+	case F54_RX_OPENS2:
+	case F54_FULL_RAW_CAP:
+	case F54_FULL_RAW_CAP_RX_COUPLING_COMP:
+	case F54_SENSOR_SPEED:
+	case F54_ADC_RANGE:
+	case F54_TREX_OPENS:
+	case F54_TREX_TO_GND:
+	case F54_TREX_SHORTS:
+		return true;
+		break;
+	default:
+		f54->report_type = INVALID_REPORT_TYPE;
+		f54->report_size = 0;
+		return false;
+	}
+}
+
+static void set_report_size(void)
+{
+	int retval;
+	unsigned char rx = f54->rx_assigned;
+	unsigned char tx = f54->tx_assigned;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	switch (f54->report_type) {
+	case F54_8BIT_IMAGE:
+		f54->report_size = rx * tx;
+		break;
+	case F54_16BIT_IMAGE:
+	case F54_RAW_16BIT_IMAGE:
+	case F54_TRUE_BASELINE:
+	case F54_FULL_RAW_CAP:
+	case F54_FULL_RAW_CAP_RX_COUPLING_COMP:
+	case F54_SENSOR_SPEED:
+		f54->report_size = 2 * rx * tx;
+		break;
+	case F54_HIGH_RESISTANCE:
+		f54->report_size = HIGH_RESISTANCE_DATA_SIZE;
+		break;
+	case F54_TX_TO_TX_SHORT:
+	case F54_TX_OPEN:
+	case F54_TX_TO_GROUND:
+		f54->report_size = (tx + 7) / 8;
+		break;
+	case F54_RX_TO_RX1:
+	case F54_RX_OPENS1:
+		if (rx < tx)
+			f54->report_size = 2 * rx * rx;
+		else
+			f54->report_size = 2 * rx * tx;
+		break;
+	case F54_FULL_RAW_CAP_MIN_MAX:
+		f54->report_size = FULL_RAW_CAP_MIN_MAX_DATA_SIZE;
+		break;
+	case F54_RX_TO_RX2:
+	case F54_RX_OPENS2:
+		if (rx <= tx)
+			f54->report_size = 0;
+		else
+			f54->report_size = 2 * rx * (rx - tx);
+		break;
+	case F54_ADC_RANGE:
+		if (f54->query.has_signal_clarity) {
+			mutex_lock(&f54->control_mutex);
+			retval = synaptics_rmi4_reg_read(rmi4_data,
+					f54->control.reg_41->address,
+					f54->control.reg_41->data,
+					sizeof(f54->control.reg_41->data));
+			mutex_unlock(&f54->control_mutex);
+			if (retval < 0) {
+				dev_dbg(rmi4_data->pdev->dev.parent,
+						"%s: Failed to read control reg_41\n",
+						__func__);
+				f54->report_size = 0;
+				break;
+			}
+			if (!f54->control.reg_41->no_signal_clarity) {
+				if (tx % 4)
+					tx += 4 - (tx % 4);
+			}
+		}
+		f54->report_size = 2 * rx * tx;
+		break;
+	case F54_TREX_OPENS:
+	case F54_TREX_TO_GND:
+	case F54_TREX_SHORTS:
+		f54->report_size = TREX_DATA_SIZE;
+		break;
+	default:
+		f54->report_size = 0;
+	}
+
+	return;
+}
+
+static int set_interrupt(bool set)
+{
+	int retval;
+	unsigned char ii;
+	unsigned char zero = 0x00;
+	unsigned char *intr_mask;
+	unsigned short f01_ctrl_reg;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	intr_mask = rmi4_data->intr_mask;
+	f01_ctrl_reg = rmi4_data->f01_ctrl_base_addr + 1 + f54->intr_reg_num;
+
+	if (!set) {
+		retval = synaptics_rmi4_reg_write(rmi4_data,
+				f01_ctrl_reg,
+				&zero,
+				sizeof(zero));
+		if (retval < 0)
+			return retval;
+	}
+
+	for (ii = 0; ii < rmi4_data->num_of_intr_regs; ii++) {
+		if (intr_mask[ii] != 0x00) {
+			f01_ctrl_reg = rmi4_data->f01_ctrl_base_addr + 1 + ii;
+			if (set) {
+				retval = synaptics_rmi4_reg_write(rmi4_data,
+						f01_ctrl_reg,
+						&zero,
+						sizeof(zero));
+				if (retval < 0)
+					return retval;
+			} else {
+				retval = synaptics_rmi4_reg_write(rmi4_data,
+						f01_ctrl_reg,
+						&(intr_mask[ii]),
+						sizeof(intr_mask[ii]));
+				if (retval < 0)
+					return retval;
+			}
+		}
+	}
+
+	f01_ctrl_reg = rmi4_data->f01_ctrl_base_addr + 1 + f54->intr_reg_num;
+
+	if (set) {
+		retval = synaptics_rmi4_reg_write(rmi4_data,
+				f01_ctrl_reg,
+				&f54->intr_mask,
+				1);
+		if (retval < 0)
+			return retval;
+	}
+
+	return 0;
+}
+
+static int do_preparation(void)
+{
+	int retval;
+	unsigned char value;
+	unsigned char command;
+	unsigned char timeout_count;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	mutex_lock(&f54->control_mutex);
+
+	if (f54->query.touch_controller_family == 1) {
+		value = 0;
+		retval = synaptics_rmi4_reg_write(rmi4_data,
+				f54->control.reg_7->address,
+				&value,
+				sizeof(f54->control.reg_7->data));
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to disable CBC\n",
+					__func__);
+			mutex_unlock(&f54->control_mutex);
+			return retval;
+		}
+	} else if (f54->query.has_ctrl88 == 1) {
+		retval = synaptics_rmi4_reg_read(rmi4_data,
+				f54->control.reg_88->address,
+				f54->control.reg_88->data,
+				sizeof(f54->control.reg_88->data));
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to disable CBC (read ctrl88)\n",
+					__func__);
+			mutex_unlock(&f54->control_mutex);
+			return retval;
+		}
+		f54->control.reg_88->cbc_polarity = 0;
+		f54->control.reg_88->cbc_tx_carrier_selection = 0;
+		retval = synaptics_rmi4_reg_write(rmi4_data,
+				f54->control.reg_88->address,
+				f54->control.reg_88->data,
+				sizeof(f54->control.reg_88->data));
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to disable CBC (write ctrl88)\n",
+					__func__);
+			mutex_unlock(&f54->control_mutex);
+			return retval;
+		}
+	}
+
+	if (f54->query.has_0d_acquisition_control) {
+		value = 0;
+		retval = synaptics_rmi4_reg_write(rmi4_data,
+				f54->control.reg_57->address,
+				&value,
+				sizeof(f54->control.reg_57->data));
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to disable 0D CBC\n",
+					__func__);
+			mutex_unlock(&f54->control_mutex);
+			return retval;
+		}
+	}
+
+	if (f54->query.has_signal_clarity) {
+		value = 1;
+		retval = synaptics_rmi4_reg_write(rmi4_data,
+				f54->control.reg_41->address,
+				&value,
+				sizeof(f54->control.reg_41->data));
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to disable signal clarity\n",
+					__func__);
+			mutex_unlock(&f54->control_mutex);
+			return retval;
+		}
+	}
+
+	mutex_unlock(&f54->control_mutex);
+
+	command = (unsigned char)COMMAND_FORCE_UPDATE;
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			f54->command_base_addr,
+			&command,
+			sizeof(command));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to write force update command\n",
+				__func__);
+		return retval;
+	}
+
+	timeout_count = 0;
+	do {
+		retval = synaptics_rmi4_reg_read(rmi4_data,
+				f54->command_base_addr,
+				&value,
+				sizeof(value));
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to read command register\n",
+					__func__);
+			return retval;
+		}
+
+		if (value == 0x00)
+			break;
+
+		msleep(100);
+		timeout_count++;
+	} while (timeout_count < FORCE_TIMEOUT_100MS);
+
+	if (timeout_count == FORCE_TIMEOUT_100MS) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Timed out waiting for force update\n",
+				__func__);
+		return -ETIMEDOUT;
+	}
+
+	command = (unsigned char)COMMAND_FORCE_CAL;
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			f54->command_base_addr,
+			&command,
+			sizeof(command));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to write force cal command\n",
+				__func__);
+		return retval;
+	}
+
+	timeout_count = 0;
+	do {
+		retval = synaptics_rmi4_reg_read(rmi4_data,
+				f54->command_base_addr,
+				&value,
+				sizeof(value));
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to read command register\n",
+					__func__);
+			return retval;
+		}
+
+		if (value == 0x00)
+			break;
+
+		msleep(100);
+		timeout_count++;
+	} while (timeout_count < FORCE_TIMEOUT_100MS);
+
+	if (timeout_count == FORCE_TIMEOUT_100MS) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Timed out waiting for force cal\n",
+				__func__);
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+#ifdef WATCHDOG_HRTIMER
+static void timeout_set_status(struct work_struct *work)
+{
+	int retval;
+	unsigned char command;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	mutex_lock(&f54->status_mutex);
+	if (f54->status == STATUS_BUSY) {
+		retval = synaptics_rmi4_reg_read(rmi4_data,
+				f54->command_base_addr,
+				&command,
+				sizeof(command));
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to read command register\n",
+					__func__);
+		} else if (command & COMMAND_GET_REPORT) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Report type not supported by FW\n",
+					__func__);
+		} else {
+			queue_delayed_work(f54->status_workqueue,
+					&f54->status_work,
+					0);
+			mutex_unlock(&f54->status_mutex);
+			return;
+		}
+		f54->report_type = INVALID_REPORT_TYPE;
+		f54->report_size = 0;
+	}
+	mutex_unlock(&f54->status_mutex);
+
+	return;
+}
+
+static enum hrtimer_restart get_report_timeout(struct hrtimer *timer)
+{
+	schedule_work(&(f54->timeout_work));
+
+	return HRTIMER_NORESTART;
+}
+#endif
+
+#ifdef RAW_HEX
+static void print_raw_hex_report(void)
+{
+	unsigned int ii;
+
+	pr_info("%s: Report data (raw hex)\n", __func__);
+
+	switch (f54->report_type) {
+	case F54_16BIT_IMAGE:
+	case F54_RAW_16BIT_IMAGE:
+	case F54_HIGH_RESISTANCE:
+	case F54_TRUE_BASELINE:
+	case F54_FULL_RAW_CAP_MIN_MAX:
+	case F54_FULL_RAW_CAP:
+	case F54_FULL_RAW_CAP_RX_COUPLING_COMP:
+	case F54_SENSOR_SPEED:
+	case F54_ADC_RANGE:
+		for (ii = 0; ii < f54->report_size; ii += 2) {
+			pr_info("%03d: 0x%02x%02x\n",
+					ii / 2,
+					f54->report_data[ii + 1],
+					f54->report_data[ii]);
+		}
+		break;
+	default:
+		for (ii = 0; ii < f54->report_size; ii++)
+			pr_info("%03d: 0x%02x\n", ii, f54->report_data[ii]);
+		break;
+	}
+
+	return;
+}
+#endif
+
+#ifdef HUMAN_READABLE
+static void print_image_report(void)
+{
+	unsigned int ii;
+	unsigned int jj;
+	short *report_data;
+
+	switch (f54->report_type) {
+	case F54_16BIT_IMAGE:
+	case F54_RAW_16BIT_IMAGE:
+	case F54_TRUE_BASELINE:
+	case F54_FULL_RAW_CAP:
+	case F54_FULL_RAW_CAP_RX_COUPLING_COMP:
+		pr_info("%s: Report data (image)\n", __func__);
+
+		report_data = (short *)f54->report_data;
+
+		for (ii = 0; ii < f54->tx_assigned; ii++) {
+			for (jj = 0; jj < f54->rx_assigned; jj++) {
+				if (*report_data < -64)
+					pr_cont(".");
+				else if (*report_data < 0)
+					pr_cont("-");
+				else if (*report_data > 64)
+					pr_cont("*");
+				else if (*report_data > 0)
+					pr_cont("+");
+				else
+					pr_cont("0");
+
+				report_data++;
+			}
+			pr_info("");
+		}
+		pr_info("%s: End of report\n", __func__);
+		break;
+	default:
+		pr_info("%s: Image not supported for report type %d\n",
+				__func__, f54->report_type);
+	}
+
+	return;
+}
+#endif
+
+static void free_control_mem(void)
+{
+	struct f54_control control = f54->control;
+
+	kfree(control.reg_0);
+	kfree(control.reg_1);
+	kfree(control.reg_2);
+	kfree(control.reg_3);
+	kfree(control.reg_4__6);
+	kfree(control.reg_7);
+	kfree(control.reg_8__9);
+	kfree(control.reg_10);
+	kfree(control.reg_11);
+	kfree(control.reg_12__13);
+	kfree(control.reg_14);
+	kfree(control.reg_15);
+	kfree(control.reg_16);
+	kfree(control.reg_17);
+	kfree(control.reg_18);
+	kfree(control.reg_19);
+	kfree(control.reg_20);
+	kfree(control.reg_21);
+	kfree(control.reg_22__26);
+	kfree(control.reg_27);
+	kfree(control.reg_28);
+	kfree(control.reg_29);
+	kfree(control.reg_30);
+	kfree(control.reg_31);
+	kfree(control.reg_32__35);
+	kfree(control.reg_36);
+	kfree(control.reg_37);
+	kfree(control.reg_38);
+	kfree(control.reg_39);
+	kfree(control.reg_40);
+	kfree(control.reg_41);
+	kfree(control.reg_57);
+
+	return;
+}
+
+static void remove_sysfs(void)
+{
+	int reg_num;
+
+	sysfs_remove_bin_file(f54->attr_dir, &dev_report_data);
+
+	sysfs_remove_group(f54->attr_dir, &attr_group);
+
+	for (reg_num = 0; reg_num < ARRAY_SIZE(attrs_ctrl_regs); reg_num++)
+		sysfs_remove_group(f54->attr_dir, &attrs_ctrl_regs[reg_num]);
+
+	kobject_put(f54->attr_dir);
+
+	return;
+}
+
+static ssize_t synaptics_rmi4_f54_status_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u\n", f54->status);
+}
+
+static ssize_t synaptics_rmi4_f54_report_size_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u\n", f54->report_size);
+}
+
+static ssize_t synaptics_rmi4_f54_no_auto_cal_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u\n", f54->no_auto_cal);
+}
+
+static ssize_t synaptics_rmi4_f54_no_auto_cal_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned char data;
+	unsigned long setting;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	retval = sstrtoul(buf, 10, &setting);
+	if (retval)
+		return retval;
+
+	if (setting > 1)
+		return -EINVAL;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			f54->control_base_addr,
+			&data,
+			sizeof(data));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read control register\n",
+				__func__);
+		return retval;
+	}
+
+	if ((data & NO_AUTO_CAL_MASK) == setting)
+		return count;
+
+	data = (data & ~NO_AUTO_CAL_MASK) | (data & NO_AUTO_CAL_MASK);
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			f54->control_base_addr,
+			&data,
+			sizeof(data));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to write control register\n",
+				__func__);
+		return retval;
+	}
+
+	f54->no_auto_cal = (setting == 1);
+
+	return count;
+}
+
+static ssize_t synaptics_rmi4_f54_report_type_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u\n", f54->report_type);
+}
+
+static ssize_t synaptics_rmi4_f54_report_type_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned char data;
+	unsigned long setting;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	retval = sstrtoul(buf, 10, &setting);
+	if (retval)
+		return retval;
+
+	if (!is_report_type_valid((enum f54_report_types)setting)) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Report type not supported by driver\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	mutex_lock(&f54->status_mutex);
+
+	if (f54->status != STATUS_BUSY) {
+		f54->report_type = (enum f54_report_types)setting;
+		data = (unsigned char)setting;
+		retval = synaptics_rmi4_reg_write(rmi4_data,
+				f54->data_base_addr,
+				&data,
+				sizeof(data));
+		mutex_unlock(&f54->status_mutex);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to write data register\n",
+					__func__);
+			return retval;
+		}
+		return count;
+	} else {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Previous get report still ongoing\n",
+				__func__);
+		mutex_unlock(&f54->status_mutex);
+		return -EINVAL;
+	}
+}
+
+static ssize_t synaptics_rmi4_f54_fifoindex_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int retval;
+	unsigned char data[2];
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			f54->data_base_addr + DATA_REPORT_INDEX_OFFSET,
+			data,
+			sizeof(data));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read data registers\n",
+				__func__);
+		return retval;
+	}
+
+	batohs(&f54->fifoindex, data);
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", f54->fifoindex);
+}
+static ssize_t synaptics_rmi4_f54_fifoindex_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned char data[2];
+	unsigned long setting;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	retval = sstrtoul(buf, 10, &setting);
+	if (retval)
+		return retval;
+
+	f54->fifoindex = setting;
+
+	hstoba(data, (unsigned short)setting);
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			f54->data_base_addr + DATA_REPORT_INDEX_OFFSET,
+			data,
+			sizeof(data));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to write data registers\n",
+				__func__);
+		return retval;
+	}
+
+	return count;
+}
+
+static ssize_t synaptics_rmi4_f54_do_preparation_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned long setting;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	retval = sstrtoul(buf, 10, &setting);
+	if (retval)
+		return retval;
+
+	if (setting != 1)
+		return -EINVAL;
+
+	mutex_lock(&f54->status_mutex);
+
+	if (f54->status != STATUS_IDLE) {
+		if (f54->status != STATUS_BUSY) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Invalid status (%d)\n",
+					__func__, f54->status);
+		} else {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Previous get report still ongoing\n",
+					__func__);
+		}
+		mutex_unlock(&f54->status_mutex);
+		return -EBUSY;
+	}
+
+	mutex_unlock(&f54->status_mutex);
+
+	retval = do_preparation();
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to do preparation\n",
+				__func__);
+		return retval;
+	}
+
+	return count;
+}
+
+static ssize_t synaptics_rmi4_f54_get_report_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned char command;
+	unsigned long setting;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	retval = sstrtoul(buf, 10, &setting);
+	if (retval)
+		return retval;
+
+	if (setting != 1)
+		return -EINVAL;
+
+	command = (unsigned char)COMMAND_GET_REPORT;
+
+	if (!is_report_type_valid(f54->report_type)) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Invalid report type\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	mutex_lock(&f54->status_mutex);
+
+	if (f54->status != STATUS_IDLE) {
+		if (f54->status != STATUS_BUSY) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Invalid status (%d)\n",
+					__func__, f54->status);
+		} else {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Previous get report still ongoing\n",
+					__func__);
+		}
+		mutex_unlock(&f54->status_mutex);
+		return -EBUSY;
+	}
+
+	set_interrupt(true);
+
+	f54->status = STATUS_BUSY;
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			f54->command_base_addr,
+			&command,
+			sizeof(command));
+	mutex_unlock(&f54->status_mutex);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to write get report command\n",
+				__func__);
+		return retval;
+	}
+
+#ifdef WATCHDOG_HRTIMER
+	hrtimer_start(&f54->watchdog,
+			ktime_set(WATCHDOG_TIMEOUT_S, 0),
+			HRTIMER_MODE_REL);
+#endif
+
+	return count;
+}
+
+static ssize_t synaptics_rmi4_f54_force_cal_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned char command;
+	unsigned long setting;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	retval = sstrtoul(buf, 10, &setting);
+	if (retval)
+		return retval;
+
+	if (setting != 1)
+		return -EINVAL;
+
+	command = (unsigned char)COMMAND_FORCE_CAL;
+
+	if (f54->status == STATUS_BUSY)
+		return -EBUSY;
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			f54->command_base_addr,
+			&command,
+			sizeof(command));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to write force cal command\n",
+				__func__);
+		return retval;
+	}
+
+	return count;
+}
+
+static ssize_t synaptics_rmi4_f54_resume_touch_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned long setting;
+
+	retval = sstrtoul(buf, 10, &setting);
+	if (retval)
+		return retval;
+
+	if (setting != 1)
+		return -EINVAL;
+
+	set_interrupt(false);
+
+	return count;
+}
+
+static ssize_t synaptics_rmi4_f54_num_of_mapped_rx_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u\n", f54->rx_assigned);
+}
+
+static ssize_t synaptics_rmi4_f54_num_of_mapped_tx_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u\n", f54->tx_assigned);
+}
+
+simple_show_func_unsigned(query, num_of_rx_electrodes)
+simple_show_func_unsigned(query, num_of_tx_electrodes)
+simple_show_func_unsigned(query, has_image16)
+simple_show_func_unsigned(query, has_image8)
+simple_show_func_unsigned(query, has_baseline)
+simple_show_func_unsigned(query, clock_rate)
+simple_show_func_unsigned(query, touch_controller_family)
+simple_show_func_unsigned(query, has_pixel_touch_threshold_adjustment)
+simple_show_func_unsigned(query, has_sensor_assignment)
+simple_show_func_unsigned(query, has_interference_metric)
+simple_show_func_unsigned(query, has_sense_frequency_control)
+simple_show_func_unsigned(query, has_firmware_noise_mitigation)
+simple_show_func_unsigned(query, has_two_byte_report_rate)
+simple_show_func_unsigned(query, has_one_byte_report_rate)
+simple_show_func_unsigned(query, has_relaxation_control)
+simple_show_func_unsigned(query, curve_compensation_mode)
+simple_show_func_unsigned(query, has_iir_filter)
+simple_show_func_unsigned(query, has_cmn_removal)
+simple_show_func_unsigned(query, has_cmn_maximum)
+simple_show_func_unsigned(query, has_touch_hysteresis)
+simple_show_func_unsigned(query, has_edge_compensation)
+simple_show_func_unsigned(query, has_per_frequency_noise_control)
+simple_show_func_unsigned(query, has_signal_clarity)
+simple_show_func_unsigned(query, number_of_sensing_frequencies)
+
+show_store_func_unsigned(control, reg_0, no_relax)
+show_store_func_unsigned(control, reg_0, no_scan)
+show_store_func_unsigned(control, reg_1, bursts_per_cluster)
+show_store_func_unsigned(control, reg_2, saturation_cap)
+show_store_func_unsigned(control, reg_3, pixel_touch_threshold)
+show_store_func_unsigned(control, reg_4__6, rx_feedback_cap)
+show_store_func_unsigned(control, reg_4__6, low_ref_cap)
+show_store_func_unsigned(control, reg_4__6, low_ref_feedback_cap)
+show_store_func_unsigned(control, reg_4__6, low_ref_polarity)
+show_store_func_unsigned(control, reg_4__6, high_ref_cap)
+show_store_func_unsigned(control, reg_4__6, high_ref_feedback_cap)
+show_store_func_unsigned(control, reg_4__6, high_ref_polarity)
+show_store_func_unsigned(control, reg_7, cbc_cap)
+show_store_func_unsigned(control, reg_7, cbc_polarity)
+show_store_func_unsigned(control, reg_7, cbc_tx_carrier_selection)
+show_store_func_unsigned(control, reg_8__9, integration_duration)
+show_store_func_unsigned(control, reg_8__9, reset_duration)
+show_store_func_unsigned(control, reg_10, noise_sensing_bursts_per_image)
+show_store_func_unsigned(control, reg_12__13, slow_relaxation_rate)
+show_store_func_unsigned(control, reg_12__13, fast_relaxation_rate)
+show_store_func_unsigned(control, reg_14, rxs_on_xaxis)
+show_store_func_unsigned(control, reg_14, curve_comp_on_txs)
+show_store_func_unsigned(control, reg_20, disable_noise_mitigation)
+show_store_func_unsigned(control, reg_21, freq_shift_noise_threshold)
+show_store_func_unsigned(control, reg_22__26, medium_noise_threshold)
+show_store_func_unsigned(control, reg_22__26, high_noise_threshold)
+show_store_func_unsigned(control, reg_22__26, noise_density)
+show_store_func_unsigned(control, reg_22__26, frame_count)
+show_store_func_unsigned(control, reg_27, iir_filter_coef)
+show_store_func_unsigned(control, reg_28, quiet_threshold)
+show_store_func_unsigned(control, reg_29, cmn_filter_disable)
+show_store_func_unsigned(control, reg_30, cmn_filter_max)
+show_store_func_unsigned(control, reg_31, touch_hysteresis)
+show_store_func_unsigned(control, reg_32__35, rx_low_edge_comp)
+show_store_func_unsigned(control, reg_32__35, rx_high_edge_comp)
+show_store_func_unsigned(control, reg_32__35, tx_low_edge_comp)
+show_store_func_unsigned(control, reg_32__35, tx_high_edge_comp)
+show_store_func_unsigned(control, reg_41, no_signal_clarity)
+show_store_func_unsigned(control, reg_57, cbc_cap_0d)
+show_store_func_unsigned(control, reg_57, cbc_polarity_0d)
+show_store_func_unsigned(control, reg_57, cbc_tx_carrier_selection_0d)
+
+show_replicated_func_unsigned(control, reg_15, sensor_rx_assignment)
+show_replicated_func_unsigned(control, reg_16, sensor_tx_assignment)
+show_replicated_func_unsigned(control, reg_17, disable)
+show_replicated_func_unsigned(control, reg_17, filter_bandwidth)
+show_replicated_func_unsigned(control, reg_19, stretch_duration)
+show_replicated_func_unsigned(control, reg_38, noise_control_1)
+show_replicated_func_unsigned(control, reg_39, noise_control_2)
+show_replicated_func_unsigned(control, reg_40, noise_control_3)
+
+show_store_replicated_func_unsigned(control, reg_36, axis1_comp)
+show_store_replicated_func_unsigned(control, reg_37, axis2_comp)
+
+static ssize_t synaptics_rmi4_f54_burst_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int retval;
+	int size = 0;
+	unsigned char ii;
+	unsigned char *temp;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	mutex_lock(&f54->control_mutex);
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			f54->control.reg_17->address,
+			(unsigned char *)f54->control.reg_17->data,
+			f54->control.reg_17->length);
+	if (retval < 0) {
+		dev_dbg(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read control reg_17\n",
+				__func__);
+	}
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			f54->control.reg_18->address,
+			(unsigned char *)f54->control.reg_18->data,
+			f54->control.reg_18->length);
+	if (retval < 0) {
+		dev_dbg(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read control reg_18\n",
+				__func__);
+	}
+
+	mutex_unlock(&f54->control_mutex);
+
+	temp = buf;
+
+	for (ii = 0; ii < f54->control.reg_17->length; ii++) {
+		retval = snprintf(temp, PAGE_SIZE - size, "%u ", (1 << 8) *
+			f54->control.reg_17->data[ii].burst_count_b8__10 +
+			f54->control.reg_18->data[ii].burst_count_b0__7);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Faild to write output\n",
+					__func__);
+			return retval;
+		}
+		size += retval;
+		temp += retval;
+	}
+
+	retval = snprintf(temp, PAGE_SIZE - size, "\n");
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Faild to write null terminator\n",
+				__func__);
+		return retval;
+	}
+
+	return size + retval;
+}
+
+static ssize_t synaptics_rmi4_f54_data_read(struct file *data_file,
+		struct kobject *kobj, struct bin_attribute *attributes,
+		char *buf, loff_t pos, size_t count)
+{
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	mutex_lock(&f54->data_mutex);
+
+	if (count < f54->report_size) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Report type %d data size (%d) too large\n",
+				__func__, f54->report_type, f54->report_size);
+		mutex_unlock(&f54->data_mutex);
+		return -EINVAL;
+	}
+
+	if (f54->report_data) {
+		memcpy(buf, f54->report_data, f54->report_size);
+		mutex_unlock(&f54->data_mutex);
+		return f54->report_size;
+	} else {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Report type %d data not available\n",
+				__func__, f54->report_type);
+		mutex_unlock(&f54->data_mutex);
+		return -EINVAL;
+	}
+}
+
+static int synaptics_rmi4_f54_set_sysfs(void)
+{
+	int retval;
+	int reg_num;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	f54->attr_dir = kobject_create_and_add("f54",
+			&rmi4_data->input_dev->dev.kobj);
+	if (!f54->attr_dir) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to create sysfs directory\n",
+				__func__);
+		goto exit_1;
+	}
+
+	retval = sysfs_create_bin_file(f54->attr_dir, &dev_report_data);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to create sysfs bin file\n",
+				__func__);
+		goto exit_2;
+	}
+
+	retval = sysfs_create_group(f54->attr_dir, &attr_group);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to create sysfs attributes\n",
+				__func__);
+		goto exit_3;
+	}
+
+	for (reg_num = 0; reg_num < ARRAY_SIZE(attrs_ctrl_regs); reg_num++) {
+		if (attrs_ctrl_regs_exist[reg_num]) {
+			retval = sysfs_create_group(f54->attr_dir,
+					&attrs_ctrl_regs[reg_num]);
+			if (retval < 0) {
+				dev_err(rmi4_data->pdev->dev.parent,
+						"%s: Failed to create sysfs attributes\n",
+						__func__);
+				goto exit_4;
+			}
+		}
+	}
+
+	return 0;
+
+exit_4:
+	sysfs_remove_group(f54->attr_dir, &attr_group);
+
+	for (reg_num--; reg_num >= 0; reg_num--)
+		sysfs_remove_group(f54->attr_dir, &attrs_ctrl_regs[reg_num]);
+
+exit_3:
+	sysfs_remove_bin_file(f54->attr_dir, &dev_report_data);
+
+exit_2:
+	kobject_put(f54->attr_dir);
+
+exit_1:
+	return -ENODEV;
+}
+
+static int synaptics_rmi4_f54_set_ctrl(void)
+{
+	unsigned char length;
+	unsigned char reg_num = 0;
+	unsigned char num_of_sensing_freqs;
+	unsigned short reg_addr = f54->control_base_addr;
+	struct f54_control *control = &f54->control;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	num_of_sensing_freqs = f54->query.number_of_sensing_frequencies;
+
+	/* control 0 */
+	attrs_ctrl_regs_exist[reg_num] = true;
+	control->reg_0 = kzalloc(sizeof(*(control->reg_0)),
+			GFP_KERNEL);
+	if (!control->reg_0)
+		goto exit_no_mem;
+	control->reg_0->address = reg_addr;
+	reg_addr += sizeof(control->reg_0->data);
+	reg_num++;
+
+	/* control 1 */
+	if ((f54->query.touch_controller_family == 0) ||
+			(f54->query.touch_controller_family == 1)) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_1 = kzalloc(sizeof(*(control->reg_1)),
+				GFP_KERNEL);
+		if (!control->reg_1)
+			goto exit_no_mem;
+		control->reg_1->address = reg_addr;
+		reg_addr += sizeof(control->reg_1->data);
+	}
+	reg_num++;
+
+	/* control 2 */
+	attrs_ctrl_regs_exist[reg_num] = true;
+	control->reg_2 = kzalloc(sizeof(*(control->reg_2)),
+			GFP_KERNEL);
+	if (!control->reg_2)
+		goto exit_no_mem;
+	control->reg_2->address = reg_addr;
+	reg_addr += sizeof(control->reg_2->data);
+	reg_num++;
+
+	/* control 3 */
+	if (f54->query.has_pixel_touch_threshold_adjustment == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_3 = kzalloc(sizeof(*(control->reg_3)),
+				GFP_KERNEL);
+		if (!control->reg_3)
+			goto exit_no_mem;
+		control->reg_3->address = reg_addr;
+		reg_addr += sizeof(control->reg_3->data);
+	}
+	reg_num++;
+
+	/* controls 4 5 6 */
+	if ((f54->query.touch_controller_family == 0) ||
+			(f54->query.touch_controller_family == 1)) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_4__6 = kzalloc(sizeof(*(control->reg_4__6)),
+				GFP_KERNEL);
+		if (!control->reg_4__6)
+			goto exit_no_mem;
+		control->reg_4__6->address = reg_addr;
+		reg_addr += sizeof(control->reg_4__6->data);
+	}
+	reg_num++;
+
+	/* control 7 */
+	if (f54->query.touch_controller_family == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_7 = kzalloc(sizeof(*(control->reg_7)),
+				GFP_KERNEL);
+		if (!control->reg_7)
+			goto exit_no_mem;
+		control->reg_7->address = reg_addr;
+		reg_addr += sizeof(control->reg_7->data);
+	}
+	reg_num++;
+
+	/* controls 8 9 */
+	if ((f54->query.touch_controller_family == 0) ||
+			(f54->query.touch_controller_family == 1)) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_8__9 = kzalloc(sizeof(*(control->reg_8__9)),
+				GFP_KERNEL);
+		if (!control->reg_8__9)
+			goto exit_no_mem;
+		control->reg_8__9->address = reg_addr;
+		reg_addr += sizeof(control->reg_8__9->data);
+	}
+	reg_num++;
+
+	/* control 10 */
+	if (f54->query.has_interference_metric == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_10 = kzalloc(sizeof(*(control->reg_10)),
+				GFP_KERNEL);
+		if (!control->reg_10)
+			goto exit_no_mem;
+		control->reg_10->address = reg_addr;
+		reg_addr += sizeof(control->reg_10->data);
+	}
+	reg_num++;
+
+	/* control 11 */
+	if (f54->query.has_ctrl11 == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_11 = kzalloc(sizeof(*(control->reg_11)),
+				GFP_KERNEL);
+		if (!control->reg_11)
+			goto exit_no_mem;
+		control->reg_11->address = reg_addr;
+		reg_addr += sizeof(control->reg_11->data);
+	}
+	reg_num++;
+
+	/* controls 12 13 */
+	if (f54->query.has_relaxation_control == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_12__13 = kzalloc(sizeof(*(control->reg_12__13)),
+				GFP_KERNEL);
+		if (!control->reg_12__13)
+			goto exit_no_mem;
+		control->reg_12__13->address = reg_addr;
+		reg_addr += sizeof(control->reg_12__13->data);
+	}
+	reg_num++;
+
+	/* controls 14 15 16 */
+	if (f54->query.has_sensor_assignment == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+
+		control->reg_14 = kzalloc(sizeof(*(control->reg_14)),
+				GFP_KERNEL);
+		if (!control->reg_14)
+			goto exit_no_mem;
+		control->reg_14->address = reg_addr;
+		reg_addr += sizeof(control->reg_14->data);
+
+		control->reg_15 = kzalloc(sizeof(*(control->reg_15)),
+				GFP_KERNEL);
+		if (!control->reg_15)
+			goto exit_no_mem;
+		control->reg_15->length = f54->query.num_of_rx_electrodes;
+		control->reg_15->data = kzalloc(control->reg_15->length *
+				sizeof(*(control->reg_15->data)), GFP_KERNEL);
+		if (!control->reg_15->data)
+			goto exit_no_mem;
+		control->reg_15->address = reg_addr;
+		reg_addr += control->reg_15->length;
+
+		control->reg_16 = kzalloc(sizeof(*(control->reg_16)),
+				GFP_KERNEL);
+		if (!control->reg_16)
+			goto exit_no_mem;
+		control->reg_16->length = f54->query.num_of_tx_electrodes;
+		control->reg_16->data = kzalloc(control->reg_16->length *
+				sizeof(*(control->reg_16->data)), GFP_KERNEL);
+		if (!control->reg_16->data)
+			goto exit_no_mem;
+		control->reg_16->address = reg_addr;
+		reg_addr += control->reg_16->length;
+	}
+	reg_num++;
+
+	/* controls 17 18 19 */
+	if (f54->query.has_sense_frequency_control == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+
+		length = num_of_sensing_freqs;
+
+		control->reg_17 = kzalloc(sizeof(*(control->reg_17)),
+				GFP_KERNEL);
+		if (!control->reg_17)
+			goto exit_no_mem;
+		control->reg_17->length = length;
+		control->reg_17->data = kzalloc(length *
+				sizeof(*(control->reg_17->data)), GFP_KERNEL);
+		if (!control->reg_17->data)
+			goto exit_no_mem;
+		control->reg_17->address = reg_addr;
+		reg_addr += length;
+
+		control->reg_18 = kzalloc(sizeof(*(control->reg_18)),
+				GFP_KERNEL);
+		if (!control->reg_18)
+			goto exit_no_mem;
+		control->reg_18->length = length;
+		control->reg_18->data = kzalloc(length *
+				sizeof(*(control->reg_18->data)), GFP_KERNEL);
+		if (!control->reg_18->data)
+			goto exit_no_mem;
+		control->reg_18->address = reg_addr;
+		reg_addr += length;
+
+		control->reg_19 = kzalloc(sizeof(*(control->reg_19)),
+				GFP_KERNEL);
+		if (!control->reg_19)
+			goto exit_no_mem;
+		control->reg_19->length = length;
+		control->reg_19->data = kzalloc(length *
+				sizeof(*(control->reg_19->data)), GFP_KERNEL);
+		if (!control->reg_19->data)
+			goto exit_no_mem;
+		control->reg_19->address = reg_addr;
+		reg_addr += length;
+	}
+	reg_num++;
+
+	/* control 20 */
+	attrs_ctrl_regs_exist[reg_num] = true;
+	control->reg_20 = kzalloc(sizeof(*(control->reg_20)),
+			GFP_KERNEL);
+	if (!control->reg_20)
+		goto exit_no_mem;
+	control->reg_20->address = reg_addr;
+	reg_addr += sizeof(control->reg_20->data);
+	reg_num++;
+
+	/* control 21 */
+	if (f54->query.has_sense_frequency_control == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_21 = kzalloc(sizeof(*(control->reg_21)),
+				GFP_KERNEL);
+		if (!control->reg_21)
+			goto exit_no_mem;
+		control->reg_21->address = reg_addr;
+		reg_addr += sizeof(control->reg_21->data);
+	}
+	reg_num++;
+
+	/* controls 22 23 24 25 26 */
+	if (f54->query.has_firmware_noise_mitigation == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_22__26 = kzalloc(sizeof(*(control->reg_22__26)),
+				GFP_KERNEL);
+		if (!control->reg_22__26)
+			goto exit_no_mem;
+		control->reg_22__26->address = reg_addr;
+		reg_addr += sizeof(control->reg_22__26->data);
+	}
+	reg_num++;
+
+	/* control 27 */
+	if (f54->query.has_iir_filter == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_27 = kzalloc(sizeof(*(control->reg_27)),
+				GFP_KERNEL);
+		if (!control->reg_27)
+			goto exit_no_mem;
+		control->reg_27->address = reg_addr;
+		reg_addr += sizeof(control->reg_27->data);
+	}
+	reg_num++;
+
+	/* control 28 */
+	if (f54->query.has_firmware_noise_mitigation == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_28 = kzalloc(sizeof(*(control->reg_28)),
+				GFP_KERNEL);
+		if (!control->reg_28)
+			goto exit_no_mem;
+		control->reg_28->address = reg_addr;
+		reg_addr += sizeof(control->reg_28->data);
+	}
+	reg_num++;
+
+	/* control 29 */
+	if (f54->query.has_cmn_removal == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_29 = kzalloc(sizeof(*(control->reg_29)),
+				GFP_KERNEL);
+		if (!control->reg_29)
+			goto exit_no_mem;
+		control->reg_29->address = reg_addr;
+		reg_addr += sizeof(control->reg_29->data);
+	}
+	reg_num++;
+
+	/* control 30 */
+	if (f54->query.has_cmn_maximum == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_30 = kzalloc(sizeof(*(control->reg_30)),
+				GFP_KERNEL);
+		if (!control->reg_30)
+			goto exit_no_mem;
+		control->reg_30->address = reg_addr;
+		reg_addr += sizeof(control->reg_30->data);
+	}
+	reg_num++;
+
+	/* control 31 */
+	if (f54->query.has_touch_hysteresis == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_31 = kzalloc(sizeof(*(control->reg_31)),
+				GFP_KERNEL);
+		if (!control->reg_31)
+			goto exit_no_mem;
+		control->reg_31->address = reg_addr;
+		reg_addr += sizeof(control->reg_31->data);
+	}
+	reg_num++;
+
+	/* controls 32 33 34 35 */
+	if (f54->query.has_edge_compensation == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_32__35 = kzalloc(sizeof(*(control->reg_32__35)),
+				GFP_KERNEL);
+		if (!control->reg_32__35)
+			goto exit_no_mem;
+		control->reg_32__35->address = reg_addr;
+		reg_addr += sizeof(control->reg_32__35->data);
+	}
+	reg_num++;
+
+	/* control 36 */
+	if ((f54->query.curve_compensation_mode == 1) ||
+			(f54->query.curve_compensation_mode == 2)) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+
+		if (f54->query.curve_compensation_mode == 1) {
+			length = max(f54->query.num_of_rx_electrodes,
+					f54->query.num_of_tx_electrodes);
+		} else if (f54->query.curve_compensation_mode == 2) {
+			length = f54->query.num_of_rx_electrodes;
+		}
+
+		control->reg_36 = kzalloc(sizeof(*(control->reg_36)),
+				GFP_KERNEL);
+		if (!control->reg_36)
+			goto exit_no_mem;
+		control->reg_36->length = length;
+		control->reg_36->data = kzalloc(length *
+				sizeof(*(control->reg_36->data)), GFP_KERNEL);
+		if (!control->reg_36->data)
+			goto exit_no_mem;
+		control->reg_36->address = reg_addr;
+		reg_addr += length;
+	}
+	reg_num++;
+
+	/* control 37 */
+	if (f54->query.curve_compensation_mode == 2) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+
+		control->reg_37 = kzalloc(sizeof(*(control->reg_37)),
+				GFP_KERNEL);
+		if (!control->reg_37)
+			goto exit_no_mem;
+		control->reg_37->length = f54->query.num_of_tx_electrodes;
+		control->reg_37->data = kzalloc(control->reg_37->length *
+				sizeof(*(control->reg_37->data)), GFP_KERNEL);
+		if (!control->reg_37->data)
+			goto exit_no_mem;
+
+		control->reg_37->address = reg_addr;
+		reg_addr += control->reg_37->length;
+	}
+	reg_num++;
+
+	/* controls 38 39 40 */
+	if (f54->query.has_per_frequency_noise_control == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+
+		control->reg_38 = kzalloc(sizeof(*(control->reg_38)),
+				GFP_KERNEL);
+		if (!control->reg_38)
+			goto exit_no_mem;
+		control->reg_38->length = num_of_sensing_freqs;
+		control->reg_38->data = kzalloc(control->reg_38->length *
+				sizeof(*(control->reg_38->data)), GFP_KERNEL);
+		if (!control->reg_38->data)
+			goto exit_no_mem;
+		control->reg_38->address = reg_addr;
+		reg_addr += control->reg_38->length;
+
+		control->reg_39 = kzalloc(sizeof(*(control->reg_39)),
+				GFP_KERNEL);
+		if (!control->reg_39)
+			goto exit_no_mem;
+		control->reg_39->length = num_of_sensing_freqs;
+		control->reg_39->data = kzalloc(control->reg_39->length *
+				sizeof(*(control->reg_39->data)), GFP_KERNEL);
+		if (!control->reg_39->data)
+			goto exit_no_mem;
+		control->reg_39->address = reg_addr;
+		reg_addr += control->reg_39->length;
+
+		control->reg_40 = kzalloc(sizeof(*(control->reg_40)),
+				GFP_KERNEL);
+		if (!control->reg_40)
+			goto exit_no_mem;
+		control->reg_40->length = num_of_sensing_freqs;
+		control->reg_40->data = kzalloc(control->reg_40->length *
+				sizeof(*(control->reg_40->data)), GFP_KERNEL);
+		if (!control->reg_40->data)
+			goto exit_no_mem;
+		control->reg_40->address = reg_addr;
+		reg_addr += control->reg_40->length;
+	}
+	reg_num++;
+
+	/* control 41 */
+	if (f54->query.has_signal_clarity == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_41 = kzalloc(sizeof(*(control->reg_41)),
+				GFP_KERNEL);
+		if (!control->reg_41)
+			goto exit_no_mem;
+		control->reg_41->address = reg_addr;
+		reg_addr += sizeof(control->reg_41->data);
+	}
+	reg_num++;
+
+	/* control 42 */
+	if (f54->query.has_variance_metric == 1)
+		reg_addr += CONTROL_42_SIZE;
+
+	/* controls 43 44 45 46 47 48 49 50 51 52 53 54 */
+	if (f54->query.has_multi_metric_state_machine == 1)
+		reg_addr += CONTROL_43_54_SIZE;
+
+	/* controls 55 56 */
+	if (f54->query.has_0d_relaxation_control == 1)
+		reg_addr += CONTROL_55_56_SIZE;
+
+	/* control 57 */
+	if (f54->query.has_0d_acquisition_control == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_57 = kzalloc(sizeof(*(control->reg_57)),
+				GFP_KERNEL);
+		if (!control->reg_57)
+			goto exit_no_mem;
+		control->reg_57->address = reg_addr;
+		reg_addr += sizeof(control->reg_57->data);
+	}
+	reg_num++;
+
+	/* control 58 */
+	if (f54->query.has_0d_acquisition_control == 1)
+		reg_addr += CONTROL_58_SIZE;
+
+	/* control 59 */
+	if (f54->query.has_h_blank == 1)
+		reg_addr += CONTROL_59_SIZE;
+
+	/* controls 60 61 62 */
+	if ((f54->query.has_h_blank == 1) ||
+			(f54->query.has_v_blank == 1) ||
+			(f54->query.has_long_h_blank == 1))
+		reg_addr += CONTROL_60_62_SIZE;
+
+	/* control 63 */
+	if ((f54->query.has_h_blank == 1) ||
+			(f54->query.has_v_blank == 1) ||
+			(f54->query.has_long_h_blank == 1) ||
+			(f54->query.has_slew_metric == 1) ||
+			(f54->query.has_slew_option == 1) ||
+			(f54->query.has_noise_mitigation2 == 1))
+		reg_addr += CONTROL_63_SIZE;
+
+	/* controls 64 65 66 67 */
+	if (f54->query.has_h_blank == 1)
+		reg_addr += CONTROL_64_67_SIZE * 7;
+	else if ((f54->query.has_v_blank == 1) ||
+			(f54->query.has_long_h_blank == 1))
+		reg_addr += CONTROL_64_67_SIZE;
+
+	/* controls 68 69 70 71 72 73 */
+	if ((f54->query.has_h_blank == 1) ||
+			(f54->query.has_v_blank == 1) ||
+			(f54->query.has_long_h_blank == 1))
+		reg_addr += CONTROL_68_73_SIZE;
+
+	/* control 74 */
+	if (f54->query.has_slew_metric == 1)
+		reg_addr += CONTROL_74_SIZE;
+
+	/* control 75 */
+	if (f54->query.has_enhanced_stretch == 1)
+		reg_addr += num_of_sensing_freqs;
+
+	/* control 76 */
+	if (f54->query.has_startup_fast_relaxation == 1)
+		reg_addr += CONTROL_76_SIZE;
+
+	/* controls 77 78 */
+	if (f54->query.has_esd_control == 1)
+		reg_addr += CONTROL_77_78_SIZE;
+
+	/* controls 79 80 81 82 83 */
+	if (f54->query.has_noise_mitigation2 == 1)
+		reg_addr += CONTROL_79_83_SIZE;
+
+	/* controls 84 85 */
+	if (f54->query.has_energy_ratio_relaxation == 1)
+		reg_addr += CONTROL_84_85_SIZE;
+
+	/* control 86 */
+	if ((f54->query.has_query13 == 1) && (f54->query.has_ctrl86 == 1))
+		reg_addr += CONTROL_86_SIZE;
+
+	/* control 87 */
+	if ((f54->query.has_query13 == 1) && (f54->query.has_ctrl87 == 1))
+		reg_addr += CONTROL_87_SIZE;
+
+	/* control 88 */
+	if (f54->query.has_ctrl88 == 1) {
+		control->reg_88 = kzalloc(sizeof(*(control->reg_88)),
+				GFP_KERNEL);
+		if (!control->reg_88)
+			goto exit_no_mem;
+		control->reg_88->address = reg_addr;
+		reg_addr += sizeof(control->reg_88->data);
+	}
+
+	return 0;
+
+exit_no_mem:
+	dev_err(rmi4_data->pdev->dev.parent,
+			"%s: Failed to alloc mem for control registers\n",
+			__func__);
+	return -ENOMEM;
+}
+
+static void synaptics_rmi4_f54_status_work(struct work_struct *work)
+{
+	int retval;
+	unsigned char report_index[2];
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	if (f54->status != STATUS_BUSY)
+		return;
+
+	set_report_size();
+	if (f54->report_size == 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Report data size = 0\n",
+				__func__);
+		retval = -EINVAL;
+		goto error_exit;
+	}
+
+	if (f54->data_buffer_size < f54->report_size) {
+		mutex_lock(&f54->data_mutex);
+		if (f54->data_buffer_size)
+			kfree(f54->report_data);
+		f54->report_data = kzalloc(f54->report_size, GFP_KERNEL);
+		if (!f54->report_data) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to alloc mem for data buffer\n",
+					__func__);
+			f54->data_buffer_size = 0;
+			mutex_unlock(&f54->data_mutex);
+			retval = -ENOMEM;
+			goto error_exit;
+		}
+		f54->data_buffer_size = f54->report_size;
+		mutex_unlock(&f54->data_mutex);
+	}
+
+	report_index[0] = 0;
+	report_index[1] = 0;
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			f54->data_base_addr + DATA_REPORT_INDEX_OFFSET,
+			report_index,
+			sizeof(report_index));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to write report data index\n",
+				__func__);
+		retval = -EINVAL;
+		goto error_exit;
+	}
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			f54->data_base_addr + DATA_REPORT_DATA_OFFSET,
+			f54->report_data,
+			f54->report_size);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read report data\n",
+				__func__);
+		retval = -EINVAL;
+		goto error_exit;
+	}
+
+	retval = STATUS_IDLE;
+
+#ifdef RAW_HEX
+	print_raw_hex_report();
+#endif
+
+#ifdef HUMAN_READABLE
+	print_image_report();
+#endif
+
+error_exit:
+	mutex_lock(&f54->status_mutex);
+	f54->status = retval;
+	mutex_unlock(&f54->status_mutex);
+
+	return;
+}
+
+static void synaptics_rmi4_f54_set_regs(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn_desc *fd,
+		unsigned int intr_count,
+		unsigned char page)
+{
+	unsigned char ii;
+	unsigned char intr_offset;
+
+	f54->query_base_addr = fd->query_base_addr | (page << 8);
+	f54->control_base_addr = fd->ctrl_base_addr | (page << 8);
+	f54->data_base_addr = fd->data_base_addr | (page << 8);
+	f54->command_base_addr = fd->cmd_base_addr | (page << 8);
+
+	f54->intr_reg_num = (intr_count + 7) / 8;
+	if (f54->intr_reg_num != 0)
+		f54->intr_reg_num -= 1;
+
+	f54->intr_mask = 0;
+	intr_offset = intr_count % 8;
+	for (ii = intr_offset;
+			ii < ((fd->intr_src_count & MASK_3BIT) +
+			intr_offset);
+			ii++) {
+		f54->intr_mask |= 1 << ii;
+	}
+
+	return;
+}
+
+/*luochangyang for factory_result 2014/04/05*/
+static int _synaptics_rmi4_f54_factory_result_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+//	unsigned long setting = F54_RAW_16BIT_IMAGE;
+	unsigned int ii;
+	int retval = 0;
+	int patience = 10000;
+//	unsigned char command = (unsigned char)COMMAND_GET_REPORT;
+	short report_data;
+	short LOWER_CAPACITY = 1400; //250
+	short UPPER_CAPACITY = 4800; //5500
+	
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	/* before get_report, status must be idle 0
+	    after   get_report, status must be busy 1*/
+
+	/*1. reset*/
+	#if 0
+	dev_info(rmi4_data->pdev->dev.parent, "%s: reset...\n", __func__);
+	retval = rmi4_data->reset_device(rmi4_data);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to issue reset command, error = %d\n",
+				__func__, retval);
+		goto exit_1;
+	}
+	f54->status = STATUS_IDLE;
+	#endif
+	
+	/*2. set report type*/
+	dev_info(rmi4_data->pdev->dev.parent, "%s: set report type...\n", __func__);
+	retval = synaptics_rmi4_f54_report_type_store(dev, attr, "3", 2);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to set report type\n",
+				__func__);
+		retval = -EINVAL;
+		goto exit_1;
+	}
+
+	/*3. get report*/
+	dev_info(rmi4_data->pdev->dev.parent, "%s: get report type...\n", __func__);
+	retval = synaptics_rmi4_f54_get_report_store(dev, attr, "1", 2);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to get report type\n",
+				__func__);
+		retval = -EINVAL;
+		goto exit_1;
+	}
+
+	/*4. get status*/
+	dev_info(rmi4_data->pdev->dev.parent, "%s: get status...\n", __func__);
+	do{
+		if(f54->status == STATUS_IDLE){
+            dev_info(rmi4_data->pdev->dev.parent, "%s:get status == STATUS_IDLE\n", __func__);
+			break;
+          }
+	}while(--patience > 0);   
+    printk("[factory_result]get_status...%d\n",f54->status);
+
+	/*5. read, compare*/
+	dev_info(rmi4_data->pdev->dev.parent, "%s: read...\n", __func__);
+
+	switch (f54->report_type) {
+	case F54_RAW_16BIT_IMAGE:
+                if (f54->report_size == 0) {
+                    dev_err(rmi4_data->pdev->dev.parent,
+                            "%s: ERROR: report_size == 0 \n\n",
+                            __func__);
+                    retval = -EINVAL;
+                    goto exit_1;
+                 }
+                printk("[factory_result] f54->report_size = %d.\n", f54->report_size);
+            
+                if (f54->report_data == NULL) {
+                    dev_err(rmi4_data->pdev->dev.parent,
+                            "%s: ERROR: f54->report_data == NULL \n",
+                            __func__);
+			retval = -EINVAL;
+			goto exit_1;
+		}
+            for (ii = 0; ii < ((f54->report_size)-60); ii += 2) {
+                report_data = f54->report_data[ii] | (f54->report_data[ii + 1] << 8);
+               // printk("[factory_result]read,capacity %03d is %d\n", ii / 2, report_data);
+                if((ii/2)%27 < 24){
+                    if(report_data < LOWER_CAPACITY || report_data > UPPER_CAPACITY){
+                                        printk("[factory_result]read,capacity %03d is wrong...%d\n", ii / 2, report_data);
+                                        retval = -EINVAL;
+                                        goto exit_1;
+                       }
+                }else{
+                    //printk("[factory_result]read,capacity %03d is %d\n", ii / 2, report_data);
+                }
+            }
+		retval = 0;
+		break;
+		default:
+			printk("[factory_result]test type error...type=%d\n",f54->report_type);
+            break;
+	}
+	
+#ifdef RAW_HEX
+		print_raw_hex_report();
+#endif
+	
+#ifdef HUMAN_READABLE
+		print_image_report();
+#endif
+
+exit_1:
+    synaptics_rmi4_f54_resume_touch_store(dev, attr, "1", 2);
+    printk("[factory_result 0] retval = %d\n",retval);
+    return retval;
+    //snprintf(buf, PAGE_SIZE, "%u\n", retval<0?0:1);//0:four bytes;(char)0:one byte
+	//return snprintf(buf, PAGE_SIZE, "%u\n", (char)(retval == 0? 0:1));
+}
+/*luochangyang END*/
+
+/*lixin for factory_result 2014/06/05*/
+static ssize_t synaptics_rmi4_f54_factory_result_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int retval = 0;
+	retval = _synaptics_rmi4_f54_factory_result_show(dev, attr, buf);
+    msleep(2500);
+    retval = _synaptics_rmi4_f54_factory_result_show(dev, attr, buf);
+	printk("[factory_result 1] retval = %d\n",retval);
+	//snprintf(buf, PAGE_SIZE, "%u\n", retval<0?0:1);//0:four bytes;(char)0:one byte
+	return snprintf(buf, PAGE_SIZE, "%u\n", (char)(retval == 0? 0:1));
+}
+/*luochangyang END*/
+
+static void synaptics_rmi5_f55_init(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	unsigned char ii;
+	unsigned char rx_electrodes = f54->query.num_of_rx_electrodes;
+	unsigned char tx_electrodes = f54->query.num_of_tx_electrodes;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			f55->query_base_addr,
+			f55->query.data,
+			sizeof(f55->query.data));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read f55 query registers\n",
+				__func__);
+		return;
+	}
+
+	if (!f55->query.has_sensor_assignment)
+		return;
+
+	f55->rx_assignment = kzalloc(rx_electrodes, GFP_KERNEL);
+	f55->tx_assignment = kzalloc(tx_electrodes, GFP_KERNEL);
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			f55->control_base_addr + SENSOR_RX_MAPPING_OFFSET,
+			f55->rx_assignment,
+			rx_electrodes);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read f55 rx assignment\n",
+				__func__);
+		return;
+	}
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			f55->control_base_addr + SENSOR_TX_MAPPING_OFFSET,
+			f55->tx_assignment,
+			tx_electrodes);
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read f55 tx assignment\n",
+				__func__);
+		return;
+	}
+
+	f54->rx_assigned = 0;
+	for (ii = 0; ii < rx_electrodes; ii++) {
+		if (f55->rx_assignment[ii] != 0xff)
+			f54->rx_assigned++;
+	}
+
+	f54->tx_assigned = 0;
+	for (ii = 0; ii < tx_electrodes; ii++) {
+		if (f55->tx_assignment[ii] != 0xff)
+			f54->tx_assigned++;
+	}
+
+	return;
+}
+
+static void synaptics_rmi4_f55_set_regs(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn_desc *fd,
+		unsigned char page)
+{
+	f55 = kzalloc(sizeof(*f55), GFP_KERNEL);
+	if (!f55) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to alloc mem for f55\n",
+				__func__);
+		return;
+	}
+
+	f55->query_base_addr = fd->query_base_addr | (page << 8);
+	f55->control_base_addr = fd->ctrl_base_addr | (page << 8);
+	f55->data_base_addr = fd->data_base_addr | (page << 8);
+	f55->command_base_addr = fd->cmd_base_addr | (page << 8);
+
+	return;
+}
+
+static void synaptics_rmi4_f54_attn(struct synaptics_rmi4_data *rmi4_data,
+		unsigned char intr_mask)
+{
+	if (!f54)
+		return;
+
+	if (f54->intr_mask & intr_mask) {
+		queue_delayed_work(f54->status_workqueue,
+				&f54->status_work,
+				msecs_to_jiffies(STATUS_WORK_INTERVAL));
+	}
+
+	return;
+}
+
+static int synaptics_rmi4_f54_init(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	unsigned short addr;
+	unsigned char page;
+	unsigned char intr_count = 0;
+	bool f54found = false;
+	bool f55found = false;
+	struct synaptics_rmi4_fn_desc rmi_fd;
+
+	f54 = kzalloc(sizeof(*f54), GFP_KERNEL);
+	if (!f54) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to alloc mem for f54\n",
+				__func__);
+		retval = -ENOMEM;
+		goto exit;
+	}
+
+	f54->rmi4_data = rmi4_data;
+
+	for (page = 0; page < PAGES_TO_SERVICE; page++) {
+		for (addr = PDT_START; addr > PDT_END; addr -= PDT_ENTRY_SIZE) {
+			addr |= (page << 8);
+
+			retval = synaptics_rmi4_reg_read(rmi4_data,
+					addr,
+					(unsigned char *)&rmi_fd,
+					sizeof(rmi_fd));
+			if (retval < 0)
+				goto exit_free_mem;
+
+			addr &= ~(MASK_8BIT << 8);
+
+			if (!rmi_fd.fn_number)
+				break;
+
+			switch (rmi_fd.fn_number) {
+			case SYNAPTICS_RMI4_F54:
+				synaptics_rmi4_f54_set_regs(rmi4_data,
+						&rmi_fd, intr_count, page);
+				f54found = true;
+				break;
+			case SYNAPTICS_RMI4_F55:
+				synaptics_rmi4_f55_set_regs(rmi4_data,
+						&rmi_fd, page);
+				f55found = true;
+				break;
+			default:
+				break;
+			}
+
+			if (f54found && f55found)
+				goto pdt_done;
+
+			intr_count += (rmi_fd.intr_src_count & MASK_3BIT);
+		}
+	}
+
+	if (!f54found) {
+		retval = -ENODEV;
+		goto exit_free_mem;
+	}
+
+pdt_done:
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			f54->query_base_addr,
+			f54->query.data,
+			sizeof(f54->query.data));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read f54 query registers\n",
+				__func__);
+		goto exit_free_mem;
+	}
+
+	f54->rx_assigned = f54->query.num_of_rx_electrodes;
+	f54->tx_assigned = f54->query.num_of_tx_electrodes;
+
+	retval = synaptics_rmi4_f54_set_ctrl();
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to set up f54 control registers\n",
+				__func__);
+		goto exit_free_control;
+	}
+
+	if (f55found)
+		synaptics_rmi5_f55_init(rmi4_data);
+
+	mutex_init(&f54->status_mutex);
+	mutex_init(&f54->data_mutex);
+	mutex_init(&f54->control_mutex);
+
+	retval = synaptics_rmi4_f54_set_sysfs();
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to create sysfs entries\n",
+				__func__);
+		goto exit_sysfs;
+	}
+
+	f54->status_workqueue =
+			create_singlethread_workqueue("f54_status_workqueue");
+	INIT_DELAYED_WORK(&f54->status_work,
+			synaptics_rmi4_f54_status_work);
+
+#ifdef WATCHDOG_HRTIMER
+	/* Watchdog timer to catch unanswered get report commands */
+	hrtimer_init(&f54->watchdog, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	f54->watchdog.function = get_report_timeout;
+
+	/* Work function to do actual cleaning up */
+	INIT_WORK(&f54->timeout_work, timeout_set_status);
+#endif
+
+	f54->status = STATUS_IDLE;
+
+	return 0;
+
+exit_sysfs:
+	kfree(f55->rx_assignment);
+	kfree(f55->tx_assignment);
+
+exit_free_control:
+	free_control_mem();
+
+exit_free_mem:
+	kfree(f55);
+	kfree(f54);
+	f54 = NULL;
+
+exit:
+	return retval;
+}
+
+static void synaptics_rmi4_f54_remove(struct synaptics_rmi4_data *rmi4_data)
+{
+	if (!f54)
+		goto exit;
+
+#ifdef WATCHDOG_HRTIMER
+	hrtimer_cancel(&f54->watchdog);
+#endif
+
+	cancel_delayed_work_sync(&f54->status_work);
+	flush_workqueue(f54->status_workqueue);
+	destroy_workqueue(f54->status_workqueue);
+
+	remove_sysfs();
+
+	kfree(f55->rx_assignment);
+	kfree(f55->tx_assignment);
+
+	free_control_mem();
+
+	kfree(f55);
+
+	if (f54->data_buffer_size)
+		kfree(f54->report_data);
+
+	kfree(f54);
+	f54 = NULL;
+
+exit:
+	complete(&f54_remove_complete);
+
+	return;
+}
+
+static void synaptics_rmi4_f54_reset(struct synaptics_rmi4_data *rmi4_data)
+{
+	if (!f54)
+		return;
+
+	synaptics_rmi4_f54_remove(rmi4_data);
+	synaptics_rmi4_f54_init(rmi4_data);
+
+	return;
+}
+
+static struct synaptics_rmi4_exp_fn f54_module = {
+	.fn_type = RMI_F54,
+	.init = synaptics_rmi4_f54_init,
+	.remove = synaptics_rmi4_f54_remove,
+	.reset = synaptics_rmi4_f54_reset,
+	.reinit = NULL,
+	.early_suspend = NULL,
+	.suspend = NULL,
+	.resume = NULL,
+	.late_resume = NULL,
+	.attn = synaptics_rmi4_f54_attn,
+};
+
+static int __init rmi4_f54_module_init(void)
+{
+	synaptics_rmi4_new_function(&f54_module, true);
+
+	return 0;
+}
+
+static void __exit rmi4_f54_module_exit(void)
+{
+	synaptics_rmi4_new_function(&f54_module, false);
+
+	wait_for_completion(&f54_remove_complete);
+
+	return;
+}
+
+module_init(rmi4_f54_module_init);
+module_exit(rmi4_f54_module_exit);
+
+MODULE_AUTHOR("Synaptics, Inc.");
+MODULE_DESCRIPTION("Synaptics DSX Test Reporting Module");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
old mode 100644
new mode 100755
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
old mode 100644
new mode 100755
diff --git a/drivers/media/platform/msm/camera_v2/Kconfig b/drivers/media/platform/msm/camera_v2/Kconfig
old mode 100644
new mode 100755
index 9fff025..2e8cbbe
--- a/drivers/media/platform/msm/camera_v2/Kconfig
+++ b/drivers/media/platform/msm/camera_v2/Kconfig
@@ -101,6 +101,23 @@ config MSM_ISPIF_V1
           of any CID of MSM_CSI22_HEADER can be routed to of pixel
           or raw data interface in VFE.
 
+config IMX135_Z5S
+	bool "Sensor IMX135_Z5S (BAYER 12M)"
+	depends on MSMB_CAMERA
+	---help---
+		Sony 12 MP Bayer Sensor with auto focus, uses
+		4 mipi lanes, preview config = 2104 x 1560 at 49 fps,
+		snapshot config = 4208 x 3120 at 24 fps,
+		Video HDR support.
+config IMX135_Z5S_069
+	bool "Sensor IMX135_Z5S (BAYER 12M)"
+	depends on MSMB_CAMERA
+	---help---
+		Sony 12 MP Bayer Sensor with auto focus, uses
+		4 mipi lanes, preview config = 2104 x 1560 at 49 fps,
+		snapshot config = 4208 x 3120 at 24 fps,
+		Video HDR support.
+
 config IMX134
 	bool "Sensor IMX134 (BAYER 8M)"
 	depends on MSMB_CAMERA
@@ -137,6 +154,15 @@ config OV5648
 		snapshot set to 2592*1944 at 12 fps,
 		This sensor driver does not support auto focus.
 
+config OV5648_Z5S
+	bool "Sensor OV5648_Z5S (BAYER 5M)"
+	depends on MSMB_CAMERA
+	---help---
+		OmniVision 5 MP Bayer Sensor, only use 1 mipi lane,
+		preview set to 1296*972 at 30 fps,
+		snapshot set to 2592*1944 at 12 fps,
+		This sensor driver does not support auto focus.
+		
 config MT9M114
 	bool "Sensor MT9M114 (YUV 1.26MP)"
 	depends on MSMB_CAMERA
diff --git a/drivers/media/platform/msm/camera_v2/ispif/msm_ispif.c b/drivers/media/platform/msm/camera_v2/ispif/msm_ispif.c
index 3f8f844..5a240a1 100755
--- a/drivers/media/platform/msm/camera_v2/ispif/msm_ispif.c
+++ b/drivers/media/platform/msm/camera_v2/ispif/msm_ispif.c
@@ -41,7 +41,10 @@
 #define ISPIF_INTF_CMD_DISABLE_IMMEDIATELY    0x02
 
 #define ISPIF_TIMEOUT_SLEEP_US                1000
-#define ISPIF_TIMEOUT_ALL_US               1000000
+//#define ISPIF_TIMEOUT_ALL_US               1000000
+ /* ZTEMT: zhangliang Add For SlowShutter ---Begin */
+#define ISPIF_TIMEOUT_ALL_US               1000000000
+ /* ZTEMT: zhangliang Add For SlowShutter ---End */
 
 #undef CDBG
 #ifdef CONFIG_MSMB_CAMERA_DEBUG
diff --git a/drivers/media/platform/msm/camera_v2/sensor/Makefile b/drivers/media/platform/msm/camera_v2/sensor/Makefile
old mode 100644
new mode 100755
index a33cf62..6365592
--- a/drivers/media/platform/msm/camera_v2/sensor/Makefile
+++ b/drivers/media/platform/msm/camera_v2/sensor/Makefile
@@ -5,6 +5,8 @@ ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
 ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/cci
 obj-$(CONFIG_MSMB_CAMERA) += cci/ io/ csiphy/ csid/ actuator/ flash/ eeprom/
 obj-$(CONFIG_MSM_CAMERA_SENSOR) += msm_sensor_init.o msm_sensor_driver.o msm_sensor.o
+obj-$(CONFIG_IMX135_Z5S) += imx135_z5s.o 
+obj-$(CONFIG_IMX135_Z5S_069) += imx135_z5s_069.o 
 obj-$(CONFIG_IMX134) += imx134.o
 obj-$(CONFIG_OV8825) += ov8825.o
 obj-$(CONFIG_OV8865) += ov8865.o
@@ -13,6 +15,7 @@ obj-$(CONFIG_OV12830) += ov12830.o
 obj-$(CONFIG_OV9724) += ov9724.o
 obj-$(CONFIG_HI256) += hi256.o
 obj-$(CONFIG_OV5648) += ov5648.o
+obj-$(CONFIG_OV5648_Z5S) += ov5648_z5s.o
 obj-$(CONFIG_MT9M114) += mt9m114.o
 obj-$(CONFIG_SP1628) += sp1628.o
 obj-$(CONFIG_GC0339) += gc0339.o
diff --git a/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c b/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c
old mode 100644
new mode 100755
index 4f69122..ee27e21
--- a/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c
@@ -27,6 +27,13 @@ DEFINE_MSM_MUTEX(msm_actuator_mutex);
 #define CDBG(fmt, args...) pr_debug(fmt, ##args)
 #endif
 
+/*ZTEMT: Jinghongliang Add for Read AF OTP  ---Start*/
+#ifdef CONFIG_IMX135_Z5S
+extern unsigned short af_start_value;
+extern unsigned short af_infinity_value;
+extern unsigned short af_macro_value;
+#endif
+/*ZTEMT: Jinghongliang Add for Read AF OTP  ---End*/
 
 static int32_t msm_actuator_power_up(struct msm_actuator_ctrl_t *a_ctrl);
 static int32_t msm_actuator_power_down(struct msm_actuator_ctrl_t *a_ctrl);
@@ -98,7 +105,15 @@ static void msm_actuator_parse_i2c_params(struct msm_actuator_ctrl_t *a_ctrl,
 				i2c_byte1 = write_arr[i].reg_addr;
 				i2c_byte2 = value;
 				if (size != (i+1)) {
+#ifdef CONFIG_IMX135_Z5S
+					if (a_ctrl->i2c_client.cci_client->sid == 0x1c >> 1) {
+						i2c_byte2 = (value & 0x0300) >> 8;
+					} else {
+						i2c_byte2 = value & 0xFF;
+					}						
+#else
 					i2c_byte2 = value & 0xFF;
+#endif
 					CDBG("byte1:0x%x, byte2:0x%x\n",
 						i2c_byte1, i2c_byte2);
 					i2c_tbl[a_ctrl->i2c_tbl_index].
@@ -110,7 +125,15 @@ static void msm_actuator_parse_i2c_params(struct msm_actuator_ctrl_t *a_ctrl,
 					a_ctrl->i2c_tbl_index++;
 					i++;
 					i2c_byte1 = write_arr[i].reg_addr;
+#ifdef CONFIG_IMX135_Z5S
+					if (a_ctrl->i2c_client.cci_client->sid == 0x1c >> 1) {
+						i2c_byte2 = value & 0xFF;
+					} else {
+						i2c_byte2 = (value & 0xFF00) >> 8;
+					}
+#else
 					i2c_byte2 = (value & 0xFF00) >> 8;
+#endif
 				}
 			} else {
 				i2c_byte1 = (value & 0xFF00) >> 8;
@@ -407,7 +430,37 @@ static int32_t msm_actuator_init_step_table(struct msm_actuator_ctrl_t *a_ctrl,
 
 	if (a_ctrl->step_position_table == NULL)
 		return -ENOMEM;
-
+#ifdef CONFIG_IMX135_Z5S
+	if ((set_info->actuator_params.i2c_addr != 0x1c) && (set_info->actuator_params.i2c_addr != 0x48)) {
+		cur_code = set_info->af_tuning_params.initial_code;
+		a_ctrl->step_position_table[step_index++] = cur_code;
+		for (region_index = 0;
+			region_index < a_ctrl->region_size;
+			region_index++) {
+			code_per_step =
+				a_ctrl->region_params[region_index].code_per_step;
+			step_boundary =
+				a_ctrl->region_params[region_index].
+				step_bound[MOVE_NEAR];
+			for (; step_index <= step_boundary;
+				step_index++) {
+				cur_code += code_per_step;
+				if (cur_code < max_code_size)
+					a_ctrl->step_position_table[step_index] =
+						cur_code;
+				else {
+					for (; step_index <
+						set_info->af_tuning_params.total_steps;
+						step_index++)
+						a_ctrl->
+							step_position_table[
+							step_index] =
+							max_code_size;
+				}
+			}
+		}
+	}
+#else
 	cur_code = set_info->af_tuning_params.initial_code;
 	a_ctrl->step_position_table[step_index++] = cur_code;
 	for (region_index = 0;
@@ -435,6 +488,12 @@ static int32_t msm_actuator_init_step_table(struct msm_actuator_ctrl_t *a_ctrl,
 			}
 		}
 	}
+#endif
+
+	//for(i=0;i<set_info->af_tuning_params.total_steps;i++)
+	// printk("%s:jun] table[%d]=%d\n",__func__, i,a_ctrl->step_position_table[i]);
+
+	/*ZTEMT: Jinghongliang Add for Read AF OTP	---end*/
 	CDBG("Exit\n");
 	return 0;
 }
@@ -444,10 +503,25 @@ static int32_t msm_actuator_set_default_focus(
 	struct msm_actuator_move_params_t *move_params)
 {
 	int32_t rc = 0;
+	//int32_t step_boundary= a_ctrl->region_params[0].step_bound[MOVE_NEAR];
 	CDBG("Enter\n");
+	
+	#if 0  //jun add for avoid click sound when exit from camera
+	pr_err("%s[jun]Enter, step_boundary=%d,\n",__func__,step_boundary);
+	if (a_ctrl->curr_step_pos != 0) {
+		move_params->dest_step_pos = step_boundary;
+		rc = a_ctrl->func_tbl->actuator_move_focus(a_ctrl, move_params);
+		//mdelay(10);
+		move_params->dest_step_pos = 0;
+		rc = a_ctrl->func_tbl->actuator_move_focus(a_ctrl, move_params);
+		}
+	pr_err("%s[jun]Exit\n",__func__);
+	#else
 
 	if (a_ctrl->curr_step_pos != 0)
 		rc = a_ctrl->func_tbl->actuator_move_focus(a_ctrl, move_params);
+	#endif
+	
 	CDBG("Exit\n");
 	return rc;
 }
@@ -786,7 +860,7 @@ static int msm_actuator_open(struct v4l2_subdev *sd,
 	struct v4l2_subdev_fh *fh) {
 	int rc = 0;
 	struct msm_actuator_ctrl_t *a_ctrl =  v4l2_get_subdevdata(sd);
-	CDBG("Enter\n");
+	pr_err("Enter\n");
 	if (!a_ctrl) {
 		pr_err("failed\n");
 		return -EINVAL;
@@ -797,7 +871,7 @@ static int msm_actuator_open(struct v4l2_subdev *sd,
 		if (rc < 0)
 			pr_err("cci_init failed\n");
 	}
-	CDBG("Exit\n");
+	pr_err("Exit\n");
 	return rc;
 }
 
diff --git a/drivers/media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c b/drivers/media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c
old mode 100644
new mode 100755
diff --git a/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_torch.c b/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_torch.c
old mode 100644
new mode 100755
index ff63696..12feadd
--- a/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_torch.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_torch.c
@@ -25,7 +25,7 @@ static void msm_led_torch_brightness_set(struct led_classdev *led_cdev,
 		pr_err("No torch trigger found, can't set brightness\n");
 		return;
 	}
-
+	printk("lonely led test\n");
 	led_trigger_event(torch_trigger, value);
 };
 
diff --git a/drivers/media/platform/msm/camera_v2/sensor/imx135.c b/drivers/media/platform/msm/camera_v2/sensor/imx135.c
old mode 100644
new mode 100755
index c26e4ff..649575e
--- a/drivers/media/platform/msm/camera_v2/sensor/imx135.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/imx135.c
@@ -19,16 +19,17 @@ static struct msm_sensor_ctrl_t imx135_s_ctrl;
 static struct msm_sensor_power_setting imx135_power_setting[] = {
 	{
 		.seq_type = SENSOR_VREG,
-		.seq_val = CAM_VDIG,
+		.seq_val = 0,
 		.config_val = 0,
 		.delay = 0,
 	},
 	{
 		.seq_type = SENSOR_VREG,
-		.seq_val = CAM_VANA,
+		.seq_val = 1,
 		.config_val = 0,
 		.delay = 0,
 	},
+#if 0
 	{
 		.seq_type = SENSOR_VREG,
 		.seq_val = CAM_VIO,
@@ -41,6 +42,7 @@ static struct msm_sensor_power_setting imx135_power_setting[] = {
 		.config_val = 0,
 		.delay = 0,
 	},
+#endif
 	{
 		.seq_type = SENSOR_GPIO,
 		.seq_val = SENSOR_GPIO_RESET,
diff --git a/drivers/media/platform/msm/camera_v2/sensor/imx135_z5s.c b/drivers/media/platform/msm/camera_v2/sensor/imx135_z5s.c
new file mode 100755
index 0000000..ba32cf4
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/imx135_z5s.c
@@ -0,0 +1,181 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include "msm_sensor.h"
+#define IMX135_SENSOR_NAME "imx135_z5s"
+DEFINE_MSM_MUTEX(imx135_mut);
+
+static struct msm_sensor_ctrl_t imx135_s_ctrl;
+
+static struct msm_sensor_power_setting imx135_power_setting[] = {
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VDIG,
+		.config_val = 0,
+		.delay = 0,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VANA,    // This VREG is DRV_AVDD, it can enbale the IMX135's AVDD
+		.config_val = 0,
+		.delay = 0,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VIO,
+		.config_val = 0,
+		.delay = 0,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VAF,
+		.config_val = 0,
+ 		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 30,
+	},
+ 	 #ifdef CONFIG_IMX135_Z5S
+        {
+ 		.seq_type = SENSOR_GPIO,
+ 		.seq_val = SENSOR_GPIO_STANDBY,
+ 		.config_val = GPIO_OUT_HIGH,
+ 		.delay = 5,
+ 	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_LOW,
+ 		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_HIGH,
+ 		.delay = 5,
+	},
+ 	#endif
+	{
+		.seq_type = SENSOR_CLK,
+		.seq_val = SENSOR_CAM_MCLK,
+		.config_val = 24000000,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_I2C_MUX,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+};
+
+static struct v4l2_subdev_info imx135_subdev_info[] = {
+	{
+		.code = V4L2_MBUS_FMT_SBGGR10_1X10,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.fmt = 1,
+		.order = 0,
+	},
+};
+
+static const struct i2c_device_id imx135_i2c_id[] = {
+	{IMX135_SENSOR_NAME, (kernel_ulong_t)&imx135_s_ctrl},
+	{ }
+};
+
+static int32_t msm_imx135_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	return msm_sensor_i2c_probe(client, id, &imx135_s_ctrl);
+}
+
+static struct i2c_driver imx135_i2c_driver = {
+	.id_table = imx135_i2c_id,
+	.probe  = msm_imx135_i2c_probe,
+	.driver = {
+		.name = IMX135_SENSOR_NAME,
+	},
+};
+
+static struct msm_camera_i2c_client imx135_sensor_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+};
+
+static const struct of_device_id imx135_dt_match[] = {
+	{.compatible = "qcom,imx135_z5s", .data = &imx135_s_ctrl},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, imx135_dt_match);
+
+static struct platform_driver imx135_platform_driver = {
+	.driver = {
+		.name = "qcom,imx135_z5s",
+		.owner = THIS_MODULE,
+		.of_match_table = imx135_dt_match,
+	},
+};
+
+static int32_t imx135_platform_probe(struct platform_device *pdev)
+{
+	int32_t rc = 0;
+	const struct of_device_id *match;
+	match = of_match_device(imx135_dt_match, &pdev->dev);
+	rc = msm_sensor_platform_probe(pdev, match->data);
+	return rc;
+}
+
+static int __init imx135_z5s_init_module(void)
+{
+	int32_t rc = 0;
+	pr_info("%s:%d\n", __func__, __LINE__);
+	rc = platform_driver_probe(&imx135_platform_driver,
+		imx135_platform_probe);
+	if (!rc)
+		return rc;
+	pr_err("%s:%d rc %d\n", __func__, __LINE__, rc);
+	return i2c_add_driver(&imx135_i2c_driver);
+}
+
+static void __exit imx135_z5s_exit_module(void)
+{
+	pr_info("%s:%d\n", __func__, __LINE__);
+	if (imx135_s_ctrl.pdev) {
+		msm_sensor_free_sensor_data(&imx135_s_ctrl);
+		platform_driver_unregister(&imx135_platform_driver);
+	} else
+		i2c_del_driver(&imx135_i2c_driver);
+	return;
+}
+
+static struct msm_sensor_ctrl_t imx135_s_ctrl = {
+	.sensor_i2c_client = &imx135_sensor_i2c_client,
+	.power_setting_array.power_setting = imx135_power_setting,
+	.power_setting_array.size = ARRAY_SIZE(imx135_power_setting),
+	.msm_sensor_mutex = &imx135_mut,
+	.sensor_v4l2_subdev_info = imx135_subdev_info,
+	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(imx135_subdev_info),
+};
+
+module_init(imx135_z5s_init_module);
+module_exit(imx135_z5s_exit_module);
+MODULE_DESCRIPTION("imx135");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/msm/camera_v2/sensor/imx135_z5s_069.c b/drivers/media/platform/msm/camera_v2/sensor/imx135_z5s_069.c
new file mode 100755
index 0000000..905d081
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/imx135_z5s_069.c
@@ -0,0 +1,181 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include "msm_sensor.h"
+#define IMX135_SENSOR_NAME "imx135_z5s_069"
+DEFINE_MSM_MUTEX(imx135_mut);
+
+static struct msm_sensor_ctrl_t imx135_s_ctrl;
+
+static struct msm_sensor_power_setting imx135_power_setting[] = {
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VDIG,
+		.config_val = 0,
+		.delay = 0,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VANA,    // This VREG is DRV_AVDD, it can enbale the IMX135's AVDD
+		.config_val = 0,
+		.delay = 0,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VIO,
+		.config_val = 0,
+		.delay = 0,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VAF,
+		.config_val = 0,
+ 		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 30,
+	},
+ 	 #ifdef CONFIG_ZTEMT_CAMERA_OIS
+        {
+ 		.seq_type = SENSOR_GPIO,
+ 		.seq_val = SENSOR_GPIO_STANDBY,
+ 		.config_val = GPIO_OUT_HIGH,
+ 		.delay = 5,
+ 	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_LOW,
+ 		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_HIGH,
+ 		.delay = 5,
+	},
+ 	#endif
+	{
+		.seq_type = SENSOR_CLK,
+		.seq_val = SENSOR_CAM_MCLK,
+		.config_val = 24000000,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_I2C_MUX,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+};
+
+static struct v4l2_subdev_info imx135_subdev_info[] = {
+	{
+		.code = V4L2_MBUS_FMT_SBGGR10_1X10,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.fmt = 1,
+		.order = 0,
+	},
+};
+
+static const struct i2c_device_id imx135_i2c_id[] = {
+	{IMX135_SENSOR_NAME, (kernel_ulong_t)&imx135_s_ctrl},
+	{ }
+};
+
+static int32_t msm_imx135_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	return msm_sensor_i2c_probe(client, id, &imx135_s_ctrl);
+}
+
+static struct i2c_driver imx135_i2c_driver = {
+	.id_table = imx135_i2c_id,
+	.probe  = msm_imx135_i2c_probe,
+	.driver = {
+		.name = IMX135_SENSOR_NAME,
+	},
+};
+
+static struct msm_camera_i2c_client imx135_sensor_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+};
+
+static const struct of_device_id imx135_dt_match[] = {
+	{.compatible = "qcom,imx135_z5s_069", .data = &imx135_s_ctrl},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, imx135_dt_match);
+
+static struct platform_driver imx135_z5s_069_platform_driver = {
+	.driver = {
+		.name = "qcom,imx135_z5s_069",
+		.owner = THIS_MODULE,
+		.of_match_table = imx135_dt_match,
+	},
+};
+
+static int32_t imx135_platform_probe(struct platform_device *pdev)
+{
+	int32_t rc = 0;
+	const struct of_device_id *match;
+	match = of_match_device(imx135_dt_match, &pdev->dev);
+	rc = msm_sensor_platform_probe(pdev, match->data);
+	return rc;
+}
+
+static int __init imx135_z5s_069_init_module(void)
+{
+	int32_t rc = 0;
+	pr_info("%s:%d\n", __func__, __LINE__);
+	rc = platform_driver_probe(&imx135_z5s_069_platform_driver,
+		imx135_platform_probe);
+	if (!rc)
+		return rc;
+	pr_err("%s:%d rc %d\n", __func__, __LINE__, rc);
+	return i2c_add_driver(&imx135_i2c_driver);
+}
+
+static void __exit imx135_z5s_069_exit_module(void)
+{
+	pr_info("%s:%d\n", __func__, __LINE__);
+	if (imx135_s_ctrl.pdev) {
+		msm_sensor_free_sensor_data(&imx135_s_ctrl);
+		platform_driver_unregister(&imx135_z5s_069_platform_driver);
+	} else
+		i2c_del_driver(&imx135_i2c_driver);
+	return;
+}
+
+static struct msm_sensor_ctrl_t imx135_s_ctrl = {
+	.sensor_i2c_client = &imx135_sensor_i2c_client,
+	.power_setting_array.power_setting = imx135_power_setting,
+	.power_setting_array.size = ARRAY_SIZE(imx135_power_setting),
+	.msm_sensor_mutex = &imx135_mut,
+	.sensor_v4l2_subdev_info = imx135_subdev_info,
+	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(imx135_subdev_info),
+};
+
+module_init(imx135_z5s_069_init_module);
+module_exit(imx135_z5s_069_exit_module);
+MODULE_DESCRIPTION("imx135");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c b/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c
old mode 100644
new mode 100755
diff --git a/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c b/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c
old mode 100644
new mode 100755
index c321a68..284dd23
--- a/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c
@@ -15,6 +15,7 @@
 #include "msm_camera_io_util.h"
 #include "msm_camera_i2c_mux.h"
 #include "msm_cci.h"
+#include "../msm_sensor.h"
 
 /*#define CONFIG_MSM_CAMERA_DT_DEBUG*/
 #undef CDBG
@@ -1054,7 +1055,8 @@ int msm_camera_power_up(struct msm_camera_power_ctrl_t *ctrl,
 				(power_setting->delay * 1000) + 1000);
 		}
 	}
-
+#if defined(CONFIG_IMX135_Z5S_069) || defined(CONFIG_IMX135_Z5S)
+#else
 	if (device_type == MSM_CAMERA_PLATFORM_DEVICE) {
 		rc = sensor_i2c_client->i2c_func_tbl->i2c_util(
 			sensor_i2c_client, MSM_CCI_INIT);
@@ -1063,11 +1065,18 @@ int msm_camera_power_up(struct msm_camera_power_ctrl_t *ctrl,
 			goto power_up_failed;
 		}
 	}
-
+#endif
 	CDBG("%s exit\n", __func__);
 	return 0;
 power_up_failed:
 	pr_err("%s:%d failed\n", __func__, __LINE__);
+#if defined(CONFIG_IMX135_Z5S_069) || defined(CONFIG_IMX135_Z5S)
+#else
+	/*if (device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+		sensor_i2c_client->i2c_func_tbl->i2c_util(
+			sensor_i2c_client, MSM_CCI_RELEASE);
+	}*/
+#endif
 	for (index--; index >= 0; index--) {
 		CDBG("%s index %d\n", __func__, index);
 		power_setting = &ctrl->power_setting[index];
@@ -1192,8 +1201,7 @@ int msm_camera_power_down(struct msm_camera_power_ctrl_t *ctrl,
 			gpio_set_value_cansleep(
 				ctrl->gpio_conf->gpio_num_info->gpio_num
 				[pd->seq_val],
-				ctrl->gpio_conf->gpio_num_info->gpio_num
-				[pd->config_val]);
+				pd->config_val);
 			break;
 		case SENSOR_VREG:
 			if (pd->seq_val >= CAM_VREG_MAX) {
@@ -1207,11 +1215,12 @@ int msm_camera_power_down(struct msm_camera_power_ctrl_t *ctrl,
 						pd->seq_type,
 						pd->seq_val);
 
-			if (ps)
+			if (ps) {
 				msm_camera_config_single_vreg(ctrl->dev,
 					&ctrl->cam_vreg[pd->seq_val],
 					(struct regulator **)&ps->data[0],
 					0);
+			}
 			else
 				pr_err("%s error in power up/down seq data\n",
 								__func__);
diff --git a/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h b/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h
old mode 100644
new mode 100755
diff --git a/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h b/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h
old mode 100644
new mode 100755
diff --git a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.c b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.c
index b4375cd..6cd66a3 100755
--- a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.c
@@ -396,6 +396,30 @@ static struct msm_cam_clk_info cam_8974_clk_info[] = {
 	[SENSOR_CAM_CLK] = {"cam_clk", 0},
 };
 
+#if defined(CONFIG_IMX135_Z5S_069) ||defined(CONFIG_IMX135_Z5S)
+int temp_i2c_data_type = 0 ;
+static int RegRead8byte_adaptive(uint16_t reg_addr, struct msm_sensor_ctrl_t *s_ctrl)
+{
+	uint8_t data[8];
+	int32_t rc=0;
+	enum msm_camera_i2c_reg_addr_type addr_type;
+	addr_type = s_ctrl->sensor_i2c_client->addr_type;
+	memset(data, 0x00, 8);
+	s_ctrl->sensor_i2c_client->addr_type = MSM_CAMERA_I2C_BYTE_ADDR;
+
+	rc =  s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_read_seq
+	 (
+		s_ctrl->sensor_i2c_client,
+		reg_addr, &data[0],
+		8);
+	if (rc < 0) {
+		pr_err("%s: line %d rc = %d\n", __func__, __LINE__, rc);
+	}
+	s_ctrl->sensor_i2c_client->addr_type = addr_type;
+	CDBG("sss %x %x %x %x\n", data[0],data[1],data[2],data[3]);
+	return rc;
+}
+#endif
 int msm_sensor_power_down(struct msm_sensor_ctrl_t *s_ctrl)
 {
 	struct msm_camera_power_ctrl_t *power_info;
@@ -452,12 +476,65 @@ int msm_sensor_power_up(struct msm_sensor_ctrl_t *s_ctrl)
 		sensor_i2c_client);
 	if (rc < 0)
 		return rc;
+	
+#if defined(CONFIG_IMX135_Z5S_069) ||defined(CONFIG_IMX135_Z5S)
+      if (!strncmp(s_ctrl->sensordata->sensor_name, "imx135_z5s", 32)) {
+		s_ctrl->sensor_i2c_client->cci_client->sid = 0x1c >> 1;
+		if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+			rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+				s_ctrl->sensor_i2c_client, MSM_CCI_INIT);
+			if (rc < 0) {
+				pr_err("%s cci_init failed\n", __func__);
+				goto power_up_failed;
+			}
+		}
+		rc = RegRead8byte_adaptive(0x02, s_ctrl);
+		if (rc < 0) {
+				pr_err("%s cci_init failed\n", __func__);
+				goto power_up_failed;
+		}
+		if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+			s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+				s_ctrl->sensor_i2c_client, MSM_CCI_RELEASE);
+		}
+		s_ctrl->sensor_i2c_client->cci_client->sid = s_ctrl->sensordata->slave_info->sensor_slave_addr >> 1;
+	}
+       if (!strncmp(s_ctrl->sensordata->sensor_name, "imx135_z5s_069", 32)) {
+		s_ctrl->sensor_i2c_client->cci_client->sid = 0x18 >> 1;
+		if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+			rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+				s_ctrl->sensor_i2c_client, MSM_CCI_INIT);
+			if (rc < 0) {
+				pr_err("%s cci_init failed\n", __func__);
+				goto power_up_failed;
+			}
+		}
+		rc = RegRead8byte_adaptive(0x94, s_ctrl);
+		if (rc < 0) {
+				pr_err("%s cci_init failed\n", __func__);
+				goto power_up_failed;
+		}
+		if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+			s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+				s_ctrl->sensor_i2c_client, MSM_CCI_RELEASE);
+		}
+		s_ctrl->sensor_i2c_client->cci_client->sid = s_ctrl->sensordata->slave_info->sensor_slave_addr >> 1;
+	}
+		
+#endif
+
 	rc = msm_sensor_check_id(s_ctrl);
 	if (rc < 0)
 		msm_camera_power_down(power_info, s_ctrl->sensor_device_type,
 					sensor_i2c_client);
 
 	return rc;
+#if defined(CONFIG_IMX135_Z5S_069) ||defined(CONFIG_IMX135_Z5S)
+	power_up_failed:	
+		msm_camera_power_down(power_info, s_ctrl->sensor_device_type,
+			sensor_i2c_client);
+	return -1;
+#endif
 }
 
 int msm_sensor_match_id(struct msm_sensor_ctrl_t *s_ctrl)
@@ -1035,6 +1112,52 @@ int msm_sensor_config(struct msm_sensor_ctrl_t *s_ctrl, void __user *argp)
 		}
 		break;
 	}
+	/* ZTEMT: Jinghongliang Add for Manual AF Mode ----Start */
+	case CFG_SET_MANUAL_AF_ZTEMT: {
+			int32_t value = 0;
+			int32_t lens_position = 0;
+			uint16_t MSB = 0;
+			uint16_t LSB = 0;
+			uint16_t addr = 0;
+			uint16_t data = 0;
+			if(copy_from_user(&value,
+				(void *)cdata->cfg.setting,sizeof(int32_t))){
+				pr_err("%s:%d failed\n", __func__, __LINE__);
+				rc = -EFAULT;
+			break;
+			}else{
+				printk("<ZTEMT_CAM> Manual AF value = %d \n",value);
+				if(value < 0 || value > 79){     /* if over total steps*/
+					break;
+				}
+				
+				if(value < 5){
+					lens_position = 100+10*value;
+				}else{
+				    lens_position = 140 + 7*(value-4);
+				}
+				if(value == 79)
+					lens_position = 900;   /* push the VCM to Macro position*/
+
+				MSB = ( lens_position & 0x0300 ) >> 8;
+				LSB = lens_position & 0xFF;
+				lens_position = lens_position | 0xF400;
+				addr = (lens_position & 0xFF00) >> 8;
+				data = lens_position & 0xFF;
+				printk("<<<ZTEMT_JHL>>> This sensor not support Manual AF\n");
+			}
+		break;
+	  }
+	/* ZTEMT: Jinghongliang Add for Manual AF Mode ----End */
+	//	#ifdef CONFIG_ZTEMT_CAMERA_OIS   //ZTEMT CAMERA FOR OIS MENU ----START
+    case CFG_ENABLE_OIS: {
+		break;
+	}
+
+    case CFG_DISABLE_OIS: {
+		break;
+	}
+
 	default:
 		rc = -EFAULT;
 		break;
@@ -1114,6 +1237,10 @@ static struct msm_camera_i2c_fn_t msm_sensor_cci_func_tbl = {
 		msm_camera_cci_i2c_write_table_w_microdelay,
 	.i2c_util = msm_sensor_cci_i2c_util,
 	.i2c_write_conf_tbl = msm_camera_cci_i2c_write_conf_tbl,
+#ifdef CONFIG_IMX135_Z5S
+	.i2c_write_seq = msm_camera_cci_i2c_write_seq,
+#endif
+
 };
 
 static struct msm_camera_i2c_fn_t msm_sensor_qup_func_tbl = {
diff --git a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.h b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.h
old mode 100644
new mode 100755
diff --git a/drivers/media/platform/msm/camera_v2/sensor/ov5648_z5s.c b/drivers/media/platform/msm/camera_v2/sensor/ov5648_z5s.c
new file mode 100755
index 0000000..c8c0bbc
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/ov5648_z5s.c
@@ -0,0 +1,175 @@
+
+
+ 
+ /* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 and
+  * only version 2 as published by the Free Software Foundation.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  */
+ #include "msm_sensor.h"
+ #define OV5648_SENSOR_NAME "ov5648_z5s"
+ DEFINE_MSM_MUTEX(ov5648_mut);
+ 
+ static struct msm_sensor_ctrl_t ov5648_s_ctrl;
+ 
+ static struct msm_sensor_power_setting ov5648_power_setting[] = {
+       {
+ 		.seq_type = SENSOR_VREG,
+ 		.seq_val = CAM_VIO,
+ 		.config_val = 0,
+ 		.delay = 0,
+ 	},
+
+       
+		
+ 	{
+ 		.seq_type = SENSOR_VREG,
+ 		.seq_val = CAM_VANA,
+ 		.config_val = 0,
+ 		.delay = 0,
+ 	},
+
+        
+        {
+ 		.seq_type = SENSOR_GPIO,
+ 		.seq_val = SENSOR_GPIO_STANDBY,
+ 		.config_val = GPIO_OUT_LOW,
+ 		.delay = 6,
+ 	},
+
+ 	{
+ 		.seq_type = SENSOR_GPIO,
+ 		.seq_val = SENSOR_GPIO_STANDBY,
+ 		.config_val = GPIO_OUT_HIGH,
+ 		.delay = 30,
+ 	},
+ 	
+ 	{
+ 		.seq_type = SENSOR_GPIO,
+ 		.seq_val = SENSOR_GPIO_RESET,
+ 		.config_val = GPIO_OUT_LOW,
+ 		.delay = 1,
+ 	},
+ 	{
+ 		.seq_type = SENSOR_GPIO,
+ 		.seq_val = SENSOR_GPIO_RESET,
+ 		.config_val = GPIO_OUT_HIGH,
+ 		.delay = 30,
+ 	},
+ 	
+ 	
+ 	{
+ 		.seq_type = SENSOR_CLK,
+ 		.seq_val = SENSOR_CAM_MCLK,
+ 		.config_val = 0,
+ 		.delay = 1,
+ 	},
+ 	{
+ 		.seq_type = SENSOR_I2C_MUX,
+ 		.seq_val = 0,
+ 		.config_val = 0,
+ 		.delay = 0,
+ 	},
+ };
+ 
+ static struct v4l2_subdev_info ov5648_subdev_info[] = {
+ 	{
+ 		.code = V4L2_MBUS_FMT_SBGGR10_1X10,
+ 		.colorspace = V4L2_COLORSPACE_JPEG,
+ 		.fmt = 1,
+ 		.order = 0,
+ 	},
+ };
+ 
+ static const struct i2c_device_id ov5648_i2c_id[] = {
+ 	{OV5648_SENSOR_NAME, (kernel_ulong_t)&ov5648_s_ctrl},
+ 	{ }
+ };
+
+static int32_t msm_ov5648_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	return msm_sensor_i2c_probe(client, id, &ov5648_s_ctrl);
+}
+ 
+ static struct i2c_driver ov5648_i2c_driver = {
+ 	.id_table = ov5648_i2c_id,
+ 	.probe  = msm_ov5648_i2c_probe,
+ 	.driver = {
+ 		.name = OV5648_SENSOR_NAME,
+ 	},
+ };
+ 
+ static struct msm_camera_i2c_client ov5648_sensor_i2c_client = {
+ 	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+ };
+ 
+ static const struct of_device_id ov5648_dt_match[] = {
+ 	{.compatible = "qcom,ov5648_z5s", .data = &ov5648_s_ctrl},
+ 	{}
+ };
+ 
+ MODULE_DEVICE_TABLE(of, ov5648_dt_match);
+ 
+ static struct platform_driver ov5648_platform_driver = {
+ 	.driver = {
+ 		.name = "qcom,ov5648_z5s",
+ 		.owner = THIS_MODULE,
+ 		.of_match_table = ov5648_dt_match,
+ 	},
+ };
+ 
+ static int32_t ov5648_platform_probe(struct platform_device *pdev)
+ {
+ 	int32_t rc = 0;
+ 	const struct of_device_id *match;
+ 	match = of_match_device(ov5648_dt_match, &pdev->dev);
+ 	rc = msm_sensor_platform_probe(pdev, match->data);
+ 	return rc;
+ }
+ 
+ static int __init ov5648_init_module(void)
+ {
+ 	int32_t rc = 0;
+ 	pr_info("%s:%d\n", __func__, __LINE__);
+ 	rc = platform_driver_probe(&ov5648_platform_driver,
+ 		ov5648_platform_probe);
+ 	if (!rc)
+ 		return rc;
+ 	pr_err("%s:%d rc %d\n", __func__, __LINE__, rc);
+ 	return i2c_add_driver(&ov5648_i2c_driver);
+ }
+ 
+ static void __exit ov5648_exit_module(void)
+ {
+ 	pr_info("%s:%d\n", __func__, __LINE__);
+ 	if (ov5648_s_ctrl.pdev) {
+ 		msm_sensor_free_sensor_data(&ov5648_s_ctrl);
+ 		platform_driver_unregister(&ov5648_platform_driver);
+ 	} else
+ 		i2c_del_driver(&ov5648_i2c_driver);
+ 	return;
+ }
+ 
+ static struct msm_sensor_ctrl_t ov5648_s_ctrl = {
+ 	.sensor_i2c_client = &ov5648_sensor_i2c_client,
+ 	.power_setting_array.power_setting = ov5648_power_setting,
+ 	.power_setting_array.size = ARRAY_SIZE(ov5648_power_setting),
+ 	.msm_sensor_mutex = &ov5648_mut,
+ 	.sensor_v4l2_subdev_info = ov5648_subdev_info,
+ 	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(ov5648_subdev_info),
+ };
+ 
+ module_init(ov5648_init_module);
+ module_exit(ov5648_exit_module);
+ MODULE_DESCRIPTION("ov5648");
+ MODULE_LICENSE("GPL v2");
+
+
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
old mode 100644
new mode 100755
index a7932ba..ee8013e
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -665,6 +665,28 @@ config TI_DRV2667
 	  To compile this driver as a module, choose M here: the
 	  module will be called ti_drv2667.
 
+menuconfig ZTEMT_VIBRATOR
+	bool "ZTEMT VIBRATOR"
+	default y
+
+if ZTEMT_VIBRATOR
+
+config ZTEMT_HAPTICS_DRV2605
+	tristate "HAPTICS Support for Texas Instruments DRV2605"
+	depends on I2C
+	default n
+	help
+	  This option enables support for on-chip drv2605 drivers.
+
+config ZTEMT_HAPTICS_DRV2605_DRIVE_ERM
+	bool "HAPTICS Support for DRV2605 driving ERM"
+	depends on ZTEMT_HAPTICS_DRV2605
+	default n
+	help
+	  Say 'y' here to drive ERM rather than LRA using drv2605.
+
+endif
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
old mode 100644
new mode 100755
index 760f768..7c309e7
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -70,3 +70,4 @@ obj-$(CONFIG_QSEECOM) += qseecom.o
 obj-$(CONFIG_QFP_FUSE) += qfp_fuse.o
 obj-$(CONFIG_TI_DRV2667) += ti_drv2667.o
 obj-$(CONFIG_QPNP_MISC) += qpnp-misc.o
+obj-$(CONFIG_ZTEMT_HAPTICS_DRV2605) += drv2605.o
diff --git a/drivers/misc/drv2605.c b/drivers/misc/drv2605.c
new file mode 100755
index 0000000..89cb4a0
--- /dev/null
+++ b/drivers/misc/drv2605.c
@@ -0,0 +1,1547 @@
+/*
+** ========================================================================
+** Copyright 2013 Texas Instruments Inc.
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+** ========================================================================
+*/
+/*
+** File:
+**     drv2605.c
+**
+** Description:
+**     DRV2605 chip driver
+**
+*/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <linux/slab.h>
+#include <linux/types.h>
+
+#include <linux/fs.h>
+#include <linux/cdev.h>
+
+#include <linux/i2c.h>
+#include <linux/semaphore.h>
+#include <linux/device.h>
+
+#include <linux/syscalls.h>
+#include <asm/uaccess.h>
+
+#include <linux/gpio.h>
+
+#include <linux/sched.h>
+
+#include <linux/i2c/drv2605.h>
+
+#include <linux/spinlock_types.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/jiffies.h>
+#include <linux/timer.h>
+
+#include <linux/workqueue.h>
+#include <../../../drivers/staging/android/timed_output.h>
+#include <linux/hrtimer.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/clk.h>
+#include <linux/wakelock.h>
+#include <linux/of_gpio.h>
+
+
+#ifdef VIBRATOR_DEBUG
+#define vibrator_debug(fmt, args...) printk(KERN_DEBUG "[drv2605]"fmt, ##args)
+#else
+#define vibrator_debug(fmt, args...) do {} while(0)
+#endif
+
+#ifdef VIBRATOR_MULTI_USERMODE
+unsigned char nubia_wave_sequence[] = {
+	WAVEFORM_SEQUENCER_REG, 		15,
+	WAVEFORM_SEQUENCER_REG2,		150,
+	WAVEFORM_SEQUENCER_REG3,		15,
+	WAVEFORM_SEQUENCER_REG4,		150,
+	WAVEFORM_SEQUENCER_REG5,		15,
+	WAVEFORM_SEQUENCER_REG6,		150,
+	WAVEFORM_SEQUENCER_REG7,		15,
+	WAVEFORM_SEQUENCER_REG8,		150,
+};
+
+unsigned char nubia_wave_sequence1[] = {
+	WAVEFORM_SEQUENCER_REG, 		1,
+	WAVEFORM_SEQUENCER_REG2,		0,
+	WAVEFORM_SEQUENCER_REG3,		0,
+	WAVEFORM_SEQUENCER_REG4,		0,
+	WAVEFORM_SEQUENCER_REG5,		0,
+	WAVEFORM_SEQUENCER_REG6,		0,
+	WAVEFORM_SEQUENCER_REG7,		0,
+	WAVEFORM_SEQUENCER_REG8,		0,
+};
+
+unsigned char nubia_wave_sequence2[] = {
+	WAVEFORM_SEQUENCER_REG, 		2,
+	WAVEFORM_SEQUENCER_REG2,		0,
+	WAVEFORM_SEQUENCER_REG3,		0,
+	WAVEFORM_SEQUENCER_REG4,		0,
+	WAVEFORM_SEQUENCER_REG5,		0,
+	WAVEFORM_SEQUENCER_REG6,		0,
+	WAVEFORM_SEQUENCER_REG7,		0,
+	WAVEFORM_SEQUENCER_REG8,		0,
+};
+
+unsigned char nubia_wave_sequence3[] = {
+	WAVEFORM_SEQUENCER_REG, 		49,
+	WAVEFORM_SEQUENCER_REG2,		0,
+	WAVEFORM_SEQUENCER_REG3,		0,
+	WAVEFORM_SEQUENCER_REG4,		0,
+	WAVEFORM_SEQUENCER_REG5,		0,
+	WAVEFORM_SEQUENCER_REG6,		0,
+	WAVEFORM_SEQUENCER_REG7,		0,
+	WAVEFORM_SEQUENCER_REG8,		0,
+};
+
+unsigned char nubia_wave_sequence4[] = {
+	WAVEFORM_SEQUENCER_REG, 		34,
+	WAVEFORM_SEQUENCER_REG2,		0,
+	WAVEFORM_SEQUENCER_REG3,		0,
+	WAVEFORM_SEQUENCER_REG4,		0,
+	WAVEFORM_SEQUENCER_REG5,		0,
+	WAVEFORM_SEQUENCER_REG6,		0,
+	WAVEFORM_SEQUENCER_REG7,		0,
+	WAVEFORM_SEQUENCER_REG8,		0,
+};
+
+unsigned char nubia_wave_sequence5[] = {
+	WAVEFORM_SEQUENCER_REG, 		24,
+	WAVEFORM_SEQUENCER_REG2,		0,
+	WAVEFORM_SEQUENCER_REG3,		0,
+	WAVEFORM_SEQUENCER_REG4,		0,
+	WAVEFORM_SEQUENCER_REG5,		0,
+	WAVEFORM_SEQUENCER_REG6,		0,
+	WAVEFORM_SEQUENCER_REG7,		0,
+	WAVEFORM_SEQUENCER_REG8,		0,
+};
+
+unsigned char nubia_wave_sequence6[] = {
+	WAVEFORM_SEQUENCER_REG, 		6,
+	WAVEFORM_SEQUENCER_REG2,		0,
+	WAVEFORM_SEQUENCER_REG3,		0,
+	WAVEFORM_SEQUENCER_REG4,		0,
+	WAVEFORM_SEQUENCER_REG5,		0,
+	WAVEFORM_SEQUENCER_REG6,		0,
+	WAVEFORM_SEQUENCER_REG7,		0,
+	WAVEFORM_SEQUENCER_REG8,		0,
+};
+
+unsigned char nubia_wave_sequence7[] = {
+	WAVEFORM_SEQUENCER_REG, 		74,
+	WAVEFORM_SEQUENCER_REG2,		0,
+	WAVEFORM_SEQUENCER_REG3,		0,
+	WAVEFORM_SEQUENCER_REG4,		0,
+	WAVEFORM_SEQUENCER_REG5,		0,
+	WAVEFORM_SEQUENCER_REG6,		0,
+	WAVEFORM_SEQUENCER_REG7,		0,
+	WAVEFORM_SEQUENCER_REG8,		0,
+};
+
+unsigned char nubia_wave_sequence8[] = {
+	WAVEFORM_SEQUENCER_REG, 		47,
+	WAVEFORM_SEQUENCER_REG2,		0,
+	WAVEFORM_SEQUENCER_REG3,		0,
+	WAVEFORM_SEQUENCER_REG4,		0,
+	WAVEFORM_SEQUENCER_REG5,		0,
+	WAVEFORM_SEQUENCER_REG6,		0,
+	WAVEFORM_SEQUENCER_REG7,		0,
+	WAVEFORM_SEQUENCER_REG8,		0,
+};
+
+unsigned char nubia_wave_sequence9[] = {
+	WAVEFORM_SEQUENCER_REG, 		5,
+	WAVEFORM_SEQUENCER_REG2,		0,
+	WAVEFORM_SEQUENCER_REG3,		0,
+	WAVEFORM_SEQUENCER_REG4,		0,
+	WAVEFORM_SEQUENCER_REG5,		0,
+	WAVEFORM_SEQUENCER_REG6,		0,
+	WAVEFORM_SEQUENCER_REG7,		0,
+	WAVEFORM_SEQUENCER_REG8,		0,
+};
+unsigned char nubia_wave_sequence10[] = {
+	WAVEFORM_SEQUENCER_REG, 		4,
+	WAVEFORM_SEQUENCER_REG2,		0,
+	WAVEFORM_SEQUENCER_REG3,		0,
+	WAVEFORM_SEQUENCER_REG4,		0,
+	WAVEFORM_SEQUENCER_REG5,		0,
+	WAVEFORM_SEQUENCER_REG6,		0,
+	WAVEFORM_SEQUENCER_REG7,		0,
+	WAVEFORM_SEQUENCER_REG8,		0,
+};
+#endif
+
+#ifdef VIBRATOR_AUTO_CALIBRATE
+static const unsigned char autocal_sequence[] = {
+	MODE_REG,                       AUTO_CALIBRATION,
+	REAL_TIME_PLAYBACK_REG,         REAL_TIME_PLAYBACK_STRENGTH,
+	GO_REG,                         GO,
+};
+#endif
+
+static int drv260x_resume(struct i2c_client *client)
+{
+	struct drv2605_data *pDrv2605data = i2c_get_clientdata(client);
+	gpio_set_value(pDrv2605data->PlatData.GpioEnable, GPIO_LEVEL_HIGH);
+	return 0;
+}
+
+static int drv260x_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	struct drv2605_data *pDrv2605data = i2c_get_clientdata(client);
+	gpio_set_value(pDrv2605data->PlatData.GpioEnable, GPIO_LEVEL_LOW);
+	return 0;
+}
+
+static int drv260x_write_reg_val(struct i2c_client *client,const unsigned char* data, unsigned int size)
+{
+	int i = 0;
+	int err = 0;
+
+	if (size % 2 != 0)
+	return -EINVAL;
+
+	vibrator_debug("%s:", __func__);
+
+	while (i < size)
+	{
+#ifdef VIBRATOR_DEBUG
+		printk(" 0x%x:0x%x", data[i], data[i+1]);
+#endif
+		err = i2c_smbus_write_byte_data(client, data[i], data[i+1]);
+		if(err < 0){
+			printk(KERN_ERR"%s, err=%d\n", __FUNCTION__, err);
+			break;
+		}
+		i+=2;
+	}
+
+#ifdef VIBRATOR_DEBUG
+	printk("\n");
+#endif
+
+	return err;
+}
+
+static void drv260x_set_go_bit(struct i2c_client *client,char val)
+{
+	char go[] =
+	{
+		GO_REG, val
+	};
+	drv260x_write_reg_val(client, go, sizeof(go));
+}
+
+static unsigned char drv260x_read_reg(struct i2c_client *client, unsigned char reg)
+{
+	return i2c_smbus_read_byte_data(client, reg);
+}
+
+static unsigned char drv260x_setbit_reg(struct i2c_client *client, unsigned char reg, unsigned char mask, unsigned char value)
+{
+	unsigned char temp = 0;
+	unsigned char buff[2];
+	unsigned char regval = drv260x_read_reg(client,reg);
+
+	temp = regval & ~mask;
+	temp |= value & mask;
+
+	if(temp != regval){
+		buff[0] = reg;
+		buff[1] = temp;
+
+		return drv260x_write_reg_val(client, buff, 2);
+	}else
+		return 2;
+}
+
+static void drv2605_poll_go_bit(struct i2c_client *client)
+{
+	while (drv260x_read_reg(client, GO_REG) == GO)
+	schedule_timeout_interruptible(msecs_to_jiffies(GO_BIT_POLL_INTERVAL));
+}
+
+static void drv2605_select_library(struct i2c_client *client, char lib)
+{
+	char library[] =
+	{
+		LIBRARY_SELECTION_REG, lib
+	};
+	drv260x_write_reg_val(client, library, sizeof(library));
+}
+
+static void drv260x_set_rtp_val(struct i2c_client *client, char value)
+{
+	char rtp_val[] =
+	{
+		REAL_TIME_PLAYBACK_REG, value
+	};
+	drv260x_write_reg_val(client, rtp_val, sizeof(rtp_val));
+}
+
+static void drv2605_set_waveform_sequence(struct i2c_client *client, unsigned char* seq, unsigned int size)
+{
+	unsigned char data[WAVEFORM_SEQUENCER_MAX + 1];
+
+	if (size > WAVEFORM_SEQUENCER_MAX)
+	return;
+
+	memset(data, 0, sizeof(data));
+	memcpy(&data[1], seq, size);
+	data[0] = WAVEFORM_SEQUENCER_REG;
+
+	i2c_master_send(client, data, sizeof(data));
+}
+
+static void drv260x_change_mode(struct i2c_client *client, char mode)
+{
+	struct drv2605_data *pDrv2605data = i2c_get_clientdata(client);
+	unsigned char tmp[2] = {MODE_REG, mode};
+
+	if((mode == MODE_PATTERN_RTP_ON) || (mode == MODE_SEQ_RTP_ON))
+		tmp[1] = MODE_REAL_TIME_PLAYBACK;
+	else if((mode == MODE_PATTERN_RTP_OFF) || (mode == MODE_SEQ_RTP_OFF))
+		tmp[1] = MODE_INTERNAL_TRIGGER;
+
+	if(((mode == MODE_INTERNAL_TRIGGER) || (mode == MODE_PATTERN_RTP_OFF)
+		|| (mode == MODE_SEQ_RTP_OFF))
+		&& ((pDrv2605data->mode == MODE_PATTERN_RTP_OFF) ||
+		(pDrv2605data->mode == MODE_INTERNAL_TRIGGER) ||
+		(pDrv2605data->mode == MODE_SEQ_RTP_OFF))) {
+	} else if(mode != pDrv2605data->mode || pDrv2605data->mode == MODE_STANDBY) {
+		//printk("%s, new mode=%d, old mode=%d, reg=0x%x\n", __FUNCTION__,mode, pDrv2605data->mode, tmp[1]);
+		drv260x_write_reg_val(client, tmp, sizeof(tmp));
+		if(tmp[1] == MODE_STANDBY) {
+			schedule_timeout_interruptible(msecs_to_jiffies(10));
+		}else if(pDrv2605data->mode == MODE_STANDBY) {
+			schedule_timeout_interruptible(msecs_to_jiffies(1));
+		}
+	}
+
+	pDrv2605data->mode = mode;
+}
+
+/* --------------------------------------------------------------------------------- */
+#define YES 1
+#define NO  0
+
+static void setAudioHapticsEnabled(struct i2c_client *client, int enable);
+
+static struct Haptics {
+	struct wake_lock wklock;
+	struct pwm_device *pwm_dev;
+	struct hrtimer timer;
+	struct mutex lock;
+	struct work_struct work;
+	struct work_struct work_play_eff;
+	unsigned char sequence[8];
+	volatile int should_stop;
+	struct timed_output_dev to_dev;
+	int testdata;
+} vibdata;
+
+static struct i2c_client *this_client;
+
+static int vibrator_get_time(struct timed_output_dev *dev)
+{
+	//struct Haptics	*pvibdata = container_of(dev, struct Haptics, to_dev);
+
+	if (hrtimer_active(&vibdata.timer)) {
+		ktime_t r = hrtimer_get_remaining(&vibdata.timer);
+		return ktime_to_ms(r);
+	}
+
+	return 0;
+}
+
+static void vibrator_off(struct i2c_client *client)
+{
+	struct drv2605_data *pDrv2605data = i2c_get_clientdata(client);
+
+	if (1) {
+		pDrv2605data->vibrator_is_playing = NO;
+		if (pDrv2605data->audio_haptics_enabled)
+		{
+			if ((drv260x_read_reg(client, MODE_REG) & DRV260X_MODE_MASK) != MODE_AUDIOHAPTIC)
+				setAudioHapticsEnabled(client, YES);
+		} else {
+			switch_set_state(&pDrv2605data->sw_dev, SW_STATE_IDLE);
+			drv260x_change_mode(client, MODE_STANDBY);
+		}
+	}
+
+#ifdef VIBRATOR_MULTI_USERMODE
+	pDrv2605data->usermode = 0;
+#endif
+
+	wake_unlock(&vibdata.wklock);
+}
+
+#ifdef VIBRATOR_MULTI_USERMODE
+/* Real-Time Playback (RTP) Mode */
+static void vibrator_enable_rtp(struct timed_output_dev *dev, int value)
+{
+	struct i2c_client *client = this_client;
+	struct drv2605_data *pDrv2605data = i2c_get_clientdata(client);
+	//struct Haptics	*pvibdata = container_of(dev, struct Haptics, to_dev);
+	char mode;
+
+	mutex_lock(&vibdata.lock);
+	hrtimer_cancel(&vibdata.timer);
+	cancel_work_sync(&vibdata.work);
+
+	if (value) {
+		wake_lock(&vibdata.wklock);
+
+		mode = drv260x_read_reg(client, MODE_REG) & DRV260X_MODE_MASK;
+		/* Only change the mode if not already in RTP mode; RTP input already set at init */
+		if (mode != MODE_REAL_TIME_PLAYBACK)
+		{
+			if (pDrv2605data->audio_haptics_enabled && mode == MODE_AUDIOHAPTIC)
+			setAudioHapticsEnabled(client, NO);
+
+			drv260x_set_rtp_val(client, REAL_TIME_PLAYBACK_STRENGTH);
+			drv260x_change_mode(client, MODE_REAL_TIME_PLAYBACK);
+			pDrv2605data->vibrator_is_playing = YES;
+			switch_set_state(&pDrv2605data->sw_dev, SW_STATE_RTP_PLAYBACK);
+		}
+
+		if (value > 0) {
+			if (value > MAX_TIMEOUT)
+				value = MAX_TIMEOUT;
+			hrtimer_start(&vibdata.timer, ns_to_ktime((u64)value * NSEC_PER_MSEC), HRTIMER_MODE_REL);
+		}
+	}	else {
+		vibrator_off(client);
+	}
+
+	mutex_unlock(&vibdata.lock);
+}
+
+/* Internal Trigger (default) Mode */
+static void vibrator_enable_internal_trigger(struct timed_output_dev *dev, int value)
+{
+	struct i2c_client *client = this_client;
+	struct drv2605_data *pDrv2605data = i2c_get_clientdata(client);
+	//struct Haptics	*pvibdata = container_of(dev, struct Haptics, to_dev);
+	char mode;
+
+	mutex_lock(&vibdata.lock);
+	hrtimer_cancel(&vibdata.timer);
+	cancel_work_sync(&vibdata.work);
+
+	wake_lock(&vibdata.wklock);
+
+	if (value) {
+		switch(pDrv2605data->usermode){
+		case 1:
+			drv260x_write_reg_val(client, nubia_wave_sequence1, sizeof(nubia_wave_sequence1));
+			break;
+		case 2:
+			drv260x_write_reg_val(client, nubia_wave_sequence2, sizeof(nubia_wave_sequence2));
+			break;
+		case 3:
+			drv260x_write_reg_val(client, nubia_wave_sequence3, sizeof(nubia_wave_sequence3));
+			break;
+		case 4:
+			drv260x_write_reg_val(client, nubia_wave_sequence4, sizeof(nubia_wave_sequence4));
+			break;
+		case 5:
+			drv260x_write_reg_val(client, nubia_wave_sequence5, sizeof(nubia_wave_sequence5));
+			break;
+		case 6:
+			drv260x_write_reg_val(client, nubia_wave_sequence6, sizeof(nubia_wave_sequence6));
+			break;
+		case 7:
+			drv260x_write_reg_val(client, nubia_wave_sequence7, sizeof(nubia_wave_sequence7));
+			break;
+		case 8:
+			drv260x_write_reg_val(client, nubia_wave_sequence8, sizeof(nubia_wave_sequence8));
+			break;
+		case 9:
+			drv260x_write_reg_val(client, nubia_wave_sequence9, sizeof(nubia_wave_sequence9));
+			break;
+		case 10:
+			drv260x_write_reg_val(client, nubia_wave_sequence10, sizeof(nubia_wave_sequence10));
+			break;
+		default:
+			printk(KERN_ERR "%s: Unknown usermode(%d).\n", __func__, pDrv2605data->usermode);
+			break;
+		}
+
+		mode = drv260x_read_reg(client, MODE_REG) & DRV260X_MODE_MASK;
+		if (pDrv2605data->audio_haptics_enabled && mode == MODE_AUDIOHAPTIC)
+			setAudioHapticsEnabled(client, NO);
+
+		drv260x_change_mode(client, MODE_INTERNAL_TRIGGER);
+		pDrv2605data->vibrator_is_playing = YES;
+		switch_set_state(&pDrv2605data->sw_dev, SW_STATE_SEQUENCE_PLAYBACK);			
+
+		drv260x_set_go_bit(client, GO);
+		if (value > 0) {
+			if (value > MAX_TIMEOUT)
+				value = MAX_TIMEOUT;
+			hrtimer_start(&vibdata.timer, ns_to_ktime((u64)value * NSEC_PER_MSEC), HRTIMER_MODE_REL);
+		}
+	} else {
+		vibrator_off(client);
+	}
+
+	mutex_unlock(&vibdata.lock);
+}
+
+static void vibrator_enable(struct timed_output_dev *dev, int value)
+{
+	struct i2c_client *client = this_client;
+	struct drv2605_data *pDrv2605data = i2c_get_clientdata(client);
+
+	vibrator_debug("%s(%d):usermode=%d,value=%d\n", __func__, __LINE__,
+			pDrv2605data->usermode, value);
+
+	if(pDrv2605data->usermode){
+		vibrator_enable_internal_trigger(dev, value);
+	}	else {
+		vibrator_enable_rtp(dev, value);
+	}
+}
+
+#else
+static void vibrator_enable(struct timed_output_dev *dev, int value)
+{
+	struct i2c_client *client = this_client;
+	struct drv2605_data *pDrv2605data = i2c_get_clientdata(client);
+	//struct Haptics	*pvibdata = container_of(dev, struct Haptics, to_dev);
+	char mode;
+
+	mutex_lock(&vibdata.lock);
+	hrtimer_cancel(&vibdata.timer);
+	cancel_work_sync(&vibdata.work);
+
+	if (value) {
+		wake_lock(&vibdata.wklock);
+
+		mode = drv260x_read_reg(client, MODE_REG) & DRV260X_MODE_MASK;
+		/* Only change the mode if not already in RTP mode; RTP input already set at init */
+		if (mode != MODE_REAL_TIME_PLAYBACK)
+		{
+			if (pDrv2605data->audio_haptics_enabled && mode == MODE_AUDIOHAPTIC)
+			setAudioHapticsEnabled(client, NO);
+
+			drv260x_set_rtp_val(client, REAL_TIME_PLAYBACK_STRENGTH);
+			drv260x_change_mode(client, MODE_REAL_TIME_PLAYBACK);
+			pDrv2605data->vibrator_is_playing = YES;
+			switch_set_state(&pDrv2605data->sw_dev, SW_STATE_RTP_PLAYBACK);
+		}
+
+		if (value > 0) {
+			if (value > MAX_TIMEOUT)
+				value = MAX_TIMEOUT;
+			hrtimer_start(&vibdata.timer, ns_to_ktime((u64)value * NSEC_PER_MSEC), HRTIMER_MODE_REL);
+		}
+	}
+	else
+		vibrator_off(client);
+
+	mutex_unlock(&vibdata.lock);
+}
+#endif
+
+#ifdef VIBRATOR_MULTI_USERMODE
+static ssize_t vibrator_usermode_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+	struct i2c_client *client = this_client;
+	struct drv2605_data *pDrv2605data = i2c_get_clientdata(client);
+
+	return sprintf(buf, "%d\n", pDrv2605data->usermode);
+}
+
+static ssize_t vibrator_usermode_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct i2c_client *client = this_client;
+	struct drv2605_data *pDrv2605data = i2c_get_clientdata(client);
+	unsigned long value;
+
+	if (strict_strtoul(buf, 0, &value))
+		return -EINVAL;
+
+	pDrv2605data->usermode = value;
+
+	return size;
+}
+
+static struct device_attribute vibrator_attributes[] = {
+	__ATTR(usermode, 0644, vibrator_usermode_show, vibrator_usermode_store),
+};
+
+static int vibrator_create_sysfs(struct device *dev)
+{
+	int i;
+
+	for(i=0; i<ARRAY_SIZE(vibrator_attributes); i++) {
+		if (device_create_file(dev, vibrator_attributes+i))
+		goto error;
+	}
+	return 0;
+
+error:
+	for(; i>=0; i--) {
+		device_remove_file(dev, vibrator_attributes+i);
+	}
+	dev_err(dev, "%s:Unable to create sysfs\n", __func__);
+	return -1;
+}
+#endif
+
+static enum hrtimer_restart vibrator_timer_func(struct hrtimer *timer)
+{
+	schedule_work(&vibdata.work);
+	return HRTIMER_NORESTART;
+}
+
+static void vibrator_work(struct work_struct *work)
+{
+	struct i2c_client *client = this_client;
+	struct drv2605_data *pDrv2605data = i2c_get_clientdata(client);
+
+	if(pDrv2605data->mode == MODE_PATTERN_RTP_ON) {
+		drv260x_change_mode(client, MODE_PATTERN_RTP_OFF);
+		if(pDrv2605data->repeat_times == 0) {
+			drv260x_change_mode(client, MODE_STANDBY);
+			pDrv2605data->vibrator_is_playing = NO;
+			switch_set_state(&pDrv2605data->sw_dev, SW_STATE_IDLE);
+		} else {
+			hrtimer_start(&vibdata.timer, ns_to_ktime((u64)pDrv2605data->silience_time * NSEC_PER_MSEC), HRTIMER_MODE_REL);
+		}
+	} else if(pDrv2605data->mode == MODE_PATTERN_RTP_OFF) {
+		if(pDrv2605data->repeat_times > 0) {
+			pDrv2605data->repeat_times--;
+			drv260x_change_mode(client, MODE_PATTERN_RTP_ON);
+			hrtimer_start(&vibdata.timer, ns_to_ktime((u64)pDrv2605data->vibration_time * NSEC_PER_MSEC), HRTIMER_MODE_REL);
+		} else {
+			drv260x_change_mode(client, MODE_STANDBY);
+			pDrv2605data->vibrator_is_playing = NO;
+			switch_set_state(&pDrv2605data->sw_dev, SW_STATE_IDLE);
+		}
+	} else if((pDrv2605data->mode == MODE_SEQ_RTP_OFF)||((pDrv2605data->mode == MODE_SEQ_RTP_ON))) {
+		if(pDrv2605data->RTPSeq.RTPindex < pDrv2605data->RTPSeq.RTPCounts){
+			int RTPTime = pDrv2605data->RTPSeq.RTPData[pDrv2605data->RTPSeq.RTPindex] >> 8;
+			int RTPVal = pDrv2605data->RTPSeq.RTPData[pDrv2605data->RTPSeq.RTPindex] & 0x00ff ;
+			if(RTPTime != 0) {
+				//printk("%s, RTP SEQ[%d]=amp=0x%x, time=%d \n", __FUNCTION__, pDrv2605data->RTPSeq.RTPindex, RTPVal, RTPTime);
+				drv260x_set_rtp_val(client,  RTPVal);
+				if(pDrv2605data->mode == MODE_SEQ_RTP_OFF)
+					drv260x_change_mode(client, MODE_SEQ_RTP_ON);
+
+				hrtimer_start(&vibdata.timer, ns_to_ktime((u64)RTPTime * NSEC_PER_MSEC), HRTIMER_MODE_REL);
+				pDrv2605data->RTPSeq.RTPindex++;
+			} else {
+				drv260x_change_mode(client, MODE_STANDBY);
+				pDrv2605data->vibrator_is_playing = NO;
+				switch_set_state(&pDrv2605data->sw_dev, SW_STATE_IDLE);
+			}
+		} else {
+			drv260x_change_mode(client, MODE_STANDBY);
+			pDrv2605data->vibrator_is_playing = NO;
+			switch_set_state(&pDrv2605data->sw_dev, SW_STATE_IDLE);
+		}
+	} else {
+		vibrator_off(client);
+	}
+}
+
+/* ----------------------------------------------------------------------------- */
+
+static void play_effect(struct work_struct *work)
+{
+	struct i2c_client *client = this_client;
+	struct drv2605_data *pDrv2605data = i2c_get_clientdata(client);
+
+	switch_set_state(&pDrv2605data->sw_dev, SW_STATE_SEQUENCE_PLAYBACK);
+
+	if (pDrv2605data->audio_haptics_enabled &&
+			((drv260x_read_reg(client, MODE_REG) & DRV260X_MODE_MASK) == MODE_AUDIOHAPTIC)){
+		setAudioHapticsEnabled(client, NO);
+	}
+
+	drv260x_change_mode(client, MODE_INTERNAL_TRIGGER);
+	drv2605_set_waveform_sequence(client, vibdata.sequence, sizeof(vibdata.sequence));
+	drv260x_set_go_bit(client, GO);
+
+	while(drv260x_read_reg(client, GO_REG) == GO && !vibdata.should_stop)
+	schedule_timeout_interruptible(msecs_to_jiffies(GO_BIT_POLL_INTERVAL));
+
+	wake_unlock(&vibdata.wklock);
+	if (pDrv2605data->audio_haptics_enabled)
+	{
+		setAudioHapticsEnabled(client, YES);
+	} else {
+		drv260x_change_mode(client, MODE_STANDBY);
+		switch_set_state(&pDrv2605data->sw_dev, SW_STATE_IDLE);
+	}
+}
+
+static void setAudioHapticsEnabled(struct i2c_client *client, int enable)
+{
+	struct drv2605_data *pDrv2605data = i2c_get_clientdata(client);
+
+	vibrator_debug("%s(%d):enable=%d\n", __func__, __LINE__, enable);
+
+	if (enable)
+	{
+		drv260x_change_mode(client, MODE_INTERNAL_TRIGGER);
+		schedule_timeout_interruptible(msecs_to_jiffies(STANDBY_WAKE_DELAY));
+
+		drv260x_setbit_reg(client, Control1_REG, Control1_REG_AC_COUPLE_MASK,
+			AC_COUPLE_ENABLED );
+
+		drv260x_setbit_reg(client, Control3_REG, Control3_REG_PWMANALOG_MASK,
+			INPUT_ANALOG);
+
+		drv260x_change_mode(client, MODE_AUDIOHAPTIC);
+		pDrv2605data->audio_haptics_enabled = YES;
+		switch_set_state(&pDrv2605data->sw_dev, SW_STATE_AUDIO2HAPTIC);
+	} else {
+		drv260x_change_mode(client, MODE_STANDBY); // Disable audio-to-haptics
+		schedule_timeout_interruptible(msecs_to_jiffies(STANDBY_WAKE_DELAY));
+
+		// Chip needs to be brought out of standby to change the registers
+		drv260x_change_mode(client, MODE_INTERNAL_TRIGGER);
+		schedule_timeout_interruptible(msecs_to_jiffies(STANDBY_WAKE_DELAY));
+
+		drv260x_setbit_reg(client, Control1_REG, Control1_REG_AC_COUPLE_MASK,
+			AC_COUPLE_DISABLED);
+
+		drv260x_setbit_reg(client, Control3_REG, Control3_REG_PWMANALOG_MASK,
+			INPUT_PWM);
+
+		pDrv2605data->audio_haptics_enabled = NO;
+		switch_set_state(&pDrv2605data->sw_dev, SW_STATE_IDLE);
+	}
+}
+
+static ssize_t drv260x_read(struct file* filp, char* buff, size_t length, loff_t* offset)
+{
+	struct i2c_client *client = this_client;
+	struct drv2605_data *pDrv2605data = i2c_get_clientdata(client);
+	int ret = 0;
+
+	if(pDrv2605data->pReadValue != NULL){
+
+		ret = copy_to_user(buff,pDrv2605data->pReadValue, pDrv2605data->ReadLen);
+		if (ret != 0){
+			printk("%s, copy_to_user err=%d \n", __FUNCTION__, ret);
+		} else {
+			ret = pDrv2605data->ReadLen;
+		}
+		pDrv2605data->ReadLen = 0;
+		kfree(pDrv2605data->pReadValue);
+		pDrv2605data->pReadValue = NULL;
+
+	} else {
+		buff[0] = pDrv2605data->read_val;
+		ret = 1;
+	}
+
+	return ret;
+}
+
+static bool isforDebug(int cmd){
+	return ((cmd == HAPTIC_CMDID_REG_WRITE)
+	||(cmd == HAPTIC_CMDID_REG_READ)
+	||(cmd == HAPTIC_CMDID_REG_SETBIT));
+}
+
+static ssize_t drv260x_write(struct file* filp, const char* buff, size_t len, loff_t* off)
+{
+	struct i2c_client *client = this_client;
+	struct drv2605_data *pDrv2605data = i2c_get_clientdata(client);
+
+	vibrator_debug("%s(%d):buff[0]=%c(%d)\n", __func__, __LINE__, buff[0], buff[0]);
+
+	mutex_lock(&vibdata.lock);
+
+	if(isforDebug(buff[0])){
+	} else {
+		hrtimer_cancel(&vibdata.timer);
+
+		vibdata.should_stop = YES;
+		cancel_work_sync(&vibdata.work_play_eff);
+		cancel_work_sync(&vibdata.work);
+
+		if (pDrv2605data->vibrator_is_playing)
+		{
+			pDrv2605data->vibrator_is_playing = NO;
+			drv260x_change_mode(client, MODE_STANDBY);
+		}
+	}
+
+	switch(buff[0])
+	{
+	case HAPTIC_CMDID_PLAY_SINGLE_EFFECT:
+	case HAPTIC_CMDID_PLAY_EFFECT_SEQUENCE:
+	{
+		memset(&vibdata.sequence, 0, sizeof(vibdata.sequence));
+		if (!copy_from_user(&vibdata.sequence, &buff[1], len - 1))
+		{
+			vibdata.should_stop = NO;
+			wake_lock(&vibdata.wklock);
+			schedule_work(&vibdata.work_play_eff);
+		}
+		break;
+	}
+	case HAPTIC_CMDID_PLAY_TIMED_EFFECT:
+	{
+		unsigned int value = 0;
+		char mode;
+
+		value = buff[2];
+		value <<= 8;
+		value |= buff[1];
+
+		if (value)
+		{
+			wake_lock(&vibdata.wklock);
+			mode = drv260x_read_reg(client, MODE_REG) & DRV260X_MODE_MASK;
+			if (mode != MODE_REAL_TIME_PLAYBACK)
+			{
+				if (pDrv2605data->audio_haptics_enabled && mode == MODE_AUDIOHAPTIC){
+					setAudioHapticsEnabled(client, NO);
+				}
+
+				drv260x_set_rtp_val(client, REAL_TIME_PLAYBACK_STRENGTH);
+				drv260x_change_mode(client, MODE_REAL_TIME_PLAYBACK);
+				switch_set_state(&pDrv2605data->sw_dev, SW_STATE_RTP_PLAYBACK);
+				pDrv2605data->vibrator_is_playing = YES;
+			}
+
+			if (value > 0)
+			{
+				if (value > MAX_TIMEOUT)
+					value = MAX_TIMEOUT;
+				hrtimer_start(&vibdata.timer, ns_to_ktime((u64)value * NSEC_PER_MSEC), HRTIMER_MODE_REL);
+			}
+		}
+		break;
+	}
+	case HAPTIC_CMDID_PATTERN_RTP:
+	{
+		char mode;
+		unsigned char strength = 0;
+
+		pDrv2605data->vibration_time = (int)((((int)buff[2])<<8) | (int)buff[1]);
+		pDrv2605data->silience_time = (int)((((int)buff[4])<<8) | (int)buff[3]);
+		pDrv2605data->repeat_times = buff[5];
+		strength = buff[6];
+
+		if(pDrv2605data->vibration_time > 0) {
+			mode = drv260x_read_reg(client, MODE_REG) & DRV260X_MODE_MASK;
+				if (mode != MODE_REAL_TIME_PLAYBACK) {
+					if (pDrv2605data->audio_haptics_enabled && mode == MODE_AUDIOHAPTIC) {
+						setAudioHapticsEnabled(client, NO);
+					} else if(mode == MODE_STANDBY) {
+						drv260x_change_mode(client, MODE_INTERNAL_TRIGGER);
+					}
+
+					drv260x_set_rtp_val(client, strength);
+					drv260x_change_mode(client, MODE_PATTERN_RTP_ON);
+					if(pDrv2605data->repeat_times > 0)
+						pDrv2605data->repeat_times--;
+					switch_set_state(&pDrv2605data->sw_dev, SW_STATE_RTP_PLAYBACK);
+					pDrv2605data->vibrator_is_playing = YES;
+				}
+
+				if (pDrv2605data->vibration_time > MAX_TIMEOUT)
+					pDrv2605data->vibration_time = MAX_TIMEOUT;
+
+				hrtimer_start(&vibdata.timer, ns_to_ktime((u64)pDrv2605data->vibration_time * NSEC_PER_MSEC), HRTIMER_MODE_REL);
+		}
+		break;
+	}
+	case HAPTIC_CMDID_RTP_SEQUENCE:
+	{
+		memset(&pDrv2605data->RTPSeq, 0, sizeof(struct RTP_Seq));
+		pDrv2605data->RTPSeq.RTPCounts = buff[1];
+		if(pDrv2605data->RTPSeq.RTPCounts < 17) {
+			if(copy_from_user(pDrv2605data->RTPSeq.RTPData, &buff[2], pDrv2605data->RTPSeq.RTPCounts*2) != 0) {
+				break;
+			}
+		switch_set_state(&pDrv2605data->sw_dev, SW_STATE_RTP_PLAYBACK);
+		drv260x_change_mode(client, MODE_SEQ_RTP_OFF);
+		schedule_work(&vibdata.work);
+		}
+		break;
+	}
+	case HAPTIC_CMDID_STOP:
+	{
+		if (pDrv2605data->vibrator_is_playing)
+		{
+			pDrv2605data->vibrator_is_playing = NO;
+			if (pDrv2605data->audio_haptics_enabled)
+			{
+				setAudioHapticsEnabled(client, YES);
+			} else {
+					switch_set_state(&pDrv2605data->sw_dev, SW_STATE_IDLE);
+					drv260x_change_mode(client, MODE_STANDBY);
+			}
+		}
+		vibdata.should_stop = YES;
+		break;
+	}
+	case HAPTIC_CMDID_GET_DEV_ID:
+	{
+		/* Dev ID includes 2 parts, upper word for device id, lower word for chip revision */
+		int revision = (drv260x_read_reg(client, SILICON_REVISION_REG) & SILICON_REVISION_MASK);
+		pDrv2605data->read_val = (pDrv2605data->device_id >> 1) | revision;
+		break;
+	}
+	case HAPTIC_CMDID_RUN_DIAG:
+	{
+		char diag_seq[] =
+		{
+			MODE_REG, MODE_DIAGNOSTICS,
+			GO_REG,   GO
+		};
+
+		if (pDrv2605data->audio_haptics_enabled &&
+				((drv260x_read_reg(client, MODE_REG) & DRV260X_MODE_MASK) == MODE_AUDIOHAPTIC)){
+				setAudioHapticsEnabled(client, NO);
+		}
+
+		drv260x_write_reg_val(client, diag_seq, sizeof(diag_seq));
+		drv2605_poll_go_bit(client);
+		pDrv2605data->read_val = (drv260x_read_reg(client, STATUS_REG) & DIAG_RESULT_MASK) >> 3;
+		break;
+	}
+	case HAPTIC_CMDID_AUDIOHAPTIC_ENABLE:
+	{
+		if ((drv260x_read_reg(client, MODE_REG) & DRV260X_MODE_MASK) != MODE_AUDIOHAPTIC)
+		{
+			setAudioHapticsEnabled(client, YES);
+		}
+		break;
+	}
+	case HAPTIC_CMDID_AUDIOHAPTIC_DISABLE:
+	{
+		if (pDrv2605data->audio_haptics_enabled)
+		{
+			if ((drv260x_read_reg(client, MODE_REG) & DRV260X_MODE_MASK) == MODE_AUDIOHAPTIC)
+				setAudioHapticsEnabled(client, NO);
+			drv260x_change_mode(client, MODE_STANDBY);
+			switch_set_state(&pDrv2605data->sw_dev, SW_STATE_IDLE);
+		}
+		break;
+	}
+	case HAPTIC_CMDID_AUDIOHAPTIC_GETSTATUS:
+	{
+		if ((drv260x_read_reg(client, MODE_REG) & DRV260X_MODE_MASK) == MODE_AUDIOHAPTIC)
+		{
+			pDrv2605data->read_val = 1;
+		}	else {
+			pDrv2605data->read_val = 0;
+		}
+		break;
+	}
+	case HAPTIC_CMDID_REG_READ:
+	{
+		int i=1;
+		if(pDrv2605data->pReadValue != NULL){
+			printk("%s, ERROR, pReadValue should be NULL\n",__FUNCTION__);
+		} else {
+			pDrv2605data->pReadValue = (char *)kzalloc(len-1, GFP_KERNEL);
+			if(pDrv2605data->pReadValue == NULL){
+				printk("%s, ERROR, pReadValue alloc fail\n",__FUNCTION__);					
+			} else {
+				pDrv2605data->ReadLen = len -1;
+				for(i=0;i<(len-1);i++){
+					pDrv2605data->pReadValue[i] = drv260x_read_reg(client, buff[i+1]);	
+				}
+			}
+		}
+		break;
+	}
+	case HAPTIC_CMDID_REG_WRITE:
+	{
+		drv260x_write_reg_val(client, &buff[1], len-1);
+		break;
+	}
+	case HAPTIC_CMDID_REG_SETBIT:
+	{
+		int i=1;
+		for(i=1; i< len; ){
+			drv260x_setbit_reg(client, buff[i], buff[i+1], buff[i+2]);
+			i += 3;
+		}
+		break;
+	}
+	default:
+		printk("%s, unknown HAPTIC cmd\n", __FUNCTION__);
+		break;
+	}
+
+	mutex_unlock(&vibdata.lock);
+
+	return len;
+}
+
+
+static struct file_operations fops =
+{
+	.read = drv260x_read,
+	.write = drv260x_write
+};
+
+static int Haptics_init(struct drv2605_data *pDrv2605Data)
+{
+	int reval = -ENOMEM;
+
+	pDrv2605Data->version = MKDEV(0,0);
+	reval = alloc_chrdev_region(&pDrv2605Data->version, 0, 1, HAPTICS_DEVICE_NAME);
+	if (reval < 0)
+	{
+		printk(KERN_ALERT"drv260x: error getting major number %d\n", reval);
+		goto fail0;
+	}
+
+	pDrv2605Data->class = class_create(THIS_MODULE, HAPTICS_DEVICE_NAME);
+	if (!pDrv2605Data->class)
+	{
+		printk(KERN_ALERT"drv260x: error creating class\n");
+		goto fail1;
+	}
+
+	pDrv2605Data->device = device_create(pDrv2605Data->class, NULL, pDrv2605Data->version, NULL, HAPTICS_DEVICE_NAME);
+	if (!pDrv2605Data->device)
+	{
+		printk(KERN_ALERT"drv260x: error creating device 2605\n");
+		goto fail2;
+	}
+
+	cdev_init(&pDrv2605Data->cdev, &fops);
+	pDrv2605Data->cdev.owner = THIS_MODULE;
+	pDrv2605Data->cdev.ops = &fops;
+	reval = cdev_add(&pDrv2605Data->cdev, pDrv2605Data->version, 1);
+
+	if (reval)
+	{
+		printk(KERN_ALERT"drv260x: fail to add cdev\n");
+		goto fail3;
+	}
+
+	pDrv2605Data->sw_dev.name = "haptics";
+	reval = switch_dev_register(&pDrv2605Data->sw_dev);
+	if (reval < 0) {
+		printk(KERN_ALERT"drv260x: fail to register switch\n");
+		goto fail4;
+	}
+
+	vibdata.to_dev.name = "vibrator";
+	vibdata.to_dev.get_time = vibrator_get_time;
+	vibdata.to_dev.enable = vibrator_enable;
+
+	if (timed_output_dev_register(&(vibdata.to_dev)) < 0)
+	{
+		printk(KERN_ALERT"drv260x: fail to create timed output dev\n");
+		goto fail3;
+	}
+
+#ifdef VIBRATOR_MULTI_USERMODE
+	if(vibrator_create_sysfs(vibdata.to_dev.dev) < 0)
+	{
+		printk(KERN_ALERT"drv260x: fail to create sysfs\n");
+		goto fail3;
+	}
+#endif
+
+	hrtimer_init(&vibdata.timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	vibdata.timer.function = vibrator_timer_func;
+	INIT_WORK(&vibdata.work, vibrator_work);
+	INIT_WORK(&vibdata.work_play_eff, play_effect);
+
+	wake_lock_init(&vibdata.wklock, WAKE_LOCK_SUSPEND, "vibrator");
+	mutex_init(&vibdata.lock);
+
+	printk(KERN_ALERT"drv260x: initialized\n");
+	return 0;
+
+fail4:
+	switch_dev_unregister(&pDrv2605Data->sw_dev);
+fail3:
+	device_destroy(pDrv2605Data->class, pDrv2605Data->version);
+fail2:
+	class_destroy(pDrv2605Data->class);
+fail1:
+	unregister_chrdev_region(pDrv2605Data->version, 1);
+fail0:
+	return reval;
+}
+
+static void dev_init_platform_data(struct i2c_client* client, struct drv2605_data *pDrv2605data)
+{
+	struct drv2605_platform_data *pDrv2605Platdata = &pDrv2605data->PlatData;
+	struct actuator_data actuator = pDrv2605Platdata->actuator;
+	struct audio2haptics_data a2h = pDrv2605Platdata->a2h;
+	unsigned char loop = 0;
+	unsigned char tmp[8] = {0};
+
+	drv2605_select_library(client, actuator.g_effect_bank);
+
+	//OTP memory saves data from 0x16 to 0x1a
+	if(pDrv2605data->OTP == 0) {
+		if(actuator.rated_vol != 0){
+			tmp[0] = RATED_VOLTAGE_REG;
+			tmp[1] = actuator.rated_vol;
+			printk("%s, RatedVol = 0x%x\n", __FUNCTION__, actuator.rated_vol);
+			drv260x_write_reg_val(client, tmp, 2);
+		} else {
+			printk("%s, ERROR Rated ZERO\n", __FUNCTION__);
+		}
+
+		if(actuator.over_drive_vol != 0){
+			tmp[0] = OVERDRIVE_CLAMP_VOLTAGE_REG;
+			tmp[1] = actuator.over_drive_vol;
+			printk("%s, OverDriveVol = 0x%x\n", __FUNCTION__, actuator.over_drive_vol);
+			drv260x_write_reg_val(client, tmp, 2);
+		} else {
+			printk("%s, ERROR OverDriveVol ZERO\n", __FUNCTION__);
+		}
+
+		drv260x_setbit_reg(client, FEEDBACK_CONTROL_REG,
+			FEEDBACK_CONTROL_DEVICE_TYPE_MASK,
+			(actuator.device_type == LRA)?FEEDBACK_CONTROL_MODE_LRA:FEEDBACK_CONTROL_MODE_ERM);
+	} else {
+		printk("%s, OTP programmed\n", __FUNCTION__);
+	}
+
+	if(actuator.loop == OPEN_LOOP) {
+		if(actuator.device_type == LRA)
+			loop = 0x01;
+		else if(actuator.device_type == ERM)
+			loop = ERM_OpenLoop_Enabled;
+	}
+
+	drv260x_setbit_reg(client, Control3_REG, Control3_REG_LOOP_MASK, loop);
+
+	//for audio to haptics
+	if(pDrv2605Platdata->GpioTrigger == 0)	//not used as external trigger
+	{
+		tmp[0] = AUDIO_HAPTICS_MIN_INPUT_REG;
+		tmp[1] = a2h.a2h_min_input;
+		tmp[2] = AUDIO_HAPTICS_MAX_INPUT_REG;
+		tmp[3] = a2h.a2h_max_input;
+		tmp[4] = AUDIO_HAPTICS_MIN_OUTPUT_REG;
+		tmp[5] = a2h.a2h_min_output;
+		tmp[6] = AUDIO_HAPTICS_MAX_OUTPUT_REG;
+		tmp[7] = a2h.a2h_max_output;
+		drv260x_write_reg_val(client, tmp, sizeof(tmp));
+	}
+}
+
+#ifdef VIBRATOR_AUTO_CALIBRATE
+static int dev_auto_calibrate(struct i2c_client* client, struct drv2605_data *pDrv2605data)
+{
+	int err = 0, status=0;
+
+	err = drv260x_write_reg_val(client, autocal_sequence, sizeof(autocal_sequence));
+	pDrv2605data->mode = AUTO_CALIBRATION;
+
+	/* Wait until the procedure is done */
+	drv2605_poll_go_bit(client);
+	/* Read status */
+	status = drv260x_read_reg(client, STATUS_REG);
+
+	if(pDrv2605data->device_id != (status & DEV_ID_MASK)) {
+		printk("%s, ERROR after calibration status =0x%x\n", __FUNCTION__, status);
+		return -ENODEV;
+	}
+
+	/* Check result */
+	if ((status & DIAG_RESULT_MASK) == AUTO_CAL_FAILED)
+	{
+		printk(KERN_ALERT"drv260x auto-cal failed.\n");
+		drv260x_write_reg_val(client, autocal_sequence, sizeof(autocal_sequence));
+
+		drv2605_poll_go_bit(client);
+		status = drv260x_read_reg(client, STATUS_REG);
+		if ((status & DIAG_RESULT_MASK) == AUTO_CAL_FAILED)
+		{
+			printk(KERN_ALERT"drv260x auto-cal retry failed.\n");
+			// return -ENODEV;
+		}
+	}
+
+	/* Read calibration results */
+	drv260x_read_reg(client, AUTO_CALI_RESULT_REG);
+	drv260x_read_reg(client, AUTO_CALI_BACK_EMF_RESULT_REG);
+	drv260x_read_reg(client, FEEDBACK_CONTROL_REG);
+
+	return err;
+}
+#else
+#ifdef CONFIG_ZTEMT_HAPTICS_DRV2605_DRIVE_ERM
+static int dev_manual_calibrate(struct i2c_client* client, struct drv2605_data *pDrv2605data)
+{
+	return 0;
+}
+#else
+static int dev_manual_calibrate(struct i2c_client* client, struct drv2605_data *pDrv2605data)
+{
+	unsigned char manual_seq[] = {
+		RATED_VOLTAGE_REG,              NUBIA_LRA_RATED_VOLTAGE,
+		OVERDRIVE_CLAMP_VOLTAGE_REG,    NUBIA_LRA_OVERDRIVE_CLAMP_VOLTAGE,
+		AUTO_CALI_RESULT_REG,           NUBIA_LRA_AUTOCAL_COMPENSATION,
+		AUTO_CALI_BACK_EMF_RESULT_REG,  NUBIA_LRA_AUTOCAL_BACKEMF,
+	};
+
+	drv260x_write_reg_val(client, manual_seq, sizeof(manual_seq));
+
+	drv260x_setbit_reg(client, FEEDBACK_CONTROL_REG,
+		FEEDBACK_CONTROL_BEMF_GAIN_MASK, FEEDBACK_CONTROL_BEMF_LRA_GAIN2);
+
+	return 0;
+}
+#endif
+#endif
+
+#ifdef CONFIG_OF
+static int drv260x_parse_dt(struct device *dev,
+			struct drv2605_platform_data *pdata)
+{
+	struct device_node *temp = NULL, *np = dev->of_node;
+	enum of_gpio_flags gpio_enable_flags = OF_GPIO_ACTIVE_LOW;
+	int rc = 0;
+	u32 temp_val = 0;
+
+	pdata->GpioTrigger = of_property_read_bool(np, "immersion,external-trigger");
+	pdata->GpioEnable = of_get_named_gpio_flags(np,
+				"immersion,gpio-enable", 0, &gpio_enable_flags);
+
+	temp = of_find_node_by_name(np, "immersion,actuator");
+	if(!temp) {
+		dev_err(dev, "Unable to find actuator data\n");
+		return -1;
+	}
+	rc = of_property_read_u32(temp, "actuator,type", &pdata->actuator.device_type);
+	if (rc) {
+		dev_err(dev, "Unable to read actuator type\n");
+		return rc;
+	}
+	rc = of_property_read_u32(temp, "actuator,effect-bank", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read actuator effect bank\n");
+		return rc;
+	} else {
+		pdata->actuator.g_effect_bank = temp_val;
+	}
+	rc = of_property_read_u32(temp, "actuator,loop", &pdata->actuator.loop);
+	if (rc) {
+		dev_err(dev, "Unable to read actuator loop type\n");
+		return rc;
+	}
+	rc = of_property_read_u32(temp, "actuator,rated-vol", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read actuator rated voltage\n");
+		return rc;
+	} else {
+		pdata->actuator.rated_vol = temp_val;
+	}
+	rc = of_property_read_u32(temp, "actuator,over-drive-vol", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read actuator over driver voltage\n");
+		return rc;
+	} else {
+		pdata->actuator.over_drive_vol = temp_val;
+	}
+
+	temp = of_find_node_by_name(np, "immersion,audio2haptics");
+	if(!temp) {
+		dev_err(dev, "Unable to find audio2haptics data\n");
+		return -1;
+	}
+	rc = of_property_read_u32(temp, "a2h,min-input", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read a2h min input\n");
+		return rc;
+	} else {
+		pdata->a2h.a2h_min_input = temp_val;
+	}
+	rc = of_property_read_u32(temp, "a2h,max-input", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read a2h max-input\n");
+		return rc;
+	} else {
+		pdata->a2h.a2h_max_input = temp_val;
+	}
+	rc = of_property_read_u32(temp, "a2h,min-output", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read a2h min-output\n");
+		return rc;
+	} else {
+		pdata->a2h.a2h_min_output = temp_val;
+	}
+	rc = of_property_read_u32(temp, "a2h,max-output", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read actuator a2h max-output\n");
+		return rc;
+	} else {
+		pdata->a2h.a2h_max_output = temp_val;
+	}
+
+	vibrator_debug("%s:GpioTrigger=%d, GpioEnable=%d\n", __func__,
+		pdata->GpioTrigger, pdata->GpioEnable);
+	vibrator_debug("%s:actuator:0x%x,0x%x,0x%x,0x%x,0x%x\n", __func__,
+		pdata->actuator.device_type, pdata->actuator.g_effect_bank,
+		pdata->actuator.loop, pdata->actuator.rated_vol,
+		pdata->actuator.over_drive_vol);
+	vibrator_debug("%s:a2h:0x%x,0x%x,0x%x,0x%x\n", __func__,
+		pdata->a2h.a2h_min_input,	pdata->a2h.a2h_max_input,
+		pdata->a2h.a2h_min_output, pdata->a2h.a2h_max_output);
+
+	return 0;
+}
+#else
+static int drv260x_parse_dt(struct device *dev,
+		struct drv2605_platform_data *pdata)
+{
+	return -ENODEV;
+}
+#endif
+
+static int drv260x_probe(struct i2c_client* client, const struct i2c_device_id* id)
+{
+	struct drv2605_data *pDrv2605data;
+	struct drv2605_platform_data *pDrv2605Platdata;
+	int err = 0;
+	int status = 0;
+
+	if (client->dev.of_node) {
+		pDrv2605Platdata = devm_kzalloc(&client->dev,
+			sizeof(struct drv2605_platform_data), GFP_KERNEL);
+		if (!pDrv2605Platdata) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			return -ENOMEM;
+		}
+
+		err = drv260x_parse_dt(&client->dev, pDrv2605Platdata);
+		if (err) {
+			dev_err(&client->dev, "Parsing DT failed(%d)", err);
+			return err;
+		}
+	} else {
+		pDrv2605Platdata = client->dev.platform_data;
+	}
+
+	if (!pDrv2605Platdata) {
+		dev_err(&client->dev, "%s: no platform data\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+	{
+		printk(KERN_ERR"%s:I2C check failed\n", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	pDrv2605data = kzalloc(sizeof(struct drv2605_data),GFP_KERNEL);
+	if(!pDrv2605data){
+		err = -ENOMEM;
+		printk(KERN_ERR"%s: -ENOMEM error\n", __FUNCTION__);
+		goto exit_alloc_data_failed;
+	}
+
+	pDrv2605data->client = client;
+	this_client = client;
+
+	memcpy(&pDrv2605data->PlatData, pDrv2605Platdata, sizeof(struct drv2605_platform_data));
+	i2c_set_clientdata(client,pDrv2605data);
+
+	if(pDrv2605data->PlatData.GpioTrigger){
+		err = gpio_request(pDrv2605data->PlatData.GpioTrigger, HAPTICS_DEVICE_NAME"Trigger");
+		if(err < 0){
+			printk(KERN_ERR"%s: GPIO request Trigger error\n", __FUNCTION__);				
+			goto exit_gpio_request_failed1;
+		}
+	}
+
+	if(pDrv2605data->PlatData.GpioEnable){
+		err = gpio_request(pDrv2605data->PlatData.GpioEnable, HAPTICS_DEVICE_NAME"Enable");
+		if(err < 0){
+			printk(KERN_ERR"%s: GPIO request enable error\n", __FUNCTION__);
+			goto exit_gpio_request_failed2;
+		}
+
+		/* Enable power to the chip */
+		gpio_direction_output(pDrv2605data->PlatData.GpioEnable, GPIO_LEVEL_HIGH);
+
+		/* Wait 30 us */
+		udelay(30);
+	}
+
+	status = drv260x_read_reg(pDrv2605data->client, STATUS_REG);
+	/* Read device ID */
+	pDrv2605data->device_id = (status & DEV_ID_MASK);
+	switch (pDrv2605data->device_id)
+	{
+	case DRV2605_VER_1DOT1:
+		printk("drv260x driver found: drv2605 v1.1.\n");
+		break;
+	case DRV2605_VER_1DOT0:
+		printk("drv260x driver found: drv2605 v1.0.\n");
+		break;
+	case DRV2604:
+		printk(KERN_ALERT"drv260x driver found: drv2604.\n");
+		break;
+	default:
+		printk(KERN_ERR"drv260x driver found: unknown.\n");
+		break;
+	}
+
+	if((pDrv2605data->device_id != DRV2605_VER_1DOT1)
+		&& (pDrv2605data->device_id != DRV2605_VER_1DOT0)) {
+		printk("%s, status(0x%x),device_id(%d) fail\n",
+			__FUNCTION__, status, pDrv2605data->device_id);
+		err = -ENODEV;
+		goto exit_device_id_failed;
+	}
+
+	pDrv2605data->mode = MODE_STANDBY;
+
+	drv260x_change_mode(pDrv2605data->client, MODE_INTERNAL_TRIGGER);
+	schedule_timeout_interruptible(msecs_to_jiffies(STANDBY_WAKE_DELAY));
+
+	pDrv2605data->OTP = drv260x_read_reg(pDrv2605data->client, AUTOCAL_MEM_INTERFACE_REG) & AUTOCAL_MEM_INTERFACE_REG_OTP_MASK;
+
+	dev_init_platform_data(pDrv2605data->client, pDrv2605data);
+
+#ifdef VIBRATOR_AUTO_CALIBRATE
+	if(pDrv2605data->OTP == 0) {
+		err = dev_auto_calibrate(pDrv2605data->client, pDrv2605data);
+		if(err < 0){
+			printk("%s, ERROR, calibration fail\n",	__FUNCTION__);
+			goto exit_device_id_failed;
+		}
+	}
+#else
+	if(pDrv2605data->OTP == 0) {
+		dev_manual_calibrate(pDrv2605data->client, pDrv2605data);
+	}
+#endif
+
+	/* Put hardware in standby */
+	drv260x_change_mode(pDrv2605data->client, MODE_STANDBY);
+
+	Haptics_init(pDrv2605data);
+
+	printk("drv260x probe succeeded\n");
+
+	return 0;
+
+	exit_device_id_failed:
+	if(pDrv2605data->PlatData.GpioEnable){
+		gpio_set_value(pDrv2605data->PlatData.GpioEnable, GPIO_LEVEL_LOW);
+		gpio_free(pDrv2605data->PlatData.GpioEnable);
+	}
+
+	exit_gpio_request_failed2:
+	if(pDrv2605data->PlatData.GpioTrigger){
+		gpio_free(pDrv2605data->PlatData.GpioTrigger);
+	}
+
+	exit_gpio_request_failed1:
+	if(pDrv2605data){
+		kfree(pDrv2605data);
+	}
+	exit_alloc_data_failed:
+	printk(KERN_ERR"%s failed, err=%d\n",__FUNCTION__, err);
+	return err;
+}
+
+static int drv260x_remove(struct i2c_client* client)
+{
+	struct drv2605_data *pDrv2605Data = i2c_get_clientdata(client);
+
+	device_destroy(pDrv2605Data->class, pDrv2605Data->version);
+	class_destroy(pDrv2605Data->class);
+	unregister_chrdev_region(pDrv2605Data->version, 1);
+
+	if(pDrv2605Data->PlatData.GpioTrigger)
+	gpio_free(pDrv2605Data->PlatData.GpioTrigger);
+
+	if(pDrv2605Data->PlatData.GpioEnable)
+	gpio_free(pDrv2605Data->PlatData.GpioEnable);
+
+	kfree(pDrv2605Data);
+
+	i2c_set_clientdata(client,NULL);
+
+	printk(KERN_ALERT"drv260x remove");
+
+	return 0;
+}
+
+
+static struct i2c_device_id drv260x_id_table[] =
+{
+	{ HAPTICS_DEVICE_NAME, 0 },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, drv260x_id_table);
+
+#ifdef CONFIG_OF
+static struct of_device_id drv2605_match_table[] = {
+	{ .compatible = "immersion,drv2605",},
+	{ },
+};
+#else
+#define drv2605_match_table NULL
+#endif
+
+static struct i2c_driver drv260x_driver =
+{
+	.driver = {
+		.name = HAPTICS_DEVICE_NAME,
+		.of_match_table = drv2605_match_table,
+	},
+	.id_table = drv260x_id_table,
+	.probe = drv260x_probe,
+	.remove = drv260x_remove,
+	.suspend = drv260x_suspend,
+	.resume = drv260x_resume
+};
+
+static int __init drv260x_init(void)
+{
+	return i2c_add_driver(&drv260x_driver);
+}
+
+static void __exit drv260x_exit(void)
+{
+	i2c_del_driver(&drv260x_driver);
+}
+
+module_init(drv260x_init);
+module_exit(drv260x_exit);
+
+MODULE_AUTHOR("Texas Instrument Inc.");
+MODULE_DESCRIPTION("Driver for "HAPTICS_DEVICE_NAME);
diff --git a/drivers/mmc/Kconfig b/drivers/mmc/Kconfig
old mode 100644
new mode 100755
diff --git a/drivers/mmc/Makefile b/drivers/mmc/Makefile
old mode 100644
new mode 100755
diff --git a/drivers/mmc/card/Kconfig b/drivers/mmc/card/Kconfig
old mode 100644
new mode 100755
diff --git a/drivers/mmc/card/Makefile b/drivers/mmc/card/Makefile
old mode 100644
new mode 100755
diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
old mode 100644
new mode 100755
index 9bf4804..e2ccb33
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -2689,11 +2689,21 @@ static int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
 		/* complete ongoing async transfer before issuing discard */
 		if (card->host->areq)
 			mmc_blk_issue_rw_rq(mq, NULL);
+//ztemt modify by ttwang for factory reset too long time 2014/07/03
+#if 1
+		if(0){
+		if (cmd_flags & REQ_SECURE &&
+			!(card->quirks & MMC_QUIRK_SEC_ERASE_TRIM_BROKEN))
+			ret = mmc_blk_issue_secdiscard_rq(mq, req);
+		}
+			ret = mmc_blk_issue_discard_rq(mq, req);
+#else
 		if (cmd_flags & REQ_SECURE &&
 			!(card->quirks & MMC_QUIRK_SEC_ERASE_TRIM_BROKEN))
 			ret = mmc_blk_issue_secdiscard_rq(mq, req);
 		else
 			ret = mmc_blk_issue_discard_rq(mq, req);
+#endif
 	} else if (cmd_flags & REQ_FLUSH) {
 		/* complete ongoing async transfer before issuing flush */
 		if (card->host->areq)
diff --git a/drivers/mmc/card/mmc_block_test.c b/drivers/mmc/card/mmc_block_test.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/card/mmc_test.c b/drivers/mmc/card/mmc_test.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/card/queue.c b/drivers/mmc/card/queue.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/card/queue.h b/drivers/mmc/card/queue.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/card/sdio_uart.c b/drivers/mmc/card/sdio_uart.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/Kconfig b/drivers/mmc/core/Kconfig
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/Makefile b/drivers/mmc/core/Makefile
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/bus.c b/drivers/mmc/core/bus.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/bus.h b/drivers/mmc/core/bus.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/cd-gpio.c b/drivers/mmc/core/cd-gpio.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
old mode 100644
new mode 100755
index 1f71ac2..66c7e3b
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -3192,12 +3192,23 @@ int mmc_detect_card_removed(struct mmc_host *host)
 }
 EXPORT_SYMBOL(mmc_detect_card_removed);
 
+extern void clear_detect_flag(void);
+extern int check_detect_flag(void);
 void mmc_rescan(struct work_struct *work)
 {
 	struct mmc_host *host =
 		container_of(work, struct mmc_host, detect.work);
 	bool extend_wakelock = false;
 
+	if(host->index == 1) {
+		if(check_detect_flag()) {
+			printk("Broadcom enable detect, continue\n");
+			clear_detect_flag();
+		} else {
+			printk("Broadcom didn't enable detect, skip\n");
+			return;
+		}
+	}
 	if (host->rescan_disable)
 		return;
 
diff --git a/drivers/mmc/core/core.h b/drivers/mmc/core/core.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/debugfs.c b/drivers/mmc/core/debugfs.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/host.c b/drivers/mmc/core/host.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/host.h b/drivers/mmc/core/host.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/mmc_ops.c b/drivers/mmc/core/mmc_ops.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/mmc_ops.h b/drivers/mmc/core/mmc_ops.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/quirks.c b/drivers/mmc/core/quirks.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
old mode 100644
new mode 100755
index ee5a454..71d4392
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1134,11 +1134,11 @@ static void mmc_sd_remove(struct mmc_host *host)
 	BUG_ON(!host);
 	BUG_ON(!host->card);
 
-	mmc_exit_clk_scaling(host);
 	mmc_remove_card(host->card);
 
 	mmc_claim_host(host);
 	host->card = NULL;
+	mmc_exit_clk_scaling(host);
 	mmc_release_host(host);
 }
 
diff --git a/drivers/mmc/core/sd.h b/drivers/mmc/core/sd.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/sd_ops.c b/drivers/mmc/core/sd_ops.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/sd_ops.h b/drivers/mmc/core/sd_ops.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/sdio_bus.h b/drivers/mmc/core/sdio_bus.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/sdio_cis.h b/drivers/mmc/core/sdio_cis.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/sdio_ops.c b/drivers/mmc/core/sdio_ops.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/core/sdio_ops.h b/drivers/mmc/core/sdio_ops.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/at91_mci.c b/drivers/mmc/host/at91_mci.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/at91_mci.h b/drivers/mmc/host/at91_mci.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/atmel-mci-regs.h b/drivers/mmc/host/atmel-mci-regs.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/atmel-mci.c b/drivers/mmc/host/atmel-mci.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/au1xmmc.c b/drivers/mmc/host/au1xmmc.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/bfin_sdh.c b/drivers/mmc/host/bfin_sdh.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/cb710-mmc.c b/drivers/mmc/host/cb710-mmc.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/cb710-mmc.h b/drivers/mmc/host/cb710-mmc.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/davinci_mmc.c b/drivers/mmc/host/davinci_mmc.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/dw_mmc-pci.c b/drivers/mmc/host/dw_mmc-pci.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/dw_mmc-pltfm.c b/drivers/mmc/host/dw_mmc-pltfm.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/dw_mmc.c b/drivers/mmc/host/dw_mmc.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/dw_mmc.h b/drivers/mmc/host/dw_mmc.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/imxmmc.c b/drivers/mmc/host/imxmmc.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/imxmmc.h b/drivers/mmc/host/imxmmc.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/jz4740_mmc.c b/drivers/mmc/host/jz4740_mmc.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/mmc_spi.c b/drivers/mmc/host/mmc_spi.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/mmci.c b/drivers/mmc/host/mmci.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/msm_sdcc.c b/drivers/mmc/host/msm_sdcc.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/msm_sdcc.h b/drivers/mmc/host/msm_sdcc.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/msm_sdcc_dml.c b/drivers/mmc/host/msm_sdcc_dml.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/msm_sdcc_dml.h b/drivers/mmc/host/msm_sdcc_dml.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/mvsdio.c b/drivers/mmc/host/mvsdio.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/mvsdio.h b/drivers/mmc/host/mvsdio.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/mxcmmc.c b/drivers/mmc/host/mxcmmc.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/mxs-mmc.c b/drivers/mmc/host/mxs-mmc.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/of_mmc_spi.c b/drivers/mmc/host/of_mmc_spi.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/omap.c b/drivers/mmc/host/omap.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/omap_hsmmc.c b/drivers/mmc/host/omap_hsmmc.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/pxamci.c b/drivers/mmc/host/pxamci.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/pxamci.h b/drivers/mmc/host/pxamci.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/s3cmci.c b/drivers/mmc/host/s3cmci.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/s3cmci.h b/drivers/mmc/host/s3cmci.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/sdhci-cns3xxx.c b/drivers/mmc/host/sdhci-cns3xxx.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/sdhci-dove.c b/drivers/mmc/host/sdhci-dove.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/sdhci-esdhc-imx.c b/drivers/mmc/host/sdhci-esdhc-imx.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/sdhci-esdhc.h b/drivers/mmc/host/sdhci-esdhc.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/sdhci-msm.c b/drivers/mmc/host/sdhci-msm.c
old mode 100644
new mode 100755
index 2c96d3c..cffa1b1
--- a/drivers/mmc/host/sdhci-msm.c
+++ b/drivers/mmc/host/sdhci-msm.c
@@ -2702,6 +2702,31 @@ static int sdhci_msm_cfg_mpm_pin_wakeup(struct sdhci_host *host, unsigned mode)
 	}
 	return ret;
 }
+//shaohua add
+static void
+msm_check_status(unsigned long data)
+{
+	struct sdhci_host *host = (struct sdhci_host *)data;
+
+	mmc_detect_change(host->mmc, 0);
+}
+
+
+static void
+msm_status_notify_cb(int card_present, void *dev_id)
+{
+	struct sdhci_host *host = dev_id;
+
+	printk("shaohua, %s: card_present %d\n", mmc_hostname(host->mmc),
+	       card_present);
+	msm_check_status((unsigned long) host);
+}
+
+extern int bcm_wifi_status_register(
+                        void (*callback)(int card_present, void *dev_id),
+                        void *dev_id);
+
+//shaohua add
 
 static int __devinit sdhci_msm_probe(struct platform_device *pdev)
 {
@@ -3033,6 +3058,10 @@ static int __devinit sdhci_msm_probe(struct platform_device *pdev)
 			spin_unlock_irqrestore(&host->lock, flags);
 		}
 	}
+//shaohua add
+	if(host->mmc->index == 1)
+		bcm_wifi_status_register(msm_status_notify_cb, host);
+//shaohua add
 
 	ret = sdhci_add_host(host);
 	if (ret) {
diff --git a/drivers/mmc/host/sdhci-of-esdhc.c b/drivers/mmc/host/sdhci-of-esdhc.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/sdhci-of-hlwd.c b/drivers/mmc/host/sdhci-of-hlwd.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/sdhci-pci-data.c b/drivers/mmc/host/sdhci-pci-data.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/sdhci-pci.c b/drivers/mmc/host/sdhci-pci.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/sdhci-pltfm.c b/drivers/mmc/host/sdhci-pltfm.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/sdhci-pltfm.h b/drivers/mmc/host/sdhci-pltfm.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/sdhci-pxav2.c b/drivers/mmc/host/sdhci-pxav2.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/sdhci-pxav3.c b/drivers/mmc/host/sdhci-pxav3.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/sdhci-s3c.c b/drivers/mmc/host/sdhci-s3c.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/sdhci-spear.c b/drivers/mmc/host/sdhci-spear.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/sdhci-tegra.c b/drivers/mmc/host/sdhci-tegra.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
old mode 100644
new mode 100755
index ba07348..532c0b1
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -2035,8 +2035,11 @@ static int sdhci_do_start_signal_voltage_switch(struct sdhci_host *host,
 				 */
 				present_state = sdhci_readl(host,
 							SDHCI_PRESENT_STATE);
-				if ((present_state & SDHCI_DATA_LVL_MASK) ==
-				     SDHCI_DATA_LVL_MASK)
+				/*
+				 * WiFi PATCH
+				 */
+/*				if ((present_state & SDHCI_DATA_LVL_MASK) ==
+				     SDHCI_DATA_LVL_MASK)*/
 					return 0;
 			}
 		}
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/sdricoh_cs.c b/drivers/mmc/host/sdricoh_cs.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/sh_mmcif.c b/drivers/mmc/host/sh_mmcif.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/sh_mobile_sdhi.c b/drivers/mmc/host/sh_mobile_sdhi.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/tifm_sd.c b/drivers/mmc/host/tifm_sd.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/tmio_mmc.c b/drivers/mmc/host/tmio_mmc.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/tmio_mmc.h b/drivers/mmc/host/tmio_mmc.h
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/tmio_mmc_dma.c b/drivers/mmc/host/tmio_mmc_dma.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/tmio_mmc_pio.c b/drivers/mmc/host/tmio_mmc_pio.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/ushc.c b/drivers/mmc/host/ushc.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/via-sdmmc.c b/drivers/mmc/host/via-sdmmc.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/vub300.c b/drivers/mmc/host/vub300.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/wbsd.c b/drivers/mmc/host/wbsd.c
old mode 100644
new mode 100755
diff --git a/drivers/mmc/host/wbsd.h b/drivers/mmc/host/wbsd.h
old mode 100644
new mode 100755
diff --git a/drivers/net/wireless/bcmdhd/Kconfig b/drivers/net/wireless/bcmdhd/Kconfig
old mode 100644
new mode 100755
diff --git a/drivers/net/wireless/bcmdhd/Makefile b/drivers/net/wireless/bcmdhd/Makefile
old mode 100644
new mode 100755
index 7925661..5043cf9
--- a/drivers/net/wireless/bcmdhd/Makefile
+++ b/drivers/net/wireless/bcmdhd/Makefile
@@ -1,39 +1,69 @@
 # bcmdhd
-#	-DDHDTHREAD -DDHD_GPL -DDHD_SCHED -DDHD_DEBUG -DSDTEST -DBDC -DTOE    \
-#	-DDHD_BCMEVENTS -DSHOW_EVENTS -DDONGLEOVERLAYS -DBCMDBG               \
-#	-DCUSTOMER_HW2 -DOOB_INTR_ONLY -DHW_OOB       \
-#	-DMMC_SDIO_ABORT -DBCMSDIO -DBCMLXSDMMC -DBCMPLATFORM_BUS -DWLP2P     \
-#	-DNEW_COMPAT_WIRELESS -DWIFI_ACT_FRAME -DARP_OFFLOAD_SUPPORT          \
-#	-DKEEP_ALIVE -DCSCAN -DGET_CUSTOM_MAC_ENABLE -DPKT_FILTER_SUPPORT     \
-#	-DEMBEDDED_PLATFORM -DENABLE_INSMOD_NO_FW_LOAD -DPNO_SUPPORT          \
-
 DHDCFLAGS = -Wall -Wstrict-prototypes -Dlinux -DBCMDRIVER                     \
-	-DBCMDONGLEHOST -DUNRELEASEDCHIP -DBCMDMA32 -DBCMFILEIMAGE            \
-	-DDHDTHREAD -DDHD_DEBUG -DSDTEST -DBDC -DTOE                          \
-	-DDHD_BCMEVENTS -DSHOW_EVENTS -DPROP_TXSTATUS -DBCMDBG                \
-	-DCUSTOMER_HW2 -DOOB_INTR_ONLY -DHW_OOB                               \
+	-DDHD_FIRSTREAD=128 -DMAX_HDR_READ=128                                \
+	-DPROP_TXSTATUS_VSDB -DPROP_TXSTATUS  -DCONFIG_HAS_WAKELOCK         \
+	-DBCMDONGLEHOST -DUNRELEASEDCHIP -DBCMDMA32 -DWLBTAMP -DBCMFILEIMAGE  \
+	-DDHDTHREAD -DDHD_GPL -DDHD_SCHED -DDHD_DEBUG -DSDTEST -DBDC -DTOE    \
+	-DDHD_BCMEVENTS -DSHOW_EVENTS -DDONGLEOVERLAYS -DBCMDBG               \
+	-DCUSTOMER_HW2 -DCUSTOM_OOB_GPIO_NUM=2 -DOOB_INTR_ONLY -DHW_OOB       \
 	-DMMC_SDIO_ABORT -DBCMSDIO -DBCMLXSDMMC -DBCMPLATFORM_BUS -DWLP2P     \
-	-DWIFI_ACT_FRAME -DARP_OFFLOAD_SUPPORT                                \
-	-DKEEP_ALIVE -DGET_CUSTOM_MAC_ENABLE -DPKT_FILTER_SUPPORT             \
+	-DNEW_COMPAT_WIRELESS -DWIFI_ACT_FRAME -DARP_OFFLOAD_SUPPORT          \
+	-DKEEP_ALIVE -DCSCAN -DGET_CUSTOM_MAC_ENABLE -DPKT_FILTER_SUPPORT     \
 	-DEMBEDDED_PLATFORM -DENABLE_INSMOD_NO_FW_LOAD -DPNO_SUPPORT          \
+	-DOEM_ANDROID -DLINUX -DWL_ENABLE_P2P_IF -DWL_CFG80211_STA_EVENT -DHT40_GO  \
+	-DWL_SUPPORT_BACKPORTED_KPATCHES \
 	-Idrivers/net/wireless/bcmdhd -Idrivers/net/wireless/bcmdhd/include
 
+DHDCFLAGS += -DDHD_FIRSTREAD=128 -DDHD_SDALIGN=32 -DMAX_HDR_READ=128           
+ 
+DHDCFLAGS += -DOOB_INTR_ONLY	-DHW_OOB
+
+DHDCFLAGS += -DCONFIG_WIFI_CONTROL_FUNC  -DENHANCED_STATIC_BUF -DCONFIG_DHD_USE_STATIC_BUF 
+
+  DHDCFLAGS += -DDHD_USE_IDLECOUNT
+  DHDCFLAGS += -DPROP_TXSTATUS  -DPROP_TXSTATUS_VSDB
+
+
+# rxglom use chain
+  DHDCFLAGS += -DCUSTOM_RXCHAIN=1
+
+# txglom enable, maxtxglom size, increase txbound 
+  DHDCFLAGS += -DBCMSDIOH_TXGLOM -DCUSTOM_TXGLOM=1 -DBCMSDIOH_TXGLOM_HIGHSPEED
+  DHDCFLAGS += -DCUSTOM_TXGLOM_SIZE=32 -DCUSTOM_MAX_TXGLOM_SIZE=32 -DDHD_TXBOUND=40
+
+# inprove tcp ack
+  DHDCFLAGS += -DDHDTCPACK_SUPPRESS
+
+# enable frameburst
+  DHDCFLAGS += -DUSE_WL_FRAMEBURST
+# enable rx_thread
+  DHDCFLAGS += -DRXFRAME_THREAD
+DHDCFLAGS += -DWL_CFG80211 -DWL_CFG80211_STA_EVENT -DWL_ENABLE_P2P_IF
+DHDCFLAGS += -DWL_IFACE_COMB_NUM_CHANNELS
+
+# decrease ampdu size from 64 to 40
+  DHDCFLAGS += -DCUSTOM_AMPDU_BA_WSIZE=40
 DHDOFILES = aiutils.o bcmsdh_sdmmc_linux.o dhd_linux.o siutils.o bcmutils.o   \
-	dhd_linux_sched.o dhd_sdio.o bcmwifi_channels.o bcmevent.o hndpmu.o   \
-	bcmsdh.o dhd_cdc.o bcmsdh_linux.o dhd_common.o linux_osl.o            \
-	bcmsdh_sdmmc.o dhd_custom_gpio.o sbutils.o wldev_common.o wl_android.o
+	dhd_linux_sched.o bcmwifi_channels.o dhd_sdio.o bcmevent.o dhd_bta.o hndpmu.o  \
+	bcmsdh.o dhd_cdc.o bcmsdh_linux.o dhd_common.o dhd_wlfc.o dhd_ip.o linux_osl.o \
+	bcmsdh_sdmmc.o dhd_custom_gpio.o sbutils.o wldev_common.o wl_android.o dhd_cfg80211.o
 
 obj-$(CONFIG_BCMDHD) += bcmdhd.o
 bcmdhd-objs += $(DHDOFILES)
 ifneq ($(CONFIG_WIRELESS_EXT),)
 bcmdhd-objs += wl_iw.o
-DHDCFLAGS += -DSOFTAP -DUSE_IW
+#DHDCFLAGS += -DSOFTAP
 endif
 ifneq ($(CONFIG_CFG80211),)
-bcmdhd-objs += wl_cfg80211.o wl_cfgp2p.o wl_linux_mon.o dhd_cfg80211.o
-DHDCFLAGS += -DWL_CFG80211 -DWL_CFG80211_STA_EVENT -DWL_ENABLE_P2P_IF
+bcmdhd-objs += wl_cfg80211.o wl_cfgp2p.o wl_linux_mon.o
+#DHDCFLAGS += -DCUSTOM_ROAM_TRIGGER_SETTING=-65
+DHDCFLAGS += -DCUSTOM_ROAM_TRIGGER_SETTING=-85
+DHDCFLAGS += -DWL_CFG80211
 endif
 EXTRA_CFLAGS = $(DHDCFLAGS)
 ifeq ($(CONFIG_BCMDHD),m)
 EXTRA_LDFLAGS += --strip-debug
 endif
+DHDCFLAGS += -DWL_SUPPORT_BACKPORTED_KPATCHES
+DHDCFLAGS += -DWL_IFACE_COMB_NUM_CHANNELS
+#DHDCFLAGS += -DBCMWAPI_WPI -DBCMWAPI_WAI
diff --git a/drivers/net/wireless/bcmdhd/aiutils.c b/drivers/net/wireless/bcmdhd/aiutils.c
old mode 100644
new mode 100755
index f1db5a2..ec3f537
--- a/drivers/net/wireless/bcmdhd/aiutils.c
+++ b/drivers/net/wireless/bcmdhd/aiutils.c
@@ -2,27 +2,9 @@
  * Misc utility routines for accessing chip-specific features
  * of the SiliconBackplane-based Broadcom chips.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: aiutils.c 321247 2012-03-14 21:14:33Z $
+ * $Id: aiutils.c 385510 2013-02-15 21:02:07Z $
  */
 #include <bcm_cfg.h>
 #include <typedefs.h>
@@ -38,6 +20,7 @@
 
 #define BCM47162_DMP() (0)
 #define BCM5357_DMP() (0)
+#define BCM4707_DMP() (0)
 #define remap_coreid(sih, coreid)	(coreid)
 #define remap_corerev(sih, corerev)	(corerev)
 
@@ -207,7 +190,7 @@ ai_scan(si_t *sih, void *regs, uint devid)
 					sii->oob_router = addrl;
 				}
 			}
-			if (cid != GMAC_COMMON_4706_CORE_ID)
+			if (cid != GMAC_COMMON_4706_CORE_ID && cid != NS_CCB_CORE_ID)
 				continue;
 		}
 
@@ -231,17 +214,27 @@ ai_scan(si_t *sih, void *regs, uint devid)
 		
 		asd = get_asd(sih, &eromptr, 0, 0, AD_ST_SLAVE, &addrl, &addrh, &sizel, &sizeh);
 		if (asd == 0) {
+			do {
 			
 			asd = get_asd(sih, &eromptr, 0, 0, AD_ST_BRIDGE, &addrl, &addrh,
 			              &sizel, &sizeh);
 			if (asd != 0)
 				br = TRUE;
-			else
-				if ((addrh != 0) || (sizeh != 0) || (sizel != SI_CORE_SIZE)) {
-					SI_ERROR(("First Slave ASD for core 0x%04x malformed "
-					          "(0x%08x)\n", cid, asd));
-					goto error;
+			else {
+					if (br == TRUE) {
+						break;
+					}
+					else if ((addrh != 0) || (sizeh != 0) ||
+						(sizel != SI_CORE_SIZE)) {
+						SI_ERROR(("addrh = 0x%x\t sizeh = 0x%x\t size1 ="
+							"0x%x\n", addrh, sizeh, sizel));
+						SI_ERROR(("First Slave ASD for"
+							"core 0x%04x malformed "
+							"(0x%08x)\n", cid, asd));
+						goto error;
+					}
 				}
+			} while (1);
 		}
 		sii->coresba[idx] = addrl;
 		sii->coresba_size[idx] = sizel;
@@ -348,7 +341,7 @@ ai_setcoreidx(si_t *sih, uint coreidx)
 			ASSERT(GOODREGS(sii->regs[coreidx]));
 		}
 		sii->curmap = regs = sii->regs[coreidx];
-		if (!sii->wrappers[coreidx]) {
+		if (!sii->wrappers[coreidx] && (wrap != 0)) {
 			sii->wrappers[coreidx] = REG_MAP(wrap, SI_CORE_SIZE);
 			ASSERT(GOODREGS(sii->wrappers[coreidx]));
 		}
@@ -524,11 +517,41 @@ ai_flag(si_t *sih)
 		SI_ERROR(("%s: Attempting to read USB20H DMP registers on 5357b0\n", __FUNCTION__));
 		return sii->curidx;
 	}
+	if (BCM4707_DMP()) {
+		SI_ERROR(("%s: Attempting to read CHIPCOMMONB DMP registers on 4707\n",
+			__FUNCTION__));
+		return sii->curidx;
+	}
 	ai = sii->curwrap;
 
 	return (R_REG(sii->osh, &ai->oobselouta30) & 0x1f);
 }
 
+uint
+ai_flag_alt(si_t *sih)
+{
+	si_info_t *sii;
+	aidmp_t *ai;
+
+	sii = SI_INFO(sih);
+	if (BCM47162_DMP()) {
+		SI_ERROR(("%s: Attempting to read MIPS DMP registers on 47162a0", __FUNCTION__));
+		return sii->curidx;
+	}
+	if (BCM5357_DMP()) {
+		SI_ERROR(("%s: Attempting to read USB20H DMP registers on 5357b0\n", __FUNCTION__));
+		return sii->curidx;
+	}
+	if (BCM4707_DMP()) {
+		SI_ERROR(("%s: Attempting to read CHIPCOMMONB DMP registers on 4707\n",
+			__FUNCTION__));
+		return sii->curidx;
+	}
+	ai = sii->curwrap;
+
+	return ((R_REG(sii->osh, &ai->oobselouta30) >> AI_OOBSEL_1_SHIFT) & AI_OOBSEL_MASK);
+}
+
 void
 ai_setint(si_t *sih, int siflag)
 {
@@ -697,15 +720,15 @@ ai_core_disable(si_t *sih, uint32 bits)
 		
 	}
 
-	W_REG(sii->osh, &ai->ioctrl, bits);
-	dummy = R_REG(sii->osh, &ai->ioctrl);
-	BCM_REFERENCE(dummy);
-	OSL_DELAY(10);
-
 	W_REG(sii->osh, &ai->resetctrl, AIRC_RESET);
 	dummy = R_REG(sii->osh, &ai->resetctrl);
 	BCM_REFERENCE(dummy);
 	OSL_DELAY(1);
+
+	W_REG(sii->osh, &ai->ioctrl, bits);
+	dummy = R_REG(sii->osh, &ai->ioctrl);
+	BCM_REFERENCE(dummy);
+	OSL_DELAY(10);
 }
 
 
@@ -758,6 +781,11 @@ ai_core_cflags_wo(si_t *sih, uint32 mask, uint32 val)
 		          __FUNCTION__));
 		return;
 	}
+	if (BCM4707_DMP()) {
+		SI_ERROR(("%s: Accessing CHIPCOMMONB DMP register (ioctrl) on 4707\n",
+			__FUNCTION__));
+		return;
+	}
 
 	ASSERT(GOODREGS(sii->curwrap));
 	ai = sii->curwrap;
@@ -788,6 +816,11 @@ ai_core_cflags(si_t *sih, uint32 mask, uint32 val)
 		          __FUNCTION__));
 		return 0;
 	}
+	if (BCM4707_DMP()) {
+		SI_ERROR(("%s: Accessing CHIPCOMMONB DMP register (ioctrl) on 4707\n",
+			__FUNCTION__));
+		return 0;
+	}
 
 	ASSERT(GOODREGS(sii->curwrap));
 	ai = sii->curwrap;
@@ -820,6 +853,11 @@ ai_core_sflags(si_t *sih, uint32 mask, uint32 val)
 		          __FUNCTION__));
 		return 0;
 	}
+	if (BCM4707_DMP()) {
+		SI_ERROR(("%s: Accessing CHIPCOMMONB DMP register (ioctrl) on 4707\n",
+			__FUNCTION__));
+		return 0;
+	}
 
 	ASSERT(GOODREGS(sii->curwrap));
 	ai = sii->curwrap;
diff --git a/drivers/net/wireless/bcmdhd/bcmevent.c b/drivers/net/wireless/bcmdhd/bcmevent.c
old mode 100644
new mode 100755
index cecea60..0fdf5d1
--- a/drivers/net/wireless/bcmdhd/bcmevent.c
+++ b/drivers/net/wireless/bcmdhd/bcmevent.c
@@ -1,26 +1,8 @@
 /*
  * bcmevent read-only data shared by kernel or app layers
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
- * $Id: bcmevent.c 327460 2012-04-13 18:38:41Z $
+ * $Copyright Open Broadcom Corporation$
+ * $Id: bcmevent.c 389384 2013-03-06 12:20:17Z $
  */
 
 #include <typedefs.h>
@@ -29,7 +11,7 @@
 #include <proto/bcmeth.h>
 #include <proto/bcmevent.h>
 
-#if WLC_E_LAST != 94
+#if WLC_E_LAST != 125
 #error "You need to add an entry to bcmevent_names[] for the new event"
 #endif
 
@@ -74,6 +56,10 @@ const bcmevent_name_t bcmevent_names[] = {
 #endif /* defined(IBSS_PEER_DISCOVERY_EVENT) */
 	{ WLC_E_RADIO, "RADIO" },
 	{ WLC_E_PSM_WATCHDOG, "PSM_WATCHDOG" },
+#if defined(BCMCCX) && defined(CCX_SDK)
+	{ WLC_E_CCX_ASSOC_START, "CCX_ASSOC_START" },
+	{ WLC_E_CCX_ASSOC_ABORT, "CCX_ASSOC_ABORT" },
+#endif /* BCMCCX && CCX_SDK */
 	{ WLC_E_PROBREQ_MSG, "PROBE_REQ_MSG" },
 	{ WLC_E_SCAN_CONFIRM_IND, "SCAN_CONFIRM_IND" },
 	{ WLC_E_PSK_SUP, "PSK_SUP" },
@@ -98,7 +84,7 @@ const bcmevent_name_t bcmevent_names[] = {
 	{ WLC_E_ACTION_FRAME_RX, "ACTION_FRAME_RX" },
 	{ WLC_E_ACTION_FRAME_COMPLETE, "ACTION_FRAME_COMPLETE" },
 #endif
-#if 0 && (NDISVER >= 0x0620)
+#if 0 && (0>= 0x0620)
 	{ WLC_E_PRE_ASSOC_IND, "ASSOC_RECV" },
 	{ WLC_E_PRE_REASSOC_IND, "REASSOC_RECV" },
 	{ WLC_E_CHANNEL_ADOPTED, "CHANNEL_ADOPTED" },
@@ -109,7 +95,8 @@ const bcmevent_name_t bcmevent_names[] = {
 	{ WLC_E_REASSOC_IND_NDIS, "REASSOC_IND_NDIS"},
 	{ WLC_E_ACTION_FRAME_RX_NDIS, "WLC_E_ACTION_FRAME_RX_NDIS" },
 	{ WLC_E_AUTH_REQ, "WLC_E_AUTH_REQ" },
-#endif
+	{ WLC_E_IBSS_COALESCE, "IBSS COALESCE" },
+#endif 
 #ifdef BCMWAPI_WAI
 	{ WLC_E_WAI_STA_EVENT, "WAI_STA_EVENT" },
 	{ WLC_E_WAI_MSG, "WAI_MSG" },
@@ -143,6 +130,22 @@ const bcmevent_name_t bcmevent_names[] = {
 #ifdef WLTDLS
 	{ WLC_E_TDLS_PEER_EVENT, "TDLS_PEER_EVENT" },
 #endif /* WLTDLS */
+	{ WLC_E_NATIVE, "NATIVE" },
+#ifdef WLPKTDLYSTAT
+	{ WLC_E_PKTDELAY_IND, "PKTDELAY_IND" },
+#endif /* WLPKTDLYSTAT */
+	{ WLC_E_SERVICE_FOUND, "SERVICE_FOUND" },
+	{ WLC_E_GAS_FRAGMENT_RX, "GAS_FRAGMENT_RX" },
+	{ WLC_E_GAS_COMPLETE, "GAS_COMPLETE" },
+	{ WLC_E_P2PO_ADD_DEVICE, "P2PO_DEV_FOUND" },
+	{ WLC_E_P2PO_DEL_DEVICE, "P2PO_DEV_LOST" },
+#ifdef WLWNM
+	{ WLC_E_WNM_STA_SLEEP, "WMM_STA_SLEEP" },
+#endif /* WLWNM */
+#if defined(WL_PROXDETECT)
+	{ WLC_E_PROXD, "WLC_E_PROXD" },
+#endif
+	{ WLC_E_CCA_CHAN_QUAL, "CCA_BASED_CHANNEL_QUALITY" },
 };
 
 const int bcmevent_names_size = ARRAYSIZE(bcmevent_names);
diff --git a/drivers/net/wireless/bcmdhd/bcmsdh.c b/drivers/net/wireless/bcmdhd/bcmsdh.c
old mode 100644
new mode 100755
index 6e1a6b0..d940e02
--- a/drivers/net/wireless/bcmdhd/bcmsdh.c
+++ b/drivers/net/wireless/bcmdhd/bcmsdh.c
@@ -2,27 +2,9 @@
  *  BCMSDH interface glue
  *  implement bcmsdh API for SDIOH driver
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $ Copyright Open Broadcom Corporation $
  *
- * $Id: bcmsdh.c 300445 2011-12-03 05:37:20Z $
+ * $Id: bcmsdh.c 373331 2012-12-07 04:46:22Z $
  */
 
 /**
@@ -362,9 +344,10 @@ bcmsdh_cis_read(void *sdh, uint func, uint8 *cis, uint length)
 		}
 		bcopy(cis, tmp_buf, length);
 		for (tmp_ptr = tmp_buf, ptr = cis; ptr < (cis + length - 4); tmp_ptr++) {
-			ptr += sprintf((char*)ptr, "%.2x ", *tmp_ptr & 0xff);
+			ptr += snprintf((char*)ptr, (cis + length - ptr - 4),
+				"%.2x ", *tmp_ptr & 0xff);
 			if ((((tmp_ptr - tmp_buf) + 1) & 0xf) == 0)
-				ptr += sprintf((char *)ptr, "\n");
+				ptr += snprintf((char *)ptr, (cis + length - ptr -4), "\n");
 		}
 		MFREE(bcmsdh->osh, tmp_buf, length);
 	}
@@ -724,3 +707,32 @@ bcmsdh_gpioout(void *sdh, uint32 gpio, bool enab)
 
 	return sdioh_gpioout(sd, gpio, enab);
 }
+
+#ifdef BCMSDIOH_TXGLOM
+void
+bcmsdh_glom_post(void *sdh, uint8 *frame, void *pkt, uint len)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *)sdh;
+	sdioh_glom_post(bcmsdh->sdioh, frame, pkt, len);
+}
+
+void
+bcmsdh_glom_clear(void *sdh)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *)sdh;
+	sdioh_glom_clear(bcmsdh->sdioh);
+}
+
+uint
+bcmsdh_set_mode(void *sdh, uint mode)
+{
+	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *)sdh;
+	return (sdioh_set_mode(bcmsdh->sdioh, mode));
+}
+
+bool
+bcmsdh_glom_enabled(void)
+{
+	return (sdioh_glom_enabled());
+}
+#endif /* BCMSDIOH_TXGLOM */
diff --git a/drivers/net/wireless/bcmdhd/bcmsdh_linux.c b/drivers/net/wireless/bcmdhd/bcmsdh_linux.c
old mode 100644
new mode 100755
index 79760eb..5e4b43a
--- a/drivers/net/wireless/bcmdhd/bcmsdh_linux.c
+++ b/drivers/net/wireless/bcmdhd/bcmsdh_linux.c
@@ -1,27 +1,9 @@
 /*
  * SDIO access interface for drivers - linux specific (pci only)
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: bcmsdh_linux.c 312788 2012-02-03 23:06:32Z $
+ * $Id: bcmsdh_linux.c 384887 2013-02-13 13:23:52Z $
  */
 
 /**
@@ -47,7 +29,7 @@ extern void dhdsdio_isr(void * args);
 #include <bcmutils.h>
 #include <dngl_stats.h>
 #include <dhd.h>
-#endif /* defined(OOB_INTR_ONLY) */
+#endif 
 
 /**
  * SDIO Host Controller info
@@ -71,10 +53,12 @@ struct bcmsdh_hc {
 	bool oob_irq_enable_flag;
 #if defined(OOB_INTR_ONLY)
 	spinlock_t irq_lock;
-#endif
+#endif 
 };
 static bcmsdh_hc_t *sdhcinfo = NULL;
 
+struct device *pm_dev;
+
 /* driver info, initialized when bcmsdh_register is called */
 static bcmsdh_driver_t drvinfo = {NULL, NULL};
 
@@ -144,21 +128,21 @@ EXPORT_SYMBOL(bcmsdh_remove);
 /* forward declarations */
 static int __devinit bcmsdh_probe(struct device *dev);
 static int __devexit bcmsdh_remove(struct device *dev);
-#endif /* BCMLXSDMMC */
+#endif 
 
-#ifndef BCMLXSDMMC
+#if !defined(BCMLXSDMMC)
 static
-#endif /* BCMLXSDMMC */
+#endif 
 int bcmsdh_probe(struct device *dev)
 {
 	osl_t *osh = NULL;
-	bcmsdh_hc_t *sdhc = NULL;
+	bcmsdh_hc_t *sdhc = NULL, *sdhc_org = sdhcinfo;
 	ulong regs = 0;
 	bcmsdh_info_t *sdh = NULL;
 #if !defined(BCMLXSDMMC) && defined(BCMPLATFORM_BUS)
 	struct platform_device *pdev;
 	struct resource *r;
-#endif /* BCMLXSDMMC */
+#endif 
 	int irq = 0;
 	uint32 vendevid;
 	unsigned long irq_flags = 0;
@@ -167,9 +151,9 @@ int bcmsdh_probe(struct device *dev)
 	pdev = to_platform_device(dev);
 	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	irq = platform_get_irq(pdev, 0);
-	if (!r || irq == NO_IRQ)
+	if (!r || irq < 0)
 		return -ENXIO;
-#endif /* BCMLXSDMMC */
+#endif 
 
 #if defined(OOB_INTR_ONLY)
 #ifdef HW_OOB
@@ -183,9 +167,9 @@ int bcmsdh_probe(struct device *dev)
 	irq = dhd_customer_oob_irq_map(&irq_flags);
 	if  (irq < 0) {
 		SDLX_MSG(("%s: Host irq is not defined\n", __FUNCTION__));
-		return 1;
+		goto err;
 	}
-#endif /* defined(OOB_INTR_ONLY) */
+#endif 
 	/* allocate SDIO Host Controller state info */
 	if (!(osh = osl_attach(dev, PCI_BUS, FALSE))) {
 		SDLX_MSG(("%s: osl_attach failed\n", __FUNCTION__));
@@ -202,7 +186,7 @@ int bcmsdh_probe(struct device *dev)
 
 	sdhc->dev = (void *)dev;
 
-#ifdef BCMLXSDMMC
+#if defined(BCMLXSDMMC)
 	if (!(sdh = bcmsdh_attach(osh, (void *)0,
 	                          (void **)&regs, irq))) {
 		SDLX_MSG(("%s: bcmsdh_attach failed\n", __FUNCTION__));
@@ -214,7 +198,7 @@ int bcmsdh_probe(struct device *dev)
 		SDLX_MSG(("%s: bcmsdh_attach failed\n", __FUNCTION__));
 		goto err;
 	}
-#endif /* BCMLXSDMMC */
+#endif 
 	sdhc->sdh = sdh;
 	sdhc->oob_irq = irq;
 	sdhc->oob_flags = irq_flags;
@@ -222,12 +206,17 @@ int bcmsdh_probe(struct device *dev)
 	sdhc->oob_irq_enable_flag = FALSE;
 #if defined(OOB_INTR_ONLY)
 	spin_lock_init(&sdhc->irq_lock);
-#endif
+#endif 
 
 	/* chain SDIO Host Controller info together */
 	sdhc->next = sdhcinfo;
 	sdhcinfo = sdhc;
 
+#if !defined(CONFIG_HAS_WAKELOCK) && (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 36))
+	if (!device_init_wakeup(dev, 1))
+		pm_dev = dev;
+#endif /* !CONFIG_HAS_WAKELOCK */
+
 	/* Read the vendor/device ID from the CIS */
 	vendevid = bcmsdh_query_device(sdh);
 	/* try to attach to the target device */
@@ -246,31 +235,34 @@ err:
 		if (sdhc->sdh)
 			bcmsdh_detach(sdhc->osh, sdhc->sdh);
 		MFREE(osh, sdhc, sizeof(bcmsdh_hc_t));
+		sdhcinfo = sdhc_org;
 	}
 	if (osh)
 		osl_detach(osh);
 	return -ENODEV;
 }
 
-#ifndef BCMLXSDMMC
+#if !defined(BCMLXSDMMC)
 static
-#endif /* BCMLXSDMMC */
+#endif 
 int bcmsdh_remove(struct device *dev)
 {
 	bcmsdh_hc_t *sdhc, *prev;
 	osl_t *osh;
-
-	sdhc = sdhcinfo;
-	drvinfo.detach(sdhc->ch);
-	bcmsdh_detach(sdhc->osh, sdhc->sdh);
+	int sdhcinfo_null = false;
 
 	/* find the SDIO Host Controller state for this pdev and take it out from the list */
 	for (sdhc = sdhcinfo, prev = NULL; sdhc; sdhc = sdhc->next) {
 		if (sdhc->dev == (void *)dev) {
 			if (prev)
 				prev->next = sdhc->next;
-			else
-				sdhcinfo = NULL;
+			else {
+				if (sdhc->next != NULL) {
+					SDLX_MSG(("%s: more SDHC exist, should be care about it\n",
+						__FUNCTION__));
+				}
+				sdhcinfo_null = true;
+			}
 			break;
 		}
 		prev = sdhc;
@@ -280,6 +272,20 @@ int bcmsdh_remove(struct device *dev)
 		return 0;
 	}
 
+	/* detach ch & sdhc if dev is valid */
+	drvinfo.detach(sdhc->ch);
+	bcmsdh_detach(sdhc->osh, sdhc->sdh);
+
+#if !defined(CONFIG_HAS_WAKELOCK) && (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 36))
+	if (pm_dev) {
+		device_init_wakeup(pm_dev, 0);
+		pm_dev = NULL;
+	}
+#endif /* !CONFIG_HAS_WAKELOCK */
+
+	if (sdhcinfo_null == true)
+		sdhcinfo = NULL;
+
 	/* release SDIO Host Controller info */
 	osh = sdhc->osh;
 	MFREE(osh, sdhc, sizeof(bcmsdh_hc_t));
@@ -287,7 +293,7 @@ int bcmsdh_remove(struct device *dev)
 
 #if !defined(BCMLXSDMMC) || defined(OOB_INTR_ONLY)
 	dev_set_drvdata(dev, NULL);
-#endif /* !defined(BCMLXSDMMC) || defined(OOB_INTR_ONLY) */
+#endif 
 
 	return 0;
 }
@@ -404,6 +410,10 @@ bcmsdh_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	/* match this pci device with what we support */
 	/* we can't solely rely on this to believe it is our SDIO Host Controller! */
 	if (!bcmsdh_chipmatch(pdev->vendor, pdev->device)) {
+		if (pdev->vendor == VENDOR_BROADCOM) {
+			SDLX_MSG(("%s: Unknown Broadcom device (vendor: %#x, device: %#x).\n",
+				__FUNCTION__, pdev->vendor, pdev->device));
+		}
 		return -ENODEV;
 	}
 
@@ -627,7 +637,9 @@ int bcmsdh_register_oob_intr(void * dhdp)
 		if (error)
 			return -ENODEV;
 
-		enable_irq_wake(sdhcinfo->oob_irq);
+			error = enable_irq_wake(sdhcinfo->oob_irq);
+		if (error)
+			SDLX_MSG(("%s enable_irq_wake error=%d \n", __FUNCTION__, error));
 		sdhcinfo->oob_irq_registered = TRUE;
 		sdhcinfo->oob_irq_enable_flag = TRUE;
 	}
@@ -642,9 +654,9 @@ void bcmsdh_set_irq(int flag)
 		sdhcinfo->oob_irq_enable_flag = flag;
 		if (flag) {
 			enable_irq(sdhcinfo->oob_irq);
-			enable_irq_wake(sdhcinfo->oob_irq);
+				enable_irq_wake(sdhcinfo->oob_irq);
 		} else {
-			disable_irq_wake(sdhcinfo->oob_irq);
+				disable_irq_wake(sdhcinfo->oob_irq);
 			disable_irq(sdhcinfo->oob_irq);
 		}
 	}
@@ -660,7 +672,7 @@ void bcmsdh_unregister_oob_intr(void)
 		sdhcinfo->oob_irq_registered = FALSE;
 	}
 }
-#endif /* defined(OOB_INTR_ONLY) */
+#endif 
 
 #if defined(BCMLXSDMMC)
 void *bcmsdh_get_drvdata(void)
@@ -697,6 +709,15 @@ module_param(sd_f2_blocksize, int, 0);
 #ifdef BCMSDIOH_STD
 extern int sd_uhsimode;
 module_param(sd_uhsimode, int, 0);
+extern uint sd_tuning_period;
+module_param(sd_tuning_period, uint, 0);
+extern int sd_delay_value;
+module_param(sd_delay_value, uint, 0);
+#endif
+
+#ifdef BCMSDIOH_TXGLOM
+extern uint sd_txglom;
+module_param(sd_txglom, uint, 0);
 #endif
 
 #ifdef BCMSDH_MODULE
diff --git a/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c b/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c
old mode 100644
new mode 100755
index afe4019..c938f79
--- a/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c
+++ b/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c
@@ -1,7 +1,7 @@
 /*
  * BCMSDH Function Driver for the native SDIO/MMC driver in the Linux Kernel
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
+ * Copyright (C) 1999-2013, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmsdh_sdmmc.c 321372 2012-03-15 01:10:32Z $
+ * $Id: bcmsdh_sdmmc.c 386902 2013-02-22 09:10:37Z $
  */
 #include <typedefs.h>
 
@@ -62,9 +62,13 @@ extern int sdio_reset_comm(struct mmc_card *card);
 
 extern PBCMSDH_SDMMC_INSTANCE gInstance;
 
-uint sd_sdmode = SDIOH_MODE_SD4;	/* Use SD4 mode by default */
-uint sd_f2_blocksize = 512;		/* Default blocksize */
+#define DEFAULT_SDIO_F2_BLKSIZE		512
+#ifndef CUSTOM_SDIO_F2_BLKSIZE
+#define CUSTOM_SDIO_F2_BLKSIZE		DEFAULT_SDIO_F2_BLKSIZE
+#endif
 
+uint sd_sdmode = SDIOH_MODE_SD4;	/* Use SD4 mode by default */
+uint sd_f2_blocksize = CUSTOM_SDIO_F2_BLKSIZE;
 uint sd_divisor = 2;			/* Default 48MHz/2 = 24MHz */
 
 uint sd_power = 1;		/* Default to SD Slot powered ON */
@@ -72,12 +76,25 @@ uint sd_clock = 1;		/* Default to SD Clock turned ON */
 uint sd_hiok = FALSE;	/* Don't use hi-speed mode by default */
 uint sd_msglevel = 0x01;
 uint sd_use_dma = TRUE;
+
+#ifdef BCMSDIOH_TXGLOM
+#ifndef CUSTOM_TXGLOM
+#define CUSTOM_TXGLOM 0
+#endif
+uint sd_txglom = CUSTOM_TXGLOM;
+#endif /* BCMSDIOH_TXGLOM */
+
+#ifndef CUSTOM_RXCHAIN
+#define CUSTOM_RXCHAIN 0
+#endif
+
 DHD_PM_RESUME_WAIT_INIT(sdioh_request_byte_wait);
 DHD_PM_RESUME_WAIT_INIT(sdioh_request_word_wait);
 DHD_PM_RESUME_WAIT_INIT(sdioh_request_packet_wait);
 DHD_PM_RESUME_WAIT_INIT(sdioh_request_buffer_wait);
 
 #define DMA_ALIGN_MASK	0x03
+#define MMC_SDIO_ABORT_RETRY_LIMIT 5
 
 int sdioh_sdmmc_card_regread(sdioh_info_t *sd, int func, uint32 regaddr, int regsize, uint32 *data);
 
@@ -149,21 +166,27 @@ sdioh_attach(osl_t *osh, void *bar0, uint irq)
 	sd->sd_blockmode = TRUE;
 	sd->use_client_ints = TRUE;
 	sd->client_block_size[0] = 64;
-	sd->use_rxchain = FALSE;
+	sd->use_rxchain = CUSTOM_RXCHAIN;
 
 	gInstance->sd = sd;
 
 	/* Claim host controller */
-	sdio_claim_host(gInstance->func[1]);
+	if (gInstance->func[1]) {
+		sdio_claim_host(gInstance->func[1]);
 
-	sd->client_block_size[1] = 64;
-	err_ret = sdio_set_block_size(gInstance->func[1], 64);
-	if (err_ret) {
-		sd_err(("bcmsdh_sdmmc: Failed to set F1 blocksize\n"));
-	}
+		sd->client_block_size[1] = 64;
+		err_ret = sdio_set_block_size(gInstance->func[1], 64);
+		if (err_ret) {
+			sd_err(("bcmsdh_sdmmc: Failed to set F1 blocksize\n"));
+		}
 
-	/* Release host controller F1 */
-	sdio_release_host(gInstance->func[1]);
+		/* Release host controller F1 */
+		sdio_release_host(gInstance->func[1]);
+	} else {
+		sd_err(("%s:gInstance->func[1] is null\n", __FUNCTION__));
+		MFREE(sd->osh, sd, sizeof(sdioh_info_t));
+		return NULL;
+	}
 
 	if (gInstance->func[2]) {
 		/* Claim host controller F2 */
@@ -178,6 +201,10 @@ sdioh_attach(osl_t *osh, void *bar0, uint irq)
 
 		/* Release host controller F2 */
 		sdio_release_host(gInstance->func[2]);
+	} else {
+		sd_err(("%s:gInstance->func[2] is null\n", __FUNCTION__));
+		MFREE(sd->osh, sd, sizeof(sdioh_info_t));
+		return NULL;
 	}
 
 	sdioh_sdmmc_card_enablefuncs(sd);
@@ -235,9 +262,9 @@ sdioh_enable_func_intr(void)
 			return SDIOH_API_RC_FAIL;
 		}
 
-		/* Enable F1 and F2 interrupts, set master enable */
-		reg |= (INTR_CTL_FUNC1_EN | INTR_CTL_FUNC2_EN | INTR_CTL_MASTER_EN);
-
+		/* Enable F1 and F2 interrupts, clear master enable */
+		reg &= ~INTR_CTL_MASTER_EN;
+		reg |= (INTR_CTL_FUNC1_EN | INTR_CTL_FUNC2_EN);
 		sdio_writeb(gInstance->func[0], reg, SDIOD_CCCR_INTEN, &err);
 		sdio_release_host(gInstance->func[0]);
 
@@ -764,7 +791,10 @@ sdioh_cis_read(sdioh_info_t *sd, uint func, uint8 *cisd, uint32 length)
 extern SDIOH_API_RC
 sdioh_request_byte(sdioh_info_t *sd, uint rw, uint func, uint regaddr, uint8 *byte)
 {
-	int err_ret;
+	int err_ret = 0;
+#if defined(MMC_SDIO_ABORT)
+	int sdio_abort_retry = MMC_SDIO_ABORT_RETRY_LIMIT;
+#endif
 
 	sd_info(("%s: rw=%d, func=%d, addr=0x%05x\n", __FUNCTION__, rw, func, regaddr));
 
@@ -799,46 +829,61 @@ sdioh_request_byte(sdioh_info_t *sd, uint rw, uint func, uint regaddr, uint8 *by
 #if defined(MMC_SDIO_ABORT)
 			/* to allow abort command through F1 */
 			else if (regaddr == SDIOD_CCCR_IOABORT) {
-				sdio_claim_host(gInstance->func[func]);
-				/*
-				* this sdio_f0_writeb() can be replaced with another api
-				* depending upon MMC driver change.
-				* As of this time, this is temporaray one
-				*/
-				sdio_writeb(gInstance->func[func], *byte, regaddr, &err_ret);
-				sdio_release_host(gInstance->func[func]);
+				while (sdio_abort_retry--) {
+					if (gInstance->func[func]) {
+						sdio_claim_host(gInstance->func[func]);
+						/*
+						 * this sdio_f0_writeb() can be replaced with
+						 * another api depending upon MMC driver change.
+						 * As of this time, this is temporaray one
+						 */
+						sdio_writeb(gInstance->func[func],
+							*byte, regaddr, &err_ret);
+						sdio_release_host(gInstance->func[func]);
+					}
+					if (!err_ret)
+						break;
+				}
 			}
 #endif /* MMC_SDIO_ABORT */
 			else if (regaddr < 0xF0) {
 				sd_err(("bcmsdh_sdmmc: F0 Wr:0x%02x: write disallowed\n", regaddr));
 			} else {
 				/* Claim host controller, perform F0 write, and release */
-				sdio_claim_host(gInstance->func[func]);
-				sdio_f0_writeb(gInstance->func[func], *byte, regaddr, &err_ret);
-				sdio_release_host(gInstance->func[func]);
+				if (gInstance->func[func]) {
+					sdio_claim_host(gInstance->func[func]);
+					sdio_f0_writeb(gInstance->func[func],
+						*byte, regaddr, &err_ret);
+					sdio_release_host(gInstance->func[func]);
+				}
 			}
 		} else {
 			/* Claim host controller, perform Fn write, and release */
-			sdio_claim_host(gInstance->func[func]);
-			sdio_writeb(gInstance->func[func], *byte, regaddr, &err_ret);
-			sdio_release_host(gInstance->func[func]);
+			if (gInstance->func[func]) {
+				sdio_claim_host(gInstance->func[func]);
+				sdio_writeb(gInstance->func[func], *byte, regaddr, &err_ret);
+				sdio_release_host(gInstance->func[func]);
+			}
 		}
 	} else { /* CMD52 Read */
 		/* Claim host controller, perform Fn read, and release */
-		sdio_claim_host(gInstance->func[func]);
-
-		if (func == 0) {
-			*byte = sdio_f0_readb(gInstance->func[func], regaddr, &err_ret);
-		} else {
-			*byte = sdio_readb(gInstance->func[func], regaddr, &err_ret);
+		if (gInstance->func[func]) {
+			sdio_claim_host(gInstance->func[func]);
+			if (func == 0) {
+				*byte = sdio_f0_readb(gInstance->func[func], regaddr, &err_ret);
+			} else {
+				*byte = sdio_readb(gInstance->func[func], regaddr, &err_ret);
+			}
+			sdio_release_host(gInstance->func[func]);
 		}
-
-		sdio_release_host(gInstance->func[func]);
 	}
 
 	if (err_ret) {
-		sd_err(("bcmsdh_sdmmc: Failed to %s byte F%d:@0x%05x=%02x, Err: %d\n",
-		                        rw ? "Write" : "Read", func, regaddr, *byte, err_ret));
+		if ((regaddr == 0x1001F) && (err_ret == -110)) {
+		} else {
+			sd_err(("bcmsdh_sdmmc: Failed to %s byte F%d:@0x%05x=%02x, Err: %d\n",
+				rw ? "Write" : "Read", func, regaddr, *byte, err_ret));
+		}
 	}
 
 	return ((err_ret == 0) ? SDIOH_API_RC_SUCCESS : SDIOH_API_RC_FAIL);
@@ -849,6 +894,9 @@ sdioh_request_word(sdioh_info_t *sd, uint cmd_type, uint rw, uint func, uint add
                                    uint32 *word, uint nbytes)
 {
 	int err_ret = SDIOH_API_RC_FAIL;
+#if defined(MMC_SDIO_ABORT)
+	int sdio_abort_retry = MMC_SDIO_ABORT_RETRY_LIMIT;
+#endif
 
 	if (func == 0) {
 		sd_err(("%s: Only CMD52 allowed to F0.\n", __FUNCTION__));
@@ -885,13 +933,101 @@ sdioh_request_word(sdioh_info_t *sd, uint cmd_type, uint rw, uint func, uint add
 	sdio_release_host(gInstance->func[func]);
 
 	if (err_ret) {
-		sd_err(("bcmsdh_sdmmc: Failed to %s word, Err: 0x%08x",
-		                        rw ? "Write" : "Read", err_ret));
+#if defined(MMC_SDIO_ABORT)
+		/* Any error on CMD53 transaction should abort that function using function 0. */
+		while (sdio_abort_retry--) {
+			if (gInstance->func[0]) {
+				sdio_claim_host(gInstance->func[0]);
+				/*
+				 * this sdio_f0_writeb() can be replaced with another api
+				 * depending upon MMC driver change.
+				 * As of this time, this is temporaray one
+				 */
+				sdio_writeb(gInstance->func[0],
+					func, SDIOD_CCCR_IOABORT, &err_ret);
+				sdio_release_host(gInstance->func[0]);
+			}
+			if (!err_ret)
+				break;
+		}
+		if (err_ret)
+#endif /* MMC_SDIO_ABORT */
+		{
+			sd_err(("bcmsdh_sdmmc: Failed to %s word, Err: 0x%08x",
+				rw ? "Write" : "Read", err_ret));
+		}
 	}
 
 	return ((err_ret == 0) ? SDIOH_API_RC_SUCCESS : SDIOH_API_RC_FAIL);
 }
 
+#ifdef BCMSDIOH_TXGLOM
+void
+sdioh_glom_post(sdioh_info_t *sd, uint8 *frame, void *pkt, uint len)
+{
+	void *phead = sd->glom_info.glom_pkt_head;
+	void *ptail = sd->glom_info.glom_pkt_tail;
+
+	BCM_REFERENCE(frame);
+
+	ASSERT(!PKTLINK(pkt));
+	if (!phead) {
+		ASSERT(!phead);
+		sd->glom_info.glom_pkt_head = sd->glom_info.glom_pkt_tail = pkt;
+	}
+	else {
+		ASSERT(ptail);
+		PKTSETNEXT(sd->osh, ptail, pkt);
+		sd->glom_info.glom_pkt_tail = pkt;
+	}
+	sd->glom_info.count++;
+}
+
+void
+sdioh_glom_clear(sdioh_info_t *sd)
+{
+	void *pnow, *pnext;
+
+	pnext = sd->glom_info.glom_pkt_head;
+
+	if (!pnext) {
+		sd_err(("sdioh_glom_clear: no first packet to clear!\n"));
+		return;
+	}
+
+	while (pnext) {
+		pnow = pnext;
+		pnext = PKTNEXT(sd->osh, pnow);
+		PKTSETNEXT(sd->osh, pnow, NULL);
+		sd->glom_info.count--;
+	}
+
+	sd->glom_info.glom_pkt_head = NULL;
+	sd->glom_info.glom_pkt_tail = NULL;
+	if (sd->glom_info.count != 0) {
+		sd_err(("sdioh_glom_clear: glom count mismatch!\n"));
+		sd->glom_info.count = 0;
+	}
+}
+
+uint
+sdioh_set_mode(sdioh_info_t *sd, uint mode)
+{
+	if (mode == SDPCM_TXGLOM_CPY)
+		sd->txglom_mode = mode;
+	else if (mode == SDPCM_TXGLOM_MDESC)
+		sd->txglom_mode = mode;
+
+	return (sd->txglom_mode);
+}
+
+bool
+sdioh_glom_enabled(void)
+{
+	return sd_txglom;
+}
+#endif /* BCMSDIOH_TXGLOM */
+
 static SDIOH_API_RC
 sdioh_request_packet(sdioh_info_t *sd, uint fix_inc, uint write, uint func,
                      uint addr, void *pkt)
@@ -899,12 +1035,20 @@ sdioh_request_packet(sdioh_info_t *sd, uint fix_inc, uint write, uint func,
 	bool fifo = (fix_inc == SDIOH_DATA_FIX);
 	uint32	SGCount = 0;
 	int err_ret = 0;
-	void *pnext, *pprev;
+	void *pnext;
 	uint ttl_len, dma_len, lft_len, xfred_len, pkt_len;
 	uint blk_num;
+	int blk_size;
 	struct mmc_request mmc_req;
 	struct mmc_command mmc_cmd;
 	struct mmc_data mmc_dat;
+#ifdef BCMSDIOH_TXGLOM
+	uint8 *localbuf = NULL;
+	uint local_plen = 0;
+	bool need_txglom = write && sdioh_glom_enabled() &&
+		(pkt == sd->glom_info.glom_pkt_tail) &&
+		(sd->glom_info.glom_pkt_head != sd->glom_info.glom_pkt_tail);
+#endif /* BCMSDIOH_TXGLOM */
 
 	sd_trace(("%s: Enter\n", __FUNCTION__));
 
@@ -913,17 +1057,29 @@ sdioh_request_packet(sdioh_info_t *sd, uint fix_inc, uint write, uint func,
 	DHD_PM_RESUME_RETURN_ERROR(SDIOH_API_RC_FAIL);
 
 	ttl_len = xfred_len = 0;
+#ifdef BCMSDIOH_TXGLOM
+	if (need_txglom) {
+		pkt = sd->glom_info.glom_pkt_head;
+	}
+#endif /* BCMSDIOH_TXGLOM */
+
 	/* at least 4 bytes alignment of skb buff is guaranteed */
 	for (pnext = pkt; pnext; pnext = PKTNEXT(sd->osh, pnext))
 		ttl_len += PKTLEN(sd->osh, pnext);
 
-	if (!sd->use_rxchain || ttl_len <= sd->client_block_size[func]) {
+	blk_size = sd->client_block_size[func];
+	if (((!write && sd->use_rxchain) ||
+#ifdef BCMSDIOH_TXGLOM
+		(need_txglom && sd->txglom_mode == SDPCM_TXGLOM_MDESC) ||
+#endif
+		0) && (ttl_len > blk_size)) {
+		blk_num = ttl_len / blk_size;
+		dma_len = blk_num * blk_size;
+	} else {
 		blk_num = 0;
 		dma_len = 0;
-	} else {
-		blk_num = ttl_len / sd->client_block_size[func];
-		dma_len = blk_num * sd->client_block_size[func];
 	}
+
 	lft_len = ttl_len - dma_len;
 
 	sd_trace(("%s: %s %dB to func%d:%08x, %d blks with DMA, %dB leftover\n",
@@ -936,7 +1092,6 @@ sdioh_request_packet(sdioh_info_t *sd, uint fix_inc, uint write, uint func,
 		memset(&mmc_dat, 0, sizeof(struct mmc_data));
 
 		/* Set up DMA descriptors */
-		pprev = pkt;
 		for (pnext = pkt;
 		     pnext && dma_len;
 		     pnext = PKTNEXT(sd->osh, pnext)) {
@@ -963,7 +1118,7 @@ sdioh_request_packet(sdioh_info_t *sd, uint fix_inc, uint write, uint func,
 
 		mmc_dat.sg = sd->sg_list;
 		mmc_dat.sg_len = SGCount;
-		mmc_dat.blksz = sd->client_block_size[func];
+		mmc_dat.blksz = blk_size;
 		mmc_dat.blocks = blk_num;
 		mmc_dat.flags = write ? MMC_DATA_WRITE : MMC_DATA_READ;
 
@@ -990,12 +1145,8 @@ sdioh_request_packet(sdioh_info_t *sd, uint fix_inc, uint write, uint func,
 			       __FUNCTION__,
 			       write ? "write" : "read",
 			       err_ret));
-			sd_err(("%s:Disabling rxchain and fire it with PIO\n",
-			       __FUNCTION__));
-			sd->use_rxchain = FALSE;
-			pkt = pprev;
-			lft_len = ttl_len;
-		} else if (!fifo) {
+		}
+		if (!fifo) {
 			addr = addr + ttl_len - lft_len - dma_len;
 		}
 	}
@@ -1012,7 +1163,36 @@ sdioh_request_packet(sdioh_info_t *sd, uint fix_inc, uint write, uint func,
 				pkt_len -= xfred_len;
 				xfred_len = 0;
 			}
-			pkt_len = (pkt_len + 3) & 0xFFFFFFFC;
+#ifdef BCMSDIOH_TXGLOM
+			if (need_txglom) {
+				if (!localbuf) {
+					localbuf = (uint8 *)MALLOC(sd->osh, lft_len);
+					if (localbuf == NULL) {
+						sd_err(("%s: %s TXGLOM: localbuf malloc FAILED\n",
+							__FUNCTION__, (write) ? "TX" : "RX"));
+						goto txglomfail;
+					}
+				}
+				bcopy(buf, (localbuf + local_plen), pkt_len);
+				local_plen += pkt_len;
+
+				if (PKTNEXT(sd->osh, pnext)) {
+					continue;
+				}
+
+				buf = localbuf;
+				pkt_len = local_plen;
+			}
+
+txglomfail:
+#endif /* BCMSDIOH_TXGLOM */
+
+			/* Align Patch */
+			if (!write || pkt_len < 32)
+				pkt_len = (pkt_len + 3) & 0xFFFFFFFC;
+			else if (pkt_len % blk_size)
+				pkt_len += blk_size - (pkt_len % blk_size);
+
 #ifdef CONFIG_MMC_MSM7X00A
 			if ((pkt_len % 64) == 32) {
 				sd_trace(("%s: Rounding up TX packet +=32\n", __FUNCTION__));
@@ -1054,6 +1234,10 @@ sdioh_request_packet(sdioh_info_t *sd, uint fix_inc, uint write, uint func,
 		}
 		sdio_release_host(gInstance->func[func]);
 	}
+#ifdef BCMSDIOH_TXGLOM
+	if (localbuf)
+		MFREE(sd->osh, localbuf, lft_len);
+#endif /* BCMSDIOH_TXGLOM */
 
 	sd_trace(("%s: Exit\n", __FUNCTION__));
 	return ((err_ret == 0) ? SDIOH_API_RC_SUCCESS : SDIOH_API_RC_FAIL);
@@ -1073,87 +1257,51 @@ sdioh_request_packet(sdioh_info_t *sd, uint fix_inc, uint write, uint func,
  */
 extern SDIOH_API_RC
 sdioh_request_buffer(sdioh_info_t *sd, uint pio_dma, uint fix_inc, uint write, uint func,
-                     uint addr, uint reg_width, uint buflen_u, uint8 *buffer, void *pkt)
+	uint addr, uint reg_width, uint buflen_u, uint8 *buffer, void *pkt)
 {
 	SDIOH_API_RC Status;
-	void *mypkt = NULL;
+	void *tmppkt;
+	void *orig_buf = NULL;
+	uint copylen = 0;
 
 	sd_trace(("%s: Enter\n", __FUNCTION__));
 
 	DHD_PM_RESUME_WAIT(sdioh_request_buffer_wait);
 	DHD_PM_RESUME_RETURN_ERROR(SDIOH_API_RC_FAIL);
-	/* Case 1: we don't have a packet. */
-	if (pkt == NULL) {
-		sd_data(("%s: Creating new %s Packet, len=%d\n",
-		         __FUNCTION__, write ? "TX" : "RX", buflen_u));
-#ifdef CONFIG_DHD_USE_STATIC_BUF
-		if (!(mypkt = PKTGET_STATIC(sd->osh, buflen_u, write ? TRUE : FALSE))) {
-#else
-		if (!(mypkt = PKTGET(sd->osh, buflen_u, write ? TRUE : FALSE))) {
-#endif /* CONFIG_DHD_USE_STATIC_BUF */
-			sd_err(("%s: PKTGET failed: len %d\n",
-			           __FUNCTION__, buflen_u));
-			return SDIOH_API_RC_FAIL;
-		}
-
-		/* For a write, copy the buffer data into the packet. */
-		if (write) {
-			bcopy(buffer, PKTDATA(sd->osh, mypkt), buflen_u);
-		}
-
-		Status = sdioh_request_packet(sd, fix_inc, write, func, addr, mypkt);
 
-		/* For a read, copy the packet data back to the buffer. */
-		if (!write) {
-			bcopy(PKTDATA(sd->osh, mypkt), buffer, buflen_u);
-		}
-#ifdef CONFIG_DHD_USE_STATIC_BUF
-		PKTFREE_STATIC(sd->osh, mypkt, write ? TRUE : FALSE);
-#else
-		PKTFREE(sd->osh, mypkt, write ? TRUE : FALSE);
-#endif /* CONFIG_DHD_USE_STATIC_BUF */
-	} else if (((uint32)(PKTDATA(sd->osh, pkt)) & DMA_ALIGN_MASK) != 0) {
-		/* Case 2: We have a packet, but it is unaligned. */
-
-		/* In this case, we cannot have a chain. */
+	if (pkt == NULL) {
+		/* Case 1: we don't have a packet. */
+		orig_buf = buffer;
+		copylen = buflen_u;
+	} else if ((ulong)PKTDATA(sd->osh, pkt) & DMA_ALIGN_MASK) {
+		/* Case 2: We have a packet, but it is unaligned.
+		 * in this case, we cannot have a chain.
+		 */
 		ASSERT(PKTNEXT(sd->osh, pkt) == NULL);
 
-		sd_data(("%s: Creating aligned %s Packet, len=%d\n",
-		         __FUNCTION__, write ? "TX" : "RX", PKTLEN(sd->osh, pkt)));
-#ifdef CONFIG_DHD_USE_STATIC_BUF
-		if (!(mypkt = PKTGET_STATIC(sd->osh, PKTLEN(sd->osh, pkt), write ? TRUE : FALSE))) {
-#else
-		if (!(mypkt = PKTGET(sd->osh, PKTLEN(sd->osh, pkt), write ? TRUE : FALSE))) {
-#endif /* CONFIG_DHD_USE_STATIC_BUF */
-			sd_err(("%s: PKTGET failed: len %d\n",
-			           __FUNCTION__, PKTLEN(sd->osh, pkt)));
+		orig_buf =	PKTDATA(sd->osh, pkt);
+		copylen = PKTLEN(sd->osh, pkt);
+	}
+
+	tmppkt = pkt;
+	if (copylen) {
+		tmppkt = PKTGET_STATIC(sd->osh, copylen, write ? TRUE : FALSE);
+		if (tmppkt == NULL) {
+			sd_err(("%s: PKTGET failed: len %d\n", __FUNCTION__, copylen));
 			return SDIOH_API_RC_FAIL;
 		}
-
 		/* For a write, copy the buffer data into the packet. */
-		if (write) {
-			bcopy(PKTDATA(sd->osh, pkt),
-			      PKTDATA(sd->osh, mypkt),
-			      PKTLEN(sd->osh, pkt));
-		}
+		if (write)
+			bcopy(orig_buf, PKTDATA(sd->osh, tmppkt), copylen);
+	}
 
-		Status = sdioh_request_packet(sd, fix_inc, write, func, addr, mypkt);
+	Status = sdioh_request_packet(sd, fix_inc, write, func, addr, tmppkt);
 
+	if (copylen) {
 		/* For a read, copy the packet data back to the buffer. */
-		if (!write) {
-			bcopy(PKTDATA(sd->osh, mypkt),
-			      PKTDATA(sd->osh, pkt),
-			      PKTLEN(sd->osh, mypkt));
-		}
-#ifdef CONFIG_DHD_USE_STATIC_BUF
-		PKTFREE_STATIC(sd->osh, mypkt, write ? TRUE : FALSE);
-#else
-		PKTFREE(sd->osh, mypkt, write ? TRUE : FALSE);
-#endif /* CONFIG_DHD_USE_STATIC_BUF */
-	} else { /* case 3: We have a packet and it is aligned. */
-		sd_data(("%s: Aligned %s Packet, direct DMA\n",
-		         __FUNCTION__, write ? "Tx" : "Rx"));
-		Status = sdioh_request_packet(sd, fix_inc, write, func, addr, pkt);
+		if (!write)
+			bcopy(PKTDATA(sd->osh, tmppkt), orig_buf, PKTLEN(sd->osh, tmppkt));
+		PKTFREE_STATIC(sd->osh, tmppkt, write ? TRUE : FALSE);
 	}
 
 	return (Status);
@@ -1300,6 +1448,11 @@ sdioh_start(sdioh_info_t *si, int stage)
 	int ret;
 	sdioh_info_t *sd = gInstance->sd;
 
+	if (!sd) {
+		sd_err(("%s Failed, sd is NULL\n", __FUNCTION__));
+		return (0);
+	}
+
 	/* Need to do this stages as we can't enable the interrupt till
 		downloading of the firmware is complete, other wise polling
 		sdio access will come in way
@@ -1325,16 +1478,18 @@ sdioh_start(sdioh_info_t *si, int stage)
 			sd->use_client_ints = TRUE;
 			sd->client_block_size[0] = 64;
 
-			/* Claim host controller */
-			sdio_claim_host(gInstance->func[1]);
+			if (gInstance->func[1]) {
+				/* Claim host controller */
+				sdio_claim_host(gInstance->func[1]);
 
-			sd->client_block_size[1] = 64;
-			if (sdio_set_block_size(gInstance->func[1], 64)) {
-				sd_err(("bcmsdh_sdmmc: Failed to set F1 blocksize\n"));
-			}
+				sd->client_block_size[1] = 64;
+				if (sdio_set_block_size(gInstance->func[1], 64)) {
+					sd_err(("bcmsdh_sdmmc: Failed to set F1 blocksize\n"));
+				}
 
-			/* Release host controller F1 */
-			sdio_release_host(gInstance->func[1]);
+				/* Release host controller F1 */
+				sdio_release_host(gInstance->func[1]);
+			}
 
 			if (gInstance->func[2]) {
 				/* Claim host controller F2 */
@@ -1356,8 +1511,10 @@ sdioh_start(sdioh_info_t *si, int stage)
 		} else {
 #if !defined(OOB_INTR_ONLY)
 			sdio_claim_host(gInstance->func[0]);
-			sdio_claim_irq(gInstance->func[2], IRQHandlerF2);
-			sdio_claim_irq(gInstance->func[1], IRQHandler);
+			if (gInstance->func[2])
+				sdio_claim_irq(gInstance->func[2], IRQHandlerF2);
+			if (gInstance->func[1])
+				sdio_claim_irq(gInstance->func[1], IRQHandler);
 			sdio_release_host(gInstance->func[0]);
 #else /* defined(OOB_INTR_ONLY) */
 #if defined(HW_OOB)
@@ -1385,8 +1542,10 @@ sdioh_stop(sdioh_info_t *si)
 	if (gInstance->func[0]) {
 #if !defined(OOB_INTR_ONLY)
 		sdio_claim_host(gInstance->func[0]);
-		sdio_release_irq(gInstance->func[1]);
-		sdio_release_irq(gInstance->func[2]);
+		if (gInstance->func[1])
+			sdio_release_irq(gInstance->func[1]);
+		if (gInstance->func[2])
+			sdio_release_irq(gInstance->func[2]);
 		sdio_release_host(gInstance->func[0]);
 #else /* defined(OOB_INTR_ONLY) */
 #if defined(HW_OOB)
diff --git a/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc_linux.c b/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc_linux.c
old mode 100644
new mode 100755
index 9d2b1d3..6ec1dad
--- a/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc_linux.c
+++ b/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc_linux.c
@@ -1,7 +1,7 @@
 /*
  * BCMSDH Function Driver for the native SDIO/MMC driver in the Linux Kernel
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
+ * Copyright (C) 1999-2013, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmsdh_sdmmc_linux.c 312783 2012-02-03 22:53:56Z $
+ * $Id: bcmsdh_sdmmc_linux.c 383841 2013-02-08 00:10:58Z $
  */
 
 #include <typedefs.h>
@@ -67,6 +67,9 @@
 #if !defined(SDIO_DEVICE_ID_BROADCOM_43239)
 #define SDIO_DEVICE_ID_BROADCOM_43239    43239
 #endif /* !defined(SDIO_DEVICE_ID_BROADCOM_43239) */
+#if !defined(SDIO_DEVICE_ID_BROADCOM_4335)
+#define SDIO_DEVICE_ID_BROADCOM_4335    4335
+#endif /* !defined(SDIO_DEVICE_ID_BROADCOM_4335) */
 
 
 #include <bcmsdh_sdmmc.h>
@@ -109,31 +112,38 @@ static int bcmsdh_sdmmc_probe(struct sdio_func *func,
 {
 	int ret = 0;
 	static struct sdio_func sdio_func_0;
-	sd_trace(("bcmsdh_sdmmc: %s Enter\n", __FUNCTION__));
-	sd_trace(("sdio_bcmsdh: func->class=%x\n", func->class));
-	sd_trace(("sdio_vendor: 0x%04x\n", func->vendor));
-	sd_trace(("sdio_device: 0x%04x\n", func->device));
-	sd_trace(("Function#: 0x%04x\n", func->num));
-
-	if (func->num == 1) {
-		sdio_func_0.num = 0;
-		sdio_func_0.card = func->card;
-		gInstance->func[0] = &sdio_func_0;
-		if(func->device == 0x4) { /* 4318 */
-			gInstance->func[2] = NULL;
-			sd_trace(("NIC found, calling bcmsdh_probe...\n"));
-			ret = bcmsdh_probe(&func->dev);
+
+	if (func) {
+		sd_trace(("bcmsdh_sdmmc: %s Enter\n", __FUNCTION__));
+		sd_trace(("sdio_bcmsdh: func->class=%x\n", func->class));
+		sd_trace(("sdio_vendor: 0x%04x\n", func->vendor));
+		sd_trace(("sdio_device: 0x%04x\n", func->device));
+		sd_trace(("Function#: 0x%04x\n", func->num));
+
+		if (func->num == 1) {
+			sdio_func_0.num = 0;
+			sdio_func_0.card = func->card;
+			gInstance->func[0] = &sdio_func_0;
+			if(func->device == 0x4) { /* 4318 */
+				gInstance->func[2] = NULL;
+				sd_trace(("NIC found, calling bcmsdh_probe...\n"));
+				ret = bcmsdh_probe(&func->dev);
+			}
 		}
-	}
 
-	gInstance->func[func->num] = func;
+		gInstance->func[func->num] = func;
 
-	if (func->num == 2) {
-#ifdef WL_CFG80211
-		wl_cfg80211_set_parent_dev(&func->dev);
-#endif
-		sd_trace(("F2 found, calling bcmsdh_probe...\n"));
-		ret = bcmsdh_probe(&func->dev);
+		if (func->num == 2) {
+	#ifdef WL_CFG80211
+			wl_cfg80211_set_parent_dev(&func->dev);
+	#endif
+			sd_trace(("F2 found, calling bcmsdh_probe...\n"));
+			ret = bcmsdh_probe(&func->dev);
+			if (ret < 0 && gInstance)
+				gInstance->func[2] = NULL;
+		}
+	} else {
+		ret = -ENODEV;
 	}
 
 	return ret;
@@ -141,20 +151,24 @@ static int bcmsdh_sdmmc_probe(struct sdio_func *func,
 
 static void bcmsdh_sdmmc_remove(struct sdio_func *func)
 {
-	sd_trace(("bcmsdh_sdmmc: %s Enter\n", __FUNCTION__));
-	sd_info(("sdio_bcmsdh: func->class=%x\n", func->class));
-	sd_info(("sdio_vendor: 0x%04x\n", func->vendor));
-	sd_info(("sdio_device: 0x%04x\n", func->device));
-	sd_info(("Function#: 0x%04x\n", func->num));
-
-	if (func->num == 2) {
-		sd_trace(("F2 found, calling bcmsdh_remove...\n"));
-		bcmsdh_remove(&func->dev);
-	} else if (func->num == 1) {
-		sdio_claim_host(func);
-		sdio_disable_func(func);
-		sdio_release_host(func);
-		gInstance->func[1] = NULL;
+	if (func) {
+		sd_trace(("bcmsdh_sdmmc: %s Enter\n", __FUNCTION__));
+		sd_info(("sdio_bcmsdh: func->class=%x\n", func->class));
+		sd_info(("sdio_vendor: 0x%04x\n", func->vendor));
+		sd_info(("sdio_device: 0x%04x\n", func->device));
+		sd_info(("Function#: 0x%04x\n", func->num));
+
+		if (gInstance->func[2]) {
+			sd_trace(("F2 found, calling bcmsdh_remove...\n"));
+			bcmsdh_remove(&func->dev);
+			gInstance->func[2] = NULL;
+		}
+		if (func->num == 1) {
+			sdio_claim_host(func);
+			sdio_disable_func(func);
+			sdio_release_host(func);
+			gInstance->func[1] = NULL;
+		}
 	}
 }
 
@@ -169,6 +183,7 @@ static const struct sdio_device_id bcmsdh_sdmmc_ids[] = {
 	{ SDIO_DEVICE(SDIO_VENDOR_ID_BROADCOM, SDIO_DEVICE_ID_BROADCOM_4334) },
 	{ SDIO_DEVICE(SDIO_VENDOR_ID_BROADCOM, SDIO_DEVICE_ID_BROADCOM_4324) },
 	{ SDIO_DEVICE(SDIO_VENDOR_ID_BROADCOM, SDIO_DEVICE_ID_BROADCOM_43239) },
+	{ SDIO_DEVICE(SDIO_VENDOR_ID_BROADCOM, SDIO_DEVICE_ID_BROADCOM_4335) },
 	{ SDIO_DEVICE_CLASS(SDIO_CLASS_NONE)		},
 	{ /* end: all zeroes */				},
 };
@@ -186,7 +201,6 @@ static int bcmsdh_sdmmc_suspend(struct device *pdev)
 		return 0;
 
 	sd_trace(("%s Enter\n", __FUNCTION__));
-
 	if (dhd_os_check_wakelock(bcmsdh_get_drvdata()))
 		return -EBUSY;
 	sdio_flags = sdio_get_host_pm_caps(func);
@@ -204,7 +218,7 @@ static int bcmsdh_sdmmc_suspend(struct device *pdev)
 	}
 #if defined(OOB_INTR_ONLY)
 	bcmsdh_oob_intr_set(0);
-#endif	/* defined(OOB_INTR_ONLY) */
+#endif 
 	dhd_mmc_suspend = TRUE;
 	smp_mb();
 
@@ -215,13 +229,13 @@ static int bcmsdh_sdmmc_resume(struct device *pdev)
 {
 #if defined(OOB_INTR_ONLY)
 	struct sdio_func *func = dev_to_sdio_func(pdev);
-#endif
+#endif 
 	sd_trace(("%s Enter\n", __FUNCTION__));
 	dhd_mmc_suspend = FALSE;
 #if defined(OOB_INTR_ONLY)
 	if ((func->num == 2) && dhd_os_check_if_up(bcmsdh_get_drvdata()))
 		bcmsdh_oob_intr_set(1);
-#endif /* (OOB_INTR_ONLY) */
+#endif 
 
 	smp_mb();
 	return 0;
@@ -291,6 +305,9 @@ sdioh_sdmmc_osinit(sdioh_info_t *sd)
 {
 	struct sdos_info *sdos;
 
+	if (!sd)
+		return BCME_BADARG;
+
 	sdos = (struct sdos_info*)MALLOC(sd->osh, sizeof(struct sdos_info));
 	sd->sdos_info = (void*)sdos;
 	if (sdos == NULL)
@@ -318,6 +335,9 @@ sdioh_interrupt_set(sdioh_info_t *sd, bool enable)
 	ulong flags;
 	struct sdos_info *sdos;
 
+	if (!sd)
+		return BCME_BADARG;
+
 	sd_trace(("%s: %s\n", __FUNCTION__, enable ? "Enabling" : "Disabling"));
 
 	sdos = (struct sdos_info *)sd->sdos_info;
@@ -351,7 +371,7 @@ static int __init
 bcmsdh_module_init(void)
 {
 	int error = 0;
-	sdio_function_init();
+	error = sdio_function_init();
 	return error;
 }
 
@@ -382,6 +402,10 @@ int sdio_function_init(void)
 		return -ENOMEM;
 
 	error = sdio_register_driver(&bcmsdh_sdmmc_driver);
+	if (error) {
+		kfree(gInstance);
+		gInstance = NULL;
+	}
 
 	return error;
 }
@@ -397,6 +421,8 @@ void sdio_function_cleanup(void)
 
 	sdio_unregister_driver(&bcmsdh_sdmmc_driver);
 
-	if (gInstance)
+	if (gInstance) {
 		kfree(gInstance);
+		gInstance = NULL;
+	}
 }
diff --git a/drivers/net/wireless/bcmdhd/bcmutils.c b/drivers/net/wireless/bcmdhd/bcmutils.c
old mode 100644
new mode 100755
index 0d92efc..698cf44
--- a/drivers/net/wireless/bcmdhd/bcmutils.c
+++ b/drivers/net/wireless/bcmdhd/bcmutils.c
@@ -1,26 +1,8 @@
 /*
  * Driver O/S-independent utility routines
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
- * $Id: bcmutils.c 312855 2012-02-04 02:01:18Z $
+ * $Copyright Open Broadcom Corporation$
+ * $Id: bcmutils.c 380908 2013-01-24 12:26:18Z $
  */
 
 #include <bcm_cfg.h>
@@ -192,7 +174,7 @@ pktsegcnt_war(osl_t *osh, void *p)
 }
 
 uint8 * BCMFASTPATH
-pktoffset(osl_t *osh, void *p,  uint offset)
+pktdataoffset(osl_t *osh, void *p,  uint offset)
 {
 	uint total = pkttotlen(osh, p);
 	uint pkt_off = 0, len = 0;
@@ -211,6 +193,25 @@ pktoffset(osl_t *osh, void *p,  uint offset)
 	return (uint8*) (pdata+pkt_off);
 }
 
+
+/* given a offset in pdata, find the pkt seg hdr */
+void *
+pktoffset(osl_t *osh, void *p,  uint offset)
+{
+	uint total = pkttotlen(osh, p);
+	uint len = 0;
+
+	if (offset > total)
+		return NULL;
+
+	for (; p; p = PKTNEXT(osh, p)) {
+		len += PKTLEN(osh, p);
+		if (len > offset)
+			break;
+	}
+	return p;
+}
+
 /*
  * osl multiple-precedence packet queue
  * hi_prec is always >= the number of the highest non-empty precedence
@@ -324,6 +325,44 @@ pktq_pdeq_prev(struct pktq *pq, int prec, void *prev_p)
 }
 
 void * BCMFASTPATH
+pktq_pdeq_with_fn(struct pktq *pq, int prec, ifpkt_cb_t fn, int arg)
+{
+	struct pktq_prec *q;
+	void *p, *prev = NULL;
+
+	ASSERT(prec >= 0 && prec < pq->num_prec);
+
+	q = &pq->q[prec];
+	p = q->head;
+
+	while (p) {
+		if (fn == NULL || (*fn)(p, arg)) {
+			break;
+		} else {
+			prev = p;
+			p = PKTLINK(p);
+		}
+	}
+	if (p == NULL)
+		return NULL;
+
+	if (prev == NULL) {
+		if ((q->head = PKTLINK(p)) == NULL)
+			q->tail = NULL;
+	} else {
+		PKTSETLINK(prev, PKTLINK(p));
+	}
+
+	q->len--;
+
+	pq->len--;
+
+	PKTSETLINK(p, NULL);
+
+	return p;
+}
+
+void * BCMFASTPATH
 pktq_pdeq_tail(struct pktq *pq, int prec)
 {
 	struct pktq_prec *q;
@@ -654,6 +693,7 @@ pktq_mdeq(struct pktq *pq, uint prec_bmp, int *prec_out)
 
 #endif /* BCMDRIVER */
 
+#if !defined(BCMROMOFFLOAD_EXCLUDE_BCMUTILS_FUNCS)
 const unsigned char bcm_ctype[] = {
 
 	_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,			/* 0-7 */
@@ -967,6 +1007,7 @@ bcm_ether_atoe(const char *p, struct ether_addr *ea)
 
 	return (i == 6);
 }
+#endif	/* !BCMROMOFFLOAD_EXCLUDE_BCMUTILS_FUNCS */
 
 
 #if defined(CONFIG_USBRNDIS_RETAIL) || defined(NDIS_MINIPORT_DRIVER)
@@ -1078,7 +1119,7 @@ pktsetprio(void *pkt, bool update_vtag)
 
 	eh = (struct ether_header *) pktdata;
 
-	if (ntoh16(eh->ether_type) == ETHER_TYPE_8021Q) {
+	if (eh->ether_type == hton16(ETHER_TYPE_8021Q)) {
 		uint16 vlan_tag;
 		int vlan_prio, dscp_prio = 0;
 
@@ -1087,7 +1128,7 @@ pktsetprio(void *pkt, bool update_vtag)
 		vlan_tag = ntoh16(evh->vlan_tag);
 		vlan_prio = (int) (vlan_tag >> VLAN_PRI_SHIFT) & VLAN_PRI_MASK;
 
-		if (ntoh16(evh->ether_type) == ETHER_TYPE_IP) {
+		if (evh->ether_type == hton16(ETHER_TYPE_IP)) {
 			uint8 *ip_body = pktdata + sizeof(struct ethervlan_header);
 			uint8 tos_tc = IP_TOS46(ip_body);
 			dscp_prio = (int)(tos_tc >> IPV4_TOS_PREC_SHIFT);
@@ -1114,7 +1155,7 @@ pktsetprio(void *pkt, bool update_vtag)
 			evh->vlan_tag = hton16(vlan_tag);
 			rc |= PKTPRIO_UPD;
 		}
-	} else if (ntoh16(eh->ether_type) == ETHER_TYPE_IP) {
+	} else if (eh->ether_type == hton16(ETHER_TYPE_IP)) {
 		uint8 *ip_body = pktdata + sizeof(struct ether_header);
 		uint8 tos_tc = IP_TOS46(ip_body);
 		priority = (int)(tos_tc >> IPV4_TOS_PREC_SHIFT);
@@ -1223,6 +1264,7 @@ bcm_iovar_lencheck(const bcm_iovar_t *vi, void *arg, int len, bool set)
 #endif	/* BCMDRIVER */
 
 
+#if !defined(BCMROMOFFLOAD_EXCLUDE_BCMUTILS_FUNCS)
 /*******************************************************************************
  * crc8
  *
@@ -1579,10 +1621,36 @@ bcm_parse_ordered_tlvs(void *buf, int buflen, uint key)
 	}
 	return NULL;
 }
+#endif	/* !BCMROMOFFLOAD_EXCLUDE_BCMUTILS_FUNCS */
 
 #if defined(WLMSG_PRHDRS) || defined(WLMSG_PRPKT) || defined(WLMSG_ASSOC) || \
 	defined(DHD_DEBUG)
 int
+bcm_format_field(const bcm_bit_desc_ex_t *bd, uint32 flags, char* buf, int len)
+{
+	int i, slen = 0;
+	uint32 bit, mask;
+	const char *name;
+	mask = bd->mask;
+	if (len < 2 || !buf)
+		return 0;
+
+	buf[0] = '\0';
+
+	for (i = 0;  (name = bd->bitfield[i].name) != NULL; i++) {
+		bit = bd->bitfield[i].bit;
+		if ((flags & mask) == bit) {
+			if (len > (int)strlen(name)) {
+				slen = strlen(name);
+				strncpy(buf, name, slen+1);
+			}
+			break;
+		}
+	}
+	return slen;
+}
+
+int
 bcm_format_flags(const bcm_bit_desc_t *bd, uint32 flags, char* buf, int len)
 {
 	int i;
@@ -1695,10 +1763,17 @@ static const char *crypto_algo_names[] = {
 	"AES_CCM",
 	"AES_OCB_MSDU",
 	"AES_OCB_MPDU",
+#ifdef BCMCCX
+	"CKIP",
+	"CKIP_MMH",
+	"WEP_MMH",
+	"NALG"
+#else
 	"NALG"
 	"UNDEF",
 	"UNDEF",
 	"UNDEF",
+#endif /* BCMCCX */
 #ifdef BCMWAPI_WPI
 	"WAPI",
 #endif /* BCMWAPI_WPI */
@@ -2004,6 +2079,39 @@ bcm_print_bytes(const char *name, const uchar *data, int len)
 	}
 	printf("\n");
 }
+
+/* Look for vendor-specific IE with specified OUI and optional type */
+bcm_tlv_t *
+find_vendor_ie(void *tlvs, int tlvs_len, const char *voui, uint8 *type, int type_len)
+{
+	bcm_tlv_t *ie;
+	uint8 ie_len;
+
+	ie = (bcm_tlv_t*)tlvs;
+
+	/* make sure we are looking at a valid IE */
+	if (ie == NULL ||
+	    !bcm_valid_tlv(ie, tlvs_len))
+		return NULL;
+
+	/* Walk through the IEs looking for an OUI match */
+	do {
+		ie_len = ie->len;
+		if ((ie->id == DOT11_MNG_PROPR_ID) &&
+		    (ie_len >= (DOT11_OUI_LEN + type_len)) &&
+		    !bcmp(ie->data, voui, DOT11_OUI_LEN))
+		{
+			/* compare optional type */
+			if (type_len == 0 ||
+			    !bcmp(&ie->data[DOT11_OUI_LEN], type, type_len)) {
+				return (ie);		/* a match */
+			}
+		}
+	} while ((ie = bcm_next_tlv(ie, &tlvs_len)) != NULL);
+
+	return NULL;
+}
+
 #if defined(WLTINYDUMP) || defined(WLMSG_INFORM) || defined(WLMSG_ASSOC) || \
 	defined(WLMSG_PRPKT) || defined(WLMSG_WSEC)
 #define SSID_FMT_BUF_LEN	((4 * DOT11_MAX_SSID_LEN) + 1)
@@ -2091,3 +2199,93 @@ process_nvram_vars(char *varbuf, unsigned int len)
 
 	return buf_len;
 }
+
+/* calculate a * b + c */
+void
+bcm_uint64_multiple_add(uint32* r_high, uint32* r_low, uint32 a, uint32 b, uint32 c)
+{
+#define FORMALIZE(var) {cc += (var & 0x80000000) ? 1 : 0; var &= 0x7fffffff;}
+	uint32 r1, r0;
+	uint32 a1, a0, b1, b0, t, cc = 0;
+
+	a1 = a >> 16;
+	a0 = a & 0xffff;
+	b1 = b >> 16;
+	b0 = b & 0xffff;
+
+	r0 = a0 * b0;
+	FORMALIZE(r0);
+
+	t = (a1 * b0) << 16;
+	FORMALIZE(t);
+
+	r0 += t;
+	FORMALIZE(r0);
+
+	t = (a0 * b1) << 16;
+	FORMALIZE(t);
+
+	r0 += t;
+	FORMALIZE(r0);
+
+	FORMALIZE(c);
+
+	r0 += c;
+	FORMALIZE(r0);
+
+	r0 |= (cc % 2) ? 0x80000000 : 0;
+	r1 = a1 * b1 + ((a1 * b0) >> 16) + ((b1 * a0) >> 16) + (cc / 2);
+
+	*r_high = r1;
+	*r_low = r0;
+}
+
+/* calculate a / b */
+void
+bcm_uint64_divide(uint32* r, uint32 a_high, uint32 a_low, uint32 b)
+{
+	uint32 a1 = a_high, a0 = a_low, r0 = 0;
+
+	if (b < 2)
+		return;
+
+	while (a1 != 0) {
+		r0 += (0xffffffff / b) * a1;
+		bcm_uint64_multiple_add(&a1, &a0, ((0xffffffff % b) + 1) % b, a1, a0);
+	}
+
+	r0 += a0 / b;
+	*r = r0;
+}
+
+#ifndef setbit       /* As in the header file */
+#ifdef BCMUTILS_BIT_MACROS_USE_FUNCS
+/* Set bit in byte array. */
+void
+setbit(void *array, uint bit)
+{
+	((uint8 *)array)[bit / NBBY] |= 1 << (bit % NBBY);
+}
+
+/* Clear bit in byte array. */
+void
+clrbit(void *array, uint bit)
+{
+	((uint8 *)array)[bit / NBBY] &= ~(1 << (bit % NBBY));
+}
+
+/* Test if bit is set in byte array. */
+bool
+isset(const void *array, uint bit)
+{
+	return (((const uint8 *)array)[bit / NBBY] & (1 << (bit % NBBY)));
+}
+
+/* Test if bit is clear in byte array. */
+bool
+isclr(const void *array, uint bit)
+{
+	return ((((const uint8 *)array)[bit / NBBY] & (1 << (bit % NBBY))) == 0);
+}
+#endif /* BCMUTILS_BIT_MACROS_USE_FUNCS */
+#endif /* setbit */
diff --git a/drivers/net/wireless/bcmdhd/bcmwifi_channels.c b/drivers/net/wireless/bcmdhd/bcmwifi_channels.c
old mode 100644
new mode 100755
index 0a570f6..4fe34b3
--- a/drivers/net/wireless/bcmdhd/bcmwifi_channels.c
+++ b/drivers/net/wireless/bcmdhd/bcmwifi_channels.c
@@ -3,34 +3,16 @@
  * Contents are wifi-specific, used by any kernel or app-level
  * software that might want wifi things as it grows.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  * $Id: bcmwifi_channels.c 309193 2012-01-19 00:03:57Z $
  */
 
 #include <bcm_cfg.h>
 #include <typedefs.h>
+#include <bcmutils.h>
 
 #ifdef BCMDRIVER
 #include <osl.h>
-#include <bcmutils.h>
 #define strtoul(nptr, endptr, base) bcm_strtoul((nptr), (endptr), (base))
 #define tolower(c) (bcm_isupper((c)) ? ((c) + 'a' - 'A') : (c))
 #else
@@ -440,7 +422,7 @@ wf_chspec_aton(const char *a)
 		return 0;
 
 	
-	c = tolower(a[0]);
+	c = tolower((int)a[0]);
 	if (c == 'g') {
 		a ++; 
 
@@ -456,7 +438,7 @@ wf_chspec_aton(const char *a)
 		if (!read_uint(&a, &ctl_ch))
 			return 0;
 
-		c = tolower(a[0]);
+		c = tolower((int)a[0]);
 	}
 	else {
 		
@@ -503,7 +485,7 @@ wf_chspec_aton(const char *a)
 
 	
 
-	c = tolower(a[0]);
+	c = tolower((int)a[0]);
 
 	
 	if (chspec_band == WL_CHANSPEC_BAND_2G && bw == 40) {
@@ -842,6 +824,56 @@ wf_chspec_ctlchspec(chanspec_t chspec)
 	return ctl_chspec;
 }
 
+
+uint16
+wf_channel2chspec(uint ctl_ch, uint bw)
+{
+	uint16 chspec;
+	const uint8 *center_ch = NULL;
+	int num_ch = 0;
+	int sb = -1;
+	int i = 0;
+
+	chspec = ((ctl_ch <= CH_MAX_2G_CHANNEL) ? WL_CHANSPEC_BAND_2G : WL_CHANSPEC_BAND_5G);
+
+	chspec |= bw;
+
+	if (bw == WL_CHANSPEC_BW_40) {
+		center_ch = wf_5g_40m_chans;
+		num_ch = WF_NUM_5G_40M_CHANS;
+		bw = 40;
+	} else if (bw == WL_CHANSPEC_BW_80) {
+		center_ch = wf_5g_80m_chans;
+		num_ch = WF_NUM_5G_80M_CHANS;
+		bw = 80;
+	} else if (bw == WL_CHANSPEC_BW_160) {
+		center_ch = wf_5g_160m_chans;
+		num_ch = WF_NUM_5G_160M_CHANS;
+		bw = 160;
+	} else if (bw == WL_CHANSPEC_BW_20) {
+		chspec |= ctl_ch;
+		return chspec;
+	} else {
+		return 0;
+	}
+
+	for (i = 0; i < num_ch; i ++) {
+		sb = channel_to_sb(center_ch[i], ctl_ch, bw);
+		if (sb >= 0) {
+			chspec |= center_ch[i];
+			chspec |= (sb << WL_CHANSPEC_CTL_SB_SHIFT);
+			break;
+		}
+	}
+
+	
+	if (sb < 0) {
+		return 0;
+	}
+
+	return chspec;
+}
+
 #endif 
 
 
@@ -934,3 +966,99 @@ wf_channel2mhz(uint ch, uint start_factor)
 
 	return freq;
 }
+
+
+static const struct chan_info {
+	uint16	chan;	
+	uint16	freq;	
+} chan_info[] = {
+	
+		{1,	2412},
+		{2,	2417},
+		{3,	2422},
+		{4,	2427},
+		{5,	2432},
+		{6,	2437},
+		{7,	2442},
+		{8,	2447},
+		{9,	2452},
+		{10,	2457},
+	{11,	2462},
+	{12,	2467},
+	{13,	2472},
+	{14,	2484},
+
+#ifdef BAND5G
+
+	{34,	5170},
+	{38,	5190},
+	{42,	5210},
+	{46,	5230},
+
+
+	{36,	5180},
+	{40,	5200},
+	{44,	5220},
+	{48,	5240},
+	{52,	5260},
+	{56,	5280},
+	{60,	5300},
+	{64,	5320},
+
+
+	{100,	5500},
+	{104,	5520},
+	{108,	5540},
+	{112,	5560},
+	{116,	5580},
+	{120,	5600},
+	{124,	5620},
+	{128,	5640},
+	{132,	5660},
+	{136,	5680},
+	{140,	5700},
+
+
+	{149,	5745},
+	{153,	5765},
+	{157,	5785},
+	{161,	5805},
+	{165,	5825},
+
+
+	{184,	4920},
+	{188,	4940},
+	{192,	4960},
+	{196,	4980},
+	{200,	5000},
+	{204,	5020},
+	{208,	5040},
+	{212,	5060},
+	{216,	5080}
+#endif 
+};
+
+
+uint
+wf_freq2channel(uint freq)
+{
+	uint i;
+
+	for (i = 0; i < ARRAYSIZE(chan_info); i++) {
+		if (chan_info[i].freq == freq)
+			return (chan_info[i].chan);
+	}
+	return (0);
+}
+
+
+uint
+wf_channel2freq(uint channel)
+{
+	uint i;
+
+	for (i = 0; i < ARRAYSIZE(chan_info); i++)
+		if (chan_info[i].chan == channel)
+			return (chan_info[i].freq);
+	return (0);
+}
diff --git a/drivers/net/wireless/bcmdhd/bcmwifi_channels.h b/drivers/net/wireless/bcmdhd/bcmwifi_channels.h
deleted file mode 100644
index c797047..0000000
--- a/drivers/net/wireless/bcmdhd/bcmwifi_channels.h
+++ /dev/null
@@ -1,345 +0,0 @@
-/*
- * Misc utility routines for WL and Apps
- * This header file housing the define and function prototype use by
- * both the wl driver, tools & Apps.
- *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
- *
- * $Id: bcmwifi_channels.h 309193 2012-01-19 00:03:57Z $
- */
-
-#ifndef	_bcmwifi_channels_h_
-#define	_bcmwifi_channels_h_
-
-
-
-typedef uint16 chanspec_t;
-
-
-#define CH_UPPER_SB			0x01
-#define CH_LOWER_SB			0x02
-#define CH_EWA_VALID			0x04
-#define CH_80MHZ_APART			16
-#define CH_40MHZ_APART			8
-#define CH_20MHZ_APART			4
-#define CH_10MHZ_APART			2
-#define CH_5MHZ_APART			1	
-#define CH_MAX_2G_CHANNEL		14	
-#define	MAXCHANNEL		224	
-#define CHSPEC_CTLOVLP(sp1, sp2, sep)	ABS(wf_chspec_ctlchan(sp1) - wf_chspec_ctlchan(sp2)) < (sep)
-
-
-#undef  D11AC_IOTYPES
-#define D11AC_IOTYPES
-
-#ifndef D11AC_IOTYPES
-
-#define WL_CHANSPEC_CHAN_MASK		0x00ff
-#define WL_CHANSPEC_CHAN_SHIFT		0
-
-#define WL_CHANSPEC_CTL_SB_MASK		0x0300
-#define WL_CHANSPEC_CTL_SB_SHIFT	     8
-#define WL_CHANSPEC_CTL_SB_LOWER	0x0100
-#define WL_CHANSPEC_CTL_SB_UPPER	0x0200
-#define WL_CHANSPEC_CTL_SB_NONE		0x0300
-
-#define WL_CHANSPEC_BW_MASK		0x0C00
-#define WL_CHANSPEC_BW_SHIFT		    10
-#define WL_CHANSPEC_BW_10		0x0400
-#define WL_CHANSPEC_BW_20		0x0800
-#define WL_CHANSPEC_BW_40		0x0C00
-
-#define WL_CHANSPEC_BAND_MASK		0xf000
-#define WL_CHANSPEC_BAND_SHIFT		12
-#define WL_CHANSPEC_BAND_5G		0x1000
-#define WL_CHANSPEC_BAND_2G		0x2000
-#define INVCHANSPEC			255
-
-
-#define LOWER_20_SB(channel)	(((channel) > CH_10MHZ_APART) ? ((channel) - CH_10MHZ_APART) : 0)
-#define UPPER_20_SB(channel)	(((channel) < (MAXCHANNEL - CH_10MHZ_APART)) ? \
-				((channel) + CH_10MHZ_APART) : 0)
-#define CHSPEC_WLCBANDUNIT(chspec)	(CHSPEC_IS5G(chspec) ? BAND_5G_INDEX : BAND_2G_INDEX)
-#define CH20MHZ_CHSPEC(channel)	(chanspec_t)((chanspec_t)(channel) | WL_CHANSPEC_BW_20 | \
-				WL_CHANSPEC_CTL_SB_NONE | (((channel) <= CH_MAX_2G_CHANNEL) ? \
-				WL_CHANSPEC_BAND_2G : WL_CHANSPEC_BAND_5G))
-#define NEXT_20MHZ_CHAN(channel)	(((channel) < (MAXCHANNEL - CH_20MHZ_APART)) ? \
-					((channel) + CH_20MHZ_APART) : 0)
-#define CH40MHZ_CHSPEC(channel, ctlsb)	(chanspec_t) \
-					((channel) | (ctlsb) | WL_CHANSPEC_BW_40 | \
-					((channel) <= CH_MAX_2G_CHANNEL ? WL_CHANSPEC_BAND_2G : \
-					WL_CHANSPEC_BAND_5G))
-#define CHSPEC_CHANNEL(chspec)	((uint8)((chspec) & WL_CHANSPEC_CHAN_MASK))
-#define CHSPEC_BAND(chspec)	((chspec) & WL_CHANSPEC_BAND_MASK)
-
-
-#define CHSPEC_CTL_SB(chspec)	((chspec) & WL_CHANSPEC_CTL_SB_MASK)
-#define CHSPEC_BW(chspec)	((chspec) & WL_CHANSPEC_BW_MASK)
-
-#ifdef WL11N_20MHZONLY
-
-#define CHSPEC_IS10(chspec)	0
-#define CHSPEC_IS20(chspec)	1
-#ifndef CHSPEC_IS40
-#define CHSPEC_IS40(chspec)	0
-#endif
-
-#else 
-
-#define CHSPEC_IS10(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_10)
-#define CHSPEC_IS20(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_20)
-#ifndef CHSPEC_IS40
-#define CHSPEC_IS40(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_40)
-#endif
-
-#endif 
-
-#define CHSPEC_IS5G(chspec)	(((chspec) & WL_CHANSPEC_BAND_MASK) == WL_CHANSPEC_BAND_5G)
-#define CHSPEC_IS2G(chspec)	(((chspec) & WL_CHANSPEC_BAND_MASK) == WL_CHANSPEC_BAND_2G)
-#define CHSPEC_SB_NONE(chspec)	(((chspec) & WL_CHANSPEC_CTL_SB_MASK) == WL_CHANSPEC_CTL_SB_NONE)
-#define CHSPEC_SB_UPPER(chspec)	(((chspec) & WL_CHANSPEC_CTL_SB_MASK) == WL_CHANSPEC_CTL_SB_UPPER)
-#define CHSPEC_SB_LOWER(chspec)	(((chspec) & WL_CHANSPEC_CTL_SB_MASK) == WL_CHANSPEC_CTL_SB_LOWER)
-#define CHSPEC_CTL_CHAN(chspec)  ((CHSPEC_SB_LOWER(chspec)) ? \
-				  (LOWER_20_SB(((chspec) & WL_CHANSPEC_CHAN_MASK))) : \
-				  (UPPER_20_SB(((chspec) & WL_CHANSPEC_CHAN_MASK))))
-#define CHSPEC2WLC_BAND(chspec) (CHSPEC_IS5G(chspec) ? WLC_BAND_5G : WLC_BAND_2G)
-
-#define CHANSPEC_STR_LEN    8
-
-#else 
-
-#define WL_CHANSPEC_CHAN_MASK		0x00ff
-#define WL_CHANSPEC_CHAN_SHIFT		0
-#define WL_CHANSPEC_CHAN1_MASK		0x000f
-#define WL_CHANSPEC_CHAN1_SHIFT		0
-#define WL_CHANSPEC_CHAN2_MASK		0x00f0
-#define WL_CHANSPEC_CHAN2_SHIFT		4
-
-#define WL_CHANSPEC_CTL_SB_MASK		0x0700
-#define WL_CHANSPEC_CTL_SB_SHIFT	8
-#define WL_CHANSPEC_CTL_SB_LLL		0x0000
-#define WL_CHANSPEC_CTL_SB_LLU		0x0100
-#define WL_CHANSPEC_CTL_SB_LUL		0x0200
-#define WL_CHANSPEC_CTL_SB_LUU		0x0300
-#define WL_CHANSPEC_CTL_SB_ULL		0x0400
-#define WL_CHANSPEC_CTL_SB_ULU		0x0500
-#define WL_CHANSPEC_CTL_SB_UUL		0x0600
-#define WL_CHANSPEC_CTL_SB_UUU		0x0700
-#define WL_CHANSPEC_CTL_SB_LL		WL_CHANSPEC_CTL_SB_LLL
-#define WL_CHANSPEC_CTL_SB_LU		WL_CHANSPEC_CTL_SB_LLU
-#define WL_CHANSPEC_CTL_SB_UL		WL_CHANSPEC_CTL_SB_LUL
-#define WL_CHANSPEC_CTL_SB_UU		WL_CHANSPEC_CTL_SB_LUU
-#define WL_CHANSPEC_CTL_SB_L		WL_CHANSPEC_CTL_SB_LLL
-#define WL_CHANSPEC_CTL_SB_U		WL_CHANSPEC_CTL_SB_LLU
-#define WL_CHANSPEC_CTL_SB_LOWER 	WL_CHANSPEC_CTL_SB_LLL
-#define WL_CHANSPEC_CTL_SB_UPPER	WL_CHANSPEC_CTL_SB_LLU
-
-#define WL_CHANSPEC_BW_MASK		0x3800
-#define WL_CHANSPEC_BW_SHIFT		11
-#define WL_CHANSPEC_BW_5		0x0000
-#define WL_CHANSPEC_BW_10		0x0800
-#define WL_CHANSPEC_BW_20		0x1000
-#define WL_CHANSPEC_BW_40		0x1800
-#define WL_CHANSPEC_BW_80		0x2000
-#define WL_CHANSPEC_BW_160		0x2800
-#define WL_CHANSPEC_BW_8080		0x3000
-
-#define WL_CHANSPEC_BAND_MASK		0xc000
-#define WL_CHANSPEC_BAND_SHIFT		14
-#define WL_CHANSPEC_BAND_2G		0x0000
-#define WL_CHANSPEC_BAND_3G		0x4000
-#define WL_CHANSPEC_BAND_4G		0x8000
-#define WL_CHANSPEC_BAND_5G		0xc000
-#define INVCHANSPEC			255
-
-
-#define LOWER_20_SB(channel)		(((channel) > CH_10MHZ_APART) ? \
-					((channel) - CH_10MHZ_APART) : 0)
-#define UPPER_20_SB(channel)		(((channel) < (MAXCHANNEL - CH_10MHZ_APART)) ? \
-					((channel) + CH_10MHZ_APART) : 0)
-#define LOWER_40_SB(channel)		((channel) - CH_20MHZ_APART)
-#define UPPER_40_SB(channel)		((channel) + CH_20MHZ_APART)
-#define CHSPEC_WLCBANDUNIT(chspec)	(CHSPEC_IS5G(chspec) ? BAND_5G_INDEX : BAND_2G_INDEX)
-#define CH20MHZ_CHSPEC(channel)		(chanspec_t)((chanspec_t)(channel) | WL_CHANSPEC_BW_20 | \
-					(((channel) <= CH_MAX_2G_CHANNEL) ? \
-					WL_CHANSPEC_BAND_2G : WL_CHANSPEC_BAND_5G))
-#define NEXT_20MHZ_CHAN(channel)	(((channel) < (MAXCHANNEL - CH_20MHZ_APART)) ? \
-					((channel) + CH_20MHZ_APART) : 0)
-#define CH40MHZ_CHSPEC(channel, ctlsb)	(chanspec_t) \
-					((channel) | (ctlsb) | WL_CHANSPEC_BW_40 | \
-					((channel) <= CH_MAX_2G_CHANNEL ? WL_CHANSPEC_BAND_2G : \
-					WL_CHANSPEC_BAND_5G))
-#define CH80MHZ_CHSPEC(channel, ctlsb)	(chanspec_t) \
-					((channel) | (ctlsb) | \
-					 WL_CHANSPEC_BW_80 | WL_CHANSPEC_BAND_5G)
-#define CH160MHZ_CHSPEC(channel, ctlsb)	(chanspec_t) \
-					((channel) | (ctlsb) | \
-					 WL_CHANSPEC_BW_160 | WL_CHANSPEC_BAND_5G)
-
-
-#define CHSPEC_CHANNEL(chspec)		((uint8)((chspec) & WL_CHANSPEC_CHAN_MASK))
-#define CHSPEC_CHAN1(chspec)		((chspec) & WL_CHANSPEC_CHAN1_MASK)
-#define CHSPEC_CHAN2(chspec)		((chspec) & WL_CHANSPEC_CHAN2_MASK)
-#define CHSPEC_BAND(chspec)		((chspec) & WL_CHANSPEC_BAND_MASK)
-#define CHSPEC_CTL_SB(chspec)		((chspec) & WL_CHANSPEC_CTL_SB_MASK)
-#define CHSPEC_BW(chspec)		((chspec) & WL_CHANSPEC_BW_MASK)
-
-#ifdef WL11N_20MHZONLY
-
-#define CHSPEC_IS10(chspec)	0
-#define CHSPEC_IS20(chspec)	1
-#ifndef CHSPEC_IS40
-#define CHSPEC_IS40(chspec)	0
-#endif
-#ifndef CHSPEC_IS80
-#define CHSPEC_IS80(chspec)	0
-#endif
-#ifndef CHSPEC_IS160
-#define CHSPEC_IS160(chspec)	0
-#endif
-#ifndef CHSPEC_IS8080
-#define CHSPEC_IS8080(chspec)	0
-#endif
-
-#else 
-
-#define CHSPEC_IS10(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_10)
-#define CHSPEC_IS20(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_20)
-#ifndef CHSPEC_IS40
-#define CHSPEC_IS40(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_40)
-#endif
-#ifndef CHSPEC_IS80
-#define CHSPEC_IS80(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_80)
-#endif
-#ifndef CHSPEC_IS160
-#define CHSPEC_IS160(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_160)
-#endif
-#ifndef CHSPEC_IS8080
-#define CHSPEC_IS8080(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_8080)
-#endif
-
-#endif 
-
-#define CHSPEC_IS5G(chspec)	(((chspec) & WL_CHANSPEC_BAND_MASK) == WL_CHANSPEC_BAND_5G)
-#define CHSPEC_IS2G(chspec)	(((chspec) & WL_CHANSPEC_BAND_MASK) == WL_CHANSPEC_BAND_2G)
-#define CHSPEC_SB_UPPER(chspec)	\
-	((((chspec) & WL_CHANSPEC_CTL_SB_MASK) == WL_CHANSPEC_CTL_SB_UPPER) && \
-	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_40))
-#define CHSPEC_SB_LOWER(chspec)	\
-	((((chspec) & WL_CHANSPEC_CTL_SB_MASK) == WL_CHANSPEC_CTL_SB_LOWER) && \
-	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_40))
-#define CHSPEC2WLC_BAND(chspec) (CHSPEC_IS5G(chspec) ? WLC_BAND_5G : WLC_BAND_2G)
-
-
-#define CHANSPEC_STR_LEN    20
-
-
-
-#define WL_LCHANSPEC_CHAN_MASK		0x00ff
-#define WL_LCHANSPEC_CHAN_SHIFT		     0
-
-#define WL_LCHANSPEC_CTL_SB_MASK	0x0300
-#define WL_LCHANSPEC_CTL_SB_SHIFT	     8
-#define WL_LCHANSPEC_CTL_SB_LOWER	0x0100
-#define WL_LCHANSPEC_CTL_SB_UPPER	0x0200
-#define WL_LCHANSPEC_CTL_SB_NONE	0x0300
-
-#define WL_LCHANSPEC_BW_MASK		0x0C00
-#define WL_LCHANSPEC_BW_SHIFT		    10
-#define WL_LCHANSPEC_BW_10		0x0400
-#define WL_LCHANSPEC_BW_20		0x0800
-#define WL_LCHANSPEC_BW_40		0x0C00
-
-#define WL_LCHANSPEC_BAND_MASK		0xf000
-#define WL_LCHANSPEC_BAND_SHIFT		    12
-#define WL_LCHANSPEC_BAND_5G		0x1000
-#define WL_LCHANSPEC_BAND_2G		0x2000
-
-#define LCHSPEC_CHANNEL(chspec)	((uint8)((chspec) & WL_LCHANSPEC_CHAN_MASK))
-#define LCHSPEC_BAND(chspec)	((chspec) & WL_LCHANSPEC_BAND_MASK)
-#define LCHSPEC_CTL_SB(chspec)	((chspec) & WL_LCHANSPEC_CTL_SB_MASK)
-#define LCHSPEC_BW(chspec)	((chspec) & WL_LCHANSPEC_BW_MASK)
-#define LCHSPEC_IS10(chspec)	(((chspec) & WL_LCHANSPEC_BW_MASK) == WL_LCHANSPEC_BW_10)
-#define LCHSPEC_IS20(chspec)	(((chspec) & WL_LCHANSPEC_BW_MASK) == WL_LCHANSPEC_BW_20)
-#define LCHSPEC_IS40(chspec)	(((chspec) & WL_LCHANSPEC_BW_MASK) == WL_LCHANSPEC_BW_40)
-#define LCHSPEC_IS5G(chspec)	(((chspec) & WL_LCHANSPEC_BAND_MASK) == WL_LCHANSPEC_BAND_5G)
-#define LCHSPEC_IS2G(chspec)	(((chspec) & WL_LCHANSPEC_BAND_MASK) == WL_LCHANSPEC_BAND_2G)
-
-#define LCHSPEC_CREATE(chan, band, bw, sb)  ((uint16)((chan) | (sb) | (bw) | (band)))
-
-#endif 
-
-
-
-
-#define WF_CHAN_FACTOR_2_4_G		4814	
-
-
-#define WF_CHAN_FACTOR_5_G		10000	
-
-
-#define WF_CHAN_FACTOR_4_G		8000	
-
-
-#define WLC_MAXRATE	108	
-#define WLC_RATE_1M	2	
-#define WLC_RATE_2M	4	
-#define WLC_RATE_5M5	11	
-#define WLC_RATE_11M	22	
-#define WLC_RATE_6M	12	
-#define WLC_RATE_9M	18	
-#define WLC_RATE_12M	24	
-#define WLC_RATE_18M	36	
-#define WLC_RATE_24M	48	
-#define WLC_RATE_36M	72	
-#define WLC_RATE_48M	96	
-#define WLC_RATE_54M	108	
-
-#define WLC_2G_25MHZ_OFFSET		5	
-
-
-extern char * wf_chspec_ntoa(chanspec_t chspec, char *buf);
-
-
-extern chanspec_t wf_chspec_aton(const char *a);
-
-
-extern bool wf_chspec_malformed(chanspec_t chanspec);
-
-
-extern bool wf_chspec_valid(chanspec_t chanspec);
-
-
-extern uint8 wf_chspec_ctlchan(chanspec_t chspec);
-
-
-extern chanspec_t wf_chspec_ctlchspec(chanspec_t chspec);
-
-
-extern chanspec_t wf_chspec_primary40_chspec(chanspec_t chspec);
-
-
-extern int wf_mhz2channel(uint freq, uint start_factor);
-
-
-extern int wf_channel2mhz(uint channel, uint start_factor);
-
-#endif	
diff --git a/drivers/net/wireless/bcmdhd/bcmwifi_rates.h b/drivers/net/wireless/bcmdhd/bcmwifi_rates.h
deleted file mode 100644
index 9896b23..0000000
--- a/drivers/net/wireless/bcmdhd/bcmwifi_rates.h
+++ /dev/null
@@ -1,306 +0,0 @@
-/*
- * Indices for 802.11 a/b/g/n/ac 1-3 chain symmetric transmit rates
- *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
- *
- * $Id: bcmwifi_rates.h 252708 2011-04-12 06:45:56Z $
- */
-
-#ifndef _bcmwifi_rates_h_
-#define _bcmwifi_rates_h_
-
-#ifdef __cplusplus
-extern "C" {
-#endif 
-
-
-#define WL_RATESET_SZ_DSSS		4
-#define WL_RATESET_SZ_OFDM		8
-#define WL_RATESET_SZ_HT_MCS	8
-#define WL_RATESET_SZ_VHT_MCS	10
-
-#define WL_TX_CHAINS_MAX	3
-
-#define WL_RATE_DISABLED		(-128) 
-
-
-typedef enum wl_tx_bw {
-	WL_TX_BW_20,
-	WL_TX_BW_40,
-	WL_TX_BW_80,
-	WL_TX_BW_20IN40,
-	WL_TX_BW_20IN80,
-	WL_TX_BW_40IN80,
-	WL_TX_BW_ALL
-} wl_tx_bw_t;
-
-
-
-typedef enum wl_tx_mode {
-	WL_TX_MODE_NONE,
-	WL_TX_MODE_STBC,
-	WL_TX_MODE_CDD,
-	WL_TX_MODE_SDM
-} wl_tx_mode_t;
-
-
-
-typedef enum wl_tx_chains {
-	WL_TX_CHAINS_1 = 1,
-	WL_TX_CHAINS_2,
-	WL_TX_CHAINS_3
-} wl_tx_chains_t;
-
-
-
-typedef enum wl_tx_nss {
-	WL_TX_NSS_1 = 1,
-	WL_TX_NSS_2,
-	WL_TX_NSS_3
-} wl_tx_nss_t;
-
-
-typedef enum clm_rates {
-	
-
-	
-	WL_RATE_1X1_DSSS_1         = 0,
-	WL_RATE_1X1_DSSS_2         = 1,
-	WL_RATE_1X1_DSSS_5_5       = 2,
-	WL_RATE_1X1_DSSS_11        = 3,
-
-	WL_RATE_1X1_OFDM_6         = 4,
-	WL_RATE_1X1_OFDM_9         = 5,
-	WL_RATE_1X1_OFDM_12        = 6,
-	WL_RATE_1X1_OFDM_18        = 7,
-	WL_RATE_1X1_OFDM_24        = 8,
-	WL_RATE_1X1_OFDM_36        = 9,
-	WL_RATE_1X1_OFDM_48        = 10,
-	WL_RATE_1X1_OFDM_54        = 11,
-
-	WL_RATE_1X1_MCS0           = 12,
-	WL_RATE_1X1_MCS1           = 13,
-	WL_RATE_1X1_MCS2           = 14,
-	WL_RATE_1X1_MCS3           = 15,
-	WL_RATE_1X1_MCS4           = 16,
-	WL_RATE_1X1_MCS5           = 17,
-	WL_RATE_1X1_MCS6           = 18,
-	WL_RATE_1X1_MCS7           = 19,
-
-	WL_RATE_1X1_VHT0SS1        = 12,
-	WL_RATE_1X1_VHT1SS1        = 13,
-	WL_RATE_1X1_VHT2SS1        = 14,
-	WL_RATE_1X1_VHT3SS1        = 15,
-	WL_RATE_1X1_VHT4SS1        = 16,
-	WL_RATE_1X1_VHT5SS1        = 17,
-	WL_RATE_1X1_VHT6SS1        = 18,
-	WL_RATE_1X1_VHT7SS1        = 19,
-	WL_RATE_1X1_VHT8SS1        = 20,
-	WL_RATE_1X1_VHT9SS1        = 21,
-
-
-	
-
-	
-	WL_RATE_1X2_DSSS_1         = 22,
-	WL_RATE_1X2_DSSS_2         = 23,
-	WL_RATE_1X2_DSSS_5_5       = 24,
-	WL_RATE_1X2_DSSS_11        = 25,
-
-	WL_RATE_1X2_CDD_OFDM_6     = 26,
-	WL_RATE_1X2_CDD_OFDM_9     = 27,
-	WL_RATE_1X2_CDD_OFDM_12    = 28,
-	WL_RATE_1X2_CDD_OFDM_18    = 29,
-	WL_RATE_1X2_CDD_OFDM_24    = 30,
-	WL_RATE_1X2_CDD_OFDM_36    = 31,
-	WL_RATE_1X2_CDD_OFDM_48    = 32,
-	WL_RATE_1X2_CDD_OFDM_54    = 33,
-
-	WL_RATE_1X2_CDD_MCS0       = 34,
-	WL_RATE_1X2_CDD_MCS1       = 35,
-	WL_RATE_1X2_CDD_MCS2       = 36,
-	WL_RATE_1X2_CDD_MCS3       = 37,
-	WL_RATE_1X2_CDD_MCS4       = 38,
-	WL_RATE_1X2_CDD_MCS5       = 39,
-	WL_RATE_1X2_CDD_MCS6       = 40,
-	WL_RATE_1X2_CDD_MCS7       = 41,
-
-	WL_RATE_1X2_VHT0SS1        = 34,
-	WL_RATE_1X2_VHT1SS1        = 35,
-	WL_RATE_1X2_VHT2SS1        = 36,
-	WL_RATE_1X2_VHT3SS1        = 37,
-	WL_RATE_1X2_VHT4SS1        = 38,
-	WL_RATE_1X2_VHT5SS1        = 39,
-	WL_RATE_1X2_VHT6SS1        = 40,
-	WL_RATE_1X2_VHT7SS1        = 41,
-	WL_RATE_1X2_VHT8SS1        = 42,
-	WL_RATE_1X2_VHT9SS1        = 43,
-
-	
-	WL_RATE_2X2_STBC_MCS0      = 44,
-	WL_RATE_2X2_STBC_MCS1      = 45,
-	WL_RATE_2X2_STBC_MCS2      = 46,
-	WL_RATE_2X2_STBC_MCS3      = 47,
-	WL_RATE_2X2_STBC_MCS4      = 48,
-	WL_RATE_2X2_STBC_MCS5      = 49,
-	WL_RATE_2X2_STBC_MCS6      = 50,
-	WL_RATE_2X2_STBC_MCS7      = 51,
-
-	WL_RATE_2X2_STBC_VHT0SS1   = 44,
-	WL_RATE_2X2_STBC_VHT1SS1   = 45,
-	WL_RATE_2X2_STBC_VHT2SS1   = 46,
-	WL_RATE_2X2_STBC_VHT3SS1   = 47,
-	WL_RATE_2X2_STBC_VHT4SS1   = 48,
-	WL_RATE_2X2_STBC_VHT5SS1   = 49,
-	WL_RATE_2X2_STBC_VHT6SS1   = 50,
-	WL_RATE_2X2_STBC_VHT7SS1   = 51,
-	WL_RATE_2X2_STBC_VHT8SS1   = 52,
-	WL_RATE_2X2_STBC_VHT9SS1   = 53,
-
-	WL_RATE_2X2_SDM_MCS8       = 54,
-	WL_RATE_2X2_SDM_MCS9       = 55,
-	WL_RATE_2X2_SDM_MCS10      = 56,
-	WL_RATE_2X2_SDM_MCS11      = 57,
-	WL_RATE_2X2_SDM_MCS12      = 58,
-	WL_RATE_2X2_SDM_MCS13      = 59,
-	WL_RATE_2X2_SDM_MCS14      = 60,
-	WL_RATE_2X2_SDM_MCS15      = 61,
-
-	WL_RATE_2X2_VHT0SS2        = 54,
-	WL_RATE_2X2_VHT1SS2        = 55,
-	WL_RATE_2X2_VHT2SS2        = 56,
-	WL_RATE_2X2_VHT3SS2        = 57,
-	WL_RATE_2X2_VHT4SS2        = 58,
-	WL_RATE_2X2_VHT5SS2        = 59,
-	WL_RATE_2X2_VHT6SS2        = 60,
-	WL_RATE_2X2_VHT7SS2        = 61,
-	WL_RATE_2X2_VHT8SS2        = 62,
-	WL_RATE_2X2_VHT9SS2        = 63,
-
-
-	
-
-	
-	WL_RATE_1X3_DSSS_1         = 64,
-	WL_RATE_1X3_DSSS_2         = 65,
-	WL_RATE_1X3_DSSS_5_5       = 66,
-	WL_RATE_1X3_DSSS_11        = 67,
-
-	WL_RATE_1X3_CDD_OFDM_6     = 68,
-	WL_RATE_1X3_CDD_OFDM_9     = 69,
-	WL_RATE_1X3_CDD_OFDM_12    = 70,
-	WL_RATE_1X3_CDD_OFDM_18    = 71,
-	WL_RATE_1X3_CDD_OFDM_24    = 72,
-	WL_RATE_1X3_CDD_OFDM_36    = 73,
-	WL_RATE_1X3_CDD_OFDM_48    = 74,
-	WL_RATE_1X3_CDD_OFDM_54    = 75,
-
-	WL_RATE_1X3_CDD_MCS0       = 76,
-	WL_RATE_1X3_CDD_MCS1       = 77,
-	WL_RATE_1X3_CDD_MCS2       = 78,
-	WL_RATE_1X3_CDD_MCS3       = 79,
-	WL_RATE_1X3_CDD_MCS4       = 80,
-	WL_RATE_1X3_CDD_MCS5       = 81,
-	WL_RATE_1X3_CDD_MCS6       = 82,
-	WL_RATE_1X3_CDD_MCS7       = 83,
-
-	WL_RATE_1X3_VHT0SS1        = 76,
-	WL_RATE_1X3_VHT1SS1        = 77,
-	WL_RATE_1X3_VHT2SS1        = 78,
-	WL_RATE_1X3_VHT3SS1        = 79,
-	WL_RATE_1X3_VHT4SS1        = 80,
-	WL_RATE_1X3_VHT5SS1        = 81,
-	WL_RATE_1X3_VHT6SS1        = 82,
-	WL_RATE_1X3_VHT7SS1        = 83,
-	WL_RATE_1X3_VHT8SS1        = 84,
-	WL_RATE_1X3_VHT9SS1        = 85,
-
-	
-	WL_RATE_2X3_STBC_MCS0      = 86,
-	WL_RATE_2X3_STBC_MCS1      = 87,
-	WL_RATE_2X3_STBC_MCS2      = 88,
-	WL_RATE_2X3_STBC_MCS3      = 89,
-	WL_RATE_2X3_STBC_MCS4      = 90,
-	WL_RATE_2X3_STBC_MCS5      = 91,
-	WL_RATE_2X3_STBC_MCS6      = 92,
-	WL_RATE_2X3_STBC_MCS7      = 93,
-
-	WL_RATE_2X3_STBC_VHT0SS1   = 86,
-	WL_RATE_2X3_STBC_VHT1SS1   = 87,
-	WL_RATE_2X3_STBC_VHT2SS1   = 88,
-	WL_RATE_2X3_STBC_VHT3SS1   = 89,
-	WL_RATE_2X3_STBC_VHT4SS1   = 90,
-	WL_RATE_2X3_STBC_VHT5SS1   = 91,
-	WL_RATE_2X3_STBC_VHT6SS1   = 92,
-	WL_RATE_2X3_STBC_VHT7SS1   = 93,
-	WL_RATE_2X3_STBC_VHT8SS1   = 94,
-	WL_RATE_2X3_STBC_VHT9SS1   = 95,
-
-	WL_RATE_2X3_SDM_MCS8       = 96,
-	WL_RATE_2X3_SDM_MCS9       = 97,
-	WL_RATE_2X3_SDM_MCS10      = 98,
-	WL_RATE_2X3_SDM_MCS11      = 99,
-	WL_RATE_2X3_SDM_MCS12      = 100,
-	WL_RATE_2X3_SDM_MCS13      = 101,
-	WL_RATE_2X3_SDM_MCS14      = 102,
-	WL_RATE_2X3_SDM_MCS15      = 103,
-
-	WL_RATE_2X3_VHT0SS2        = 96,
-	WL_RATE_2X3_VHT1SS2        = 97,
-	WL_RATE_2X3_VHT2SS2        = 98,
-	WL_RATE_2X3_VHT3SS2        = 99,
-	WL_RATE_2X3_VHT4SS2        = 100,
-	WL_RATE_2X3_VHT5SS2        = 101,
-	WL_RATE_2X3_VHT6SS2        = 102,
-	WL_RATE_2X3_VHT7SS2        = 103,
-	WL_RATE_2X3_VHT8SS2        = 104,
-	WL_RATE_2X3_VHT9SS2        = 105,
-
-	
-	WL_RATE_3X3_SDM_MCS16      = 106,
-	WL_RATE_3X3_SDM_MCS17      = 107,
-	WL_RATE_3X3_SDM_MCS18      = 108,
-	WL_RATE_3X3_SDM_MCS19      = 109,
-	WL_RATE_3X3_SDM_MCS20      = 110,
-	WL_RATE_3X3_SDM_MCS21      = 111,
-	WL_RATE_3X3_SDM_MCS22      = 112,
-	WL_RATE_3X3_SDM_MCS23      = 113,
-
-	WL_RATE_3X3_VHT0SS3        = 106,
-	WL_RATE_3X3_VHT1SS3        = 107,
-	WL_RATE_3X3_VHT2SS3        = 108,
-	WL_RATE_3X3_VHT3SS3        = 109,
-	WL_RATE_3X3_VHT4SS3        = 110,
-	WL_RATE_3X3_VHT5SS3        = 111,
-	WL_RATE_3X3_VHT6SS3        = 112,
-	WL_RATE_3X3_VHT7SS3        = 113,
-	WL_RATE_3X3_VHT8SS3        = 114,
-	WL_RATE_3X3_VHT9SS3        = 115,
-
-	
-	WL_NUMRATES                = 116
-} clm_rates_t;
-
-#ifdef __cplusplus
-}
-#endif 
-
-#endif 
diff --git a/drivers/net/wireless/bcmdhd/dhd.h b/drivers/net/wireless/bcmdhd/dhd.h
old mode 100644
new mode 100755
index c3e05c9..96ce83f
--- a/drivers/net/wireless/bcmdhd/dhd.h
+++ b/drivers/net/wireless/bcmdhd/dhd.h
@@ -4,27 +4,9 @@
  * Provides type definitions and function prototypes used to link the
  * DHD OS, bus, and protocol modules.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: dhd.h 329678 2012-04-26 08:51:32Z $
+ * $Id: dhd.h 393288 2013-03-27 01:02:25Z $
  */
 
 /****************
@@ -58,11 +40,22 @@ int setScheduler(struct task_struct *p, int policy, struct sched_param *param);
 #include <wlioctl.h>
 #include <wlfc_proto.h>
 
+#if 0 && (0>= 0x0600)
+#include <wdf.h>
+#include <WdfMiniport.h>
+#endif 
 
+#if defined(KEEP_ALIVE)
+/* Default KEEP_ALIVE Period is 55 sec to prevent AP from sending Keep Alive probe frame */
+#define KEEP_ALIVE_PERIOD 55000
+#define NULL_PKT_STR	"null_pkt"
+#endif /* KEEP_ALIVE */
 /* Forward decls */
 struct dhd_bus;
 struct dhd_prot;
 struct dhd_info;
+struct dhd_ioctl;
+struct dhd_cmn;
 
 /* The level of bus communication with the dongle */
 enum dhd_bus_state {
@@ -71,7 +64,7 @@ enum dhd_bus_state {
 	DHD_BUS_DATA		/* Ready for frame transfers */
 };
 
-
+#if 0 && (0>= 0x0600)
 /* Firmware requested operation mode */
 #define STA_MASK			0x0001
 #define HOSTAPD_MASK		0x0002
@@ -80,18 +73,41 @@ enum dhd_bus_state {
 #define P2P_GO_ENABLED		0x0010
 #define P2P_GC_ENABLED		0x0020
 #define CONCURENT_MASK		0x00F0
+#endif 
 
-/* max sequential rxcntl timeouts to set HANG event */
-#define MAX_CNTL_TIMEOUT  2
+enum dhd_op_flags {
+/* Firmware requested operation mode */
+	DHD_FLAG_STA_MODE				= (1 << (0)), /* STA only */
+	DHD_FLAG_HOSTAP_MODE				= (1 << (1)), /* SOFTAP only */
+	DHD_FLAG_P2P_MODE				= (1 << (2)), /* P2P Only */
+	/* STA + P2P */
+	DHD_FLAG_CONCURR_SINGLE_CHAN_MODE = (DHD_FLAG_STA_MODE | DHD_FLAG_P2P_MODE),
+	DHD_FLAG_CONCURR_MULTI_CHAN_MODE		= (1 << (4)), /* STA + P2P */
+	/* Current P2P mode for P2P connection */
+	DHD_FLAG_P2P_GC_MODE				= (1 << (5)),
+	DHD_FLAG_P2P_GO_MODE				= (1 << (6)),
+	DHD_FLAG_MBSS_MODE				= (1 << (7)) /* MBSS in future */
+};
+
+#define MANUFACTRING_FW 	"WLTEST"
 
-#define DHD_SCAN_ACTIVE_TIME	 40 /* ms : Embedded default Active setting from DHD Driver */
-#define DHD_SCAN_PASSIVE_TIME	130 /* ms: Embedded default Passive setting from DHD Driver */
+/* Max sequential TX/RX Control timeouts to set HANG event */
+#ifndef MAX_CNTL_TX_TIMEOUT
+#define MAX_CNTL_TX_TIMEOUT 10
+#endif /* MAX_CNTL_TX_TIMEOUT */
+#ifndef MAX_CNTL_RX_TIMEOUT
+#define MAX_CNTL_RX_TIMEOUT 10
+#endif /* MAX_CNTL_RX_TIMEOUT */
+
+#define DHD_SCAN_ASSOC_ACTIVE_TIME	40 /* ms: Embedded default Active setting from DHD */
+#define DHD_SCAN_UNASSOC_ACTIVE_TIME 80 /* ms: Embedded def. Unassoc Active setting from DHD */
+#define DHD_SCAN_PASSIVE_TIME		130 /* ms: Embedded default Passive setting from DHD */
 
 #ifndef POWERUP_MAX_RETRY
-#define POWERUP_MAX_RETRY	(10) /* how many times we retry to power up the chip */
+#define POWERUP_MAX_RETRY	3 /* how many times we retry to power up the chip */
 #endif
 #ifndef POWERUP_WAIT_MS
-#define POWERUP_WAIT_MS		(2000) /* ms: time out in waiting wifi to come up */
+#define POWERUP_WAIT_MS		2000 /* ms: time out in waiting wifi to come up */
 #endif
 
 enum dhd_bus_wake_state {
@@ -107,15 +123,17 @@ enum dhd_bus_wake_state {
 	WAKE_LOCK_SOFTAP_SET,
 	WAKE_LOCK_SOFTAP_STOP,
 	WAKE_LOCK_SOFTAP_START,
-	WAKE_LOCK_SOFTAP_THREAD,
-	WAKE_LOCK_MAX
+	WAKE_LOCK_SOFTAP_THREAD
 };
 
 enum dhd_prealloc_index {
 	DHD_PREALLOC_PROT = 0,
 	DHD_PREALLOC_RXBUF,
 	DHD_PREALLOC_DATABUF,
-	DHD_PREALLOC_OSL_BUF
+	DHD_PREALLOC_OSL_BUF,
+#if defined(STATIC_WL_PRIV_STRUCT)
+	DHD_PREALLOC_WIPHY_ESCAN0 = 5,
+#endif /* STATIC_WL_PRIV_STRUCT */
 };
 
 typedef enum  {
@@ -157,6 +175,7 @@ typedef struct reorder_info {
 	uint8 pend_pkts;
 } reorder_info_t;
 
+
 /* Common structure for module and instance linkage */
 typedef struct dhd_pub {
 	/* Linkage ponters */
@@ -164,6 +183,7 @@ typedef struct dhd_pub {
 	struct dhd_bus *bus;	/* Bus module handle */
 	struct dhd_prot *prot;	/* Protocol module handle */
 	struct dhd_info  *info; /* Info module handle */
+	struct dhd_cmn	*cmn;	/* dhd_common module handle */
 
 	/* Internal dhd items */
 	bool up;		/* Driver up/down (to OS) */
@@ -216,8 +236,10 @@ typedef struct dhd_pub {
 	int pno_enable;                 /* pno status : "1" is pno enable */
 	int pno_suspend;		/* pno suspend status : "1" is pno suspended */
 #endif /* PNO_SUPPORT */
-	int dtim_skip;         /* dtim skip , default 0 means wake each dtim */
-
+	/* DTIM skip value, default 0(or 1) means wake each DTIM
+	 * 3 means skip 2 DTIMs and wake up 3rd DTIM(9th beacon when AP DTIM is 3)
+	 */
+	int suspend_bcn_li_dtim;         /* bcn_li_dtim value in suspend mode */
 #ifdef PKT_FILTER_SUPPORT
 	int early_suspended;	/* Early suspend status */
 	int dhcp_in_progress;	/* DHCP period */
@@ -237,9 +259,6 @@ typedef struct dhd_pub {
  */
 /* #define WL_ENABLE_P2P_IF		1 */
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_HAS_WAKELOCK)
-	struct wake_lock wakelock[WAKE_LOCK_MAX];
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined (CONFIG_HAS_WAKELOCK) */
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
 	struct mutex 	wl_start_stop_lock; /* lock/unlock for Android start/stop */
 	struct mutex 	wl_softap_lock;		 /* lock/unlock for any SoftAP/STA settings */
@@ -249,19 +268,48 @@ typedef struct dhd_pub {
 	uint16	maxdatablks;
 #endif /* WLBTAMP */
 #ifdef PROP_TXSTATUS
-	int   wlfc_enabled;
-	void* wlfc_state;
+	int	wlfc_enabled;
+	void*	wlfc_state;
+	int	ptx_opt_enabled;
+	bool    pending_tx_pkts;
+
+	/*
+	 * implement below functions in each platform if needed.
+	 */
+	/* platform specific function whether to skip flow control */
+	bool (*skip_fc)(void);
+	/* platform specific function for wlfc_enable and wlfc_deinit */
+	void (*plat_enable)(void *dhd);
+	void (*plat_deinit)(void *dhd);
 #endif
 	bool	dongle_isolation;
+	bool	dongle_trap_occured;	/* flag for sending HANG event to upper layer */
 	int   hang_was_sent;
 	int   rxcnt_timeout;		/* counter rxcnt timeout to send HANG */
 	int   txcnt_timeout;		/* counter txcnt timeout to send HANG */
+	bool hang_report;		/* enable hang report by default */
 #ifdef WLMEDIA_HTSF
 	uint8 htsfdlystat_sz; /* Size of delay stats, max 255B */
 #endif
 	struct reorder_info *reorder_bufs[WLHOST_REORDERDATA_MAXFLOWS];
+#ifdef RXFRAME_THREAD
+#define MAXSKBPEND 1024
+	void *skbbuf[MAXSKBPEND];
+	uint32 store_idx;
+	uint32 sent_idx;
+#endif /* RXFRAME_THREAD */
+#if defined(ARP_OFFLOAD_SUPPORT)
+	uint32 arp_version;
+#endif
+#if defined(BCMSUP_4WAY_HANDSHAKE) && defined(WLAN_AKM_SUITE_FT_8021X)
+	bool fw_4way_handshake;		/* Whether firmware will to do the 4way handshake. */
+#endif
 } dhd_pub_t;
 
+typedef struct dhd_cmn {
+	osl_t *osh;		/* OSL handle */
+	dhd_pub_t *dhd;
+} dhd_cmn_t;
 
 	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_PM_SLEEP)
 
@@ -271,7 +319,7 @@ typedef struct dhd_pub {
 			SMP_RD_BARRIER_DEPENDS(); \
 			while (dhd_mmc_suspend && retry++ != b) { \
 				SMP_RD_BARRIER_DEPENDS(); \
-				wait_event_interruptible_timeout(a, !dhd_mmc_suspend, HZ/100); \
+				wait_event_interruptible_timeout(a, !dhd_mmc_suspend, 1); \
 			} \
 		} 	while (0)
 	#define DHD_PM_RESUME_WAIT(a) 		_DHD_PM_RESUME_WAIT(a, 200)
@@ -283,7 +331,7 @@ typedef struct dhd_pub {
 	#define SPINWAIT_SLEEP(a, exp, us) do { \
 		uint countdown = (us) + 9999; \
 		while ((exp) && (countdown >= 10000)) { \
-			wait_event_interruptible_timeout(a, FALSE, HZ/100); \
+			wait_event_interruptible_timeout(a, FALSE, 1); \
 			countdown -= 10000; \
 		} \
 	} while (0)
@@ -319,7 +367,10 @@ void dhd_os_spin_unlock(dhd_pub_t *pub, unsigned long flags);
 extern int dhd_os_wake_lock(dhd_pub_t *pub);
 extern int dhd_os_wake_unlock(dhd_pub_t *pub);
 extern int dhd_os_wake_lock_timeout(dhd_pub_t *pub);
-extern int dhd_os_wake_lock_timeout_enable(dhd_pub_t *pub, int val);
+extern int dhd_os_wake_lock_rx_timeout_enable(dhd_pub_t *pub, int val);
+extern int dhd_os_wake_lock_ctrl_timeout_enable(dhd_pub_t *pub, int val);
+extern int dhd_os_wd_wake_lock(dhd_pub_t *pub);
+extern int dhd_os_wd_wake_unlock(dhd_pub_t *pub);
 
 inline static void MUTEX_LOCK_SOFTAP_SET_INIT(dhd_pub_t * dhdp)
 {
@@ -342,19 +393,31 @@ inline static void MUTEX_UNLOCK_SOFTAP_SET(dhd_pub_t * dhdp)
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
 }
 
-#define DHD_OS_WAKE_LOCK(pub) 			dhd_os_wake_lock(pub)
-#define DHD_OS_WAKE_UNLOCK(pub) 		dhd_os_wake_unlock(pub)
+#define DHD_OS_WAKE_LOCK(pub)			dhd_os_wake_lock(pub)
+#define DHD_OS_WAKE_UNLOCK(pub)		dhd_os_wake_unlock(pub)
+#define DHD_OS_WD_WAKE_LOCK(pub)		dhd_os_wd_wake_lock(pub)
+#define DHD_OS_WD_WAKE_UNLOCK(pub)		dhd_os_wd_wake_unlock(pub)
 #define DHD_OS_WAKE_LOCK_TIMEOUT(pub)		dhd_os_wake_lock_timeout(pub)
-#define DHD_OS_WAKE_LOCK_TIMEOUT_ENABLE(pub, val)	dhd_os_wake_lock_timeout_enable(pub, val)
+#define DHD_OS_WAKE_LOCK_RX_TIMEOUT_ENABLE(pub, val) \
+	dhd_os_wake_lock_rx_timeout_enable(pub, val)
+#define DHD_OS_WAKE_LOCK_CTRL_TIMEOUT_ENABLE(pub, val) \
+	dhd_os_wake_lock_ctrl_timeout_enable(pub, val)
 #define DHD_PACKET_TIMEOUT_MS	1000
 #define DHD_EVENT_TIMEOUT_MS	1500
 
+
 /* interface operations (register, remove) should be atomic, use this lock to prevent race
  * condition among wifi on/off and interface operation functions
  */
 void dhd_net_if_lock(struct net_device *dev);
 void dhd_net_if_unlock(struct net_device *dev);
 
+#if defined(MULTIPLE_SUPPLICANT)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1 && 1
+extern struct mutex _dhd_sdio_mutex_lock_;
+#endif
+#endif /* MULTIPLE_SUPPLICANT */
+
 typedef struct dhd_if_event {
 	uint8 ifidx;
 	uint8 action;
@@ -443,15 +506,23 @@ extern void dhd_os_sdunlock_txq(dhd_pub_t * pub);
 extern void dhd_os_sdlock_rxq(dhd_pub_t * pub);
 extern void dhd_os_sdunlock_rxq(dhd_pub_t * pub);
 extern void dhd_os_sdlock_sndup_rxq(dhd_pub_t * pub);
+
 extern void dhd_customer_gpio_wlan_ctrl(int onoff);
 extern int dhd_custom_get_mac_address(unsigned char *buf);
 extern void dhd_os_sdunlock_sndup_rxq(dhd_pub_t * pub);
 extern void dhd_os_sdlock_eventq(dhd_pub_t * pub);
 extern void dhd_os_sdunlock_eventq(dhd_pub_t * pub);
 extern bool dhd_os_check_hang(dhd_pub_t *dhdp, int ifidx, int ret);
+extern int dhd_os_send_hang_message(dhd_pub_t *dhdp);
+extern void dhd_set_version_info(dhd_pub_t *pub, char *fw);
+
+#if defined(KEEP_ALIVE)
+extern int dhd_keep_alive_onoff(dhd_pub_t *dhd);
+#endif /* KEEP_ALIVE */
 
 #ifdef PNO_SUPPORT
 extern int dhd_pno_enable(dhd_pub_t *dhd, int pfn_enabled);
+extern int dhd_pnoenable(dhd_pub_t *dhd, int pfn_enabled);
 extern int dhd_pno_clean(dhd_pub_t *dhd);
 extern int dhd_pno_set(dhd_pub_t *dhd, wlc_ssid_t* ssids_local, int nssid,
                        ushort  scan_fr, int pno_repeat, int pno_freq_expo_max);
@@ -461,24 +532,33 @@ extern int dhd_dev_pno_set(struct net_device *dev, wlc_ssid_t* ssids_local,
                            int nssid, ushort  scan_fr, int pno_repeat, int pno_freq_expo_max);
 extern int dhd_dev_pno_enable(struct net_device *dev,  int pfn_enabled);
 extern int dhd_dev_get_pno_status(struct net_device *dev);
+extern int dhd_pno_set_add(dhd_pub_t *dhd, wl_pfn_t *netinfo, int nssid,
+	ushort scan_fr, ushort slowscan_fr, uint8 pno_repeat, uint8 pno_freq_expo_max, int16 flags);
+extern int dhd_pno_cfg(dhd_pub_t *dhd, wl_pfn_cfg_t *pcfg);
+extern int dhd_pno_suspend(dhd_pub_t *dhd, int pfn_suspend);
 #endif /* PNO_SUPPORT */
 
+#ifdef PKT_FILTER_SUPPORT
 #define DHD_UNICAST_FILTER_NUM		0
 #define DHD_BROADCAST_FILTER_NUM	1
 #define DHD_MULTICAST4_FILTER_NUM	2
 #define DHD_MULTICAST6_FILTER_NUM	3
-extern int net_os_set_packet_filter(struct net_device *dev, int val);
+#define DHD_MDNS_FILTER_NUM		4
+extern int 	dhd_os_enable_packet_filter(dhd_pub_t *dhdp, int val);
+extern void dhd_enable_packet_filter(int value, dhd_pub_t *dhd);
+extern int net_os_enable_packet_filter(struct net_device *dev, int val);
 extern int net_os_rxfilter_add_remove(struct net_device *dev, int val, int num);
+#endif /* PKT_FILTER_SUPPORT */
 
-extern int dhd_get_dtim_skip(dhd_pub_t *dhd);
-extern bool dhd_check_ap_wfd_mode_set(dhd_pub_t *dhd);
+extern int dhd_get_suspend_bcn_li_dtim(dhd_pub_t *dhd);
+extern bool dhd_support_sta_mode(dhd_pub_t *dhd);
 
 #ifdef DHD_DEBUG
 extern int write_to_file(dhd_pub_t *dhd, uint8 *buf, int size);
 #endif /* DHD_DEBUG */
 #if defined(OOB_INTR_ONLY)
 extern int dhd_customer_oob_irq_map(unsigned long *irq_flags_ptr);
-#endif /* defined(OOB_INTR_ONLY) */
+#endif 
 extern void dhd_os_sdtxlock(dhd_pub_t * pub);
 extern void dhd_os_sdtxunlock(dhd_pub_t * pub);
 
@@ -495,6 +575,7 @@ extern int dhd_timeout_expired(dhd_timeout_t *tmo);
 extern int dhd_ifname2idx(struct dhd_info *dhd, char *name);
 extern int dhd_net2idx(struct dhd_info *dhd, struct net_device *net);
 extern struct net_device * dhd_idx2net(void *pub, int ifidx);
+extern int net_os_send_hang_message(struct net_device *dev);
 extern int wl_host_event(dhd_pub_t *dhd_pub, int *idx, void *pktdata,
                          wl_event_msg_t *, void **data_ptr);
 extern void wl_event_to_host_order(wl_event_msg_t * evt);
@@ -502,7 +583,6 @@ extern void wl_event_to_host_order(wl_event_msg_t * evt);
 extern int dhd_wl_ioctl(dhd_pub_t *dhd_pub, int ifindex, wl_ioctl_t *ioc, void *buf, int len);
 extern int dhd_wl_ioctl_cmd(dhd_pub_t *dhd_pub, int cmd, void *arg, int len, uint8 set,
                             int ifindex);
-
 extern void dhd_common_init(osl_t *osh);
 
 extern int dhd_do_driver_init(struct net_device *net);
@@ -529,18 +609,16 @@ extern uint dhd_bus_status(dhd_pub_t *dhdp);
 extern int  dhd_bus_start(dhd_pub_t *dhdp);
 extern int dhd_bus_membytes(dhd_pub_t *dhdp, bool set, uint32 address, uint8 *data, uint size);
 extern void dhd_print_buf(void *pbuf, int len, int bytes_per_line);
-extern bool dhd_is_associated(dhd_pub_t *dhd, void *bss_buf);
+extern bool dhd_is_associated(dhd_pub_t *dhd, void *bss_buf, int *retval);
 extern uint dhd_bus_chip_id(dhd_pub_t *dhdp);
+extern uint dhd_bus_chiprev_id(dhd_pub_t *dhdp);
+extern uint dhd_bus_chippkg_id(dhd_pub_t *dhdp);
 
 #if defined(KEEP_ALIVE)
 extern int dhd_keep_alive_onoff(dhd_pub_t *dhd);
 #endif /* KEEP_ALIVE */
 
-#ifdef ARP_OFFLOAD_SUPPORT
-extern void dhd_arp_offload_set(dhd_pub_t * dhd, int arp_mode);
-extern void dhd_arp_offload_enable(dhd_pub_t * dhd, int arp_enable);
-#endif /* ARP_OFFLOAD_SUPPORT */
-
+extern bool dhd_is_concurrent_mode(dhd_pub_t *dhd);
 
 typedef enum cust_gpio_modes {
 	WLAN_RESET_ON,
@@ -595,7 +673,11 @@ extern uint dhd_radio_up;
 
 /* Initial idletime ticks (may be -1 for immediate idle, 0 for no idle) */
 extern int dhd_idletime;
+#ifdef DHD_USE_IDLECOUNT
+#define DHD_IDLETIME_TICKS 5
+#else
 #define DHD_IDLETIME_TICKS 1
+#endif /* DHD_USE_IDLECOUNT */
 
 /* SDIO Drive Strength */
 extern uint dhd_sdiod_drive_strength;
@@ -603,9 +685,66 @@ extern uint dhd_sdiod_drive_strength;
 /* Override to force tx queueing all the time */
 extern uint dhd_force_tx_queueing;
 /* Default KEEP_ALIVE Period is 55 sec to prevent AP from sending Keep Alive probe frame */
-#define KEEP_ALIVE_PERIOD 55000
+#define DEFAULT_KEEP_ALIVE_VALUE 	55000 /* msec */
+#ifndef CUSTOM_KEEP_ALIVE_SETTING
+#define CUSTOM_KEEP_ALIVE_SETTING 	DEFAULT_KEEP_ALIVE_VALUE
+#endif /* DEFAULT_KEEP_ALIVE_VALUE */
+
 #define NULL_PKT_STR	"null_pkt"
 
+/* hooks for custom glom setting option via Makefile */
+#define DEFAULT_GLOM_VALUE 	-1
+#ifndef CUSTOM_GLOM_SETTING
+#define CUSTOM_GLOM_SETTING 	DEFAULT_GLOM_VALUE
+#endif
+#define WL_AUTO_ROAM_TRIGGER -75
+/* hooks for custom Roaming Trigger  setting via Makefile */
+#define DEFAULT_ROAM_TRIGGER_VALUE -75 /* dBm default roam trigger all band */
+#define DEFAULT_ROAM_TRIGGER_SETTING 	-1
+#ifndef CUSTOM_ROAM_TRIGGER_SETTING
+#define CUSTOM_ROAM_TRIGGER_SETTING 	DEFAULT_ROAM_TRIGGER_VALUE
+#endif
+
+/* hooks for custom Roaming Romaing  setting via Makefile */
+#define DEFAULT_ROAM_DELTA_VALUE  10 /* dBm default roam delta all band */
+#define DEFAULT_ROAM_DELTA_SETTING 	-1
+#ifndef CUSTOM_ROAM_DELTA_SETTING
+#define CUSTOM_ROAM_DELTA_SETTING 	DEFAULT_ROAM_DELTA_VALUE
+#endif
+
+/* hooks for custom PNO Event wake lock to guarantee enough time
+	for the Platform to detect Event before system suspended
+*/
+#define DEFAULT_PNO_EVENT_LOCK_xTIME 	2 	/* multiplay of DHD_PACKET_TIMEOUT_MS */
+#ifndef CUSTOM_PNO_EVENT_LOCK_xTIME
+#define CUSTOM_PNO_EVENT_LOCK_xTIME	 DEFAULT_PNO_EVENT_LOCK_xTIME
+#endif
+/* hooks for custom dhd_dpc_prio setting option via Makefile */
+#define DEFAULT_DHP_DPC_PRIO  1
+#ifndef CUSTOM_DPC_PRIO_SETTING
+#define CUSTOM_DPC_PRIO_SETTING 	DEFAULT_DHP_DPC_PRIO
+#endif
+
+#define DEFAULT_SUSPEND_BCN_LI_DTIM		3
+#ifndef CUSTOM_SUSPEND_BCN_LI_DTIM
+#define CUSTOM_SUSPEND_BCN_LI_DTIM		DEFAULT_SUSPEND_BCN_LI_DTIM
+#endif
+
+#ifdef RXFRAME_THREAD
+#ifndef CUSTOM_RXF_PRIO_SETTING
+#define CUSTOM_RXF_PRIO_SETTING 	(DEFAULT_DHP_DPC_PRIO + 1)
+#endif
+#endif /* RXFRAME_THREAD */
+
+#ifdef WLTDLS
+#ifndef CUSTOM_TDLS_IDLE_MODE_SETTING
+#define CUSTOM_TDLS_IDLE_MODE_SETTING  60000 /* 60sec to tear down TDLS of not active */
+#endif
+#endif /* WLTDLS */
+
+
+#define MAX_DTIM_SKIP_BEACON_ITERVAL	100 /* max allowed associated AP beacon for dtim skip */
+
 #ifdef SDTEST
 /* Echo packet generator (SDIO), pkts/s */
 extern uint dhd_pktgen;
@@ -621,6 +760,7 @@ extern uint dhd_pktgen_len;
 extern char fw_path[MOD_PARAM_PATHLEN];
 extern char nv_path[MOD_PARAM_PATHLEN];
 
+#define MOD_PARAM_INFOLEN	512
 #ifdef SOFTAP
 extern char fw_path2[MOD_PARAM_PATHLEN];
 #endif
@@ -628,6 +768,7 @@ extern char fw_path2[MOD_PARAM_PATHLEN];
 /* Flag to indicate if we should download firmware on driver load */
 extern uint dhd_download_fw_on_driverload;
 
+
 /* For supporting multiple interfaces */
 #define DHD_MAX_IFS	16
 #define DHD_DEL_IF	-0xe
@@ -637,6 +778,8 @@ extern uint dhd_download_fw_on_driverload;
 /* Please be mindful that total pkttag space is 32 octets only */
 typedef struct dhd_pkttag {
 	/*
+	b[14:13]  - encryption exemption
+	b[12 ] - 1 = event channel
 	b[11 ] - 1 = this packet was sent in response to one time packet request,
 	do not increment credit on status for this one. [WLFC_CTL_TYPE_MAC_REQUEST_PACKET].
 	b[10 ] - 1 = signal-only-packet to firmware [i.e. nothing to piggyback on]
@@ -687,6 +830,12 @@ typedef struct dhd_pkttag {
 #define DHD_PKTTAG_ONETIMEPKTRQST_MASK		0x1
 #define DHD_PKTTAG_ONETIMEPKTRQST_SHIFT		11
 
+#define DHD_PKTTAG_EVENT_MASK				0x1
+#define DHD_PKTTAG_EVENT_SHIFT				12
+
+#define DHD_PKTTAG_EXEMPT_MASK				0x3
+#define DHD_PKTTAG_EXEMPT_SHIFT				13
+
 #define DHD_PKTTAG_PKTDIR_MASK			0x1
 #define DHD_PKTTAG_PKTDIR_SHIFT			9
 
@@ -740,11 +889,28 @@ typedef struct dhd_pkttag {
 #define DHD_PKTTAG_ONETIMEPKTRQST(tag)	((((dhd_pkttag_t*)(tag))->if_flags >> \
 	DHD_PKTTAG_ONETIMEPKTRQST_SHIFT) & DHD_PKTTAG_ONETIMEPKTRQST_MASK)
 
+#define DHD_PKTTAG_SETEVENT(tag, event)	((dhd_pkttag_t*)(tag))->if_flags = \
+	(((dhd_pkttag_t*)(tag))->if_flags & \
+	~(DHD_PKTTAG_EVENT_MASK << DHD_PKTTAG_EVENT_SHIFT)) | \
+	(((event) & DHD_PKTTAG_EVENT_MASK) << DHD_PKTTAG_EVENT_SHIFT)
+#define DHD_PKTTAG_EVENT(tag)	((((dhd_pkttag_t*)(tag))->if_flags >> \
+	DHD_PKTTAG_EVENT_SHIFT) & DHD_PKTTAG_EVENT_MASK)
+
+#define DHD_PKTTAG_EXEMPT_SET(tag, value)	((dhd_pkttag_t*)(tag))->if_flags = \
+	(((dhd_pkttag_t*)(tag))->if_flags & \
+	~(DHD_PKTTAG_EXEMPT_MASK << DHD_PKTTAG_EXEMPT_SHIFT)) | \
+	(((value) & DHD_PKTTAG_EXEMPT_MASK) << DHD_PKTTAG_EXEMPT_SHIFT)
+#define DHD_PKTTAG_EXEMPT(tag)	((((dhd_pkttag_t*)(tag))->if_flags >> \
+	DHD_PKTTAG_EXEMPT_SHIFT) & DHD_PKTTAG_EXEMPT_MASK)
+
 #define DHD_PKTTAG_SETDSTN(tag, dstn_MAC_ea)	memcpy(((dhd_pkttag_t*)((tag)))->dstn_ether, \
 	(dstn_MAC_ea), ETHER_ADDR_LEN)
 #define DHD_PKTTAG_DSTN(tag)	((dhd_pkttag_t*)(tag))->dstn_ether
 
 typedef int (*f_commitpkt_t)(void* ctx, void* p);
+int dhd_os_wlfc_block(dhd_pub_t *pub);
+int dhd_os_wlfc_unblock(dhd_pub_t *pub);
+void dhd_schedule_tx(struct dhd_info *dhd);
 
 #ifdef PROP_TXSTATUS_DEBUG
 #define DHD_WLFC_CTRINC_MAC_CLOSE(entry)	do { (entry)->closed_ct++; } while (0)
@@ -779,11 +945,21 @@ extern int dhd_pno_suspend(dhd_pub_t *dhd, int pfn_suspend);
 #endif /* PNO_SUPPORT */
 #ifdef ARP_OFFLOAD_SUPPORT
 #define MAX_IPV4_ENTRIES	8
+void dhd_arp_offload_set(dhd_pub_t * dhd, int arp_mode);
+void dhd_arp_offload_enable(dhd_pub_t * dhd, int arp_enable);
+
 /* dhd_commn arp offload wrapers */
-void dhd_aoe_hostip_clr(dhd_pub_t *dhd);
-void dhd_aoe_arp_clr(dhd_pub_t *dhd);
-int dhd_arp_get_arp_hostip_table(dhd_pub_t *dhd, void *buf, int buflen);
-void dhd_arp_offload_add_ip(dhd_pub_t *dhd, uint32 ipaddr);
+void dhd_aoe_hostip_clr(dhd_pub_t *dhd, int idx);
+void dhd_aoe_arp_clr(dhd_pub_t *dhd, int idx);
+int dhd_arp_get_arp_hostip_table(dhd_pub_t *dhd, void *buf, int buflen, int idx);
+void dhd_arp_offload_add_ip(dhd_pub_t *dhd, uint32 ipaddr, int idx);
 #endif /* ARP_OFFLOAD_SUPPORT */
 
+/* ioctl processing for nl80211 */
+int dhd_ioctl_process(dhd_pub_t *pub, int ifidx, struct dhd_ioctl *ioc);
+
+void dhd_set_bus_state(void *bus, uint32 state);
+
+/* Remove proper pkts(either one no-frag pkt or whole fragmented pkts) */
+extern bool dhd_prec_drop_pkts(osl_t *osh, struct pktq *pq, int prec);
 #endif /* _dhd_h_ */
diff --git a/drivers/net/wireless/bcmdhd/dhd_bta.c b/drivers/net/wireless/bcmdhd/dhd_bta.c
old mode 100644
new mode 100755
index 15c605e..5b52a44
--- a/drivers/net/wireless/bcmdhd/dhd_bta.c
+++ b/drivers/net/wireless/bcmdhd/dhd_bta.c
@@ -1,27 +1,9 @@
 /*
  * BT-AMP support routines
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: dhd_bta.c 303834 2011-12-20 06:17:39Z $
+ * $Id: dhd_bta.c 379512 2013-01-17 22:49:08Z $
  */
 #ifndef WLBTAMP
 #error "WLBTAMP is not defined"
@@ -313,6 +295,9 @@ dhd_bta_doevt(dhd_pub_t *dhdp, void *data_buf, uint data_len)
 {
 	amp_hci_event_t *evt = (amp_hci_event_t *)data_buf;
 
+	ASSERT(dhdp);
+	ASSERT(evt);
+
 	switch (evt->ecode) {
 	case HCI_Command_Complete: {
 		cmd_complete_parms_t *parms = (cmd_complete_parms_t *)evt->parms;
diff --git a/drivers/net/wireless/bcmdhd/dhd_bta.h b/drivers/net/wireless/bcmdhd/dhd_bta.h
old mode 100644
new mode 100755
index 0337f15..4067fc3
--- a/drivers/net/wireless/bcmdhd/dhd_bta.h
+++ b/drivers/net/wireless/bcmdhd/dhd_bta.h
@@ -1,25 +1,7 @@
 /*
  * BT-AMP support routines
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * $Id: dhd_bta.h 291086 2011-10-21 01:17:24Z $
  */
diff --git a/drivers/net/wireless/bcmdhd/dhd_bus.h b/drivers/net/wireless/bcmdhd/dhd_bus.h
old mode 100644
new mode 100755
index 3626771..f87f80f
--- a/drivers/net/wireless/bcmdhd/dhd_bus.h
+++ b/drivers/net/wireless/bcmdhd/dhd_bus.h
@@ -4,27 +4,9 @@
  * Provides type definitions and function prototypes used to link the
  * DHD OS, bus, and protocol modules.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: dhd_bus.h 313456 2012-02-07 22:03:40Z $
+ * $Id: dhd_bus.h 335569 2012-05-29 12:04:43Z $
  */
 
 #ifndef _dhd_bus_h_
@@ -106,4 +88,6 @@ extern uint dhd_bus_hdrlen(struct dhd_bus *bus);
 extern int dhd_bus_reg_sdio_notify(void* semaphore);
 extern void dhd_bus_unreg_sdio_notify(void);
 
+extern void dhd_txglom_enable(dhd_pub_t *dhdp, bool enable);
+
 #endif /* _dhd_bus_h_ */
diff --git a/drivers/net/wireless/bcmdhd/dhd_cdc.c b/drivers/net/wireless/bcmdhd/dhd_cdc.c
old mode 100644
new mode 100755
index abd0873..d57cacb
--- a/drivers/net/wireless/bcmdhd/dhd_cdc.c
+++ b/drivers/net/wireless/bcmdhd/dhd_cdc.c
@@ -1,27 +1,9 @@
 /*
  * DHD Protocol Module for CDC and BDC.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: dhd_cdc.c 328424 2012-04-19 05:23:09Z $
+ * $Id: dhd_cdc.c 393623 2013-03-28 06:27:09Z $
  *
  * BDC is like CDC, except it includes a header for data packets to convey
  * packet priority over the bus, and flags (e.g. to indicate checksum status
@@ -49,7 +31,7 @@
 
 
 #define RETRIES 2		/* # of retries to retrieve matching ioctl response */
-#define BUS_HEADER_LEN	(16+DHD_SDALIGN)	/* Must be at least SDPCM_RESERVE
+#define BUS_HEADER_LEN	(24+DHD_SDALIGN)	/* Must be at least SDPCM_RESERVE
 				 * defined in dhd_sdio.c (amount of header tha might be added)
 				 * plus any space that might be needed for alignment padding.
 				 */
@@ -57,18 +39,6 @@
 				 * round off at the end of buffer
 				 */
 
-#define BUS_RETRIES 1	/* # of retries before aborting a bus tx operation */
-
-#ifdef PROP_TXSTATUS
-typedef struct dhd_wlfc_commit_info {
-	uint8					needs_hdr;
-	uint8					ac_fifo_credit_spent;
-	ewlfc_packet_state_t	pkt_type;
-	wlfc_mac_descriptor_t*	mac_entry;
-	void*					p;
-} dhd_wlfc_commit_info_t;
-#endif /* PROP_TXSTATUS */
-
 typedef struct dhd_prot {
 	uint16 reqid;
 	uint8 pending;
@@ -78,6 +48,8 @@ typedef struct dhd_prot {
 	unsigned char buf[WLC_IOCTL_MAXLEN + ROUND_UP_MARGIN];
 } dhd_prot_t;
 
+extern int module_remove;
+
 
 static int
 dhdcdc_msg(dhd_pub_t *dhd)
@@ -112,13 +84,19 @@ dhdcdc_cmplt(dhd_pub_t *dhd, uint32 id, uint32 len)
 	dhd_prot_t *prot = dhd->prot;
 
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
-
+#if 0
+	if ((dhd->busstate == DHD_BUS_DOWN) || dhd->hang_was_sent || module_remove) {
+		DHD_ERROR(("%s : bus is down. we have nothing to do\n", __FUNCTION__));
+		return -EIO;
+	}
+#endif
 	do {
 		ret = dhd_bus_rxctl(dhd->bus, (uchar*)&prot->msg, cdc_len);
 		if (ret < 0)
 			break;
 	} while (CDC_IOC_ID(ltoh32(prot->msg.flags)) != id);
 
+
 	return ret;
 }
 
@@ -195,7 +173,8 @@ retry:
 	{
 		if (ret < (int)len)
 			len = ret;
-		memcpy(buf, info, len);
+		//memcpy(buf, info, len);
+		memcpy(buf, (void*) prot->buf, len);
 	}
 
 	/* Check the ERROR flag */
@@ -210,6 +189,7 @@ done:
 	return ret;
 }
 
+
 static int
 dhdcdc_set_ioctl(dhd_pub_t *dhd, int ifidx, uint cmd, void *buf, uint len, uint8 action)
 {
@@ -233,6 +213,7 @@ dhdcdc_set_ioctl(dhd_pub_t *dhd, int ifidx, uint cmd, void *buf, uint len, uint8
 		return -EIO;
 	}
 
+
 	memset(msg, 0, sizeof(cdc_ioctl_t));
 
 	msg->cmd = htol32(cmd);
@@ -284,26 +265,12 @@ dhd_prot_ioctl(dhd_pub_t *dhd, int ifidx, wl_ioctl_t * ioc, void * buf, int len)
 	dhd_prot_t *prot = dhd->prot;
 	int ret = -1;
 	uint8 action;
-#if defined(NDIS630)
-	bool acquired = FALSE;
-#endif
 
 	if ((dhd->busstate == DHD_BUS_DOWN) || dhd->hang_was_sent) {
+//	if ((dhd->busstate == DHD_BUS_DOWN) || dhd->hang_was_sent || module_remove) {
 		DHD_ERROR(("%s : bus is down. we have nothing to do\n", __FUNCTION__));
 		goto done;
 	}
-#if defined(NDIS630)
-	if (dhd_os_proto_block(dhd))
-	{
-		acquired = TRUE;
-	}
-	else
-	{
-		/* attempt to acquire protocol mutex timed out. */
-		ret = -1;
-		return ret;
-	}
-#endif /* NDIS630 */
 
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
@@ -354,10 +321,7 @@ dhd_prot_ioctl(dhd_pub_t *dhd, int ifidx, wl_ioctl_t * ioc, void * buf, int len)
 	prot->pending = FALSE;
 
 done:
-#if defined(NDIS630)
-	if (acquired)
-	   dhd_os_proto_unblock(dhd);
-#endif
+
 	return ret;
 }
 
@@ -368,2225 +332,248 @@ dhd_prot_iovar_op(dhd_pub_t *dhdp, const char *name,
 	return BCME_UNSUPPORTED;
 }
 
+void
+dhd_prot_dump(dhd_pub_t *dhdp, struct bcmstrbuf *strbuf)
+{
+	bcm_bprintf(strbuf, "Protocol CDC: reqid %d\n", dhdp->prot->reqid);
 #ifdef PROP_TXSTATUS
+	if (dhdp->wlfc_state)
+		dhd_wlfc_dump(dhdp, strbuf);
+#endif
+}
+
+/*	The FreeBSD PKTPUSH could change the packet buf pinter
+	so we need to make it changable
+*/
+#define PKTBUF pktbuf
 void
-dhd_wlfc_dump(dhd_pub_t *dhdp, struct bcmstrbuf *strbuf)
+dhd_prot_hdrpush(dhd_pub_t *dhd, int ifidx, void *PKTBUF)
 {
-	int i;
-	uint8* ea;
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhdp->wlfc_state;
-	wlfc_hanger_t* h;
-	wlfc_mac_descriptor_t* mac_table;
-	wlfc_mac_descriptor_t* interfaces;
-	char* iftypes[] = {"STA", "AP", "WDS", "p2pGO", "p2pCL"};
-
-	if (wlfc == NULL) {
-		bcm_bprintf(strbuf, "wlfc not initialized yet\n");
-		return;
-	}
-	h = (wlfc_hanger_t*)wlfc->hanger;
-	if (h == NULL) {
-		bcm_bprintf(strbuf, "wlfc-hanger not initialized yet\n");
-	}
+#ifdef BDC
+	struct bdc_header *h;
+#endif /* BDC */
 
-	mac_table = wlfc->destination_entries.nodes;
-	interfaces = wlfc->destination_entries.interfaces;
-	bcm_bprintf(strbuf, "---- wlfc stats ----\n");
-	if (h) {
-		bcm_bprintf(strbuf, "wlfc hanger (pushed,popped,f_push,"
-			"f_pop,f_slot, pending) = (%d,%d,%d,%d,%d,%d)\n",
-			h->pushed,
-			h->popped,
-			h->failed_to_push,
-			h->failed_to_pop,
-			h->failed_slotfind,
-			(h->pushed - h->popped));
-	}
+	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
-	bcm_bprintf(strbuf, "wlfc fail(tlv,credit_rqst,mac_update,psmode_update), "
-		"(dq_full,sendq_full, rollback_fail) = (%d,%d,%d,%d), (%d,%d,%d)\n",
-		wlfc->stats.tlv_parse_failed,
-		wlfc->stats.credit_request_failed,
-		wlfc->stats.mac_update_failed,
-		wlfc->stats.psmode_update_failed,
-		wlfc->stats.delayq_full_error,
-		wlfc->stats.sendq_full_error,
-		wlfc->stats.rollback_failed);
-
-	bcm_bprintf(strbuf, "SENDQ (len,credit,sent) "
-		"(AC0[%d,%d,%d],AC1[%d,%d,%d],AC2[%d,%d,%d],AC3[%d,%d,%d],BC_MC[%d,%d,%d])\n",
-		wlfc->SENDQ.q[0].len, wlfc->FIFO_credit[0], wlfc->stats.sendq_pkts[0],
-		wlfc->SENDQ.q[1].len, wlfc->FIFO_credit[1], wlfc->stats.sendq_pkts[1],
-		wlfc->SENDQ.q[2].len, wlfc->FIFO_credit[2], wlfc->stats.sendq_pkts[2],
-		wlfc->SENDQ.q[3].len, wlfc->FIFO_credit[3], wlfc->stats.sendq_pkts[3],
-		wlfc->SENDQ.q[4].len, wlfc->FIFO_credit[4], wlfc->stats.sendq_pkts[4]);
-
-#ifdef PROP_TXSTATUS_DEBUG
-	bcm_bprintf(strbuf, "SENDQ dropped: AC[0-3]:(%d,%d,%d,%d), (bcmc,atim):(%d,%d)\n",
-		wlfc->stats.dropped_qfull[0], wlfc->stats.dropped_qfull[1],
-		wlfc->stats.dropped_qfull[2], wlfc->stats.dropped_qfull[3],
-		wlfc->stats.dropped_qfull[4], wlfc->stats.dropped_qfull[5]);
-#endif
+#ifdef BDC
+	/* Push BDC header used to convey priority for buses that don't */
 
-	bcm_bprintf(strbuf, "\n");
-	for (i = 0; i < WLFC_MAX_IFNUM; i++) {
-		if (interfaces[i].occupied) {
-			char* iftype_desc;
+	PKTPUSH(dhd->osh, PKTBUF, BDC_HEADER_LEN);
+
+	h = (struct bdc_header *)PKTDATA(dhd->osh, PKTBUF);
+
+	h->flags = (BDC_PROTO_VER << BDC_FLAG_VER_SHIFT);
+	if (PKTSUMNEEDED(PKTBUF))
+		h->flags |= BDC_FLAG_SUM_NEEDED;
 
-			if (interfaces[i].iftype > WLC_E_IF_ROLE_P2P_CLIENT)
-				iftype_desc = "<Unknown";
-			else
-				iftype_desc = iftypes[interfaces[i].iftype];
-
-			ea = interfaces[i].ea;
-			bcm_bprintf(strbuf, "INTERFACE[%d].ea = "
-				"[%02x:%02x:%02x:%02x:%02x:%02x], if:%d, type: %s"
-				"netif_flow_control:%s\n", i,
-				ea[0], ea[1], ea[2], ea[3], ea[4], ea[5],
-				interfaces[i].interface_id,
-				iftype_desc, ((wlfc->hostif_flow_state[i] == OFF)
-				? " OFF":" ON"));
-
-			bcm_bprintf(strbuf, "INTERFACE[%d].DELAYQ(len,state,credit)"
-				"= (%d,%s,%d)\n",
-				i,
-				interfaces[i].psq.len,
-				((interfaces[i].state ==
-				WLFC_STATE_OPEN) ? " OPEN":"CLOSE"),
-				interfaces[i].requested_credit);
-
-			bcm_bprintf(strbuf, "INTERFACE[%d].DELAYQ"
-				"(sup,ac0),(sup,ac1),(sup,ac2),(sup,ac3) = "
-				"(%d,%d),(%d,%d),(%d,%d),(%d,%d)\n",
-				i,
-				interfaces[i].psq.q[0].len,
-				interfaces[i].psq.q[1].len,
-				interfaces[i].psq.q[2].len,
-				interfaces[i].psq.q[3].len,
-				interfaces[i].psq.q[4].len,
-				interfaces[i].psq.q[5].len,
-				interfaces[i].psq.q[6].len,
-				interfaces[i].psq.q[7].len);
-		}
-	}
 
-	bcm_bprintf(strbuf, "\n");
-	for (i = 0; i < WLFC_MAC_DESC_TABLE_SIZE; i++) {
-		if (mac_table[i].occupied) {
-			ea = mac_table[i].ea;
-			bcm_bprintf(strbuf, "MAC_table[%d].ea = "
-				"[%02x:%02x:%02x:%02x:%02x:%02x], if:%d \n", i,
-				ea[0], ea[1], ea[2], ea[3], ea[4], ea[5],
-				mac_table[i].interface_id);
-
-			bcm_bprintf(strbuf, "MAC_table[%d].DELAYQ(len,state,credit)"
-				"= (%d,%s,%d)\n",
-				i,
-				mac_table[i].psq.len,
-				((mac_table[i].state ==
-				WLFC_STATE_OPEN) ? " OPEN":"CLOSE"),
-				mac_table[i].requested_credit);
-#ifdef PROP_TXSTATUS_DEBUG
-			bcm_bprintf(strbuf, "MAC_table[%d]: (opened, closed) = (%d, %d)\n",
-				i, mac_table[i].opened_ct, mac_table[i].closed_ct);
+	h->priority = (PKTPRIO(PKTBUF) & BDC_PRIORITY_MASK);
+	h->flags2 = 0;
+	h->dataOffset = 0;
+#endif /* BDC */
+	BDC_SET_IF_IDX(h, ifidx);
+}
+#undef PKTBUF	/* Only defined in the above routine */
+
+int
+dhd_prot_hdrpull(dhd_pub_t *dhd, int *ifidx, void *pktbuf, uchar *reorder_buf_info,
+	uint *reorder_info_len)
+{
+#ifdef BDC
+	struct bdc_header *h;
 #endif
-			bcm_bprintf(strbuf, "MAC_table[%d].DELAYQ"
-				"(sup,ac0),(sup,ac1),(sup,ac2),(sup,ac3) = "
-				"(%d,%d),(%d,%d),(%d,%d),(%d,%d)\n",
-				i,
-				mac_table[i].psq.q[0].len,
-				mac_table[i].psq.q[1].len,
-				mac_table[i].psq.q[2].len,
-				mac_table[i].psq.q[3].len,
-				mac_table[i].psq.q[4].len,
-				mac_table[i].psq.q[5].len,
-				mac_table[i].psq.q[6].len,
-				mac_table[i].psq.q[7].len);
-		}
-	}
+	uint8 data_offset = 0;
 
-#ifdef PROP_TXSTATUS_DEBUG
-	{
-		int avg;
-		int moving_avg = 0;
-		int moving_samples;
-
-		if (wlfc->stats.latency_sample_count) {
-			moving_samples = sizeof(wlfc->stats.deltas)/sizeof(uint32);
-
-			for (i = 0; i < moving_samples; i++)
-				moving_avg += wlfc->stats.deltas[i];
-			moving_avg /= moving_samples;
-
-			avg = (100 * wlfc->stats.total_status_latency) /
-				wlfc->stats.latency_sample_count;
-			bcm_bprintf(strbuf, "txstatus latency (average, last, moving[%d]) = "
-				"(%d.%d, %03d, %03d)\n",
-				moving_samples, avg/100, (avg - (avg/100)*100),
-				wlfc->stats.latency_most_recent,
-				moving_avg);
-		}
-	}
+	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
-	bcm_bprintf(strbuf, "wlfc- fifo[0-5] credit stats: sent = (%d,%d,%d,%d,%d,%d), "
-		"back = (%d,%d,%d,%d,%d,%d)\n",
-		wlfc->stats.fifo_credits_sent[0],
-		wlfc->stats.fifo_credits_sent[1],
-		wlfc->stats.fifo_credits_sent[2],
-		wlfc->stats.fifo_credits_sent[3],
-		wlfc->stats.fifo_credits_sent[4],
-		wlfc->stats.fifo_credits_sent[5],
-
-		wlfc->stats.fifo_credits_back[0],
-		wlfc->stats.fifo_credits_back[1],
-		wlfc->stats.fifo_credits_back[2],
-		wlfc->stats.fifo_credits_back[3],
-		wlfc->stats.fifo_credits_back[4],
-		wlfc->stats.fifo_credits_back[5]);
-	{
-		uint32 fifo_cr_sent = 0;
-		uint32 fifo_cr_acked = 0;
-		uint32 request_cr_sent = 0;
-		uint32 request_cr_ack = 0;
-		uint32 bc_mc_cr_ack = 0;
-
-		for (i = 0; i < sizeof(wlfc->stats.fifo_credits_sent)/sizeof(uint32); i++) {
-			fifo_cr_sent += wlfc->stats.fifo_credits_sent[i];
-		}
+#ifdef BDC
+	if (reorder_info_len)
+		*reorder_info_len = 0;
+	/* Pop BDC header used to convey priority for buses that don't */
 
-		for (i = 0; i < sizeof(wlfc->stats.fifo_credits_back)/sizeof(uint32); i++) {
-			fifo_cr_acked += wlfc->stats.fifo_credits_back[i];
-		}
+	if (PKTLEN(dhd->osh, pktbuf) < BDC_HEADER_LEN) {
+		DHD_ERROR(("%s: rx data too short (%d < %d)\n", __FUNCTION__,
+		           PKTLEN(dhd->osh, pktbuf), BDC_HEADER_LEN));
+		return BCME_ERROR;
+	}
 
-		for (i = 0; i < WLFC_MAC_DESC_TABLE_SIZE; i++) {
-			if (wlfc->destination_entries.nodes[i].occupied) {
-				request_cr_sent +=
-					wlfc->destination_entries.nodes[i].dstncredit_sent_packets;
-			}
-		}
-		for (i = 0; i < WLFC_MAX_IFNUM; i++) {
-			if (wlfc->destination_entries.interfaces[i].occupied) {
-				request_cr_sent +=
-				wlfc->destination_entries.interfaces[i].dstncredit_sent_packets;
-			}
-		}
-		for (i = 0; i < WLFC_MAC_DESC_TABLE_SIZE; i++) {
-			if (wlfc->destination_entries.nodes[i].occupied) {
-				request_cr_ack +=
-					wlfc->destination_entries.nodes[i].dstncredit_acks;
-			}
-		}
-		for (i = 0; i < WLFC_MAX_IFNUM; i++) {
-			if (wlfc->destination_entries.interfaces[i].occupied) {
-				request_cr_ack +=
-					wlfc->destination_entries.interfaces[i].dstncredit_acks;
-			}
-		}
-		bcm_bprintf(strbuf, "wlfc- (sent, status) => pq(%d,%d), vq(%d,%d),"
-			"other:%d, bc_mc:%d, signal-only, (sent,freed): (%d,%d)",
-			fifo_cr_sent, fifo_cr_acked,
-			request_cr_sent, request_cr_ack,
-			wlfc->destination_entries.other.dstncredit_acks,
-			bc_mc_cr_ack,
-			wlfc->stats.signal_only_pkts_sent, wlfc->stats.signal_only_pkts_freed);
+	h = (struct bdc_header *)PKTDATA(dhd->osh, pktbuf);
+
+	if (!ifidx) {
+		/* for tx packet, skip the analysis */
+		data_offset = h->dataOffset;
+		PKTPULL(dhd->osh, pktbuf, BDC_HEADER_LEN);
+		goto exit;
 	}
-#endif /* PROP_TXSTATUS_DEBUG */
-	bcm_bprintf(strbuf, "\n");
-	bcm_bprintf(strbuf, "wlfc- pkt((in,2bus,txstats,hdrpull),(dropped,hdr_only,wlc_tossed)"
-		"(freed,free_err,rollback)) = "
-		"((%d,%d,%d,%d),(%d,%d,%d),(%d,%d,%d))\n",
-		wlfc->stats.pktin,
-		wlfc->stats.pkt2bus,
-		wlfc->stats.txstatus_in,
-		wlfc->stats.dhd_hdrpulls,
-
-		wlfc->stats.pktdropped,
-		wlfc->stats.wlfc_header_only_pkt,
-		wlfc->stats.wlc_tossed_pkts,
-
-		wlfc->stats.pkt_freed,
-		wlfc->stats.pkt_free_err, wlfc->stats.rollback);
-
-	bcm_bprintf(strbuf, "wlfc- suppress((d11,wlc,err),enq(d11,wl,hq,mac?),retx(d11,wlc,hq)) = "
-		"((%d,%d,%d),(%d,%d,%d,%d),(%d,%d,%d))\n",
-
-		wlfc->stats.d11_suppress,
-		wlfc->stats.wl_suppress,
-		wlfc->stats.bad_suppress,
-
-		wlfc->stats.psq_d11sup_enq,
-		wlfc->stats.psq_wlsup_enq,
-		wlfc->stats.psq_hostq_enq,
-		wlfc->stats.mac_handle_notfound,
-
-		wlfc->stats.psq_d11sup_retx,
-		wlfc->stats.psq_wlsup_retx,
-		wlfc->stats.psq_hostq_retx);
-	return;
-}
 
-/* Create a place to store all packet pointers submitted to the firmware until
-	a status comes back, suppress or otherwise.
+	if ((*ifidx = BDC_GET_IF_IDX(h)) >= DHD_MAX_IFS) {
+		DHD_ERROR(("%s: rx data ifnum out of range (%d)\n",
+		           __FUNCTION__, *ifidx));
+		return BCME_ERROR;
+	}
 
-	hang-er: noun, a contrivance on which things are hung, as a hook.
-*/
-static void*
-dhd_wlfc_hanger_create(osl_t *osh, int max_items)
-{
-	int i;
-	wlfc_hanger_t* hanger;
+	if (((h->flags & BDC_FLAG_VER_MASK) >> BDC_FLAG_VER_SHIFT) != BDC_PROTO_VER) {
+		DHD_ERROR(("%s: non-BDC packet received, flags = 0x%x\n",
+		           dhd_ifname(dhd, *ifidx), h->flags));
+		if (((h->flags & BDC_FLAG_VER_MASK) >> BDC_FLAG_VER_SHIFT) == BDC_PROTO_VER_1)
+			h->dataOffset = 0;
+		else
+		return BCME_ERROR;
+	}
 
-	/* allow only up to a specific size for now */
-	ASSERT(max_items == WLFC_HANGER_MAXITEMS);
+	if (h->flags & BDC_FLAG_SUM_GOOD) {
+		DHD_INFO(("%s: BDC packet received with good rx-csum, flags 0x%x\n",
+		          dhd_ifname(dhd, *ifidx), h->flags));
+		PKTSETSUMGOOD(pktbuf, TRUE);
+	}
 
-	if ((hanger = (wlfc_hanger_t*)MALLOC(osh, WLFC_HANGER_SIZE(max_items))) == NULL)
-		return NULL;
+	PKTSETPRIO(pktbuf, (h->priority & BDC_PRIORITY_MASK));
+	data_offset = h->dataOffset;
+	PKTPULL(dhd->osh, pktbuf, BDC_HEADER_LEN);
+#endif /* BDC */
 
-	memset(hanger, 0, WLFC_HANGER_SIZE(max_items));
-	hanger->max_items = max_items;
+#ifdef PROP_TXSTATUS
+	dhd_os_wlfc_block(dhd);
+	if (dhd->wlfc_state &&
+		((athost_wl_status_info_t*)dhd->wlfc_state)->proptxstatus_mode
+		!= WLFC_FCMODE_NONE &&
+		(!DHD_PKTTAG_PKTDIR(PKTTAG(pktbuf)))) {
+		/*
+		- parse txstatus only for packets that came from the firmware
+		*/
+		dhd_wlfc_parse_header_info(dhd, pktbuf, (data_offset << 2),
+			reorder_buf_info, reorder_info_len);
+		((athost_wl_status_info_t*)dhd->wlfc_state)->stats.dhd_hdrpulls++;
 
-	for (i = 0; i < hanger->max_items; i++) {
-		hanger->items[i].state = WLFC_HANGER_ITEM_STATE_FREE;
 	}
-	return hanger;
+	dhd_os_wlfc_unblock(dhd);
+#endif /* PROP_TXSTATUS */
+
+exit:
+		PKTPULL(dhd->osh, pktbuf, (data_offset << 2));
+	return 0;
 }
 
-static int
-dhd_wlfc_hanger_delete(osl_t *osh, void* hanger)
+#if defined(PROP_TXSTATUS)
+void
+dhd_wlfc_trigger_pktcommit(dhd_pub_t *dhd)
 {
-	wlfc_hanger_t* h = (wlfc_hanger_t*)hanger;
-
-	if (h) {
-		MFREE(osh, h, WLFC_HANGER_SIZE(h->max_items));
-		return BCME_OK;
+	dhd_os_wlfc_block(dhd);
+	if (dhd->wlfc_state &&
+		(((athost_wl_status_info_t*)dhd->wlfc_state)->proptxstatus_mode
+		!= WLFC_FCMODE_NONE)) {
+		dhd_wlfc_commit_packets(dhd->wlfc_state, (f_commitpkt_t)dhd_bus_txdata,
+			(void *)dhd->bus, NULL);
 	}
-	return BCME_BADARG;
+	dhd_os_wlfc_unblock(dhd);
 }
+#endif
 
-static uint16
-dhd_wlfc_hanger_get_free_slot(void* hanger)
+
+int
+dhd_prot_attach(dhd_pub_t *dhd)
 {
-	int i;
-	wlfc_hanger_t* h = (wlfc_hanger_t*)hanger;
+	dhd_prot_t *cdc;
 
-	if (h) {
-		for (i = 0; i < h->max_items; i++) {
-			if (h->items[i].state == WLFC_HANGER_ITEM_STATE_FREE)
-				return (uint16)i;
+	if (!(cdc = (dhd_prot_t *)DHD_OS_PREALLOC(dhd->osh, DHD_PREALLOC_PROT,
+		sizeof(dhd_prot_t)))) {
+			DHD_ERROR(("%s: kmalloc failed\n", __FUNCTION__));
+			goto fail;
 		}
-		h->failed_slotfind++;
+	memset(cdc, 0, sizeof(dhd_prot_t));
+
+	/* ensure that the msg buf directly follows the cdc msg struct */
+	if ((uintptr)(&cdc->msg + 1) != (uintptr)cdc->buf) {
+		DHD_ERROR(("dhd_prot_t is not correctly defined\n"));
+		goto fail;
 	}
-	return WLFC_HANGER_MAXITEMS;
+
+	dhd->prot = cdc;
+#ifdef BDC
+	dhd->hdrlen += BDC_HEADER_LEN;
+#endif
+	dhd->maxctl = WLC_IOCTL_MAXLEN + sizeof(cdc_ioctl_t) + ROUND_UP_MARGIN;
+	return 0;
+
+fail:
+#ifndef CONFIG_DHD_USE_STATIC_BUF
+	if (cdc != NULL)
+		MFREE(dhd->osh, cdc, sizeof(dhd_prot_t));
+#endif /* CONFIG_DHD_USE_STATIC_BUF */
+	return BCME_NOMEM;
 }
 
-static int
-dhd_wlfc_hanger_pushpkt(void* hanger, void* pkt, uint32 slot_id)
+/* ~NOTE~ What if another thread is waiting on the semaphore?  Holding it? */
+void
+dhd_prot_detach(dhd_pub_t *dhd)
 {
-	int rc = BCME_OK;
-	wlfc_hanger_t* h = (wlfc_hanger_t*)hanger;
-
-	if (h && (slot_id < WLFC_HANGER_MAXITEMS)) {
-		if (h->items[slot_id].state == WLFC_HANGER_ITEM_STATE_FREE) {
-			h->items[slot_id].state = WLFC_HANGER_ITEM_STATE_INUSE;
-			h->items[slot_id].pkt = pkt;
-			h->items[slot_id].identifier = slot_id;
-			h->pushed++;
-		}
-		else {
-			h->failed_to_push++;
-			rc = BCME_NOTFOUND;
-		}
-	}
-	else
-		rc = BCME_BADARG;
-	return rc;
+#ifdef PROP_TXSTATUS
+	dhd_wlfc_deinit(dhd);
+#endif
+#ifndef CONFIG_DHD_USE_STATIC_BUF
+	MFREE(dhd->osh, dhd->prot, sizeof(dhd_prot_t));
+#endif /* CONFIG_DHD_USE_STATIC_BUF */
+	dhd->prot = NULL;
 }
 
-static int
-dhd_wlfc_hanger_poppkt(void* hanger, uint32 slot_id, void** pktout, int remove_from_hanger)
+void
+dhd_prot_dstats(dhd_pub_t *dhd)
 {
-	int rc = BCME_OK;
-	wlfc_hanger_t* h = (wlfc_hanger_t*)hanger;
-
-	/* this packet was not pushed at the time it went to the firmware */
-	if (slot_id == WLFC_HANGER_MAXITEMS)
-		return BCME_NOTFOUND;
-
-	if (h) {
-		if (h->items[slot_id].state == WLFC_HANGER_ITEM_STATE_INUSE) {
-			*pktout = h->items[slot_id].pkt;
-			if (remove_from_hanger) {
-				h->items[slot_id].state =
-					WLFC_HANGER_ITEM_STATE_FREE;
-				h->items[slot_id].pkt = NULL;
-				h->items[slot_id].identifier = 0;
-				h->popped++;
-			}
-		}
-		else {
-			h->failed_to_pop++;
-			rc = BCME_NOTFOUND;
-		}
-	}
-	else
-		rc = BCME_BADARG;
-	return rc;
+	/* No stats from dongle added yet, copy bus stats */
+	dhd->dstats.tx_packets = dhd->tx_packets;
+	dhd->dstats.tx_errors = dhd->tx_errors;
+	dhd->dstats.rx_packets = dhd->rx_packets;
+	dhd->dstats.rx_errors = dhd->rx_errors;
+	dhd->dstats.rx_dropped = dhd->rx_dropped;
+	dhd->dstats.multicast = dhd->rx_multicast;
+	return;
 }
 
-static int
-_dhd_wlfc_pushheader(athost_wl_status_info_t* ctx, void* p, bool tim_signal,
-	uint8 tim_bmp, uint8 mac_handle, uint32 htodtag)
+int
+dhd_prot_init(dhd_pub_t *dhd)
 {
-	uint32 wl_pktinfo = 0;
-	uint8* wlh;
-	uint8 dataOffset;
-	uint8 fillers;
-	uint8 tim_signal_len = 0;
-
-	struct bdc_header *h;
-
-	if (tim_signal) {
-		tim_signal_len = 1 + 1 + WLFC_CTL_VALUE_LEN_PENDING_TRAFFIC_BMP;
-	}
-
-	/* +2 is for Type[1] and Len[1] in TLV, plus TIM signal */
-	dataOffset = WLFC_CTL_VALUE_LEN_PKTTAG + 2 + tim_signal_len;
-	fillers = ROUNDUP(dataOffset, 4) - dataOffset;
-	dataOffset += fillers;
+	int ret = 0;
+	wlc_rev_info_t revinfo;
+	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
-	PKTPUSH(ctx->osh, p, dataOffset);
-	wlh = (uint8*) PKTDATA(ctx->osh, p);
 
-	wl_pktinfo = htol32(htodtag);
+	/* Get the device rev info */
+	memset(&revinfo, 0, sizeof(revinfo));
+	ret = dhd_wl_ioctl_cmd(dhd, WLC_GET_REVINFO, &revinfo, sizeof(revinfo), FALSE, 0);
+	if (ret < 0)
+		goto done;
 
-	wlh[0] = WLFC_CTL_TYPE_PKTTAG;
-	wlh[1] = WLFC_CTL_VALUE_LEN_PKTTAG;
-	memcpy(&wlh[2], &wl_pktinfo, sizeof(uint32));
 
-	if (tim_signal_len) {
-		wlh[dataOffset - fillers - tim_signal_len ] =
-			WLFC_CTL_TYPE_PENDING_TRAFFIC_BMP;
-		wlh[dataOffset - fillers - tim_signal_len + 1] =
-			WLFC_CTL_VALUE_LEN_PENDING_TRAFFIC_BMP;
-		wlh[dataOffset - fillers - tim_signal_len + 2] = mac_handle;
-		wlh[dataOffset - fillers - tim_signal_len + 3] = tim_bmp;
-	}
-	if (fillers)
-		memset(&wlh[dataOffset - fillers], WLFC_CTL_TYPE_FILLER, fillers);
+#if defined(WL_CFG80211)
+	if (dhd_download_fw_on_driverload)
+#endif /* defined(WL_CFG80211) */
+		ret = dhd_preinit_ioctls(dhd);
 
-	PKTPUSH(ctx->osh, p, BDC_HEADER_LEN);
-	h = (struct bdc_header *)PKTDATA(ctx->osh, p);
-	h->flags = (BDC_PROTO_VER << BDC_FLAG_VER_SHIFT);
-	if (PKTSUMNEEDED(p))
-		h->flags |= BDC_FLAG_SUM_NEEDED;
+#ifdef PROP_TXSTATUS
+	ret = dhd_wlfc_init(dhd);
+#endif
 
+	/* Always assumes wl for now */
+	dhd->iswl = TRUE;
 
-	h->priority = (PKTPRIO(p) & BDC_PRIORITY_MASK);
-	h->flags2 = 0;
-	h->dataOffset = dataOffset >> 2;
-	BDC_SET_IF_IDX(h, DHD_PKTTAG_IF(PKTTAG(p)));
-	return BCME_OK;
+done:
+	return ret;
 }
 
-static int
-_dhd_wlfc_pullheader(athost_wl_status_info_t* ctx, void* pktbuf)
+void
+dhd_prot_stop(dhd_pub_t *dhd)
 {
-	struct bdc_header *h;
-
-	if (PKTLEN(ctx->osh, pktbuf) < BDC_HEADER_LEN) {
-		WLFC_DBGMESG(("%s: rx data too short (%d < %d)\n", __FUNCTION__,
-		           PKTLEN(ctx->osh, pktbuf), BDC_HEADER_LEN));
-		return BCME_ERROR;
-	}
-	h = (struct bdc_header *)PKTDATA(ctx->osh, pktbuf);
-
-	/* pull BDC header */
-	PKTPULL(ctx->osh, pktbuf, BDC_HEADER_LEN);
-	/* pull wl-header */
-	PKTPULL(ctx->osh, pktbuf, (h->dataOffset << 2));
-	return BCME_OK;
+	/* Nothing to do for CDC */
 }
 
-static wlfc_mac_descriptor_t*
-_dhd_wlfc_find_table_entry(athost_wl_status_info_t* ctx, void* p)
-{
-	int i;
-	wlfc_mac_descriptor_t* table = ctx->destination_entries.nodes;
-	uint8 ifid = DHD_PKTTAG_IF(PKTTAG(p));
-	uint8* dstn = DHD_PKTTAG_DSTN(PKTTAG(p));
-
-	if (((ctx->destination_entries.interfaces[ifid].iftype == WLC_E_IF_ROLE_STA) ||
-		ETHER_ISMULTI(dstn) ||
-		(ctx->destination_entries.interfaces[ifid].iftype == WLC_E_IF_ROLE_P2P_CLIENT)) &&
-		(ctx->destination_entries.interfaces[ifid].occupied)) {
-			return &ctx->destination_entries.interfaces[ifid];
-	}
-
-	for (i = 0; i < WLFC_MAC_DESC_TABLE_SIZE; i++) {
-		if (table[i].occupied) {
-			if (table[i].interface_id == ifid) {
-				if (!memcmp(table[i].ea, dstn, ETHER_ADDR_LEN))
-					return &table[i];
-			}
-		}
-	}
-	return &ctx->destination_entries.other;
-}
 
-static int
-_dhd_wlfc_rollback_packet_toq(athost_wl_status_info_t* ctx,
-	void* p, ewlfc_packet_state_t pkt_type, uint32 hslot)
+static void
+dhd_get_hostreorder_pkts(void *osh, struct reorder_info *ptr, void **pkt,
+	uint32 *pkt_count, void **pplast, uint8 start, uint8 end)
 {
-	/*
-	put the packet back to the head of queue
-
-	- a packet from send-q will need to go back to send-q and not delay-q
-	since that will change the order of packets.
-	- suppressed packet goes back to suppress sub-queue
-	- pull out the header, if new or delayed packet
-
-	Note: hslot is used only when header removal is done.
-	*/
-	wlfc_mac_descriptor_t* entry;
-	void* pktout;
-	int rc = BCME_OK;
-	int prec;
-
-	entry = _dhd_wlfc_find_table_entry(ctx, p);
-	prec = DHD_PKTTAG_FIFO(PKTTAG(p));
-	if (entry != NULL) {
-		if (pkt_type == eWLFC_PKTTYPE_SUPPRESSED) {
-			/* wl-header is saved for suppressed packets */
-			if (WLFC_PKTQ_PENQ_HEAD(&entry->psq, ((prec << 1) + 1), p) == NULL) {
-				WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
-				rc = BCME_ERROR;
-			}
-		}
-		else {
-			/* remove header first */
-			_dhd_wlfc_pullheader(ctx, p);
-
-			if (pkt_type == eWLFC_PKTTYPE_DELAYED) {
-				/* delay-q packets are going to delay-q */
-				if (WLFC_PKTQ_PENQ_HEAD(&entry->psq, (prec << 1), p) == NULL) {
-					WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
-					rc = BCME_ERROR;
-				}
-			}
-			else {
-				/* these are going to SENDQ */
-				if (WLFC_PKTQ_PENQ_HEAD(&ctx->SENDQ, prec, p) == NULL) {
-					WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
-					rc = BCME_ERROR;
-				}
-			}
-			/* free the hanger slot */
-			dhd_wlfc_hanger_poppkt(ctx->hanger, hslot, &pktout, 1);
-
-			/* decrement sequence count */
-			WLFC_DECR_SEQCOUNT(entry, prec);
-		}
-		/*
-		if this packet did not count against FIFO credit, it must have
-		taken a requested_credit from the firmware (for pspoll etc.)
-		*/
-		if (!DHD_PKTTAG_CREDITCHECK(PKTTAG(p))) {
-			entry->requested_credit++;
-		}
-	}
-	else {
-		WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
-		rc = BCME_ERROR;
-	}
-	if (rc != BCME_OK)
-		ctx->stats.rollback_failed++;
-	else
-		ctx->stats.rollback++;
-
-	return rc;
-}
-
-static void
-_dhd_wlfc_flow_control_check(athost_wl_status_info_t* ctx, struct pktq* pq, uint8 if_id)
-{
-	if ((pq->len <= WLFC_FLOWCONTROL_LOWATER) && (ctx->hostif_flow_state[if_id] == ON)) {
-		/* start traffic */
-		ctx->hostif_flow_state[if_id] = OFF;
-		/*
-		WLFC_DBGMESG(("qlen:%02d, if:%02d, ->OFF, start traffic %s()\n",
-		pq->len, if_id, __FUNCTION__));
-		*/
-		WLFC_DBGMESG(("F"));
-		dhd_txflowcontrol(ctx->dhdp, if_id, OFF);
-		ctx->toggle_host_if = 0;
-	}
-	if ((pq->len >= WLFC_FLOWCONTROL_HIWATER) && (ctx->hostif_flow_state[if_id] == OFF)) {
-		/* stop traffic */
-		ctx->hostif_flow_state[if_id] = ON;
-		/*
-		WLFC_DBGMESG(("qlen:%02d, if:%02d, ->ON, stop traffic   %s()\n",
-		pq->len, if_id, __FUNCTION__));
-		*/
-		WLFC_DBGMESG(("N"));
-		dhd_txflowcontrol(ctx->dhdp, if_id, ON);
-		ctx->host_ifidx = if_id;
-		ctx->toggle_host_if = 1;
-	}
-	return;
-}
-
-static int
-_dhd_wlfc_send_signalonly_packet(athost_wl_status_info_t* ctx, wlfc_mac_descriptor_t* entry,
-	uint8 ta_bmp)
-{
-	int rc = BCME_OK;
-	void* p = NULL;
-	int dummylen = ((dhd_pub_t *)ctx->dhdp)->hdrlen+ 12;
-
-	/* allocate a dummy packet */
-	p = PKTGET(ctx->osh, dummylen, TRUE);
-	if (p) {
-		PKTPULL(ctx->osh, p, dummylen);
-		DHD_PKTTAG_SET_H2DTAG(PKTTAG(p), 0);
-		_dhd_wlfc_pushheader(ctx, p, TRUE, ta_bmp, entry->mac_handle, 0);
-		DHD_PKTTAG_SETSIGNALONLY(PKTTAG(p), 1);
-#ifdef PROP_TXSTATUS_DEBUG
-		ctx->stats.signal_only_pkts_sent++;
-#endif
-		rc = dhd_bus_txdata(((dhd_pub_t *)ctx->dhdp)->bus, p);
-		if (rc != BCME_OK) {
-			PKTFREE(ctx->osh, p, TRUE);
-		}
-	}
-	else {
-		DHD_ERROR(("%s: couldn't allocate new %d-byte packet\n",
-		           __FUNCTION__, dummylen));
-		rc = BCME_NOMEM;
-	}
-	return rc;
-}
-
-/* Return TRUE if traffic availability changed */
-static bool
-_dhd_wlfc_traffic_pending_check(athost_wl_status_info_t* ctx, wlfc_mac_descriptor_t* entry,
-	int prec)
-{
-	bool rc = FALSE;
-
-	if (entry->state == WLFC_STATE_CLOSE) {
-		if ((pktq_plen(&entry->psq, (prec << 1)) == 0) &&
-			(pktq_plen(&entry->psq, ((prec << 1) + 1)) == 0)) {
-
-			if (entry->traffic_pending_bmp & NBITVAL(prec)) {
-				rc = TRUE;
-				entry->traffic_pending_bmp =
-					entry->traffic_pending_bmp & ~ NBITVAL(prec);
-			}
-		}
-		else {
-			if (!(entry->traffic_pending_bmp & NBITVAL(prec))) {
-				rc = TRUE;
-				entry->traffic_pending_bmp =
-					entry->traffic_pending_bmp | NBITVAL(prec);
-			}
-		}
-	}
-	if (rc) {
-		/* request a TIM update to firmware at the next piggyback opportunity */
-		if (entry->traffic_lastreported_bmp != entry->traffic_pending_bmp) {
-			entry->send_tim_signal = 1;
-			_dhd_wlfc_send_signalonly_packet(ctx, entry, entry->traffic_pending_bmp);
-			entry->traffic_lastreported_bmp = entry->traffic_pending_bmp;
-			entry->send_tim_signal = 0;
-		}
-		else {
-			rc = FALSE;
-		}
-	}
-	return rc;
-}
-
-static int
-_dhd_wlfc_enque_suppressed(athost_wl_status_info_t* ctx, int prec, void* p)
-{
-	wlfc_mac_descriptor_t* entry;
-
-	entry = _dhd_wlfc_find_table_entry(ctx, p);
-	if (entry == NULL) {
-		WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
-		return BCME_NOTFOUND;
-	}
-	/*
-	- suppressed packets go to sub_queue[2*prec + 1] AND
-	- delayed packets go to sub_queue[2*prec + 0] to ensure
-	order of delivery.
-	*/
-	if (WLFC_PKTQ_PENQ(&entry->psq, ((prec << 1) + 1), p) == NULL) {
-		ctx->stats.delayq_full_error++;
-		/* WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__)); */
-		WLFC_DBGMESG(("s"));
-		return BCME_ERROR;
-	}
-	/* A packet has been pushed, update traffic availability bitmap, if applicable */
-	_dhd_wlfc_traffic_pending_check(ctx, entry, prec);
-	_dhd_wlfc_flow_control_check(ctx, &entry->psq, DHD_PKTTAG_IF(PKTTAG(p)));
-	return BCME_OK;
-}
-
-static int
-_dhd_wlfc_pretx_pktprocess(athost_wl_status_info_t* ctx,
-	wlfc_mac_descriptor_t* entry, void* p, int header_needed, uint32* slot)
-{
-	int rc = BCME_OK;
-	int hslot = WLFC_HANGER_MAXITEMS;
-	bool send_tim_update = FALSE;
-	uint32 htod = 0;
-	uint8 free_ctr;
-
-	*slot = hslot;
-
-	if (entry == NULL) {
-		entry = _dhd_wlfc_find_table_entry(ctx, p);
-	}
-
-	if (entry == NULL) {
-		WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
-		return BCME_ERROR;
-	}
-	if (entry->send_tim_signal) {
-		send_tim_update = TRUE;
-		entry->send_tim_signal = 0;
-		entry->traffic_lastreported_bmp = entry->traffic_pending_bmp;
-	}
-	if (header_needed) {
-		hslot = dhd_wlfc_hanger_get_free_slot(ctx->hanger);
-		free_ctr = WLFC_SEQCOUNT(entry, DHD_PKTTAG_FIFO(PKTTAG(p)));
-		DHD_PKTTAG_SET_H2DTAG(PKTTAG(p), htod);
-	}
-	else {
-		hslot = WLFC_PKTID_HSLOT_GET(DHD_PKTTAG_H2DTAG(PKTTAG(p)));
-		free_ctr = WLFC_PKTID_FREERUNCTR_GET(DHD_PKTTAG_H2DTAG(PKTTAG(p)));
-	}
-	WLFC_PKTID_HSLOT_SET(htod, hslot);
-	WLFC_PKTID_FREERUNCTR_SET(htod, free_ctr);
-	DHD_PKTTAG_SETPKTDIR(PKTTAG(p), 1);
-	WL_TXSTATUS_SET_FLAGS(htod, WLFC_PKTFLAG_PKTFROMHOST);
-	WL_TXSTATUS_SET_FIFO(htod, DHD_PKTTAG_FIFO(PKTTAG(p)));
-	WLFC_PKTFLAG_SET_GENERATION(htod, entry->generation);
-
-	if (!DHD_PKTTAG_CREDITCHECK(PKTTAG(p))) {
-		/*
-		Indicate that this packet is being sent in response to an
-		explicit request from the firmware side.
-		*/
-		WLFC_PKTFLAG_SET_PKTREQUESTED(htod);
-	}
-	else {
-		WLFC_PKTFLAG_CLR_PKTREQUESTED(htod);
-	}
-	if (header_needed) {
-		rc = _dhd_wlfc_pushheader(ctx, p, send_tim_update,
-			entry->traffic_lastreported_bmp, entry->mac_handle, htod);
-		if (rc == BCME_OK) {
-			DHD_PKTTAG_SET_H2DTAG(PKTTAG(p), htod);
-			/*
-			a new header was created for this packet.
-			push to hanger slot and scrub q. Since bus
-			send succeeded, increment seq number as well.
-			*/
-			rc = dhd_wlfc_hanger_pushpkt(ctx->hanger, p, hslot);
-			if (rc == BCME_OK) {
-				/* increment free running sequence count */
-				WLFC_INCR_SEQCOUNT(entry, DHD_PKTTAG_FIFO(PKTTAG(p)));
-#ifdef PROP_TXSTATUS_DEBUG
-				((wlfc_hanger_t*)(ctx->hanger))->items[hslot].push_time =
-					OSL_SYSUPTIME();
-#endif
-			}
-			else {
-				WLFC_DBGMESG(("%s() hanger_pushpkt() failed, rc: %d\n",
-					__FUNCTION__, rc));
-			}
-		}
-	}
-	else {
-		/* remove old header */
-		_dhd_wlfc_pullheader(ctx, p);
-
-		hslot = WLFC_PKTID_HSLOT_GET(DHD_PKTTAG_H2DTAG(PKTTAG(p)));
-		free_ctr = WLFC_PKTID_FREERUNCTR_GET(DHD_PKTTAG_H2DTAG(PKTTAG(p)));
-		/* push new header */
-		_dhd_wlfc_pushheader(ctx, p, send_tim_update,
-			entry->traffic_lastreported_bmp, entry->mac_handle, htod);
-	}
-	*slot = hslot;
-	return rc;
-}
-
-static int
-_dhd_wlfc_is_destination_closed(athost_wl_status_info_t* ctx,
-	wlfc_mac_descriptor_t* entry, int prec)
-{
-	if (ctx->destination_entries.interfaces[entry->interface_id].iftype ==
-		WLC_E_IF_ROLE_P2P_GO) {
-		/* - destination interface is of type p2p GO.
-		For a p2pGO interface, if the destination is OPEN but the interface is
-		CLOSEd, do not send traffic. But if the dstn is CLOSEd while there is
-		destination-specific-credit left send packets. This is because the
-		firmware storing the destination-specific-requested packet in queue.
-		*/
-		if ((entry->state == WLFC_STATE_CLOSE) && (entry->requested_credit == 0) &&
-			(entry->requested_packet == 0))
-			return 1;
-	}
-	/* AP, p2p_go -> unicast desc entry, STA/p2p_cl -> interface desc. entry */
-	if (((entry->state == WLFC_STATE_CLOSE) && (entry->requested_credit == 0) &&
-		(entry->requested_packet == 0)) ||
-		(!(entry->ac_bitmap & (1 << prec))))
-		return 1;
-
-	return 0;
-}
-
-static void*
-_dhd_wlfc_deque_delayedq(athost_wl_status_info_t* ctx,
-	int prec, uint8* ac_credit_spent, uint8* needs_hdr, wlfc_mac_descriptor_t** entry_out)
-{
-	wlfc_mac_descriptor_t* entry;
-	wlfc_mac_descriptor_t* table;
-	uint8 token_pos;
-	int total_entries;
-	void* p = NULL;
-	int pout;
-	int i;
-
-	*entry_out = NULL;
-	token_pos = ctx->token_pos[prec];
-	/* most cases a packet will count against FIFO credit */
-	*ac_credit_spent = 1;
-	*needs_hdr = 1;
-
-	/* search all entries, include nodes as well as interfaces */
-	table = (wlfc_mac_descriptor_t*)&ctx->destination_entries;
-	total_entries = sizeof(ctx->destination_entries)/sizeof(wlfc_mac_descriptor_t);
-
-	for (i = 0; i < total_entries; i++) {
-		entry = &table[(token_pos + i) % total_entries];
-		if (entry->occupied) {
-			if (!_dhd_wlfc_is_destination_closed(ctx, entry, prec)) {
-				p = pktq_mdeq(&entry->psq,
-					/* higher precedence will be picked up first,
-					i.e. suppressed packets before delayed ones
-					*/
-					(NBITVAL((prec << 1) + 1) | NBITVAL((prec << 1))),
-					&pout);
-				if (p != NULL) {
-					/* did the packet come from suppress sub-queue? */
-					if (pout == ((prec << 1) + 1)) {
-						/*
-						this packet was suppressed and was sent on the bus
-						previously; this already has a header
-						*/
-						*needs_hdr = 0;
-					}
-					if (entry->requested_credit > 0) {
-						entry->requested_credit--;
-#ifdef PROP_TXSTATUS_DEBUG
-						entry->dstncredit_sent_packets++;
-#endif
-						/*
-						if the packet was pulled out while destination is in
-						closed state but had a non-zero packets requested,
-						then this should not count against the FIFO credit.
-						That is due to the fact that the firmware will
-						most likely hold onto this packet until a suitable
-						time later to push it to the appropriate  AC FIFO.
-						*/
-						if (entry->state == WLFC_STATE_CLOSE)
-							*ac_credit_spent = 0;
-					}
-					else if (entry->requested_packet > 0) {
-						entry->requested_packet--;
-						DHD_PKTTAG_SETONETIMEPKTRQST(PKTTAG(p));
-						if (entry->state == WLFC_STATE_CLOSE)
-							*ac_credit_spent = 0;
-					}
-					/* move token to ensure fair round-robin */
-					ctx->token_pos[prec] =
-						(token_pos + i + 1) % total_entries;
-					*entry_out = entry;
-					_dhd_wlfc_flow_control_check(ctx, &entry->psq,
-						DHD_PKTTAG_IF(PKTTAG(p)));
-					/*
-					A packet has been picked up, update traffic
-					availability bitmap, if applicable
-					*/
-					_dhd_wlfc_traffic_pending_check(ctx, entry, prec);
-					return p;
-				}
-			}
-		}
-	}
-	return NULL;
-}
-
-static void*
-_dhd_wlfc_deque_sendq(athost_wl_status_info_t* ctx, int prec)
-{
-	wlfc_mac_descriptor_t* entry;
-	void* p;
-
-
-	p = pktq_pdeq(&ctx->SENDQ, prec);
-	if (p != NULL) {
-		if (ETHER_ISMULTI(DHD_PKTTAG_DSTN(PKTTAG(p))))
-			/* bc/mc packets do not have a delay queue */
-			return p;
-
-		entry = _dhd_wlfc_find_table_entry(ctx, p);
-
-		if (entry == NULL) {
-			WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
-			return p;
-		}
-
-		while ((p != NULL)) {
-			/*
-			- suppressed packets go to sub_queue[2*prec + 1] AND
-			- delayed packets go to sub_queue[2*prec + 0] to ensure
-			order of delivery.
-			*/
-			if (WLFC_PKTQ_PENQ(&entry->psq, (prec << 1), p) == NULL) {
-				WLFC_DBGMESG(("D"));
-				/* dhd_txcomplete(ctx->dhdp, p, FALSE); */
-				PKTFREE(ctx->osh, p, TRUE);
-				ctx->stats.delayq_full_error++;
-			}
-			/*
-			A packet has been pushed, update traffic availability bitmap,
-			if applicable
-			*/
-			_dhd_wlfc_traffic_pending_check(ctx, entry, prec);
-
-			p = pktq_pdeq(&ctx->SENDQ, prec);
-			if (p == NULL)
-				break;
-
-			entry = _dhd_wlfc_find_table_entry(ctx, p);
-
-			if ((entry == NULL) || (ETHER_ISMULTI(DHD_PKTTAG_DSTN(PKTTAG(p))))) {
-				return p;
-			}
-		}
-	}
-	return p;
-}
-
-static int
-_dhd_wlfc_mac_entry_update(athost_wl_status_info_t* ctx, wlfc_mac_descriptor_t* entry,
-	ewlfc_mac_entry_action_t action, uint8 ifid, uint8 iftype, uint8* ea)
-{
-	int rc = BCME_OK;
-
-	if (action == eWLFC_MAC_ENTRY_ACTION_ADD) {
-		entry->occupied = 1;
-		entry->state = WLFC_STATE_OPEN;
-		entry->requested_credit = 0;
-		entry->interface_id = ifid;
-		entry->iftype = iftype;
-		entry->ac_bitmap = 0xff; /* update this when handling APSD */
-		/* for an interface entry we may not care about the MAC address */
-		if (ea != NULL)
-			memcpy(&entry->ea[0], ea, ETHER_ADDR_LEN);
-		pktq_init(&entry->psq, WLFC_PSQ_PREC_COUNT, WLFC_PSQ_LEN);
-	}
-	else if (action == eWLFC_MAC_ENTRY_ACTION_UPDATE) {
-		entry->occupied = 1;
-		entry->state = WLFC_STATE_OPEN;
-		entry->requested_credit = 0;
-		entry->interface_id = ifid;
-		entry->iftype = iftype;
-		entry->ac_bitmap = 0xff; /* update this when handling APSD */
-		/* for an interface entry we may not care about the MAC address */
-		if (ea != NULL)
-			memcpy(&entry->ea[0], ea, ETHER_ADDR_LEN);
-	}
-	else if (action == eWLFC_MAC_ENTRY_ACTION_DEL) {
-		entry->occupied = 0;
-		entry->state = WLFC_STATE_CLOSE;
-		entry->requested_credit = 0;
-		/* enable after packets are queued-deqeued properly.
-		pktq_flush(dhd->osh, &entry->psq, FALSE, NULL, 0);
-		*/
-	}
-	return rc;
-}
-
-int
-_dhd_wlfc_borrow_credit(athost_wl_status_info_t* ctx, uint8 available_credit_map, int borrower_ac)
-{
-	int lender_ac;
-	int rc = BCME_ERROR;
-
-	if (ctx == NULL || available_credit_map == 0) {
-		WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
-		return BCME_BADARG;
-	}
-
-	/* Borrow from lowest priority available AC (including BC/MC credits) */
-	for (lender_ac = 0; lender_ac <= AC_COUNT; lender_ac++) {
-		if ((available_credit_map && (1 << lender_ac)) &&
-		   (ctx->FIFO_credit[lender_ac] > 0)) {
-			ctx->credits_borrowed[borrower_ac][lender_ac]++;
-			ctx->FIFO_credit[lender_ac]--;
-			rc = BCME_OK;
-			break;
-		}
-	}
-
-	return rc;
-}
-
-int
-dhd_wlfc_interface_entry_update(void* state,
-	ewlfc_mac_entry_action_t action, uint8 ifid, uint8 iftype, uint8* ea)
-{
-	athost_wl_status_info_t* ctx = (athost_wl_status_info_t*)state;
-	wlfc_mac_descriptor_t* entry;
-
-	if (ifid >= WLFC_MAX_IFNUM)
-		return BCME_BADARG;
-
-	entry = &ctx->destination_entries.interfaces[ifid];
-	return _dhd_wlfc_mac_entry_update(ctx, entry, action, ifid, iftype, ea);
-}
-
-int
-dhd_wlfc_FIFOcreditmap_update(void* state, uint8* credits)
-{
-	athost_wl_status_info_t* ctx = (athost_wl_status_info_t*)state;
-
-	/* update the AC FIFO credit map */
-	ctx->FIFO_credit[0] = credits[0];
-	ctx->FIFO_credit[1] = credits[1];
-	ctx->FIFO_credit[2] = credits[2];
-	ctx->FIFO_credit[3] = credits[3];
-	/* credit for bc/mc packets */
-	ctx->FIFO_credit[4] = credits[4];
-	/* credit for ATIM FIFO is not used yet. */
-	ctx->FIFO_credit[5] = 0;
-	return BCME_OK;
-}
-
-int
-dhd_wlfc_enque_sendq(void* state, int prec, void* p)
-{
-	athost_wl_status_info_t* ctx = (athost_wl_status_info_t*)state;
-
-	if ((state == NULL) ||
-		/* prec = AC_COUNT is used for bc/mc queue */
-		(prec > AC_COUNT) ||
-		(p == NULL)) {
-		WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
-		return BCME_BADARG;
-	}
-	if (FALSE == dhd_prec_enq(ctx->dhdp, &ctx->SENDQ, p, prec)) {
-		ctx->stats.sendq_full_error++;
-		/*
-		WLFC_DBGMESG(("Error: %s():%d, qlen:%d\n",
-		__FUNCTION__, __LINE__, ctx->SENDQ.len));
-		*/
-		WLFC_HOST_FIFO_DROPPEDCTR_INC(ctx, prec);
-		WLFC_DBGMESG(("Q"));
-		PKTFREE(ctx->osh, p, TRUE);
-		return BCME_ERROR;
-	}
-	ctx->stats.pktin++;
-	/* _dhd_wlfc_flow_control_check(ctx, &ctx->SENDQ, DHD_PKTTAG_IF(PKTTAG(p))); */
-	return BCME_OK;
-}
-
-int
-_dhd_wlfc_handle_packet_commit(athost_wl_status_info_t* ctx, int ac,
-    dhd_wlfc_commit_info_t *commit_info, f_commitpkt_t fcommit, void* commit_ctx)
-{
-	uint32 hslot;
-	int	rc;
-
-	/*
-		if ac_fifo_credit_spent = 0
-
-		This packet will not count against the FIFO credit.
-		To ensure the txstatus corresponding to this packet
-		does not provide an implied credit (default behavior)
-		mark the packet accordingly.
-
-		if ac_fifo_credit_spent = 1
-
-		This is a normal packet and it counts against the FIFO
-		credit count.
-	*/
-	DHD_PKTTAG_SETCREDITCHECK(PKTTAG(commit_info->p), commit_info->ac_fifo_credit_spent);
-	rc = _dhd_wlfc_pretx_pktprocess(ctx, commit_info->mac_entry, commit_info->p,
-	     commit_info->needs_hdr, &hslot);
-
-	if (rc == BCME_OK)
-		rc = fcommit(commit_ctx, commit_info->p);
-	else
-		ctx->stats.generic_error++;
-
-	if (rc == BCME_OK) {
-		ctx->stats.pkt2bus++;
-		if (commit_info->ac_fifo_credit_spent) {
-			ctx->stats.sendq_pkts[ac]++;
-			WLFC_HOST_FIFO_CREDIT_INC_SENTCTRS(ctx, ac);
-		}
-	}
-	else {
-		/*
-		   bus commit has failed, rollback.
-		   - remove wl-header for a delayed packet
-		   - save wl-header header for suppressed packets
-		*/
-		rc = _dhd_wlfc_rollback_packet_toq(ctx,	commit_info->p,
-		     (commit_info->pkt_type), hslot);
-		if (rc != BCME_OK)
-			ctx->stats.rollback_failed++;
-
-		rc = BCME_ERROR;
-	}
-
-	return rc;
-}
-
-int
-dhd_wlfc_commit_packets(void* state, f_commitpkt_t fcommit, void* commit_ctx)
-{
-	int ac;
-	int credit;
-	int rc;
-	dhd_wlfc_commit_info_t  commit_info;
-	athost_wl_status_info_t* ctx = (athost_wl_status_info_t*)state;
-	int credit_count = 0;
-	int bus_retry_count = 0;
-	uint8 ac_available = 0;  /* Bitmask for 4 ACs + BC/MC */
-
-	if ((state == NULL) ||
-		(fcommit == NULL)) {
-		WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
-		return BCME_BADARG;
-	}
-
-	memset(&commit_info, 0, sizeof(commit_info));
-
-	/*
-	Commit packets for regular AC traffic. Higher priority first.
-	First, use up FIFO credits available to each AC. Based on distribution
-	and credits left, borrow from other ACs as applicable
-
-	-NOTE:
-	If the bus between the host and firmware is overwhelmed by the
-	traffic from host, it is possible that higher priority traffic
-	starves the lower priority queue. If that occurs often, we may
-	have to employ weighted round-robin or ucode scheme to avoid
-	low priority packet starvation.
-	*/
-
-	for (ac = AC_COUNT; ac >= 0; ac--) {
-
-		int initial_credit_count = ctx->FIFO_credit[ac];
-
-		/* packets from SENDQ are fresh and they'd need header and have no MAC entry */
-		commit_info.needs_hdr = 1;
-		commit_info.mac_entry = NULL;
-		commit_info.pkt_type = eWLFC_PKTTYPE_NEW;
-
-		do {
-			commit_info.p = _dhd_wlfc_deque_sendq(ctx, ac);
-			if (commit_info.p == NULL)
-				break;
-			else if (ETHER_ISMULTI(DHD_PKTTAG_DSTN(PKTTAG(commit_info.p)))) {
-				ASSERT(ac == AC_COUNT);
-
-				if (ctx->FIFO_credit[ac]) {
-					rc = _dhd_wlfc_handle_packet_commit(ctx, ac, &commit_info,
-						fcommit, commit_ctx);
-
-			/* Bus commits may fail (e.g. flow control); abort after retries */
-					if (rc == BCME_OK) {
-						if (commit_info.ac_fifo_credit_spent) {
-							(void) _dhd_wlfc_borrow_credit(ctx,
-								ac_available, ac);
-							credit_count--;
-						}
-					} else {
-						bus_retry_count++;
-						if (bus_retry_count >= BUS_RETRIES) {
-							DHD_ERROR((" %s: bus error\n",
-								__FUNCTION__));
-							return rc;
-						}
-					}
-				}
-			}
-
-		} while (commit_info.p);
-
-		for (credit = 0; credit < ctx->FIFO_credit[ac];) {
-			commit_info.p = _dhd_wlfc_deque_delayedq(ctx, ac,
-			                &(commit_info.ac_fifo_credit_spent),
-			                &(commit_info.needs_hdr),
-			                &(commit_info.mac_entry));
-
-			if (commit_info.p == NULL)
-				break;
-
-			commit_info.pkt_type = (commit_info.needs_hdr) ? eWLFC_PKTTYPE_DELAYED :
-				eWLFC_PKTTYPE_SUPPRESSED;
-
-			rc = _dhd_wlfc_handle_packet_commit(ctx, ac, &commit_info,
-			     fcommit, commit_ctx);
-
-			/* Bus commits may fail (e.g. flow control); abort after retries */
-			if (rc == BCME_OK) {
-				if (commit_info.ac_fifo_credit_spent) {
-					credit++;
-				}
-			}
-			else {
-				bus_retry_count++;
-				if (bus_retry_count >= BUS_RETRIES) {
-					DHD_ERROR(("dhd_wlfc_commit_packets(): bus error\n"));
-					ctx->FIFO_credit[ac] -= credit;
-					return rc;
-				}
-			}
-		}
-
-		ctx->FIFO_credit[ac] -= credit;
-
-
-		/* If no credits were used, the queue is idle and can be re-used
-		   Note that resv credits cannot be borrowed
-		   */
-		if (initial_credit_count == ctx->FIFO_credit[ac]) {
-			ac_available |= (1 << ac);
-			credit_count += ctx->FIFO_credit[ac];
-		}
-	}
-
-	/* We borrow only for AC_BE and only if no other traffic seen for DEFER_PERIOD
-
-	   Note that (ac_available & WLFC_AC_BE_TRAFFIC_ONLY) is done to:
-	   a) ignore BC/MC for deferring borrow
-	   b) ignore AC_BE being available along with other ACs
-		  (this should happen only for pure BC/MC traffic)
-
-	   i.e. AC_VI, AC_VO, AC_BK all MUST be available (i.e. no traffic) and
-	   we do not care if AC_BE and BC/MC are available or not
-	   */
-	if ((ac_available & WLFC_AC_BE_TRAFFIC_ONLY) == WLFC_AC_BE_TRAFFIC_ONLY) {
-
-		if (ctx->allow_credit_borrow) {
-			ac = 1;  /* Set ac to AC_BE and borrow credits */
-		}
-		else {
-			int delta;
-			int curr_t = OSL_SYSUPTIME();
-
-			if (curr_t > ctx->borrow_defer_timestamp)
-				delta = curr_t - ctx->borrow_defer_timestamp;
-			else
-				delta = 0xffffffff + curr_t - ctx->borrow_defer_timestamp;
-
-			if (delta >= WLFC_BORROW_DEFER_PERIOD_MS) {
-				/* Reset borrow but defer to next iteration (defensive borrowing) */
-				ctx->allow_credit_borrow = TRUE;
-				ctx->borrow_defer_timestamp = 0;
-			}
-			return BCME_OK;
-		}
-	}
-	else {
-		/* If we have multiple AC traffic, turn off borrowing, mark time and bail out */
-		ctx->allow_credit_borrow = FALSE;
-		ctx->borrow_defer_timestamp = OSL_SYSUPTIME();
-		return BCME_OK;
-	}
-
-	/* At this point, borrow all credits only for "ac" (which should be set above to AC_BE)
-	   Generically use "ac" only in case we extend to all ACs in future
-	   */
-	for (; (credit_count > 0);) {
-
-		commit_info.p = _dhd_wlfc_deque_delayedq(ctx, ac,
-		                &(commit_info.ac_fifo_credit_spent),
-		                &(commit_info.needs_hdr),
-		                &(commit_info.mac_entry));
-		if (commit_info.p == NULL)
-			break;
-
-		commit_info.pkt_type = (commit_info.needs_hdr) ? eWLFC_PKTTYPE_DELAYED :
-			eWLFC_PKTTYPE_SUPPRESSED;
-
-		rc = _dhd_wlfc_handle_packet_commit(ctx, ac, &commit_info,
-		     fcommit, commit_ctx);
-
-		/* Bus commits may fail (e.g. flow control); abort after retries */
-		if (rc == BCME_OK) {
-			if (commit_info.ac_fifo_credit_spent) {
-				(void) _dhd_wlfc_borrow_credit(ctx, ac_available, ac);
-				credit_count--;
-			}
-		}
-		else {
-			bus_retry_count++;
-			if (bus_retry_count >= BUS_RETRIES) {
-				DHD_ERROR(("dhd_wlfc_commit_packets(): bus error\n"));
-				return rc;
-			}
-		}
-	}
-
-	/* packets from SENDQ are fresh and they'd need header and have no MAC entry */
-	commit_info.needs_hdr = 1;
-	commit_info.mac_entry = NULL;
-	commit_info.pkt_type = eWLFC_PKTTYPE_NEW;
-
-	for (; (credit_count > 0);) {
-
-		commit_info.p = _dhd_wlfc_deque_sendq(ctx, ac);
-		if (commit_info.p == NULL)
-			break;
-
-		rc = _dhd_wlfc_handle_packet_commit(ctx, ac, &commit_info,
-		     fcommit, commit_ctx);
-
-		/* Bus commits may fail (e.g. flow control); abort after retries */
-		if (rc == BCME_OK) {
-			if (commit_info.ac_fifo_credit_spent) {
-				(void) _dhd_wlfc_borrow_credit(ctx, ac_available, ac);
-				credit_count--;
-			}
-		}
-		else {
-			bus_retry_count++;
-			if (bus_retry_count >= BUS_RETRIES) {
-				DHD_ERROR(("dhd_wlfc_commit_packets(): bus error\n"));
-				return rc;
-			}
-		}
-	}
-
-	return BCME_OK;
-}
-
-static uint8
-dhd_wlfc_find_mac_desc_id_from_mac(dhd_pub_t *dhdp, uint8* ea)
-{
-	wlfc_mac_descriptor_t* table =
-		((athost_wl_status_info_t*)dhdp->wlfc_state)->destination_entries.nodes;
-	uint8 table_index;
-
-	if (ea != NULL) {
-		for (table_index = 0; table_index < WLFC_MAC_DESC_TABLE_SIZE; table_index++) {
-			if ((memcmp(ea, &table[table_index].ea[0], ETHER_ADDR_LEN) == 0) &&
-				table[table_index].occupied)
-				return table_index;
-		}
-	}
-	return WLFC_MAC_DESC_ID_INVALID;
-}
-
-void
-dhd_wlfc_txcomplete(dhd_pub_t *dhd, void *txp, bool success)
-{
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhd->wlfc_state;
-	void* p;
-	int fifo_id;
-
-	if (DHD_PKTTAG_SIGNALONLY(PKTTAG(txp))) {
-#ifdef PROP_TXSTATUS_DEBUG
-		wlfc->stats.signal_only_pkts_freed++;
-#endif
-		/* is this a signal-only packet? */
-		PKTFREE(wlfc->osh, txp, TRUE);
-		return;
-	}
-	if (!success) {
-		WLFC_DBGMESG(("At: %s():%d, bus_complete() failure for %p, htod_tag:0x%08x\n",
-			__FUNCTION__, __LINE__, txp, DHD_PKTTAG_H2DTAG(PKTTAG(txp))));
-		dhd_wlfc_hanger_poppkt(wlfc->hanger, WLFC_PKTID_HSLOT_GET(DHD_PKTTAG_H2DTAG
-			(PKTTAG(txp))), &p, 1);
-
-		/* indicate failure and free the packet */
-		dhd_txcomplete(dhd, txp, FALSE);
-
-		/* return the credit, if necessary */
-		if (DHD_PKTTAG_CREDITCHECK(PKTTAG(txp))) {
-			int lender, credit_returned = 0; /* Note that borrower is fifo_id */
-
-			fifo_id = DHD_PKTTAG_FIFO(PKTTAG(txp));
-
-			/* Return credits to highest priority lender first */
-			for (lender = AC_COUNT; lender >= 0; lender--) {
-				if (wlfc->credits_borrowed[fifo_id][lender] > 0) {
-					wlfc->FIFO_credit[lender]++;
-					wlfc->credits_borrowed[fifo_id][lender]--;
-					credit_returned = 1;
-					break;
-				}
-			}
-
-			if (!credit_returned) {
-				wlfc->FIFO_credit[fifo_id]++;
-			}
-		}
-
-		PKTFREE(wlfc->osh, txp, TRUE);
-	}
-	return;
-}
-
-/* Handle discard or suppress indication */
-static int
-dhd_wlfc_txstatus_update(dhd_pub_t *dhd, uint8* pkt_info)
-{
-	uint8 	status_flag;
-	uint32	status;
-	int		ret;
-	int		remove_from_hanger = 1;
-	void*	pktbuf;
-	uint8	fifo_id;
-	wlfc_mac_descriptor_t* entry = NULL;
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhd->wlfc_state;
-
-	memcpy(&status, pkt_info, sizeof(uint32));
-	status_flag = WL_TXSTATUS_GET_FLAGS(status);
-	wlfc->stats.txstatus_in++;
-
-	if (status_flag == WLFC_CTL_PKTFLAG_DISCARD) {
-		wlfc->stats.pkt_freed++;
-	}
-
-	else if (status_flag == WLFC_CTL_PKTFLAG_D11SUPPRESS) {
-		wlfc->stats.d11_suppress++;
-		remove_from_hanger = 0;
-	}
-
-	else if (status_flag == WLFC_CTL_PKTFLAG_WLSUPPRESS) {
-		wlfc->stats.wl_suppress++;
-		remove_from_hanger = 0;
-	}
-
-	else if (status_flag == WLFC_CTL_PKTFLAG_TOSSED_BYWLC) {
-		wlfc->stats.wlc_tossed_pkts++;
-	}
-
-	ret = dhd_wlfc_hanger_poppkt(wlfc->hanger,
-		WLFC_PKTID_HSLOT_GET(status), &pktbuf, remove_from_hanger);
-	if (ret != BCME_OK) {
-		/* do something */
-		return ret;
-	}
-
-	if (!remove_from_hanger) {
-		/* this packet was suppressed */
-
-		entry = _dhd_wlfc_find_table_entry(wlfc, pktbuf);
-		entry->generation = WLFC_PKTID_GEN(status);
-	}
-
-#ifdef PROP_TXSTATUS_DEBUG
-	{
-		uint32 new_t = OSL_SYSUPTIME();
-		uint32 old_t;
-		uint32 delta;
-		old_t = ((wlfc_hanger_t*)(wlfc->hanger))->items[
-			WLFC_PKTID_HSLOT_GET(status)].push_time;
-
-
-		wlfc->stats.latency_sample_count++;
-		if (new_t > old_t)
-			delta = new_t - old_t;
-		else
-			delta = 0xffffffff + new_t - old_t;
-		wlfc->stats.total_status_latency += delta;
-		wlfc->stats.latency_most_recent = delta;
-
-		wlfc->stats.deltas[wlfc->stats.idx_delta++] = delta;
-		if (wlfc->stats.idx_delta == sizeof(wlfc->stats.deltas)/sizeof(uint32))
-			wlfc->stats.idx_delta = 0;
-	}
-#endif /* PROP_TXSTATUS_DEBUG */
-
-	fifo_id = DHD_PKTTAG_FIFO(PKTTAG(pktbuf));
-
-	/* pick up the implicit credit from this packet */
-	if (DHD_PKTTAG_CREDITCHECK(PKTTAG(pktbuf))) {
-		if (wlfc->proptxstatus_mode == WLFC_FCMODE_IMPLIED_CREDIT) {
-
-			int lender, credit_returned = 0; /* Note that borrower is fifo_id */
-
-			/* Return credits to highest priority lender first */
-			for (lender = AC_COUNT; lender >= 0; lender--)	{
-				if (wlfc->credits_borrowed[fifo_id][lender] > 0) {
-					wlfc->FIFO_credit[lender]++;
-					wlfc->credits_borrowed[fifo_id][lender]--;
-					credit_returned = 1;
-					break;
-				}
-			}
-
-			if (!credit_returned) {
-				wlfc->FIFO_credit[fifo_id]++;
-			}
-		}
-	}
-	else {
-		/*
-		if this packet did not count against FIFO credit, it must have
-		taken a requested_credit from the destination entry (for pspoll etc.)
-		*/
-		if (!entry) {
-
-			entry = _dhd_wlfc_find_table_entry(wlfc, pktbuf);
-		}
-		if (!DHD_PKTTAG_ONETIMEPKTRQST(PKTTAG(pktbuf)))
-			entry->requested_credit++;
-#ifdef PROP_TXSTATUS_DEBUG
-		entry->dstncredit_acks++;
-#endif
-	}
-	if ((status_flag == WLFC_CTL_PKTFLAG_D11SUPPRESS) ||
-		(status_flag == WLFC_CTL_PKTFLAG_WLSUPPRESS)) {
-		ret = _dhd_wlfc_enque_suppressed(wlfc, fifo_id, pktbuf);
-		if (ret != BCME_OK) {
-			/* delay q is full, drop this packet */
-			dhd_wlfc_hanger_poppkt(wlfc->hanger, WLFC_PKTID_HSLOT_GET(status),
-			&pktbuf, 1);
-
-			/* indicate failure and free the packet */
-			dhd_txcomplete(dhd, pktbuf, FALSE);
-			PKTFREE(wlfc->osh, pktbuf, TRUE);
-		}
-	}
-	else {
-		dhd_txcomplete(dhd, pktbuf, TRUE);
-		/* free the packet */
-		PKTFREE(wlfc->osh, pktbuf, TRUE);
-	}
-	return BCME_OK;
-}
-
-static int
-dhd_wlfc_fifocreditback_indicate(dhd_pub_t *dhd, uint8* credits)
-{
-	int i;
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhd->wlfc_state;
-	for (i = 0; i < WLFC_CTL_VALUE_LEN_FIFO_CREDITBACK; i++) {
-#ifdef PROP_TXSTATUS_DEBUG
-		wlfc->stats.fifo_credits_back[i] += credits[i];
-#endif
-		/* update FIFO credits */
-		if (wlfc->proptxstatus_mode == WLFC_FCMODE_EXPLICIT_CREDIT)
-		{
-			int lender; /* Note that borrower is i */
-
-			/* Return credits to highest priority lender first */
-			for (lender = AC_COUNT; (lender >= 0) && (credits[i] > 0); lender--) {
-				if (wlfc->credits_borrowed[i][lender] > 0) {
-					if (credits[i] >= wlfc->credits_borrowed[i][lender]) {
-						credits[i] -= wlfc->credits_borrowed[i][lender];
-						wlfc->FIFO_credit[lender] +=
-						    wlfc->credits_borrowed[i][lender];
-						wlfc->credits_borrowed[i][lender] = 0;
-					}
-					else {
-						wlfc->credits_borrowed[i][lender] -= credits[i];
-						wlfc->FIFO_credit[lender] += credits[i];
-						credits[i] = 0;
-					}
-				}
-			}
-
-			/* If we have more credits left over, these must belong to the AC */
-			if (credits[i] > 0) {
-				wlfc->FIFO_credit[i] += credits[i];
-			}
-		}
-	}
-
-	return BCME_OK;
-}
-
-static int
-dhd_wlfc_rssi_indicate(dhd_pub_t *dhd, uint8* rssi)
-{
-	(void)dhd;
-	(void)rssi;
-	return BCME_OK;
-}
-
-static int
-dhd_wlfc_mac_table_update(dhd_pub_t *dhd, uint8* value, uint8 type)
-{
-	int rc;
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhd->wlfc_state;
-	wlfc_mac_descriptor_t* table;
-	uint8 existing_index;
-	uint8 table_index;
-	uint8 ifid;
-	uint8* ea;
-
-	WLFC_DBGMESG(("%s(), mac [%02x:%02x:%02x:%02x:%02x:%02x],%s,idx:%d,id:0x%02x\n",
-		__FUNCTION__, value[2], value[3], value[4], value[5], value[6], value[7],
-		((type == WLFC_CTL_TYPE_MACDESC_ADD) ? "ADD":"DEL"),
-		WLFC_MAC_DESC_GET_LOOKUP_INDEX(value[0]), value[0]));
-
-	table = wlfc->destination_entries.nodes;
-	table_index = WLFC_MAC_DESC_GET_LOOKUP_INDEX(value[0]);
-	ifid = value[1];
-	ea = &value[2];
-
-	if (type == WLFC_CTL_TYPE_MACDESC_ADD) {
-		existing_index = dhd_wlfc_find_mac_desc_id_from_mac(dhd, &value[2]);
-		if (existing_index == WLFC_MAC_DESC_ID_INVALID) {
-			/* this MAC entry does not exist, create one */
-			if (!table[table_index].occupied) {
-				table[table_index].mac_handle = value[0];
-				rc = _dhd_wlfc_mac_entry_update(wlfc, &table[table_index],
-				eWLFC_MAC_ENTRY_ACTION_ADD, ifid,
-				wlfc->destination_entries.interfaces[ifid].iftype,
-				ea);
-			}
-			else {
-				/* the space should have been empty, but it's not */
-				wlfc->stats.mac_update_failed++;
-			}
-		}
-		else {
-			/*
-			there is an existing entry, move it to new index
-			if necessary.
-			*/
-			if (existing_index != table_index) {
-				/* if we already have an entry, free the old one */
-				table[existing_index].occupied = 0;
-				table[existing_index].state = WLFC_STATE_CLOSE;
-				table[existing_index].requested_credit = 0;
-				table[existing_index].interface_id = 0;
-				/* enable after packets are queued-deqeued properly.
-				pktq_flush(dhd->osh, &table[existing_index].psq, FALSE, NULL, 0);
-				*/
-			}
-		}
-	}
-	if (type == WLFC_CTL_TYPE_MACDESC_DEL) {
-		if (table[table_index].occupied) {
-				rc = _dhd_wlfc_mac_entry_update(wlfc, &table[table_index],
-					eWLFC_MAC_ENTRY_ACTION_DEL, ifid,
-					wlfc->destination_entries.interfaces[ifid].iftype,
-					ea);
-		}
-		else {
-			/* the space should have been occupied, but it's not */
-			wlfc->stats.mac_update_failed++;
-		}
-	}
-	BCM_REFERENCE(rc);
-	return BCME_OK;
-}
-
-static int
-dhd_wlfc_psmode_update(dhd_pub_t *dhd, uint8* value, uint8 type)
-{
-	/* Handle PS on/off indication */
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhd->wlfc_state;
-	wlfc_mac_descriptor_t* table;
-	wlfc_mac_descriptor_t* desc;
-	uint8 mac_handle = value[0];
-	int i;
-
-	table = wlfc->destination_entries.nodes;
-	desc = &table[WLFC_MAC_DESC_GET_LOOKUP_INDEX(mac_handle)];
-	if (desc->occupied) {
-		/* a fresh PS mode should wipe old ps credits? */
-		desc->requested_credit = 0;
-		if (type == WLFC_CTL_TYPE_MAC_OPEN) {
-			desc->state = WLFC_STATE_OPEN;
-			DHD_WLFC_CTRINC_MAC_OPEN(desc);
-		}
-		else {
-			desc->state = WLFC_STATE_CLOSE;
-			DHD_WLFC_CTRINC_MAC_CLOSE(desc);
-			/*
-			Indicate to firmware if there is any traffic pending.
-			*/
-			for (i = AC_BE; i < AC_COUNT; i++) {
-				_dhd_wlfc_traffic_pending_check(wlfc, desc, i);
-			}
-		}
-	}
-	else {
-		wlfc->stats.psmode_update_failed++;
-	}
-	return BCME_OK;
-}
-
-static int
-dhd_wlfc_interface_update(dhd_pub_t *dhd, uint8* value, uint8 type)
-{
-	/* Handle PS on/off indication */
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhd->wlfc_state;
-	wlfc_mac_descriptor_t* table;
-	uint8 if_id = value[0];
-
-	if (if_id < WLFC_MAX_IFNUM) {
-		table = wlfc->destination_entries.interfaces;
-		if (table[if_id].occupied) {
-			if (type == WLFC_CTL_TYPE_INTERFACE_OPEN) {
-				table[if_id].state = WLFC_STATE_OPEN;
-				/* WLFC_DBGMESG(("INTERFACE[%d] OPEN\n", if_id)); */
-			}
-			else {
-				table[if_id].state = WLFC_STATE_CLOSE;
-				/* WLFC_DBGMESG(("INTERFACE[%d] CLOSE\n", if_id)); */
-			}
-			return BCME_OK;
-		}
-	}
-	wlfc->stats.interface_update_failed++;
-
-	return BCME_OK;
-}
-
-static int
-dhd_wlfc_credit_request(dhd_pub_t *dhd, uint8* value)
-{
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhd->wlfc_state;
-	wlfc_mac_descriptor_t* table;
-	wlfc_mac_descriptor_t* desc;
-	uint8 mac_handle;
-	uint8 credit;
-
-	table = wlfc->destination_entries.nodes;
-	mac_handle = value[1];
-	credit = value[0];
-
-	desc = &table[WLFC_MAC_DESC_GET_LOOKUP_INDEX(mac_handle)];
-	if (desc->occupied) {
-		desc->requested_credit = credit;
-
-		desc->ac_bitmap = value[2];
-	}
-	else {
-		wlfc->stats.credit_request_failed++;
-	}
-	return BCME_OK;
-}
-
-static int
-dhd_wlfc_packet_request(dhd_pub_t *dhd, uint8* value)
-{
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhd->wlfc_state;
-	wlfc_mac_descriptor_t* table;
-	wlfc_mac_descriptor_t* desc;
-	uint8 mac_handle;
-	uint8 packet_count;
-
-	table = wlfc->destination_entries.nodes;
-	mac_handle = value[1];
-	packet_count = value[0];
-
-	desc = &table[WLFC_MAC_DESC_GET_LOOKUP_INDEX(mac_handle)];
-	if (desc->occupied) {
-		desc->requested_packet = packet_count;
-
-		desc->ac_bitmap = value[2];
-	}
-	else {
-		wlfc->stats.packet_request_failed++;
-	}
-	return BCME_OK;
-}
-
-static void
-dhd_wlfc_reorderinfo_indicate(uint8 *val, uint8 len, uchar *info_buf, uint *info_len)
-{
-	if (info_len) {
-		if (info_buf) {
-			bcopy(val, info_buf, len);
-			*info_len = len;
-		}
-		else
-			*info_len = 0;
-	}
-}
-
-static int
-dhd_wlfc_parse_header_info(dhd_pub_t *dhd, void* pktbuf, int tlv_hdr_len, uchar *reorder_info_buf,
-	uint *reorder_info_len)
-{
-	uint8 type, len;
-	uint8* value;
-	uint8* tmpbuf;
-	uint16 remainder = tlv_hdr_len;
-	uint16 processed = 0;
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhd->wlfc_state;
-	tmpbuf = (uint8*)PKTDATA(dhd->osh, pktbuf);
-	if (remainder) {
-		while ((processed < (WLFC_MAX_PENDING_DATALEN * 2)) && (remainder > 0)) {
-			type = tmpbuf[processed];
-			if (type == WLFC_CTL_TYPE_FILLER) {
-				remainder -= 1;
-				processed += 1;
-				continue;
-			}
-
-			len  = tmpbuf[processed + 1];
-			value = &tmpbuf[processed + 2];
-
-			if (remainder < (2 + len))
-				break;
-
-			remainder -= 2 + len;
-			processed += 2 + len;
-			if (type == WLFC_CTL_TYPE_TXSTATUS)
-				dhd_wlfc_txstatus_update(dhd, value);
-
-			else if (type == WLFC_CTL_TYPE_HOST_REORDER_RXPKTS)
-				dhd_wlfc_reorderinfo_indicate(value, len, reorder_info_buf,
-					reorder_info_len);
-			else if (type == WLFC_CTL_TYPE_FIFO_CREDITBACK)
-				dhd_wlfc_fifocreditback_indicate(dhd, value);
-
-			else if (type == WLFC_CTL_TYPE_RSSI)
-				dhd_wlfc_rssi_indicate(dhd, value);
-
-			else if (type == WLFC_CTL_TYPE_MAC_REQUEST_CREDIT)
-				dhd_wlfc_credit_request(dhd, value);
-
-			else if (type == WLFC_CTL_TYPE_MAC_REQUEST_PACKET)
-				dhd_wlfc_packet_request(dhd, value);
-
-			else if ((type == WLFC_CTL_TYPE_MAC_OPEN) ||
-				(type == WLFC_CTL_TYPE_MAC_CLOSE))
-				dhd_wlfc_psmode_update(dhd, value, type);
-
-			else if ((type == WLFC_CTL_TYPE_MACDESC_ADD) ||
-				(type == WLFC_CTL_TYPE_MACDESC_DEL))
-				dhd_wlfc_mac_table_update(dhd, value, type);
-
-			else if ((type == WLFC_CTL_TYPE_INTERFACE_OPEN) ||
-				(type == WLFC_CTL_TYPE_INTERFACE_CLOSE)) {
-				dhd_wlfc_interface_update(dhd, value, type);
-			}
-		}
-		if (remainder != 0) {
-			/* trouble..., something is not right */
-			wlfc->stats.tlv_parse_failed++;
-		}
-	}
-	return BCME_OK;
-}
-
-int
-dhd_wlfc_init(dhd_pub_t *dhd)
-{
-	char iovbuf[12]; /* Room for "tlv" + '\0' + parameter */
-	/* enable all signals & indicate host proptxstatus logic is active */
-	uint32 tlv = dhd->wlfc_enabled?
-		WLFC_FLAGS_RSSI_SIGNALS |
-		WLFC_FLAGS_XONXOFF_SIGNALS |
-		WLFC_FLAGS_CREDIT_STATUS_SIGNALS |
-		WLFC_FLAGS_HOST_RXRERODER_ACTIVE : 0;
-		/* WLFC_FLAGS_HOST_PROPTXSTATUS_ACTIVE | WLFC_FLAGS_HOST_RXRERODER_ACTIVE : 0; */
-
-
-	/*
-	try to enable/disable signaling by sending "tlv" iovar. if that fails,
-	fallback to no flow control? Print a message for now.
-	*/
-
-	/* enable proptxtstatus signaling by default */
-	bcm_mkiovar("tlv", (char *)&tlv, 4, iovbuf, sizeof(iovbuf));
-	if (dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0) < 0) {
-		DHD_ERROR(("dhd_wlfc_init(): failed to enable/disable bdcv2 tlv signaling\n"));
-	}
-	else {
-		/*
-		Leaving the message for now, it should be removed after a while; once
-		the tlv situation is stable.
-		*/
-		DHD_ERROR(("dhd_wlfc_init(): successfully %s bdcv2 tlv signaling, %d\n",
-			dhd->wlfc_enabled?"enabled":"disabled", tlv));
-	}
-	return BCME_OK;
-}
-
-int
-dhd_wlfc_enable(dhd_pub_t *dhd)
-{
-	int i;
-	athost_wl_status_info_t* wlfc;
-
-	if (!dhd->wlfc_enabled || dhd->wlfc_state)
-		return BCME_OK;
-
-	/* allocate space to track txstatus propagated from firmware */
-	dhd->wlfc_state = MALLOC(dhd->osh, sizeof(athost_wl_status_info_t));
-	if (dhd->wlfc_state == NULL)
-		return BCME_NOMEM;
-
-	/* initialize state space */
-	wlfc = (athost_wl_status_info_t*)dhd->wlfc_state;
-	memset(wlfc, 0, sizeof(athost_wl_status_info_t));
-
-	/* remember osh & dhdp */
-	wlfc->osh = dhd->osh;
-	wlfc->dhdp = dhd;
-
-	wlfc->hanger =
-		dhd_wlfc_hanger_create(dhd->osh, WLFC_HANGER_MAXITEMS);
-	if (wlfc->hanger == NULL) {
-		MFREE(dhd->osh, dhd->wlfc_state, sizeof(athost_wl_status_info_t));
-		dhd->wlfc_state = NULL;
-		return BCME_NOMEM;
-	}
-
-	/* initialize all interfaces to accept traffic */
-	for (i = 0; i < WLFC_MAX_IFNUM; i++) {
-		wlfc->hostif_flow_state[i] = OFF;
-	}
-
-	/*
-	create the SENDQ containing
-	sub-queues for all AC precedences + 1 for bc/mc traffic
-	*/
-	pktq_init(&wlfc->SENDQ, (AC_COUNT + 1), WLFC_SENDQ_LEN);
-
-	wlfc->destination_entries.other.state = WLFC_STATE_OPEN;
-	/* bc/mc FIFO is always open [credit aside], i.e. b[5] */
-	wlfc->destination_entries.other.ac_bitmap = 0x1f;
-	wlfc->destination_entries.other.interface_id = 0;
-
-	wlfc->proptxstatus_mode = WLFC_FCMODE_EXPLICIT_CREDIT;
-
-	wlfc->allow_credit_borrow = TRUE;
-	wlfc->borrow_defer_timestamp = 0;
-
-	return BCME_OK;
-}
-
-/* release all packet resources */
-void
-dhd_wlfc_cleanup(dhd_pub_t *dhd)
-{
-	int i;
-	int total_entries;
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhd->wlfc_state;
-	wlfc_mac_descriptor_t* table;
-	wlfc_hanger_t* h;
-
-	if (dhd->wlfc_state == NULL)
-		return;
-
-	total_entries = sizeof(wlfc->destination_entries)/sizeof(wlfc_mac_descriptor_t);
-	/* search all entries, include nodes as well as interfaces */
-	table = (wlfc_mac_descriptor_t*)&wlfc->destination_entries;
-
-	for (i = 0; i < total_entries; i++) {
-		if (table[i].occupied) {
-			if (table[i].psq.len) {
-				WLFC_DBGMESG(("%s(): DELAYQ[%d].len = %d\n",
-					__FUNCTION__, i, table[i].psq.len));
-				/* release packets held in DELAYQ */
-				pktq_flush(wlfc->osh, &table[i].psq, TRUE, NULL, 0);
-			}
-			table[i].occupied = 0;
-		}
-	}
-	/* release packets held in SENDQ */
-	if (wlfc->SENDQ.len)
-		pktq_flush(wlfc->osh, &wlfc->SENDQ, TRUE, NULL, 0);
-	/* any in the hanger? */
-	h = (wlfc_hanger_t*)wlfc->hanger;
-	for (i = 0; i < h->max_items; i++) {
-		if (h->items[i].state == WLFC_HANGER_ITEM_STATE_INUSE) {
-			PKTFREE(wlfc->osh, h->items[i].pkt, TRUE);
-		}
-	}
-	return;
-}
-
-void
-dhd_wlfc_deinit(dhd_pub_t *dhd)
-{
-	/* cleanup all psq related resources */
-	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
-		dhd->wlfc_state;
-
-	if (dhd->wlfc_state == NULL)
-		return;
-
-#ifdef PROP_TXSTATUS_DEBUG
-	{
-		int i;
-		wlfc_hanger_t* h = (wlfc_hanger_t*)wlfc->hanger;
-		for (i = 0; i < h->max_items; i++) {
-			if (h->items[i].state == WLFC_HANGER_ITEM_STATE_INUSE) {
-				WLFC_DBGMESG(("%s() pkt[%d] = 0x%p, FIFO_credit_used:%d\n",
-					__FUNCTION__, i, h->items[i].pkt,
-					DHD_PKTTAG_CREDITCHECK(PKTTAG(h->items[i].pkt))));
-			}
-		}
-	}
-#endif
-	/* delete hanger */
-	dhd_wlfc_hanger_delete(dhd->osh, wlfc->hanger);
-
-	/* free top structure */
-	MFREE(dhd->osh, dhd->wlfc_state, sizeof(athost_wl_status_info_t));
-	dhd->wlfc_state = NULL;
-	return;
-}
-#endif /* PROP_TXSTATUS */
-
-void
-dhd_prot_dump(dhd_pub_t *dhdp, struct bcmstrbuf *strbuf)
-{
-	bcm_bprintf(strbuf, "Protocol CDC: reqid %d\n", dhdp->prot->reqid);
-#ifdef PROP_TXSTATUS
-	if (dhdp->wlfc_state)
-		dhd_wlfc_dump(dhdp, strbuf);
-#endif
-}
-
-void
-dhd_prot_hdrpush(dhd_pub_t *dhd, int ifidx, void *pktbuf)
-{
-#ifdef BDC
-	struct bdc_header *h;
-#endif /* BDC */
-
-	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
-
-#ifdef BDC
-	/* Push BDC header used to convey priority for buses that don't */
-
-	PKTPUSH(dhd->osh, pktbuf, BDC_HEADER_LEN);
-
-	h = (struct bdc_header *)PKTDATA(dhd->osh, pktbuf);
-
-	h->flags = (BDC_PROTO_VER << BDC_FLAG_VER_SHIFT);
-	if (PKTSUMNEEDED(pktbuf))
-		h->flags |= BDC_FLAG_SUM_NEEDED;
-
-
-	h->priority = (PKTPRIO(pktbuf) & BDC_PRIORITY_MASK);
-	h->flags2 = 0;
-	h->dataOffset = 0;
-#endif /* BDC */
-	BDC_SET_IF_IDX(h, ifidx);
-}
-
-int
-dhd_prot_hdrpull(dhd_pub_t *dhd, int *ifidx, void *pktbuf, uchar *reorder_buf_info,
-	uint *reorder_info_len)
-{
-#ifdef BDC
-	struct bdc_header *h;
-#endif
-
-	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
-
-#ifdef BDC
-	if (reorder_info_len)
-		*reorder_info_len = 0;
-	/* Pop BDC header used to convey priority for buses that don't */
-
-	if (PKTLEN(dhd->osh, pktbuf) < BDC_HEADER_LEN) {
-		DHD_ERROR(("%s: rx data too short (%d < %d)\n", __FUNCTION__,
-		           PKTLEN(dhd->osh, pktbuf), BDC_HEADER_LEN));
-		return BCME_ERROR;
-	}
-
-	h = (struct bdc_header *)PKTDATA(dhd->osh, pktbuf);
-
-	if ((*ifidx = BDC_GET_IF_IDX(h)) >= DHD_MAX_IFS) {
-		DHD_ERROR(("%s: rx data ifnum out of range (%d)\n",
-		           __FUNCTION__, *ifidx));
-		return BCME_ERROR;
-	}
-
-#if defined(NDIS630)
-	h->dataOffset = 0;
-#endif
-	if (((h->flags & BDC_FLAG_VER_MASK) >> BDC_FLAG_VER_SHIFT) != BDC_PROTO_VER) {
-		DHD_ERROR(("%s: non-BDC packet received, flags = 0x%x\n",
-		           dhd_ifname(dhd, *ifidx), h->flags));
-		if (((h->flags & BDC_FLAG_VER_MASK) >> BDC_FLAG_VER_SHIFT) == BDC_PROTO_VER_1)
-			h->dataOffset = 0;
-		else
-		return BCME_ERROR;
-	}
-
-	if (h->flags & BDC_FLAG_SUM_GOOD) {
-		DHD_INFO(("%s: BDC packet received with good rx-csum, flags 0x%x\n",
-		          dhd_ifname(dhd, *ifidx), h->flags));
-		PKTSETSUMGOOD(pktbuf, TRUE);
-	}
-
-	PKTSETPRIO(pktbuf, (h->priority & BDC_PRIORITY_MASK));
-	PKTPULL(dhd->osh, pktbuf, BDC_HEADER_LEN);
-#endif /* BDC */
-
-#if !defined(NDIS630)
-	if (PKTLEN(dhd->osh, pktbuf) < (uint32) (h->dataOffset << 2)) {
-		DHD_ERROR(("%s: rx data too short (%d < %d)\n", __FUNCTION__,
-		           PKTLEN(dhd->osh, pktbuf), (h->dataOffset * 4)));
-		return BCME_ERROR;
-	}
-#endif
-#ifdef PROP_TXSTATUS
-	if (dhd->wlfc_state &&
-		((athost_wl_status_info_t*)dhd->wlfc_state)->proptxstatus_mode
-		!= WLFC_FCMODE_NONE &&
-		(!DHD_PKTTAG_PKTDIR(PKTTAG(pktbuf)))) {
-		/*
-		- parse txstatus only for packets that came from the firmware
-		*/
-		dhd_os_wlfc_block(dhd);
-		dhd_wlfc_parse_header_info(dhd, pktbuf, (h->dataOffset << 2),
-			reorder_buf_info, reorder_info_len);
-		((athost_wl_status_info_t*)dhd->wlfc_state)->stats.dhd_hdrpulls++;
-		dhd_wlfc_commit_packets(dhd->wlfc_state, (f_commitpkt_t)dhd_bus_txdata,
-			(void *)dhd->bus);
-		dhd_os_wlfc_unblock(dhd);
-	}
-#endif /* PROP_TXSTATUS */
-#if !defined(NDIS630)
-		PKTPULL(dhd->osh, pktbuf, (h->dataOffset << 2));
-#endif
-	return 0;
-}
-
-int
-dhd_prot_attach(dhd_pub_t *dhd)
-{
-	dhd_prot_t *cdc;
-
-	if (!(cdc = (dhd_prot_t *)DHD_OS_PREALLOC(dhd->osh, DHD_PREALLOC_PROT,
-		sizeof(dhd_prot_t)))) {
-			DHD_ERROR(("%s: kmalloc failed\n", __FUNCTION__));
-			goto fail;
-		}
-	memset(cdc, 0, sizeof(dhd_prot_t));
-
-	/* ensure that the msg buf directly follows the cdc msg struct */
-	if ((uintptr)(&cdc->msg + 1) != (uintptr)cdc->buf) {
-		DHD_ERROR(("dhd_prot_t is not correctly defined\n"));
-		goto fail;
-	}
-
-	dhd->prot = cdc;
-#ifdef BDC
-	dhd->hdrlen += BDC_HEADER_LEN;
-#endif
-	dhd->maxctl = WLC_IOCTL_MAXLEN + sizeof(cdc_ioctl_t) + ROUND_UP_MARGIN;
-	return 0;
-
-fail:
-#ifndef CONFIG_DHD_USE_STATIC_BUF
-	if (cdc != NULL)
-		MFREE(dhd->osh, cdc, sizeof(dhd_prot_t));
-#endif /* CONFIG_DHD_USE_STATIC_BUF */
-	return BCME_NOMEM;
-}
-
-/* ~NOTE~ What if another thread is waiting on the semaphore?  Holding it? */
-void
-dhd_prot_detach(dhd_pub_t *dhd)
-{
-#ifdef PROP_TXSTATUS
-	dhd_wlfc_deinit(dhd);
-#endif
-#ifndef CONFIG_DHD_USE_STATIC_BUF
-	MFREE(dhd->osh, dhd->prot, sizeof(dhd_prot_t));
-#endif /* CONFIG_DHD_USE_STATIC_BUF */
-	dhd->prot = NULL;
-}
-
-void
-dhd_prot_dstats(dhd_pub_t *dhd)
-{
-	/* No stats from dongle added yet, copy bus stats */
-	dhd->dstats.tx_packets = dhd->tx_packets;
-	dhd->dstats.tx_errors = dhd->tx_errors;
-	dhd->dstats.rx_packets = dhd->rx_packets;
-	dhd->dstats.rx_errors = dhd->rx_errors;
-	dhd->dstats.rx_dropped = dhd->rx_dropped;
-	dhd->dstats.multicast = dhd->rx_multicast;
-	return;
-}
-
-int
-dhd_prot_init(dhd_pub_t *dhd)
-{
-	int ret = 0;
-	wlc_rev_info_t revinfo;
-	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
-
-
-	/* Get the device rev info */
-	memset(&revinfo, 0, sizeof(revinfo));
-	ret = dhd_wl_ioctl_cmd(dhd, WLC_GET_REVINFO, &revinfo, sizeof(revinfo), FALSE, 0);
-	if (ret < 0)
-		goto done;
-
-
-#ifdef PROP_TXSTATUS
-	ret = dhd_wlfc_init(dhd);
-#endif
-
-#if defined(WL_CFG80211)
-	if (dhd_download_fw_on_driverload)
-#endif /* defined(WL_CFG80211) */
-		ret = dhd_preinit_ioctls(dhd);
-
-	/* Always assumes wl for now */
-	dhd->iswl = TRUE;
-
-done:
-	return ret;
-}
-
-void
-dhd_prot_stop(dhd_pub_t *dhd)
-{
-	/* Nothing to do for CDC */
-}
-
-
-static void
-dhd_get_hostreorder_pkts(void *osh, struct reorder_info *ptr, void **pkt,
-	uint32 *pkt_count, void **pplast, uint8 start, uint8 end)
-{
-	uint i;
-	void *plast = NULL, *p;
-	uint32 pkt_cnt = 0;
+	uint i;
+	void *plast = NULL, *p;
+	uint32 pkt_cnt = 0;
 
 	if (ptr->pend_pkts == 0) {
 		DHD_REORDER(("%s: no packets in reorder queue \n", __FUNCTION__));
@@ -2599,7 +586,7 @@ dhd_get_hostreorder_pkts(void *osh, struct reorder_info *ptr, void **pkt,
 		i = ptr->max_idx + 1;
 	else {
 		if (start > end)
-			i = (ptr->max_idx - end) + start;
+			i = ((ptr->max_idx + 1) - start) + end;
 		else
 			i = end - start;
 	}
@@ -2639,8 +626,6 @@ dhd_process_pkt_reorder_info(dhd_pub_t *dhd, uchar *reorder_info_buf, uint reord
 			*pkt_count = 0;
 		return 0;
 	}
-	cur_pkt = *pkt;
-	*pkt = NULL;
 
 	flow_id = reorder_info_buf[WLHOST_REORDERDATA_FLOWID_OFFSET];
 	flags = reorder_info_buf[WLHOST_REORDERDATA_FLAGS_OFFSET];
@@ -2657,6 +642,9 @@ dhd_process_pkt_reorder_info(dhd_pub_t *dhd, uchar *reorder_info_buf, uint reord
 		return 0;
 	}
 
+	cur_pkt = *pkt;
+	*pkt = NULL;
+
 	ptr = dhd->reorder_bufs[flow_id];
 	if (flags & WLHOST_REORDERDATA_DEL_FLOW) {
 		uint32 buf_size = sizeof(struct reorder_info);
@@ -2665,9 +653,10 @@ dhd_process_pkt_reorder_info(dhd_pub_t *dhd, uchar *reorder_info_buf, uint reord
 			__FUNCTION__, flow_id));
 
 		if (ptr == NULL) {
-			DHD_ERROR(("%s: received flags to cleanup, but no flow (%d) yet\n",
+			DHD_REORDER(("%s: received flags to cleanup, but no flow (%d) yet\n",
 				__FUNCTION__, flow_id));
 			*pkt_count = 1;
+			*pkt = cur_pkt;
 			return 0;
 		}
 
diff --git a/drivers/net/wireless/bcmdhd/dhd_cfg80211.c b/drivers/net/wireless/bcmdhd/dhd_cfg80211.c
old mode 100644
new mode 100755
index 5564590..40169b5
--- a/drivers/net/wireless/bcmdhd/dhd_cfg80211.c
+++ b/drivers/net/wireless/bcmdhd/dhd_cfg80211.c
@@ -1,25 +1,7 @@
 /*
  * Linux cfg80211 driver - Dongle Host Driver (DHD) related
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * $Id: wl_cfg80211.c,v 1.1.4.1.2.14 2011/02/09 01:40:07 Exp $
  */
@@ -80,12 +62,13 @@ s32 dhd_cfg80211_set_p2p_info(struct wl_priv *wl, int val)
 {
 	dhd_pub_t *dhd =  (dhd_pub_t *)(wl->pub);
 	dhd->op_mode |= val;
-	WL_ERR(("Set : op_mode=%d\n", dhd->op_mode));
-
+	WL_ERR(("Set : op_mode=0x%04x\n", dhd->op_mode));
 #ifdef ARP_OFFLOAD_SUPPORT
-	/* IF P2P is enabled, disable arpoe */
-	dhd_arp_offload_set(dhd, 0);
-	dhd_arp_offload_enable(dhd, false);
+	if (dhd->arp_version == 1) {
+		/* IF P2P is enabled, disable arpoe */
+		dhd_arp_offload_set(dhd, 0);
+		dhd_arp_offload_enable(dhd, false);
+	}
 #endif /* ARP_OFFLOAD_SUPPORT */
 
 	return 0;
@@ -94,13 +77,15 @@ s32 dhd_cfg80211_set_p2p_info(struct wl_priv *wl, int val)
 s32 dhd_cfg80211_clean_p2p_info(struct wl_priv *wl)
 {
 	dhd_pub_t *dhd =  (dhd_pub_t *)(wl->pub);
-	dhd->op_mode &= ~CONCURENT_MASK;
-	WL_ERR(("Clean : op_mode=%d\n", dhd->op_mode));
+	dhd->op_mode &= ~(DHD_FLAG_P2P_GC_MODE | DHD_FLAG_P2P_GO_MODE);
+	WL_ERR(("Clean : op_mode=0x%04x\n", dhd->op_mode));
 
 #ifdef ARP_OFFLOAD_SUPPORT
-	/* IF P2P is disabled, enable arpoe back for STA mode. */
-	dhd_arp_offload_set(dhd, dhd_arp_mode);
-	dhd_arp_offload_enable(dhd, true);
+	if (dhd->arp_version == 1) {
+		/* IF P2P is disabled, enable arpoe back for STA mode. */
+		dhd_arp_offload_set(dhd, dhd_arp_mode);
+		dhd_arp_offload_enable(dhd, true);
+	}
 #endif /* ARP_OFFLOAD_SUPPORT */
 
 	return 0;
@@ -149,6 +134,43 @@ default_conf_out:
 
 }
 
+#ifdef CONFIG_NL80211_TESTMODE
+int dhd_cfg80211_testmode_cmd(struct wiphy *wiphy, void *data, int len)
+{
+	struct sk_buff *reply;
+	struct wl_priv *wl;
+	dhd_pub_t *dhd;
+	dhd_ioctl_t *ioc = data;
+	int err = 0;
+
+	WL_TRACE(("entry: cmd = %d\n", ioc->cmd));
+	wl = wiphy_priv(wiphy);
+	dhd = wl->pub;
+
+	DHD_OS_WAKE_LOCK(dhd);
+
+	/* send to dongle only if we are not waiting for reload already */
+	if (dhd->hang_was_sent) {
+		WL_ERR(("HANG was sent up earlier\n"));
+		DHD_OS_WAKE_LOCK_CTRL_TIMEOUT_ENABLE(dhd, DHD_EVENT_TIMEOUT_MS);
+		DHD_OS_WAKE_UNLOCK(dhd);
+		return OSL_ERROR(BCME_DONGLE_DOWN);
+	}
+
+	/* currently there is only one wiphy for ifidx 0 */
+	err = dhd_ioctl_process(dhd, 0, ioc);
+	if (err)
+		goto done;
+
+	/* response data is in ioc->buf so return ioc here */
+	reply = cfg80211_testmode_alloc_reply_skb(wiphy, sizeof(*ioc));
+	nla_put(reply, NL80211_ATTR_TESTDATA, sizeof(*ioc), ioc);
+	err = cfg80211_testmode_reply(reply);
+done:
+	DHD_OS_WAKE_UNLOCK(dhd);
+	return err;
+}
+#endif /* CONFIG_NL80211_TESTMODE */
 
 /* TODO: clean up the BT-Coex code, it still have some legacy ioctl/iovar functions */
 #define COEX_DHCP
@@ -234,11 +256,10 @@ static bool btcoex_is_sco_active(struct net_device *dev)
 
 		ioc_res = dev_wlc_intvar_get_reg(dev, "btc_params", 27, &param27);
 
-		WL_TRACE(("%s, sample[%d], btc params: 27:%x\n",
-			__FUNCTION__, i, param27));
+		WL_TRACE(("sample[%d], btc params: 27:%x\n", i, param27));
 
 		if (ioc_res < 0) {
-			WL_ERR(("%s ioc read btc params error\n", __FUNCTION__));
+			WL_ERR(("ioc read btc params error\n"));
 			break;
 		}
 
@@ -247,8 +268,8 @@ static bool btcoex_is_sco_active(struct net_device *dev)
 		}
 
 		if (sco_id_cnt > 2) {
-			WL_TRACE(("%s, sco/esco detected, pkt id_cnt:%d  samples:%d\n",
-				__FUNCTION__, sco_id_cnt, i));
+			WL_TRACE(("sco/esco detected, pkt id_cnt:%d  samples:%d\n",
+				sco_id_cnt, i));
 			res = TRUE;
 			break;
 		}
@@ -296,9 +317,9 @@ static int set_btc_esco_params(struct net_device *dev, bool trump_sco)
 			(!dev_wlc_intvar_get_reg(dev, "btc_params", 65, &saved_reg65)) &&
 			(!dev_wlc_intvar_get_reg(dev, "btc_params", 71, &saved_reg71))) {
 			saved_status = TRUE;
-			WL_TRACE(("%s saved bt_params[50,51,64,65,71]:"
+			WL_TRACE(("saved bt_params[50,51,64,65,71]:"
 				  "0x%x 0x%x 0x%x 0x%x 0x%x\n",
-				  __FUNCTION__, saved_reg50, saved_reg51,
+				  saved_reg50, saved_reg51,
 				  saved_reg64, saved_reg65, saved_reg71));
 		} else {
 			WL_ERR((":%s: save btc_params failed\n",
@@ -395,7 +416,7 @@ wl_cfg80211_bt_setflag(struct net_device *dev, bool set)
 static void wl_cfg80211_bt_timerfunc(ulong data)
 {
 	struct btcoex_info *bt_local = (struct btcoex_info *)data;
-	WL_TRACE(("%s\n", __FUNCTION__));
+	WL_TRACE(("Enter\n"));
 	bt_local->timer_on = 0;
 	schedule_work(&bt_local->work);
 }
@@ -416,43 +437,39 @@ static void wl_cfg80211_bt_handler(struct work_struct *work)
 			/* DHCP started
 			 * provide OPPORTUNITY window to get DHCP address
 			 */
-			WL_TRACE(("%s bt_dhcp stm: started \n",
-				__FUNCTION__));
+			WL_TRACE(("bt_dhcp stm: started \n"));
+
 			btcx_inf->bt_state = BT_DHCP_OPPR_WIN;
 			mod_timer(&btcx_inf->timer,
-				jiffies + BT_DHCP_OPPR_WIN_TIME*HZ/1000);
+				jiffies + msecs_to_jiffies(BT_DHCP_OPPR_WIN_TIME));
 			btcx_inf->timer_on = 1;
 			break;
 
 		case BT_DHCP_OPPR_WIN:
 			if (btcx_inf->dhcp_done) {
-				WL_TRACE(("%s DHCP Done before T1 expiration\n",
-					__FUNCTION__));
+				WL_TRACE(("DHCP Done before T1 expiration\n"));
 				goto btc_coex_idle;
 			}
 
 			/* DHCP is not over yet, start lowering BT priority
 			 * enforce btc_params + flags if necessary
 			 */
-			WL_TRACE(("%s DHCP T1:%d expired\n", __FUNCTION__,
-				BT_DHCP_OPPR_WIN_TIME));
+			WL_TRACE(("DHCP T1:%d expired\n", BT_DHCP_OPPR_WIN_TIME));
 			if (btcx_inf->dev)
 				wl_cfg80211_bt_setflag(btcx_inf->dev, TRUE);
 			btcx_inf->bt_state = BT_DHCP_FLAG_FORCE_TIMEOUT;
 			mod_timer(&btcx_inf->timer,
-				jiffies + BT_DHCP_FLAG_FORCE_TIME*HZ/1000);
+				jiffies + msecs_to_jiffies(BT_DHCP_FLAG_FORCE_TIME));
 			btcx_inf->timer_on = 1;
 			break;
 
 		case BT_DHCP_FLAG_FORCE_TIMEOUT:
 			if (btcx_inf->dhcp_done) {
-				WL_TRACE(("%s DHCP Done before T2 expiration\n",
-					__FUNCTION__));
+				WL_TRACE(("DHCP Done before T2 expiration\n"));
 			} else {
 				/* Noo dhcp during T1+T2, restore BT priority */
-				WL_TRACE(("%s DHCP wait interval T2:%d"
-					  "msec expired\n", __FUNCTION__,
-					  BT_DHCP_FLAG_FORCE_TIME));
+				WL_TRACE(("DHCP wait interval T2:%d msec expired\n",
+					BT_DHCP_FLAG_FORCE_TIME));
 			}
 
 			/* Restoring default bt priority */
@@ -464,8 +481,7 @@ btc_coex_idle:
 			break;
 
 		default:
-			WL_ERR(("%s error g_status=%d !!!\n", __FUNCTION__,
-				btcx_inf->bt_state));
+			WL_ERR(("error g_status=%d !!!\n",	btcx_inf->bt_state));
 			if (btcx_inf->dev)
 				wl_cfg80211_bt_setflag(btcx_inf->dev, FALSE);
 			btcx_inf->bt_state = BT_DHCP_IDLE;
@@ -506,7 +522,7 @@ void wl_cfg80211_btcoex_deinit(struct wl_priv *wl)
 	if (!wl->btcoex_info)
 		return;
 
-	if (!wl->btcoex_info->timer_on) {
+	if (wl->btcoex_info->timer_on) {
 		wl->btcoex_info->timer_on = 0;
 		del_timer_sync(&wl->btcoex_info->timer);
 	}
@@ -516,7 +532,6 @@ void wl_cfg80211_btcoex_deinit(struct wl_priv *wl)
 	kfree(wl->btcoex_info);
 	wl->btcoex_info = NULL;
 }
-#endif 
 
 int wl_cfg80211_set_btcoex_dhcp(struct net_device *dev, char *command)
 {
@@ -540,26 +555,37 @@ int wl_cfg80211_set_btcoex_dhcp(struct net_device *dev, char *command)
 
 #ifdef PKT_FILTER_SUPPORT
 	dhd_pub_t *dhd =  (dhd_pub_t *)(wl->pub);
-	int i;
 #endif
 
 	/* Figure out powermode 1 or o command */
 	strncpy((char *)&powermode_val, command + strlen("BTCOEXMODE") +1, 1);
 
 	if (strnicmp((char *)&powermode_val, "1", strlen("1")) == 0) {
+		WL_TRACE_HW4(("DHCP session starts\n"));
 
-		WL_TRACE(("%s: DHCP session starts\n", __FUNCTION__));
+#if defined(DHCP_SCAN_SUPPRESS)
+{
+	int ret;
+	dhd_pub_t *dhd =  (dhd_pub_t *)(wl->pub);
+        uint32 mpc = 0;
+	char iovbuf[28];
+
+        bcm_mkiovar("mpc", (char *)&mpc, 4, iovbuf, sizeof(iovbuf));
+        if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0) 
+        {
+                WL_ERR(("%s DHCP_SCAN_SUPPRESS: set mpc=0 failed: %d\n", __FUNCTION__,ret));
+        }
+}
+		/* Suppress scan during the DHCP */
+		wl_cfg80211_scan_suppress(dev, 1);
+#endif /* OEM_ANDROID */
 
 #ifdef PKT_FILTER_SUPPORT
 		dhd->dhcp_in_progress = 1;
 
-		/* Disable packet filtering */
-		if (dhd_pkt_filter_enable && dhd->early_suspended) {
-			WL_TRACE(("DHCP in progressing , disable packet filter!!!\n"));
-			for (i = 0; i < dhd->pktfilter_count; i++) {
-				dhd_pktfilter_offload_enable(dhd, dhd->pktfilter[i],
-				 0, dhd_master_mode);
-			}
+		if (dhd->early_suspended) {
+			WL_TRACE_HW4(("DHCP in progressing , disable packet filter!!!\n"));
+			dhd_enable_packet_filter(0, dhd);
 		}
 #endif
 
@@ -595,44 +621,57 @@ int wl_cfg80211_set_btcoex_dhcp(struct net_device *dev, char *command)
 					btco_inf->bt_state = BT_DHCP_START;
 					btco_inf->timer_on = 1;
 					mod_timer(&btco_inf->timer, btco_inf->timer.expires);
-					WL_TRACE(("%s enable BT DHCP Timer\n",
-					__FUNCTION__));
+					WL_TRACE(("enable BT DHCP Timer\n"));
 				}
 #endif /* COEX_DHCP */
 		}
 		else if (saved_status == TRUE) {
-			WL_ERR(("%s was called w/o DHCP OFF. Continue\n", __FUNCTION__));
+			WL_ERR(("was called w/o DHCP OFF. Continue\n"));
 		}
 	}
 	else if (strnicmp((char *)&powermode_val, "2", strlen("2")) == 0) {
 
 
+#if defined(DHCP_SCAN_SUPPRESS)
+{
+	int ret;
+	dhd_pub_t *dhd =  (dhd_pub_t *)(wl->pub);
+        uint32 mpc = 1;
+	char iovbuf[28];
+
+        bcm_mkiovar("mpc", (char *)&mpc, 4, iovbuf, sizeof(iovbuf));
+        if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0) 
+        {
+               WL_ERR(("%s DHCP_SCAN_SUPPRESS: set mpc=1 failed: %d\n", __FUNCTION__,ret));
+        }
+}
+		/* Since DHCP is complete, enable the scan back */
+		wl_cfg80211_scan_suppress(dev, 0);
+#endif /* OEM_ANDROID */
+
 #ifdef PKT_FILTER_SUPPORT
 		dhd->dhcp_in_progress = 0;
+		WL_TRACE_HW4(("DHCP is complete \n"));
 
 		/* Enable packet filtering */
-		if (dhd_pkt_filter_enable && dhd->early_suspended) {
-			WL_TRACE(("DHCP is complete , enable packet filter!!!\n"));
-			for (i = 0; i < dhd->pktfilter_count; i++) {
-				dhd_pktfilter_offload_enable(dhd, dhd->pktfilter[i],
-				 1, dhd_master_mode);
-			}
+		if (dhd->early_suspended) {
+			WL_TRACE_HW4(("DHCP is complete , enable packet filter!!!\n"));
+			dhd_enable_packet_filter(1, dhd);
 		}
-#endif
+#endif /* PKT_FILTER_SUPPORT */
 
 		/* Restoring PM mode */
 
 #ifdef COEX_DHCP
 		/* Stop any bt timer because DHCP session is done */
-		WL_TRACE(("%s disable BT DHCP Timer\n", __FUNCTION__));
+		WL_TRACE(("disable BT DHCP Timer\n"));
 		if (btco_inf->timer_on) {
 			btco_inf->timer_on = 0;
 			del_timer_sync(&btco_inf->timer);
 
 			if (btco_inf->bt_state != BT_DHCP_IDLE) {
 			/* need to restore original btc flags & extra btc params */
-				WL_TRACE(("%s bt->bt_state:%d\n",
-					__FUNCTION__, btco_inf->bt_state));
+				WL_TRACE(("bt->bt_state:%d\n", btco_inf->bt_state));
 				/* wake up btcoex thread to restore btlags+params  */
 				schedule_work(&btco_inf->work);
 			}
@@ -663,11 +702,11 @@ int wl_cfg80211_set_btcoex_dhcp(struct net_device *dev, char *command)
 
 	}
 	else {
-		WL_ERR(("%s Unkwown yet power setting, ignored\n",
-			__FUNCTION__));
+		WL_ERR(("Unkwown yet power setting, ignored\n"));
 	}
 
 	snprintf(command, 3, "OK");
 
 	return (strlen("OK"));
 }
+#endif 
diff --git a/drivers/net/wireless/bcmdhd/dhd_cfg80211.h b/drivers/net/wireless/bcmdhd/dhd_cfg80211.h
old mode 100644
new mode 100755
index 922d6ed..04fdbe0
--- a/drivers/net/wireless/bcmdhd/dhd_cfg80211.h
+++ b/drivers/net/wireless/bcmdhd/dhd_cfg80211.h
@@ -1,25 +1,7 @@
 /*
  * Linux cfg80211 driver - Dongle Host Driver (DHD) related
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * $Id: wl_cfg80211.c,v 1.1.4.1.2.14 2011/02/09 01:40:07 Exp $
  */
@@ -38,6 +20,15 @@ s32 dhd_cfg80211_set_p2p_info(struct wl_priv *wl, int val);
 s32 dhd_cfg80211_clean_p2p_info(struct wl_priv *wl);
 s32 dhd_config_dongle(struct wl_priv *wl, bool need_lock);
 
+#ifdef CONFIG_NL80211_TESTMODE
+int dhd_cfg80211_testmode_cmd(struct wiphy *wiphy, void *data, int len);
+#else
+static inline int dhd_cfg80211_testmode_cmd(struct wiphy *wiphy, void *data, int len)
+{
+	return 0;
+}
+#endif
+
 int wl_cfg80211_btcoex_init(struct wl_priv *wl);
 void wl_cfg80211_btcoex_deinit(struct wl_priv *wl);
 
diff --git a/drivers/net/wireless/bcmdhd/dhd_common.c b/drivers/net/wireless/bcmdhd/dhd_common.c
old mode 100644
new mode 100755
index 5803554..19d5f60
--- a/drivers/net/wireless/bcmdhd/dhd_common.c
+++ b/drivers/net/wireless/bcmdhd/dhd_common.c
@@ -1,27 +1,9 @@
 /*
  * Broadcom Dongle Host Driver (DHD), common DHD core.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: dhd_common.c 327331 2012-04-13 01:42:33Z $
+ * $Id: dhd_common.c 395161 2013-04-05 13:19:38Z $
  */
 #include <typedefs.h>
 #include <osl.h>
@@ -33,6 +15,7 @@
 #include <dngl_stats.h>
 #include <wlioctl.h>
 #include <dhd.h>
+#include <dhd_ip.h>
 
 #include <proto/bcmevent.h>
 
@@ -65,7 +48,6 @@
 #include <dhd_wlfc.h>
 #endif
 
-
 #ifdef WLMEDIA_HTSF
 extern void htsf_update(struct dhd_info *dhd, void *data);
 #endif
@@ -93,6 +75,9 @@ extern int dhd_iscan_in_progress(void *h);
 void dhd_iscan_lock(void);
 void dhd_iscan_unlock(void);
 extern int dhd_change_mtu(dhd_pub_t *dhd, int new_mtu, int ifidx);
+#if !defined(AP) && defined(WLP2P)
+extern int dhd_get_concurrent_capabilites(dhd_pub_t *dhd);
+#endif
 bool ap_cfg_running = FALSE;
 bool ap_fw_loaded = FALSE;
 
@@ -131,7 +116,12 @@ enum {
 #ifdef PROP_TXSTATUS
 	IOV_PROPTXSTATUS_ENABLE,
 	IOV_PROPTXSTATUS_MODE,
-#endif
+	IOV_PROPTXSTATUS_OPT,
+#ifdef QMONITOR
+	IOV_QMON_TIME_THRES,
+	IOV_QMON_TIME_PERCENT,
+#endif /* QMONITOR */
+#endif /* PROP_TXSTATUS */
 	IOV_BUS_TYPE,
 #ifdef WLMEDIA_HTSF
 	IOV_WLPKTDLYSTAT_SZ,
@@ -170,7 +160,12 @@ const bcm_iovar_t dhd_iovars[] = {
 	2 - Use explicit credit
 	*/
 	{"ptxmode",	IOV_PROPTXSTATUS_MODE,	0,	IOVT_UINT32,	0 },
-#endif
+	{"proptx_opt", IOV_PROPTXSTATUS_OPT, 	0,	IOVT_UINT32,	0 },
+#ifdef QMONITOR
+	{"qtime_thres",	IOV_QMON_TIME_THRES,	0,	IOVT_UINT32,	0 },
+	{"qtime_percent", IOV_QMON_TIME_PERCENT, 0,	IOVT_UINT32,	0 },
+#endif /* QMONITOR */
+#endif /* PROP_TXSTATUS */
 	{"bustype", IOV_BUS_TYPE, 0, IOVT_UINT32, 0},
 #ifdef WLMEDIA_HTSF
 	{"pktdlystatsz", IOV_WLPKTDLYSTAT_SZ, 0, IOVT_UINT8, 0 },
@@ -199,6 +194,28 @@ dhd_common_init(osl_t *osh)
 #endif
 }
 
+void
+dhd_common_deinit(dhd_pub_t *dhd_pub, dhd_cmn_t *sa_cmn)
+{
+	osl_t *osh;
+	dhd_cmn_t *cmn;
+
+	if (dhd_pub != NULL)
+		cmn = dhd_pub->cmn;
+	else
+		cmn = sa_cmn;
+
+	if (!cmn)
+		return;
+
+	osh = cmn->osh;
+
+	if (dhd_pub != NULL)
+		dhd_pub->cmn = NULL;
+
+	MFREE(osh, cmn, sizeof(dhd_cmn_t));
+}
+
 static int
 dhd_dump(dhd_pub_t *dhdp, char *buf, int buflen)
 {
@@ -214,31 +231,31 @@ dhd_dump(dhd_pub_t *dhdp, char *buf, int buflen)
 	bcm_bprintf(strbuf, "\n");
 	bcm_bprintf(strbuf, "pub.up %d pub.txoff %d pub.busstate %d\n",
 	            dhdp->up, dhdp->txoff, dhdp->busstate);
-	bcm_bprintf(strbuf, "pub.hdrlen %d pub.maxctl %d pub.rxsz %d\n",
+	bcm_bprintf(strbuf, "pub.hdrlen %u pub.maxctl %u pub.rxsz %u\n",
 	            dhdp->hdrlen, dhdp->maxctl, dhdp->rxsz);
 	bcm_bprintf(strbuf, "pub.iswl %d pub.drv_version %ld pub.mac %s\n",
 	            dhdp->iswl, dhdp->drv_version, bcm_ether_ntoa(&dhdp->mac, eabuf));
-	bcm_bprintf(strbuf, "pub.bcmerror %d tickcnt %d\n", dhdp->bcmerror, dhdp->tickcnt);
+	bcm_bprintf(strbuf, "pub.bcmerror %d tickcnt %u\n", dhdp->bcmerror, dhdp->tickcnt);
 
 	bcm_bprintf(strbuf, "dongle stats:\n");
-	bcm_bprintf(strbuf, "tx_packets %ld tx_bytes %ld tx_errors %ld tx_dropped %ld\n",
+	bcm_bprintf(strbuf, "tx_packets %lu tx_bytes %lu tx_errors %lu tx_dropped %lu\n",
 	            dhdp->dstats.tx_packets, dhdp->dstats.tx_bytes,
 	            dhdp->dstats.tx_errors, dhdp->dstats.tx_dropped);
-	bcm_bprintf(strbuf, "rx_packets %ld rx_bytes %ld rx_errors %ld rx_dropped %ld\n",
+	bcm_bprintf(strbuf, "rx_packets %lu rx_bytes %lu rx_errors %lu rx_dropped %lu\n",
 	            dhdp->dstats.rx_packets, dhdp->dstats.rx_bytes,
 	            dhdp->dstats.rx_errors, dhdp->dstats.rx_dropped);
-	bcm_bprintf(strbuf, "multicast %ld\n", dhdp->dstats.multicast);
+	bcm_bprintf(strbuf, "multicast %lu\n", dhdp->dstats.multicast);
 
 	bcm_bprintf(strbuf, "bus stats:\n");
-	bcm_bprintf(strbuf, "tx_packets %ld tx_multicast %ld tx_errors %ld\n",
+	bcm_bprintf(strbuf, "tx_packets %lu tx_multicast %lu tx_errors %lu\n",
 	            dhdp->tx_packets, dhdp->tx_multicast, dhdp->tx_errors);
-	bcm_bprintf(strbuf, "tx_ctlpkts %ld tx_ctlerrs %ld\n",
+	bcm_bprintf(strbuf, "tx_ctlpkts %lu tx_ctlerrs %lu\n",
 	            dhdp->tx_ctlpkts, dhdp->tx_ctlerrs);
-	bcm_bprintf(strbuf, "rx_packets %ld rx_multicast %ld rx_errors %ld \n",
+	bcm_bprintf(strbuf, "rx_packets %lu rx_multicast %lu rx_errors %lu \n",
 	            dhdp->rx_packets, dhdp->rx_multicast, dhdp->rx_errors);
-	bcm_bprintf(strbuf, "rx_ctlpkts %ld rx_ctlerrs %ld rx_dropped %ld\n",
+	bcm_bprintf(strbuf, "rx_ctlpkts %lu rx_ctlerrs %lu rx_dropped %lu\n",
 	            dhdp->rx_ctlpkts, dhdp->rx_ctlerrs, dhdp->rx_dropped);
-	bcm_bprintf(strbuf, "rx_readahead_cnt %ld tx_realloc %ld\n",
+	bcm_bprintf(strbuf, "rx_readahead_cnt %lu tx_realloc %lu\n",
 	            dhdp->rx_readahead_cnt, dhdp->tx_realloc);
 	bcm_bprintf(strbuf, "\n");
 
@@ -269,15 +286,20 @@ dhd_wl_ioctl_cmd(dhd_pub_t *dhd_pub, int cmd, void *arg, int len, uint8 set, int
 int
 dhd_wl_ioctl(dhd_pub_t *dhd_pub, int ifindex, wl_ioctl_t *ioc, void *buf, int len)
 {
-	int ret;
+	int ret = 0;
 
-	dhd_os_proto_block(dhd_pub);
+	if (dhd_os_proto_block(dhd_pub))
+	{
+
+		ret = dhd_prot_ioctl(dhd_pub, ifindex, ioc, buf, len);
+		if ((ret) && (dhd_pub->up))
+			/* Send hang event only if dhd_open() was success */
+			dhd_os_check_hang(dhd_pub, ifindex, ret);
+
+		dhd_os_proto_unblock(dhd_pub);
 
-	ret = dhd_prot_ioctl(dhd_pub, ifindex, ioc, buf, len);
-	if (!ret)
-		dhd_os_check_hang(dhd_pub, ifindex, ret);
 
-	dhd_os_proto_unblock(dhd_pub);
+	}
 	return ret;
 }
 
@@ -309,12 +331,15 @@ dhd_doiovar(dhd_pub_t *dhd_pub, const bcm_iovar_t *vi, uint32 actionid, const ch
 		break;
 
 	case IOV_SVAL(IOV_MSGLEVEL):
-		dhd_msg_level = int_val;
 #ifdef WL_CFG80211
 		/* Enable DHD and WL logs in oneshot */
-		if (dhd_msg_level & DHD_WL_VAL)
-			wl_cfg80211_enable_trace(dhd_msg_level);
-#endif
+		if (int_val & DHD_WL_VAL2)
+			wl_cfg80211_enable_trace(TRUE, int_val & (~DHD_WL_VAL2));
+		else if (int_val & DHD_WL_VAL)
+			wl_cfg80211_enable_trace(FALSE, WL_DBG_DBG);
+		if (!(int_val & DHD_WL_VAL2))
+#endif /* WL_CFG80211 */
+		dhd_msg_level = int_val;
 		break;
 	case IOV_GVAL(IOV_BCMERRORSTR):
 		bcm_strncpy_s((char *)arg, len, bcmerrorstr(dhd_pub->bcmerror), BCME_STRLEN);
@@ -461,6 +486,24 @@ dhd_doiovar(dhd_pub_t *dhd_pub, const bcm_iovar_t *vi, uint32 actionid, const ch
 			wlfc->proptxstatus_mode = int_val & 0xff;
 		}
 		break;
+#ifdef QMONITOR
+	case IOV_GVAL(IOV_QMON_TIME_THRES): {
+		int_val = dhd_qmon_thres(dhd_pub, FALSE, 0);
+		bcopy(&int_val, arg, val_size);
+		break;
+	}
+
+	case IOV_SVAL(IOV_QMON_TIME_THRES): {
+		dhd_qmon_thres(dhd_pub, TRUE, int_val);
+		break;
+	}
+
+	case IOV_GVAL(IOV_QMON_TIME_PERCENT): {
+		int_val = dhd_qmon_getpercent(dhd_pub);
+		bcopy(&int_val, arg, val_size);
+		break;
+	}
+#endif /* QMONITOR */
 #endif /* PROP_TXSTATUS */
 
 	case IOV_GVAL(IOV_BUS_TYPE):
@@ -580,6 +623,89 @@ dhd_prec_enq(dhd_pub_t *dhdp, struct pktq *q, void *pkt, int prec)
 	return TRUE;
 }
 
+/*
+ * Functions to drop proper pkts from queue:
+ *	If one pkt in queue is non-fragmented, drop first non-fragmented pkt only
+ *	If all pkts in queue are all fragmented, find and drop one whole set fragmented pkts
+ *	If can't find pkts matching upper 2 cases, drop first pkt anyway
+ */
+bool
+dhd_prec_drop_pkts(osl_t *osh, struct pktq *pq, int prec)
+{
+	struct pktq_prec *q = NULL;
+	void *p, *prev = NULL, *next = NULL, *first = NULL, *last = NULL, *prev_first = NULL;
+	pkt_frag_t frag_info;
+
+	ASSERT(osh && pq);
+	ASSERT(prec >= 0 && prec < pq->num_prec);
+
+	q = &pq->q[prec];
+	p = q->head;
+
+	if (p == NULL)
+		return FALSE;
+
+	while (p) {
+		frag_info = pkt_frag_info(osh, p);
+		if (frag_info == DHD_PKT_FRAG_NONE) {
+			break;
+		} else if (frag_info == DHD_PKT_FRAG_FIRST) {
+			if (first) {
+				/* No last frag pkt, use prev as last */
+				last = prev;
+			} else {
+				first = p;
+				prev_first = prev;
+			}
+		} else if (frag_info == DHD_PKT_FRAG_LAST) {
+			if (first) {
+				last = p;
+				break;
+			}
+		}
+
+		prev = p;
+		p = PKTLINK(p);
+	}
+
+	if ((p == NULL) || ((frag_info != DHD_PKT_FRAG_NONE) && !(first && last))) {
+		/* Not found matching pkts, use oldest */
+		prev = NULL;
+		p = q->head;
+		frag_info = 0;
+	}
+
+	if (frag_info == DHD_PKT_FRAG_NONE) {
+		first = last = p;
+		prev_first = prev;
+	}
+
+	p = first;
+	while (p) {
+		next = PKTLINK(p);
+		q->len--;
+		pq->len--;
+
+		PKTSETLINK(p, NULL);
+
+		PKTFREE(osh, p, TRUE);
+
+		if (p == last)
+			break;
+
+		p = next;
+	}
+
+	if (prev_first == NULL) {
+		if ((q->head = next) == NULL)
+			q->tail = NULL;
+	} else {
+		PKTSETLINK(prev_first, next);
+	}
+
+	return TRUE;
+}
+
 static int
 dhd_iovar_op(dhd_pub_t *dhd_pub, const char *name,
 	void *params, int plen, void *arg, int len, bool set)
@@ -653,7 +779,7 @@ dhd_ioctl(dhd_pub_t * dhd_pub, dhd_ioctl_t *ioc, void * buf, uint buflen)
 
 	case DHD_GET_VERSION:
 		if (buflen < sizeof(int))
-			bcmerror = -BCME_BUFTOOSHORT;
+			bcmerror = BCME_BUFTOOSHORT;
 		else
 			*(int*)buf = DHD_IOCTL_VERSION;
 		break;
@@ -734,7 +860,7 @@ wl_show_host_event(wl_event_msg_t *event, void *event_data)
 	datalen = ntoh32(event->datalen);
 
 	/* debug dump of event messages */
-	sprintf(eabuf, "%02x:%02x:%02x:%02x:%02x:%02x",
+	snprintf(eabuf, sizeof(eabuf), "%02x:%02x:%02x:%02x:%02x:%02x",
 	        (uchar)event->addr.octet[0]&0xff,
 	        (uchar)event->addr.octet[1]&0xff,
 	        (uchar)event->addr.octet[2]&0xff,
@@ -794,7 +920,7 @@ wl_show_host_event(wl_event_msg_t *event, void *event_data)
 		else if (auth_type == DOT11_SHARED_KEY)
 			auth_str = "Shared Key";
 		else {
-			sprintf(err_msg, "AUTH unknown: %d", (int)auth_type);
+			snprintf(err_msg, sizeof(err_msg), "AUTH unknown: %d", (int)auth_type);
 			auth_str = err_msg;
 		}
 		if (event_type == WLC_E_AUTH_IND) {
@@ -890,6 +1016,7 @@ wl_show_host_event(wl_event_msg_t *event, void *event_data)
 
 	case WLC_E_TRACE: {
 		static uint32 seqnum_prev = 0;
+		static uint32 logtrace_seqnum_prev = 0;
 		msgtrace_hdr_t hdr;
 		uint32 nblost;
 		char *s, *p;
@@ -906,35 +1033,72 @@ wl_show_host_event(wl_event_msg_t *event, void *event_data)
 			break;
 		}
 
-		/* There are 2 bytes available at the end of data */
-		buf[MSGTRACE_HDRLEN + ntoh16(hdr.len)] = '\0';
+		if (hdr.trace_type == MSGTRACE_HDR_TYPE_MSG) {
+			/* There are 2 bytes available at the end of data */
+			buf[MSGTRACE_HDRLEN + ntoh16(hdr.len)] = '\0';
 
-		if (ntoh32(hdr.discarded_bytes) || ntoh32(hdr.discarded_printf)) {
-			printf("\nWLC_E_TRACE: [Discarded traces in dongle -->"
-			       "discarded_bytes %d discarded_printf %d]\n",
-			       ntoh32(hdr.discarded_bytes), ntoh32(hdr.discarded_printf));
-		}
+			if (ntoh32(hdr.discarded_bytes) || ntoh32(hdr.discarded_printf)) {
+				printf("\nWLC_E_TRACE: [Discarded traces in dongle -->"
+				       "discarded_bytes %d discarded_printf %d]\n",
+				       ntoh32(hdr.discarded_bytes), ntoh32(hdr.discarded_printf));
+			}
 
-		nblost = ntoh32(hdr.seqnum) - seqnum_prev - 1;
-		if (nblost > 0) {
-			printf("\nWLC_E_TRACE: [Event lost --> seqnum %d nblost %d\n",
-			       ntoh32(hdr.seqnum), nblost);
-		}
-		seqnum_prev = ntoh32(hdr.seqnum);
-
-		/* Display the trace buffer. Advance from \n to \n to avoid display big
-		 * printf (issue with Linux printk )
-		 */
-		p = (char *)&buf[MSGTRACE_HDRLEN];
-		while ((s = strstr(p, "\n")) != NULL) {
-			*s = '\0';
-			printf("%s\n", p);
-			p = s+1;
+			nblost = ntoh32(hdr.seqnum) - seqnum_prev - 1;
+			if (nblost > 0) {
+				printf("\nWLC_E_TRACE: [Event lost (msg) --> seqnum %d nblost %d\n",
+				       ntoh32(hdr.seqnum), nblost);
+			}
+			seqnum_prev = ntoh32(hdr.seqnum);
+
+			/* Display the trace buffer. Advance from \n to \n to avoid display big
+			 * printf (issue with Linux printk )
+			 */
+			p = (char *)&buf[MSGTRACE_HDRLEN];
+		while (*p != '\0' && (s = strstr(p, "\n")) != NULL) {
+				*s = '\0';
+				printf("%s\n", p);
+				p = s+1;
+			}
+			if (*p) printf("%s", p);
+
+			/* Reset datalen to avoid display below */
+			datalen = 0;
+
+		} else if (hdr.trace_type == MSGTRACE_HDR_TYPE_LOG) {
+			/* Let the standard event printing work for now */
+			uint32 timestamp, w;
+			if (ntoh32(hdr.seqnum) == logtrace_seqnum_prev) {
+				printf("\nWLC_E_TRACE: [Event duplicate (log) %d",
+				       logtrace_seqnum_prev);
+			} else {
+				nblost = ntoh32(hdr.seqnum) - logtrace_seqnum_prev - 1;
+				if (nblost > 0) {
+					printf("\nWLC_E_TRACE: [Event lost (log)"
+					       " --> seqnum %d nblost %d\n",
+					       ntoh32(hdr.seqnum), nblost);
+				}
+				logtrace_seqnum_prev = ntoh32(hdr.seqnum);
+
+				p = (char *)&buf[MSGTRACE_HDRLEN];
+				datalen -= MSGTRACE_HDRLEN;
+				w = ntoh32((uint32) *p);
+				p += 4;
+				datalen -= 4;
+				timestamp = ntoh32((uint32) *p);
+				printf("Logtrace %x timestamp %x %x",
+				       logtrace_seqnum_prev, timestamp, w);
+
+				while (datalen > 4) {
+					p += 4;
+					datalen -= 4;
+					/* Print each word.  DO NOT ntoh it.  */
+					printf(" %8.8x", *((uint32 *) p));
+				}
+				printf("\n");
+			}
+			datalen = 0;
 		}
-		printf("%s\n", p);
 
-		/* Reset datalen to avoid display below */
-		datalen = 0;
 		break;
 	}
 
@@ -943,6 +1107,12 @@ wl_show_host_event(wl_event_msg_t *event, void *event_data)
 		DHD_EVENT(("MACEVENT: %s %d\n", event_name, ntoh32(*((int *)event_data))));
 		break;
 
+	case WLC_E_SERVICE_FOUND:
+	case WLC_E_P2PO_ADD_DEVICE:
+	case WLC_E_P2PO_DEL_DEVICE:
+		DHD_EVENT(("MACEVENT: %s, MAC %s\n", event_name, eabuf));
+		break;
+
 	default:
 		DHD_EVENT(("MACEVENT: %s %d, MAC %s, status %d, reason %d, auth %d\n",
 		       event_name, event_type, eabuf, (int)status, (int)reason,
@@ -998,8 +1168,10 @@ wl_host_event(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata,
 	switch (type) {
 #ifdef PROP_TXSTATUS
 	case WLC_E_FIFO_CREDIT_MAP:
+		dhd_os_wlfc_block(dhd_pub);
 		dhd_wlfc_event(dhd_pub->info);
 		dhd_wlfc_FIFOcreditmap_event(dhd_pub->info, event_data);
+		dhd_os_wlfc_unblock(dhd_pub);
 		WLFC_DBGMESG(("WLC_E_FIFO_CREDIT_MAP:(AC0,AC1,AC2,AC3),(BC_MC),(OTHER): "
 			"(%d,%d,%d,%d),(%d),(%d)\n", event_data[0], event_data[1],
 			event_data[2],
@@ -1010,6 +1182,13 @@ wl_host_event(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata,
 	case WLC_E_IF:
 		{
 		dhd_if_event_t *ifevent = (dhd_if_event_t *)event_data;
+
+		/* Ignore the event if NOIF is set */
+		if (ifevent->flags & WLC_E_IF_FLAGS_BSSCFG_NOIF) {
+			WLFC_DBGMESG(("WLC_E_IF: NO_IF set, event Ignored\r\n"));
+			return (BCME_OK);
+		}
+
 #ifdef PROP_TXSTATUS
 			{
 		uint8* ea = pvt_data->eth.ether_dhost;
@@ -1020,6 +1199,8 @@ wl_host_event(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata,
 		              ((ifevent->is_AP == 0) ? "STA":"AP "),
 		              ea[0], ea[1], ea[2], ea[3], ea[4], ea[5]));
 		(void)ea;
+
+		dhd_os_wlfc_block(dhd_pub);
 		if (ifevent->action == WLC_E_IF_CHANGE)
 			dhd_wlfc_interface_event(dhd_pub->info,
 				eWLFC_MAC_ENTRY_ACTION_UPDATE,
@@ -1029,7 +1210,7 @@ wl_host_event(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata,
 				((ifevent->action == WLC_E_IF_ADD) ?
 				eWLFC_MAC_ENTRY_ACTION_ADD : eWLFC_MAC_ENTRY_ACTION_DEL),
 				ifevent->ifidx, ifevent->is_AP, ea);
-
+		dhd_os_wlfc_unblock(dhd_pub);
 
 		/* dhd already has created an interface by default, for 0 */
 		if (ifevent->ifidx == 0)
@@ -1042,7 +1223,8 @@ wl_host_event(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata,
 				DHD_ERROR(("%s:  ifidx %d for %s action %d\n",
 					__FUNCTION__, ifevent->ifidx,
 					event->ifname, ifevent->action));
-				if (ifevent->action == WLC_E_IF_ADD)
+				if (ifevent->action == WLC_E_IF_ADD ||
+					ifevent->action == WLC_E_IF_CHANGE)
 					wl_cfg80211_notify_ifchange();
 				return (BCME_OK);
 			}
@@ -1082,17 +1264,12 @@ wl_host_event(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata,
 		htsf_update(dhd_pub->info, event_data);
 		break;
 #endif /* WLMEDIA_HTSF */
-#if defined(NDIS630)
-	case WLC_E_NDIS_LINK:
-		break;
-#else /* defined(NDIS630) && defined(BCMDONGLEHOST) */
 	case WLC_E_NDIS_LINK: {
 		uint32 temp = hton32(WLC_E_LINK);
 
 		memcpy((void *)(&pvt_data->event.event_type), &temp,
 		       sizeof(pvt_data->event.event_type));
 	}
-#endif 
 		/* These are what external supplicant/authenticator wants */
 		/* fall through */
 	case WLC_E_LINK:
@@ -1172,9 +1349,11 @@ dhd_print_buf(void *pbuf, int len, int bytes_per_line)
 	printf("\n");
 #endif /* DHD_DEBUG */
 }
-
+#ifndef strtoul
 #define strtoul(nptr, endptr, base) bcm_strtoul((nptr), (endptr), (base))
+#endif
 
+#ifdef PKT_FILTER_SUPPORT
 /* Convert user's input in hex pattern to byte-size mask */
 static int
 wl_pattern_atoh(char *src, char *dst)
@@ -1410,6 +1589,7 @@ fail:
 	if (buf)
 		MFREE(dhd->osh, buf, BUF_SIZE);
 }
+#endif /* PKT_FILTER_SUPPORT */
 
 /* ========================== */
 /* ==== ARP OFFLOAD SUPPORT = */
@@ -1426,10 +1606,10 @@ dhd_arp_offload_set(dhd_pub_t * dhd, int arp_mode)
 	retcode = retcode >= 0 ? 0 : retcode;
 	if (retcode)
 		DHD_TRACE(("%s: failed to set ARP offload mode to 0x%x, retcode = %d\n",
-		__FUNCTION__, arp_mode, retcode));
+			__FUNCTION__, arp_mode, retcode));
 	else
 		DHD_TRACE(("%s: successfully set ARP offload mode to 0x%x\n",
-		__FUNCTION__, arp_mode));
+			__FUNCTION__, arp_mode));
 }
 
 void
@@ -1443,49 +1623,73 @@ dhd_arp_offload_enable(dhd_pub_t * dhd, int arp_enable)
 	retcode = retcode >= 0 ? 0 : retcode;
 	if (retcode)
 		DHD_TRACE(("%s: failed to enabe ARP offload to %d, retcode = %d\n",
-		__FUNCTION__, arp_enable, retcode));
+			__FUNCTION__, arp_enable, retcode));
 	else
 		DHD_TRACE(("%s: successfully enabed ARP offload to %d\n",
-		__FUNCTION__, arp_enable));
+			__FUNCTION__, arp_enable));
+	if (arp_enable) {
+		uint32 version;
+		bcm_mkiovar("arp_version", 0, 0, iovbuf, sizeof(iovbuf));
+		retcode = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, iovbuf, sizeof(iovbuf), FALSE, 0);
+		if (retcode) {
+			DHD_INFO(("%s: fail to get version (maybe version 1:retcode = %d\n",
+				__FUNCTION__, retcode));
+			dhd->arp_version = 1;
+		}
+		else {
+			memcpy(&version, iovbuf, sizeof(version));
+			DHD_INFO(("%s: ARP Version= %x\n", __FUNCTION__, version));
+			dhd->arp_version = version;
+		}
+	}
 }
 
 void
-dhd_aoe_arp_clr(dhd_pub_t *dhd)
+dhd_aoe_arp_clr(dhd_pub_t *dhd, int idx)
 {
 	int ret = 0;
 	int iov_len = 0;
 	char iovbuf[128];
 
 	if (dhd == NULL) return;
+	if (dhd->arp_version == 1)
+		idx = 0;
 
 	iov_len = bcm_mkiovar("arp_table_clear", 0, 0, iovbuf, sizeof(iovbuf));
-	if ((ret  = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, iov_len, TRUE, 0) < 0))
+	if ((ret  = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, iov_len, TRUE, idx)) < 0)
 		DHD_ERROR(("%s failed code %d\n", __FUNCTION__, ret));
 }
 
 void
-dhd_aoe_hostip_clr(dhd_pub_t *dhd)
+dhd_aoe_hostip_clr(dhd_pub_t *dhd, int idx)
 {
 	int ret = 0;
 	int iov_len = 0;
 	char iovbuf[128];
 
 	if (dhd == NULL) return;
+	if (dhd->arp_version == 1)
+		idx = 0;
 
 	iov_len = bcm_mkiovar("arp_hostip_clear", 0, 0, iovbuf, sizeof(iovbuf));
-	if ((ret  = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, iov_len, TRUE, 0)) < 0)
+	if ((ret  = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, iov_len, TRUE, idx)) < 0)
 		DHD_ERROR(("%s failed code %d\n", __FUNCTION__, ret));
 }
 
 void
-dhd_arp_offload_add_ip(dhd_pub_t *dhd, uint32 ipaddr)
+dhd_arp_offload_add_ip(dhd_pub_t *dhd, uint32 ipaddr, int idx)
 {
 	int iov_len = 0;
 	char iovbuf[32];
 	int retcode;
 
-	iov_len = bcm_mkiovar("arp_hostip", (char *)&ipaddr, 4, iovbuf, sizeof(iovbuf));
-	retcode = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, iov_len, TRUE, 0);
+
+	if (dhd == NULL) return;
+	if (dhd->arp_version == 1)
+		idx = 0;
+	iov_len = bcm_mkiovar("arp_hostip", (char *)&ipaddr,
+		sizeof(ipaddr), iovbuf, sizeof(iovbuf));
+	retcode = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, iov_len, TRUE, idx);
 
 	if (retcode)
 		DHD_TRACE(("%s: ARP ip addr add failed, retcode = %d\n",
@@ -1496,7 +1700,7 @@ dhd_arp_offload_add_ip(dhd_pub_t *dhd, uint32 ipaddr)
 }
 
 int
-dhd_arp_get_arp_hostip_table(dhd_pub_t *dhd, void *buf, int buflen)
+dhd_arp_get_arp_hostip_table(dhd_pub_t *dhd, void *buf, int buflen, int idx)
 {
 	int retcode, i;
 	int iov_len;
@@ -1505,10 +1709,13 @@ dhd_arp_get_arp_hostip_table(dhd_pub_t *dhd, void *buf, int buflen)
 
 	if (!buf)
 		return -1;
+	if (dhd == NULL) return -1;
+	if (dhd->arp_version == 1)
+		idx = 0;
 
 	iov_len = bcm_mkiovar("arp_hostip", 0, 0, buf, buflen);
 	BCM_REFERENCE(iov_len);
-	retcode = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, buf, buflen, FALSE, 0);
+	retcode = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, buf, buflen, FALSE, idx);
 
 	if (retcode) {
 		DHD_TRACE(("%s: ioctl WLC_GET_VAR error %d\n",
@@ -1549,196 +1756,11 @@ dhd_sendup_event_common(dhd_pub_t *dhdp, wl_event_msg_t *event, void *data)
 	dhd_sendup_event(dhdp, event, data);
 }
 
-#ifdef SIMPLE_ISCAN
-
-uint iscan_thread_id = 0;
-iscan_buf_t * iscan_chain = 0;
-
-iscan_buf_t *
-dhd_iscan_allocate_buf(dhd_pub_t *dhd, iscan_buf_t **iscanbuf)
-{
-	iscan_buf_t *iscanbuf_alloc = 0;
-	iscan_buf_t *iscanbuf_head;
-
-	DHD_ISCAN(("%s: Entered\n", __FUNCTION__));
-	dhd_iscan_lock();
-
-	iscanbuf_alloc = (iscan_buf_t*)MALLOC(dhd->osh, sizeof(iscan_buf_t));
-	if (iscanbuf_alloc == NULL)
-		goto fail;
-
-	iscanbuf_alloc->next = NULL;
-	iscanbuf_head = *iscanbuf;
-
-	DHD_ISCAN(("%s: addr of allocated node = 0x%X"
-		   "addr of iscanbuf_head = 0x%X dhd = 0x%X\n",
-		   __FUNCTION__, iscanbuf_alloc, iscanbuf_head, dhd));
-
-	if (iscanbuf_head == NULL) {
-		*iscanbuf = iscanbuf_alloc;
-		DHD_ISCAN(("%s: Head is allocated\n", __FUNCTION__));
-		goto fail;
-	}
-
-	while (iscanbuf_head->next)
-		iscanbuf_head = iscanbuf_head->next;
-
-	iscanbuf_head->next = iscanbuf_alloc;
-
-fail:
-	dhd_iscan_unlock();
-	return iscanbuf_alloc;
-}
-
-void
-dhd_iscan_free_buf(void *dhdp, iscan_buf_t *iscan_delete)
-{
-	iscan_buf_t *iscanbuf_free = 0;
-	iscan_buf_t *iscanbuf_prv = 0;
-	iscan_buf_t *iscanbuf_cur;
-	dhd_pub_t *dhd = dhd_bus_pub(dhdp);
-	DHD_ISCAN(("%s: Entered\n", __FUNCTION__));
-
-	dhd_iscan_lock();
-
-	iscanbuf_cur = iscan_chain;
-
-	/* If iscan_delete is null then delete the entire
-	 * chain or else delete specific one provided
-	 */
-	if (!iscan_delete) {
-		while (iscanbuf_cur) {
-			iscanbuf_free = iscanbuf_cur;
-			iscanbuf_cur = iscanbuf_cur->next;
-			iscanbuf_free->next = 0;
-			MFREE(dhd->osh, iscanbuf_free, sizeof(iscan_buf_t));
-		}
-		iscan_chain = 0;
-	} else {
-		while (iscanbuf_cur) {
-			if (iscanbuf_cur == iscan_delete)
-				break;
-			iscanbuf_prv = iscanbuf_cur;
-			iscanbuf_cur = iscanbuf_cur->next;
-		}
-		if (iscanbuf_prv)
-			iscanbuf_prv->next = iscan_delete->next;
-
-		iscan_delete->next = 0;
-		MFREE(dhd->osh, iscan_delete, sizeof(iscan_buf_t));
-
-		if (!iscanbuf_prv)
-			iscan_chain = 0;
-	}
-	dhd_iscan_unlock();
-}
-
-iscan_buf_t *
-dhd_iscan_result_buf(void)
-{
-	return iscan_chain;
-}
-
-int
-dhd_iscan_issue_request(void * dhdp, wl_iscan_params_t *pParams, uint32 size)
-{
-	int rc = -1;
-	dhd_pub_t *dhd = dhd_bus_pub(dhdp);
-	char *buf;
-	char iovar[] = "iscan";
-	uint32 allocSize = 0;
-	wl_ioctl_t ioctl;
-
-	if (pParams) {
-		allocSize = (size + strlen(iovar) + 1);
-		if ((allocSize < size) || (allocSize < strlen(iovar)))
-		{
-			DHD_ERROR(("%s: overflow - allocation size too large %d < %d + %d!\n",
-				__FUNCTION__, allocSize, size, strlen(iovar)));
-			goto cleanUp;
-		}
-		buf = MALLOC(dhd->osh, allocSize);
-
-		if (buf == NULL)
-			{
-			DHD_ERROR(("%s: malloc of size %d failed!\n", __FUNCTION__, allocSize));
-			goto cleanUp;
-			}
-		ioctl.cmd = WLC_SET_VAR;
-		bcm_mkiovar(iovar, (char *)pParams, size, buf, allocSize);
-		rc = dhd_wl_ioctl(dhd, 0, &ioctl, buf, allocSize);
-	}
-
-cleanUp:
-	if (buf) {
-		MFREE(dhd->osh, buf, allocSize);
-	}
-
-	return rc;
-}
-
-static int
-dhd_iscan_get_partial_result(void *dhdp, uint *scan_count)
-{
-	wl_iscan_results_t *list_buf;
-	wl_iscan_results_t list;
-	wl_scan_results_t *results;
-	iscan_buf_t *iscan_cur;
-	int status = -1;
-	dhd_pub_t *dhd = dhd_bus_pub(dhdp);
-	int rc;
-	wl_ioctl_t ioctl;
-
-	DHD_ISCAN(("%s: Enter\n", __FUNCTION__));
-
-	iscan_cur = dhd_iscan_allocate_buf(dhd, &iscan_chain);
-	if (!iscan_cur) {
-		DHD_ERROR(("%s: Failed to allocate node\n", __FUNCTION__));
-		dhd_iscan_free_buf(dhdp, 0);
-		dhd_iscan_request(dhdp, WL_SCAN_ACTION_ABORT);
-		dhd_ind_scan_confirm(dhdp, FALSE);
-		goto fail;
-	}
-
-	dhd_iscan_lock();
-
-	memset(iscan_cur->iscan_buf, 0, WLC_IW_ISCAN_MAXLEN);
-	list_buf = (wl_iscan_results_t*)iscan_cur->iscan_buf;
-	results = &list_buf->results;
-	results->buflen = WL_ISCAN_RESULTS_FIXED_SIZE;
-	results->version = 0;
-	results->count = 0;
-
-	memset(&list, 0, sizeof(list));
-	list.results.buflen = htod32(WLC_IW_ISCAN_MAXLEN);
-	bcm_mkiovar("iscanresults", (char *)&list, WL_ISCAN_RESULTS_FIXED_SIZE,
-		iscan_cur->iscan_buf, WLC_IW_ISCAN_MAXLEN);
-	ioctl.cmd = WLC_GET_VAR;
-	ioctl.set = FALSE;
-	rc = dhd_wl_ioctl(dhd, 0, &ioctl, iscan_cur->iscan_buf, WLC_IW_ISCAN_MAXLEN);
-
-	results->buflen = dtoh32(results->buflen);
-	results->version = dtoh32(results->version);
-	*scan_count = results->count = dtoh32(results->count);
-	status = dtoh32(list_buf->status);
-	DHD_ISCAN(("%s: Got %d resuls status = (%x)\n", __FUNCTION__, results->count, status));
-
-	dhd_iscan_unlock();
-
-	if (!(*scan_count)) {
-		 /* TODO: race condition when FLUSH already called */
-		dhd_iscan_free_buf(dhdp, 0);
-	}
-fail:
-	return status;
-}
-
-#endif /* SIMPLE_ISCAN */
 
 /*
  * returns = TRUE if associated, FALSE if not associated
  */
-bool dhd_is_associated(dhd_pub_t *dhd, void *bss_buf)
+bool dhd_is_associated(dhd_pub_t *dhd, void *bss_buf, int *retval)
 {
 	char bssid[6], zbuf[6];
 	int ret = -1;
@@ -1753,6 +1775,9 @@ bool dhd_is_associated(dhd_pub_t *dhd, void *bss_buf)
 		DHD_TRACE(("%s: not associated! res:%d\n", __FUNCTION__, ret));
 	}
 
+	if (retval)
+		*retval = ret;
+
 	if (ret < 0)
 		return FALSE;
 
@@ -1773,37 +1798,46 @@ bool dhd_is_associated(dhd_pub_t *dhd, void *bss_buf)
 
 /* Function to estimate possible DTIM_SKIP value */
 int
-dhd_get_dtim_skip(dhd_pub_t *dhd)
+dhd_get_suspend_bcn_li_dtim(dhd_pub_t *dhd)
 {
-	int bcn_li_dtim;
+	int bcn_li_dtim = 1; /* deafult no dtim skip setting */
 	int ret = -1;
 	int dtim_assoc = 0;
-
-	if ((dhd->dtim_skip == 0) || (dhd->dtim_skip == 1))
-		bcn_li_dtim = 3;
-	else
-		bcn_li_dtim = dhd->dtim_skip;
+	int ap_beacon = 0;
 
 	/* Check if associated */
-	if (dhd_is_associated(dhd, NULL) == FALSE) {
+	if (dhd_is_associated(dhd, NULL, NULL) == FALSE) {
 		DHD_TRACE(("%s NOT assoc ret %d\n", __FUNCTION__, ret));
 		goto exit;
 	}
 
-	/* if assoc grab ap's dtim value */
+	/* read associated AP beacon interval */
+	if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_GET_BCNPRD,
+		&ap_beacon, sizeof(ap_beacon), FALSE, 0)) < 0) {
+		DHD_ERROR(("%s get beacon failed code %d\n", __FUNCTION__, ret));
+		goto exit;
+	}
+
+	/* if associated APs Beacon more  that 100msec do no dtim skip */
+	if (ap_beacon > MAX_DTIM_SKIP_BEACON_ITERVAL) {
+		DHD_ERROR(("%s NO dtim skip for AP with beacon %d ms\n", __FUNCTION__, ap_beacon));
+		goto exit;
+	}
+
+	/* read associated ap's dtim setup */
 	if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_GET_DTIMPRD,
 		&dtim_assoc, sizeof(dtim_assoc), FALSE, 0)) < 0) {
 		DHD_ERROR(("%s failed code %d\n", __FUNCTION__, ret));
 		goto exit;
 	}
 
-	DHD_ERROR(("%s bcn_li_dtim=%d DTIM=%d Listen=%d\n",
-		__FUNCTION__, bcn_li_dtim, dtim_assoc, LISTEN_INTERVAL));
-
 	/* if not assocated just eixt */
 	if (dtim_assoc == 0) {
 		goto exit;
 	}
+#if 0
+	/* attemp to use platform defined dtim skip interval */
+	bcn_li_dtim = dhd->suspend_bcn_li_dtim;
 
 	/* check if sta listen interval fits into AP dtim */
 	if (dtim_assoc > LISTEN_INTERVAL) {
@@ -1820,36 +1854,33 @@ dhd_get_dtim_skip(dhd_pub_t *dhd)
 		DHD_TRACE(("%s agjust dtim_skip as %d\n", __FUNCTION__, bcn_li_dtim));
 	}
 
+	DHD_ERROR(("%s beacon=%d bcn_li_dtim=%d DTIM=%d Listen=%d\n",
+		__FUNCTION__, ap_beacon, bcn_li_dtim, dtim_assoc, LISTEN_INTERVAL));
+#else
+	if(dtim_assoc == 1)
+		bcn_li_dtim = 3;//listen beacon every 100ms * 3
+	else if(dtim_assoc == 2)
+		bcn_li_dtim = 2;//listen beacon every 200ms * 2
+	else
+		bcn_li_dtim = 1;//Don't skip if DTIM > 2
+#endif
 exit:
 	return bcn_li_dtim;
 }
 
-/* Check if HostAPD or WFD mode setup */
-bool dhd_check_ap_wfd_mode_set(dhd_pub_t *dhd)
+/* Check if the mode supports STA MODE */
+bool dhd_support_sta_mode(dhd_pub_t *dhd)
 {
+
 #ifdef  WL_CFG80211
-#ifndef WL_ENABLE_P2P_IF
-	/* To be back compatble with ICS MR1 release where p2p interface
-	 * disable but wlan0 used for p2p
-	 */
-	if (((dhd->op_mode & HOSTAPD_MASK) == HOSTAPD_MASK) ||
-		((dhd->op_mode & WFD_MASK) == WFD_MASK)) {
-		return TRUE;
-	}
-	else
-#else
-	/* concurent mode with p2p interface for wfd and wlan0 for sta */
-	if (((dhd->op_mode & P2P_GO_ENABLED) == P2P_GO_ENABLED) ||
-		((dhd->op_mode & P2P_GC_ENABLED) == P2P_GC_ENABLED)) {
-		DHD_ERROR(("%s P2P enabled for  mode=%d\n", __FUNCTION__, dhd->op_mode));
-		return TRUE;
-	}
+	if (!(dhd->op_mode & DHD_FLAG_STA_MODE))
+		return FALSE;
 	else
-#endif /* WL_ENABLE_P2P_IF */
 #endif /* WL_CFG80211 */
-		return FALSE;
+		return TRUE;
 }
 
+
 #if defined(PNO_SUPPORT)
 int
 dhd_pno_clean(dhd_pub_t *dhd)
@@ -1892,15 +1923,17 @@ dhd_pno_enable(dhd_pub_t *dhd, int pfn_enabled)
 		return ret;
 	}
 
-	if (dhd_check_ap_wfd_mode_set(dhd) == TRUE)
+#ifndef WL_SCHED_SCAN
+	if (!dhd_support_sta_mode(dhd))
 		return (ret);
 
 	memset(iovbuf, 0, sizeof(iovbuf));
 
-	if ((pfn_enabled) && (dhd_is_associated(dhd, NULL) == TRUE)) {
+	if ((pfn_enabled) && (dhd_is_associated(dhd, NULL, NULL) == TRUE)) {
 		DHD_ERROR(("%s pno is NOT enable : called in assoc mode , ignore\n", __FUNCTION__));
 		return ret;
 	}
+#endif /* !WL_SCHED_SCAN */
 
 	/* Enable/disable PNO */
 	if ((ret = bcm_mkiovar("pfn", (char *)&pfn_enabled, 4, iovbuf, sizeof(iovbuf))) > 0) {
@@ -1934,14 +1967,16 @@ dhd_pno_set(dhd_pub_t *dhd, wlc_ssid_t* ssids_local, int nssid, ushort scan_fr,
 
 	DHD_TRACE(("%s nssid=%d nchan=%d\n", __FUNCTION__, nssid, scan_fr));
 
-	if ((!dhd) && (!ssids_local)) {
-		DHD_ERROR(("%s error exit\n", __FUNCTION__));
+	if ((!dhd) || (!ssids_local)) {
+		DHD_ERROR(("%s error exit(%s %s)\n", __FUNCTION__,
+		(!dhd)?"dhd is null":"", (!ssids_local)?"ssid is null":""));
 		err = -1;
 		return err;
 	}
-
-	if (dhd_check_ap_wfd_mode_set(dhd) == TRUE)
-		return (err);
+#ifndef WL_SCHED_SCAN
+	if (!dhd_support_sta_mode(dhd))
+		return err;
+#endif /* !WL_SCHED_SCAN */
 
 	/* Check for broadcast ssid */
 	for (k = 0; k < nssid; k++) {
@@ -2052,14 +2087,14 @@ int dhd_keep_alive_onoff(dhd_pub_t *dhd)
 {
 	char 				buf[256];
 	const char 			*str;
-	wl_mkeep_alive_pkt_t	mkeep_alive_pkt;
+	wl_mkeep_alive_pkt_t	mkeep_alive_pkt = {0};
 	wl_mkeep_alive_pkt_t	*mkeep_alive_pktp;
 	int					buf_len;
 	int					str_len;
 	int res 				= -1;
 
-	if (dhd_check_ap_wfd_mode_set(dhd) == TRUE)
-		return (res);
+	if (!dhd_support_sta_mode(dhd))
+		return res;
 
 	DHD_TRACE(("%s execution\n", __FUNCTION__));
 
@@ -2068,7 +2103,7 @@ int dhd_keep_alive_onoff(dhd_pub_t *dhd)
 	strncpy(buf, str, str_len);
 	buf[ str_len ] = '\0';
 	mkeep_alive_pktp = (wl_mkeep_alive_pkt_t *) (buf + str_len + 1);
-	mkeep_alive_pkt.period_msec = KEEP_ALIVE_PERIOD;
+	mkeep_alive_pkt.period_msec = CUSTOM_KEEP_ALIVE_SETTING;
 	buf_len = str_len + 1;
 	mkeep_alive_pkt.version = htod16(WL_MKEEP_ALIVE_VERSION);
 	mkeep_alive_pkt.length = htod16(WL_MKEEP_ALIVE_FIXED_LEN);
@@ -2076,6 +2111,7 @@ int dhd_keep_alive_onoff(dhd_pub_t *dhd)
 	mkeep_alive_pkt.keep_alive_id = 0;
 	mkeep_alive_pkt.len_bytes = 0;
 	buf_len += WL_MKEEP_ALIVE_FIXED_LEN;
+	bzero(mkeep_alive_pkt.data, sizeof(mkeep_alive_pkt.data));
 	/* Keep-alive attributes are set in local	variable (mkeep_alive_pkt), and
 	 * then memcpy'ed into buffer (mkeep_alive_pktp) since there is no
 	 * guarantee that the buffer is properly aligned.
@@ -2096,7 +2132,7 @@ int
 wl_iw_parse_data_tlv(char** list_str, void *dst, int dst_size, const char token,
                      int input_size, int *bytes_left)
 {
-	char* str = *list_str;
+	char* str;
 	uint16 short_temp;
 	uint32 int_temp;
 
@@ -2104,6 +2140,7 @@ wl_iw_parse_data_tlv(char** list_str, void *dst, int dst_size, const char token,
 		DHD_ERROR(("%s error paramters\n", __FUNCTION__));
 		return -1;
 	}
+	str = *list_str;
 
 	/* Clean all dest bytes */
 	memset(dst, 0, dst_size);
@@ -2145,13 +2182,14 @@ int
 wl_iw_parse_channel_list_tlv(char** list_str, uint16* channel_list,
                              int channel_num, int *bytes_left)
 {
-	char* str = *list_str;
+	char* str;
 	int idx = 0;
 
 	if ((list_str == NULL) || (*list_str == NULL) ||(bytes_left == NULL) || (*bytes_left < 0)) {
 		DHD_ERROR(("%s error paramters\n", __FUNCTION__));
 		return -1;
 	}
+	str = *list_str;
 
 	while (*bytes_left > 0) {
 
@@ -2290,7 +2328,8 @@ wl_iw_parse_ssid_list(char** list_str, wlc_ssid_t* ssid, int idx, int max)
 			ssid[idx].SSID_len = 0;
 
 		if (idx < max) {
-			bcm_strcpy_s((char*)ssid[idx].SSID, sizeof(ssid[idx].SSID), str);
+			bzero(ssid[idx].SSID, sizeof(ssid[idx].SSID));
+			strncpy((char*)ssid[idx].SSID, str, sizeof(ssid[idx].SSID) - 1);
 			ssid[idx].SSID_len = strlen(str);
 		}
 		idx++;
diff --git a/drivers/net/wireless/bcmdhd/dhd_custom_gpio.c b/drivers/net/wireless/bcmdhd/dhd_custom_gpio.c
old mode 100644
new mode 100755
index 9a9d182..e139b64
--- a/drivers/net/wireless/bcmdhd/dhd_custom_gpio.c
+++ b/drivers/net/wireless/bcmdhd/dhd_custom_gpio.c
@@ -1,26 +1,8 @@
 /*
 * Customer code to add GPIO control during WLAN start/stop
-* Copyright (C) 1999-2012, Broadcom Corporation
-* 
-*      Unless you and Broadcom execute a separate written software license
-* agreement governing use of this software, this software is licensed to you
-* under the terms of the GNU General Public License version 2 (the "GPL"),
-* available at http://www.broadcom.com/licenses/GPLv2.php, with the
-* following added to such license:
-* 
-*      As a special exception, the copyright holders of this software give you
-* permission to link this software with independent modules, and to copy and
-* distribute the resulting executable under terms of your choice, provided that
-* you also meet, for each linked independent module, the terms and conditions of
-* the license of that module.  An independent module is a module which is not
-* derived from this software.  The special exception does not apply to any
-* modifications of the software.
-* 
-*      Notwithstanding the above, under no circumstances may you combine this
-* software in any way with any other Broadcom software provided under a license
-* other than the GPL, without Broadcom's express prior written consent.
+* $Copyright Open Broadcom Corporation$
 *
-* $Id: dhd_custom_gpio.c 291086 2011-10-21 01:17:24Z $
+* $Id: dhd_custom_gpio.c 389250 2013-03-06 02:05:03Z $
 */
 
 #include <typedefs.h>
@@ -42,6 +24,11 @@ extern  void bcm_wlan_power_off(int);
 extern  void bcm_wlan_power_on(int);
 #endif /* CUSTOMER_HW */
 #if defined(CUSTOMER_HW2)
+
+#if defined(PLATFORM_MPS)
+int __attribute__ ((weak)) wifi_get_fw_nv_path(char *fw, char *nv) { return 0;};
+#endif
+
 #ifdef CONFIG_WIFI_CONTROL_FUNC
 int wifi_set_power(int on, unsigned long msec);
 int wifi_get_irq_number(unsigned long *irq_flags_ptr);
@@ -53,7 +40,7 @@ int wifi_get_irq_number(unsigned long *irq_flags_ptr) { return -1; }
 int wifi_get_mac_addr(unsigned char *buf) { return -1; }
 void *wifi_get_country_code(char *ccode) { return NULL; }
 #endif /* CONFIG_WIFI_CONTROL_FUNC */
-#endif /* CUSTOMER_HW2 */
+#endif 
 
 #if defined(OOB_INTR_ONLY)
 
@@ -61,16 +48,55 @@ void *wifi_get_country_code(char *ccode) { return NULL; }
 extern int sdioh_mmc_irq(int irq);
 #endif /* (BCMLXSDMMC)  */
 
-#ifdef CUSTOMER_HW3
+#if defined(CUSTOMER_HW3) || defined(PLATFORM_MPS)
 #include <mach/gpio.h>
 #endif
 
+#define islower(c)  (c >=  'a' && c <= 'z')
+#define isdigit(c)  (c >= '0' && c <= '9')
+#define toupper(c)  (islower(c) ? (c - 'a' + 'A') : (c))
 /* Customer specific Host GPIO defintion  */
 static int dhd_oob_gpio_num = -1;
 
 module_param(dhd_oob_gpio_num, int, 0644);
 MODULE_PARM_DESC(dhd_oob_gpio_num, "DHD oob gpio number");
 
+
+/*****************************************************************************
+**  Function        scru_ascii_2_hex
+**
+**  Description     This function converts an ASCII string into HEX
+**
+**  Returns         the number of hex bytes filled.
+*****************************************************************************/
+int scru_ascii_2_hex (char *p_ascii, int len, unsigned char *p_hex)
+{
+    int     x;
+    unsigned char   c;
+
+    for (x = 0; (x < len) && (*p_ascii); x++)
+    {
+        if (isdigit (*p_ascii))
+            c = (*p_ascii - '0') << 4;
+        else
+            c = (toupper(*p_ascii) - 'A' + 10) << 4;
+
+        p_ascii++;
+        if (*p_ascii)
+        {
+            if (isdigit (*p_ascii))
+                c |= (*p_ascii - '0');
+            else
+                c |= (toupper(*p_ascii) - 'A' + 10);
+
+            p_ascii++;
+        }
+        *p_hex++ = c;
+    }
+
+    return (x);
+}
+
 /* This function will return:
  *  1) return :  Host gpio interrupt number per customer platform
  *  2) irq_flags_ptr : Type of Host interrupt as Level or Edge
@@ -86,7 +112,7 @@ int dhd_customer_oob_irq_map(unsigned long *irq_flags_ptr)
 {
 	int  host_oob_irq = 0;
 
-#ifdef CUSTOMER_HW2
+#if defined(CUSTOMER_HW2) && !defined(PLATFORM_MPS)
 	host_oob_irq = wifi_get_irq_number(irq_flags_ptr);
 
 #else
@@ -94,7 +120,7 @@ int dhd_customer_oob_irq_map(unsigned long *irq_flags_ptr)
 	if (dhd_oob_gpio_num < 0) {
 		dhd_oob_gpio_num = CUSTOM_OOB_GPIO_NUM;
 	}
-#endif /* CUSTOMER_HW2 */
+#endif /* CUSTOMER_OOB_GPIO_NUM */
 
 	if (dhd_oob_gpio_num < 0) {
 		WL_ERROR(("%s: ERROR customer specific Host GPIO is NOT defined \n",
@@ -107,16 +133,16 @@ int dhd_customer_oob_irq_map(unsigned long *irq_flags_ptr)
 
 #if defined CUSTOMER_HW
 	host_oob_irq = MSM_GPIO_TO_INT(dhd_oob_gpio_num);
-#elif defined CUSTOMER_HW3
+#elif defined CUSTOMER_HW3 || defined(PLATFORM_MPS)
 	gpio_request(dhd_oob_gpio_num, "oob irq");
 	host_oob_irq = gpio_to_irq(dhd_oob_gpio_num);
 	gpio_direction_input(dhd_oob_gpio_num);
 #endif /* CUSTOMER_HW */
-#endif /* CUSTOMER_HW2 */
+#endif 
 
 	return (host_oob_irq);
 }
-#endif /* defined(OOB_INTR_ONLY) */
+#endif 
 
 /* Customer function to control hw specific wlan gpios */
 void
@@ -129,7 +155,7 @@ dhd_customer_gpio_wlan_ctrl(int onoff)
 #ifdef CUSTOMER_HW
 			bcm_wlan_power_off(2);
 #endif /* CUSTOMER_HW */
-#ifdef CUSTOMER_HW2
+#if defined(CUSTOMER_HW2)
 			wifi_set_power(0, 0);
 #endif
 			WL_ERROR(("=========== WLAN placed in RESET ========\n"));
@@ -141,7 +167,7 @@ dhd_customer_gpio_wlan_ctrl(int onoff)
 #ifdef CUSTOMER_HW
 			bcm_wlan_power_on(2);
 #endif /* CUSTOMER_HW */
-#ifdef CUSTOMER_HW2
+#if defined(CUSTOMER_HW2)
 			wifi_set_power(1, 0);
 #endif
 			WL_ERROR(("=========== WLAN going back to live  ========\n"));
@@ -183,13 +209,64 @@ dhd_custom_get_mac_address(unsigned char *buf)
 	ret = wifi_get_mac_addr(buf);
 #endif
 
-#ifdef EXAMPLE_GET_MAC
+//#ifdef EXAMPLE_GET_MAC
 	/* EXAMPLE code */
 	{
-		struct ether_addr ea_example = {{0x00, 0x11, 0x22, 0x33, 0x44, 0xFF}};
+	    
+	    char text[128];
+	    int len;
+	    void *image = NULL;
+	    char *p_start=NULL;  
+        char text_addr[12];
+         
+		struct ether_addr ea_example = {{0xc8, 0x56, 0x78, 0x9a, 0xbc, 0xde}};
+        
+
 		bcopy((char *)&ea_example, buf, sizeof(struct ether_addr));
+         buf[4]=random32()&0xff;
+         buf[5]=random32()&0xff;
+        image = dhd_os_open_image("/persist/WCNSS_qcom_cfg.ini");
+        if (image == NULL)
+            WL_ERROR(("%s can't open wncss config file!!!\n", __FUNCTION__));  
+
+        	/* Download image */
+#if defined(NDISVER) && (NDISVER >= 0x0630)
+	while ((len = dhd_os_get_image_block((char*)text, 127, image, FALSE))) {
+#else
+	while ((len = dhd_os_get_image_block((char*)text, 127, image))) {
+#endif /* NDSIVER && (NDISVER >= 0x0680) */
+		if (len < 0) {
+			  WL_ERROR(("%s get address data failed (%d)\n", __FUNCTION__,len));
+			    goto err;;
+			
+		}
+        if(text[0]=='#')
+            continue;
+         if ((p_start=strstr(text, "Intf0MacAddress")))
+            {
+                if ((p_start=strstr(text, "="))){
+
+                                        
+                      scru_ascii_2_hex (p_start+1, 12,text_addr);  
+ 
+                        memcpy(buf,text_addr,6);   
+                     
+                        printk("get wifi NV address=%x:%x:%x:%x:%x:%x\n",buf[0],buf[1],buf[2],buf[3],buf[4],buf[5]); 
+                        ret = 0;      
+                break;
+                    }
+            }
+
+         
+       }
+    err:
+        if (image){
+		dhd_os_close_image(image);
+          
+            }
+        
 	}
-#endif /* EXAMPLE_GET_MAC */
+//#endif /* EXAMPLE_GET_MAC */
 
 	return ret;
 }
diff --git a/drivers/net/wireless/bcmdhd/dhd_dbg.h b/drivers/net/wireless/bcmdhd/dhd_dbg.h
old mode 100644
new mode 100755
index 2b40d27..f016d48
--- a/drivers/net/wireless/bcmdhd/dhd_dbg.h
+++ b/drivers/net/wireless/bcmdhd/dhd_dbg.h
@@ -1,36 +1,19 @@
 /*
  * Debug/trace/assert driver definitions for Dongle Host Driver.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $ Copyright Open Broadcom Corporation $
  *
- * $Id: dhd_dbg.h 308299 2012-01-14 01:36:58Z $
+ * $Id: dhd_dbg.h 353883 2012-08-29 04:43:40Z $
  */
 
 #ifndef _dhd_dbg_
 #define _dhd_dbg_
 
+#define USE_NET_RATELIMIT		net_ratelimit()
+
 #if defined(DHD_DEBUG)
 
-#define DHD_ERROR(args)	       do {if ((dhd_msg_level & DHD_ERROR_VAL) && (net_ratelimit())) \
-								printf args;} while (0)
+#define DHD_ERROR(args)		printf args//do {if ((dhd_msg_level & DHD_ERROR_VAL) && USE_NET_RATELIMIT) printf args;} while (0)
 #define DHD_TRACE(args)		do {if (dhd_msg_level & DHD_TRACE_VAL) printf args;} while (0)
 #define DHD_INFO(args)		do {if (dhd_msg_level & DHD_INFO_VAL) printf args;} while (0)
 #define DHD_DATA(args)		do {if (dhd_msg_level & DHD_DATA_VAL) printf args;} while (0)
@@ -46,6 +29,8 @@
 #define DHD_ARPOE(args)		do {if (dhd_msg_level & DHD_ARPOE_VAL) printf args;} while (0)
 #define DHD_REORDER(args)	do {if (dhd_msg_level & DHD_REORDER_VAL) printf args;} while (0)
 
+#define DHD_TRACE_HW4	DHD_TRACE
+
 #define DHD_ERROR_ON()		(dhd_msg_level & DHD_ERROR_VAL)
 #define DHD_TRACE_ON()		(dhd_msg_level & DHD_TRACE_VAL)
 #define DHD_INFO_ON()		(dhd_msg_level & DHD_INFO_VAL)
@@ -61,10 +46,11 @@
 #define DHD_ISCAN_ON()		(dhd_msg_level & DHD_ISCAN_VAL)
 #define DHD_ARPOE_ON()		(dhd_msg_level & DHD_ARPOE_VAL)
 #define DHD_REORDER_ON()	(dhd_msg_level & DHD_REORDER_VAL)
+#define DHD_NOCHECKDIED_ON()	(dhd_msg_level & DHD_NOCHECKDIED_VAL)
 
 #else /* defined(BCMDBG) || defined(DHD_DEBUG) */
 
-#define DHD_ERROR(args)    	do {if (net_ratelimit()) printf args;} while (0)
+#define DHD_ERROR(args)		do {if (USE_NET_RATELIMIT) printf args;} while (0)
 #define DHD_TRACE(args)
 #define DHD_INFO(args)
 #define DHD_DATA(args)
@@ -80,6 +66,8 @@
 #define DHD_ARPOE(args)
 #define DHD_REORDER(args)
 
+#define DHD_TRACE_HW4	DHD_TRACE
+
 #define DHD_ERROR_ON()		0
 #define DHD_TRACE_ON()		0
 #define DHD_INFO_ON()		0
@@ -95,6 +83,7 @@
 #define DHD_ISCAN_ON()		0
 #define DHD_ARPOE_ON()		0
 #define DHD_REORDER_ON()	0
+#define DHD_NOCHECKDIED_ON()	0
 #endif 
 
 #define DHD_LOG(args)
diff --git a/drivers/net/wireless/bcmdhd/dhd_ip.c b/drivers/net/wireless/bcmdhd/dhd_ip.c
new file mode 100755
index 0000000..b044526
--- /dev/null
+++ b/drivers/net/wireless/bcmdhd/dhd_ip.c
@@ -0,0 +1,93 @@
+/*
+ * IP Packet Parser Module.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ * $Id$
+ */
+#include <typedefs.h>
+#include <osl.h>
+
+#include <proto/ethernet.h>
+#include <proto/vlan.h>
+#include <proto/802.3.h>
+#include <proto/bcmip.h>
+#include <bcmendian.h>
+
+#include <dhd_dbg.h>
+
+#include <dhd_ip.h>
+
+/* special values */
+/* 802.3 llc/snap header */
+static const uint8 llc_snap_hdr[SNAP_HDR_LEN] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00};
+
+pkt_frag_t pkt_frag_info(osl_t *osh, void *p)
+{
+	uint8 *frame;
+	int length;
+	uint8 *pt;			/* Pointer to type field */
+	uint16 ethertype;
+	struct ipv4_hdr *iph;		/* IP frame pointer */
+	int ipl;			/* IP frame length */
+	uint16 iph_frag;
+
+	ASSERT(osh && p);
+
+	frame = PKTDATA(osh, p);
+	length = PKTLEN(osh, p);
+
+	/* Process Ethernet II or SNAP-encapsulated 802.3 frames */
+	if (length < ETHER_HDR_LEN) {
+		DHD_INFO(("%s: short eth frame (%d)\n", __FUNCTION__, length));
+		return DHD_PKT_FRAG_NONE;
+	} else if (ntoh16(*(uint16 *)(frame + ETHER_TYPE_OFFSET)) >= ETHER_TYPE_MIN) {
+		/* Frame is Ethernet II */
+		pt = frame + ETHER_TYPE_OFFSET;
+	} else if (length >= ETHER_HDR_LEN + SNAP_HDR_LEN + ETHER_TYPE_LEN &&
+	           !bcmp(llc_snap_hdr, frame + ETHER_HDR_LEN, SNAP_HDR_LEN)) {
+		pt = frame + ETHER_HDR_LEN + SNAP_HDR_LEN;
+	} else {
+		DHD_INFO(("%s: non-SNAP 802.3 frame\n", __FUNCTION__));
+		return DHD_PKT_FRAG_NONE;
+	}
+
+	ethertype = ntoh16(*(uint16 *)pt);
+
+	/* Skip VLAN tag, if any */
+	if (ethertype == ETHER_TYPE_8021Q) {
+		pt += VLAN_TAG_LEN;
+
+		if (pt + ETHER_TYPE_LEN > frame + length) {
+			DHD_INFO(("%s: short VLAN frame (%d)\n", __FUNCTION__, length));
+			return DHD_PKT_FRAG_NONE;
+		}
+
+		ethertype = ntoh16(*(uint16 *)pt);
+	}
+
+	if (ethertype != ETHER_TYPE_IP) {
+		DHD_INFO(("%s: non-IP frame (ethertype 0x%x, length %d)\n",
+			__FUNCTION__, ethertype, length));
+		return DHD_PKT_FRAG_NONE;
+	}
+
+	iph = (struct ipv4_hdr *)(pt + ETHER_TYPE_LEN);
+	ipl = length - (pt + ETHER_TYPE_LEN - frame);
+
+	/* We support IPv4 only */
+	if ((ipl < IPV4_OPTIONS_OFFSET) || (IP_VER(iph) != IP_VER_4)) {
+		DHD_INFO(("%s: short frame (%d) or non-IPv4\n", __FUNCTION__, ipl));
+		return DHD_PKT_FRAG_NONE;
+	}
+
+	iph_frag = ntoh16(iph->frag);
+
+	if (iph_frag & IPV4_FRAG_DONT) {
+		return DHD_PKT_FRAG_NONE;
+	} else if ((iph_frag & IPV4_FRAG_MORE) == 0) {
+		return DHD_PKT_FRAG_LAST;
+	} else {
+		return (iph_frag & IPV4_FRAG_OFFSET_MASK)? DHD_PKT_FRAG_CONT : DHD_PKT_FRAG_FIRST;
+	}
+}
diff --git a/drivers/net/wireless/bcmdhd/dhd_ip.h b/drivers/net/wireless/bcmdhd/dhd_ip.h
new file mode 100755
index 0000000..782736f
--- /dev/null
+++ b/drivers/net/wireless/bcmdhd/dhd_ip.h
@@ -0,0 +1,24 @@
+/*
+ * Header file describing the common ip parser function.
+ *
+ * Provides type definitions and function prototypes used to parse ip packet.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ * $Id$
+ */
+
+#ifndef _dhd_ip_h_
+#define _dhd_ip_h_
+
+typedef enum pkt_frag
+{
+	DHD_PKT_FRAG_NONE = 0,
+	DHD_PKT_FRAG_FIRST,
+	DHD_PKT_FRAG_CONT,
+	DHD_PKT_FRAG_LAST
+} pkt_frag_t;
+
+extern pkt_frag_t pkt_frag_info(osl_t *osh, void *p);
+
+#endif /* _dhd_ip_h_ */
diff --git a/drivers/net/wireless/bcmdhd/dhd_linux.c b/drivers/net/wireless/bcmdhd/dhd_linux.c
old mode 100644
new mode 100755
index 0d1ba9d..ca9b72f
--- a/drivers/net/wireless/bcmdhd/dhd_linux.c
+++ b/drivers/net/wireless/bcmdhd/dhd_linux.c
@@ -2,27 +2,9 @@
  * Broadcom Dongle Host Driver (DHD), Linux-specific network interface
  * Basically selected code segments from usb-cdc.c and usb-rndis.c
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: dhd_linux.c 329678 2012-04-26 08:51:32Z $
+ * $Id: dhd_linux.c 394924 2013-04-04 06:55:46Z $
  */
 
 #include <typedefs.h>
@@ -33,6 +15,7 @@
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/skbuff.h>
+#include <linux/kthread.h>
 #include <linux/netdevice.h>
 #include <linux/inetdevice.h>
 #include <linux/rtnetlink.h>
@@ -42,6 +25,7 @@
 #include <linux/ethtool.h>
 #include <linux/fcntl.h>
 #include <linux/fs.h>
+#include <linux/ip.h>
 
 #include <asm/uaccess.h>
 #include <asm/unaligned.h>
@@ -69,6 +53,8 @@
 #include <proto/bt_amp_hci.h>
 #include <dhd_bta.h>
 #endif
+static int module_insert = 0;
+int module_remove = 0; 
 
 #ifdef WLMEDIA_HTSF
 #include <linux/time.h>
@@ -96,6 +82,7 @@ typedef struct histo_ {
 static histo_t vi_d1, vi_d2, vi_d3, vi_d4;
 #endif /* WLMEDIA_HTSF */
 
+
 #if defined(SOFTAP)
 extern bool ap_cfg_running;
 extern bool ap_fw_loaded;
@@ -116,7 +103,7 @@ extern bool ap_fw_loaded;
 #include <wl_android.h>
 
 #ifdef ARP_OFFLOAD_SUPPORT
-void aoe_update_host_ipv4_table(dhd_pub_t *dhd_pub, u32 ipa, bool add);
+void aoe_update_host_ipv4_table(dhd_pub_t *dhd_pub, u32 ipa, bool add, int idx);
 static int dhd_device_event(struct notifier_block *this,
 	unsigned long event,
 	void *ptr);
@@ -134,7 +121,10 @@ DECLARE_WAIT_QUEUE_HEAD(dhd_dpc_wait);
 
 #if defined(OOB_INTR_ONLY)
 extern void dhd_enable_oob_intr(struct dhd_bus *bus, bool enable);
-#endif /* defined(OOB_INTR_ONLY) */
+#endif 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && (1)
+static void dhd_hang_process(struct work_struct *work);
+#endif 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))
 MODULE_LICENSE("GPL v2");
 #endif /* LinuxVer */
@@ -151,6 +141,12 @@ MODULE_LICENSE("GPL v2");
 #endif
 #endif /* BCM_FD_AGGR */
 
+#ifdef PROP_TXSTATUS
+extern bool dhd_wlfc_skip_fc(void);
+extern void dhd_wlfc_plat_enable(void *dhd);
+extern void dhd_wlfc_plat_deinit(void *dhd);
+#endif /* PROP_TXSTATUS */
+
 #if LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 15)
 const char *
 print_tainted()
@@ -160,22 +156,30 @@ print_tainted()
 #endif	/* LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 15) */
 
 /* Linux wireless extension support */
-#if defined(CONFIG_WIRELESS_EXT)
+#if defined(WL_WIRELESS_EXT)
 #include <wl_iw.h>
 extern wl_iw_extra_params_t  g_wl_iw_params;
-#endif /* defined(CONFIG_WIRELESS_EXT) */
+#endif /* defined(WL_WIRELESS_EXT) */
 
-#if defined(CONFIG_HAS_EARLYSUSPEND)
+#if defined(CONFIG_HAS_EARLYSUSPEND) && defined(DHD_USE_EARLYSUSPEND)
 #include <linux/earlysuspend.h>
-extern int dhdcdc_set_ioctl(dhd_pub_t *dhd, int ifidx, uint cmd, void *buf, uint len);
-extern int dhd_get_dtim_skip(dhd_pub_t *dhd);
-#endif /* defined(CONFIG_HAS_EARLYSUSPEND) */
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND) && defined(DHD_USE_EARLYSUSPEND) */
+
+extern int dhd_get_suspend_bcn_li_dtim(dhd_pub_t *dhd);
 
 #ifdef PKT_FILTER_SUPPORT
 extern void dhd_pktfilter_offload_set(dhd_pub_t * dhd, char *arg);
 extern void dhd_pktfilter_offload_enable(dhd_pub_t * dhd, char *arg, int enable, int master_mode);
 #endif
 
+
+#ifdef READ_MACADDR
+extern int dhd_read_macaddr(struct dhd_info *dhd);
+#endif
+#ifdef WRITE_MACADDR
+extern int dhd_write_macaddr(struct ether_addr *mac);
+#endif
+
 /* Interface control information */
 typedef struct dhd_if {
 	struct dhd_info *info;			/* back pointer to dhd_info */
@@ -224,9 +228,9 @@ static uint32 maxdelay = 0, tspktcnt = 0, maxdelaypktno = 0;
 
 /* Local private structure (extension of pub) */
 typedef struct dhd_info {
-#if defined(CONFIG_WIRELESS_EXT)
+#if defined(WL_WIRELESS_EXT)
 	wl_iw_t		iw;		/* wireless extensions state (must be first) */
-#endif /* defined(CONFIG_WIRELESS_EXT) */
+#endif /* defined(WL_WIRELESS_EXT) */
 
 	dhd_pub_t pub;
 
@@ -241,6 +245,8 @@ typedef struct dhd_info {
 	htsf_t  htsf;
 #endif
 	wait_queue_head_t ioctl_resp_wait;
+	uint32	default_wd_interval;
+
 	struct timer_list timer;
 	bool wd_timer_valid;
 	struct tasklet_struct tasklet;
@@ -254,14 +260,23 @@ typedef struct dhd_info {
 
 	tsk_ctl_t	thr_dpc_ctl;
 	tsk_ctl_t	thr_wdt_ctl;
+#ifdef RXFRAME_THREAD
+	tsk_ctl_t	thr_rxf_ctl;
+	spinlock_t	rxf_lock;
+#endif /* RXFRAME_THREAD */
 #endif /* DHDTHREAD */
 	bool dhd_tasklet_create;
 	tsk_ctl_t	thr_sysioc_ctl;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
+	struct work_struct work_hang;
+#endif
 
 	/* Wakelocks */
 #if defined(CONFIG_HAS_WAKELOCK) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
 	struct wake_lock wl_wifi;   /* Wifi wakelock */
 	struct wake_lock wl_rxwake; /* Wifi rx wakelock */
+	struct wake_lock wl_ctrlwake; /* Wifi ctrl wakelock */
+	struct wake_lock wl_wdwake; /* Wifi wd wakelock */
 #endif
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
@@ -269,10 +284,13 @@ typedef struct dhd_info {
 	 * calls and wifi_on or wifi_off
 	 */
 	struct mutex dhd_net_if_mutex;
+	struct mutex dhd_suspend_mutex;
 #endif
 	spinlock_t wakelock_spinlock;
 	int wakelock_counter;
-	int wakelock_timeout_enable;
+	int wakelock_wd_counter;
+	int wakelock_rx_timeout_enable;
+	int wakelock_ctrl_timeout_enable;
 
 	/* Thread to issue ioctl for multicast */
 	unsigned char set_macaddress;
@@ -281,9 +299,9 @@ typedef struct dhd_info {
 	atomic_t pend_8021x_cnt;
 	dhd_attach_states_t dhd_state;
 
-#ifdef CONFIG_HAS_EARLYSUSPEND
+#if defined(CONFIG_HAS_EARLYSUSPEND) && defined(DHD_USE_EARLYSUSPEND)
 	struct early_suspend early_suspend;
-#endif /* CONFIG_HAS_EARLYSUSPEND */
+#endif /* CONFIG_HAS_EARLYSUSPEND && DHD_USE_EARLYSUSPEND */
 
 #ifdef ARP_OFFLOAD_SUPPORT
 	u32 pend_ipaddr;
@@ -297,6 +315,8 @@ typedef struct dhd_info {
 #endif
 } dhd_info_t;
 
+/* Flag to indicate if we should download firmware on driver load */
+uint dhd_download_fw_on_driverload = TRUE;
 
 /* Definitions to provide path to the firmware and nvram
  * example nvram_path[MOD_PARAM_PATHLEN]="/projects/wlan/nvram.txt"
@@ -304,13 +324,17 @@ typedef struct dhd_info {
 char firmware_path[MOD_PARAM_PATHLEN];
 char nvram_path[MOD_PARAM_PATHLEN];
 
+/* information string to keep firmware, chio, cheip version info visiable from log */
+char info_string[MOD_PARAM_INFOLEN];
+module_param_string(info_string, info_string, MOD_PARAM_INFOLEN, 0444);
 int op_mode = 0;
+int disable_proptx = 0;
 module_param(op_mode, int, 0644);
 extern int wl_control_wl_start(struct net_device *dev);
-extern int net_os_send_hang_message(struct net_device *dev);
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
 struct semaphore dhd_registration_sem;
 struct semaphore dhd_chipup_sem;
+int dhd_registration_check = FALSE;
 
 #define DHD_REGISTRATION_TIMEOUT  12000  /* msec : allowed time to finished dhd registration */
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
@@ -322,12 +346,32 @@ module_param(dhd_sysioc, uint, 0);
 /* Error bits */
 module_param(dhd_msg_level, int, 0);
 
+#ifdef ARP_OFFLOAD_SUPPORT
+/* ARP offload enable */
+uint dhd_arp_enable = TRUE;
+module_param(dhd_arp_enable, uint, 0);
+
+/* ARP offload agent mode : Enable ARP Host Auto-Reply and ARP Peer Auto-Reply */
+
+uint dhd_arp_mode = ARP_OL_AGENT | ARP_OL_PEER_AUTO_REPLY;
+
+module_param(dhd_arp_mode, uint, 0);
+#endif /* ARP_OFFLOAD_SUPPORT */
+
+
+
+/* Disable Prop tx */
+module_param(disable_proptx, int, 0644);
 /* load firmware and/or nvram values from the filesystem */
 module_param_string(firmware_path, firmware_path, MOD_PARAM_PATHLEN, 0660);
 module_param_string(nvram_path, nvram_path, MOD_PARAM_PATHLEN, 0);
 
 /* Watchdog interval */
-uint dhd_watchdog_ms = 0;
+
+/* extend watchdog expiration to 2 seconds when DPC is running */
+#define WATCHDOG_EXTEND_INTERVAL (2000)
+
+uint dhd_watchdog_ms = 10;
 module_param(dhd_watchdog_ms, uint, 0);
 
 #if defined(DHD_DEBUG)
@@ -339,43 +383,48 @@ module_param(dhd_console_ms, uint, 0644);
 uint dhd_slpauto = TRUE;
 module_param(dhd_slpauto, uint, 0);
 
-/* ARP offload agent mode : Enable ARP Host Auto-Reply and ARP Peer Auto-Reply */
-uint dhd_arp_mode = 0xb;
-module_param(dhd_arp_mode, uint, 0);
-
-/* ARP offload enable */
-uint dhd_arp_enable = TRUE;
-module_param(dhd_arp_enable, uint, 0);
-
 #ifdef PKT_FILTER_SUPPORT
 /* Global Pkt filter enable control */
 uint dhd_pkt_filter_enable = TRUE;
 module_param(dhd_pkt_filter_enable, uint, 0);
 #endif
 
-/*  Pkt filter init setup */
+/* Pkt filter init setup */
 uint dhd_pkt_filter_init = 0;
 module_param(dhd_pkt_filter_init, uint, 0);
 
 /* Pkt filter mode control */
+#ifdef GAN_LITE_NAT_KEEPALIVE_FILTER
+uint dhd_master_mode = FALSE;
+#else
 uint dhd_master_mode = TRUE;
-module_param(dhd_master_mode, uint, 1);
+#endif /* GAL_LITE_NAT_KEEPALIVE_FILTER */
+module_param(dhd_master_mode, uint, 0);
 
 #ifdef DHDTHREAD
-/* Watchdog thread priority, -1 to use kernel timer */
-int dhd_watchdog_prio = 97;
+int dhd_watchdog_prio = 0;
 module_param(dhd_watchdog_prio, int, 0);
 
-/* DPC thread priority, -1 to use tasklet */
-int dhd_dpc_prio = 98;
+/* DPC thread priority */
+int dhd_dpc_prio = CUSTOM_DPC_PRIO_SETTING;
 module_param(dhd_dpc_prio, int, 0);
 
+#ifdef RXFRAME_THREAD
+/* RX frame thread priority */
+int dhd_rxf_prio = CUSTOM_RXF_PRIO_SETTING;
+module_param(dhd_rxf_prio, int, 0);
+#endif /* RXFRAME_THREAD */
+
 /* DPC thread priority, -1 to use tasklet */
-extern int dhd_dongle_memsize;
-module_param(dhd_dongle_memsize, int, 0);
+extern int dhd_dongle_ramsize;
+module_param(dhd_dongle_ramsize, int, 0);
 #endif /* DHDTHREAD */
 /* Control fw roaming */
+#ifdef BCMCCX
+uint dhd_roam_disable = 0;
+#else
 uint dhd_roam_disable = 0;
+#endif /* BCMCCX */
 
 /* Control radio state */
 uint dhd_radio_up = 1;
@@ -384,12 +433,6 @@ uint dhd_radio_up = 1;
 char iface_name[IFNAMSIZ] = {'\0'};
 module_param_string(iface_name, iface_name, IFNAMSIZ, 0);
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))
-#define BLOCKABLE()	(!in_atomic())
-#else
-#define BLOCKABLE()	(!in_interrupt())
-#endif
-
 /* The following are specific to the SDIO dongle */
 
 /* IOCTL response timeout */
@@ -455,6 +498,8 @@ static char dhd_version[] = "Dongle Host Driver, version " EPI_VERSION_STR
 ;
 static void dhd_net_if_lock_local(dhd_info_t *dhd);
 static void dhd_net_if_unlock_local(dhd_info_t *dhd);
+static void dhd_suspend_lock(dhd_pub_t *dhdp);
+static void dhd_suspend_unlock(dhd_pub_t *dhdp);
 
 #ifdef WLMEDIA_HTSF
 void htsf_update(dhd_info_t *dhd, void *data);
@@ -473,13 +518,16 @@ int dhd_monitor_init(void *dhd_pub);
 int dhd_monitor_uninit(void);
 
 
-#if defined(CONFIG_WIRELESS_EXT)
+
+
+#if defined(WL_WIRELESS_EXT)
 struct iw_statistics *dhd_get_wireless_stats(struct net_device *dev);
-#endif /* defined(CONFIG_WIRELESS_EXT) */
+#endif /* defined(WL_WIRELESS_EXT) */
 
 static void dhd_dpc(ulong data);
 /* forward decl */
 extern int dhd_wait_pend8021x(struct net_device *dev);
+void dhd_os_wd_timer_extend(void *bus, bool extend);
 
 #ifdef TOE
 #ifndef BDC
@@ -497,7 +545,7 @@ static int dhd_sleep_pm_callback(struct notifier_block *nfb, unsigned long actio
 {
 	int ret = NOTIFY_DONE;
 
-#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 39))
+//#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 39))
 	switch (action) {
 	case PM_HIBERNATION_PREPARE:
 	case PM_SUSPEND_PREPARE:
@@ -511,49 +559,154 @@ static int dhd_sleep_pm_callback(struct notifier_block *nfb, unsigned long actio
 		break;
 	}
 	smp_mb();
-#endif
+//#endif
 	return ret;
 }
 
 static struct notifier_block dhd_sleep_pm_notifier = {
 	.notifier_call = dhd_sleep_pm_callback,
-	.priority = 0
+	.priority = 10
 };
 extern int register_pm_notifier(struct notifier_block *nb);
 extern int unregister_pm_notifier(struct notifier_block *nb);
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_PM_SLEEP) */
 
-static void dhd_set_packet_filter(int value, dhd_pub_t *dhd)
+#if defined(DHDTHREAD) && defined(RXFRAME_THREAD)
+/* Request scheduling of the bus rx frame */
+static void dhd_sched_rxf(dhd_pub_t *dhdp, void *skb);
+static void dhd_os_rxflock(dhd_pub_t *pub);
+static void dhd_os_rxfunlock(dhd_pub_t *pub);
+
+static inline int dhd_rxf_enqueue(dhd_pub_t *dhdp, void* skb)
+{
+	uint32 store_idx;
+	uint32 sent_idx;
+
+	if (!skb) {
+		DHD_ERROR(("dhd_rxf_enqueue: NULL skb!!!\n"));
+		return BCME_ERROR;
+	}
+
+	dhd_os_rxflock(dhdp);
+	store_idx = dhdp->store_idx;
+	sent_idx = dhdp->sent_idx;
+	if (dhdp->skbbuf[store_idx] != NULL) {
+		/* Make sure the previous packets are processed */
+		/* Do I need to make this context sleep here? Definitely in Single processor case */
+		dhd_os_rxfunlock(dhdp);
+		DHD_ERROR(("dhd_rxf_enqueue: pktbuf not consumed %p, store idx %d sent idx %d\n",
+			skb, store_idx, sent_idx));
+		msleep(1);
+		return BCME_ERROR;
+	}
+	DHD_TRACE(("dhd_rxf_enqueue: Store SKB %p. idx %d -> %d\n",
+		skb, store_idx, (store_idx + 1) & (MAXSKBPEND - 1)));
+	dhdp->skbbuf[store_idx] = skb;
+	dhdp->store_idx = (store_idx + 1) & (MAXSKBPEND - 1);
+	dhd_os_rxfunlock(dhdp);
+
+	return BCME_OK;
+}
+
+static inline void* dhd_rxf_dequeue(dhd_pub_t *dhdp)
+{
+	uint32 store_idx;
+	uint32 sent_idx;
+	void *skb;
+
+	dhd_os_rxflock(dhdp);
+
+	store_idx = dhdp->store_idx;
+	sent_idx = dhdp->sent_idx;
+	skb = dhdp->skbbuf[sent_idx];
+
+	if (skb == NULL) {
+		dhd_os_rxfunlock(dhdp);
+		DHD_ERROR(("dhd_rxf_dequeue: Dequeued packet is NULL, store idx %d sent idx %d\n",
+			store_idx, sent_idx));
+		return NULL;
+	}
+
+	dhdp->skbbuf[sent_idx] = NULL;
+	dhdp->sent_idx = (sent_idx + 1) & (MAXSKBPEND - 1);
+
+	DHD_TRACE(("dhd_rxf_dequeue: netif_rx_ni(%p), sent idx %d\n",
+		skb, sent_idx));
+
+	dhd_os_rxfunlock(dhdp);
+
+	return skb;
+}
+#endif /* defined(DHDTHREAD) && defined(RXFRAME_THREAD) */
+
+void dhd_set_packet_filter(dhd_pub_t *dhd)
 {
 #ifdef PKT_FILTER_SUPPORT
-	DHD_TRACE(("%s: %d\n", __FUNCTION__, value));
-	/* 1 - Enable packet filter, only allow unicast packet to send up */
-	/* 0 - Disable packet filter */
-	if (dhd_pkt_filter_enable && !dhd->dhcp_in_progress) {
-		int i;
+	int i;
 
+	DHD_TRACE(("%s: enter\n", __FUNCTION__));
+	if (dhd_pkt_filter_enable) {
 		for (i = 0; i < dhd->pktfilter_count; i++) {
 			dhd_pktfilter_offload_set(dhd, dhd->pktfilter[i]);
+		}
+	}
+#endif /* PKT_FILTER_SUPPORT */
+}
+
+void dhd_enable_packet_filter(int value, dhd_pub_t *dhd)
+{
+#ifdef PKT_FILTER_SUPPORT
+	int i;
+
+	DHD_TRACE(("%s: enter, value = %d\n", __FUNCTION__, value));
+	/* 1 - Enable packet filter, only allow unicast packet to send up */
+	/* 0 - Disable packet filter */
+	if (dhd_pkt_filter_enable && (!value ||
+	    (dhd_support_sta_mode(dhd) && !dhd->dhcp_in_progress)))
+	    {
+		for (i = 0; i < dhd->pktfilter_count; i++) {
+#ifdef PASS_ARP_PACKET
+			if (value && (i == dhd->pktfilter_count -1) &&
+				!(dhd->op_mode & (DHD_FLAG_P2P_GC_MODE | DHD_FLAG_P2P_GO_MODE))) {
+				DHD_TRACE_HW4(("Do not turn on ARP white list pkt filter:"
+					"val %d, cnt %d, op_mode 0x%x\n",
+					value, i, dhd->op_mode));
+				continue;
+			}
+#endif
 			dhd_pktfilter_offload_enable(dhd, dhd->pktfilter[i],
 				value, dhd_master_mode);
 		}
 	}
-#endif
+#endif /* PKT_FILTER_SUPPORT */
 }
 
-#if defined(CONFIG_HAS_EARLYSUSPEND)
+#define mpc_patch 0
+
 static int dhd_set_suspend(int value, dhd_pub_t *dhd)
 {
+#ifndef SUPPORT_PM2_ONLY
 	int power_mode = PM_MAX;
+#endif /* SUPPORT_PM2_ONLY */
 	/* wl_pkt_filter_enable_t	enable_parm; */
 	char iovbuf[32];
-	int bcn_li_dtim = 3;
+	int bcn_li_dtim = 0; /* Default bcn_li_dtim in resume mode is 0 */
+#ifndef ENABLE_FW_ROAM_SUSPEND
 	uint roamvar = 1;
+#endif /* ENABLE_FW_ROAM_SUSPEND */
+
+#ifdef mpc_patch
+		int mpc = 1;
+#endif
+
+	if (!dhd)
+		return -ENODEV;
 
 	DHD_TRACE(("%s: enter, value = %d in_suspend=%d\n",
 		__FUNCTION__, value, dhd->in_suspend));
 
-	if (dhd && dhd->up) {
+	dhd_suspend_lock(dhd);
+	if (dhd->up) {
 		if (value && dhd->in_suspend) {
 #ifdef PKT_FILTER_SUPPORT
 				dhd->early_suspended = 1;
@@ -561,86 +714,108 @@ static int dhd_set_suspend(int value, dhd_pub_t *dhd)
 				/* Kernel suspended */
 				DHD_ERROR(("%s: force extra Suspend setting \n", __FUNCTION__));
 
+#ifndef SUPPORT_PM2_ONLY
 				dhd_wl_ioctl_cmd(dhd, WLC_SET_PM, (char *)&power_mode,
 				                 sizeof(power_mode), TRUE, 0);
+#endif /* SUPPORT_PM2_ONLY */
 
 				/* Enable packet filter, only allow unicast packet to send up */
-				dhd_set_packet_filter(1, dhd);
+				dhd_enable_packet_filter(1, dhd);
+
 
 				/* If DTIM skip is set up as default, force it to wake
 				 * each third DTIM for better power savings.  Note that
 				 * one side effect is a chance to miss BC/MC packet.
 				 */
-				bcn_li_dtim = dhd_get_dtim_skip(dhd);
+				bcn_li_dtim = dhd_get_suspend_bcn_li_dtim(dhd);
 				bcm_mkiovar("bcn_li_dtim", (char *)&bcn_li_dtim,
 					4, iovbuf, sizeof(iovbuf));
-				dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
+				if (dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf),
+					TRUE, 0) < 0)
+					DHD_ERROR(("%s: set dtim failed\n", __FUNCTION__));
 
+#ifndef ENABLE_FW_ROAM_SUSPEND
 				/* Disable firmware roaming during suspend */
 				bcm_mkiovar("roam_off", (char *)&roamvar, 4,
 					iovbuf, sizeof(iovbuf));
 				dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
+#endif /* ENABLE_FW_ROAM_SUSPEND */
+#ifdef mpc_patch
+				bcm_mkiovar("mpc",(char*)&mpc, 4, iovbuf, sizeof(iovbuf));
+				dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
+#endif
 			} else {
 #ifdef PKT_FILTER_SUPPORT
 				dhd->early_suspended = 0;
 #endif
 				/* Kernel resumed  */
-				DHD_TRACE(("%s: Remove extra suspend setting \n", __FUNCTION__));
+				DHD_ERROR(("%s: Remove extra suspend setting \n", __FUNCTION__));
 
+#ifndef SUPPORT_PM2_ONLY
 				power_mode = PM_FAST;
 				dhd_wl_ioctl_cmd(dhd, WLC_SET_PM, (char *)&power_mode,
 				                 sizeof(power_mode), TRUE, 0);
-
+#endif /* SUPPORT_PM2_ONLY */
+#ifdef PKT_FILTER_SUPPORT
 				/* disable pkt filter */
-				dhd_set_packet_filter(0, dhd);
+				dhd_enable_packet_filter(0, dhd);
+#endif /* PKT_FILTER_SUPPORT */
 
 				/* restore pre-suspend setting for dtim_skip */
-				bcm_mkiovar("bcn_li_dtim", (char *)&dhd->dtim_skip,
+				bcm_mkiovar("bcn_li_dtim", (char *)&bcn_li_dtim,
 					4, iovbuf, sizeof(iovbuf));
 
 				dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
+#ifndef ENABLE_FW_ROAM_SUSPEND
 				roamvar = dhd_roam_disable;
 				bcm_mkiovar("roam_off", (char *)&roamvar, 4, iovbuf,
 					sizeof(iovbuf));
 				dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
+#endif /* ENABLE_FW_ROAM_SUSPEND */
 			}
 	}
+	dhd_suspend_unlock(dhd);
 
 	return 0;
 }
 
-static void dhd_suspend_resume_helper(struct dhd_info *dhd, int val)
+static int dhd_suspend_resume_helper(struct dhd_info *dhd, int val, int force)
 {
 	dhd_pub_t *dhdp = &dhd->pub;
+	int ret = 0;
 
 	DHD_OS_WAKE_LOCK(dhdp);
 	/* Set flag when early suspend was called */
 	dhdp->in_suspend = val;
-	if ((!dhdp->suspend_disable_flag) && (dhd_check_ap_wfd_mode_set(dhdp) == FALSE))
-		dhd_set_suspend(val, dhdp);
+	if ((force || !dhdp->suspend_disable_flag) &&
+		dhd_support_sta_mode(dhdp))
+	{
+		ret = dhd_set_suspend(val, dhdp);
+	}
+
 	DHD_OS_WAKE_UNLOCK(dhdp);
+	return ret;
 }
 
+#if defined(CONFIG_HAS_EARLYSUSPEND) && defined(DHD_USE_EARLYSUSPEND)
 static void dhd_early_suspend(struct early_suspend *h)
 {
 	struct dhd_info *dhd = container_of(h, struct dhd_info, early_suspend);
-
-	DHD_TRACE(("%s: enter\n", __FUNCTION__));
+	DHD_TRACE_HW4(("%s: enter\n", __FUNCTION__));
 
 	if (dhd)
-		dhd_suspend_resume_helper(dhd, 1);
+		dhd_suspend_resume_helper(dhd, 1, 0);
 }
 
 static void dhd_late_resume(struct early_suspend *h)
 {
 	struct dhd_info *dhd = container_of(h, struct dhd_info, early_suspend);
-
-	DHD_TRACE(("%s: enter\n", __FUNCTION__));
+	DHD_TRACE_HW4(("%s: enter\n", __FUNCTION__));
 
 	if (dhd)
-		dhd_suspend_resume_helper(dhd, 0);
+		dhd_suspend_resume_helper(dhd, 0, 0);
 }
-#endif /* defined(CONFIG_HAS_EARLYSUSPEND) */
+#endif /* CONFIG_HAS_EARLYSUSPEND && DHD_USE_EARLYSUSPEND */
 
 /*
  * Generalized timeout mechanism.  Uses spin sleep with exponential back-off until
@@ -660,7 +835,7 @@ dhd_timeout_start(dhd_timeout_t *tmo, uint usec)
 	tmo->limit = usec;
 	tmo->increment = 0;
 	tmo->elapsed = 0;
-	tmo->tick = 1000000 / HZ;
+	tmo->tick = jiffies_to_usecs(1);
 }
 
 int
@@ -686,16 +861,12 @@ dhd_timeout_expired(dhd_timeout_t *tmo)
 	} else {
 		wait_queue_head_t delay_wait;
 		DECLARE_WAITQUEUE(wait, current);
-		int pending;
 		init_waitqueue_head(&delay_wait);
 		add_wait_queue(&delay_wait, &wait);
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(1);
-		pending = signal_pending(current);
 		remove_wait_queue(&delay_wait, &wait);
 		set_current_state(TASK_RUNNING);
-		if (pending)
-			return 1;	/* Interrupted */
 	}
 
 	return 0;
@@ -802,21 +973,24 @@ _dhd_set_multicast_list(dhd_info_t *dhd, int ifidx)
 	uint buflen;
 	int ret;
 
-	ASSERT(dhd && dhd->iflist[ifidx]);
-	dev = dhd->iflist[ifidx]->net;
+			ASSERT(dhd && dhd->iflist[ifidx]);
+			dev = dhd->iflist[ifidx]->net;
+			if (!dev)
+				return;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
-	netif_addr_lock_bh(dev);
+			netif_addr_lock_bh(dev);
 #endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
-	cnt = netdev_mc_count(dev);
+			cnt = netdev_mc_count(dev);
 #else
-	cnt = dev->mc_count;
-#endif
+			cnt = dev->mc_count;
+#endif /* LINUX_VERSION_CODE */
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
-	netif_addr_unlock_bh(dev);
+			netif_addr_unlock_bh(dev);
 #endif
 
-	/* Determine initial value of allmulti flag */
+			/* Determine initial value of allmulti flag */
 	allmulti = (dev->flags & IFF_ALLMULTI) ? TRUE : FALSE;
 
 	/* Send down the multicast list first. */
@@ -829,32 +1003,36 @@ _dhd_set_multicast_list(dhd_info_t *dhd, int ifidx)
 		return;
 	}
 
-	strcpy(bufp, "mcast_list");
+	strncpy(bufp, "mcast_list", buflen - 1);
+	bufp[buflen - 1] = '\0';
 	bufp += strlen("mcast_list") + 1;
 
 	cnt = htol32(cnt);
 	memcpy(bufp, &cnt, sizeof(cnt));
 	bufp += sizeof(cnt);
 
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
-	netif_addr_lock_bh(dev);
+			netif_addr_lock_bh(dev);
 #endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
-	netdev_for_each_mc_addr(ha, dev) {
-		if (!cnt)
-			break;
-		memcpy(bufp, ha->addr, ETHER_ADDR_LEN);
-		bufp += ETHER_ADDR_LEN;
-		cnt--;
+			netdev_for_each_mc_addr(ha, dev) {
+				if (!cnt)
+					break;
+				memcpy(bufp, ha->addr, ETHER_ADDR_LEN);
+				bufp += ETHER_ADDR_LEN;
+				cnt--;
 	}
 #else
-	for (mclist = dev->mc_list; (mclist && (cnt > 0)); cnt--, mclist = mclist->next) {
-		memcpy(bufp, (void *)mclist->dmi_addr, ETHER_ADDR_LEN);
-		bufp += ETHER_ADDR_LEN;
-	}
-#endif
+	for (mclist = dev->mc_list; (mclist && (cnt > 0));
+		cnt--, mclist = mclist->next) {
+				memcpy(bufp, (void *)mclist->dmi_addr, ETHER_ADDR_LEN);
+				bufp += ETHER_ADDR_LEN;
+			}
+#endif /* LINUX_VERSION_CODE */
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
-	netif_addr_unlock_bh(dev);
+			netif_addr_unlock_bh(dev);
 #endif
 
 	memset(&ioc, 0, sizeof(ioc));
@@ -909,6 +1087,7 @@ _dhd_set_multicast_list(dhd_info_t *dhd, int ifidx)
 	/* Finally, pick up the PROMISC flag as well, like the NIC driver does */
 
 	allmulti = (dev->flags & IFF_PROMISC) ? TRUE : FALSE;
+
 	allmulti = htol32(allmulti);
 
 	memset(&ioc, 0, sizeof(ioc));
@@ -924,13 +1103,17 @@ _dhd_set_multicast_list(dhd_info_t *dhd, int ifidx)
 	}
 }
 
-static int
+int
 _dhd_set_mac_address(dhd_info_t *dhd, int ifidx, struct ether_addr *addr)
 {
 	char buf[32];
 	wl_ioctl_t ioc;
 	int ret;
 
+	if (module_remove) {
+		printf("%s: module removed.\n", __FUNCTION__);
+		return -1;
+	}
 	if (!bcm_mkiovar("cur_etheraddr", (char*)addr, ETHER_ADDR_LEN, buf, 32)) {
 		DHD_ERROR(("%s: mkiovar failed for cur_etheraddr\n", dhd_ifname(&dhd->pub, ifidx)));
 		return -1;
@@ -993,7 +1176,7 @@ dhd_op_if(dhd_if_t *ifp)
 		}
 		/* Allocate etherdev, including space for private structure */
 		if (!(ifp->net = alloc_etherdev(sizeof(dhd)))) {
-			DHD_ERROR(("%s: OOM - alloc_etherdev\n", __FUNCTION__));
+			DHD_ERROR(("%s: OOM - alloc_etherdev(%d)\n", __FUNCTION__, sizeof(dhd)));
 			ret = -ENOMEM;
 		}
 		if (ret == 0) {
@@ -1038,14 +1221,19 @@ dhd_op_if(dhd_if_t *ifp)
 		ifp->state = DHD_IF_DELETING;
 		if (ifp->net != NULL) {
 			DHD_TRACE(("\n%s: got 'DHD_IF_DEL' state\n", __FUNCTION__));
+			netif_stop_queue(ifp->net);
 #ifdef WL_CFG80211
 			if (dhd->dhd_state & DHD_ATTACH_STATE_CFG80211) {
-				wl_cfg80211_notify_ifdel(ifp->net);
+				wl_cfg80211_ifdel_ops(ifp->net);
 			}
 #endif
-			netif_stop_queue(ifp->net);
 			unregister_netdev(ifp->net);
 			ret = DHD_DEL_IF;	/* Make sure the free_netdev() is called */
+#ifdef WL_CFG80211
+			if (dhd->dhd_state & DHD_ATTACH_STATE_CFG80211) {
+				wl_cfg80211_notify_ifdel();
+			}
+#endif
 		}
 		break;
 	case DHD_IF_DELETING:
@@ -1073,6 +1261,7 @@ dhd_op_if(dhd_if_t *ifp)
 	}
 }
 
+
 static int
 _dhd_sysioc_thread(void *data)
 {
@@ -1086,9 +1275,11 @@ _dhd_sysioc_thread(void *data)
 	unsigned long flags;
 #endif
 
+#ifndef USE_KTHREAD_API
 	DAEMONIZE("dhd_sysioc");
 
 	complete(&tsk->completed);
+#endif
 
 	while (down_interruptible(&tsk->sema) == 0) {
 
@@ -1131,13 +1322,24 @@ _dhd_sysioc_thread(void *data)
 					continue;
 				}
 #endif /* SOFTAP */
+				if (dhd->pub.up == 0)
+					continue;
 				if (dhd->iflist[i]->set_multicast) {
 					dhd->iflist[i]->set_multicast = FALSE;
 					_dhd_set_multicast_list(dhd, i);
+
 				}
 				if (dhd->set_macaddress == i+1) {
 					dhd->set_macaddress = 0;
-					_dhd_set_mac_address(dhd, i, &dhd->macvalue);
+					if (_dhd_set_mac_address(dhd, i, &dhd->macvalue) == 0) {
+						DHD_INFO((
+							"%s: MACID is overwritten\n",
+							__FUNCTION__));
+					} else {
+						DHD_ERROR((
+							"%s: _dhd_set_mac_address() failed\n",
+							__FUNCTION__));
+					}
 				}
 			}
 		}
@@ -1162,7 +1364,7 @@ dhd_set_mac_address(struct net_device *dev, void *addr)
 	if (ifidx == DHD_BAD_IF)
 		return -1;
 
-	ASSERT(&dhd->thr_sysioc_ctl.thr_pid >= 0);
+	ASSERT(dhd->thr_sysioc_ctl.thr_pid >= 0);
 	memcpy(&dhd->macvalue, sa->sa_data, ETHER_ADDR_LEN);
 	dhd->set_macaddress = ifidx+1;
 	up(&dhd->thr_sysioc_ctl.sema);
@@ -1176,11 +1378,16 @@ dhd_set_multicast_list(struct net_device *dev)
 	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
 	int ifidx;
 
+	printf("enter %s\n", __func__);
+	if ( !dhd->pub.up || (dhd->pub.busstate == DHD_BUS_DOWN) || module_remove) {
+		printf("%s: dhd is down module_remove[%d]. skip it.\n", __func__,module_remove);
+		return;
+	}
 	ifidx = dhd_net2idx(dhd, dev);
 	if (ifidx == DHD_BAD_IF)
 		return;
 
-	ASSERT(&dhd->thr_sysioc_ctl.thr_pid >= 0);
+	ASSERT(dhd->thr_sysioc_ctl.thr_pid >= 0);
 	dhd->iflist[ifidx]->set_multicast = TRUE;
 	up(&dhd->thr_sysioc_ctl.sema);
 }
@@ -1200,7 +1407,6 @@ dhd_os_wlfc_unblock(dhd_pub_t *pub)
 {
 	dhd_info_t *di = (dhd_info_t *)(pub->info);
 
-	(void)di;
 	ASSERT(di != NULL);
 	spin_unlock_bh(&di->wlfc_spinlock);
 	return 1;
@@ -1214,7 +1420,7 @@ uint8 prio2fifo[8] = { 1, 0, 0, 1, 2, 2, 3, 3 };
 int
 dhd_sendpkt(dhd_pub_t *dhdp, int ifidx, void *pktbuf)
 {
-	int ret;
+	int ret = BCME_OK;
 	dhd_info_t *dhd = (dhd_info_t *)(dhdp->info);
 	struct ether_header *eh = NULL;
 
@@ -1240,7 +1446,9 @@ dhd_sendpkt(dhd_pub_t *dhdp, int ifidx, void *pktbuf)
 	}
 
 	/* Look into the packet and update the packet priority */
+#ifndef PKTPRIO_OVERRIDE
 	if (PKTPRIO(pktbuf) == 0)
+#endif 
 		pktsetprio(pktbuf, FALSE);
 
 #ifdef PROP_TXSTATUS
@@ -1267,21 +1475,23 @@ dhd_sendpkt(dhd_pub_t *dhdp, int ifidx, void *pktbuf)
 	dhd_htsf_addtxts(dhdp, pktbuf);
 #endif
 #ifdef PROP_TXSTATUS
+	{
+	dhd_os_wlfc_block(dhdp);
 	if (dhdp->wlfc_state && ((athost_wl_status_info_t*)dhdp->wlfc_state)->proptxstatus_mode
 		!= WLFC_FCMODE_NONE) {
-		dhd_os_wlfc_block(dhdp);
-		ret = dhd_wlfc_enque_sendq(dhdp->wlfc_state, DHD_PKTTAG_FIFO(PKTTAG(pktbuf)),
-			pktbuf);
 		dhd_wlfc_commit_packets(dhdp->wlfc_state,  (f_commitpkt_t)dhd_bus_txdata,
-			dhdp->bus);
+			dhdp->bus, pktbuf);
 		if (((athost_wl_status_info_t*)dhdp->wlfc_state)->toggle_host_if) {
 			((athost_wl_status_info_t*)dhdp->wlfc_state)->toggle_host_if = 0;
 		}
 		dhd_os_wlfc_unblock(dhdp);
 	}
-	else
+	else {
+		dhd_os_wlfc_unblock(dhdp);
 		/* non-proptxstatus way */
-	ret = dhd_bus_txdata(dhdp->bus, pktbuf);
+		ret = dhd_bus_txdata(dhdp->bus, pktbuf);
+	}
+	}
 #else
 	ret = dhd_bus_txdata(dhdp->bus, pktbuf);
 #endif /* PROP_TXSTATUS */
@@ -1293,8 +1503,10 @@ int
 dhd_start_xmit(struct sk_buff *skb, struct net_device *net)
 {
 	int ret;
+	uint datalen;
 	void *pktbuf;
-	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(net);
+	dhd_info_t *dhd  =  *(dhd_info_t **)netdev_priv(net);
+	dhd_if_t *ifp = NULL;
 	int ifidx;
 #ifdef WLMEDIA_HTSF
 	uint8 htsfdlystat_sz = dhd->pub.htsfdlystat_sz;
@@ -1303,16 +1515,22 @@ dhd_start_xmit(struct sk_buff *skb, struct net_device *net)
 #endif
 
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
+	if (module_remove) {
+		printf("%s: module removed.", __FUNCTION__);
+		dev_kfree_skb(skb); /* Add to free skb */
+		netif_stop_queue(net);
+		return -ENODEV;
+	}
 
 	DHD_OS_WAKE_LOCK(&dhd->pub);
 
 	/* Reject if down */
-	if (!dhd->pub.up || (dhd->pub.busstate == DHD_BUS_DOWN)) {
+	if (dhd->pub.busstate == DHD_BUS_DOWN || dhd->pub.hang_was_sent) {
 		DHD_ERROR(("%s: xmit rejected pub.up=%d busstate=%d \n",
 			__FUNCTION__, dhd->pub.up, dhd->pub.busstate));
 		netif_stop_queue(net);
 		/* Send Event when bus down detected during data session */
-		if (dhd->pub.busstate == DHD_BUS_DOWN)  {
+		if (dhd->pub.up) {
 			DHD_ERROR(("%s: Event HANG sent up\n", __FUNCTION__));
 			net_os_send_hang_message(net);
 		}
@@ -1336,6 +1554,9 @@ dhd_start_xmit(struct sk_buff *skb, struct net_device *net)
 #endif
 	}
 
+	ifp = dhd->iflist[ifidx];
+	datalen  = PKTLEN(dhdp->osh, skb);
+
 	/* Make sure there's enough room for any header */
 
 	if (skb_headroom(skb) < dhd->pub.hdrlen + htsfdlystat_sz) {
@@ -1378,12 +1599,15 @@ dhd_start_xmit(struct sk_buff *skb, struct net_device *net)
 
 	ret = dhd_sendpkt(&dhd->pub, ifidx, pktbuf);
 
-
 done:
-	if (ret)
-		dhd->pub.dstats.tx_dropped++;
-	else
-		dhd->pub.tx_packets++;
+	if (ret) {
+			ifp->stats.tx_dropped++;
+	}
+	else {
+			dhd->pub.tx_packets++;
+			ifp->stats.tx_packets++;
+			ifp->stats.tx_bytes += datalen;
+	}
 
 	DHD_OS_WAKE_UNLOCK(&dhd->pub);
 
@@ -1404,11 +1628,11 @@ dhd_txflowcontrol(dhd_pub_t *dhdp, int ifidx, bool state)
 
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
-	dhdp->txoff = state;
 	ASSERT(dhd);
 
 	if (ifidx == ALL_INTERFACES) {
 		/* Flow control on all active interfaces */
+		dhdp->txoff = state;
 		for (i = 0; i < DHD_MAX_IFS; i++) {
 			if (dhd->iflist[i]) {
 				net = dhd->iflist[i]->net;
@@ -1430,6 +1654,36 @@ dhd_txflowcontrol(dhd_pub_t *dhdp, int ifidx, bool state)
 	}
 }
 
+#ifdef DHD_RX_DUMP
+typedef struct {
+	uint16 type;
+	const char *str;
+} PKTTYPE_INFO;
+
+static const PKTTYPE_INFO packet_type_info[] =
+{
+	{ ETHER_TYPE_IP, "IP" },
+	{ ETHER_TYPE_ARP, "ARP" },
+	{ ETHER_TYPE_BRCM, "BRCM" },
+	{ ETHER_TYPE_802_1X, "802.1X" },
+	{ ETHER_TYPE_WAI, "WAPI" },
+	{ 0, ""}
+};
+
+static const char *_get_packet_type_str(uint16 type)
+{
+	int i;
+	int n = sizeof(packet_type_info)/sizeof(packet_type_info[1]) - 1;
+
+	for (i = 0; i < n; i++) {
+		if (packet_type_info[i].type == type)
+			return packet_type_info[i].str;
+	}
+
+	return packet_type_info[n].str;
+}
+#endif /* DHD_RX_DUMP */
+
 void
 dhd_rx_frame(dhd_pub_t *dhdp, int ifidx, void *pktbuf, int numpkt, uint8 chan)
 {
@@ -1441,18 +1695,44 @@ dhd_rx_frame(dhd_pub_t *dhdp, int ifidx, void *pktbuf, int numpkt, uint8 chan)
 	int i;
 	dhd_if_t *ifp;
 	wl_event_msg_t event;
-	int tout = DHD_PACKET_TIMEOUT_MS;
-
+	int tout_rx = 0;
+	int tout_ctrl = 0;
+#if defined(DHDTHREAD) && defined(RXFRAME_THREAD)
+	void *skbhead = NULL;
+	void *skbprev = NULL;
+#endif /* defined(DHDTHREAD) && defined(RXFRAME_THREAD) */
+#ifdef DHD_RX_DUMP
+#ifdef DHD_RX_FULL_DUMP
+	int k;
+#endif /* DHD_RX_FULL_DUMP */
+	char *dump_data;
+	uint16 protocol;
+#endif /* DHD_RX_DUMP */
 
-	BCM_REFERENCE(tout);
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
+	if (module_remove || (!module_insert)) {
+		for (i = 0; pktbuf && i < numpkt; i++, pktbuf = pnext) {
+			pnext = PKTNEXT(dhdp->osh, pktbuf);
+			PKTSETNEXT(wl->sh.osh, pktbuf, NULL);
+			skb = PKTTONATIVE(dhdp->osh, pktbuf);
+			dev_kfree_skb_any(skb);
+		}
+		if (!module_insert)
+			DHD_ERROR(("%s: module not insert, skip\n", __FUNCTION__));
+		else
+			DHD_ERROR(("%s: module removed. skip rx frame\n", __FUNCTION__));
+		return;
+	}
 	for (i = 0; pktbuf && i < numpkt; i++, pktbuf = pnext) {
 #ifdef WLBTAMP
 		struct ether_header *eh;
 		struct dot11_llc_snap_header *lsh;
 #endif
 
+		pnext = PKTNEXT(dhdp->osh, pktbuf);
+		PKTSETNEXT(wl->sh.osh, pktbuf, NULL);
+
 		ifp = dhd->iflist[ifidx];
 		if (ifp == NULL) {
 			DHD_ERROR(("%s: ifp is NULL. drop packet\n",
@@ -1462,17 +1742,17 @@ dhd_rx_frame(dhd_pub_t *dhdp, int ifidx, void *pktbuf, int numpkt, uint8 chan)
 		}
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
 		/* Dropping packets before registering net device to avoid kernel panic */
-		if (!ifp->net || ifp->net->reg_state != NETREG_REGISTERED ||
-			!dhd->pub.up) {
+#ifndef PROP_TXSTATUS_VSDB
+		if (!ifp->net || ifp->net->reg_state != NETREG_REGISTERED) {
+#else
+		if (!ifp->net || ifp->net->reg_state != NETREG_REGISTERED || !dhd->pub.up) {
+#endif /* PROP_TXSTATUS_VSDB */
 			DHD_ERROR(("%s: net device is NOT registered yet. drop packet\n",
 			__FUNCTION__));
 			PKTFREE(dhdp->osh, pktbuf, TRUE);
 			continue;
 		}
-#endif
-
-		pnext = PKTNEXT(dhdp->osh, pktbuf);
-		PKTSETNEXT(wl->sh.osh, pktbuf, NULL);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0) */
 
 #ifdef WLBTAMP
 		eh = (struct ether_header *)PKTDATA(wl->sh.osh, pktbuf);
@@ -1514,6 +1794,46 @@ dhd_rx_frame(dhd_pub_t *dhdp, int ifidx, void *pktbuf, int numpkt, uint8 chan)
 		eth = skb->data;
 		len = skb->len;
 
+#ifdef DHD_RX_DUMP
+		dump_data = skb->data;
+		protocol = (dump_data[12] << 8) | dump_data[13];
+		DHD_ERROR(("RX DUMP - %s\n", _get_packet_type_str(protocol)));
+
+#ifdef DHD_RX_FULL_DUMP
+		if (protocol != ETHER_TYPE_BRCM) {
+			for (k = 0; k < skb->len; k++) {
+				DHD_ERROR(("%02X ", dump_data[k]));
+				if ((k & 15) == 15)
+					DHD_ERROR(("\n"));
+			}
+			DHD_ERROR(("\n"));
+		}
+#endif /* DHD_RX_FULL_DUMP */
+
+		if (protocol != ETHER_TYPE_BRCM) {
+			if (dump_data[0] == 0xFF) {
+				DHD_ERROR(("%s: BROADCAST\n", __FUNCTION__));
+
+				if ((dump_data[12] == 8) &&
+					(dump_data[13] == 6)) {
+					DHD_ERROR(("%s: ARP %d\n",
+						__FUNCTION__, dump_data[0x15]));
+				}
+			} else if (dump_data[0] & 1) {
+				DHD_ERROR(("%s: MULTICAST: " MACDBG "\n",
+					__FUNCTION__, MAC2STRDBG(dump_data)));
+			}
+
+			if (protocol == ETHER_TYPE_802_1X) {
+				DHD_ERROR(("ETHER_TYPE_802_1X: "
+					"ver %d, type %d, replay %d\n",
+					dump_data[14], dump_data[15],
+					dump_data[30]));
+			}
+		}
+
+#endif /* DHD_RX_DUMP */
+
 		ifp = dhd->iflist[ifidx];
 		if (ifp == NULL)
 			ifp = dhd->iflist[0];
@@ -1536,23 +1856,39 @@ dhd_rx_frame(dhd_pub_t *dhdp, int ifidx, void *pktbuf, int numpkt, uint8 chan)
 		skb_pull(skb, ETH_HLEN);
 
 		/* Process special event packets and then discard them */
+		memset(&event, 0, sizeof(event));
 		if (ntoh16(skb->protocol) == ETHER_TYPE_BRCM) {
 			dhd_wl_host_event(dhd, &ifidx,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22)
-			skb->mac_header,
+			skb_mac_header(skb),
 #else
 			skb->mac.raw,
 #endif
 			&event,
 			&data);
 
-#ifdef WLBTAMP
 			wl_event_to_host_order(&event);
+			if (!tout_ctrl)
+				tout_ctrl = DHD_PACKET_TIMEOUT_MS;
+#ifdef WLBTAMP
 			if (event.event_type == WLC_E_BTA_HCI_EVENT) {
 				dhd_bta_doevt(dhdp, data, event.datalen);
 			}
-			tout = DHD_EVENT_TIMEOUT_MS;
 #endif /* WLBTAMP */
+
+#if defined(PNO_SUPPORT)
+			if (event.event_type == WLC_E_PFN_NET_FOUND) {
+				/* enforce custom wake lock to garantee that Kernel not suspended */
+				tout_ctrl = CUSTOM_PNO_EVENT_LOCK_xTIME * DHD_PACKET_TIMEOUT_MS;
+			}
+#endif /* PNO_SUPPORT */
+
+#ifdef DHD_DONOT_FORWARD_BCMEVENT_AS_NETWORK_PKT
+			PKTFREE(dhdp->osh, pktbuf, TRUE);
+			continue;
+#endif
+		} else {
+			tout_rx = DHD_PACKET_TIMEOUT_MS;
 		}
 
 		ASSERT(ifidx < DHD_MAX_IFS && dhd->iflist[ifidx]);
@@ -1564,6 +1900,8 @@ dhd_rx_frame(dhd_pub_t *dhdp, int ifidx, void *pktbuf, int numpkt, uint8 chan)
 
 		dhdp->dstats.rx_bytes += skb->len;
 		dhdp->rx_packets++; /* Local count */
+		ifp->stats.rx_bytes += skb->len;
+		ifp->stats.rx_packets++;
 
 		if (in_interrupt()) {
 			netif_rx(skb);
@@ -1574,6 +1912,13 @@ dhd_rx_frame(dhd_pub_t *dhdp, int ifidx, void *pktbuf, int numpkt, uint8 chan)
 			 * by netif_rx_ni(), but in earlier kernels, we need
 			 * to do it manually.
 			 */
+#if defined(DHDTHREAD) && defined(RXFRAME_THREAD)
+			if (!skbhead)
+				skbhead = skb;
+			else
+				PKTSETNEXT(wl->sh.osh, skbprev, skb);
+			skbprev = skb;
+#else
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
 			netif_rx_ni(skb);
 #else
@@ -1583,9 +1928,15 @@ dhd_rx_frame(dhd_pub_t *dhdp, int ifidx, void *pktbuf, int numpkt, uint8 chan)
 			RAISE_RX_SOFTIRQ();
 			local_irq_restore(flags);
 #endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0) */
+#endif /* defined(DHDTHREAD) && defined(RXFRAME_THREAD) */
 		}
 	}
-	DHD_OS_WAKE_LOCK_TIMEOUT_ENABLE(dhdp, tout);
+#if defined(DHDTHREAD) && defined(RXFRAME_THREAD)
+	if (skbhead)
+		dhd_sched_rxf(dhdp, skbhead);
+#endif
+	DHD_OS_WAKE_LOCK_RX_TIMEOUT_ENABLE(dhdp, tout_rx);
+	DHD_OS_WAKE_LOCK_CTRL_TIMEOUT_ENABLE(dhdp, tout_ctrl);
 }
 
 void
@@ -1598,7 +1949,6 @@ dhd_event(struct dhd_info *dhd, char *evpkt, int evlen, int ifidx)
 void
 dhd_txcomplete(dhd_pub_t *dhdp, void *txp, bool success)
 {
-	uint ifidx;
 	dhd_info_t *dhd = (dhd_info_t *)(dhdp->info);
 	struct ether_header *eh;
 	uint16 type;
@@ -1606,7 +1956,7 @@ dhd_txcomplete(dhd_pub_t *dhdp, void *txp, bool success)
 	uint len;
 #endif
 
-	dhd_prot_hdrpull(dhdp, &ifidx, txp, NULL, NULL);
+	dhd_prot_hdrpull(dhdp, NULL, txp, NULL, NULL);
 
 	eh = (struct ether_header *)PKTDATA(dhdp->osh, txp);
 	type  = ntoh16(eh->ether_type);
@@ -1652,6 +2002,9 @@ dhd_get_stats(struct net_device *net)
 	ASSERT(dhd && ifp);
 
 	if (dhd->pub.up) {
+		if (module_remove) {
+			printf("%s: module removed. return old value. ifp=%p, dhd=%p\n", __FUNCTION__, ifp, dhd);
+		} else 
 		/* Use the protocol to get dongle stats */
 		dhd_prot_dstats(&dhd->pub);
 	}
@@ -1685,15 +2038,18 @@ dhd_watchdog_thread(void *data)
 			dhd_watchdog_prio:(MAX_RT_PRIO-1);
 		setScheduler(current, SCHED_FIFO, &param);
 	}
-
+#ifndef USE_KTHREAD_API
 	DAEMONIZE("dhd_watchdog");
 
 	/* Run until signal received */
 	complete(&tsk->completed);
+#endif
 
 	while (1)
 		if (down_interruptible (&tsk->sema) == 0) {
 			unsigned long flags;
+			unsigned long jiffies_at_start = jiffies;
+			unsigned long time_lapse;
 
 			SMP_RD_BARRIER_DEPENDS();
 			if (tsk->terminated) {
@@ -1710,14 +2066,17 @@ dhd_watchdog_thread(void *data)
 				flags = dhd_os_spin_lock(&dhd->pub);
 				/* Count the tick for reference */
 				dhd->pub.tickcnt++;
+				time_lapse = jiffies - jiffies_at_start;
+
 				/* Reschedule the watchdog */
 				if (dhd->wd_timer_valid)
 					mod_timer(&dhd->timer,
-					jiffies + dhd_watchdog_ms * HZ / 1000);
+					jiffies +
+					msecs_to_jiffies(dhd_watchdog_ms) -
+					min(msecs_to_jiffies(dhd_watchdog_ms), time_lapse));
 				dhd_os_spin_unlock(&dhd->pub, flags);
 			}
 			dhd_os_sdunlock(&dhd->pub);
-			DHD_OS_WAKE_UNLOCK(&dhd->pub);
 		} else {
 			break;
 	}
@@ -1731,9 +2090,7 @@ static void dhd_watchdog(ulong data)
 	dhd_info_t *dhd = (dhd_info_t *)data;
 	unsigned long flags;
 
-	DHD_OS_WAKE_LOCK(&dhd->pub);
 	if (dhd->pub.dongle_reset) {
-		DHD_OS_WAKE_UNLOCK(&dhd->pub);
 		return;
 	}
 
@@ -1754,10 +2111,9 @@ static void dhd_watchdog(ulong data)
 
 	/* Reschedule the watchdog */
 	if (dhd->wd_timer_valid)
-		mod_timer(&dhd->timer, jiffies + dhd_watchdog_ms * HZ / 1000);
+		mod_timer(&dhd->timer, jiffies + msecs_to_jiffies(dhd_watchdog_ms));
 	dhd_os_spin_unlock(&dhd->pub, flags);
 	dhd_os_sdunlock(&dhd->pub);
-	DHD_OS_WAKE_UNLOCK(&dhd->pub);
 }
 
 #ifdef DHDTHREAD
@@ -1776,12 +2132,17 @@ dhd_dpc_thread(void *data)
 		param.sched_priority = (dhd_dpc_prio < MAX_RT_PRIO)?dhd_dpc_prio:(MAX_RT_PRIO-1);
 		setScheduler(current, SCHED_FIFO, &param);
 	}
-
+#ifndef USE_KTHREAD_API
 	DAEMONIZE("dhd_dpc");
 	/* DHD_OS_WAKE_LOCK is called in dhd_sched_dpc[dhd_linux.c] down below  */
 
 	/*  signal: thread has started */
 	complete(&tsk->completed);
+#endif
+
+#ifdef CUSTOM_DPC_CPUCORE
+	set_cpus_allowed_ptr(current, cpumask_of(CUSTOM_DPC_CPUCORE));
+#endif
 
 	/* Run until signal received */
 	while (1) {
@@ -1794,12 +2155,13 @@ dhd_dpc_thread(void *data)
 
 			/* Call bus dpc unless it indicated down (then clean stop) */
 			if (dhd->pub.busstate != DHD_BUS_DOWN) {
-				if (dhd_bus_dpc(dhd->pub.bus)) {
-					up(&tsk->sema);
-				}
-				else {
-					DHD_OS_WAKE_UNLOCK(&dhd->pub);
+				dhd_os_wd_timer_extend(&dhd->pub, TRUE);
+				while (dhd_bus_dpc(dhd->pub.bus)) {
+					/* process all data */
 				}
+				dhd_os_wd_timer_extend(&dhd->pub, FALSE);
+				DHD_OS_WAKE_UNLOCK(&dhd->pub);
+
 			} else {
 				if (dhd->pub.up)
 					dhd_bus_stop(dhd->pub.bus, TRUE);
@@ -1812,28 +2174,96 @@ dhd_dpc_thread(void *data)
 
 	complete_and_exit(&tsk->completed, 0);
 }
-#endif /* DHDTHREAD */
 
-static void
-dhd_dpc(ulong data)
+#ifdef RXFRAME_THREAD
+static int
+dhd_rxf_thread(void *data)
 {
-	dhd_info_t *dhd;
-
-	dhd = (dhd_info_t *)data;
+	tsk_ctl_t *tsk = (tsk_ctl_t *)data;
+	dhd_info_t *dhd = (dhd_info_t *)tsk->parent;
+	dhd_pub_t *pub = &dhd->pub;
 
-	/* this (tasklet) can be scheduled in dhd_sched_dpc[dhd_linux.c]
-	 * down below , wake lock is set,
-	 * the tasklet is initialized in dhd_attach()
+	/* This thread doesn't need any user-level access,
+	 * so get rid of all our resources
 	 */
-	/* Call bus dpc unless it indicated down (then clean stop) */
-	if (dhd->pub.busstate != DHD_BUS_DOWN) {
-		if (dhd_bus_dpc(dhd->pub.bus))
-			tasklet_schedule(&dhd->tasklet);
-		else
-			DHD_OS_WAKE_UNLOCK(&dhd->pub);
-	} else {
-		dhd_bus_stop(dhd->pub.bus, TRUE);
-		DHD_OS_WAKE_UNLOCK(&dhd->pub);
+	if (dhd_rxf_prio > 0)
+	{
+		struct sched_param param;
+		param.sched_priority = (dhd_rxf_prio < MAX_RT_PRIO)?dhd_rxf_prio:(MAX_RT_PRIO-1);
+		setScheduler(current, SCHED_FIFO, &param);
+	}
+
+	DAEMONIZE("dhd_rxf");
+	/* DHD_OS_WAKE_LOCK is called in dhd_sched_dpc[dhd_linux.c] down below  */
+
+	/*  signal: thread has started */
+	complete(&tsk->completed);
+
+	/* Run until signal received */
+	while (1) {
+		if (down_interruptible(&tsk->sema) == 0) {
+			void *skb;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+			ulong flags;
+#endif
+
+			SMP_RD_BARRIER_DEPENDS();
+
+			if (tsk->terminated) {
+				break;
+			}
+			skb = dhd_rxf_dequeue(pub);
+
+			if (skb == NULL) {
+				continue;
+			}
+			while (skb) {
+				void *skbnext = PKTNEXT(pub->osh, skb);
+				PKTSETNEXT(pub->osh, skb, NULL);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+				netif_rx_ni(skb);
+#else
+				netif_rx(skb);
+				local_irq_save(flags);
+				RAISE_RX_SOFTIRQ();
+				local_irq_restore(flags);
+
+#endif
+				skb = skbnext;
+			}
+
+			DHD_OS_WAKE_UNLOCK(pub);
+		}
+		else
+			break;
+	}
+
+	complete_and_exit(&tsk->completed, 0);
+}
+#endif /* RXFRAME_THREAD */
+#endif /* DHDTHREAD */
+
+static void
+dhd_dpc(ulong data)
+{
+	dhd_info_t *dhd;
+
+	dhd = (dhd_info_t *)data;
+
+	/* this (tasklet) can be scheduled in dhd_sched_dpc[dhd_linux.c]
+	 * down below , wake lock is set,
+	 * the tasklet is initialized in dhd_attach()
+	 */
+	/* Call bus dpc unless it indicated down (then clean stop) */
+	if (dhd->pub.busstate != DHD_BUS_DOWN) {
+		if (dhd_bus_dpc(dhd->pub.bus))
+			tasklet_schedule(&dhd->tasklet);
+		else
+			DHD_OS_WAKE_UNLOCK(&dhd->pub);
+	} else {
+		dhd_bus_stop(dhd->pub.bus, TRUE);
+		DHD_OS_WAKE_UNLOCK(&dhd->pub);
 	}
 }
 
@@ -1854,6 +2284,27 @@ dhd_sched_dpc(dhd_pub_t *dhdp)
 		tasklet_schedule(&dhd->tasklet);
 }
 
+#if defined(DHDTHREAD) && defined(RXFRAME_THREAD)
+static void
+dhd_sched_rxf(dhd_pub_t *dhdp, void *skb)
+{
+	dhd_info_t *dhd = (dhd_info_t *)dhdp->info;
+
+	DHD_OS_WAKE_LOCK(dhdp);
+
+	DHD_TRACE(("dhd_sched_rxf: Enter\n"));
+
+	do {
+		if (dhd_rxf_enqueue(dhdp, skb) == BCME_OK)
+			break;
+	} while (1);
+	if (dhd->thr_rxf_ctl.thr_pid >= 0) {
+		up(&dhd->thr_rxf_ctl.sema);
+	}
+	return;
+}
+#endif /* defined(DHDTHREAD) && defined(RXFRAME_THREAD) */
+
 #ifdef TOE
 /* Retrieve current toe component enables, which are kept as a bitmap in toe_ol iovar */
 static int
@@ -1870,7 +2321,8 @@ dhd_toe_get(dhd_info_t *dhd, int ifidx, uint32 *toe_ol)
 	ioc.len = (uint)sizeof(buf);
 	ioc.set = FALSE;
 
-	strcpy(buf, "toe_ol");
+	strncpy(buf, "toe_ol", sizeof(buf) - 1);
+	buf[sizeof(buf) - 1] = '\0';
 	if ((ret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len)) < 0) {
 		/* Check for older dongle image that doesn't support toe_ol */
 		if (ret == -EIO) {
@@ -1904,7 +2356,8 @@ dhd_toe_set(dhd_info_t *dhd, int ifidx, uint32 toe_ol)
 
 	/* Set toe_ol as requested */
 
-	strcpy(buf, "toe_ol");
+	strncpy(buf, "toe_ol", sizeof(buf) - 1);
+	buf[sizeof(buf) - 1] = '\0';
 	memcpy(&buf[sizeof("toe_ol")], &toe_ol, sizeof(uint32));
 
 	if ((ret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len)) < 0) {
@@ -1935,8 +2388,8 @@ dhd_ethtool_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info)
 {
 	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(net);
 
-	sprintf(info->driver, "wl");
-	sprintf(info->version, "%lu", dhd->pub.drv_version);
+	snprintf(info->driver, sizeof(info->driver), "wl");
+	snprintf(info->version, sizeof(info->version), "%lu", dhd->pub.drv_version);
 }
 
 struct ethtool_ops dhd_ethtool_ops = {
@@ -1978,8 +2431,9 @@ dhd_ethtool(dhd_info_t *dhd, void *uaddr)
 
 		/* if dhd requested, identify ourselves */
 		if (strcmp(drvname, "?dhd") == 0) {
-			sprintf(info.driver, "dhd");
-			strcpy(info.version, EPI_VERSION_STR);
+			snprintf(info.driver, sizeof(info.driver), "dhd");
+			strncpy(info.version, EPI_VERSION_STR, sizeof(info.version) - 1);
+			info.version[sizeof(info.version) - 1] = '\0';
 		}
 
 		/* otherwise, require dongle to be up */
@@ -1990,11 +2444,11 @@ dhd_ethtool(dhd_info_t *dhd, void *uaddr)
 
 		/* finally, report dongle driver type */
 		else if (dhd->pub.iswl)
-			sprintf(info.driver, "wl");
+			snprintf(info.driver, sizeof(info.driver), "wl");
 		else
-			sprintf(info.driver, "xx");
+			snprintf(info.driver, sizeof(info.driver), "xx");
 
-		sprintf(info.version, "%lu", dhd->pub.drv_version);
+		snprintf(info.version, sizeof(info.version), "%lu", dhd->pub.drv_version);
 		if (copy_to_user(uaddr, &info, sizeof(info)))
 			return -EFAULT;
 		DHD_CTL(("%s: given %*s, returning %s\n", __FUNCTION__,
@@ -2058,10 +2512,19 @@ dhd_ethtool(dhd_info_t *dhd, void *uaddr)
 
 static bool dhd_check_hang(struct net_device *net, dhd_pub_t *dhdp, int error)
 {
+	dhd_info_t *dhd;
+
 	if (!dhdp)
 		return FALSE;
-	if ((error == -ETIMEDOUT) || ((dhdp->busstate == DHD_BUS_DOWN) &&
-		(!dhdp->dongle_reset))) {
+
+	dhd = (dhd_info_t *)dhdp->info;
+	if (dhd->thr_sysioc_ctl.thr_pid < 0) {
+		DHD_ERROR(("%s : skipped due to negative pid - unloading?\n", __FUNCTION__));
+		return FALSE;
+	}
+
+	if ((error == -ETIMEDOUT) || (error == -EREMOTEIO) ||
+		((dhdp->busstate == DHD_BUS_DOWN) && (!dhdp->dongle_reset))) {
 		DHD_ERROR(("%s: Event HANG send up due to  re=%d te=%d e=%d s=%d\n", __FUNCTION__,
 			dhdp->rxcnt_timeout, dhdp->txcnt_timeout, error, dhdp->busstate));
 		net_os_send_hang_message(net);
@@ -2070,128 +2533,60 @@ static bool dhd_check_hang(struct net_device *net, dhd_pub_t *dhdp, int error)
 	return FALSE;
 }
 
-static int
-dhd_ioctl_entry(struct net_device *net, struct ifreq *ifr, int cmd)
+int dhd_ioctl_process(dhd_pub_t *pub, int ifidx, dhd_ioctl_t *ioc)
 {
-	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(net);
-	dhd_ioctl_t ioc;
-	int bcmerror = 0;
+	int bcmerror = BCME_OK;
 	int buflen = 0;
 	void *buf = NULL;
-	uint driver = 0;
-	int ifidx;
-	int ret;
-
-	DHD_OS_WAKE_LOCK(&dhd->pub);
-
-	/* send to dongle only if we are not waiting for reload already */
-	if (dhd->pub.hang_was_sent) {
-		DHD_ERROR(("%s: HANG was sent up earlier\n", __FUNCTION__));
-		DHD_OS_WAKE_LOCK_TIMEOUT_ENABLE(&dhd->pub, DHD_EVENT_TIMEOUT_MS);
-		DHD_OS_WAKE_UNLOCK(&dhd->pub);
-		return OSL_ERROR(BCME_DONGLE_DOWN);
-	}
-
-	ifidx = dhd_net2idx(dhd, net);
-	DHD_TRACE(("%s: ifidx %d, cmd 0x%04x\n", __FUNCTION__, ifidx, cmd));
-
-	if (ifidx == DHD_BAD_IF) {
-		DHD_ERROR(("%s: BAD IF\n", __FUNCTION__));
-		DHD_OS_WAKE_UNLOCK(&dhd->pub);
-		return -1;
-	}
-
-#if defined(CONFIG_WIRELESS_EXT)
-	/* linux wireless extensions */
-	if ((cmd >= SIOCIWFIRST) && (cmd <= SIOCIWLAST)) {
-		/* may recurse, do NOT lock */
-		ret = wl_iw_ioctl(net, ifr, cmd);
-		DHD_OS_WAKE_UNLOCK(&dhd->pub);
-		return ret;
-	}
-#endif /* defined(CONFIG_WIRELESS_EXT) */
-
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 4, 2)
-	if (cmd == SIOCETHTOOL) {
-		ret = dhd_ethtool(dhd, (void*)ifr->ifr_data);
-		DHD_OS_WAKE_UNLOCK(&dhd->pub);
-		return ret;
-	}
-#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 4, 2) */
-
-	if (cmd == SIOCDEVPRIVATE+1) {
-		ret = wl_android_priv_cmd(net, ifr, cmd);
-		dhd_check_hang(net, &dhd->pub, ret);
-		DHD_OS_WAKE_UNLOCK(&dhd->pub);
-		return ret;
-	}
-
-	if (cmd != SIOCDEVPRIVATE) {
-		DHD_OS_WAKE_UNLOCK(&dhd->pub);
-		return -EOPNOTSUPP;
-	}
-
-	memset(&ioc, 0, sizeof(ioc));
+	struct net_device *net;
 
-	/* Copy the ioc control structure part of ioctl request */
-	if (copy_from_user(&ioc, ifr->ifr_data, sizeof(wl_ioctl_t))) {
-		bcmerror = -BCME_BADADDR;
+	net = dhd_idx2net(pub, ifidx);
+	if (!net) {
+		bcmerror = BCME_BADARG;
 		goto done;
 	}
 
 	/* Copy out any buffer passed */
-	if (ioc.buf) {
-		if (ioc.len == 0) {
-			DHD_TRACE(("%s: ioc.len=0, returns BCME_BADARG \n", __FUNCTION__));
-			bcmerror = -BCME_BADARG;
+	if (ioc->buf) {
+		if (ioc->len == 0) {
+			DHD_TRACE(("%s: ioc->len=0, returns BCME_BADARG \n", __FUNCTION__));
+			bcmerror = BCME_BADARG;
 			goto done;
 		}
-		buflen = MIN(ioc.len, DHD_IOCTL_MAXLEN);
+		buflen = MIN(ioc->len, DHD_IOCTL_MAXLEN);
 		/* optimization for direct ioctl calls from kernel */
 		/*
 		if (segment_eq(get_fs(), KERNEL_DS)) {
-			buf = ioc.buf;
+			buf = ioc->buf;
 		} else {
 		*/
 		{
-			if (!(buf = (char*)MALLOC(dhd->pub.osh, buflen))) {
-				bcmerror = -BCME_NOMEM;
+			if (!(buf = (char*)MALLOC(pub->osh, buflen))) {
+				bcmerror = BCME_NOMEM;
 				goto done;
 			}
-			if (copy_from_user(buf, ioc.buf, buflen)) {
-				bcmerror = -BCME_BADADDR;
+			if (copy_from_user(buf, ioc->buf, buflen)) {
+				bcmerror = BCME_BADADDR;
 				goto done;
 			}
 		}
 	}
 
-	/* To differentiate between wl and dhd read 4 more byes */
-	if ((copy_from_user(&driver, (char *)ifr->ifr_data + sizeof(wl_ioctl_t),
-		sizeof(uint)) != 0)) {
-		bcmerror = -BCME_BADADDR;
-		goto done;
-	}
-
-	if (!capable(CAP_NET_ADMIN)) {
-		bcmerror = -BCME_EPERM;
-		goto done;
-	}
-
 	/* check for local dhd ioctl and handle it */
-	if (driver == DHD_IOCTL_MAGIC) {
-		bcmerror = dhd_ioctl((void *)&dhd->pub, &ioc, buf, buflen);
+	if (ioc->driver == DHD_IOCTL_MAGIC) {
+		bcmerror = dhd_ioctl((void *)pub, ioc, buf, buflen);
 		if (bcmerror)
-			dhd->pub.bcmerror = bcmerror;
+			pub->bcmerror = bcmerror;
 		goto done;
 	}
 
 	/* send to dongle (must be up, and wl). */
-	if (dhd->pub.busstate != DHD_BUS_DATA) {
+	if (pub->busstate != DHD_BUS_DATA) {
 		bcmerror = BCME_DONGLE_DOWN;
 		goto done;
 	}
 
-	if (!dhd->pub.iswl) {
+	if (!pub->iswl) {
 		bcmerror = BCME_DONGLE_DOWN;
 		goto done;
 	}
@@ -2203,24 +2598,24 @@ dhd_ioctl_entry(struct net_device *net, struct ifreq *ifr, int cmd)
 	 * intercept WLC_DISASSOC IOCTL - serialize WPS-DONE and WLC_DISASSOC IOCTL to
 	 * prevent disassoc frame being sent before WPS-DONE frame.
 	 */
-	if (ioc.cmd == WLC_SET_KEY ||
-	    (ioc.cmd == WLC_SET_VAR && ioc.buf != NULL &&
-	     strncmp("wsec_key", ioc.buf, 9) == 0) ||
-	    (ioc.cmd == WLC_SET_VAR && ioc.buf != NULL &&
-	     strncmp("bsscfg:wsec_key", ioc.buf, 15) == 0) ||
-	    ioc.cmd == WLC_DISASSOC)
+	if (ioc->cmd == WLC_SET_KEY ||
+	    (ioc->cmd == WLC_SET_VAR && ioc->buf != NULL &&
+	     strncmp("wsec_key", ioc->buf, 9) == 0) ||
+	    (ioc->cmd == WLC_SET_VAR && ioc->buf != NULL &&
+	     strncmp("bsscfg:wsec_key", ioc->buf, 15) == 0) ||
+	    ioc->cmd == WLC_DISASSOC)
 		dhd_wait_pend8021x(net);
 
 #ifdef WLMEDIA_HTSF
-	if (ioc.buf) {
+	if (ioc->buf) {
 		/*  short cut wl ioctl calls here  */
-		if (strcmp("htsf", ioc.buf) == 0) {
+		if (strcmp("htsf", ioc->buf) == 0) {
 			dhd_ioctl_htsf_get(dhd, 0);
 			return BCME_OK;
 		}
 
-		if (strcmp("htsflate", ioc.buf) == 0) {
-			if (ioc.set) {
+		if (strcmp("htsflate", ioc->buf) == 0) {
+			if (ioc->set) {
 				memset(ts, 0, sizeof(tstamp_t)*TSMAX);
 				memset(&maxdelayts, 0, sizeof(tstamp_t));
 				maxdelay = 0;
@@ -2235,7 +2630,7 @@ dhd_ioctl_entry(struct net_device *net, struct ifreq *ifr, int cmd)
 			}
 			return BCME_OK;
 		}
-		if (strcmp("htsfclear", ioc.buf) == 0) {
+		if (strcmp("htsfclear", ioc->buf) == 0) {
 			memset(&vi_d1.bin, 0, sizeof(uint32)*NUMBIN);
 			memset(&vi_d2.bin, 0, sizeof(uint32)*NUMBIN);
 			memset(&vi_d3.bin, 0, sizeof(uint32)*NUMBIN);
@@ -2243,16 +2638,16 @@ dhd_ioctl_entry(struct net_device *net, struct ifreq *ifr, int cmd)
 			htsf_seqnum = 0;
 			return BCME_OK;
 		}
-		if (strcmp("htsfhis", ioc.buf) == 0) {
+		if (strcmp("htsfhis", ioc->buf) == 0) {
 			dhd_dump_htsfhisto(&vi_d1, "H to D");
 			dhd_dump_htsfhisto(&vi_d2, "D to D");
 			dhd_dump_htsfhisto(&vi_d3, "D to H");
 			dhd_dump_htsfhisto(&vi_d4, "H to H");
 			return BCME_OK;
 		}
-		if (strcmp("tsport", ioc.buf) == 0) {
-			if (ioc.set) {
-				memcpy(&tsport, ioc.buf + 7, 4);
+		if (strcmp("tsport", ioc->buf) == 0) {
+			if (ioc->set) {
+				memcpy(&tsport, ioc->buf + 7, 4);
 			} else {
 				DHD_ERROR(("current timestamp port: %d \n", tsport));
 			}
@@ -2261,28 +2656,120 @@ dhd_ioctl_entry(struct net_device *net, struct ifreq *ifr, int cmd)
 	}
 #endif /* WLMEDIA_HTSF */
 
-	if ((ioc.cmd == WLC_SET_VAR || ioc.cmd == WLC_GET_VAR) &&
-		ioc.buf != NULL && strncmp("rpc_", ioc.buf, 4) == 0) {
+	if ((ioc->cmd == WLC_SET_VAR || ioc->cmd == WLC_GET_VAR) &&
+		ioc->buf != NULL && strncmp("rpc_", ioc->buf, 4) == 0) {
 #ifdef BCM_FD_AGGR
-		bcmerror = dhd_fdaggr_ioctl(&dhd->pub, ifidx, (wl_ioctl_t *)&ioc, buf, buflen);
+		bcmerror = dhd_fdaggr_ioctl(pub, ifidx, (wl_ioctl_t *)ioc, buf, buflen);
 #else
 		bcmerror = BCME_UNSUPPORTED;
 #endif
 		goto done;
 	}
-	bcmerror = dhd_wl_ioctl(&dhd->pub, ifidx, (wl_ioctl_t *)&ioc, buf, buflen);
+	bcmerror = dhd_wl_ioctl(pub, ifidx, (wl_ioctl_t *)ioc, buf, buflen);
 
 done:
-	dhd_check_hang(net, &dhd->pub, bcmerror);
+	dhd_check_hang(net, pub, bcmerror);
 
-	if (!bcmerror && buf && ioc.buf) {
-		if (copy_to_user(ioc.buf, buf, buflen))
+	if (!bcmerror && buf && ioc->buf) {
+		if (copy_to_user(ioc->buf, buf, buflen))
 			bcmerror = -EFAULT;
 	}
 
 	if (buf)
-		MFREE(dhd->pub.osh, buf, buflen);
+		MFREE(pub->osh, buf, buflen);
+
+	return bcmerror;
+}
+
+static int
+dhd_ioctl_entry(struct net_device *net, struct ifreq *ifr, int cmd)
+{
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(net);
+	dhd_ioctl_t ioc;
+	int bcmerror = 0;
+	int ifidx;
+	int ret;
 
+	if (module_remove) {
+		printf("%s: module removed. cmd 0x%04x\n", __FUNCTION__, cmd);
+		return -1;
+	}
+	if ( !dhd->pub.up || (dhd->pub.busstate == DHD_BUS_DOWN)){
+		printf("%s: dhd is down. skip it.\n", __func__);
+		return -ENODEV;
+	}
+	DHD_OS_WAKE_LOCK(&dhd->pub);
+
+	/* send to dongle only if we are not waiting for reload already */
+	if (dhd->pub.hang_was_sent) {
+		DHD_ERROR(("%s: HANG was sent up earlier\n", __FUNCTION__));
+		DHD_OS_WAKE_LOCK_CTRL_TIMEOUT_ENABLE(&dhd->pub, DHD_EVENT_TIMEOUT_MS);
+		DHD_OS_WAKE_UNLOCK(&dhd->pub);
+		return OSL_ERROR(BCME_DONGLE_DOWN);
+	}
+
+	ifidx = dhd_net2idx(dhd, net);
+	DHD_TRACE(("%s: ifidx %d, cmd 0x%04x\n", __FUNCTION__, ifidx, cmd));
+
+	if (ifidx == DHD_BAD_IF) {
+		DHD_ERROR(("%s: BAD IF\n", __FUNCTION__));
+		DHD_OS_WAKE_UNLOCK(&dhd->pub);
+		return -1;
+	}
+
+#if defined(WL_WIRELESS_EXT)
+	/* linux wireless extensions */
+	if ((cmd >= SIOCIWFIRST) && (cmd <= SIOCIWLAST)) {
+		/* may recurse, do NOT lock */
+		ret = wl_iw_ioctl(net, ifr, cmd);
+		DHD_OS_WAKE_UNLOCK(&dhd->pub);
+		return ret;
+	}
+#endif /* defined(WL_WIRELESS_EXT) */
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 4, 2)
+	if (cmd == SIOCETHTOOL) {
+		ret = dhd_ethtool(dhd, (void*)ifr->ifr_data);
+		DHD_OS_WAKE_UNLOCK(&dhd->pub);
+		return ret;
+	}
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 4, 2) */
+
+	if (cmd == SIOCDEVPRIVATE+1) {
+		ret = wl_android_priv_cmd(net, ifr, cmd);
+		dhd_check_hang(net, &dhd->pub, ret);
+		DHD_OS_WAKE_UNLOCK(&dhd->pub);
+		return ret;
+	}
+
+	if (cmd != SIOCDEVPRIVATE) {
+		DHD_OS_WAKE_UNLOCK(&dhd->pub);
+		return -EOPNOTSUPP;
+	}
+
+	memset(&ioc, 0, sizeof(ioc));
+
+	/* Copy the ioc control structure part of ioctl request */
+	if (copy_from_user(&ioc, ifr->ifr_data, sizeof(wl_ioctl_t))) {
+		bcmerror = BCME_BADADDR;
+		goto done;
+	}
+
+	/* To differentiate between wl and dhd read 4 more byes */
+	if ((copy_from_user(&ioc.driver, (char *)ifr->ifr_data + sizeof(wl_ioctl_t),
+		sizeof(uint)) != 0)) {
+		bcmerror = BCME_BADADDR;
+		goto done;
+	}
+
+	if (!capable(CAP_NET_ADMIN)) {
+		bcmerror = BCME_EPERM;
+		goto done;
+	}
+
+	bcmerror = dhd_ioctl_process(&dhd->pub, ifidx, &ioc);
+
+done:
 	DHD_OS_WAKE_UNLOCK(&dhd->pub);
 
 	return OSL_ERROR(bcmerror);
@@ -2308,17 +2795,17 @@ dhd_cleanup_virt_ifaces(dhd_info_t *dhd)
 #endif
 
 	for (i = 1; i < DHD_MAX_IFS; i++) {
+		dhd_net_if_lock_local(dhd);
 		if (dhd->iflist[i]) {
 			DHD_TRACE(("Deleting IF: %d \n", i));
 			if ((dhd->iflist[i]->state != DHD_IF_DEL) &&
 				(dhd->iflist[i]->state != DHD_IF_DELETING)) {
 				dhd->iflist[i]->state = DHD_IF_DEL;
 				dhd->iflist[i]->idx = i;
-				dhd_net_if_lock_local(dhd);
 				dhd_op_if(dhd->iflist[i]);
-				dhd_net_if_unlock_local(dhd);
 			}
 		}
+		dhd_net_if_unlock_local(dhd);
 	}
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
@@ -2330,10 +2817,11 @@ dhd_cleanup_virt_ifaces(dhd_info_t *dhd)
 }
 #endif /* WL_CFG80211 */
 
+
 static int
 dhd_stop(struct net_device *net)
 {
-	int ifidx;
+	int ifidx = 0;
 	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(net);
 	DHD_OS_WAKE_LOCK(&dhd->pub);
 	DHD_TRACE(("%s: Enter %p\n", __FUNCTION__, net));
@@ -2343,6 +2831,12 @@ dhd_stop(struct net_device *net)
 	ifidx = dhd_net2idx(dhd, net);
 	BCM_REFERENCE(ifidx);
 
+	module_remove = 1;
+
+	/* Set state and stop OS transmissions */
+	netif_stop_queue(net);
+	dhd->pub.up = 0;
+
 #ifdef WL_CFG80211
 	if (ifidx == 0) {
 		wl_cfg80211_down(NULL);
@@ -2359,24 +2853,20 @@ dhd_stop(struct net_device *net)
 #endif
 
 #ifdef PROP_TXSTATUS
-	dhd_wlfc_cleanup(&dhd->pub);
+	dhd_wlfc_cleanup(&dhd->pub, NULL, 0);
 #endif
-	/* Set state and stop OS transmissions */
-	dhd->pub.up = 0;
-	netif_stop_queue(net);
-
 	/* Stop the protocol module */
 	dhd_prot_stop(&dhd->pub);
 
+	OLD_MOD_DEC_USE_COUNT;
+exit:
 #if defined(WL_CFG80211)
 	if (ifidx == 0 && !dhd_download_fw_on_driverload)
 		wl_android_wifi_off(net);
 #endif 
-	dhd->pub.hang_was_sent = 0;
 	dhd->pub.rxcnt_timeout = 0;
 	dhd->pub.txcnt_timeout = 0;
-	OLD_MOD_DEC_USE_COUNT;
-exit:
+
 	DHD_OS_WAKE_UNLOCK(&dhd->pub);
 	return 0;
 }
@@ -2385,28 +2875,60 @@ static int
 dhd_open(struct net_device *net)
 {
 	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(net);
-	uint up = 0;
 #ifdef TOE
 	uint32 toe_ol;
 #endif
 	int ifidx;
 	int32 ret = 0;
+
+#if 0
+	/* WAR : to prevent calling dhd_open abnormally in quick succession after hang event */
+	if (dhd->pub.hang_was_sent == 1) {
+		DHD_ERROR(("%s: HANG was sent up earlier\n", __FUNCTION__));
+#else
+	module_remove = 0;
+	if (module_remove) {
+		printf("%s: module removed. Just return.\n", __FUNCTION__);
+#endif
+		return -1;
+	}
+
+#if defined(MULTIPLE_SUPPLICANT)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1 && 1
+	if (mutex_is_locked(&_dhd_sdio_mutex_lock_) != 0) {
+		DHD_ERROR(("%s : dhd_open: call dev open before insmod complete!\n", __FUNCTION__));
+	}
+	mutex_lock(&_dhd_sdio_mutex_lock_);
+#endif
+#endif /* MULTIPLE_SUPPLICANT */
+
 	DHD_OS_WAKE_LOCK(&dhd->pub);
 	/* Update FW path if it was changed */
-	if ((firmware_path != NULL) && (firmware_path[0] != '\0')) {
+	if (strlen(firmware_path) != 0) {
 		if (firmware_path[strlen(firmware_path)-1] == '\n')
 			firmware_path[strlen(firmware_path)-1] = '\0';
-		strcpy(fw_path, firmware_path);
+		bzero(fw_path, MOD_PARAM_PATHLEN);
+		strncpy(fw_path, firmware_path, sizeof(fw_path)-1);
 		firmware_path[0] = '\0';
 	}
 
+
+
+	dhd->pub.dongle_trap_occured = 0;
+	dhd->pub.hang_was_sent = 0;
 #if !defined(WL_CFG80211)
 	/*
 	 * Force start if ifconfig_up gets called before START command
 	 *  We keep WEXT's wl_control_wl_start to provide backward compatibility
 	 *  This should be removed in the future
 	 */
-	wl_control_wl_start(net);
+	ret = wl_control_wl_start(net);
+	if (ret != 0) {
+		DHD_ERROR(("%s: failed with code %d\n", __FUNCTION__, ret));
+		ret = -1;
+		goto exit;
+	}
+
 #endif 
 
 	ifidx = dhd_net2idx(dhd, net);
@@ -2431,7 +2953,9 @@ dhd_open(struct net_device *net)
 		if (!dhd_download_fw_on_driverload) {
 			ret = wl_android_wifi_on(net);
 			if (ret != 0) {
-				DHD_ERROR(("wl_android_wifi_on failed (%d)\n", ret));
+				DHD_ERROR(("%s : wl_android_wifi_on failed (%d)\n",
+					__FUNCTION__, ret));
+				ret = -1;
 				goto exit;
 			}
 		}
@@ -2472,17 +2996,23 @@ dhd_open(struct net_device *net)
 	netif_start_queue(net);
 	dhd->pub.up = 1;
 
-	/* Fire a WLC_UP for primary interface to enable RF */
-	if (ifidx == 0)
-		dhd_wl_ioctl_cmd(&dhd->pub, WLC_UP, (char *)&up, sizeof(up), TRUE, 0);
-
 #ifdef BCMDBGFS
 	dhd_dbg_init(&dhd->pub);
 #endif
 
 	OLD_MOD_INC_USE_COUNT;
 exit:
+	if (ret)
+		dhd_stop(net);
+
 	DHD_OS_WAKE_UNLOCK(&dhd->pub);
+
+#if defined(MULTIPLE_SUPPLICANT)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1 && 1
+	mutex_unlock(&_dhd_sdio_mutex_lock_);
+#endif
+#endif /* MULTIPLE_SUPPLICANT */
+
 	return ret;
 }
 
@@ -2495,6 +3025,16 @@ int dhd_do_driver_init(struct net_device *net)
 		return -EINVAL;
 	}
 
+#ifdef MULTIPLE_SUPPLICANT
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1 && 1
+	if (mutex_is_locked(&_dhd_sdio_mutex_lock_) != 0) {
+		DHD_ERROR(("%s : dhdsdio_probe is already running!\n", __FUNCTION__));
+		return 0;
+	}
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) */
+#endif /* MULTIPLE_SUPPLICANT */
+
+	/*  && defined(OEM_ANDROID) && defined(BCMSDIO) */
 	dhd = *(dhd_info_t **)netdev_priv(net);
 
 	/* If driver is already initialized, do nothing
@@ -2526,6 +3066,7 @@ dhd_osl_detach(osl_t *osh)
 	}
 	osl_detach(osh);
 #if 1 && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
+	dhd_registration_check = FALSE;
 	up(&dhd_registration_sem);
 #if	defined(BCMLXSDMMC)
 	up(&dhd_chipup_sem);
@@ -2552,7 +3093,7 @@ dhd_add_if(dhd_info_t *dhd, int ifidx, void *handle, char *name,
 		}
 	} else
 		if ((ifp = MALLOC(dhd->pub.osh, sizeof(dhd_if_t))) == NULL) {
-			DHD_ERROR(("%s: OOM - dhd_if_t\n", __FUNCTION__));
+			DHD_ERROR(("%s: OOM - dhd_if_t(%d)\n", __FUNCTION__, sizeof(dhd_if_t)));
 			return -ENOMEM;
 		}
 
@@ -2569,7 +3110,7 @@ dhd_add_if(dhd_info_t *dhd, int ifidx, void *handle, char *name,
 		ifp->state = DHD_IF_ADD;
 		ifp->idx = ifidx;
 		ifp->bssidx = bssidx;
-		ASSERT(&dhd->thr_sysioc_ctl.thr_pid >= 0);
+		ASSERT(dhd->thr_sysioc_ctl.thr_pid >= 0);
 		up(&dhd->thr_sysioc_ctl.sema);
 	} else
 		ifp->net = (struct net_device *)handle;
@@ -2597,7 +3138,7 @@ dhd_del_if(dhd_info_t *dhd, int ifidx)
 
 	ifp->state = DHD_IF_DEL;
 	ifp->idx = ifidx;
-	ASSERT(&dhd->thr_sysioc_ctl.thr_pid >= 0);
+	ASSERT(dhd->thr_sysioc_ctl.thr_pid >= 0);
 	up(&dhd->thr_sysioc_ctl.sema);
 }
 
@@ -2639,10 +3180,14 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
 	/* updates firmware nvram path if it was provided as module parameters */
-	if ((firmware_path != NULL) && (firmware_path[0] != '\0'))
-		strcpy(fw_path, firmware_path);
-	if ((nvram_path != NULL) && (nvram_path[0] != '\0'))
-		strcpy(nv_path, nvram_path);
+	if (strlen(firmware_path) != 0) {
+		bzero(fw_path, MOD_PARAM_PATHLEN);
+		strncpy(fw_path, firmware_path, sizeof(fw_path) - 1);
+	}
+	if (strlen(nvram_path) != 0) {
+		bzero(nv_path, MOD_PARAM_PATHLEN);
+		strncpy(nv_path, nvram_path, sizeof(nv_path) -1);
+	}
 
 	/* Allocate etherdev, including space for private structure */
 	if (!(net = alloc_etherdev(sizeof(dhd)))) {
@@ -2704,7 +3249,15 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 
 #ifdef PROP_TXSTATUS
 	spin_lock_init(&dhd->wlfc_spinlock);
+#ifdef PROP_TXSTATUS_VSDB
+	dhd->pub.wlfc_enabled = FALSE;
+#else
 	dhd->pub.wlfc_enabled = TRUE;
+#endif /* PROP_TXSTATUS_VSDB */
+	dhd->pub.ptx_opt_enabled = FALSE;
+	dhd->pub.skip_fc = dhd_wlfc_skip_fc;
+	dhd->pub.plat_enable = dhd_wlfc_plat_enable;
+	dhd->pub.plat_deinit = dhd_wlfc_plat_deinit;
 #endif /* PROP_TXSTATUS */
 
 	/* Initialize other structure content */
@@ -2715,17 +3268,25 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 	spin_lock_init(&dhd->sdlock);
 	spin_lock_init(&dhd->txqlock);
 	spin_lock_init(&dhd->dhd_lock);
+#if defined(DHDTHREAD) && defined(RXFRAME_THREAD)
+	spin_lock_init(&dhd->rxf_lock);
+#endif /* defined(DHDTHREAD) && defined(RXFRAME_THREAD) */
 
 	/* Initialize Wakelock stuff */
 	spin_lock_init(&dhd->wakelock_spinlock);
 	dhd->wakelock_counter = 0;
-	dhd->wakelock_timeout_enable = 0;
+	dhd->wakelock_wd_counter = 0;
+	dhd->wakelock_rx_timeout_enable = 0;
+	dhd->wakelock_ctrl_timeout_enable = 0;
 #ifdef CONFIG_HAS_WAKELOCK
 	wake_lock_init(&dhd->wl_wifi, WAKE_LOCK_SUSPEND, "wlan_wake");
 	wake_lock_init(&dhd->wl_rxwake, WAKE_LOCK_SUSPEND, "wlan_rx_wake");
-#endif
+	wake_lock_init(&dhd->wl_ctrlwake, WAKE_LOCK_SUSPEND, "wlan_ctrl_wake");
+	wake_lock_init(&dhd->wl_wdwake, WAKE_LOCK_SUSPEND, "wlan_wd_wake");
+#endif /* CONFIG_HAS_WAKELOCK */
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
 	mutex_init(&dhd->dhd_net_if_mutex);
+	mutex_init(&dhd->dhd_suspend_mutex);
 #endif
 	dhd_state |= DHD_ATTACH_STATE_WAKELOCKS_INIT;
 
@@ -2746,7 +3307,7 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 	dhd_monitor_init(&dhd->pub);
 	dhd_state |= DHD_ATTACH_STATE_CFG80211;
 #endif
-#if defined(CONFIG_WIRELESS_EXT)
+#if defined(WL_WIRELESS_EXT)
 	/* Attach and link in the iw */
 	if (!(dhd_state &  DHD_ATTACH_STATE_CFG80211)) {
 		if (wl_iw_attach(net, (void *)&dhd->pub) != 0) {
@@ -2755,13 +3316,14 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 	}
 	dhd_state |= DHD_ATTACH_STATE_WL_ATTACH;
 	}
-#endif /* defined(CONFIG_WIRELESS_EXT) */
+#endif /* defined(WL_WIRELESS_EXT) */
 
 
 	/* Set up the watchdog timer */
 	init_timer(&dhd->timer);
 	dhd->timer.data = (ulong)dhd;
 	dhd->timer.function = dhd_watchdog;
+	dhd->default_wd_interval = dhd_watchdog_ms;
 
 #ifdef DHDTHREAD
 	/* Initialize thread based operation and lock */
@@ -2773,9 +3335,10 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 		dhd->threads_only = FALSE;
 	}
 
-	if (dhd_dpc_prio >= 0) {
+	if (dhd_watchdog_prio >= 0) {
 		/* Initialize watchdog thread */
-		PROC_START(dhd_watchdog_thread, dhd, &dhd->thr_wdt_ctl, 0);
+		PROC_START(dhd_watchdog_thread, dhd, &dhd->thr_wdt_ctl, 0, "dhd_watchdog_thread");
+
 	} else {
 		dhd->thr_wdt_ctl.thr_pid = -1;
 	}
@@ -2783,12 +3346,17 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 	/* Set up the bottom half handler */
 	if (dhd_dpc_prio >= 0) {
 		/* Initialize DPC thread */
-		PROC_START(dhd_dpc_thread, dhd, &dhd->thr_dpc_ctl, 0);
+		PROC_START(dhd_dpc_thread, dhd, &dhd->thr_dpc_ctl, 0, "dhd_dpc");
 	} else {
 		/*  use tasklet for dpc */
 		tasklet_init(&dhd->tasklet, dhd_dpc, (ulong)dhd);
 		dhd->thr_dpc_ctl.thr_pid = -1;
 	}
+#ifdef RXFRAME_THREAD
+	bzero(&dhd->pub.skbbuf[0], sizeof(void *) * MAXSKBPEND);
+	/* Initialize RXF thread */
+	PROC_START(dhd_rxf_thread, dhd, &dhd->thr_rxf_ctl, 0, "dhd_rxf");
+#endif
 #else
 	/* Set up the bottom half handler */
 	tasklet_init(&dhd->tasklet, dhd_dpc, (ulong)dhd);
@@ -2796,12 +3364,16 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 #endif /* DHDTHREAD */
 
 	if (dhd_sysioc) {
-		PROC_START(_dhd_sysioc_thread, dhd, &dhd->thr_sysioc_ctl, 0);
+		PROC_START(_dhd_sysioc_thread, dhd, &dhd->thr_sysioc_ctl, 0, "dhd_sysioc");
 	} else {
 		dhd->thr_sysioc_ctl.thr_pid = -1;
 	}
 	dhd_state |= DHD_ATTACH_STATE_THREADS_CREATED;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && (1)
+	INIT_WORK(&dhd->work_hang, dhd_hang_process);
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))  */
+
 	/*
 	 * Save the dhd_info into the priv
 	 */
@@ -2811,19 +3383,20 @@ dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
 	register_pm_notifier(&dhd_sleep_pm_notifier);
 #endif /*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_PM_SLEEP) */
 
-#ifdef CONFIG_HAS_EARLYSUSPEND
+#if defined(CONFIG_HAS_EARLYSUSPEND) && defined(DHD_USE_EARLYSUSPEND)
 	dhd->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 20;
 	dhd->early_suspend.suspend = dhd_early_suspend;
 	dhd->early_suspend.resume = dhd_late_resume;
 	register_early_suspend(&dhd->early_suspend);
 	dhd_state |= DHD_ATTACH_STATE_EARLYSUSPEND_DONE;
-#endif
+#endif /* CONFIG_HAS_EARLYSUSPEND && DHD_USE_EARLYSUSPEND */
 
 #ifdef ARP_OFFLOAD_SUPPORT
 	dhd->pend_ipaddr = 0;
 	register_inetaddr_notifier(&dhd_notifier);
 #endif /* ARP_OFFLOAD_SUPPORT */
 
+
 	dhd_state |= DHD_ATTACH_STATE_DONE;
 	dhd->dhd_state = dhd_state;
 	return &dhd->pub;
@@ -2861,13 +3434,24 @@ dhd_bus_start(dhd_pub_t *dhdp)
 
 	/* try to download image and nvram to the dongle */
 	if  ((dhd->pub.busstate == DHD_BUS_DOWN) &&
-		(fw_path != NULL) && (fw_path[0] != '\0') &&
-		(nv_path != NULL) && (nv_path[0] != '\0')) {
+		(fw_path[0] != '\0') && (nv_path[0] != '\0')) {
+#ifdef SHOW_NVRAM_TYPE
+		{	/* Show nvram type in the kernel log */
+			int i;
+			for (i = 0; nv_path[i] != '\0'; ++i) {
+				if (nv_path[i] == '.') {
+					++i;
+					break;
+				}
+			}
+			DHD_ERROR(("%s: nvram_type = [%s]\n", __FUNCTION__, &nv_path[i]));
+		}
+#endif /* SHOW_NVRAM_TYPE */
 		/* wake lock moved to dhdsdio_download_firmware */
 		if (!(dhd_bus_download_firmware(dhd->pub.bus, dhd->pub.osh,
-		                                fw_path, nv_path))) {
+			fw_path, nv_path))) {
 			DHD_ERROR(("%s: dhdsdio_probe_download failed. firmware = %s nvram = %s\n",
-			           __FUNCTION__, fw_path, nv_path));
+				__FUNCTION__, fw_path, nv_path));
 #ifdef DHDTHREAD
 			if (dhd->threads_only)
 				dhd_os_sdunlock(dhdp);
@@ -2912,12 +3496,13 @@ dhd_bus_start(dhd_pub_t *dhdp)
 		if (dhd->threads_only)
 			dhd_os_sdunlock(dhdp);
 #endif /* DHDTHREAD */
+		DHD_OS_WD_WAKE_UNLOCK(&dhd->pub);
 		return -ENODEV;
 	}
 
 	/* Enable oob at firmware */
 	dhd_enable_oob_intr(dhd->pub.bus, TRUE);
-#endif /* defined(OOB_INTR_ONLY) */
+#endif 
 
 	/* If bus is not ready, can't come up */
 	if (dhd->pub.busstate != DHD_BUS_DATA) {
@@ -2930,6 +3515,7 @@ dhd_bus_start(dhd_pub_t *dhdp)
 		if (dhd->threads_only)
 			dhd_os_sdunlock(dhdp);
 #endif /* DHDTHREAD */
+		DHD_OS_WD_WAKE_UNLOCK(&dhd->pub);
 		return -ENODEV;
 	}
 
@@ -2938,6 +3524,14 @@ dhd_bus_start(dhd_pub_t *dhdp)
 		dhd_os_sdunlock(dhdp);
 #endif /* DHDTHREAD */
 
+#if 0
+#ifdef BCMSDIOH_TXGLOM
+	if ((dhd->pub.busstate == DHD_BUS_DATA) && bcmsdh_glom_enabled()) {
+		dhd_txglom_enable(dhdp, TRUE);
+	}
+#endif
+#endif
+
 #ifdef READ_MACADDR
 	dhd_read_macaddr(dhd);
 #endif
@@ -2953,7 +3547,7 @@ dhd_bus_start(dhd_pub_t *dhdp)
 #ifdef ARP_OFFLOAD_SUPPORT
 	if (dhd->pend_ipaddr) {
 #ifdef AOE_IP_ALIAS_SUPPORT
-		aoe_update_host_ipv4_table(&dhd->pub, dhd->pend_ipaddr, TRUE);
+		aoe_update_host_ipv4_table(&dhd->pub, dhd->pend_ipaddr, TRUE, 0);
 #endif /* AOE_IP_ALIAS_SUPPORT */
 		dhd->pend_ipaddr = 0;
 	}
@@ -2962,31 +3556,77 @@ dhd_bus_start(dhd_pub_t *dhdp)
 	return 0;
 }
 
+bool dhd_is_concurrent_mode(dhd_pub_t *dhd)
+{
+	if (!dhd)
+		return FALSE;
+
+	if (dhd->op_mode & DHD_FLAG_CONCURR_MULTI_CHAN_MODE)
+		return TRUE;
+	else if ((dhd->op_mode & DHD_FLAG_CONCURR_SINGLE_CHAN_MODE) ==
+		DHD_FLAG_CONCURR_SINGLE_CHAN_MODE)
+		return TRUE;
+	else
+		return FALSE;
+}
 #if !defined(AP) && defined(WLP2P)
-/* For Android ICS MR2 release, the concurrent mode is enabled by default and the firmware
+/* From Android JerryBean release, the concurrent mode is enabled by default and the firmware
  * name would be fw_bcmdhd.bin. So we need to determine whether P2P is enabled in the STA
  * firmware and accordingly enable concurrent mode (Apply P2P settings). SoftAP firmware
  * would still be named as fw_bcmdhd_apsta.
  */
-static u32
-dhd_concurrent_fw(dhd_pub_t *dhd)
+uint32
+dhd_get_concurrent_capabilites(dhd_pub_t *dhd)
 {
-	int ret = 0;
+	int32 ret = 0;
 	char buf[WLC_IOCTL_SMLEN];
-
-	if ((!op_mode) && (strstr(fw_path, "_p2p") == NULL) &&
-		(strstr(fw_path, "_apsta") == NULL)) {
-		/* Given path is for the STA firmware. Check whether P2P support is present in
-		 * the firmware. If so, set mode as P2P (concurrent support).
-		 */
+	bool mchan_supported = FALSE;
+	/* if dhd->op_mode is already set for HOSTAP,
+	  * that means we only will use the mode as it is
+	  */
+	if (dhd->op_mode & DHD_FLAG_HOSTAP_MODE)
+		return 0;
+	memset(buf, 0, sizeof(buf));
+	bcm_mkiovar("cap", 0, 0, buf, sizeof(buf));
+	if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, buf, sizeof(buf),
+		FALSE, 0)) < 0) {
+		DHD_ERROR(("%s: Get Capability failed (error=%d)\n",
+			__FUNCTION__, ret));
+		return 0;
+	}
+	if (strstr(buf, "vsdb")) {
+		mchan_supported = TRUE;
+	}
+	if (strstr(buf, "p2p") == NULL) {
+		DHD_TRACE(("Chip does not support p2p\n"));
+		return 0;
+	}
+	else {
+		/* Chip supports p2p but ensure that p2p is really implemented in firmware or not */
 		memset(buf, 0, sizeof(buf));
 		bcm_mkiovar("p2p", 0, 0, buf, sizeof(buf));
 		if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, buf, sizeof(buf),
 			FALSE, 0)) < 0) {
-			DHD_TRACE(("%s: Get P2P failed (error=%d)\n", __FUNCTION__, ret));
-		} else if (buf[0] == 1) {
-			DHD_TRACE(("%s: P2P is supported\n", __FUNCTION__));
-			return 1;
+			DHD_ERROR(("%s: Get P2P failed (error=%d)\n", __FUNCTION__, ret));
+			return 0;
+		}
+		else {
+			if (buf[0] == 1) {
+				/* By default, chip supports single chan concurrency,
+				* now lets check for mchan
+				*/
+				ret = DHD_FLAG_CONCURR_SINGLE_CHAN_MODE;
+				if (mchan_supported)
+					ret |= DHD_FLAG_CONCURR_MULTI_CHAN_MODE;
+#if defined(WL_ENABLE_P2P_IF)
+				/* For customer_hw4, although ICS,
+				* we still support concurrent mode
+				*/
+				return ret;
+#else
+				return 0;
+#endif
+			}
 		}
 	}
 	return 0;
@@ -2998,27 +3638,51 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 	int ret = 0;
 	char eventmask[WL_EVENTING_MASK_LEN];
 	char iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" + '\0' + bitvec  */
-
-	uint power_mode = PM_OFF; /* PM_FAST; */
+	uint32 buf_key_b4_m4 = 1;
+#if defined(BCMSUP_4WAY_HANDSHAKE) && defined(WLAN_AKM_SUITE_FT_8021X)
+	uint32 sup_wpa = 0;
+#endif
+#ifdef CUSTOM_AMPDU_BA_WSIZE
+	uint32 ampdu_ba_wsize = CUSTOM_AMPDU_BA_WSIZE;
+#endif /* CUSTOM_AMPDU_BA_WSIZE */
+	uint power_mode = PM_FAST;
 	uint32 dongle_align = DHD_SDALIGN;
-	uint32 glom = 0;
-	uint bcn_timeout = 4;
-	uint retry_max = 3;
+	uint32 glom = CUSTOM_GLOM_SETTING;
+	uint bcn_timeout = 10;
+	uint retry_max = 10;
 #if defined(ARP_OFFLOAD_SUPPORT)
 	int arpoe = 1;
 #endif
-	int scan_assoc_time = DHD_SCAN_ACTIVE_TIME;
-	int scan_unassoc_time = 40;
+	int scan_assoc_time = DHD_SCAN_ASSOC_ACTIVE_TIME;
+	int scan_unassoc_time = DHD_SCAN_UNASSOC_ACTIVE_TIME;
 	int scan_passive_time = DHD_SCAN_PASSIVE_TIME;
 	char buf[WLC_IOCTL_SMLEN];
 	char *ptr;
 	uint32 listen_interval = LISTEN_INTERVAL; /* Default Listen Interval in Beacons */
-	uint16 chipID;
+#ifdef ROAM_ENABLE
+	uint roamvar = 0;
+	int roam_trigger[2] = {CUSTOM_ROAM_TRIGGER_SETTING, WLC_BAND_ALL};
+	int roam_scan_period[2] = {10, WLC_BAND_ALL};
+	int roam_delta[2] = {CUSTOM_ROAM_DELTA_SETTING, WLC_BAND_ALL};
+#ifdef FULL_ROAMING_SCAN_PERIOD_60_SEC
+	int roam_fullscan_period = 60;
+#else /* FULL_ROAMING_SCAN_PERIOD_60_SEC */
+	int roam_fullscan_period = 120;
+#endif /* FULL_ROAMING_SCAN_PERIOD_60_SEC */
+#else
+#ifdef DISABLE_BUILTIN_ROAM
+	uint roamvar = 1;
+#endif /* DISABLE_BUILTIN_ROAM */
+#endif /* ROAM_ENABLE */
+
+	int srl = 15;
+	int lrl = 15;
 #if defined(SOFTAP)
 	uint dtim = 1;
 #endif
 #if (defined(AP) && !defined(WLP2P)) || (!defined(AP) && defined(WL_CFG80211))
 	uint32 mpc = 0; /* Turn MPC off for AP/APSTA mode */
+	struct ether_addr p2p_ea;
 #endif
 
 #if defined(AP) || defined(WLP2P)
@@ -3027,7 +3691,29 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 #ifdef GET_CUSTOM_MAC_ENABLE
 	struct ether_addr ea_addr;
 #endif /* GET_CUSTOM_MAC_ENABLE */
-
+#ifdef WLTDLS
+	uint32 tdls = 1;
+	uint32 tdls_auto_op = 1;
+	uint32 tdls_idle_time = CUSTOM_TDLS_IDLE_MODE_SETTING;
+#endif /* WLTDLS */
+
+#ifdef DISABLE_11N
+	uint32 nmode = 0;
+#endif /* DISABLE_11N */
+#ifdef USE_WL_FRAMEBURST
+	uint32 frameburst = 1;
+#endif /* USE_WL_FRAMEBURST */
+#ifdef PROP_TXSTATUS
+#ifdef PROP_TXSTATUS_VSDB
+	/* In case the host does not support proptxstatus, hostreorder in dongle should be off */
+	uint32 hostreorder = 0;
+	dhd->wlfc_enabled = FALSE;
+	/* enable WLFC only if the firmware is VSDB */
+#else
+	dhd->wlfc_enabled = TRUE;
+#endif /* PROP_TXSTATUS_VSDB */
+#endif /* PROP_TXSTATUS */
+	dhd->suspend_bcn_li_dtim = CUSTOM_SUSPEND_BCN_LI_DTIM;
 	DHD_TRACE(("Enter %s\n", __FUNCTION__));
 	dhd->op_mode = 0;
 #ifdef GET_CUSTOM_MAC_ENABLE
@@ -3040,6 +3726,7 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 			DHD_ERROR(("%s: can't set MAC address , error=%d\n", __FUNCTION__, ret));
 			return BCME_NOTUP;
 		}
+		memcpy(dhd->mac.octet, ea_addr.octet, ETHER_ADDR_LEN);
 	} else {
 #endif /* GET_CUSTOM_MAC_ENABLE */
 		/* Get the default device MAC address directly from firmware */
@@ -3057,13 +3744,24 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 	}
 #endif /* GET_CUSTOM_MAC_ENABLE */
 
+	DHD_TRACE(("Firmware = %s\n", fw_path));
+
+	if ((!op_mode && strstr(fw_path, "_apsta") != NULL) ||
+		(op_mode == DHD_FLAG_HOSTAP_MODE)) {
 #ifdef SET_RANDOM_MAC_SOFTAP
-	if ((!op_mode && strstr(fw_path, "_apsta") != NULL) || (op_mode == 0x02)) {
 		uint rand_mac;
-
+#endif
+		dhd->op_mode = DHD_FLAG_HOSTAP_MODE;
+#if defined(ARP_OFFLOAD_SUPPORT)
+			arpoe = 0;
+#endif
+#ifdef PKT_FILTER_SUPPORT
+			dhd_pkt_filter_enable = FALSE;
+#endif
+#ifdef SET_RANDOM_MAC_SOFTAP
 		srandom32((uint)jiffies);
 		rand_mac = random32();
-		iovbuf[0] = 0x02;              /* locally administered bit */
+		iovbuf[0] = 0x02;			   /* locally administered bit */
 		iovbuf[1] = 0x1A;
 		iovbuf[2] = 0x11;
 		iovbuf[3] = (unsigned char)(rand_mac & 0x0F) | 0xF0;
@@ -3076,64 +3774,67 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 			DHD_ERROR(("%s: can't set MAC address , error=%d\n", __FUNCTION__, ret));
 		} else
 			memcpy(dhd->mac.octet, iovbuf, ETHER_ADDR_LEN);
-	}
 #endif /* SET_RANDOM_MAC_SOFTAP */
+#if !defined(AP) && defined(WL_CFG80211)
+		/* Turn off MPC in AP mode */
+		bcm_mkiovar("mpc", (char *)&mpc, 4, iovbuf, sizeof(iovbuf));
+		if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf,
+			sizeof(iovbuf), TRUE, 0)) < 0) {
+			DHD_ERROR(("%s mpc for HostAPD failed  %d\n", __FUNCTION__, ret));
+		}
+#endif
 
-	DHD_TRACE(("Firmware = %s\n", fw_path));
-#if !defined(AP) && defined(WLP2P)
-	/* Check if firmware with WFD support used */
-	if ((!op_mode && strstr(fw_path, "_p2p") != NULL) || (op_mode == 0x04) ||
-		(dhd_concurrent_fw(dhd))) {
-		bcm_mkiovar("apsta", (char *)&apsta, 4, iovbuf, sizeof(iovbuf));
-		if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR,
-			iovbuf, sizeof(iovbuf), TRUE, 0)) < 0) {
-			DHD_ERROR(("%s APSTA for WFD failed ret= %d\n", __FUNCTION__, ret));
-		} else {
-			dhd->op_mode |= WFD_MASK;
+	}
+	else {
+		uint32 concurrent_mode = 0;
+		if ((!op_mode && strstr(fw_path, "_p2p") != NULL) ||
+			(op_mode == DHD_FLAG_P2P_MODE)) {
 #if defined(ARP_OFFLOAD_SUPPORT)
 			arpoe = 0;
-#endif /* (ARP_OFFLOAD_SUPPORT) */
+#endif
 #ifdef PKT_FILTER_SUPPORT
 			dhd_pkt_filter_enable = FALSE;
 #endif
+			dhd->op_mode = DHD_FLAG_P2P_MODE;
 		}
-	}
-#endif 
-
-#if !defined(AP) && defined(WL_CFG80211)
-	/* Check if firmware with HostAPD support used */
-	if ((!op_mode && strstr(fw_path, "_apsta") != NULL) || (op_mode == 0x02)) {
-			/* Turn off MPC in AP mode */
-			bcm_mkiovar("mpc", (char *)&mpc, 4, iovbuf, sizeof(iovbuf));
-			if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf,
-				sizeof(iovbuf), TRUE, 0)) < 0) {
-				DHD_ERROR(("%s mpc for HostAPD failed  %d\n", __FUNCTION__, ret));
-			} else {
-				dhd->op_mode |= HOSTAPD_MASK;
+		else
+			dhd->op_mode = DHD_FLAG_STA_MODE;
+#if !defined(AP) && defined(WLP2P)
+		if ((concurrent_mode = dhd_get_concurrent_capabilites(dhd))) {
 #if defined(ARP_OFFLOAD_SUPPORT)
-				arpoe = 0;
-#endif /* (ARP_OFFLOAD_SUPPORT) */
-#ifdef PKT_FILTER_SUPPORT
-				dhd_pkt_filter_enable = FALSE;
+			arpoe = 1;
 #endif
+			dhd->op_mode |= concurrent_mode;
+		}
+
+		/* Check if we are enabling p2p */
+		if (dhd->op_mode & DHD_FLAG_P2P_MODE) {
+			bcm_mkiovar("apsta", (char *)&apsta, 4, iovbuf, sizeof(iovbuf));
+			if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR,
+				iovbuf, sizeof(iovbuf), TRUE, 0)) < 0) {
+				DHD_ERROR(("%s APSTA for P2P failed ret= %d\n", __FUNCTION__, ret));
 			}
-	}
-#endif 
 
-	if ((dhd->op_mode != WFD_MASK) && (dhd->op_mode != HOSTAPD_MASK)) {
-		/* STA only operation mode */
-		dhd->op_mode |= STA_MASK;
-#ifdef PKT_FILTER_SUPPORT
-		dhd_pkt_filter_enable = TRUE;
-#endif
+			memcpy(&p2p_ea, &dhd->mac, ETHER_ADDR_LEN);
+			ETHER_SET_LOCALADDR(&p2p_ea);
+			bcm_mkiovar("p2p_da_override", (char *)&p2p_ea,
+				ETHER_ADDR_LEN, iovbuf, sizeof(iovbuf));
+			if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR,
+				iovbuf, sizeof(iovbuf), TRUE, 0)) < 0) {
+				DHD_ERROR(("%s p2p_da_override ret= %d\n", __FUNCTION__, ret));
+			} else {
+				DHD_INFO(("dhd_preinit_ioctls: p2p_da_override succeeded\n"));
+			}
+		}
+#else
+	(void)concurrent_mode;
+#endif 
 	}
 
-	DHD_ERROR(("Firmware up: op_mode=%d, "
-			"Broadcom Dongle Host Driver mac=%.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
-			dhd->op_mode,
-			dhd->mac.octet[0], dhd->mac.octet[1], dhd->mac.octet[2],
-			dhd->mac.octet[3], dhd->mac.octet[4], dhd->mac.octet[5]));
-
+	DHD_ERROR(("Firmware up: op_mode=0x%04x, "
+		"Broadcom Dongle Host Driver mac="MACDBG"\n",
+		dhd->op_mode,
+		MAC2STRDBG(dhd->mac.octet)));
 	/* Set Country code  */
 	if (dhd->dhd_cspec.ccode[0] != 0) {
 		bcm_mkiovar("country", (char *)&dhd->dhd_cspec,
@@ -3147,6 +3848,42 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 	if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0)
 		DHD_ERROR(("%s assoc_listen failed %d\n", __FUNCTION__, ret));
 
+#if defined(ROAM_ENABLE) || defined(DISABLE_BUILTIN_ROAM)
+	/* Disable built-in roaming to allowed ext supplicant to take care of roaming */
+	bcm_mkiovar("roam_off", (char *)&roamvar, 4, iovbuf, sizeof(iovbuf));
+	dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
+#endif /* ROAM_ENABLE || DISABLE_BUILTIN_ROAM */
+#if defined(ROAM_ENABLE)
+	if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_ROAM_TRIGGER, roam_trigger,
+		sizeof(roam_trigger), TRUE, 0)) < 0)
+		DHD_ERROR(("%s: roam trigger set failed %d\n", __FUNCTION__, ret));
+	if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_ROAM_SCAN_PERIOD, roam_scan_period,
+		sizeof(roam_scan_period), TRUE, 0)) < 0)
+		DHD_ERROR(("%s: roam scan period set failed %d\n", __FUNCTION__, ret));
+	if ((dhd_wl_ioctl_cmd(dhd, WLC_SET_ROAM_DELTA, roam_delta,
+		sizeof(roam_delta), TRUE, 0)) < 0)
+		DHD_ERROR(("%s: roam delta set failed %d\n", __FUNCTION__, ret));
+	bcm_mkiovar("fullroamperiod", (char *)&roam_fullscan_period, 4, iovbuf, sizeof(iovbuf));
+	if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0)
+		DHD_ERROR(("%s: roam fullscan period set failed %d\n", __FUNCTION__, ret));
+#endif /* ROAM_ENABLE */
+
+
+#ifdef WLTDLS
+	bcm_mkiovar("tdls_enable", (char *)&tdls, 4, iovbuf, sizeof(iovbuf));
+	if ((dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0)
+		DHD_ERROR(("%s: tdls enbale failed %d\n", __FUNCTION__, ret));
+
+	bcm_mkiovar("tdls_auto_op", (char *)&tdls_auto_op, 4, iovbuf, sizeof(iovbuf));
+	if ((dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0)
+		DHD_ERROR(("%s: tdls_auto_op failed %d\n", __FUNCTION__, ret));
+
+	bcm_mkiovar("tdls_idle_time", (char *)&tdls_idle_time, 4, iovbuf, sizeof(iovbuf));
+	if ((dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0)
+		DHD_ERROR(("%s: tdls_idle_time failed %d\n", __FUNCTION__, ret));
+#endif /* WLTDLS */
+
+
 	/* Set PowerSave mode */
 	dhd_wl_ioctl_cmd(dhd, WLC_SET_PM, (char *)&power_mode, sizeof(power_mode), TRUE, 0);
 
@@ -3154,14 +3891,17 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 	bcm_mkiovar("bus:txglomalign", (char *)&dongle_align, 4, iovbuf, sizeof(iovbuf));
 	dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
 
-	/* disable glom option for some chips */
-	chipID = (uint16)dhd_bus_chip_id(dhd);
-	if  ((chipID == BCM4330_CHIP_ID) || (chipID == BCM4329_CHIP_ID)) {
-		DHD_INFO(("%s disable glom for chipID=0x%X\n", __FUNCTION__, chipID));
+	if (glom != DEFAULT_GLOM_VALUE) {
+		DHD_INFO(("%s set glom=0x%X\n", __FUNCTION__, glom));
 		bcm_mkiovar("bus:txglom", (char *)&glom, 4, iovbuf, sizeof(iovbuf));
 		dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
 	}
 
+#ifdef BCMSDIOH_TXGLOM
+						if ((dhd->busstate == DHD_BUS_DATA) && bcmsdh_glom_enabled()) {
+							dhd_txglom_enable(dhd, TRUE);
+						}
+#endif /* BCMSDIOH_TXGLOM */
 	/* Setup timeout if Beacons are lost and roam is off to report link down */
 	bcm_mkiovar("bcn_timeout", (char *)&bcn_timeout, 4, iovbuf, sizeof(iovbuf));
 	dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
@@ -3176,6 +3916,7 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 	dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
 #endif /* defined(AP) && !defined(WLP2P) */
 
+
 #if defined(SOFTAP)
 	if (ap_fw_loaded == TRUE) {
 		dhd_wl_ioctl_cmd(dhd, WLC_SET_DTIMPRD, (char *)&dtim, sizeof(dtim), TRUE, 0);
@@ -3190,11 +3931,41 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 #if defined(SOFTAP)
 	if (ap_fw_loaded == FALSE)
 #endif 
-		if ((res = dhd_keep_alive_onoff(dhd)) < 0)
-			DHD_ERROR(("%s set keeplive failed %d\n",
-			__FUNCTION__, res));
+		if (!(dhd->op_mode & DHD_FLAG_HOSTAP_MODE)) {
+			if ((res = dhd_keep_alive_onoff(dhd)) < 0)
+				DHD_ERROR(("%s set keeplive failed %d\n",
+				__FUNCTION__, res));
+		}
 	}
 #endif /* defined(KEEP_ALIVE) */
+#ifdef USE_WL_FRAMEBURST
+	/* Set frameburst to value */
+	if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_FAKEFRAG, (char *)&frameburst,
+		sizeof(frameburst), TRUE, 0)) < 0) {
+		DHD_ERROR(("%s Set frameburst failed  %d\n", __FUNCTION__, ret));
+	}
+#endif /* USE_WL_FRAMEBURST */
+#ifdef CUSTOM_AMPDU_BA_WSIZE
+	/* Set ampdu ba wsize to 64 */
+	bcm_mkiovar("ampdu_ba_wsize", (char *)&ampdu_ba_wsize, 4, iovbuf, sizeof(iovbuf));
+	if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf,
+		sizeof(iovbuf), TRUE, 0)) < 0) {
+		DHD_ERROR(("%s Set ampdu_ba_wsize to %d failed  %d\n",
+			__FUNCTION__, CUSTOM_AMPDU_BA_WSIZE, ret));
+	}
+#endif /* CUSTOM_AMPDU_BA_WSIZE */
+#if defined(BCMSUP_4WAY_HANDSHAKE) && defined(WLAN_AKM_SUITE_FT_8021X)
+	/* Read 4-way handshake requirements. */
+	bcm_mkiovar("sup_wpa", (char *)&sup_wpa, 4,
+		iovbuf, sizeof(iovbuf));
+	ret = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, iovbuf, sizeof(iovbuf), FALSE, 0);
+	if (ret >= 0)
+		dhd->fw_4way_handshake = TRUE;
+	DHD_TRACE(("4-way handshake mode is: %d\n", dhd->fw_4way_handshake));
+#endif /* BCMSUP_4WAY_HANDSHAKE && WLAN_AKM_SUITE_FT_8021X */
+
+	bcm_mkiovar("buf_key_b4_m4", (char *)&buf_key_b4_m4, 4, iovbuf, sizeof(iovbuf));
+	dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
 
 	/* Read event_msgs mask */
 	bcm_mkiovar("event_msgs", eventmask, WL_EVENTING_MASK_LEN, iovbuf, sizeof(iovbuf));
@@ -3208,6 +3979,7 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 	setbit(eventmask, WLC_E_SET_SSID);
 	setbit(eventmask, WLC_E_PRUNE);
 	setbit(eventmask, WLC_E_AUTH);
+	setbit(eventmask, WLC_E_ASSOC);
 	setbit(eventmask, WLC_E_REASSOC);
 	setbit(eventmask, WLC_E_REASSOC_IND);
 	setbit(eventmask, WLC_E_DEAUTH);
@@ -3222,8 +3994,10 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 	setbit(eventmask, WLC_E_MIC_ERROR);
 	setbit(eventmask, WLC_E_ASSOC_REQ_IE);
 	setbit(eventmask, WLC_E_ASSOC_RESP_IE);
+#ifndef WL_CFG80211
 	setbit(eventmask, WLC_E_PMKID_CACHE);
 	setbit(eventmask, WLC_E_TXFAIL);
+#endif
 	setbit(eventmask, WLC_E_JOIN_START);
 	setbit(eventmask, WLC_E_SCAN_COMPLETE);
 #ifdef WLMEDIA_HTSF
@@ -3234,13 +4008,17 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 #endif /* PNO_SUPPORT */
 	/* enable dongle roaming event */
 	setbit(eventmask, WLC_E_ROAM);
+#ifdef BCMCCX
+	setbit(eventmask, WLC_E_ADDTS_IND);
+	setbit(eventmask, WLC_E_DELTS_IND);
+#endif /* BCMCCX */
+#ifdef WLTDLS
+	setbit(eventmask, WLC_E_TDLS_PEER_EVENT);
+#endif /* WLTDLS */
 #ifdef WL_CFG80211
 	setbit(eventmask, WLC_E_ESCAN_RESULT);
-	if ((dhd->op_mode & WFD_MASK) == WFD_MASK) {
+	if (dhd->op_mode & DHD_FLAG_P2P_MODE) {
 		setbit(eventmask, WLC_E_ACTION_FRAME_RX);
-		setbit(eventmask, WLC_E_ACTION_FRAME_COMPLETE);
-		setbit(eventmask, WLC_E_ACTION_FRAME_OFF_CHAN_COMPLETE);
-		setbit(eventmask, WLC_E_P2P_PROBREQ_MSG);
 		setbit(eventmask, WLC_E_P2P_DISC_LISTEN_COMPLETE);
 	}
 #endif /* WL_CFG80211 */
@@ -3272,26 +4050,39 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 		dhd_arp_offload_enable(dhd, FALSE);
 		dhd_arp_offload_set(dhd, 0);
 	}
+	dhd_arp_enable = arpoe;
 #endif /* ARP_OFFLOAD_SUPPORT */
 
 #ifdef PKT_FILTER_SUPPORT
-	/* Setup defintions for pktfilter , enable in suspend */
-	dhd->pktfilter_count = 4;
-	/* Setup filter to allow only unicast */
-	dhd->pktfilter[0] = "100 0 0 0 0x01 0x00";
+	/* Setup default defintions for pktfilter , enable in suspend */
+	dhd->pktfilter_count = 5;
 	dhd->pktfilter[1] = NULL;
 	dhd->pktfilter[2] = NULL;
 	dhd->pktfilter[3] = NULL;
+	/* Add filter to pass multicastDNS packet and NOT filter out as Broadcast */
+	dhd->pktfilter[4] = "104 0 0 0 0xFFFFFFFFFFFF 0x01005E0000FB";
+
+	/* Setup filter to allow only unicast */
+	dhd->pktfilter[0] = "100 0 0 0 0x01 0x00";
+
 #if defined(SOFTAP)
 	if (ap_fw_loaded) {
-		int i;
-		for (i = 0; i < dhd->pktfilter_count; i++) {
-			dhd_pktfilter_offload_enable(dhd, dhd->pktfilter[i],
-				0, dhd_master_mode);
-		}
+		dhd_enable_packet_filter(0, dhd);
 	}
 #endif /* defined(SOFTAP) */
+	dhd_set_packet_filter(dhd);
 #endif /* PKT_FILTER_SUPPORT */
+#ifdef DISABLE_11N
+	bcm_mkiovar("nmode", (char *)&nmode, 4, iovbuf, sizeof(iovbuf));
+	if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0)
+		DHD_ERROR(("%s wl nmode 0 failed %d\n", __FUNCTION__, ret));
+#else
+#if defined(PROP_TXSTATUS) && defined(PROP_TXSTATUS_VSDB)
+	bcm_mkiovar("ampdu_hostreorder", (char *)&hostreorder, 4, buf, sizeof(buf));
+	dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, buf, sizeof(buf), TRUE, 0);
+#endif 
+#endif /* DISABLE_11N */
+
 
 	/* query for 'ver' to get version info from firmware */
 	memset(buf, 0, sizeof(buf));
@@ -3303,8 +4094,18 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 		bcmstrtok(&ptr, "\n", 0);
 		/* Print fw version info */
 		DHD_ERROR(("Firmware version = %s\n", buf));
+		dhd_set_version_info(dhd, buf);
+
+		/* Check and adjust IOCTL response timeout for Manufactring firmware */
+		if (strstr(buf, MANUFACTRING_FW) != NULL) {
+			dhd_os_set_ioctl_resp_timeout(20000);
+			DHD_ERROR(("%s : adjust IOCTL response time for Manufactring Firmware\n",
+			__FUNCTION__));
+		}
 	}
 
+	dhd_wl_ioctl_cmd(dhd, WLC_SET_SRL, (char *)&srl, sizeof(srl), TRUE, 0);
+	dhd_wl_ioctl_cmd(dhd, WLC_SET_LRL, (char *)&lrl, sizeof(lrl), TRUE, 0);
 done:
 	return ret;
 }
@@ -3363,7 +4164,7 @@ int dhd_change_mtu(dhd_pub_t *dhdp, int new_mtu, int ifidx)
 #ifdef ARP_OFFLOAD_SUPPORT
 /* add or remove AOE host ip(s) (up to 8 IPs on the interface)  */
 void
-aoe_update_host_ipv4_table(dhd_pub_t *dhd_pub, u32 ipa, bool add)
+aoe_update_host_ipv4_table(dhd_pub_t *dhd_pub, u32 ipa, bool add, int idx)
 {
 	u32 ipv4_buf[MAX_IPV4_ENTRIES]; /* temp save for AOE host_ip table */
 	int i;
@@ -3372,13 +4173,13 @@ aoe_update_host_ipv4_table(dhd_pub_t *dhd_pub, u32 ipa, bool add)
 	bzero(ipv4_buf, sizeof(ipv4_buf));
 
 	/* display what we've got */
-	ret = dhd_arp_get_arp_hostip_table(dhd_pub, ipv4_buf, sizeof(ipv4_buf));
+	ret = dhd_arp_get_arp_hostip_table(dhd_pub, ipv4_buf, sizeof(ipv4_buf), idx);
 	DHD_ARPOE(("%s: hostip table read from Dongle:\n", __FUNCTION__));
 #ifdef AOE_DBG
 	dhd_print_buf(ipv4_buf, 32, 4); /* max 8 IPs 4b each */
 #endif
 	/* now we saved hoste_ip table, clr it in the dongle AOE */
-	dhd_aoe_hostip_clr(dhd_pub);
+	dhd_aoe_hostip_clr(dhd_pub, idx);
 
 	if (ret) {
 		DHD_ERROR(("%s failed\n", __FUNCTION__));
@@ -3399,19 +4200,24 @@ aoe_update_host_ipv4_table(dhd_pub_t *dhd_pub, u32 ipa, bool add)
 
 		if (ipv4_buf[i] != 0) {
 			/* add back host_ip entries from our local cache */
-			dhd_arp_offload_add_ip(dhd_pub, ipv4_buf[i]);
+			dhd_arp_offload_add_ip(dhd_pub, ipv4_buf[i], idx);
 			DHD_ARPOE(("%s: added IP:%x to dongle arp_hostip[%d]\n\n",
 				__FUNCTION__, ipv4_buf[i], i));
 		}
 	}
 #ifdef AOE_DBG
 	/* see the resulting hostip table */
-	dhd_arp_get_arp_hostip_table(dhd_pub, ipv4_buf, sizeof(ipv4_buf));
+	dhd_arp_get_arp_hostip_table(dhd_pub, ipv4_buf, sizeof(ipv4_buf), idx);
 	DHD_ARPOE(("%s: read back arp_hostip table:\n", __FUNCTION__));
 	dhd_print_buf(ipv4_buf, 32, 4); /* max 8 IPs 4b each */
 #endif
 }
 
+/*
+ * Notification mechanism from kernel to our driver. This function is called by the Linux kernel
+ * whenever there is an event related to an IP address.
+ * ptr : kernel provided pointer to IP address that has changed
+ */
 static int dhd_device_event(struct notifier_block *this,
 	unsigned long event,
 	void *ptr)
@@ -3420,19 +4226,48 @@ static int dhd_device_event(struct notifier_block *this,
 
 	dhd_info_t *dhd;
 	dhd_pub_t *dhd_pub;
+	int idx;
 
-	if (!ifa)
+	if (!dhd_arp_enable)
+		return NOTIFY_DONE;
+	if (!ifa || !(ifa->ifa_dev->dev))
 		return NOTIFY_DONE;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 31))
+	/* Filter notifications meant for non Broadcom devices */
+	if ((ifa->ifa_dev->dev->netdev_ops != &dhd_ops_pri) &&
+	    (ifa->ifa_dev->dev->netdev_ops != &dhd_ops_virt)) {
+#ifdef WLP2P
+		if (!wl_cfgp2p_is_ifops(ifa->ifa_dev->dev->netdev_ops))
+#endif
+			return NOTIFY_DONE;
+	}
+#endif /* LINUX_VERSION_CODE */
+
 	dhd = *(dhd_info_t **)netdev_priv(ifa->ifa_dev->dev);
+	if (!dhd)
+		return NOTIFY_DONE;
+
 	dhd_pub = &dhd->pub;
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 31))
-	if (ifa->ifa_dev->dev->netdev_ops == &dhd_ops_pri) {
-#else
-	if (ifa->ifa_dev->dev) {
-#endif
-		switch (event) {
+	if (dhd_pub->arp_version == 1) {
+		idx = 0;
+	}
+	else {
+		for (idx = 0; idx < DHD_MAX_IFS; idx++) {
+			if (dhd->iflist[idx] && dhd->iflist[idx]->net == ifa->ifa_dev->dev)
+			break;
+		}
+		if (idx < DHD_MAX_IFS)
+			DHD_TRACE(("ifidx : %p %s %d\n", dhd->iflist[idx]->net,
+				dhd->iflist[idx]->name, dhd->iflist[idx]->idx));
+		else {
+			DHD_ERROR(("Cannot find ifidx for(%s) set to 0\n", ifa->ifa_label));
+			idx = 0;
+		}
+	}
+
+	switch (event) {
 		case NETDEV_UP:
 			DHD_ARPOE(("%s: [%s] Up IP: 0x%x\n",
 				__FUNCTION__, ifa->ifa_label, ifa->ifa_address));
@@ -3448,14 +4283,10 @@ static int dhd_device_event(struct notifier_block *this,
 			}
 
 #ifdef AOE_IP_ALIAS_SUPPORT
-			if (ifa->ifa_label[strlen(ifa->ifa_label)-2] == 0x3a) {
-				DHD_ARPOE(("%s:add aliased IP to AOE hostip cache\n",
-					__FUNCTION__));
-				aoe_update_host_ipv4_table(dhd_pub, ifa->ifa_address, TRUE);
-			}
-			else
-				aoe_update_host_ipv4_table(dhd_pub, ifa->ifa_address, TRUE);
-#endif
+			DHD_ARPOE(("%s:add aliased IP to AOE hostip cache\n",
+				__FUNCTION__));
+			aoe_update_host_ipv4_table(dhd_pub, ifa->ifa_address, TRUE, idx);
+#endif /* AOE_IP_ALIAS_SUPPORT */
 			break;
 
 		case NETDEV_DOWN:
@@ -3463,24 +4294,19 @@ static int dhd_device_event(struct notifier_block *this,
 				__FUNCTION__, ifa->ifa_label, ifa->ifa_address));
 			dhd->pend_ipaddr = 0;
 #ifdef AOE_IP_ALIAS_SUPPORT
-		if (!(ifa->ifa_label[strlen(ifa->ifa_label)-2] == 0x3a)) {
-				DHD_ARPOE(("%s: primary interface is down, AOE clr all\n",
-				           __FUNCTION__));
-				dhd_aoe_hostip_clr(&dhd->pub);
-				dhd_aoe_arp_clr(&dhd->pub);
-		} else
-			aoe_update_host_ipv4_table(dhd_pub, ifa->ifa_address, FALSE);
+			DHD_ARPOE(("%s:interface is down, AOE clr all for this if\n",
+				__FUNCTION__));
+			aoe_update_host_ipv4_table(dhd_pub, ifa->ifa_address, FALSE, idx);
 #else
-			dhd_aoe_hostip_clr(&dhd->pub);
-			dhd_aoe_arp_clr(&dhd->pub);
-#endif
+			dhd_aoe_hostip_clr(&dhd->pub, idx);
+			dhd_aoe_arp_clr(&dhd->pub, idx);
+#endif /* AOE_IP_ALIAS_SUPPORT */
 			break;
 
 		default:
 			DHD_ARPOE(("%s: do noting for [%s] Event: %lu\n",
 				__func__, ifa->ifa_label, event));
 			break;
-		}
 	}
 	return NOTIFY_DONE;
 }
@@ -3525,6 +4351,8 @@ dhd_net_attach(dhd_pub_t *dhdp, int ifidx)
 #else
 		net->netdev_ops = &dhd_ops_pri;
 #endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31) */
+		if (!ETHER_ISNULLADDR(dhd->pub.mac.octet))
+			memcpy(temp_addr, dhd->pub.mac.octet, ETHER_ADDR_LEN);
 	} else {
 		/*
 		 * We have to use the primary MAC for virtual interfaces
@@ -3548,14 +4376,14 @@ dhd_net_attach(dhd_pub_t *dhdp, int ifidx)
 	net->ethtool_ops = &dhd_ethtool_ops;
 #endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24) */
 
-#if defined(CONFIG_WIRELESS_EXT)
+#if defined(WL_WIRELESS_EXT)
 #if WIRELESS_EXT < 19
 	net->get_wireless_stats = dhd_get_wireless_stats;
 #endif /* WIRELESS_EXT < 19 */
 #if WIRELESS_EXT > 12
 	net->wireless_handlers = (struct iw_handler_def *)&wl_iw_handler_def;
 #endif /* WIRELESS_EXT > 12 */
-#endif /* defined(CONFIG_WIRELESS_EXT) */
+#endif /* defined(WL_WIRELESS_EXT) */
 
 	dhd->pub.rxsz = DBUS_RX_BUFFER_SIZE_DHD(net);
 
@@ -3566,17 +4394,17 @@ dhd_net_attach(dhd_pub_t *dhdp, int ifidx)
 		goto fail;
 	}
 	printf("Broadcom Dongle Host Driver: register interface [%s]"
-		" MAC: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
+		" MAC: "MACDBG"\n",
 		net->name,
-		net->dev_addr[0], net->dev_addr[1], net->dev_addr[2],
-		net->dev_addr[3], net->dev_addr[4], net->dev_addr[5]);
+		MAC2STRDBG(net->dev_addr));
 
-#if defined(SOFTAP) && defined(CONFIG_WIRELESS_EXT) && !defined(WL_CFG80211)
+#if defined(SOFTAP) && defined(WL_WIRELESS_EXT) && !defined(WL_CFG80211)
 		wl_iw_iscan_set_scan_broadcast_prep(net, 1);
 #endif
 
 #if 1 && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
 	if (ifidx == 0) {
+		dhd_registration_check = TRUE;
 		up(&dhd_registration_sem);
 	}
 #endif 
@@ -3616,7 +4444,7 @@ dhd_bus_detach(dhd_pub_t *dhdp)
 
 #if defined(OOB_INTR_ONLY)
 			bcmsdh_unregister_oob_intr();
-#endif /* defined(OOB_INTR_ONLY) */
+#endif 
 		}
 	}
 }
@@ -3637,6 +4465,7 @@ void dhd_detach(dhd_pub_t *dhdp)
 
 	DHD_TRACE(("%s: Enter state 0x%x\n", __FUNCTION__, dhd->dhd_state));
 
+	dhd->pub.up = 0;
 	if (!(dhd->dhd_state & DHD_ATTACH_STATE_DONE)) {
 		/* Give sufficient time for threads to start running in case
 		 * dhd_attach() has failed
@@ -3644,26 +4473,36 @@ void dhd_detach(dhd_pub_t *dhdp)
 		osl_delay(1000*100);
 	}
 
+	if (dhd->dhd_state & DHD_ATTACH_STATE_PROT_ATTACH) {
+		dhd_bus_detach(dhdp);
+
+		if (dhdp->prot)
+			dhd_prot_detach(dhdp);
+	}
+
 #ifdef ARP_OFFLOAD_SUPPORT
 	unregister_inetaddr_notifier(&dhd_notifier);
 #endif /* ARP_OFFLOAD_SUPPORT */
 
-#if defined(CONFIG_HAS_EARLYSUSPEND)
+#if defined(CONFIG_HAS_EARLYSUSPEND) && defined(DHD_USE_EARLYSUSPEND)
 	if (dhd->dhd_state & DHD_ATTACH_STATE_EARLYSUSPEND_DONE) {
 		if (dhd->early_suspend.suspend)
 			unregister_early_suspend(&dhd->early_suspend);
 	}
-#endif /* defined(CONFIG_HAS_EARLYSUSPEND) */
+#endif /* CONFIG_HAS_EARLYSUSPEND && DHD_USE_EARLYSUSPEND */
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
+	cancel_work_sync(&dhd->work_hang);
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))  */
 
-#if defined(CONFIG_WIRELESS_EXT)
+#if defined(WL_WIRELESS_EXT)
 	if (dhd->dhd_state & DHD_ATTACH_STATE_WL_ATTACH) {
 		/* Detatch and unlink in the iw */
 		wl_iw_detach();
 	}
-#endif /* defined(CONFIG_WIRELESS_EXT) */
+#endif /* defined(WL_WIRELESS_EXT) */
 
-	if (&dhd->thr_sysioc_ctl.thr_pid >= 0) {
+	if (dhd->thr_sysioc_ctl.thr_pid >= 0) {
 		PROC_STOP(&dhd->thr_sysioc_ctl);
 	}
 
@@ -3673,31 +4512,33 @@ void dhd_detach(dhd_pub_t *dhdp)
 		dhd_if_t *ifp;
 
 		/* Cleanup virtual interfaces */
-		for (i = 1; i < DHD_MAX_IFS; i++)
+		for (i = 1; i < DHD_MAX_IFS; i++) {
+			dhd_net_if_lock_local(dhd);
 			if (dhd->iflist[i]) {
 				dhd->iflist[i]->state = DHD_IF_DEL;
 				dhd->iflist[i]->idx = i;
 				dhd_op_if(dhd->iflist[i]);
 			}
 
+			dhd_net_if_unlock_local(dhd);
+		}
 		/*  delete primary interface 0 */
 		ifp = dhd->iflist[0];
 		ASSERT(ifp);
 		ASSERT(ifp->net);
+		if (ifp && ifp->net) {
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31))
-		if (ifp->net->open)
+			if (ifp->net->open)
 #else
-		if (ifp->net->netdev_ops == &dhd_ops_pri)
+			if (ifp->net->netdev_ops == &dhd_ops_pri)
 #endif
-		{
-			if (ifp->net) {
+			{
 				unregister_netdev(ifp->net);
 				free_netdev(ifp->net);
 				ifp->net = NULL;
+				MFREE(dhd->pub.osh, ifp, sizeof(*ifp));
+				dhd->iflist[0] = NULL;
 			}
-			MFREE(dhd->pub.osh, ifp, sizeof(*ifp));
-			dhd->iflist[0] = NULL;
-
 		}
 	}
 
@@ -3718,17 +4559,15 @@ void dhd_detach(dhd_pub_t *dhdp)
 		if (dhd->thr_dpc_ctl.thr_pid >= 0) {
 			PROC_STOP(&dhd->thr_dpc_ctl);
 		}
+#ifdef RXFRAME_THREAD
+		if (dhd->thr_rxf_ctl.thr_pid >= 0) {
+			PROC_STOP(&dhd->thr_rxf_ctl);
+		}
+#endif
 		else
 #endif /* DHDTHREAD */
 		tasklet_kill(&dhd->tasklet);
 	}
-	if (dhd->dhd_state & DHD_ATTACH_STATE_PROT_ATTACH) {
-		dhd_bus_detach(dhdp);
-
-		if (dhdp->prot)
-			dhd_prot_detach(dhdp);
-	}
-
 #ifdef WL_CFG80211
 	if (dhd->dhd_state & DHD_ATTACH_STATE_CFG80211) {
 		wl_cfg80211_detach(NULL);
@@ -3743,10 +4582,17 @@ void dhd_detach(dhd_pub_t *dhdp)
 	/* && defined(CONFIG_PM_SLEEP) */
 
 	if (dhd->dhd_state & DHD_ATTACH_STATE_WAKELOCKS_INIT) {
+		DHD_TRACE(("wd wakelock count:%d\n", dhd->wakelock_wd_counter));
 #ifdef CONFIG_HAS_WAKELOCK
+		dhd->wakelock_counter = 0;
+		dhd->wakelock_wd_counter = 0;
+		dhd->wakelock_rx_timeout_enable = 0;
+		dhd->wakelock_ctrl_timeout_enable = 0;
 		wake_lock_destroy(&dhd->wl_wifi);
 		wake_lock_destroy(&dhd->wl_rxwake);
-#endif
+		wake_lock_destroy(&dhd->wl_ctrlwake);
+		wake_lock_destroy(&dhd->wl_wdwake);
+#endif /* CONFIG_HAS_WAKELOCK */
 	}
 }
 
@@ -3785,6 +4631,8 @@ dhd_module_cleanup(void)
 {
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
+	module_remove = 1; 
+	module_insert = 0;
 	dhd_bus_unregister();
 
 #if defined(CONFIG_WIFI_CONTROL_FUNC)
@@ -3797,6 +4645,10 @@ dhd_module_cleanup(void)
 }
 
 
+#if defined(CONFIG_WIFI_CONTROL_FUNC)
+extern bool g_wifi_poweron;
+#endif /* CONFIG_WIFI_CONTROL_FUNC */
+
 static int __init
 dhd_module_init(void)
 {
@@ -3823,9 +4675,11 @@ dhd_module_init(void)
 			break;
 
 		DHD_ERROR(("Invalid module parameters.\n"));
-		return -EINVAL;
+		error = -EINVAL;
 	} while (0);
 #endif 
+	if (error)
+		goto fail_0;
 
 #if 1 && defined(BCMLXSDMMC) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
 	do {
@@ -3833,8 +4687,10 @@ dhd_module_init(void)
 		dhd_bus_reg_sdio_notify(&dhd_chipup_sem);
 		dhd_customer_gpio_wlan_ctrl(WLAN_POWER_ON);
 #if defined(CONFIG_WIFI_CONTROL_FUNC)
-		if (wl_android_wifictrl_func_add() < 0)
+		if (wl_android_wifictrl_func_add() < 0) {
+			dhd_bus_unreg_sdio_notify();
 			goto fail_1;
+		}
 #endif /* defined(CONFIG_WIFI_CONTROL_FUNC) */
 		if (down_timeout(&dhd_chipup_sem,
 			msecs_to_jiffies(POWERUP_WAIT_MS)) == 0) {
@@ -3853,7 +4709,8 @@ dhd_module_init(void)
 
 	if (!chip_up) {
 		DHD_ERROR(("\nfailed to power up wifi chip, max retry reached, exits **\n\n"));
-		return -ENODEV;
+		error = -ENODEV;
+		goto fail_0;
 	}
 #else
 	dhd_customer_gpio_wlan_ctrl(WLAN_POWER_ON);
@@ -3864,6 +4721,17 @@ dhd_module_init(void)
 
 #endif 
 
+#if defined(CONFIG_WIFI_CONTROL_FUNC) && defined(BCMLXSDMMC)
+	/* If the wifi_set_power() is failed,
+	 * we need to jump error handling routines.
+	 */
+	if (!g_wifi_poweron) {
+		printk("%s: wifi_set_power() failed\n", __FUNCTION__);
+		error = -ENODEV;
+		goto fail_1;
+	}
+#endif /* defined(CONFIG_WIFI_CONTROL_FUNC) */
+
 #if 1 && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
 	sema_init(&dhd_registration_sem, 0);
 #endif 
@@ -3878,15 +4746,17 @@ dhd_module_init(void)
 		goto fail_1;
 	}
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(BCMLXSDMMC)
 	/*
 	 * Wait till MMC sdio_register_driver callback called and made driver attach.
 	 * It's needed to make sync up exit from dhd insmod  and
 	 * Kernel MMC sdio device callback registration
 	 */
-	if (down_timeout(&dhd_registration_sem,  msecs_to_jiffies(DHD_REGISTRATION_TIMEOUT)) != 0) {
+	if ((down_timeout(&dhd_registration_sem,
+		msecs_to_jiffies(DHD_REGISTRATION_TIMEOUT)) != 0) ||
+		(dhd_registration_check != TRUE)) {
 		error = -ENODEV;
-		DHD_ERROR(("%s: sdio_register_driver timeout\n", __FUNCTION__));
+		DHD_ERROR(("%s: sdio_register_driver timeout or error \n", __FUNCTION__));
 		goto fail_2;
 	}
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
@@ -3894,9 +4764,11 @@ dhd_module_init(void)
 	wl_android_post_init();
 #endif /* defined(WL_CFG80211) */
 
+	module_insert = 1;
+
 	return error;
 
-#if 1 && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
+#if 1 && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(BCMLXSDMMC)
 fail_2:
 	dhd_bus_unregister();
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
@@ -3910,6 +4782,10 @@ fail_1:
 	/* Call customer gpio to turn off power with WL_REG_ON signal */
 	dhd_customer_gpio_wlan_ctrl(WLAN_POWER_OFF);
 
+fail_0:
+
+	wl_android_exit();
+
 	return error;
 }
 
@@ -3966,36 +4842,16 @@ int
 dhd_os_ioctl_resp_wait(dhd_pub_t *pub, uint *condition, bool *pending)
 {
 	dhd_info_t * dhd = (dhd_info_t *)(pub->info);
-	DECLARE_WAITQUEUE(wait, current);
-	int timeout = dhd_ioctl_timeout_msec;
+	int timeout;
 
 	/* Convert timeout in millsecond to jiffies */
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
-	timeout = msecs_to_jiffies(timeout);
+	timeout = msecs_to_jiffies(dhd_ioctl_timeout_msec);
 #else
-	timeout = timeout * HZ / 1000;
+	timeout = dhd_ioctl_timeout_msec * HZ / 1000;
 #endif
 
-	/* Wait until control frame is available */
-	add_wait_queue(&dhd->ioctl_resp_wait, &wait);
-	set_current_state(TASK_INTERRUPTIBLE);
-
-	/* Memory barrier to support multi-processing
-	 * As the variable "condition", which points to dhd->rxlen (dhd_bus_rxctl[dhd_sdio.c])
-	 * Can be changed by another processor.
-	 */
-	smp_mb();
-	while (!(*condition) && (!signal_pending(current) && timeout)) {
-		timeout = schedule_timeout(timeout);
-		smp_mb();
-	}
-
-	if (signal_pending(current))
-		*pending = TRUE;
-
-	set_current_state(TASK_RUNNING);
-	remove_wait_queue(&dhd->ioctl_resp_wait, &wait);
-
+	timeout = wait_event_timeout(dhd->ioctl_resp_wait, (*condition), timeout);
 	return timeout;
 }
 
@@ -4005,26 +4861,46 @@ dhd_os_ioctl_resp_wake(dhd_pub_t *pub)
 	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
 
 	if (waitqueue_active(&dhd->ioctl_resp_wait)) {
-		wake_up_interruptible(&dhd->ioctl_resp_wait);
+		wake_up(&dhd->ioctl_resp_wait);
 	}
 
 	return 0;
 }
 
 void
+dhd_os_wd_timer_extend(void *bus, bool extend)
+{
+	dhd_pub_t *pub = bus;
+	dhd_info_t *dhd = (dhd_info_t *)pub->info;
+
+	if (extend)
+		dhd_os_wd_timer(bus, WATCHDOG_EXTEND_INTERVAL);
+	else
+		dhd_os_wd_timer(bus, dhd->default_wd_interval);
+}
+
+
+void
 dhd_os_wd_timer(void *bus, uint wdtick)
 {
 	dhd_pub_t *pub = bus;
 	dhd_info_t *dhd = (dhd_info_t *)pub->info;
 	unsigned long flags;
-
-	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
+	
+	DHD_TRACE(("%s: Enter, wdtick = %d\n", __FUNCTION__, wdtick));
+	
+	if (!dhd) {
+		DHD_ERROR(("%s: dhd NULL\n", __FUNCTION__));
+		return;
+	}
 
 	flags = dhd_os_spin_lock(pub);
 
 	/* don't start the wd until fw is loaded */
 	if (pub->busstate == DHD_BUS_DOWN) {
 		dhd_os_spin_unlock(pub, flags);
+		if (!wdtick)
+			DHD_OS_WD_WAKE_UNLOCK(pub);
 		return;
 	}
 
@@ -4037,13 +4913,15 @@ dhd_os_wd_timer(void *bus, uint wdtick)
 #else
 		del_timer(&dhd->timer);
 #endif /* DHDTHREAD */
+		DHD_OS_WD_WAKE_UNLOCK(pub);
 		return;
 	}
 
 	if (wdtick) {
+		DHD_OS_WD_WAKE_LOCK(pub);
 		dhd_watchdog_ms = (uint)wdtick;
 		/* Re arm the timer, at last watchdog period */
-		mod_timer(&dhd->timer, jiffies + dhd_watchdog_ms * HZ / 1000);
+		mod_timer(&dhd->timer, jiffies + msecs_to_jiffies(dhd_watchdog_ms));
 		dhd->wd_timer_valid = TRUE;
 	}
 	dhd_os_spin_unlock(pub, flags);
@@ -4161,6 +5039,28 @@ dhd_os_sdtxunlock(dhd_pub_t *pub)
 	dhd_os_sdunlock(pub);
 }
 
+#if defined(DHDTHREAD) && defined(RXFRAME_THREAD)
+static void
+dhd_os_rxflock(dhd_pub_t *pub)
+{
+	dhd_info_t *dhd;
+
+	dhd = (dhd_info_t *)(pub->info);
+	spin_lock_bh(&dhd->rxf_lock);
+
+}
+
+static void
+dhd_os_rxfunlock(dhd_pub_t *pub)
+{
+	dhd_info_t *dhd;
+
+	dhd = (dhd_info_t *)(pub->info);
+	spin_unlock_bh(&dhd->rxf_lock);
+}
+#endif /* defined(DHDTHREAD) && defined(RXFRAME_THREAD) */
+
+
 #if defined(CONFIG_DHD_USE_STATIC_BUF)
 uint8* dhd_os_prealloc(void *osh, int section, uint size)
 {
@@ -4172,7 +5072,7 @@ void dhd_os_prefree(void *osh, void *addr, uint size)
 }
 #endif /* defined(CONFIG_WIFI_CONTROL_FUNC) */
 
-#if defined(CONFIG_WIRELESS_EXT)
+#if defined(WL_WIRELESS_EXT)
 struct iw_statistics *
 dhd_get_wireless_stats(struct net_device *dev)
 {
@@ -4190,7 +5090,7 @@ dhd_get_wireless_stats(struct net_device *dev)
 	else
 		return NULL;
 }
-#endif /* defined(CONFIG_WIRELESS_EXT) */
+#endif /* defined(WL_WIRELESS_EXT) */
 
 static int
 dhd_wl_host_event(dhd_info_t *dhd, int *ifidx, void *pktdata,
@@ -4203,7 +5103,7 @@ dhd_wl_host_event(dhd_info_t *dhd, int *ifidx, void *pktdata,
 	if (bcmerror != BCME_OK)
 		return (bcmerror);
 
-#if defined(CONFIG_WIRELESS_EXT)
+#if defined(WL_WIRELESS_EXT)
 	if (event->bsscfgidx == 0) {
 		/*
 		 * Wireless ext is on primary interface only
@@ -4216,7 +5116,7 @@ dhd_wl_host_event(dhd_info_t *dhd, int *ifidx, void *pktdata,
 		wl_iw_event(dhd->iflist[*ifidx]->net, event, *data);
 		}
 	}
-#endif /* defined(CONFIG_WIRELESS_EXT)  */
+#endif /* defined(WL_WIRELESS_EXT)  */
 
 #ifdef WL_CFG80211
 	if ((ntoh32(event->event_type) == WLC_E_IF) &&
@@ -4356,10 +5256,17 @@ void dhd_wait_for_event(dhd_pub_t *dhd, bool *lockvar)
 {
 #if 1 && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))
 	struct dhd_info *dhdinfo =  dhd->info;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
+	int timeout = msecs_to_jiffies(IOCTL_RESP_TIMEOUT);
+#else
+	int timeout = (IOCTL_RESP_TIMEOUT / 1000) * HZ;
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
+
 	dhd_os_sdunlock(dhd);
-	wait_event_interruptible_timeout(dhdinfo->ctrl_wait, (*lockvar == FALSE), HZ * 2);
+	wait_event_timeout(dhdinfo->ctrl_wait, (*lockvar == FALSE), timeout);
 	dhd_os_sdlock(dhd);
-#endif
+#endif 
 	return;
 }
 
@@ -4368,7 +5275,7 @@ void dhd_wait_event_wakeup(dhd_pub_t *dhd)
 #if 1 && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))
 	struct dhd_info *dhdinfo =  dhd->info;
 	if (waitqueue_active(&dhdinfo->ctrl_wait))
-		wake_up_interruptible(&dhdinfo->ctrl_wait);
+		wake_up(&dhdinfo->ctrl_wait);
 #endif
 	return;
 }
@@ -4380,6 +5287,13 @@ dhd_dev_reset(struct net_device *dev, uint8 flag)
 
 	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
 
+	if (flag == TRUE) {
+		/* Issue wl down command before resetting the chip */
+		if (dhd_wl_ioctl_cmd(&dhd->pub, WLC_DOWN, NULL, 0, TRUE, 0) < 0) {
+			DHD_TRACE(("%s: wl down failed\n", __FUNCTION__));
+		}
+	}
+
 	ret = dhd_bus_devreset(&dhd->pub, flag);
 	if (ret) {
 		DHD_ERROR(("%s: dhd_bus_devreset: %d\n", __FUNCTION__, ret));
@@ -4401,36 +5315,44 @@ int net_os_set_suspend_disable(struct net_device *dev, int val)
 	return ret;
 }
 
-int net_os_set_suspend(struct net_device *dev, int val)
+int net_os_set_suspend(struct net_device *dev, int val, int force)
 {
 	int ret = 0;
-#if defined(CONFIG_HAS_EARLYSUSPEND)
 	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
 
 	if (dhd) {
+#if defined(CONFIG_HAS_EARLYSUSPEND) && defined(DHD_USE_EARLYSUSPEND)
 		ret = dhd_set_suspend(val, &dhd->pub);
+#else
+		ret = dhd_suspend_resume_helper(dhd, val, force);
+#endif
+#ifdef WL_CFG80211
+		wl_cfg80211_update_power_mode(dev);
+#endif
 	}
-#endif /* defined(CONFIG_HAS_EARLYSUSPEND) */
 	return ret;
 }
 
-int net_os_set_dtim_skip(struct net_device *dev, int val)
+int net_os_set_suspend_bcn_li_dtim(struct net_device *dev, int val)
 {
 	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
 
 	if (dhd)
-		dhd->pub.dtim_skip = val;
+		dhd->pub.suspend_bcn_li_dtim = val;
 
 	return 0;
 }
 
+#ifdef PKT_FILTER_SUPPORT
 int net_os_rxfilter_add_remove(struct net_device *dev, int add_remove, int num)
 {
+#ifndef GAN_LITE_NAT_KEEPALIVE_FILTER
 	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
 	char *filterp = NULL;
 	int ret = 0;
 
-	if (!dhd || (num == DHD_UNICAST_FILTER_NUM))
+	if (!dhd || (num == DHD_UNICAST_FILTER_NUM) ||
+	    (num == DHD_MDNS_FILTER_NUM))
 		return ret;
 	if (num >= dhd->pub.pktfilter_count)
 		return -EINVAL;
@@ -4450,12 +5372,16 @@ int net_os_rxfilter_add_remove(struct net_device *dev, int add_remove, int num)
 		}
 	}
 	dhd->pub.pktfilter[num] = filterp;
+	dhd_pktfilter_offload_set(&dhd->pub, dhd->pub.pktfilter[num]);
 	return ret;
+#else
+	return 0;
+#endif /* GAN_LITE_NAT_KEEPALIVE_FILTER */
 }
 
-int net_os_set_packet_filter(struct net_device *dev, int val)
+int dhd_os_enable_packet_filter(dhd_pub_t *dhdp, int val)
+
 {
-	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
 	int ret = 0;
 
 	/* Packet filtering is set only if we still in early-suspend and
@@ -4463,22 +5389,31 @@ int net_os_set_packet_filter(struct net_device *dev, int val)
 	 * We can always turn it OFF in case of early-suspend, but we turn it
 	 * back ON only if suspend_disable_flag was not set
 	*/
-	if (dhd && dhd->pub.up) {
-		if (dhd->pub.in_suspend) {
-			if (!val || (val && !dhd->pub.suspend_disable_flag))
-				dhd_set_packet_filter(val, &dhd->pub);
+	if (dhdp && dhdp->up) {
+		if (dhdp->in_suspend) {
+			if (!val || (val && !dhdp->suspend_disable_flag))
+				dhd_enable_packet_filter(val, dhdp);
 		}
 	}
 	return ret;
 }
 
+/* function to enable/disable packet for Network device */
+int net_os_enable_packet_filter(struct net_device *dev, int val)
+{
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
+
+	return dhd_os_enable_packet_filter(&dhd->pub, val);
+}
+#endif /* PKT_FILTER_SUPPORT */
 
-void
+int
 dhd_dev_init_ioctl(struct net_device *dev)
 {
 	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
 
-	dhd_preinit_ioctls(&dhd->pub);
+
+	return dhd_preinit_ioctls(&dhd->pub);
 }
 
 #ifdef PNO_SUPPORT
@@ -4523,33 +5458,112 @@ dhd_dev_get_pno_status(struct net_device *dev)
 
 #endif /* PNO_SUPPORT */
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && (1)
+static void dhd_hang_process(struct work_struct *work)
+{
+	dhd_info_t *dhd;
+	struct net_device *dev;
+
+	int ret;
+	s32 updown = 0;
+	dhd = (dhd_info_t *)container_of(work, dhd_info_t, work_hang);
+	dev = dhd->iflist[0]->net;
+
+	if (dev) {
+#if 0
+		rtnl_lock();
+		dev_close(dev);
+		rtnl_unlock();
+#else
+		printf(" %s before send hang messages, do wlc down to prevent get additional event from firmware\n", __func__);
+		if ((ret = wldev_ioctl(dev, WLC_DOWN, &updown, sizeof(s32), false))) {
+			WL_ERR(("fail to set wlc down"));
+		}
+#endif
+#if defined(WL_WIRELESS_EXT)
+		wl_iw_send_priv_event(dev, "HANG");
+#endif
+#if defined(WL_CFG80211)
+		wl_cfg80211_hang(dev, WLAN_REASON_UNSPECIFIED);
+#endif
+	}
+}
+
+int dhd_os_send_hang_message(dhd_pub_t *dhdp)
+{
+	int ret = 0;
+	printf("%s: Enter\n",__func__);
+	if (dhdp) {
+		if (!dhdp->hang_was_sent) {
+			printf("[debug] %s: set hang_was_sent\n",__func__);
+			dhdp->hang_was_sent = 1;
+
+
+			printf("[debug] %s: schedule hang event\n", __FUNCTION__);
+
+
+			schedule_work(&dhdp->info->work_hang);
+		}
+		else
+			printf("[debug] %s: hang_was_sent already is 1, don't schedule hang work again\n",__func__);
+	}
+	return ret;
+}
+
 int net_os_send_hang_message(struct net_device *dev)
 {
 	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
 	int ret = 0;
 
+	if (module_remove) {
+		printf("%s: module removed. Do not send hang event.\n", __FUNCTION__);
+		return ret;
+	}
 	if (dhd) {
-		if (!dhd->pub.hang_was_sent) {
-			dhd->pub.hang_was_sent = 1;
-#if defined(CONFIG_WIRELESS_EXT)
-			ret = wl_iw_send_priv_event(dev, "HANG");
+		/* Report FW problem when enabled */
+		if (dhd->pub.hang_report) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
+			ret = dhd_os_send_hang_message(&dhd->pub);
+#else
+			ret = wl_cfg80211_hang(dev, WLAN_REASON_UNSPECIFIED);
 #endif
-#if defined(WL_CFG80211)
+		} else if(!dhd->pub.hang_was_sent) {
+			printf("%s: execute dhd_os_send_hang_message\n",__func__);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
+			ret = dhd_os_send_hang_message(&dhd->pub);
+#else
 			ret = wl_cfg80211_hang(dev, WLAN_REASON_UNSPECIFIED);
-			dev_close(dev);
-			dev_open(dev);
 #endif
+		} else {
+			DHD_ERROR(("%s: FW HANG ignored (for testing purpose) and not sent up\n",
+				__FUNCTION__));
+			/* Enforce bus down to stop any future traffic */
+			dhd->pub.busstate = DHD_BUS_DOWN;
 		}
 	}
 	return ret;
 }
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27) && OEM_ANDROID */
 
-void dhd_bus_country_set(struct net_device *dev, wl_country_t *cspec)
+void dhd_bus_country_set(struct net_device *dev, wl_country_t *cspec, bool notify)
 {
 	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
+	if (dhd && dhd->pub.up) {
+		memcpy(&dhd->pub.dhd_cspec, cspec, sizeof(wl_country_t));
+#ifdef WL_CFG80211
+		wl_update_wiphybands(NULL, notify);
+#endif
+	}
+}
 
-	if (dhd && dhd->pub.up)
-			memcpy(&dhd->pub.dhd_cspec, cspec, sizeof(wl_country_t));
+void dhd_bus_band_set(struct net_device *dev, uint band)
+{
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
+	if (dhd && dhd->pub.up) {
+#ifdef WL_CFG80211
+		wl_update_wiphybands(NULL, true);
+#endif
+	}
 }
 
 void dhd_net_if_lock(struct net_device *dev)
@@ -4580,6 +5594,24 @@ static void dhd_net_if_unlock_local(dhd_info_t *dhd)
 #endif
 }
 
+static void dhd_suspend_lock(dhd_pub_t *pub)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
+	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
+	if (dhd)
+		mutex_lock(&dhd->dhd_suspend_mutex);
+#endif
+}
+
+static void dhd_suspend_unlock(dhd_pub_t *pub)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
+	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
+	if (dhd)
+		mutex_unlock(&dhd->dhd_suspend_mutex);
+#endif
+}
+
 unsigned long dhd_os_spin_lock(dhd_pub_t *pub)
 {
 	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
@@ -4605,13 +5637,13 @@ dhd_get_pend_8021x_cnt(dhd_info_t *dhd)
 	return (atomic_read(&dhd->pend_8021x_cnt));
 }
 
-#define MAX_WAIT_FOR_8021X_TX	10
+#define MAX_WAIT_FOR_8021X_TX	50
 
 int
 dhd_wait_pend8021x(struct net_device *dev)
 {
 	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
-	int timeout = 10 * HZ / 1000;
+	int timeout = msecs_to_jiffies(10);
 	int ntimes = MAX_WAIT_FOR_8021X_TX;
 	int pend = dhd_get_pend_8021x_cnt(dhd);
 
@@ -4624,6 +5656,10 @@ dhd_wait_pend8021x(struct net_device *dev)
 		}
 		pend = dhd_get_pend_8021x_cnt(dhd);
 	}
+	if (ntimes == 0)
+		DHD_ERROR(("%s: TIMEOUT\n", __FUNCTION__));
+//broadcom patch for reset pend_8021x_cnt when 802.1x timeout
+		atomic_set(&dhd->pend_8021x_cnt, 0);
 	return pend;
 }
 
@@ -4672,13 +5708,18 @@ int dhd_os_wake_lock_timeout(dhd_pub_t *pub)
 
 	if (dhd) {
 		spin_lock_irqsave(&dhd->wakelock_spinlock, flags);
-		ret = dhd->wakelock_timeout_enable;
+		ret = dhd->wakelock_rx_timeout_enable > dhd->wakelock_ctrl_timeout_enable ?
+			dhd->wakelock_rx_timeout_enable : dhd->wakelock_ctrl_timeout_enable;
 #ifdef CONFIG_HAS_WAKELOCK
-		if (dhd->wakelock_timeout_enable)
+		if (dhd->wakelock_rx_timeout_enable)
 			wake_lock_timeout(&dhd->wl_rxwake,
-				msecs_to_jiffies(dhd->wakelock_timeout_enable));
+				msecs_to_jiffies(dhd->wakelock_rx_timeout_enable));
+		if (dhd->wakelock_ctrl_timeout_enable)
+			wake_lock_timeout(&dhd->wl_ctrlwake,
+				msecs_to_jiffies(dhd->wakelock_ctrl_timeout_enable));
 #endif
-		dhd->wakelock_timeout_enable = 0;
+		dhd->wakelock_rx_timeout_enable = 0;
+		dhd->wakelock_ctrl_timeout_enable = 0;
 		spin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);
 	}
 	return ret;
@@ -4694,27 +5735,51 @@ int net_os_wake_lock_timeout(struct net_device *dev)
 	return ret;
 }
 
-int dhd_os_wake_lock_timeout_enable(dhd_pub_t *pub, int val)
+int dhd_os_wake_lock_rx_timeout_enable(dhd_pub_t *pub, int val)
+{
+	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
+	unsigned long flags;
+
+	if (dhd) {
+		spin_lock_irqsave(&dhd->wakelock_spinlock, flags);
+		if (val > dhd->wakelock_rx_timeout_enable)
+			dhd->wakelock_rx_timeout_enable = val;
+		spin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);
+	}
+	return 0;
+}
+
+int dhd_os_wake_lock_ctrl_timeout_enable(dhd_pub_t *pub, int val)
 {
 	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
 	unsigned long flags;
 
 	if (dhd) {
 		spin_lock_irqsave(&dhd->wakelock_spinlock, flags);
-		if (val > dhd->wakelock_timeout_enable)
-			dhd->wakelock_timeout_enable = val;
+		if (val > dhd->wakelock_ctrl_timeout_enable)
+			dhd->wakelock_ctrl_timeout_enable = val;
 		spin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);
 	}
 	return 0;
 }
 
-int net_os_wake_lock_timeout_enable(struct net_device *dev, int val)
+int net_os_wake_lock_rx_timeout_enable(struct net_device *dev, int val)
+{
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
+	int ret = 0;
+
+	if (dhd)
+		ret = dhd_os_wake_lock_rx_timeout_enable(&dhd->pub, val);
+	return ret;
+}
+
+int net_os_wake_lock_ctrl_timeout_enable(struct net_device *dev, int val)
 {
 	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
 	int ret = 0;
 
 	if (dhd)
-		ret = dhd_os_wake_lock_timeout_enable(&dhd->pub, val);
+		ret = dhd_os_wake_lock_ctrl_timeout_enable(&dhd->pub, val);
 	return ret;
 }
 
@@ -4729,6 +5794,9 @@ int dhd_os_wake_lock(dhd_pub_t *pub)
 #ifdef CONFIG_HAS_WAKELOCK
 		if (!dhd->wakelock_counter)
 			wake_lock(&dhd->wl_wifi);
+#elif 1 && (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 36))
+		if (pm_dev)
+			pm_stay_awake(pm_dev);
 #endif
 		dhd->wakelock_counter++;
 		ret = dhd->wakelock_counter;
@@ -4761,6 +5829,9 @@ int dhd_os_wake_unlock(dhd_pub_t *pub)
 #ifdef CONFIG_HAS_WAKELOCK
 			if (!dhd->wakelock_counter)
 				wake_unlock(&dhd->wl_wifi);
+#elif 1 && (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 36))
+			if (pm_dev)
+				pm_relax(pm_dev);
 #endif
 			ret = dhd->wakelock_counter;
 		}
@@ -4771,15 +5842,23 @@ int dhd_os_wake_unlock(dhd_pub_t *pub)
 
 int dhd_os_check_wakelock(void *dhdp)
 {
-#ifdef CONFIG_HAS_WAKELOCK
+#if defined(CONFIG_HAS_WAKELOCK) || (1 && (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, \
+	36)))
 	dhd_pub_t *pub = (dhd_pub_t *)dhdp;
 	dhd_info_t *dhd;
 
 	if (!pub)
 		return 0;
 	dhd = (dhd_info_t *)(pub->info);
+#endif /* CONFIG_HAS_WAKELOCK || BCMSDIO */
 
-	if (dhd && wake_lock_active(&dhd->wl_wifi))
+#ifdef CONFIG_HAS_WAKELOCK
+	/* Indicate to the SD Host to avoid going to suspend if internal locks are up */
+	if (dhd && (wake_lock_active(&dhd->wl_wifi) ||
+		(wake_lock_active(&dhd->wl_wdwake))))
+		return 1;
+#elif 1 && (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 36))
+	if (dhd && (dhd->wakelock_counter > 0) && pm_dev)
 		return 1;
 #endif
 	return 0;
@@ -4794,6 +5873,45 @@ int net_os_wake_unlock(struct net_device *dev)
 	return ret;
 }
 
+int dhd_os_wd_wake_lock(dhd_pub_t *pub)
+{
+	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
+	unsigned long flags;
+	int ret = 0;
+
+	if (dhd) {
+		spin_lock_irqsave(&dhd->wakelock_spinlock, flags);
+#ifdef CONFIG_HAS_WAKELOCK
+		/* if wakelock_wd_counter was never used : lock it at once */
+		if (!dhd->wakelock_wd_counter)
+			wake_lock(&dhd->wl_wdwake);
+#endif
+		dhd->wakelock_wd_counter++;
+		ret = dhd->wakelock_wd_counter;
+		spin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);
+	}
+	return ret;
+}
+
+int dhd_os_wd_wake_unlock(dhd_pub_t *pub)
+{
+	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
+	unsigned long flags;
+	int ret = 0;
+
+	if (dhd) {
+		spin_lock_irqsave(&dhd->wakelock_spinlock, flags);
+		if (dhd->wakelock_wd_counter) {
+
+			dhd->wakelock_wd_counter = 0;
+#ifdef CONFIG_HAS_WAKELOCK
+			wake_unlock(&dhd->wl_wdwake);
+#endif
+		}
+		spin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);
+	}
+	return ret;
+}
 int dhd_os_check_if_up(void *dhdp)
 {
 	dhd_pub_t *pub = (dhd_pub_t *)dhdp;
@@ -4802,6 +5920,21 @@ int dhd_os_check_if_up(void *dhdp)
 		return 0;
 	return pub->up;
 }
+/* function to collect firmware, chip id and chip version info */
+void dhd_set_version_info(dhd_pub_t *dhdp, char *fw)
+{
+	int i;
+
+	i = snprintf(info_string, sizeof(info_string),
+		"  Driver: %s\n  Firmware: %s ", EPI_VERSION_STR, fw);
+
+	if (!dhdp)
+		return;
+
+	i = snprintf(&info_string[i], sizeof(info_string) - i,
+		"\n  Chip: %x Rev %x Pkg %x", dhd_bus_chip_id(dhdp),
+		dhd_bus_chiprev_id(dhdp), dhd_bus_chippkg_id(dhdp));
+}
 int dhd_ioctl_entry_local(struct net_device *net, wl_ioctl_t *ioc, int cmd)
 {
 	int ifidx;
@@ -4814,6 +5947,9 @@ int dhd_ioctl_entry_local(struct net_device *net, wl_ioctl_t *ioc, int cmd)
 	}
 
 	dhd = *(dhd_info_t **)netdev_priv(net);
+	if (!dhd)
+		return -EINVAL;
+
 	ifidx = dhd_net2idx(dhd, net);
 	if (ifidx == DHD_BAD_IF) {
 		DHD_ERROR(("%s bad ifidx\n", __FUNCTION__));
@@ -4836,6 +5972,7 @@ bool dhd_os_check_hang(dhd_pub_t *dhdp, int ifidx, int ret)
 	return dhd_check_hang(net, dhdp, ret);
 }
 
+
 #ifdef PROP_TXSTATUS
 extern int dhd_wlfc_interface_entry_update(void* state,	ewlfc_mac_entry_action_t action, uint8 ifid,
 	uint8 iftype, uint8* ea);
@@ -4862,6 +5999,29 @@ int dhd_wlfc_event(struct dhd_info *dhd)
 {
 	return dhd_wlfc_enable(&dhd->pub);
 }
+
+void dhd_wlfc_plat_enable(void *dhd)
+{
+	return;
+}
+
+void dhd_wlfc_plat_deinit(void *dhd)
+{
+	return;
+}
+
+bool dhd_wlfc_skip_fc(void)
+{
+
+#ifdef WL_CFG80211
+	extern struct wl_priv *wlcfg_drv_priv;
+
+	/* enable flow control in vsdb mode */
+	return !(wlcfg_drv_priv && wlcfg_drv_priv->vsdb_mode);
+#else
+	return TRUE; /* skip flow control */
+#endif /* WL_CFG80211 */
+}
 #endif /* PROP_TXSTATUS */
 
 #ifdef BCMDBGFS
@@ -5224,7 +6384,8 @@ dhd_ioctl_htsf_get(dhd_info_t *dhd, int ifidx)
 	ioc.len = (uint)sizeof(buf);
 	ioc.set = FALSE;
 
-	strcpy(buf, "tsf");
+	strncpy(buf, "tsf", sizeof(buf) - 1);
+	buf[sizeof(buf) - 1] = '\0';
 	s1 = dhd_get_htsf(dhd, 0);
 	if ((ret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len)) < 0) {
 		if (ret == -EIO) {
diff --git a/drivers/net/wireless/bcmdhd/dhd_linux_sched.c b/drivers/net/wireless/bcmdhd/dhd_linux_sched.c
old mode 100644
new mode 100755
index 290caf7..4a84d37
--- a/drivers/net/wireless/bcmdhd/dhd_linux_sched.c
+++ b/drivers/net/wireless/bcmdhd/dhd_linux_sched.c
@@ -1,25 +1,7 @@
 /*
  * Expose some of the kernel scheduler routines
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * $Id: dhd_linux_sched.c 291086 2011-10-21 01:17:24Z $
  */
diff --git a/drivers/net/wireless/bcmdhd/dhd_proto.h b/drivers/net/wireless/bcmdhd/dhd_proto.h
old mode 100644
new mode 100755
index e420166..b54ab1a
--- a/drivers/net/wireless/bcmdhd/dhd_proto.h
+++ b/drivers/net/wireless/bcmdhd/dhd_proto.h
@@ -4,27 +4,9 @@
  * Provides type definitions and function prototypes used to link the
  * DHD OS, bus, and protocol modules.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: dhd_proto.h 303834 2011-12-20 06:17:39Z $
+ * $Id: dhd_proto.h 390836 2013-03-13 23:43:53Z $
  */
 
 #ifndef _dhd_proto_h_
@@ -34,7 +16,7 @@
 #include <wlioctl.h>
 
 #ifndef IOCTL_RESP_TIMEOUT
-#define IOCTL_RESP_TIMEOUT  20000 /* In milli second */
+#define IOCTL_RESP_TIMEOUT  2000  /* In milli second default value for Production FW */
 #endif /* IOCTL_RESP_TIMEOUT */
 
 /*
@@ -83,12 +65,6 @@ extern int dhd_ioctl(dhd_pub_t * dhd_pub, dhd_ioctl_t *ioc, void * buf, uint buf
 
 extern int dhd_preinit_ioctls(dhd_pub_t *dhd);
 
-#ifdef PROP_TXSTATUS
-extern int dhd_wlfc_enque_sendq(void* state, int prec, void* p);
-extern int dhd_wlfc_commit_packets(void* state, f_commitpkt_t fcommit, void* commit_ctx);
-extern void dhd_wlfc_cleanup(dhd_pub_t *dhd);
-#endif /* PROP_TXSTATUS */
-
 extern int dhd_process_pkt_reorder_info(dhd_pub_t *dhd, uchar *reorder_info_buf,
 	uint reorder_info_len, void **pkt, uint32 *free_buf_count);
 
@@ -100,8 +76,6 @@ extern int dhd_process_pkt_reorder_info(dhd_pub_t *dhd, uchar *reorder_info_buf,
 #define DHD_PROTOCOL "bdc"
 #elif defined(CDC)
 #define DHD_PROTOCOL "cdc"
-#elif defined(RNDIS)
-#define DHD_PROTOCOL "rndis"
 #else
 #define DHD_PROTOCOL "unknown"
 #endif /* proto */
diff --git a/drivers/net/wireless/bcmdhd/dhd_sdio.c b/drivers/net/wireless/bcmdhd/dhd_sdio.c
old mode 100644
new mode 100755
index 0ec95d2..7ce8538
--- a/drivers/net/wireless/bcmdhd/dhd_sdio.c
+++ b/drivers/net/wireless/bcmdhd/dhd_sdio.c
@@ -1,27 +1,9 @@
 /*
  * DHD Bus Module for SDIO
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: dhd_sdio.c 329638 2012-04-26 05:41:43Z $
+ * $Id: dhd_sdio.c 394696 2013-04-03 09:41:06Z $
  */
 
 #include <typedefs.h>
@@ -66,6 +48,11 @@
 #include <dhdioctl.h>
 #include <sdiovar.h>
 
+bool dhd_mp_halting(dhd_pub_t *dhdp);
+extern void bcmsdh_waitfor_iodrain(void *sdh);
+extern void bcmsdh_reject_ioreqs(void *sdh, bool reject);
+extern bool  bcmsdh_fatal_error(void *sdh);
+
 #ifndef DHDSDIO_MEM_DUMP_FNAME
 #define DHDSDIO_MEM_DUMP_FNAME         "mem_dump"
 #endif
@@ -76,10 +63,13 @@
 #define PRIOMASK	7
 
 #define TXRETRIES	2	/* # of retries for tx frames */
-
+#ifndef DHD_RXBOUND
 #define DHD_RXBOUND	50	/* Default for max rx frames in one scheduling */
+#endif
 
+#ifndef DHD_TXBOUND
 #define DHD_TXBOUND	20	/* Default for max tx frames in one scheduling */
+#endif
 
 #define DHD_TXMINMAX	1	/* Max tx frames if rx still pending */
 
@@ -94,8 +84,17 @@
 #error DHD_FIRSTREAD is not a power of 2!
 #endif
 
-/* Total length of frame header for dongle protocol */
+#ifdef BCMSDIOH_TXGLOM
+/* Total length of TX frame header for dongle protocol */
+#define SDPCM_HDRLEN	(SDPCM_FRAMETAG_LEN + SDPCM_HWEXT_LEN + SDPCM_SWHEADER_LEN)
+/* Total length of RX frame for dongle protocol */
+#else
+/* Total length of TX frame header for dongle protocol */
 #define SDPCM_HDRLEN	(SDPCM_FRAMETAG_LEN + SDPCM_SWHEADER_LEN)
+#endif
+
+#define SDPCM_HDRLEN_RX	(SDPCM_FRAMETAG_LEN + SDPCM_SWHEADER_LEN)
+
 #ifdef SDTEST
 #define SDPCM_RESERVE	(SDPCM_HDRLEN + SDPCM_TEST_HDRLEN + DHD_SDALIGN)
 #else
@@ -140,11 +139,18 @@
 DHD_SPINWAIT_SLEEP_INIT(sdioh_spinwait_sleep);
 #if defined(OOB_INTR_ONLY)
 extern void bcmsdh_set_irq(int flag);
-#endif /* defined(OOB_INTR_ONLY) */
+#endif 
 #ifdef PROP_TXSTATUS
 extern void dhd_wlfc_txcomplete(dhd_pub_t *dhd, void *txp, bool success);
+extern void dhd_wlfc_trigger_pktcommit(dhd_pub_t *dhd);
 #endif
 
+#if defined(MULTIPLE_SUPPLICANT)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25))
+DEFINE_MUTEX(_dhd_sdio_mutex_lock_);
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) */
+#endif /* LINUX */
+
 #ifdef DHD_DEBUG
 /* Device console log buffer state */
 #define CONSOLE_LINE_MAX	192
@@ -168,14 +174,19 @@ typedef struct dhd_console {
 #define	MIN_RSRC_SR			0x3
 #define	CORE_CAPEXT_ADDR		(SI_ENUM_BASE + 0x64c)
 #define	CORE_CAPEXT_SR_SUPPORTED_MASK	(1 << 1)
+#define RCTL_MACPHY_DISABLE_MASK	(1 << 26)
+#define RCTL_LOGIC_DISABLE_MASK		(1 << 27)
 
 #define	OOB_WAKEUP_ENAB(bus)		((bus)->_oobwakeup)
 #define	GPIO_DEV_SRSTATE		16	/* Host gpio17 mapped to device gpio0 SR state */
 #define	GPIO_DEV_SRSTATE_TIMEOUT	320000	/* 320ms */
 #define	GPIO_DEV_WAKEUP			17	/* Host gpio17 mapped to device gpio1 wakeup */
 #define	CC_CHIPCTRL2_GPIO1_WAKEUP	(1  << 0)
+#define	CC_CHIPCTRL3_SR_ENG_ENABLE	(1  << 2)
+#define OVERFLOW_BLKSZ512_WM		48
+#define OVERFLOW_BLKSZ512_MES		80
 
-
+#define CC_PMUCC3	(0x3)
 /* Private data for SDIO bus interaction */
 typedef struct dhd_bus {
 	dhd_pub_t	*dhd;
@@ -287,6 +298,13 @@ typedef struct dhd_bus {
 	uint		pktgen_ptick;		/* Burst counter for printing */
 	uint		pktgen_sent;		/* Number of test packets generated */
 	uint		pktgen_rcvd;		/* Number of test packets received */
+	uint		pktgen_prev_time;	/* Time at which previous stats where printed */
+	uint		pktgen_prev_sent;	/* Number of test packets generated when
+						 * previous stats were printed
+						 */
+	uint		pktgen_prev_rcvd;	/* Number of test packets received when
+						 * previous stats were printed
+						 */
 	uint		pktgen_fail;		/* Number of failed send attempts */
 	uint16		pktgen_len;		/* Length of next packet to send */
 #define PKTGEN_RCV_IDLE     (0)
@@ -329,6 +347,16 @@ typedef struct dhd_bus {
 	bool		_srenab;
 	bool        readframes;
 	bool        reqbussleep;
+	uint32		resetinstr;
+	uint32		dongle_ram_base;
+#ifdef BCMSDIOH_TXGLOM
+	void		*glom_pkt_arr[SDPCM_MAXGLOM_SIZE];	/* Array of pkts for glomming */
+	uint16		glom_cnt;	/* Number of pkts in the glom array */
+	uint16		glom_total_len;	/* Total length of pkts in glom array */
+	bool		glom_enable;	/* Flag to indicate whether tx glom is enabled/disabled */
+	uint8		glom_mode;	/* Glom mode - 0-copy mode, 1 - Multi-descriptor mode */
+	uint32		glomsize;	/* Glom size limitation */
+#endif
 } dhd_bus_t;
 
 /* clkstate */
@@ -348,6 +376,7 @@ static int tx_packets[NUMPRIO];
 const uint dhd_deferred_tx = 1;
 
 extern uint dhd_watchdog_ms;
+
 extern void dhd_os_wd_timer(void *bus, uint wdtick);
 
 /* Tx/Rx bounds */
@@ -356,10 +385,15 @@ uint dhd_rxbound;
 uint dhd_txminmax = DHD_TXMINMAX;
 
 /* override the RAM size if possible */
-#define DONGLE_MIN_MEMSIZE (128 *1024)
-int dhd_dongle_memsize;
+#define DONGLE_MIN_RAMSIZE (128 *1024)
+int dhd_dongle_ramsize;
+
+uint dhd_doflow = TRUE;
+uint dhd_dpcpoll = FALSE;
+
+module_param(dhd_doflow, uint, 0644);
+module_param(dhd_dpcpoll, uint, 0644);
 
-static bool dhd_doflow;
 static bool dhd_alignctl;
 
 static bool sd1idle;
@@ -367,8 +401,13 @@ static bool sd1idle;
 static bool retrydata;
 #define RETRYCHAN(chan) (((chan) == SDPCM_EVENT_CHANNEL) || retrydata)
 
+#if defined(SDIO_CRC_ERROR_FIX)
+static uint watermark = 48;
+static uint mesbusyctrl = 80;
+#else
 static const uint watermark = 8;
 static const uint mesbusyctrl = 0;
+#endif 
 static const uint firstread = DHD_FIRSTREAD;
 
 #define HDATLEN (firstread - (SDPCM_HDRLEN))
@@ -379,9 +418,6 @@ static const uint retry_limit = 2;
 /* Force even SD lengths (some host controllers mess up on odd bytes) */
 static bool forcealign;
 
-/* Flag to indicate if we should download firmware on driver load */
-uint dhd_download_fw_on_driverload = TRUE;
-
 #define ALIGNMENT  4
 
 #if defined(OOB_INTR_ONLY) && defined(HW_OOB)
@@ -409,7 +445,6 @@ static const uint max_roundup = 512;
 /* Try doing readahead */
 static bool dhd_readahead;
 
-
 /* To check if there's window offered */
 #define DATAOK(bus) \
 	(((uint8)(bus->tx_max - bus->tx_seq) > 1) && \
@@ -420,6 +455,10 @@ static bool dhd_readahead;
 	(((uint8)(bus->tx_max - bus->tx_seq) != 0) && \
 	(((uint8)(bus->tx_max - bus->tx_seq) & 0x80) == 0))
 
+/* Number of pkts available in dongle for data RX */
+#define DATABUFCNT(bus) \
+	((uint8)(bus->tx_max - bus->tx_seq) - 1)
+
 /* Macros to get register read/write status */
 /* NOTE: these assume a local dhdsdio_bus_t *bus! */
 #define R_SDREG(regvar, regaddr, retryvar) \
@@ -454,6 +493,7 @@ do { \
 
 #define BUS_WAKE(bus) \
 	do { \
+		bus->idlecount = 0; \
 		if ((bus)->sleeping) \
 			dhdsdio_bussleep((bus), FALSE); \
 	} while (0);
@@ -493,7 +533,7 @@ do { \
 
 #ifdef SDTEST
 static void dhdsdio_testrcv(dhd_bus_t *bus, void *pkt, uint seq);
-static void dhdsdio_sdtest_set(dhd_bus_t *bus, uint8 count);
+static void dhdsdio_sdtest_set(dhd_bus_t *bus, uint count);
 #endif
 
 #ifdef DHD_DEBUG
@@ -515,13 +555,17 @@ static bool dhdsdio_probe_init(dhd_bus_t *bus, osl_t *osh, void *sdh);
 static void dhdsdio_release_dongle(dhd_bus_t *bus, osl_t *osh, bool dongle_isolation,
 	bool reset_flag);
 
-static void dhd_dongle_setmemsize(struct dhd_bus *bus, int mem_size);
+static void dhd_dongle_setramsize(struct dhd_bus *bus, int mem_size);
 static int dhd_bcmsdh_recv_buf(dhd_bus_t *bus, uint32 addr, uint fn, uint flags,
 	uint8 *buf, uint nbytes,
 	void *pkt, bcmsdh_cmplt_fn_t complete, void *handle);
 static int dhd_bcmsdh_send_buf(dhd_bus_t *bus, uint32 addr, uint fn, uint flags,
 	uint8 *buf, uint nbytes,
 	void *pkt, bcmsdh_cmplt_fn_t complete, void *handle);
+#ifdef BCMSDIOH_TXGLOM
+static void dhd_bcmsdh_glom_post(dhd_bus_t *bus, uint8 *frame, void *pkt, uint len);
+static void dhd_bcmsdh_glom_clear(dhd_bus_t *bus);
+#endif
 
 static bool dhdsdio_download_firmware(dhd_bus_t *bus, osl_t *osh, void *sdh);
 static int _dhdsdio_download_firmware(dhd_bus_t *bus);
@@ -541,15 +585,48 @@ extern uint32 dhd_get_htsf(void *dhd, int ifidx);
 #endif /* WLMEDIA_HTSF */
 
 static void
-dhd_dongle_setmemsize(struct dhd_bus *bus, int mem_size)
+dhd_overflow_war(struct dhd_bus *bus)
 {
-	int32 min_size =  DONGLE_MIN_MEMSIZE;
-	/* Restrict the memsize to user specified limit */
+	int err;
+	uint8 devctl, wm, mes;
+
+	/* See .ppt in PR for these recommended values */
+	if (bus->blocksize == 512) {
+		wm = OVERFLOW_BLKSZ512_WM;
+		mes = OVERFLOW_BLKSZ512_MES;
+	} else {
+		mes = bus->blocksize/4;
+		wm = bus->blocksize/4;
+	}
+
+
+	/* Update watermark */
+	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_WATERMARK, wm, &err);
+
+	devctl = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, &err);
+	devctl |= SBSDIO_DEVCTL_F2WM_ENAB;
+	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, devctl, &err);
+
+	/* Update MES */
+	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_MESBUSYCTRL,
+		(mes | SBSDIO_MESBUSYCTRL_ENAB), &err);
+
+	DHD_INFO(("Apply overflow WAR: 0x%02x 0x%02x 0x%02x\n",
+		bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, &err),
+		bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_WATERMARK, &err),
+		bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_MESBUSYCTRL, &err)));
+}
+
+static void
+dhd_dongle_setramsize(struct dhd_bus *bus, int mem_size)
+{
+	int32 min_size =  DONGLE_MIN_RAMSIZE;
+	/* Restrict the ramsize to user specified limit */
 	DHD_ERROR(("user: Restrict the dongle ram size to %d, min accepted %d\n",
-		dhd_dongle_memsize, min_size));
-	if ((dhd_dongle_memsize > min_size) &&
-		(dhd_dongle_memsize < (int32)bus->orig_ramsize))
-		bus->ramsize = dhd_dongle_memsize;
+		dhd_dongle_ramsize, min_size));
+	if ((dhd_dongle_ramsize > min_size) &&
+		(dhd_dongle_ramsize < (int32)bus->orig_ramsize))
+		bus->ramsize = dhd_dongle_ramsize;
 }
 
 static int
@@ -598,12 +675,20 @@ static bool
 dhdsdio_sr_cap(dhd_bus_t *bus)
 {
 	bool cap = FALSE;
-	uint32 min = 0, core_capext, addr, data;
+	uint32  core_capext, addr, data;
 	if (bus->sih->chip == BCM4324_CHIP_ID) {
 			addr = SI_ENUM_BASE + OFFSETOF(chipcregs_t, chipcontrol_addr);
 			data = SI_ENUM_BASE + OFFSETOF(chipcregs_t, chipcontrol_data);
 			bcmsdh_reg_write(bus->sdh, addr, 4, 3);
 			core_capext = bcmsdh_reg_read(bus->sdh, data, 4);
+	} else if (bus->sih->chip == BCM4330_CHIP_ID) {
+			core_capext = FALSE;
+	} else if ((bus->sih->chip == BCM4335_CHIP_ID) ||
+		(bus->sih->chip == BCM4339_CHIP_ID) ||
+		(bus->sih->chip == BCM4350_CHIP_ID)) {
+		core_capext = TRUE;
+	} else if (bus->sih->chip == BCM43362_CHIP_ID) {
+		core_capext = FALSE;
 	} else {
 			core_capext = bcmsdh_reg_read(bus->sdh, CORE_CAPEXT_ADDR, 4);
 			core_capext = (core_capext & CORE_CAPEXT_SR_SUPPORTED_MASK);
@@ -611,16 +696,30 @@ dhdsdio_sr_cap(dhd_bus_t *bus)
 	if (!(core_capext))
 		return FALSE;
 
-	min = bcmsdh_reg_read(bus->sdh, MIN_RSRC_ADDR, 4);
-	if (min == MIN_RSRC_SR) {
+	if (bus->sih->chip == BCM4324_CHIP_ID) {
+		/* FIX: Should change to query SR control register instead */
 		cap = TRUE;
-
-		if ((bus->sih->chip == BCM4334_CHIP_ID) && (bus->sih->chiprev < 3)) {
-			cap = FALSE;
-
-			DHD_ERROR(("Only 4334 >= B2 supports SR: curr rev %d\n",
-				bus->sih->chiprev));
-		}
+	} else if ((bus->sih->chip == BCM4335_CHIP_ID) ||
+		(bus->sih->chip == BCM4339_CHIP_ID) ||
+		(bus->sih->chip == BCM4350_CHIP_ID)) {
+		uint32 enabval = 0;
+		addr = SI_ENUM_BASE + OFFSETOF(chipcregs_t, chipcontrol_addr);
+		data = SI_ENUM_BASE + OFFSETOF(chipcregs_t, chipcontrol_data);
+		bcmsdh_reg_write(bus->sdh, addr, 4, CC_PMUCC3);
+		enabval = bcmsdh_reg_read(bus->sdh, data, 4);
+
+		if ((bus->sih->chip == BCM4350_CHIP_ID) ||
+			0)
+				enabval &= CC_CHIPCTRL3_SR_ENG_ENABLE;
+
+
+		if (enabval)
+			cap = TRUE;
+	} else {
+		data = bcmsdh_reg_read(bus->sdh,
+			SI_ENUM_BASE + OFFSETOF(chipcregs_t, retention_ctl), 4);
+		if ((data & (RCTL_MACPHY_DISABLE_MASK | RCTL_LOGIC_DISABLE_MASK)) == 0)
+			cap = TRUE;
 	}
 
 	return cap;
@@ -629,7 +728,6 @@ dhdsdio_sr_cap(dhd_bus_t *bus)
 static int
 dhdsdio_srwar_init(dhd_bus_t *bus)
 {
-
 	bcmsdh_gpio_init(bus->sdh);
 
 #ifdef USE_OOB_GPIO1
@@ -697,18 +795,53 @@ dhdsdio_clk_kso_init(dhd_bus_t *bus)
 	return 0;
 }
 
+#define KSO_DBG(x)
+#define KSO_WAIT_US 50
+#define MAX_KSO_ATTEMPTS 25 //(PMU_MAX_TRANSITION_DLY/KSO_WAIT_US)
 static int
 dhdsdio_clk_kso_enab(dhd_bus_t *bus, bool on)
 {
-	uint8 val = 0;
+	uint8 wr_val = 0, rd_val, cmp_val, bmask;
 	int err = 0;
+	int try_cnt = 0;
 
-	/* Don't read here since sdio could be off so just write only */
-	val |= (on << SBSDIO_FUNC1_SLEEPCSR_KSO_SHIFT);
-	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SLEEPCSR, val, &err);
+	KSO_DBG(("%s> op:%s\n", __FUNCTION__, (on ? "KSO_SET" : "KSO_CLR")));
 
-	if (err)
-		DHD_TRACE(("%s: KSO toggle %d failed: %d\n", __FUNCTION__, on, err));
+	wr_val |= (on << SBSDIO_FUNC1_SLEEPCSR_KSO_SHIFT);
+
+	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SLEEPCSR, wr_val, &err);
+
+	if (on) {
+		cmp_val = SBSDIO_FUNC1_SLEEPCSR_KSO_MASK |  SBSDIO_FUNC1_SLEEPCSR_DEVON_MASK;
+		bmask = cmp_val;
+
+		msleep(3);
+	} else {
+		/* Put device to sleep, turn off  KSO  */
+		cmp_val = 0;
+		bmask = SBSDIO_FUNC1_SLEEPCSR_KSO_MASK;
+	}
+
+	do {
+		rd_val = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SLEEPCSR, &err);
+		if (((rd_val & bmask) == cmp_val) && !err)
+			break;
+
+		KSO_DBG(("%s> KSO wr/rd retry:%d, ERR:%x \n", __FUNCTION__, try_cnt, err));
+		OSL_DELAY(KSO_WAIT_US);
+
+		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SLEEPCSR, wr_val, &err);
+	} while (try_cnt++ < MAX_KSO_ATTEMPTS);
+
+
+	if (try_cnt > 2)
+		KSO_DBG(("%s> op:%s, try_cnt:%d, rd_val:%x, ERR:%x \n",
+			__FUNCTION__, (on ? "KSO_SET" : "KSO_CLR"), try_cnt, rd_val, err));
+
+	if (try_cnt > MAX_KSO_ATTEMPTS)  {
+		DHD_ERROR(("%s> op:%s, ERROR: try_cnt:%d, rd_val:%x, ERR:%x \n",
+			__FUNCTION__, (on ? "KSO_SET" : "KSO_CLR"), try_cnt, rd_val, err));
+	}
 	return err;
 }
 
@@ -735,16 +868,7 @@ dhdsdio_clk_kso_iovar(dhd_bus_t *bus, bool on)
 			dhdsdio_clkctl(bus, CLK_SDONLY, FALSE);
 		}
 
-		/* Double-write to be safe in case transition of AOS */
 		dhdsdio_clk_kso_enab(bus, TRUE);
-		dhdsdio_clk_kso_enab(bus, TRUE);
-		OSL_DELAY(4000);
-
-		/* Wait for device ready during transition to wake-up */
-		SPINWAIT(((dhdsdio_sleepcsr_get(bus)) !=
-			(SBSDIO_FUNC1_SLEEPCSR_KSO_MASK |
-			SBSDIO_FUNC1_SLEEPCSR_DEVON_MASK)),
-			(10000));
 
 		DHD_ERROR(("%s: sleepcsr: 0x%x\n", __FUNCTION__,
 			dhdsdio_sleepcsr_get(bus)));
@@ -826,8 +950,10 @@ dhdsdio_clk_devsleep_iovar(dhd_bus_t *bus, bool on)
 #else
 		err = dhdsdio_clk_kso_enab(bus, FALSE);
 		if (OOB_WAKEUP_ENAB(bus))
+		{
 			err = bcmsdh_gpioout(bus->sdh, GPIO_DEV_WAKEUP, FALSE);  /* GPIO_1 is off */
-#endif
+		}
+#endif /* USE_CMD14 */
 	} else {
 		/* Exit Sleep */
 		/* Make sure we have SD bus access */
@@ -873,11 +999,13 @@ dhdsdio_clk_devsleep_iovar(dhd_bus_t *bus, bool on)
 		}
 #else
 		if (OOB_WAKEUP_ENAB(bus))
+		{
 			err = bcmsdh_gpioout(bus->sdh, GPIO_DEV_WAKEUP, TRUE);  /* GPIO_1 is on */
-
+		}
 		do {
 			err = dhdsdio_clk_kso_enab(bus, TRUE);
-			OSL_DELAY(10000);
+			if (err)
+				OSL_DELAY(10000);
 		} while ((err != 0) && (++retry < 3));
 
 		if (err != 0) {
@@ -892,7 +1020,7 @@ dhdsdio_clk_devsleep_iovar(dhd_bus_t *bus, bool on)
 			/* Wait for device ready during transition to wake-up */
 			SPINWAIT((((csr = dhdsdio_sleepcsr_get(bus)) &
 				SBSDIO_FUNC1_SLEEPCSR_DEVON_MASK) !=
-				(SBSDIO_FUNC1_SLEEPCSR_DEVON_MASK)), (10000));
+				(SBSDIO_FUNC1_SLEEPCSR_DEVON_MASK)), (20000));
 
 			DHD_TRACE(("%s: ExitSleep sleepcsr: 0x%x\n", __FUNCTION__, csr));
 
@@ -914,6 +1042,8 @@ dhdsdio_clk_devsleep_iovar(dhd_bus_t *bus, bool on)
 		bus->kso = on ? FALSE : TRUE;
 	else {
 		DHD_ERROR(("%s: Sleep request failed: on:%d err:%d\n", __FUNCTION__, on, err));
+		if (!on && retry > 2)
+			bus->kso = TRUE;
 	}
 
 	return err;
@@ -923,15 +1053,14 @@ dhdsdio_clk_devsleep_iovar(dhd_bus_t *bus, bool on)
 static int
 dhdsdio_htclk(dhd_bus_t *bus, bool on, bool pendok)
 {
+#define HT_AVAIL_ERROR_MAX 10
+	static int ht_avail_error = 0;
 	int err;
 	uint8 clkctl, clkreq, devctl;
 	bcmsdh_info_t *sdh;
 
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
-#if defined(OOB_INTR_ONLY)
-		pendok = FALSE;
-#endif
 	clkctl = 0;
 	sdh = bus->sdh;
 
@@ -943,6 +1072,7 @@ dhdsdio_htclk(dhd_bus_t *bus, bool on, bool pendok)
 		bus->clkstate = (on ? CLK_AVAIL : CLK_SDONLY);
 		return BCME_OK;
 	}
+	on=1;
 
 	if (on) {
 		/* Request HT Avail */
@@ -952,16 +1082,21 @@ dhdsdio_htclk(dhd_bus_t *bus, bool on, bool pendok)
 
 		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, clkreq, &err);
 		if (err) {
-			DHD_ERROR(("%s: HT Avail request error: %d\n", __FUNCTION__, err));
+			ht_avail_error++;
+			if (ht_avail_error < HT_AVAIL_ERROR_MAX) {
+				DHD_ERROR(("%s: HT Avail request error: %d\n", __FUNCTION__, err));
+			}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+			else if (ht_avail_error == HT_AVAIL_ERROR_MAX) {
+				dhd_os_send_hang_message(bus->dhd);
+			}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27) */
 			return BCME_ERROR;
+		} else {
+			ht_avail_error = 0;
 		}
 
-		if (pendok &&
-		    ((bus->sih->buscoretype == PCMCIA_CORE_ID) && (bus->sih->buscorerev == 9))) {
-			uint32 dummy, retries;
-			R_SDREG(dummy, &bus->regs->clockctlstatus, retries);
-			BCM_REFERENCE(dummy);
-		}
 
 		/* Check current status */
 		clkctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, &err);
@@ -970,6 +1105,7 @@ dhdsdio_htclk(dhd_bus_t *bus, bool on, bool pendok)
 			return BCME_ERROR;
 		}
 
+#if !defined(OOB_INTR_ONLY)
 		/* Go to pending and await interrupt if appropriate */
 		if (!SBSDIO_CLKAV(clkctl, bus->alp_only) && pendok) {
 			/* Allow only clock-available interrupt */
@@ -985,11 +1121,15 @@ dhdsdio_htclk(dhd_bus_t *bus, bool on, bool pendok)
 			DHD_INFO(("CLKCTL: set PENDING\n"));
 			bus->clkstate = CLK_PENDING;
 			return BCME_OK;
-		} else if (bus->clkstate == CLK_PENDING) {
-			/* Cancel CA-only interrupt filter */
-			devctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, &err);
-			devctl &= ~SBSDIO_DEVCTL_CA_INT_ONLY;
-			bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, devctl, &err);
+		} else
+#endif /* !defined (OOB_INTR_ONLY) */
+		{
+			if (bus->clkstate == CLK_PENDING) {
+				/* Cancel CA-only interrupt filter */
+				devctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, &err);
+				devctl &= ~SBSDIO_DEVCTL_CA_INT_ONLY;
+				bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, devctl, &err);
+			}
 		}
 
 		/* Otherwise, wait here (polling) for HT Avail */
@@ -1028,8 +1168,12 @@ dhdsdio_htclk(dhd_bus_t *bus, bool on, bool pendok)
 #endif /* defined (DHD_DEBUG) */
 
 		bus->activity = TRUE;
+#ifdef DHD_USE_IDLECOUNT
+		bus->idlecount = 0;
+#endif /* DHD_USE_IDLECOUNT */
 	} else {
 		clkreq = 0;
+
 		if (bus->clkstate == CLK_PENDING) {
 			/* Cancel CA-only interrupt filter */
 			devctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, &err);
@@ -1146,13 +1290,16 @@ dhdsdio_clkctl(dhd_bus_t *bus, uint target, bool pendok)
 	uint oldstate = bus->clkstate;
 #endif /* DHD_DEBUG */
 
-	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
+	DHD_TRACE(("%s: Enter, lock %d\n", __FUNCTION__, target));
 
 	/* Early exit if we're already there */
 	if (bus->clkstate == target) {
 		if (target == CLK_AVAIL) {
 			dhd_os_wd_timer(bus->dhd, dhd_watchdog_ms);
 			bus->activity = TRUE;
+#ifdef DHD_USE_IDLECOUNT
+			bus->idlecount = 0;
+#endif /* DHD_USE_IDLECOUNT */
 		}
 		return ret;
 	}
@@ -1167,6 +1314,9 @@ dhdsdio_clkctl(dhd_bus_t *bus, uint target, bool pendok)
 		if (ret == BCME_OK) {
 			dhd_os_wd_timer(bus->dhd, dhd_watchdog_ms);
 		bus->activity = TRUE;
+#ifdef DHD_USE_IDLECOUNT
+			bus->idlecount = 0;
+#endif /* DHD_USE_IDLECOUNT */
 		}
 		break;
 
@@ -1303,6 +1453,7 @@ dhdsdio_bussleep(dhd_bus_t *bus, bool sleep)
 	return err;
 }
 
+
 #if defined(OOB_INTR_ONLY)
 void
 dhd_enable_oob_intr(struct dhd_bus *bus, bool enable)
@@ -1332,12 +1483,12 @@ dhd_enable_oob_intr(struct dhd_bus *bus, bool enable)
 	dhdsdio_clkctl(bus, CLK_SDONLY, FALSE);
 #endif /* !defined(HW_OOB) */
 }
-#endif /* defined(OOB_INTR_ONLY) */
+#endif 
 
 /* Writes a HW/SW header into the packet and sends it. */
 /* Assumes: (a) header space already there, (b) caller holds lock */
 static int
-dhdsdio_txpkt(dhd_bus_t *bus, void *pkt, uint chan, bool free_pkt)
+dhdsdio_txpkt(dhd_bus_t *bus, void *pkt, uint chan, bool free_pkt, bool queue_only)
 {
 	int ret;
 	osl_t *osh;
@@ -1345,9 +1496,14 @@ dhdsdio_txpkt(dhd_bus_t *bus, void *pkt, uint chan, bool free_pkt)
 	uint16 len, pad1 = 0;
 	uint32 swheader;
 	uint retries = 0;
+	uint32 real_pad = 0;
 	bcmsdh_info_t *sdh;
 	void *new;
 	int i;
+	int pkt_cnt;
+#ifdef BCMSDIOH_TXGLOM
+	uint8 *frame_tmp;
+#endif
 #ifdef WLMEDIA_HTSF
 	char *p;
 	htsfts_t *htsf_ts;
@@ -1359,6 +1515,7 @@ dhdsdio_txpkt(dhd_bus_t *bus, void *pkt, uint chan, bool free_pkt)
 	sdh = bus->sdh;
 	osh = bus->dhd->osh;
 
+
 	if (bus->dhd->dongle_reset) {
 		ret = BCME_NOTREADY;
 		goto done;
@@ -1378,7 +1535,7 @@ dhdsdio_txpkt(dhd_bus_t *bus, void *pkt, uint chan, bool free_pkt)
 #endif /* WLMEDIA_HTSF */
 
 	/* Add alignment padding, allocate new packet if needed */
-	if ((pad1 = ((uintptr)frame % DHD_SDALIGN))) {
+	if (!((uintptr)frame & 1) && (pad1 = ((uintptr)frame % DHD_SDALIGN))) {
 		if (PKTHEADROOM(osh, pkt) < pad1) {
 			DHD_INFO(("%s: insufficient headroom %d for %d pad1\n",
 			          __FUNCTION__, (int)PKTHEADROOM(osh, pkt), pad1));
@@ -1416,6 +1573,101 @@ dhdsdio_txpkt(dhd_bus_t *bus, void *pkt, uint chan, bool free_pkt)
 	*(uint16*)frame = htol16(len);
 	*(((uint16*)frame) + 1) = htol16(~len);
 
+#ifdef BCMSDIOH_TXGLOM
+	if (bus->glom_enable) {
+		uint32 hwheader1 = 0, hwheader2 = 0, act_len = len;
+
+		/* Software tag: channel, sequence number, data offset */
+		swheader = ((chan << SDPCM_CHANNEL_SHIFT) & SDPCM_CHANNEL_MASK) |
+			((bus->tx_seq + bus->glom_cnt) % SDPCM_SEQUENCE_WRAP) |
+		        (((pad1 + SDPCM_HDRLEN) << SDPCM_DOFFSET_SHIFT) & SDPCM_DOFFSET_MASK);
+		htol32_ua_store(swheader, frame + SDPCM_FRAMETAG_LEN + SDPCM_HWEXT_LEN);
+		htol32_ua_store(0, frame + SDPCM_FRAMETAG_LEN + SDPCM_HWEXT_LEN + sizeof(swheader));
+
+		if (queue_only) {
+			uint8 alignment = ALIGNMENT;
+			if (forcealign && (len & (alignment - 1)))
+				len = ROUNDUP(len, alignment);
+			/* Hardware extention tag */
+			/* 2byte frame length, 1byte-, 1byte frame flag,
+			 * 2byte-hdrlength, 2byte padlenght
+			 */
+			hwheader1 = (act_len - SDPCM_FRAMETAG_LEN) | (0 << 24);
+			hwheader2 = (len - act_len) << 16;
+			htol32_ua_store(hwheader1, frame + SDPCM_FRAMETAG_LEN);
+			htol32_ua_store(hwheader2, frame + SDPCM_FRAMETAG_LEN + 4);
+			real_pad = len - act_len;
+			if (PKTTAILROOM(osh, pkt) < real_pad) {
+				DHD_INFO(("%s 1: insufficient tailroom %d for %d real_pad\n",
+				__FUNCTION__, (int)PKTTAILROOM(osh, pkt), real_pad));
+				if (PKTPADTAILROOM(osh, pkt, real_pad)) {
+					DHD_ERROR(("padding error size %d\n", real_pad));
+				}
+			}
+#ifdef BCMLXSDMMC
+			PKTSETLEN(osh, pkt, len);
+#endif /* BCMLXSDMMC */
+			/* Post the frame pointer to sdio glom array */
+			dhd_bcmsdh_glom_post(bus, frame, pkt, len);
+			/* Save the pkt pointer in bus glom array */
+			bus->glom_pkt_arr[bus->glom_cnt] = pkt;
+			bus->glom_total_len += len;
+			bus->glom_cnt++;
+			return BCME_OK;
+		} else {
+				/* Raise len to next SDIO block to eliminate tail command */
+				if (bus->roundup && bus->blocksize &&
+					((bus->glom_total_len + len) > bus->blocksize)) {
+					uint16 pad2 = bus->blocksize -
+						((bus->glom_total_len + len) % bus->blocksize);
+					if ((pad2 <= bus->roundup) && (pad2 < bus->blocksize)) {
+							len += pad2;
+					} else {
+					}
+				} else if ((bus->glom_total_len + len) % DHD_SDALIGN) {
+					len += DHD_SDALIGN
+					    - ((bus->glom_total_len + len) % DHD_SDALIGN);
+				}
+				if (forcealign && (len & (ALIGNMENT - 1))) {
+					len = ROUNDUP(len, ALIGNMENT);
+				}
+
+				/* Hardware extention tag */
+				/* 2byte frame length, 1byte-, 1byte frame flag,
+				 * 2byte-hdrlength, 2byte padlenght
+				 */
+				hwheader1 = (act_len - SDPCM_FRAMETAG_LEN) | (1 << 24);
+				hwheader2 = (len - act_len) << 16;
+				htol32_ua_store(hwheader1, frame + SDPCM_FRAMETAG_LEN);
+				htol32_ua_store(hwheader2, frame + SDPCM_FRAMETAG_LEN + 4);
+				real_pad = len - act_len;
+				if (PKTTAILROOM(osh, pkt) < real_pad) {
+					DHD_INFO(("%s 2: insufficient tailroom %d"
+					" for %d real_pad\n",
+					__FUNCTION__, (int)PKTTAILROOM(osh, pkt), real_pad));
+					if (PKTPADTAILROOM(osh, pkt, real_pad)) {
+						DHD_ERROR(("padding error size %d\n", real_pad));
+					}
+				}
+#ifdef BCMLXSDMMC
+				PKTSETLEN(osh, pkt, len);
+#endif /* BCMLXSDMMC */
+				/* Post the frame pointer to sdio glom array */
+				dhd_bcmsdh_glom_post(bus, frame, pkt, len);
+				/* Save the pkt pointer in bus glom array */
+				bus->glom_pkt_arr[bus->glom_cnt] = pkt;
+				bus->glom_cnt++;
+				bus->glom_total_len += len;
+
+				/* Update the total length on the first pkt */
+				frame_tmp = (uint8*)PKTDATA(osh, bus->glom_pkt_arr[0]);
+				*(uint16*)frame_tmp = htol16(bus->glom_total_len);
+				*(((uint16*)frame_tmp) + 1) = htol16(~bus->glom_total_len);
+		}
+	} else
+#endif /* BCMSDIOH_TXGLOM */
+	{
+	uint32 act_len = len;
 	/* Software tag: channel, sequence number, data offset */
 	swheader = ((chan << SDPCM_CHANNEL_SHIFT) & SDPCM_CHANNEL_MASK) | bus->tx_seq |
 	        (((pad1 + SDPCM_HDRLEN) << SDPCM_DOFFSET_SHIFT) & SDPCM_DOFFSET_MASK);
@@ -1458,7 +1710,15 @@ dhdsdio_txpkt(dhd_bus_t *bus, void *pkt, uint chan, bool free_pkt)
 			DHD_ERROR(("%s: sending unrounded %d-byte packet\n", __FUNCTION__, len));
 #endif
 	}
-
+	real_pad = len - act_len;
+	if (PKTTAILROOM(osh, pkt) < real_pad) {
+		DHD_INFO(("%s 3: insufficient tailroom %d for %d real_pad\n",
+		__FUNCTION__, (int)PKTTAILROOM(osh, pkt), real_pad));
+		if (PKTPADTAILROOM(osh, pkt, real_pad)) {
+			DHD_ERROR(("padding error size %d\n", real_pad));
+		}
+	}
+	}
 	do {
 		ret = dhd_bcmsdh_send_buf(bus, bcmsdh_cur_sbwad(sdh), SDIO_FUNC_2, F2SYNC,
 		                          frame, len, pkt, NULL, NULL);
@@ -1469,7 +1729,7 @@ dhdsdio_txpkt(dhd_bus_t *bus, void *pkt, uint chan, bool free_pkt)
 			DHD_ERROR(("%s: Device asleep already\n", __FUNCTION__));
 		} else if (ret < 0) {
 			/* On failure, abort the command and terminate the frame */
-			DHD_INFO(("%s: sdio error %d, abort command and terminate frame.\n",
+			DHD_ERROR(("%s: sdio error %d, abort command and terminate frame.\n",
 			          __FUNCTION__, ret));
 			bus->tx_sderrs++;
 
@@ -1490,13 +1750,50 @@ dhdsdio_txpkt(dhd_bus_t *bus, void *pkt, uint chan, bool free_pkt)
 			}
 		}
 		if (ret == 0) {
+#ifdef BCMSDIOH_TXGLOM
+			if (bus->glom_enable) {
+				bus->tx_seq = (bus->tx_seq + bus->glom_cnt) % SDPCM_SEQUENCE_WRAP;
+			} else
+#endif
+			{
 			bus->tx_seq = (bus->tx_seq + 1) % SDPCM_SEQUENCE_WRAP;
 		}
+		}
 	} while ((ret < 0) && retrydata && retries++ < TXRETRIES);
 
 done:
+
+#ifdef BCMSDIOH_TXGLOM
+	if (bus->glom_enable) {
+		dhd_bcmsdh_glom_clear(bus);
+		pkt_cnt = bus->glom_cnt;
+	} else
+#endif
+	{
+		pkt_cnt = 1;
+	}
 		/* restore pkt buffer pointer before calling tx complete routine */
+	while (pkt_cnt) {
+#ifdef BCMSDIOH_TXGLOM
+		uint32 doff;
+		if (bus->glom_enable) {
+#ifdef BCMLXSDMMC
+			uint32 pad2 = 0;
+#endif /* BCMLXSDMMC */
+			pkt = bus->glom_pkt_arr[bus->glom_cnt - pkt_cnt];
+			frame = (uint8*)PKTDATA(osh, pkt);
+			doff = ltoh32_ua(frame + SDPCM_FRAMETAG_LEN + SDPCM_HWEXT_LEN);
+			doff = (doff & SDPCM_DOFFSET_MASK) >> SDPCM_DOFFSET_SHIFT;
+#ifdef BCMLXSDMMC
+			pad2 = ltoh32_ua(frame + SDPCM_FRAMETAG_LEN + 4) >> 16;
+			PKTSETLEN(osh, pkt, PKTLEN(osh, pkt) - pad2);
+#endif /* BCMLXSDMMC */
+			PKTPULL(osh, pkt, doff);
+		} else
+#endif /* BCMSDIOH_TXGLOM */
+		{
 	PKTPULL(osh, pkt, SDPCM_HDRLEN + pad1);
+		}
 #ifdef PROP_TXSTATUS
 	if (bus->dhd->wlfc_state) {
 		dhd_os_sdunlock(bus->dhd);
@@ -1504,13 +1801,29 @@ done:
 		dhd_os_sdlock(bus->dhd);
 	} else {
 #endif /* PROP_TXSTATUS */
+#ifdef SDTEST
+	if (chan != SDPCM_TEST_CHANNEL) {
+		dhd_txcomplete(bus->dhd, pkt, ret != 0);
+	}
+#else /* SDTEST */
 	dhd_txcomplete(bus->dhd, pkt, ret != 0);
+#endif /* SDTEST */
 	if (free_pkt)
 		PKTFREE(osh, pkt, TRUE);
 
 #ifdef PROP_TXSTATUS
 	}
 #endif
+		pkt_cnt--;
+	}
+
+#ifdef BCMSDIOH_TXGLOM
+	/* Reset the glom array */
+	if (bus->glom_enable) {
+		bus->glom_cnt = 0;
+		bus->glom_total_len = 0;
+	}
+#endif
 	return ret;
 }
 
@@ -1520,7 +1833,13 @@ dhd_bus_txdata(struct dhd_bus *bus, void *pkt)
 	int ret = BCME_ERROR;
 	osl_t *osh;
 	uint datalen, prec;
-
+#ifdef DHD_TX_DUMP
+	uint8 *dump_data;
+	uint16 protocol;
+#ifdef DHD_TX_FULL_DUMP
+	int i;
+#endif /* DHD_TX_FULL_DUMP */
+#endif /* DHD_TX_DUMP */
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
 	osh = bus->dhd->osh;
@@ -1540,6 +1859,27 @@ dhd_bus_txdata(struct dhd_bus *bus, void *pkt)
 	}
 #endif /* SDTEST */
 
+#ifdef DHD_TX_DUMP
+	dump_data = PKTDATA(osh, pkt);
+	dump_data += 4; /* skip 4 bytes header */
+	protocol = (dump_data[12] << 8) | dump_data[13];
+#ifdef DHD_TX_FULL_DUMP
+	DHD_ERROR(("TX DUMP\n"));
+
+	for (i = 0; i < (datalen - 4); i++) {
+		DHD_ERROR(("%02X ", dump_data[i]));
+		if ((i & 15) == 15)
+			printk("\n");
+	}
+	DHD_ERROR(("\n"));
+
+#endif /* DHD_TX_FULL_DUMP */
+	if (protocol == ETHER_TYPE_802_1X) {
+		DHD_ERROR(("ETHER_TYPE_802_1X: ver %d, type %d, replay %d\n",
+			dump_data[14], dump_data[15], dump_data[30]));
+	}
+#endif /* DHD_TX_DUMP */
+
 	/* Add space for the header */
 	PKTPUSH(osh, pkt, SDPCM_HDRLEN);
 	ASSERT(ISALIGNED((uintptr)PKTDATA(osh, pkt), 2));
@@ -1590,7 +1930,6 @@ dhd_bus_txdata(struct dhd_bus *bus, void *pkt)
 		}
 		else
 			ret = BCME_OK;
-		dhd_os_sdunlock_txq(bus->dhd);
 
 		if ((pktq_len(&bus->txq) >= FCHI) && dhd_doflow)
 			dhd_txflowcontrol(bus->dhd, ALL_INTERFACES, ON);
@@ -1599,6 +1938,8 @@ dhd_bus_txdata(struct dhd_bus *bus, void *pkt)
 		if (pktq_plen(&bus->txq, prec) > qcount[prec])
 			qcount[prec] = pktq_plen(&bus->txq, prec);
 #endif
+		dhd_os_sdunlock_txq(bus->dhd);
+
 		/* Schedule DPC if needed to send queued packet(s) */
 		if (dhd_deferred_tx && !bus->dpc_sched) {
 			bus->dpc_sched = TRUE;
@@ -1615,10 +1956,10 @@ dhd_bus_txdata(struct dhd_bus *bus, void *pkt)
 		/* Make sure back plane ht clk is on, no pending allowed */
 		dhdsdio_clkctl(bus, CLK_AVAIL, TRUE);
 #ifndef SDTEST
-		ret = dhdsdio_txpkt(bus, pkt, SDPCM_DATA_CHANNEL, TRUE);
+		ret = dhdsdio_txpkt(bus, pkt, SDPCM_DATA_CHANNEL, TRUE, FALSE);
 #else
 		ret = dhdsdio_txpkt(bus, pkt,
-		        (bus->ext_loop ? SDPCM_TEST_CHANNEL : SDPCM_DATA_CHANNEL), TRUE);
+		        (bus->ext_loop ? SDPCM_TEST_CHANNEL : SDPCM_DATA_CHANNEL), TRUE, FALSE);
 #endif
 		if (ret)
 			bus->dhd->tx_errors++;
@@ -1652,6 +1993,11 @@ dhdsdio_sendfromq(dhd_bus_t *bus, uint maxframes)
 	uint cnt = 0;
 	uint datalen;
 	uint8 tx_prec_map;
+	uint8 txpktqlen = 0;
+#ifdef BCMSDIOH_TXGLOM
+	uint i;
+	uint8 glom_cnt;
+#endif
 
 	dhd_pub_t *dhd = bus->dhd;
 	sdpcmd_regs_t *regs = bus->regs;
@@ -1667,20 +2013,74 @@ dhdsdio_sendfromq(dhd_bus_t *bus, uint maxframes)
 
 	/* Send frames until the limit or some other event */
 	for (cnt = 0; (cnt < maxframes) && DATAOK(bus); cnt++) {
+#ifdef BCMSDIOH_TXGLOM
+		if (bus->glom_enable) {
+			void *pkttable[SDPCM_MAXGLOM_SIZE];
+			dhd_os_sdlock_txq(bus->dhd);
+			glom_cnt = MIN(DATABUFCNT(bus), bus->glomsize);
+			glom_cnt = MIN(glom_cnt, pktq_mlen(&bus->txq, tx_prec_map));
+			glom_cnt = MIN(glom_cnt, maxframes-cnt);
+
+			/* Limiting the size to 2pkts in case of copy */
+			if (bus->glom_mode == SDPCM_TXGLOM_CPY)
+			    glom_cnt = MIN(glom_cnt, 10);
+
+			for (i = 0; i < glom_cnt; i++)
+				pkttable[i] = pktq_mdeq(&bus->txq, tx_prec_map, &prec_out);
+
+			txpktqlen = pktq_len(&bus->txq);
+			dhd_os_sdunlock_txq(bus->dhd);
+
+			if (glom_cnt == 0)
+				break;
+			datalen = 0;
+			for (i = 0; i < glom_cnt; i++) {
+				if ((pkt = pkttable[i]) == NULL) {
+					/* This case should not happen */
+					DHD_ERROR(("No pkts in the queue for glomming\n"));
+					break;
+				}
+
+				datalen += (PKTLEN(bus->dhd->osh, pkt) - SDPCM_HDRLEN);
+#ifndef SDTEST
+				ret = dhdsdio_txpkt(bus,
+					pkt,
+					SDPCM_DATA_CHANNEL,
+					TRUE,
+					(i == (glom_cnt-1))? FALSE: TRUE);
+#else
+				ret = dhdsdio_txpkt(bus,
+					pkt,
+					(bus->ext_loop ? SDPCM_TEST_CHANNEL : SDPCM_DATA_CHANNEL),
+					TRUE,
+					(i == (glom_cnt-1))? FALSE: TRUE);
+#endif
+			}
+			cnt += i-1;
+		} else
+#endif /* BCMSDIOH_TXGLOM */
+		{
 		dhd_os_sdlock_txq(bus->dhd);
 		if ((pkt = pktq_mdeq(&bus->txq, tx_prec_map, &prec_out)) == NULL) {
+			txpktqlen = pktq_len(&bus->txq);
 			dhd_os_sdunlock_txq(bus->dhd);
 			break;
 		}
+		txpktqlen = pktq_len(&bus->txq);
 		dhd_os_sdunlock_txq(bus->dhd);
 		datalen = PKTLEN(bus->dhd->osh, pkt) - SDPCM_HDRLEN;
 
 #ifndef SDTEST
-		ret = dhdsdio_txpkt(bus, pkt, SDPCM_DATA_CHANNEL, TRUE);
+		ret = dhdsdio_txpkt(bus, pkt, SDPCM_DATA_CHANNEL, TRUE, FALSE);
 #else
-		ret = dhdsdio_txpkt(bus, pkt,
-		        (bus->ext_loop ? SDPCM_TEST_CHANNEL : SDPCM_DATA_CHANNEL), TRUE);
+		ret = dhdsdio_txpkt(bus,
+			pkt,
+			(bus->ext_loop ? SDPCM_TEST_CHANNEL : SDPCM_DATA_CHANNEL),
+			TRUE,
+			FALSE);
 #endif
+		}
+
 		if (ret)
 			bus->dhd->tx_errors++;
 		else
@@ -1701,12 +2101,68 @@ dhdsdio_sendfromq(dhd_bus_t *bus, uint maxframes)
 
 	/* Deflow-control stack if needed */
 	if (dhd_doflow && dhd->up && (dhd->busstate == DHD_BUS_DATA) &&
-	    dhd->txoff && (pktq_len(&bus->txq) < FCLOW))
+	    dhd->txoff && (txpktqlen < FCLOW))
 		dhd_txflowcontrol(dhd, ALL_INTERFACES, OFF);
 
 	return cnt;
 }
 
+static void
+dhdsdio_sendpendctl(dhd_bus_t *bus)
+{
+	bcmsdh_info_t *sdh = bus->sdh;
+	int ret, i;
+	uint8* frame_seq = bus->ctrl_frame_buf + SDPCM_FRAMETAG_LEN;
+
+#ifdef BCMSDIOH_TXGLOM
+	if (bus->glom_enable)
+		frame_seq += SDPCM_HWEXT_LEN;
+#endif
+
+	if (*frame_seq != bus->tx_seq) {
+		DHD_INFO(("%s IOCTL frame seq lag detected!"
+			" frm_seq:%d != bus->tx_seq:%d, corrected\n",
+			__FUNCTION__, *frame_seq, bus->tx_seq));
+		*frame_seq = bus->tx_seq;
+	}
+
+	ret = dhd_bcmsdh_send_buf(bus, bcmsdh_cur_sbwad(sdh), SDIO_FUNC_2, F2SYNC,
+		(uint8 *)bus->ctrl_frame_buf, (uint32)bus->ctrl_frame_len,
+		NULL, NULL, NULL);
+	ASSERT(ret != BCME_PENDING);
+	if (ret == BCME_NODEVICE) {
+		DHD_ERROR(("%s: Device asleep already\n", __FUNCTION__));
+	} else if (ret < 0) {
+		/* On failure, abort the command and terminate the frame */
+		DHD_INFO(("%s: sdio error %d, abort command and terminate frame.\n",
+		          __FUNCTION__, ret));
+		bus->tx_sderrs++;
+
+		bcmsdh_abort(sdh, SDIO_FUNC_2);
+
+		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_FRAMECTRL,
+		                 SFC_WF_TERM, NULL);
+		bus->f1regdata++;
+
+		for (i = 0; i < 3; i++) {
+			uint8 hi, lo;
+			hi = bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
+			                     SBSDIO_FUNC1_WFRAMEBCHI, NULL);
+			lo = bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
+			                     SBSDIO_FUNC1_WFRAMEBCLO, NULL);
+			bus->f1regdata += 2;
+			if ((hi == 0) && (lo == 0))
+				break;
+		}
+	}
+	if (ret == 0) {
+		bus->tx_seq = (bus->tx_seq + 1) % SDPCM_SEQUENCE_WRAP;
+	}
+
+	bus->ctrl_frame_stat = FALSE;
+	dhd_wait_event_wakeup(bus->dhd);
+}
+
 int
 dhd_bus_txctl(struct dhd_bus *bus, uchar *msg, uint msglen)
 {
@@ -1768,12 +2224,33 @@ dhd_bus_txctl(struct dhd_bus *bus, uchar *msg, uint msglen)
 	*(uint16*)frame = htol16((uint16)msglen);
 	*(((uint16*)frame) + 1) = htol16(~msglen);
 
+#ifdef BCMSDIOH_TXGLOM
+	if (bus->glom_enable) {
+		uint32 hwheader1, hwheader2;
+		/* Software tag: channel, sequence number, data offset */
+		swheader = ((SDPCM_CONTROL_CHANNEL << SDPCM_CHANNEL_SHIFT) & SDPCM_CHANNEL_MASK)
+				| bus->tx_seq
+				| ((doff << SDPCM_DOFFSET_SHIFT) & SDPCM_DOFFSET_MASK);
+		htol32_ua_store(swheader, frame + SDPCM_FRAMETAG_LEN + SDPCM_HWEXT_LEN);
+		htol32_ua_store(0, frame + SDPCM_FRAMETAG_LEN
+			+ SDPCM_HWEXT_LEN + sizeof(swheader));
+
+		hwheader1 = (msglen - SDPCM_FRAMETAG_LEN) | (1 << 24);
+		hwheader2 = (len - (msglen)) << 16;
+		htol32_ua_store(hwheader1, frame + SDPCM_FRAMETAG_LEN);
+		htol32_ua_store(hwheader2, frame + SDPCM_FRAMETAG_LEN + 4);
+
+		*(uint16*)frame = htol16(len);
+		*(((uint16*)frame) + 1) = htol16(~(len));
+	} else
+#endif /* BCMSDIOH_TXGLOM */
+	{
 	/* Software tag: channel, sequence number, data offset */
 	swheader = ((SDPCM_CONTROL_CHANNEL << SDPCM_CHANNEL_SHIFT) & SDPCM_CHANNEL_MASK)
 	        | bus->tx_seq | ((doff << SDPCM_DOFFSET_SHIFT) & SDPCM_DOFFSET_MASK);
 	htol32_ua_store(swheader, frame + SDPCM_FRAMETAG_LEN);
 	htol32_ua_store(0, frame + SDPCM_FRAMETAG_LEN + sizeof(swheader));
-
+	}
 	if (!TXCTLOK(bus)) {
 		DHD_INFO(("%s: No bus credit bus->tx_max %d, bus->tx_seq %d\n",
 			__FUNCTION__, bus->tx_max, bus->tx_seq));
@@ -1782,16 +2259,23 @@ dhd_bus_txctl(struct dhd_bus *bus, uchar *msg, uint msglen)
 		bus->ctrl_frame_buf = frame;
 		bus->ctrl_frame_len = len;
 
-		dhd_wait_for_event(bus->dhd, &bus->ctrl_frame_stat);
+		if (!bus->dpc_sched) {
+			bus->dpc_sched = TRUE;
+			dhd_sched_dpc(bus->dhd);
+		}
+		if (bus->ctrl_frame_stat) {
+			dhd_wait_for_event(bus->dhd, &bus->ctrl_frame_stat);
+		}
 
 		if (bus->ctrl_frame_stat == FALSE) {
 			DHD_INFO(("%s: ctrl_frame_stat == FALSE\n", __FUNCTION__));
 			ret = 0;
 		} else {
 			bus->dhd->txcnt_timeout++;
-			if (!bus->dhd->hang_was_sent)
+			if (!bus->dhd->hang_was_sent) {
 				DHD_ERROR(("%s: ctrl_frame_stat == TRUE txcnt_timeout=%d\n",
 					__FUNCTION__, bus->dhd->txcnt_timeout));
+			}
 			ret = -1;
 			bus->ctrl_frame_stat = FALSE;
 			goto done;
@@ -1858,7 +2342,7 @@ done:
 	else
 		bus->dhd->tx_ctlpkts++;
 
-	if (bus->dhd->txcnt_timeout >= MAX_CNTL_TIMEOUT)
+	if (bus->dhd->txcnt_timeout >= MAX_CNTL_TX_TIMEOUT)
 		return -ETIMEDOUT;
 
 	return ret ? -EIO : 0;
@@ -1887,19 +2371,26 @@ dhd_bus_rxctl(struct dhd_bus *bus, uchar *msg, uint msglen)
 
 	if (rxlen) {
 		DHD_CTL(("%s: resumed on rxctl frame, got %d expected %d\n",
-		         __FUNCTION__, rxlen, msglen));
+			__FUNCTION__, rxlen, msglen));
 	} else if (timeleft == 0) {
+#ifdef DHD_DEBUG
+		uint32 status, retry = 0;
+		R_SDREG(status, &bus->regs->intstatus, retry);
+		DHD_ERROR(("%s: resumed on timeout, INT status=0x%08X\n",
+			__FUNCTION__, status));
+#else
 		DHD_ERROR(("%s: resumed on timeout\n", __FUNCTION__));
+#endif /* DHD_DEBUG */
 #ifdef DHD_DEBUG
-		if (!SLPAUTO_ENAB(bus)) {
 			dhd_os_sdlock(bus->dhd);
 			dhdsdio_checkdied(bus, NULL, 0);
 			dhd_os_sdunlock(bus->dhd);
-		}
 #endif /* DHD_DEBUG */
 	} else if (pending == TRUE) {
-		DHD_CTL(("%s: canceled\n", __FUNCTION__));
-		return -ERESTARTSYS;
+		/* signal pending */
+		DHD_ERROR(("%s: signal pending\n", __FUNCTION__));
+		return -EINTR;
+
 	} else {
 		DHD_CTL(("%s: resumed for unknown reason?\n", __FUNCTION__));
 #ifdef DHD_DEBUG
@@ -1909,8 +2400,10 @@ dhd_bus_rxctl(struct dhd_bus *bus, uchar *msg, uint msglen)
 #endif /* DHD_DEBUG */
 	}
 	if (timeleft == 0) {
-		bus->dhd->rxcnt_timeout++;
-		DHD_ERROR(("%s: rxcnt_timeout=%d\n", __FUNCTION__, bus->dhd->rxcnt_timeout));
+		if (rxlen == 0)
+			bus->dhd->rxcnt_timeout++;
+		DHD_ERROR(("%s: rxcnt_timeout=%d, rxlen=%d\n", __FUNCTION__,
+			bus->dhd->rxcnt_timeout, rxlen));
 	}
 	else
 		bus->dhd->rxcnt_timeout = 0;
@@ -1920,9 +2413,12 @@ dhd_bus_rxctl(struct dhd_bus *bus, uchar *msg, uint msglen)
 	else
 		bus->dhd->rx_ctlerrs++;
 
-	if (bus->dhd->rxcnt_timeout >= MAX_CNTL_TIMEOUT)
+	if (bus->dhd->rxcnt_timeout >= MAX_CNTL_RX_TIMEOUT)
 		return -ETIMEDOUT;
 
+	if (bus->dhd->dongle_trap_occured)
+		return -EREMOTEIO;
+
 	return rxlen ? (int)rxlen : -EIO;
 }
 
@@ -1934,7 +2430,8 @@ enum {
 	IOV_SBREG,
 	IOV_SDCIS,
 	IOV_MEMBYTES,
-	IOV_MEMSIZE,
+	IOV_RAMSIZE,
+	IOV_RAMSTART,
 #ifdef DHD_DEBUG
 	IOV_CHECKDIED,
 	IOV_SERIALCONS,
@@ -1949,6 +2446,10 @@ enum {
 	IOV_SDALIGN,
 	IOV_DEVRESET,
 	IOV_CPU,
+#if defined(SDIO_CRC_ERROR_FIX)
+	IOV_WATERMARK,
+	IOV_MESBUSYCTRL,
+#endif /* SDIO_CRC_ERROR_FIX */
 #ifdef SDTEST
 	IOV_PKTGEN,
 	IOV_EXTLOOP,
@@ -1967,8 +2468,11 @@ enum {
 	IOV_DEVCAP,
 	IOV_VARS,
 #ifdef SOFTAP
-	IOV_FWPATH
+	IOV_FWPATH,
 #endif
+	IOV_TXGLOMSIZE,
+	IOV_TXGLOMMODE,
+	IOV_HANGREPORT
 };
 
 const bcm_iovar_t dhdsdio_iovars[] = {
@@ -1979,7 +2483,8 @@ const bcm_iovar_t dhdsdio_iovars[] = {
 	{"idleclock",	IOV_IDLECLOCK,	0,	IOVT_INT32,	0 },
 	{"sd1idle",	IOV_SD1IDLE,	0,	IOVT_BOOL,	0 },
 	{"membytes",	IOV_MEMBYTES,	0,	IOVT_BUFFER,	2 * sizeof(int) },
-	{"memsize",	IOV_MEMSIZE,	0,	IOVT_UINT32,	0 },
+	{"ramsize",	IOV_RAMSIZE,	0,	IOVT_UINT32,	0 },
+	{"ramstart",	IOV_RAMSTART,	0,	IOVT_UINT32,	0 },
 	{"dwnldstate",	IOV_SET_DOWNLOAD_STATE,	0,	IOVT_BOOL,	0 },
 	{"socram_state",	IOV_SOCRAM_STATE,	0,	IOVT_BOOL,	0 },
 	{"vars",	IOV_VARS,	0,	IOVT_BUFFER,	0 },
@@ -2007,6 +2512,10 @@ const bcm_iovar_t dhdsdio_iovars[] = {
 	{"extloop",	IOV_EXTLOOP,	0,	IOVT_BOOL,	0 },
 	{"pktgen",	IOV_PKTGEN,	0,	IOVT_BUFFER,	sizeof(dhd_pktgen_t) },
 #endif /* SDTEST */
+#if defined(SDIO_CRC_ERROR_FIX)
+	{"watermark",	IOV_WATERMARK,	0,	IOVT_UINT32,	0 },
+	{"mesbusyctrl",	IOV_MESBUSYCTRL,	0,	IOVT_UINT32,	0 },
+#endif /* SDIO_CRC_ERROR_FIX */
 	{"devcap", IOV_DEVCAP,	0,	IOVT_UINT32,	0 },
 	{"dngl_isolation", IOV_DONGLEISOLATION,	0,	IOVT_UINT32,	0 },
 	{"kso",	IOV_KSO,	0,	IOVT_UINT32,	0 },
@@ -2014,6 +2523,9 @@ const bcm_iovar_t dhdsdio_iovars[] = {
 #ifdef SOFTAP
 	{"fwpath", IOV_FWPATH, 0, IOVT_BUFFER, 0 },
 #endif
+	{"txglomsize", IOV_TXGLOMSIZE, 0, IOVT_UINT32, 0 },
+	{"txglommode", IOV_TXGLOMMODE, 0, IOVT_UINT32, 0 },
+	{"fw_hang_report", IOV_HANGREPORT, 0, IOVT_BOOL, 0 },
 	{NULL, 0, 0, 0, 0 }
 };
 
@@ -2039,25 +2551,25 @@ dhd_bus_dump(dhd_pub_t *dhdp, struct bcmstrbuf *strbuf)
 	bcm_bprintf(strbuf, "Bus SDIO structure:\n");
 	bcm_bprintf(strbuf, "hostintmask 0x%08x intstatus 0x%08x sdpcm_ver %d\n",
 	            bus->hostintmask, bus->intstatus, bus->sdpcm_ver);
-	bcm_bprintf(strbuf, "fcstate %d qlen %d tx_seq %d, max %d, rxskip %d rxlen %d rx_seq %d\n",
+	bcm_bprintf(strbuf, "fcstate %d qlen %u tx_seq %d, max %d, rxskip %d rxlen %u rx_seq %d\n",
 	            bus->fcstate, pktq_len(&bus->txq), bus->tx_seq, bus->tx_max, bus->rxskip,
 	            bus->rxlen, bus->rx_seq);
-	bcm_bprintf(strbuf, "intr %d intrcount %d lastintrs %d spurious %d\n",
+	bcm_bprintf(strbuf, "intr %d intrcount %u lastintrs %u spurious %u\n",
 	            bus->intr, bus->intrcount, bus->lastintrs, bus->spurious);
-	bcm_bprintf(strbuf, "pollrate %d pollcnt %d regfails %d\n",
+	bcm_bprintf(strbuf, "pollrate %u pollcnt %u regfails %u\n",
 	            bus->pollrate, bus->pollcnt, bus->regfails);
 
 	bcm_bprintf(strbuf, "\nAdditional counters:\n");
-	bcm_bprintf(strbuf, "tx_sderrs %d fcqueued %d rxrtx %d rx_toolong %d rxc_errors %d\n",
+	bcm_bprintf(strbuf, "tx_sderrs %u fcqueued %u rxrtx %u rx_toolong %u rxc_errors %u\n",
 	            bus->tx_sderrs, bus->fcqueued, bus->rxrtx, bus->rx_toolong,
 	            bus->rxc_errors);
-	bcm_bprintf(strbuf, "rx_hdrfail %d badhdr %d badseq %d\n",
+	bcm_bprintf(strbuf, "rx_hdrfail %u badhdr %u badseq %u\n",
 	            bus->rx_hdrfail, bus->rx_badhdr, bus->rx_badseq);
-	bcm_bprintf(strbuf, "fc_rcvd %d, fc_xoff %d, fc_xon %d\n",
+	bcm_bprintf(strbuf, "fc_rcvd %u, fc_xoff %u, fc_xon %u\n",
 	            bus->fc_rcvd, bus->fc_xoff, bus->fc_xon);
-	bcm_bprintf(strbuf, "rxglomfail %d, rxglomframes %d, rxglompkts %d\n",
+	bcm_bprintf(strbuf, "rxglomfail %u, rxglomframes %u, rxglompkts %u\n",
 	            bus->rxglomfail, bus->rxglomframes, bus->rxglompkts);
-	bcm_bprintf(strbuf, "f2rx (hdrs/data) %d (%d/%d), f2tx %d f1regs %d\n",
+	bcm_bprintf(strbuf, "f2rx (hdrs/data) %u (%u/%u), f2tx %u f1regs %u\n",
 	            (bus->f2rxhdrs + bus->f2rxdata), bus->f2rxhdrs, bus->f2rxdata,
 	            bus->f2txdata, bus->f1regdata);
 	{
@@ -2097,17 +2609,17 @@ dhd_bus_dump(dhd_pub_t *dhdp, struct bcmstrbuf *strbuf)
 #ifdef SDTEST
 	if (bus->pktgen_count) {
 		bcm_bprintf(strbuf, "pktgen config and count:\n");
-		bcm_bprintf(strbuf, "freq %d count %d print %d total %d min %d len %d\n",
+		bcm_bprintf(strbuf, "freq %u count %u print %u total %u min %u len %u\n",
 		            bus->pktgen_freq, bus->pktgen_count, bus->pktgen_print,
 		            bus->pktgen_total, bus->pktgen_minlen, bus->pktgen_maxlen);
-		bcm_bprintf(strbuf, "send attempts %d rcvd %d fail %d\n",
+		bcm_bprintf(strbuf, "send attempts %u rcvd %u fail %u\n",
 		            bus->pktgen_sent, bus->pktgen_rcvd, bus->pktgen_fail);
 	}
 #endif /* SDTEST */
 #ifdef DHD_DEBUG
 	bcm_bprintf(strbuf, "dpc_sched %d host interrupt%spending\n",
 	            bus->dpc_sched, (bcmsdh_intr_pending(bus->sdh) ? " " : " not "));
-	bcm_bprintf(strbuf, "blocksize %d roundup %d\n", bus->blocksize, bus->roundup);
+	bcm_bprintf(strbuf, "blocksize %u roundup %u\n", bus->blocksize, bus->roundup);
 #endif /* DHD_DEBUG */
 	bcm_bprintf(strbuf, "clkstate %d activity %d idletime %d idlecount %d sleeping %d\n",
 	            bus->clkstate, bus->activity, bus->idletime, bus->idlecount, bus->sleeping);
@@ -2173,12 +2685,15 @@ dhdsdio_pktgen_set(dhd_bus_t *bus, uint8 *arg)
 	bus->pktgen_stop = pktgen.stop;
 
 	bus->pktgen_tick = bus->pktgen_ptick = 0;
+	bus->pktgen_prev_time = jiffies;
 	bus->pktgen_len = MAX(bus->pktgen_len, bus->pktgen_minlen);
 	bus->pktgen_len = MIN(bus->pktgen_len, bus->pktgen_maxlen);
 
 	/* Clear counts for a new pktgen (mode change, or was stopped) */
-	if (bus->pktgen_count && (!oldcnt || oldmode != bus->pktgen_mode))
-		bus->pktgen_sent = bus->pktgen_rcvd = bus->pktgen_fail = 0;
+	if (bus->pktgen_count && (!oldcnt || oldmode != bus->pktgen_mode)) {
+		bus->pktgen_sent = bus->pktgen_prev_sent = bus->pktgen_rcvd = 0;
+		bus->pktgen_prev_rcvd = bus->pktgen_fail = 0;
+	}
 
 	return 0;
 }
@@ -2265,8 +2780,7 @@ dhdsdio_readshared(dhd_bus_t *bus, sdpcm_shared_t *sh)
 	int rv, i;
 	uint32 shaddr = 0;
 
-	shaddr = bus->ramsize - 4;
-
+	shaddr = bus->dongle_ram_base + bus->ramsize - 4;
 	i = 0;
 	do {
 		/* Read last word in memory to determine address of sdpcm_shared structure */
@@ -2414,6 +2928,9 @@ dhdsdio_checkdied(dhd_bus_t *bus, char *data, uint size)
 
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
+	if (DHD_NOCHECKDIED_ON())
+		return 0;
+
 	if (data == NULL) {
 		/*
 		 * Called after a rx ctrl timeout. "data" is NULL.
@@ -2486,6 +3003,7 @@ dhdsdio_checkdied(dhd_bus_t *bus, char *data, uint size)
 		}
 
 		if (sdpcm_shared.flags & SDPCM_SHARED_TRAP) {
+			bus->dhd->dongle_trap_occured = TRUE;
 			if ((bcmerror = dhdsdio_membytes(bus, FALSE,
 			                                 sdpcm_shared.trap_addr,
 			                                 (uint8*)&tr, sizeof(trap_t))) < 0)
@@ -2639,7 +3157,10 @@ dhd_serialconsole(dhd_bus_t *bus, bool set, bool enable, int *bcmerror)
 	if (bus->sih->chip == BCM4330_CHIP_ID) {
 		uart_enab = CC_PLL_CHIPCTRL_SERIAL_ENAB;
 	}
-	else if (bus->sih->chip == BCM4334_CHIP_ID) {
+	else if (bus->sih->chip == BCM4334_CHIP_ID ||
+		bus->sih->chip == BCM43340_CHIP_ID ||	
+		bus->sih->chip == BCM43341_CHIP_ID ||
+		0) {
 		if (enable) {
 			/* Moved to PMU chipcontrol 1 from 4330 */
 			int_val &= ~gpio_sel;
@@ -2835,6 +3356,16 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bcm_iovar_t *vi, uint32 actionid, const ch
 		DHD_INFO(("%s: Request to %s %d bytes at address 0x%08x\n", __FUNCTION__,
 		          (set ? "write" : "read"), size, address));
 
+		/* check if CR4 */
+		if (si_setcore(bus->sih, ARMCR4_CORE_ID, 0)) {
+			/*
+			 * If address is start of RAM (i.e. a downloaded image),
+			 * store the reset instruction to be written in 0
+			 */
+			if (address == bus->dongle_ram_base) {
+				bus->resetinstr = *(((uint32*)params) + 2);
+			}
+		} else {
 		/* If we know about SOCRAM, check for a fit */
 		if ((bus->orig_ramsize) &&
 		    ((address > bus->orig_ramsize) || (address + size > bus->orig_ramsize)))
@@ -2876,6 +3407,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bcm_iovar_t *vi, uint32 actionid, const ch
 				break;
 			}
 		}
+		}
 
 		/* Generate the actual data pointer */
 		data = set ? (uint8*)params + 2 * sizeof(int): (uint8*)arg;
@@ -2886,11 +3418,16 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bcm_iovar_t *vi, uint32 actionid, const ch
 		break;
 	}
 
-	case IOV_GVAL(IOV_MEMSIZE):
+	case IOV_GVAL(IOV_RAMSIZE):
 		int_val = (int32)bus->ramsize;
 		bcopy(&int_val, arg, val_size);
 		break;
 
+	case IOV_GVAL(IOV_RAMSTART):
+		int_val = (int32)bus->dongle_ram_base;
+		bcopy(&int_val, arg, val_size);
+		break;
+
 	case IOV_GVAL(IOV_SDIOD_DRIVE):
 		int_val = (int32)dhd_sdiod_drive_strength;
 		bcopy(&int_val, arg, val_size);
@@ -3107,6 +3644,34 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bcm_iovar_t *vi, uint32 actionid, const ch
 		break;
 #endif /* SDTEST */
 
+#if defined(SDIO_CRC_ERROR_FIX)
+	case IOV_GVAL(IOV_WATERMARK):
+		int_val = (int32)watermark;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_WATERMARK):
+		watermark = (uint)int_val;
+		watermark = (watermark > SBSDIO_WATERMARK_MASK) ? SBSDIO_WATERMARK_MASK : watermark;
+		DHD_ERROR(("Setting watermark as 0x%x.\n", watermark));
+		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_WATERMARK, (uint8)watermark, NULL);
+		break;
+
+	case IOV_GVAL(IOV_MESBUSYCTRL):
+		int_val = (int32)mesbusyctrl;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_MESBUSYCTRL):
+		mesbusyctrl = (uint)int_val;
+		mesbusyctrl = (mesbusyctrl > SBSDIO_MESBUSYCTRL_MASK)
+			? SBSDIO_MESBUSYCTRL_MASK : mesbusyctrl;
+		DHD_ERROR(("Setting mesbusyctrl as 0x%x.\n", mesbusyctrl));
+		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_MESBUSYCTRL,
+			((uint8)mesbusyctrl | 0x80), NULL);
+		break;
+#endif /* SDIO_CRC_ERROR_FIX */
+
 
 	case IOV_GVAL(IOV_DONGLEISOLATION):
 		int_val = bus->dhd->dongle_isolation;
@@ -3190,6 +3755,42 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bcm_iovar_t *vi, uint32 actionid, const ch
 		dhdsdio_devcap_set(bus, (uint8) int_val);
 		break;
 
+#ifdef BCMSDIOH_TXGLOM
+	case IOV_GVAL(IOV_TXGLOMSIZE):
+		int_val = (int32)bus->glomsize;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_TXGLOMSIZE):
+		if (int_val > SDPCM_MAXGLOM_SIZE) {
+			bcmerror = BCME_ERROR;
+		} else {
+			bus->glomsize = (uint)int_val;
+		}
+		break;
+	case IOV_GVAL(IOV_TXGLOMMODE):
+		int_val = (int32)bus->glom_mode;
+		bcopy(&int_val, arg, val_size);
+		break;
+
+	case IOV_SVAL(IOV_TXGLOMMODE):
+		if ((int_val != SDPCM_TXGLOM_CPY) && (int_val != SDPCM_TXGLOM_MDESC)) {
+			bcmerror = BCME_RANGE;
+		} else {
+			if ((bus->glom_mode = bcmsdh_set_mode(bus->sdh, (uint)int_val)) != int_val)
+				bcmerror = BCME_ERROR;
+		}
+		break;
+#endif /* BCMSDIOH_TXGLOM */
+	case IOV_SVAL(IOV_HANGREPORT):
+		bus->dhd->hang_report = bool_val;
+		DHD_ERROR(("%s: Set hang_report as %d\n", __FUNCTION__, bus->dhd->hang_report));
+		break;
+
+	case IOV_GVAL(IOV_HANGREPORT):
+		int_val = (int32)bus->dhd->hang_report;
+		bcopy(&int_val, arg, val_size);
+		break;
 	default:
 		bcmerror = BCME_UNSUPPORTED;
 		break;
@@ -3222,6 +3823,8 @@ dhdsdio_write_vars(dhd_bus_t *bus)
 	varsize = bus->varsz ? ROUNDUP(bus->varsz, 4) : 0;
 	varaddr = (bus->ramsize - 4) - varsize;
 
+	varaddr += bus->dongle_ram_base;
+
 	if (bus->vars) {
 		if ((bus->sih->buscoretype == SDIOD_CORE_ID) && (bus->sdpcmrev == 7)) {
 			if (((varaddr & 0x3C) == 0x3C) && (varsize > 4)) {
@@ -3271,6 +3874,8 @@ dhdsdio_write_vars(dhd_bus_t *bus)
 
 	phys_size = REMAP_ENAB(bus) ? bus->ramsize : bus->orig_ramsize;
 
+	phys_size += bus->dongle_ram_base;
+
 	/* adjust to the user specified RAM */
 	DHD_INFO(("Physical memory size: %d, usable memory size: %d\n",
 		phys_size, bus->ramsize));
@@ -3304,7 +3909,10 @@ dhdsdio_download_state(dhd_bus_t *bus, bool enter)
 {
 	uint retries;
 	int bcmerror = 0;
+	int foundcr4 = 0;
 
+	if (!bus->sih)
+		return BCME_ERROR;
 	/* To enter download state, disable ARM and reset SOCRAM.
 	 * To exit download state, simply reset ARM (default is RAM boot).
 	 */
@@ -3313,80 +3921,128 @@ dhdsdio_download_state(dhd_bus_t *bus, bool enter)
 
 		if (!(si_setcore(bus->sih, ARM7S_CORE_ID, 0)) &&
 		    !(si_setcore(bus->sih, ARMCM3_CORE_ID, 0))) {
-			DHD_ERROR(("%s: Failed to find ARM core!\n", __FUNCTION__));
-			bcmerror = BCME_ERROR;
-			goto fail;
-		}
-
-		si_core_disable(bus->sih, 0);
-		if (bcmsdh_regfail(bus->sdh)) {
-			bcmerror = BCME_SDIO_ERROR;
-			goto fail;
-		}
-
-		if (!(si_setcore(bus->sih, SOCRAM_CORE_ID, 0))) {
-			DHD_ERROR(("%s: Failed to find SOCRAM core!\n", __FUNCTION__));
-			bcmerror = BCME_ERROR;
-			goto fail;
+			if (si_setcore(bus->sih, ARMCR4_CORE_ID, 0)) {
+				foundcr4 = 1;
+			} else {
+				DHD_ERROR(("%s: Failed to find ARM core!\n", __FUNCTION__));
+				bcmerror = BCME_ERROR;
+				goto fail;
+			}
 		}
 
-		si_core_reset(bus->sih, 0, 0);
-		if (bcmsdh_regfail(bus->sdh)) {
-			DHD_ERROR(("%s: Failure trying reset SOCRAM core?\n", __FUNCTION__));
-			bcmerror = BCME_SDIO_ERROR;
-			goto fail;
-		}
+		if (!foundcr4) {
+			si_core_disable(bus->sih, 0);
+			if (bcmsdh_regfail(bus->sdh)) {
+				bcmerror = BCME_SDIO_ERROR;
+				goto fail;
+			}
 
-		/* Disable remap for download */
-		if (REMAP_ENAB(bus) && si_socdevram_remap_isenb(bus->sih))
-			dhdsdio_devram_remap(bus, FALSE);
+			if (!(si_setcore(bus->sih, SOCRAM_CORE_ID, 0))) {
+				DHD_ERROR(("%s: Failed to find SOCRAM core!\n", __FUNCTION__));
+				bcmerror = BCME_ERROR;
+				goto fail;
+			}
 
-		/* Clear the top bit of memory */
-		if (bus->ramsize) {
-			uint32 zeros = 0;
-			if (dhdsdio_membytes(bus, TRUE, bus->ramsize - 4, (uint8*)&zeros, 4) < 0) {
+			si_core_reset(bus->sih, 0, 0);
+			if (bcmsdh_regfail(bus->sdh)) {
+				DHD_ERROR(("%s: Failure trying reset SOCRAM core?\n",
+				           __FUNCTION__));
 				bcmerror = BCME_SDIO_ERROR;
 				goto fail;
 			}
+
+			/* Disable remap for download */
+			if (REMAP_ENAB(bus) && si_socdevram_remap_isenb(bus->sih))
+				dhdsdio_devram_remap(bus, FALSE);
+
+			/* Clear the top bit of memory */
+			if (bus->ramsize) {
+				uint32 zeros = 0;
+				if (dhdsdio_membytes(bus, TRUE, bus->ramsize - 4,
+				                     (uint8*)&zeros, 4) < 0) {
+					bcmerror = BCME_SDIO_ERROR;
+					goto fail;
+				}
+			}
+		} else {
+			/* For CR4,
+			 * Halt ARM
+			 * Remove ARM reset
+			 * Read RAM base address [0x18_0000]
+			 * [next] Download firmware
+			 * [done at else] Populate the reset vector
+			 * [done at else] Remove ARM halt
+			*/
+			/* Halt ARM & remove reset */
+			si_core_reset(bus->sih, SICF_CPUHALT, SICF_CPUHALT);
 		}
 	} else {
-		if (!(si_setcore(bus->sih, SOCRAM_CORE_ID, 0))) {
-			DHD_ERROR(("%s: Failed to find SOCRAM core!\n", __FUNCTION__));
-			bcmerror = BCME_ERROR;
-			goto fail;
-		}
+		if (!si_setcore(bus->sih, ARMCR4_CORE_ID, 0)) {
+			if (!(si_setcore(bus->sih, SOCRAM_CORE_ID, 0))) {
+				DHD_ERROR(("%s: Failed to find SOCRAM core!\n", __FUNCTION__));
+				bcmerror = BCME_ERROR;
+				goto fail;
+			}
 
-		if (!si_iscoreup(bus->sih)) {
-			DHD_ERROR(("%s: SOCRAM core is down after reset?\n", __FUNCTION__));
-			bcmerror = BCME_ERROR;
-			goto fail;
-		}
+			if (!si_iscoreup(bus->sih)) {
+				DHD_ERROR(("%s: SOCRAM core is down after reset?\n", __FUNCTION__));
+				bcmerror = BCME_ERROR;
+				goto fail;
+			}
 
-		if ((bcmerror = dhdsdio_write_vars(bus))) {
-			DHD_ERROR(("%s: could not write vars to RAM\n", __FUNCTION__));
-			goto fail;
-		}
+			if ((bcmerror = dhdsdio_write_vars(bus))) {
+				DHD_ERROR(("%s: could not write vars to RAM\n", __FUNCTION__));
+				goto fail;
+			}
 
-		/* Enable remap before ARM reset but after vars.
-		 * No backplane access in remap mode
-		 */
-		if (REMAP_ENAB(bus) && !si_socdevram_remap_isenb(bus->sih))
-			dhdsdio_devram_remap(bus, TRUE);
+			/* Enable remap before ARM reset but after vars.
+			 * No backplane access in remap mode
+			 */
+			if (REMAP_ENAB(bus) && !si_socdevram_remap_isenb(bus->sih))
+				dhdsdio_devram_remap(bus, TRUE);
 
-		if (!si_setcore(bus->sih, PCMCIA_CORE_ID, 0) &&
-		    !si_setcore(bus->sih, SDIOD_CORE_ID, 0)) {
-			DHD_ERROR(("%s: Can't change back to SDIO core?\n", __FUNCTION__));
-			bcmerror = BCME_ERROR;
-			goto fail;
-		}
-		W_SDREG(0xFFFFFFFF, &bus->regs->intstatus, retries);
+			if (!si_setcore(bus->sih, PCMCIA_CORE_ID, 0) &&
+			    !si_setcore(bus->sih, SDIOD_CORE_ID, 0)) {
+				DHD_ERROR(("%s: Can't change back to SDIO core?\n", __FUNCTION__));
+				bcmerror = BCME_ERROR;
+				goto fail;
+			}
+			W_SDREG(0xFFFFFFFF, &bus->regs->intstatus, retries);
 
 
-		if (!(si_setcore(bus->sih, ARM7S_CORE_ID, 0)) &&
-		    !(si_setcore(bus->sih, ARMCM3_CORE_ID, 0))) {
-			DHD_ERROR(("%s: Failed to find ARM core!\n", __FUNCTION__));
-			bcmerror = BCME_ERROR;
-			goto fail;
+			if (!(si_setcore(bus->sih, ARM7S_CORE_ID, 0)) &&
+			    !(si_setcore(bus->sih, ARMCM3_CORE_ID, 0))) {
+				DHD_ERROR(("%s: Failed to find ARM core!\n", __FUNCTION__));
+				bcmerror = BCME_ERROR;
+				goto fail;
+			}
+		} else {
+			/* cr4 has no socram, but tcm's */
+			/* write vars */
+			if ((bcmerror = dhdsdio_write_vars(bus))) {
+				DHD_ERROR(("%s: could not write vars to RAM\n", __FUNCTION__));
+				goto fail;
+			}
+
+			if (!si_setcore(bus->sih, PCMCIA_CORE_ID, 0) &&
+			    !si_setcore(bus->sih, SDIOD_CORE_ID, 0)) {
+				DHD_ERROR(("%s: Can't change back to SDIO core?\n", __FUNCTION__));
+				bcmerror = BCME_ERROR;
+				goto fail;
+			}
+			W_SDREG(0xFFFFFFFF, &bus->regs->intstatus, retries);
+
+			/* switch back to arm core again */
+			if (!(si_setcore(bus->sih, ARMCR4_CORE_ID, 0))) {
+				DHD_ERROR(("%s: Failed to find ARM CR4 core!\n", __FUNCTION__));
+				bcmerror = BCME_ERROR;
+				goto fail;
+			}
+			/* write address 0 with reset instruction */
+			bcmerror = dhdsdio_membytes(bus, TRUE, 0,
+				(uint8 *)&bus->resetinstr, sizeof(bus->resetinstr));
+
+			/* now remove reset and halt and continue to run CR4 */
 		}
 
 		si_core_reset(bus->sih, 0, 0);
@@ -3476,6 +4132,11 @@ dhd_bus_iovar_op(dhd_pub_t *dhdp, const char *name,
 			} else {
 				DHD_INFO(("%s: noted %s update, value now %d\n",
 				          __FUNCTION__, "sd_blocksize", bus->blocksize));
+
+				if ((bus->sih->chip == BCM4335_CHIP_ID) ||
+					(bus->sih->chip == BCM4339_CHIP_ID) ||
+					(bus->sih->chip == BCM4350_CHIP_ID))
+					dhd_overflow_war(bus);
 			}
 		}
 		bus->roundup = MIN(max_roundup, bus->blocksize);
@@ -3520,7 +4181,7 @@ dhd_bus_stop(struct dhd_bus *bus, bool enforce_mutex)
 {
 	osl_t *osh;
 	uint32 local_hostintmask;
-	uint8 saveclk;
+	uint8 saveclk, dat;
 	uint retries;
 	int err;
 	if (!bus->dhd)
@@ -3534,42 +4195,58 @@ dhd_bus_stop(struct dhd_bus *bus, bool enforce_mutex)
 	if (enforce_mutex)
 		dhd_os_sdlock(bus->dhd);
 
-	BUS_WAKE(bus);
+	if ((bus->dhd->busstate == DHD_BUS_DOWN) || bus->dhd->hang_was_sent) {
+		/* if Firmware already hangs disbale any interrupt */
+		bus->dhd->busstate = DHD_BUS_DOWN;
+		bus->hostintmask = 0;
+		bcmsdh_intr_disable(bus->sdh);
+	} else {
 
-	/* Change our idea of bus state */
-	bus->dhd->busstate = DHD_BUS_DOWN;
+		BUS_WAKE(bus);
 
-	if (KSO_ENAB(bus)) {
+		if (KSO_ENAB(bus)) {
+			/* Mask the interrupt */
+			dat = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_0, SDIOD_CCCR_INTEN, NULL);
+			dat &= ~(INTR_CTL_FUNC1_EN | INTR_CTL_FUNC2_EN);
+			bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_0, SDIOD_CCCR_INTEN, dat, NULL);
+		}
 
-	/* Enable clock for device interrupts */
-	dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
+		/* Change our idea of bus state */
+		bus->dhd->busstate = DHD_BUS_DOWN;
 
-	/* Disable and clear interrupts at the chip level also */
-	W_SDREG(0, &bus->regs->hostintmask, retries);
-	local_hostintmask = bus->hostintmask;
-	bus->hostintmask = 0;
+		if (KSO_ENAB(bus)) {
 
-	/* Force clocks on backplane to be sure F2 interrupt propagates */
-	saveclk = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, &err);
-	if (!err) {
-		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
-		                 (saveclk | SBSDIO_FORCE_HT), &err);
-	}
-	if (err) {
-		DHD_ERROR(("%s: Failed to force clock for F2: err %d\n", __FUNCTION__, err));
-	}
+		/* Enable clock for device interrupts */
+		dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
+
+		/* Disable and clear interrupts at the chip level also */
+		W_SDREG(0, &bus->regs->hostintmask, retries);
+		local_hostintmask = bus->hostintmask;
+		bus->hostintmask = 0;
+
+		/* Force clocks on backplane to be sure F2 interrupt propagates */
+		saveclk = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, &err);
+		if (!err) {
+			bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
+			                 (saveclk | SBSDIO_FORCE_HT), &err);
+		}
+		if (err) {
+			DHD_ERROR(("%s: Failed to force clock for F2: err %d\n",
+			            __FUNCTION__, err));
+		}
 
-	/* Turn off the bus (F2), free any pending packets */
-	DHD_INTR(("%s: disable SDIO interrupts\n", __FUNCTION__));
-	bcmsdh_intr_disable(bus->sdh);
-	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_0, SDIOD_CCCR_IOEN, SDIO_FUNC_ENABLE_1, NULL);
+		/* Turn off the bus (F2), free any pending packets */
+		DHD_INTR(("%s: disable SDIO interrupts\n", __FUNCTION__));
+		bcmsdh_intr_disable(bus->sdh);
+		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_0, SDIOD_CCCR_IOEN, SDIO_FUNC_ENABLE_1, NULL);
 
-	/* Clear any pending interrupts now that F2 is disabled */
-	W_SDREG(local_hostintmask, &bus->regs->intstatus, retries);
-	}
+		/* Clear any pending interrupts now that F2 is disabled */
+		W_SDREG(local_hostintmask, &bus->regs->intstatus, retries);
+		}
 
-	/* Turn off the backplane clock (only) */
-	dhdsdio_clkctl(bus, CLK_SDONLY, FALSE);
+		/* Turn off the backplane clock (only) */
+		dhdsdio_clkctl(bus, CLK_SDONLY, FALSE);
+	}
 
 	/* Clear the data packet queues */
 	pktq_flush(osh, &bus->txq, TRUE, NULL, 0);
@@ -3591,10 +4268,41 @@ dhd_bus_stop(struct dhd_bus *bus, bool enforce_mutex)
 	bus->rxskip = FALSE;
 	bus->tx_seq = bus->rx_seq = 0;
 
+	bus->tx_max = 4;
+
 	if (enforce_mutex)
 		dhd_os_sdunlock(bus->dhd);
 }
 
+#ifdef BCMSDIOH_TXGLOM
+void
+dhd_txglom_enable(dhd_pub_t *dhdp, bool enable)
+{
+	dhd_bus_t *bus = dhdp->bus;
+
+	char buf[256];
+	uint32 rxglom;
+	int32 ret;
+
+	printk("enter %s \n", __func__);
+	if (enable) {
+		rxglom = 1;
+		memset(buf, 0, sizeof(buf));
+		bcm_mkiovar("bus:rxglom",
+			(void *)&rxglom,
+			4, buf, sizeof(buf));
+		ret = dhd_wl_ioctl_cmd(dhdp,
+			WLC_SET_VAR, buf,
+			sizeof(buf), TRUE, 0);
+		if (!(ret < 0)) {
+			bus->glom_enable = TRUE;
+		}
+	} else {
+		bus->glom_enable = FALSE;
+	}
+	printk("exit %s \n", __func__);
+}
+#endif /* BCMSDIOH_TXGLOM */
 
 int
 dhd_bus_init(dhd_pub_t *dhdp, bool enforce_mutex)
@@ -3619,6 +4327,7 @@ dhd_bus_init(dhd_pub_t *dhdp, bool enforce_mutex)
 	dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
 	if (bus->clkstate != CLK_AVAIL) {
 		DHD_ERROR(("%s: clock state is wrong. state = %d\n", __FUNCTION__, bus->clkstate));
+		ret = -1;
 		goto exit;
 	}
 
@@ -3631,6 +4340,7 @@ dhd_bus_init(dhd_pub_t *dhdp, bool enforce_mutex)
 	}
 	if (err) {
 		DHD_ERROR(("%s: Failed to force clock for F2: err %d\n", __FUNCTION__, err));
+		ret = -1;
 		goto exit;
 	}
 
@@ -3648,7 +4358,7 @@ dhd_bus_init(dhd_pub_t *dhdp, bool enforce_mutex)
 	while (ready != enable && !dhd_timeout_expired(&tmo))
 	        ready = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_0, SDIOD_CCCR_IORDY, NULL);
 
-	DHD_INFO(("%s: enable 0x%02x, ready 0x%02x (waited %uus)\n",
+	DHD_ERROR(("%s: enable 0x%02x, ready 0x%02x (waited %uus)\n",
 	          __FUNCTION__, enable, ready, tmo.elapsed));
 
 
@@ -3668,8 +4378,22 @@ dhd_bus_init(dhd_pub_t *dhdp, bool enforce_mutex)
 			bus->hostintmask |= I_XMTDATA_AVAIL;
 		}
 		W_SDREG(bus->hostintmask, &bus->regs->hostintmask, retries);
-
-		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_WATERMARK, (uint8)watermark, &err);
+#ifdef SDIO_CRC_ERROR_FIX
+		if (bus->blocksize < 512) {
+			mesbusyctrl = watermark = bus->blocksize / 4;
+		}
+#endif /* SDIO_CRC_ERROR_FIX */
+		if (!((bus->sih->chip == BCM4335_CHIP_ID) ||
+			(bus->sih->chip == BCM4339_CHIP_ID))) {
+			bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_WATERMARK,
+				(uint8)watermark, &err);
+		}
+#ifdef SDIO_CRC_ERROR_FIX
+		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_MESBUSYCTRL,
+			(uint8)mesbusyctrl|0x80, &err);
+		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL,
+			SBSDIO_DEVCTL_EN_F2_BLK_WATERMARK, NULL);
+#endif /* SDIO_CRC_ERROR_FIX */
 
 		/* Set bus state according to enable result */
 		dhdp->busstate = DHD_BUS_DATA;
@@ -3734,12 +4458,21 @@ dhdsdio_rxfail(dhd_bus_t *bus, bool abort, bool rtx)
 	}
 
 	bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_FRAMECTRL, SFC_RF_TERM, &err);
+	if (err) {
+		DHD_ERROR(("%s: SBSDIO_FUNC1_FRAMECTRL cmd err\n", __FUNCTION__));
+		goto fail;
+	}
 	bus->f1regdata++;
 
 	/* Wait until the packet has been flushed (device/FIFO stable) */
 	for (lastrbc = retries = 0xffff; retries > 0; retries--) {
 		hi = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_RFRAMEBCHI, NULL);
-		lo = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_RFRAMEBCLO, NULL);
+		lo = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_RFRAMEBCLO, &err);
+		if (err) {
+			DHD_ERROR(("%s: SBSDIO_FUNC1_RFAMEBCLO cmd err\n", __FUNCTION__));
+			goto fail;
+		}
+
 		bus->f1regdata += 2;
 
 		if ((hi == 0) && (lo == 0))
@@ -3770,6 +4503,7 @@ dhdsdio_rxfail(dhd_bus_t *bus, bool abort, bool rtx)
 	/* Clear partial in any case */
 	bus->nextlen = 0;
 
+fail:
 	/* If we can't reach the device, signal failure */
 	if (err || bcmsdh_regfail(sdh))
 		bus->dhd->busstate = DHD_BUS_DOWN;
@@ -3874,6 +4608,9 @@ done:
 	/* Awake any waiters */
 	dhd_os_ioctl_resp_wake(bus->dhd);
 }
+int
+dhd_process_pkt_reorder_info(dhd_pub_t *dhd, uchar *reorder_info_buf, uint reorder_info_len,
+	void **pkt, uint32 *pkt_count);
 
 static uint8
 dhdsdio_rxglom(dhd_bus_t *bus, uint8 rxseq)
@@ -3882,7 +4619,10 @@ dhdsdio_rxglom(dhd_bus_t *bus, uint8 rxseq)
 	uint8 *dptr, num = 0;
 
 	uint16 sublen, check;
-	void *pfirst, *plast, *pnext, *save_pfirst;
+	void *pfirst, *plast, *pnext;
+	void * list_tail[DHD_MAX_IFS] = { NULL };
+	void * list_head[DHD_MAX_IFS] = { NULL };
+	uint8 idx;
 	osl_t *osh = bus->dhd->osh;
 
 	int errcode;
@@ -3917,8 +4657,8 @@ dhdsdio_rxglom(dhd_bus_t *bus, uint8 rxseq)
 			sublen = ltoh16_ua(dptr);
 			dlen -= sizeof(uint16);
 			dptr += sizeof(uint16);
-			if ((sublen < SDPCM_HDRLEN) ||
-			    ((num == 0) && (sublen < (2 * SDPCM_HDRLEN)))) {
+			if ((sublen < SDPCM_HDRLEN_RX) ||
+			    ((num == 0) && (sublen < (2 * SDPCM_HDRLEN_RX)))) {
 				DHD_ERROR(("%s: descriptor len %d bad: %d\n",
 				           __FUNCTION__, num, sublen));
 				pnext = NULL;
@@ -4087,10 +4827,11 @@ dhdsdio_rxglom(dhd_bus_t *bus, uint8 rxseq)
 		} else if (SDPCM_GLOMDESC(&dptr[SDPCM_FRAMETAG_LEN])) {
 			DHD_ERROR(("%s (superframe): got second descriptor?\n", __FUNCTION__));
 			errcode = -1;
-		} else if ((doff < SDPCM_HDRLEN) ||
-		           (doff > (PKTLEN(osh, pfirst) - SDPCM_HDRLEN))) {
+		} else if ((doff < SDPCM_HDRLEN_RX) ||
+		           (doff > (PKTLEN(osh, pfirst) - SDPCM_HDRLEN_RX))) {
 			DHD_ERROR(("%s (superframe): Bad data offset %d: HW %d pkt %d min %d\n",
-			           __FUNCTION__, doff, sublen, PKTLEN(osh, pfirst), SDPCM_HDRLEN));
+				__FUNCTION__, doff, sublen, PKTLEN(osh, pfirst),
+				SDPCM_HDRLEN_RX));
 			errcode = -1;
 		}
 
@@ -4134,7 +4875,7 @@ dhdsdio_rxglom(dhd_bus_t *bus, uint8 rxseq)
 				           "len/check 0x%04x/0x%04x\n",
 				           __FUNCTION__, num, sublen, check));
 				errcode = -1;
-			} else if ((sublen > dlen) || (sublen < SDPCM_HDRLEN)) {
+			} else if ((sublen > dlen) || (sublen < SDPCM_HDRLEN_RX)) {
 				DHD_ERROR(("%s (subframe %d): length mismatch: "
 				           "len 0x%04x, expect 0x%04x\n",
 				           __FUNCTION__, num, sublen, dlen));
@@ -4144,9 +4885,9 @@ dhdsdio_rxglom(dhd_bus_t *bus, uint8 rxseq)
 				DHD_ERROR(("%s (subframe %d): bad channel %d\n",
 				           __FUNCTION__, num, chan));
 				errcode = -1;
-			} else if ((doff < SDPCM_HDRLEN) || (doff > sublen)) {
+			} else if ((doff < SDPCM_HDRLEN_RX) || (doff > sublen)) {
 				DHD_ERROR(("%s (subframe %d): Bad data offset %d: HW %d min %d\n",
-				           __FUNCTION__, num, doff, sublen, SDPCM_HDRLEN));
+				           __FUNCTION__, num, doff, sublen, SDPCM_HDRLEN_RX));
 				errcode = -1;
 			}
 		}
@@ -4171,7 +4912,6 @@ dhdsdio_rxglom(dhd_bus_t *bus, uint8 rxseq)
 		}
 
 		/* Basic SD framing looks ok - process each packet (header) */
-		save_pfirst = pfirst;
 		bus->glom = NULL;
 		plast = NULL;
 
@@ -4212,24 +4952,12 @@ dhdsdio_rxglom(dhd_bus_t *bus, uint8 rxseq)
 
 			if (PKTLEN(osh, pfirst) == 0) {
 				PKTFREE(bus->dhd->osh, pfirst, FALSE);
-				if (plast) {
-					PKTSETNEXT(osh, plast, pnext);
-				} else {
-					ASSERT(save_pfirst == pfirst);
-					save_pfirst = pnext;
-				}
 				continue;
 			} else if (dhd_prot_hdrpull(bus->dhd, &ifidx, pfirst, reorder_info_buf,
 				&reorder_info_len) != 0) {
 				DHD_ERROR(("%s: rx protocol error\n", __FUNCTION__));
 				bus->dhd->rx_errors++;
 				PKTFREE(osh, pfirst, FALSE);
-				if (plast) {
-					PKTSETNEXT(osh, plast, pnext);
-				} else {
-					ASSERT(save_pfirst == pfirst);
-					save_pfirst = pnext;
-				}
 				continue;
 			}
 			if (reorder_info_len) {
@@ -4242,12 +4970,6 @@ dhdsdio_rxglom(dhd_bus_t *bus, uint8 rxseq)
 					reorder_info_len, &ppfirst, &free_buf_count);
 
 				if (free_buf_count == 0) {
-					if (plast) {
-						PKTSETNEXT(osh, plast, pnext);
-					} else {
-						ASSERT(save_pfirst == pfirst);
-						save_pfirst = pnext;
-					}
 					continue;
 				}
 				else {
@@ -4259,24 +4981,25 @@ dhdsdio_rxglom(dhd_bus_t *bus, uint8 rxseq)
 						temp = PKTNEXT(osh, temp);
 					}
 					pfirst = temp;
-					if (plast) {
-						PKTSETNEXT(osh, plast, ppfirst);
-					}
-					else {
-						/* first one in the chain */
-						save_pfirst = ppfirst;
-					}
-
-					PKTSETNEXT(osh, pfirst, pnext);
-					plast = pfirst;
+					if (list_tail[ifidx] == NULL)
+						list_head[ifidx] = ppfirst;
+					else
+						PKTSETNEXT(osh, list_tail[ifidx], ppfirst);
+					list_tail[ifidx] = pfirst;
 				}
 
 				num += (uint8)free_buf_count;
 			}
 			else {
 				/* this packet will go up, link back into chain and count it */
-				PKTSETNEXT(osh, pfirst, pnext);
-				plast = pfirst;
+
+				if (list_tail[ifidx] == NULL) {
+					list_head[ifidx] = list_tail[ifidx] = pfirst;
+				}
+				else {
+					PKTSETNEXT(osh, list_tail[ifidx], pfirst);
+					list_tail[ifidx] = pfirst;
+				}
 				num++;
 			}
 #ifdef DHD_DEBUG
@@ -4291,12 +5014,23 @@ dhdsdio_rxglom(dhd_bus_t *bus, uint8 rxseq)
 #endif /* DHD_DEBUG */
 		}
 		dhd_os_sdunlock_rxq(bus->dhd);
-		if (num) {
-			dhd_os_sdunlock(bus->dhd);
-			dhd_rx_frame(bus->dhd, ifidx, save_pfirst, num, 0);
-			dhd_os_sdlock(bus->dhd);
-		}
 
+		for (idx = 0; idx < DHD_MAX_IFS; idx++) {
+			if (list_head[idx]) {
+				void *temp;
+				uint8 cnt = 0;
+				temp = list_head[idx];
+				do {
+					temp = PKTNEXT(osh, temp);
+					cnt++;
+				} while (temp);
+				if (cnt) {
+					dhd_os_sdunlock(bus->dhd);
+					dhd_rx_frame(bus->dhd, idx, list_head[idx], cnt, 0);
+					dhd_os_sdlock(bus->dhd);
+				}
+			}
+		}
 		bus->rxglomframes++;
 		bus->rxglompkts += num;
 	}
@@ -4365,7 +5099,9 @@ dhdsdio_readframes(dhd_bus_t *bus, uint maxframes, bool *finished)
 
 #ifdef DHDTHREAD
 		/* tx more to improve rx performance */
-		if ((bus->clkstate == CLK_AVAIL) && !bus->fcstate &&
+		if (TXCTLOK(bus) && bus->ctrl_frame_stat && (bus->clkstate == CLK_AVAIL)) {
+			dhdsdio_sendpendctl(bus);
+		} else if ((bus->clkstate == CLK_AVAIL) && !bus->fcstate &&
 			pktq_mlen(&bus->txq, ~bus->flowcontrol) && DATAOK(bus)) {
 			dhdsdio_sendfromq(bus, dhd_txbound);
 		}
@@ -4487,7 +5223,7 @@ dhdsdio_readframes(dhd_bus_t *bus, uint maxframes, bool *finished)
 			dhd_os_sdunlock_rxq(bus->dhd);
 
 			/* Now check the header */
-			bcopy(rxbuf, bus->rxhdr, SDPCM_HDRLEN);
+			bcopy(rxbuf, bus->rxhdr, SDPCM_HDRLEN_RX);
 
 			/* Extract hardware header fields */
 			len = ltoh16_ua(bus->rxhdr);
@@ -4519,7 +5255,7 @@ dhdsdio_readframes(dhd_bus_t *bus, uint maxframes, bool *finished)
 			}
 
 			/* Validate frame length */
-			if (len < SDPCM_HDRLEN) {
+			if (len < SDPCM_HDRLEN_RX) {
 				DHD_ERROR(("%s (nextlen): HW hdr length invalid: %d\n",
 				           __FUNCTION__, len));
 				dhd_os_sdlock_rxq(bus->dhd);
@@ -4599,7 +5335,7 @@ dhdsdio_readframes(dhd_bus_t *bus, uint maxframes, bool *finished)
 			if (DHD_BYTES_ON() && DHD_DATA_ON()) {
 				prhex("Rx Data", rxbuf, len);
 			} else if (DHD_HDRS_ON()) {
-				prhex("RxHdr", bus->rxhdr, SDPCM_HDRLEN);
+				prhex("RxHdr", bus->rxhdr, SDPCM_HDRLEN_RX);
 			}
 #endif
 
@@ -4632,9 +5368,9 @@ dhdsdio_readframes(dhd_bus_t *bus, uint maxframes, bool *finished)
 			}
 
 			/* Validate data offset */
-			if ((doff < SDPCM_HDRLEN) || (doff > len)) {
+			if ((doff < SDPCM_HDRLEN_RX) || (doff > len)) {
 				DHD_ERROR(("%s (nextlen): bad data offset %d: HW len %d min %d\n",
-				           __FUNCTION__, doff, len, SDPCM_HDRLEN));
+				           __FUNCTION__, doff, len, SDPCM_HDRLEN_RX));
 				dhd_os_sdlock_rxq(bus->dhd);
 				PKTFREE2();
 				dhd_os_sdunlock_rxq(bus->dhd);
@@ -4666,7 +5402,7 @@ dhdsdio_readframes(dhd_bus_t *bus, uint maxframes, bool *finished)
 
 #ifdef DHD_DEBUG
 		if (DHD_BYTES_ON() || DHD_HDRS_ON()) {
-			prhex("RxHdr", bus->rxhdr, SDPCM_HDRLEN);
+			prhex("RxHdr", bus->rxhdr, SDPCM_HDRLEN_RX);
 		}
 #endif
 
@@ -4690,7 +5426,7 @@ dhdsdio_readframes(dhd_bus_t *bus, uint maxframes, bool *finished)
 		}
 
 		/* Validate frame length */
-		if (len < SDPCM_HDRLEN) {
+		if (len < SDPCM_HDRLEN_RX) {
 			DHD_ERROR(("%s: HW hdr length invalid: %d\n", __FUNCTION__, len));
 			continue;
 		}
@@ -4702,9 +5438,9 @@ dhdsdio_readframes(dhd_bus_t *bus, uint maxframes, bool *finished)
 		txmax = SDPCM_WINDOW_VALUE(&bus->rxhdr[SDPCM_FRAMETAG_LEN]);
 
 		/* Validate data offset */
-		if ((doff < SDPCM_HDRLEN) || (doff > len)) {
+		if ((doff < SDPCM_HDRLEN_RX) || (doff > len)) {
 			DHD_ERROR(("%s: Bad data offset %d: HW len %d, min %d seq %d\n",
-			           __FUNCTION__, doff, len, SDPCM_HDRLEN, seq));
+			           __FUNCTION__, doff, len, SDPCM_HDRLEN_RX, seq));
 			bus->rx_badhdr++;
 			ASSERT(0);
 			dhdsdio_rxfail(bus, FALSE, FALSE);
@@ -4845,8 +5581,8 @@ deliver:
 				}
 #endif
 				PKTSETLEN(osh, pkt, len);
-				ASSERT(doff == SDPCM_HDRLEN);
-				PKTPULL(osh, pkt, SDPCM_HDRLEN);
+				ASSERT(doff == SDPCM_HDRLEN_RX);
+				PKTPULL(osh, pkt, SDPCM_HDRLEN_RX);
 				bus->glomd = pkt;
 			} else {
 				DHD_ERROR(("%s: glom superframe w/o descriptor!\n", __FUNCTION__));
@@ -4891,7 +5627,6 @@ deliver:
 		else
 			pkt_count = 1;
 
-
 		/* Unlock during rx call */
 		dhd_os_sdunlock(bus->dhd);
 		dhd_rx_frame(bus->dhd, ifidx, pkt, pkt_count, chan);
@@ -5000,8 +5735,9 @@ dhdsdio_hostmail(dhd_bus_t *bus)
 #ifdef DHD_DEBUG
 	/* At least print a message if FW halted */
 	if (hmb_data & HMB_DATA_FWHALT) {
-		DHD_ERROR(("INTERNAL ERROR: FIRMWARE HALTED\n"));
+		DHD_ERROR(("INTERNAL ERROR: FIRMWARE HALTED : set BUS DOWN\n"));
 		dhdsdio_checkdied(bus, NULL, 0);
+		bus->dhd->busstate = DHD_BUS_DOWN;
 	}
 #endif /* DHD_DEBUG */
 
@@ -5198,50 +5934,34 @@ clkwait:
 		          __FUNCTION__, rxdone, framecnt));
 		bus->intdis = FALSE;
 #if defined(OOB_INTR_ONLY)
-	bcmsdh_oob_intr_set(1);
-#endif /* (OOB_INTR_ONLY) */
+		bcmsdh_oob_intr_set(1);
+#endif /* defined(OOB_INTR_ONLY) */
 		bcmsdh_intr_enable(sdh);
 	}
 
-	if (TXCTLOK(bus) && bus->ctrl_frame_stat && (bus->clkstate == CLK_AVAIL))  {
-		int ret, i;
-
-		ret = dhd_bcmsdh_send_buf(bus, bcmsdh_cur_sbwad(sdh), SDIO_FUNC_2, F2SYNC,
-		                      (uint8 *)bus->ctrl_frame_buf, (uint32)bus->ctrl_frame_len,
-			NULL, NULL, NULL);
-		ASSERT(ret != BCME_PENDING);
-		if (ret == BCME_NODEVICE) {
-			DHD_ERROR(("%s: Device asleep already\n", __FUNCTION__));
-		} else if (ret < 0) {
-			/* On failure, abort the command and terminate the frame */
-			DHD_INFO(("%s: sdio error %d, abort command and terminate frame.\n",
-			          __FUNCTION__, ret));
-			bus->tx_sderrs++;
-
-			bcmsdh_abort(sdh, SDIO_FUNC_2);
+#if defined(OOB_INTR_ONLY) && !defined(HW_OOB)
+	/* In case of SW-OOB(using edge trigger),
+	 * Check interrupt status in the dongle again after enable irq on the host.
+	 * and rechedule dpc if interrupt is pended in the dongle.
+	 * There is a chance to miss OOB interrupt while irq is disabled on the host.
+	 * No need to do this with HW-OOB(level trigger)
+	 */
+	R_SDREG(newstatus, &regs->intstatus, retries);
+	if (bcmsdh_regfail(bus->sdh))
+		newstatus = 0;
+	if (newstatus & bus->hostintmask) {
+		bus->ipend = TRUE;
+		resched = TRUE;
+	}
+#endif /* defined(OOB_INTR_ONLY) && !defined(HW_OOB) */
 
-			bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_FRAMECTRL,
-			                 SFC_WF_TERM, NULL);
-			bus->f1regdata++;
+#ifdef PROP_TXSTATUS
+	dhd_wlfc_trigger_pktcommit(bus->dhd);
+#endif
 
-			for (i = 0; i < 3; i++) {
-				uint8 hi, lo;
-				hi = bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
-				                     SBSDIO_FUNC1_WFRAMEBCHI, NULL);
-				lo = bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
-				                     SBSDIO_FUNC1_WFRAMEBCLO, NULL);
-				bus->f1regdata += 2;
-				if ((hi == 0) && (lo == 0))
-					break;
-			}
-		}
-		if (ret == 0) {
-			bus->tx_seq = (bus->tx_seq + 1) % SDPCM_SEQUENCE_WRAP;
-		}
+	if (TXCTLOK(bus) && bus->ctrl_frame_stat && (bus->clkstate == CLK_AVAIL))
+		dhdsdio_sendpendctl(bus);
 
-		bus->ctrl_frame_stat = FALSE;
-		dhd_wait_event_wakeup(bus->dhd);
-	}
 	/* Send queued frames (limit 1 if rx may still be pending) */
 	else if ((bus->clkstate == CLK_AVAIL) && !bus->fcstate &&
 	    pktq_mlen(&bus->txq, ~bus->flowcontrol) && txlimit && DATAOK(bus)) {
@@ -5256,7 +5976,7 @@ clkwait:
 	/* Resched if events or tx frames are pending, else await next interrupt */
 	/* On failed register access, all bets are off: no resched or interrupts */
 	if ((bus->dhd->busstate == DHD_BUS_DOWN) || bcmsdh_regfail(sdh)) {
-		if ((bus->sih->buscorerev >= 12) && !(dhdsdio_sleepcsr_get(bus) &
+		if ((bus->sih && bus->sih->buscorerev >= 12) && !(dhdsdio_sleepcsr_get(bus) &
 			SBSDIO_FUNC1_SLEEPCSR_KSO_MASK)) {
 			/* Bus failed because of KSO */
 			DHD_ERROR(("%s: Bus failed due to KSO\n", __FUNCTION__));
@@ -5284,6 +6004,12 @@ clkwait:
 	}
 
 exit:
+
+	if (!resched && dhd_dpcpoll) {
+		if (dhdsdio_readframes(bus, dhd_rxbound, &rxdone) != 0)
+			resched = TRUE;
+	}
+
 	dhd_os_sdunlock(bus->dhd);
 	return resched;
 }
@@ -5351,8 +6077,10 @@ dhdsdio_isr(void *arg)
 	while (dhdsdio_dpc(bus));
 	DHD_OS_WAKE_UNLOCK(bus->dhd);
 #else
+
 	bus->dpc_sched = TRUE;
 	dhd_sched_dpc(bus->dhd);
+
 #endif 
 
 }
@@ -5373,7 +6101,7 @@ dhdsdio_pktgen_init(dhd_bus_t *bus)
 
 	/* Default to per-watchdog burst with 10s print time */
 	bus->pktgen_freq = 1;
-	bus->pktgen_print = dhd_watchdog_ms ? 10000 / dhd_watchdog_ms : 0;
+	bus->pktgen_print = dhd_watchdog_ms ? (10000 / dhd_watchdog_ms) : 0;
 	bus->pktgen_count = (dhd_pktgen * dhd_watchdog_ms + 999) / 1000;
 
 	/* Default to echo mode */
@@ -5390,19 +6118,37 @@ dhdsdio_pktgen(dhd_bus_t *bus)
 	uint fillbyte;
 	osl_t *osh = bus->dhd->osh;
 	uint16 len;
+	ulong time_lapse;
+	uint sent_pkts;
+	uint rcvd_pkts;
 
 	/* Display current count if appropriate */
 	if (bus->pktgen_print && (++bus->pktgen_ptick >= bus->pktgen_print)) {
 		bus->pktgen_ptick = 0;
-		printf("%s: send attempts %d rcvd %d\n",
-		       __FUNCTION__, bus->pktgen_sent, bus->pktgen_rcvd);
+		printf("%s: send attempts %d, rcvd %d, errors %d\n",
+		       __FUNCTION__, bus->pktgen_sent, bus->pktgen_rcvd, bus->pktgen_fail);
+
+		/* Print throughput stats only for constant length packet runs */
+		if (bus->pktgen_minlen == bus->pktgen_maxlen) {
+			time_lapse = jiffies - bus->pktgen_prev_time;
+			bus->pktgen_prev_time = jiffies;
+			sent_pkts = bus->pktgen_sent - bus->pktgen_prev_sent;
+			bus->pktgen_prev_sent = bus->pktgen_sent;
+			rcvd_pkts = bus->pktgen_rcvd - bus->pktgen_prev_rcvd;
+			bus->pktgen_prev_rcvd = bus->pktgen_rcvd;
+
+			printf("%s: Tx Throughput %d kbps, Rx Throughput %d kbps\n",
+			  __FUNCTION__,
+			  (sent_pkts * bus->pktgen_len / jiffies_to_msecs(time_lapse)) * 8,
+			  (rcvd_pkts * bus->pktgen_len  / jiffies_to_msecs(time_lapse)) * 8);
+		}
 	}
 
 	/* For recv mode, just make sure dongle has started sending */
 	if (bus->pktgen_mode == DHD_PKTGEN_RECV) {
 		if (bus->pktgen_rcv_state == PKTGEN_RCV_IDLE) {
 			bus->pktgen_rcv_state = PKTGEN_RCV_ONGOING;
-			dhdsdio_sdtest_set(bus, (uint8)bus->pktgen_total);
+			dhdsdio_sdtest_set(bus, bus->pktgen_total);
 		}
 		return;
 	}
@@ -5416,7 +6162,11 @@ dhdsdio_pktgen(dhd_bus_t *bus)
 		}
 
 		/* Allocate an appropriate-sized packet */
-		len = bus->pktgen_len;
+		if (bus->pktgen_mode == DHD_PKTGEN_RXBURST) {
+			len = SDPCM_TEST_PKT_CNT_FLD_LEN;
+		} else {
+			len = bus->pktgen_len;
+		}
 		if (!(pkt = PKTGET(osh, (len + SDPCM_HDRLEN + SDPCM_TEST_HDRLEN + DHD_SDALIGN),
 		                   TRUE))) {;
 			DHD_ERROR(("%s: PKTGET failed!\n", __FUNCTION__));
@@ -5439,7 +6189,7 @@ dhdsdio_pktgen(dhd_bus_t *bus)
 
 		case DHD_PKTGEN_RXBURST:
 			*data++ = SDPCM_TEST_BURST;
-			*data++ = (uint8)bus->pktgen_count;
+			*data++ = (uint8)bus->pktgen_count; /* Just for backward compatability */
 			break;
 
 		default:
@@ -5450,12 +6200,23 @@ dhdsdio_pktgen(dhd_bus_t *bus)
 		}
 
 		/* Write test header length field */
-		*data++ = (len >> 0);
-		*data++ = (len >> 8);
+		*data++ = (bus->pktgen_len >> 0);
+		*data++ = (bus->pktgen_len >> 8);
+
+		/* Write frame count in a 4 byte field adjucent to SDPCM test header for
+		 * burst mode
+		 */
+		if (bus->pktgen_mode == DHD_PKTGEN_RXBURST) {
+			*data++ = (uint8)(bus->pktgen_count >> 0);
+			*data++ = (uint8)(bus->pktgen_count >> 8);
+			*data++ = (uint8)(bus->pktgen_count >> 16);
+			*data++ = (uint8)(bus->pktgen_count >> 24);
+		} else {
 
-		/* Then fill in the remainder -- N/A for burst, but who cares... */
-		for (fillbyte = 0; fillbyte < len; fillbyte++)
-			*data++ = SDPCM_TEST_FILL(fillbyte, (uint8)bus->pktgen_sent);
+			/* Then fill in the remainder -- N/A for burst */
+			for (fillbyte = 0; fillbyte < len; fillbyte++)
+				*data++ = SDPCM_TEST_FILL(fillbyte, (uint8)bus->pktgen_sent);
+		}
 
 #ifdef DHD_DEBUG
 		if (DHD_BYTES_ON() && DHD_DATA_ON()) {
@@ -5465,7 +6226,7 @@ dhdsdio_pktgen(dhd_bus_t *bus)
 #endif
 
 		/* Send it */
-		if (dhdsdio_txpkt(bus, pkt, SDPCM_TEST_CHANNEL, TRUE)) {
+		if (dhdsdio_txpkt(bus, pkt, SDPCM_TEST_CHANNEL, TRUE, FALSE)) {
 			bus->pktgen_fail++;
 			if (bus->pktgen_stop && bus->pktgen_stop == bus->pktgen_fail)
 				bus->pktgen_count = 0;
@@ -5483,28 +6244,34 @@ dhdsdio_pktgen(dhd_bus_t *bus)
 }
 
 static void
-dhdsdio_sdtest_set(dhd_bus_t *bus, uint8 count)
+dhdsdio_sdtest_set(dhd_bus_t *bus, uint count)
 {
 	void *pkt;
 	uint8 *data;
 	osl_t *osh = bus->dhd->osh;
 
 	/* Allocate the packet */
-	if (!(pkt = PKTGET(osh, SDPCM_HDRLEN + SDPCM_TEST_HDRLEN + DHD_SDALIGN, TRUE))) {
+	if (!(pkt = PKTGET(osh, SDPCM_HDRLEN + SDPCM_TEST_HDRLEN +
+		SDPCM_TEST_PKT_CNT_FLD_LEN + DHD_SDALIGN, TRUE))) {
 		DHD_ERROR(("%s: PKTGET failed!\n", __FUNCTION__));
 		return;
 	}
-	PKTALIGN(osh, pkt, (SDPCM_HDRLEN + SDPCM_TEST_HDRLEN), DHD_SDALIGN);
+	PKTALIGN(osh, pkt, (SDPCM_HDRLEN + SDPCM_TEST_HDRLEN +
+		SDPCM_TEST_PKT_CNT_FLD_LEN), DHD_SDALIGN);
 	data = (uint8*)PKTDATA(osh, pkt) + SDPCM_HDRLEN;
 
 	/* Fill in the test header */
 	*data++ = SDPCM_TEST_SEND;
-	*data++ = count;
+	*data++ = (count > 0)?TRUE:FALSE;
 	*data++ = (bus->pktgen_maxlen >> 0);
 	*data++ = (bus->pktgen_maxlen >> 8);
+	*data++ = (uint8)(count >> 0);
+	*data++ = (uint8)(count >> 8);
+	*data++ = (uint8)(count >> 16);
+	*data++ = (uint8)(count >> 24);
 
 	/* Send it */
-	if (dhdsdio_txpkt(bus, pkt, SDPCM_TEST_CHANNEL, TRUE))
+	if (dhdsdio_txpkt(bus, pkt, SDPCM_TEST_CHANNEL, TRUE, FALSE))
 		bus->pktgen_fail++;
 }
 
@@ -5549,7 +6316,7 @@ dhdsdio_testrcv(dhd_bus_t *bus, void *pkt, uint seq)
 	case SDPCM_TEST_ECHOREQ:
 		/* Rx->Tx turnaround ok (even on NDIS w/current implementation) */
 		*(uint8 *)(PKTDATA(osh, pkt)) = SDPCM_TEST_ECHORSP;
-		if (dhdsdio_txpkt(bus, pkt, SDPCM_TEST_CHANNEL, TRUE) == 0) {
+		if (dhdsdio_txpkt(bus, pkt, SDPCM_TEST_CHANNEL, TRUE, FALSE) == 0) {
 			bus->pktgen_sent++;
 		} else {
 			bus->pktgen_fail++;
@@ -5703,15 +6470,36 @@ dhd_bus_watchdog(dhd_pub_t *dhdp)
 	/* Generate packets if configured */
 	if (bus->pktgen_count && (++bus->pktgen_tick >= bus->pktgen_freq)) {
 		/* Make sure backplane clock is on */
-		dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
+		if (SLPAUTO_ENAB(bus))
+			dhdsdio_bussleep(bus, FALSE);
+		else
+			dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
 		bus->pktgen_tick = 0;
 		dhdsdio_pktgen(bus);
 	}
 #endif
 
 	/* On idle timeout clear activity flag and/or turn off clock */
+#ifdef DHD_USE_IDLECOUNT
+	if (bus->activity)
+		bus->activity = FALSE;
+	else {
+		bus->idlecount++;
+
+		if (bus->idlecount >= bus->idletime) {
+			DHD_TIMER(("%s: DHD Idle state!!\n", __FUNCTION__));
+			if (SLPAUTO_ENAB(bus)) {
+				if (dhdsdio_bussleep(bus, TRUE) != BCME_BUSY)
+					dhd_os_wd_timer(bus->dhd, 0);
+			} else
+				dhdsdio_clkctl(bus, CLK_NONE, FALSE);
+
+			bus->idlecount = 0;
+		}
+	}
+#else
 	if ((bus->idletime > 0) && (bus->clkstate == CLK_AVAIL)) {
-		if (++bus->idlecount >= bus->idletime) {
+		if (++bus->idlecount > bus->idletime) {
 			bus->idlecount = 0;
 			if (bus->activity) {
 				bus->activity = FALSE;
@@ -5726,6 +6514,7 @@ dhd_bus_watchdog(dhd_pub_t *dhdp)
 			}
 		}
 	}
+#endif /* DHD_USE_IDLECOUNT */
 
 	return bus->ipend;
 }
@@ -5778,7 +6567,7 @@ dhd_bus_console_in(dhd_pub_t *dhdp, uchar *msg, uint msglen)
 	 * sdpcm_sendup (RX) checks for virtual console input.
 	 */
 	if ((pkt = PKTGET(bus->dhd->osh, 4 + SDPCM_RESERVE, TRUE)) != NULL)
-		dhdsdio_txpkt(bus, pkt, SDPCM_EVENT_CHANNEL, TRUE);
+		dhdsdio_txpkt(bus, pkt, SDPCM_EVENT_CHANNEL, TRUE, FALSE);
 
 done:
 	if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
@@ -5843,6 +6632,16 @@ dhdsdio_chipmatch(uint16 chipid)
 		return TRUE;
 	if (chipid == BCM4314_CHIP_ID)
 		return TRUE;
+	if (chipid == BCM43242_CHIP_ID)
+		return TRUE;
+    if (chipid == BCM43340_CHIP_ID)
+		return TRUE;
+	if (chipid == BCM43341_CHIP_ID)
+		return TRUE;
+	if (chipid == BCM43143_CHIP_ID)
+		return TRUE;
+	if (chipid == BCM43342_CHIP_ID)
+		return TRUE;
 	if (chipid == BCM4334_CHIP_ID)
 		return TRUE;
 	if (chipid == BCM43239_CHIP_ID)
@@ -5851,6 +6650,10 @@ dhdsdio_chipmatch(uint16 chipid)
 		return TRUE;
 	if (chipid == BCM4335_CHIP_ID)
 		return TRUE;
+	if (chipid == BCM4339_CHIP_ID)
+		return TRUE;
+	if (chipid == BCM4350_CHIP_ID)
+		return TRUE;
 	return FALSE;
 }
 
@@ -5864,6 +6667,18 @@ dhdsdio_probe(uint16 venid, uint16 devid, uint16 bus_no, uint16 slot,
 	struct ether_addr ea_addr;
 #endif /* GET_CUSTOM_MAC_ENABLE */
 
+#if defined(MULTIPLE_SUPPLICANT)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25))
+	if (mutex_is_locked(&_dhd_sdio_mutex_lock_) == 0) {
+		DHD_ERROR(("%s : no mutex held. set lock\n", __FUNCTION__));
+	}
+	else {
+		DHD_ERROR(("%s : mutex is locked!. wait for unlocking\n", __FUNCTION__));
+	}
+	mutex_lock(&_dhd_sdio_mutex_lock_);
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) */
+#endif /* LINUX */
+
 	/* Init global variables at run-time, not as part of the declaration.
 	 * This is required to support init/de-init of the driver. Initialization
 	 * of globals as part of the declaration results in non-deterministic
@@ -5876,8 +6691,12 @@ dhdsdio_probe(uint16 venid, uint16 devid, uint16 bus_no, uint16 slot,
 	sd1idle = TRUE;
 	dhd_readahead = TRUE;
 	retrydata = FALSE;
+#if !defined(PLATFORM_MPS)
 	dhd_doflow = FALSE;
-	dhd_dongle_memsize = 0;
+#else
+	dhd_doflow = TRUE;
+#endif /* OEM_ANDROID */
+	dhd_dongle_ramsize = 0;
 	dhd_txminmax = DHD_TXMINMAX;
 
 	forcealign = TRUE;
@@ -5900,7 +6719,7 @@ dhdsdio_probe(uint16 venid, uint16 devid, uint16 bus_no, uint16 slot,
 		default:
 			DHD_ERROR(("%s: unknown vendor: 0x%04x\n",
 			           __FUNCTION__, venid));
-			return NULL;
+			goto forcereturn;
 	}
 
 	/* Check the Device ID and make sure it's one that we support */
@@ -5934,14 +6753,14 @@ dhdsdio_probe(uint16 venid, uint16 devid, uint16 bus_no, uint16 slot,
 		default:
 			DHD_ERROR(("%s: skipping 0x%04x/0x%04x, not a dongle\n",
 			           __FUNCTION__, venid, devid));
-			return NULL;
+			goto forcereturn;
 	}
 
 	if (osh == NULL) {
 		/* Ask the OS interface part for an OSL handle */
 		if (!(osh = dhd_osl_attach(sdh, DHD_BUS))) {
 			DHD_ERROR(("%s: osl_attach failed!\n", __FUNCTION__));
-			return NULL;
+			goto forcereturn;
 		}
 	}
 
@@ -6010,24 +6829,321 @@ dhdsdio_probe(uint16 venid, uint16 devid, uint16 bus_no, uint16 slot,
 #endif /* GET_CUSTOM_MAC_ENABLE */
 
 	/* if firmware path present try to download and bring up bus */
-	if (dhd_download_fw_on_driverload && (ret = dhd_bus_start(bus->dhd)) != 0) {
-		DHD_ERROR(("%s: dhd_bus_start failed\n", __FUNCTION__));
-		if (ret == BCME_NOTUP)
-			goto fail;
+	bus->dhd->hang_report  = TRUE;
+	if (dhd_download_fw_on_driverload) {
+		if ((ret = dhd_bus_start(bus->dhd)) != 0) {
+			DHD_ERROR(("%s: dhd_bus_start failed\n", __FUNCTION__));
+				goto fail;
 		}
+	}
 	/* Ok, have the per-port tell the stack we're open for business */
 	if (dhd_net_attach(bus->dhd, 0) != 0) {
 		DHD_ERROR(("%s: Net attach failed!!\n", __FUNCTION__));
 		goto fail;
 	}
 
+
+#if defined(MULTIPLE_SUPPLICANT)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25))
+	mutex_unlock(&_dhd_sdio_mutex_lock_);
+	DHD_ERROR(("%s : the lock is released.\n", __FUNCTION__));
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
+#endif /* LINUX */
+
 	return bus;
 
 fail:
 	dhdsdio_release(bus, osh);
+
+forcereturn:
+#if defined(MULTIPLE_SUPPLICANT)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25))
+	mutex_unlock(&_dhd_sdio_mutex_lock_);
+	DHD_ERROR(("%s : the lock is released.\n", __FUNCTION__));
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
+#endif /* LINUX */
+
 	return NULL;
 }
 
+#ifdef REGON_BP_HANG_FIX
+static int dhd_sdio_backplane_reset(struct dhd_bus *bus)
+{
+	uint32 temp = 0;
+	DHD_ERROR(("Resetting  the backplane to avoid failure in firmware download..\n"));
+
+	temp = bcmsdh_reg_read(bus->sdh, 0x180021e0, 4);
+	DHD_INFO(("SDIO Clk Control Reg = %x\n", temp));
+
+	/* Force HT req from PMU */
+	bcmsdh_reg_write(bus->sdh, 0x18000644, 4, 0x6000005);
+
+	/* Increase the clock stretch duration. */
+	bcmsdh_reg_write(bus->sdh, 0x18000630, 4, 0xC8FFC8);
+
+	/* Setting ALP clock request in SDIOD clock control status register */
+	bcmsdh_reg_write(bus->sdh, 0x180021e0, 4, 0x41);
+
+	/* Allowing clock from SR engine to SR memory */
+	bcmsdh_reg_write(bus->sdh, 0x18004400, 4, 0xf92f1);
+	/* Disabling SR Engine before SR binary download. */
+	bcmsdh_reg_write(bus->sdh, 0x18000650, 4, 0x3);
+	bcmsdh_reg_write(bus->sdh, 0x18000654, 4, 0x0);
+
+	/* Enabling clock from backplane to SR memory */
+	bcmsdh_reg_write(bus->sdh, 0x18004400, 4, 0xf9af1);
+
+	/* Initializing SR memory address register in SOCRAM */
+	bcmsdh_reg_write(bus->sdh, 0x18004408, 4, 0x0);
+
+	/* Downloading the SR binary */
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0xc0002000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x80008000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x1051f080);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x80008000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x1050f080);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x80008000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x1050f080);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x80008000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x1050f080);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000004);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x30a00000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000604);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x30a00000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00001604);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x30a00000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00001404);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x30a08c80);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00010001);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x14a00000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00011404);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x30a00000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00002000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x04a00000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00002000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0xf8000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00002000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x04a00000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00002000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0xf8000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00011604);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x30a00000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00010604);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x30a00000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00010004);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x30a00000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00010000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x14a00000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000004);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x30a00000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00010001);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x14a00000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00010004);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x30a00000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00010000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x30a00000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00010000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x14a00000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x30a00000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000008);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x04a00000);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0x00000008);
+	bcmsdh_reg_write(bus->sdh, 0x1800440c, 4, 0xfc000000);
+	/* SR Binary Download complete */
+
+	/* Allowing clock from SR engine to SR memory */
+	bcmsdh_reg_write(bus->sdh, 0x18004400, 4, 0xf92f1);
+
+	/* Turning ON SR Engine to initiate backplane reset  Repeated ?? Maharana */
+	bcmsdh_reg_write(bus->sdh, 0x18000650, 4, 0x3);
+	bcmsdh_reg_write(bus->sdh, 0x18000654, 4, 0x0);
+	bcmsdh_reg_write(bus->sdh, 0x18000650, 4, 0x3);
+	bcmsdh_reg_write(bus->sdh, 0x18000654, 4, 0x2);
+	bcmsdh_reg_write(bus->sdh, 0x18000650, 4, 0x3);
+	bcmsdh_reg_write(bus->sdh, 0x18000654, 4, 0x3);
+	bcmsdh_reg_write(bus->sdh, 0x18000650, 4, 0x3);
+	bcmsdh_reg_write(bus->sdh, 0x18000654, 4, 0x37);
+	bcmsdh_reg_write(bus->sdh, 0x18000650, 4, 0x3);
+	temp = bcmsdh_reg_read(bus->sdh, 0x18000654, 4);
+	DHD_INFO(("0x18000654 = %x\n", temp));
+	bcmsdh_reg_write(bus->sdh, 0x18000654, 4, 0x800037);
+	OSL_DELAY(100000);
+	/* Rolling back the original values for clock stretch and PMU timers */
+	bcmsdh_reg_write(bus->sdh, 0x18000644, 4, 0x0);
+	bcmsdh_reg_write(bus->sdh, 0x18000630, 4, 0xC800C8);
+	/* Removing ALP clock request in SDIOD clock control status register */
+	bcmsdh_reg_write(bus->sdh, 0x180021e0, 4, 0x40);
+	OSL_DELAY(10000);
+	return TRUE;
+}
+
+static int dhdsdio_sdio_hang_war(struct dhd_bus *bus)
+{
+	uint32 temp = 0, temp2 = 0, counter = 0, BT_pwr_up = 0, BT_ready = 0;
+	/* Removing reset of D11 Core */
+	bcmsdh_reg_write(bus->sdh, 0x18101408, 4, 0x3);
+	bcmsdh_reg_write(bus->sdh, 0x18101800, 4, 0x0);
+	bcmsdh_reg_write(bus->sdh, 0x18101408, 4, 0x1);
+	/* Reading CLB XTAL BT cntrl register */
+	bcmsdh_reg_write(bus->sdh, 0x180013D8, 2, 0xD1);
+	bcmsdh_reg_write(bus->sdh, 0x180013DA, 2, 0x12);
+	bcmsdh_reg_write(bus->sdh, 0x180013D8, 2, 0x2D0);
+	/* Read if BT is powered up */
+	temp = bcmsdh_reg_read(bus->sdh, 0x180013DA, 2);
+	/* Read BT_ready from WLAN wireless register */
+	temp2 = bcmsdh_reg_read(bus->sdh, 0x1800002C, 4);
+	/*
+	Check if the BT is powered up and ready. The duration between BT being powered up
+	and BT becoming ready is the problematic window for WLAN. If we move ahead at this
+	time then we may encounter a corrupted backplane later. So we wait for BT to be ready
+	and then proceed after checking the health of the backplane. If the backplane shows
+	indications of failure then we	have to do a full reset of the backplane using SR engine
+	and then proceed.
+	*/
+	(temp & 0xF0) ? (BT_pwr_up = 1):(BT_pwr_up = 0);
+	(temp2 & (1<<17)) ? (BT_ready = 1):(BT_ready = 0);
+	DHD_ERROR(("WARNING: Checking if BT is ready BT_pwr_up = %x"
+		"BT_ready = %x \n", BT_pwr_up, BT_ready));
+	while (BT_pwr_up && !BT_ready)
+	{
+		OSL_DELAY(1000);
+		bcmsdh_reg_write(bus->sdh, 0x180013D8, 2, 0x2D0);
+		temp = bcmsdh_reg_read(bus->sdh, 0x180013DA, 2);
+		temp2 = bcmsdh_reg_read(bus->sdh, 0x1800002C, 4);
+		(temp & 0xF0) ? (BT_pwr_up = 1):(BT_pwr_up = 0);
+		(temp2 & (1<<17)) ? (BT_ready = 1):(BT_ready = 0);
+		counter++;
+		if (counter == 5000)
+		{
+			DHD_ERROR(("WARNING: Going ahead after 5 secs with"
+					"risk of failure because BT ready is not yet set\n"));
+			break;
+		}
+	}
+	DHD_ERROR(("\nWARNING: WL Proceeding BT_pwr_up = %x BT_ready = %x"
+			"\n", BT_pwr_up, BT_ready));
+	counter = 0;
+	OSL_DELAY(10000);
+	/*
+	Get the information of who accessed the crucial backplane entities
+	by reading read and write access registers
+	*/
+	DHD_TRACE(("%d: Read Value @ 0x18104808 = %x."
+			"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x18104808, 4)));
+	DHD_TRACE(("%d: Read Value @ 0x1810480C = %x."
+			"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x1810480C, 4)));
+	DHD_TRACE(("%d: Read Value @ 0x18106808 = %x."
+			"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x18106808, 4)));
+	DHD_TRACE(("%d: Read Value @ 0x1810680C = %x."
+			"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x1810680C, 4)));
+	DHD_TRACE(("%d: Read Value @ 0x18107808 = %x."
+			"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x18107808, 4)));
+	DHD_TRACE(("%d: Read Value @ 0x1810780C = %x."
+			"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x1810780C, 4)));
+	DHD_TRACE(("%d: Read Value @ 0x18108808 = %x."
+			"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x18108808, 4)));
+	DHD_TRACE(("%d: Read Value @ 0x1810880C = %x."
+			"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x1810880C, 4)));
+	DHD_TRACE(("%d: Read Value @ 0x18109808 = %x."
+			"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x18109808, 4)));
+	DHD_TRACE(("%d: Read Value @ 0x1810980C = %x."
+			"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x1810980C, 4)));
+	DHD_TRACE(("%d: Read Value @ 0x1810C808 = %x."
+			"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x1810c808, 4)));
+	DHD_TRACE(("%d: Read Value @ 0x1810C80C = %x."
+			"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x1810c80C, 4)));
+	counter = 0;
+	while ((bcmsdh_reg_read(bus->sdh, 0x18104808, 4) == 5) ||
+		(bcmsdh_reg_read(bus->sdh, 0x1810480C, 4) == 5) ||
+		(bcmsdh_reg_read(bus->sdh, 0x18106808, 4) == 5) ||
+		(bcmsdh_reg_read(bus->sdh, 0x1810680C, 4) == 5) ||
+		(bcmsdh_reg_read(bus->sdh, 0x1810780C, 4) == 5) ||
+		(bcmsdh_reg_read(bus->sdh, 0x1810780C, 4) == 5) ||
+		(bcmsdh_reg_read(bus->sdh, 0x1810880C, 4) == 5) ||
+		(bcmsdh_reg_read(bus->sdh, 0x1810880C, 4) == 5) ||
+		(bcmsdh_reg_read(bus->sdh, 0x1810980C, 4) == 5) ||
+		(bcmsdh_reg_read(bus->sdh, 0x1810980C, 4) == 5) ||
+		(bcmsdh_reg_read(bus->sdh, 0x1810C80C, 4) == 5) ||
+		(bcmsdh_reg_read(bus->sdh, 0x1810C80C, 4) == 5))
+	{
+		if (++counter > 10)
+		{
+			DHD_ERROR(("Unable to recover the backkplane corruption"
+					"..Tried %d times.. Exiting\n", counter));
+			break;
+		}
+		OSL_DELAY(10000);
+		dhd_sdio_backplane_reset(bus);
+		/*
+		Get the information of who accessed the crucial backplane
+		entities by reading read and write access registers
+		*/
+		DHD_ERROR(("%d: Read Value @ 0x18104808 = %x."
+				"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x18104808, 4)));
+		DHD_ERROR(("%d: Read Value @ 0x1810480C = %x."
+				"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x1810480C, 4)));
+		DHD_ERROR(("%d: Read Value @ 0x18106808 = %x."
+				"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x18106808, 4)));
+		DHD_ERROR(("%d: Read Value @ 0x1810680C = %x."
+				"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x1810680C, 4)));
+		DHD_ERROR(("%d: Read Value @ 0x18107808 = %x."
+				"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x18107808, 4)));
+		DHD_ERROR(("%d: Read Value @ 0x1810780C = %x."
+				"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x1810780C, 4)));
+		DHD_ERROR(("%d: Read Value @ 0x18108808 = %x."
+				"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x18108808, 4)));
+		DHD_ERROR(("%d: Read Value @ 0x1810880C = %x."
+				"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x1810880C, 4)));
+		DHD_ERROR(("%d: Read Value @ 0x18109808 = %x."
+				"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x18109808, 4)));
+		DHD_ERROR(("%d: Read Value @ 0x1810980C = %x."
+				"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x1810980C, 4)));
+		DHD_ERROR(("%d: Read Value @ 0x1810C808 = %x."
+				"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x1810c808, 4)));
+		DHD_ERROR(("%d: Read Value @ 0x1810C80C = %x."
+				"\n", __LINE__, bcmsdh_reg_read(bus->sdh, 0x1810c80C, 4)));
+	}
+	/* Set the WL ready to indicate BT that we are done with backplane reset */
+	DHD_ERROR(("Setting up AXI_OK\n"));
+	bcmsdh_reg_write(bus->sdh, 0x18000658, 4, 0x3);
+	temp = bcmsdh_reg_read(bus->sdh, 0x1800065c, 4);
+	temp |= 0x80000000;
+	bcmsdh_reg_write(bus->sdh, 0x1800065c, 4, temp);
+	return TRUE;
+}
+#endif /* REGON_BP_HANG_FIX */
 static bool
 dhdsdio_probe_attach(struct dhd_bus *bus, osl_t *osh, void *sdh, void *regsva,
                      uint16 devid)
@@ -6117,6 +7233,12 @@ dhdsdio_probe_attach(struct dhd_bus *bus, osl_t *osh, void *sdh, void *regsva,
 		goto fail;
 	}
 
+#ifdef REGON_BP_HANG_FIX
+	/* WAR - for 43241 B0-B1-B2. B3 onwards do not need this */
+	if (((uint16)bus->sih->chip == BCM4324_CHIP_ID) && (bus->sih->chiprev < 3))
+			dhdsdio_sdio_hang_war(bus);
+#endif /* REGON_BP_HANG_FIX */
+
 	bcmsdh_chipinfo(sdh, bus->sih->chip, bus->sih->chiprev);
 
 	if (!dhdsdio_chipmatch((uint16)bus->sih->chip)) {
@@ -6139,23 +7261,49 @@ dhdsdio_probe_attach(struct dhd_bus *bus, osl_t *osh, void *sdh, void *regsva,
 	/* Get info on the ARM and SOCRAM cores... */
 	if (!DHD_NOPMU(bus)) {
 		if ((si_setcore(bus->sih, ARM7S_CORE_ID, 0)) ||
-		    (si_setcore(bus->sih, ARMCM3_CORE_ID, 0))) {
+		    (si_setcore(bus->sih, ARMCM3_CORE_ID, 0)) ||
+		    (si_setcore(bus->sih, ARMCR4_CORE_ID, 0))) {
 			bus->armrev = si_corerev(bus->sih);
 		} else {
 			DHD_ERROR(("%s: failed to find ARM core!\n", __FUNCTION__));
 			goto fail;
 		}
-		if (!(bus->orig_ramsize = si_socram_size(bus->sih))) {
-			DHD_ERROR(("%s: failed to find SOCRAM memory!\n", __FUNCTION__));
-			goto fail;
-		}
 
+		if (!si_setcore(bus->sih, ARMCR4_CORE_ID, 0)) {
+			if (!(bus->orig_ramsize = si_socram_size(bus->sih))) {
+				DHD_ERROR(("%s: failed to find SOCRAM memory!\n", __FUNCTION__));
+				goto fail;
+			}
+		} else {
+			/* cr4 has a different way to find the RAM size from TCM's */
+			if (!(bus->orig_ramsize = si_tcm_size(bus->sih))) {
+				DHD_ERROR(("%s: failed to find CR4-TCM memory!\n", __FUNCTION__));
+				goto fail;
+			}
+			/* also populate base address */
+			switch ((uint16)bus->sih->chip) {
+			case BCM4335_CHIP_ID:
+			case BCM4339_CHIP_ID:
+				bus->dongle_ram_base = CR4_4335_RAM_BASE;
+				break;
+			case BCM4350_CHIP_ID:
+				bus->dongle_ram_base = CR4_4350_RAM_BASE;
+				break;
+			case BCM4360_CHIP_ID:
+				bus->dongle_ram_base = CR4_4360_RAM_BASE;
+				break;
+			default:
+				bus->dongle_ram_base = 0;
+				DHD_ERROR(("%s: WARNING: Using default ram base at 0x%x\n",
+				           __FUNCTION__, bus->dongle_ram_base));
+			}
+		}
 		bus->ramsize = bus->orig_ramsize;
-		if (dhd_dongle_memsize)
-			dhd_dongle_setmemsize(bus, dhd_dongle_memsize);
+		if (dhd_dongle_ramsize)
+			dhd_dongle_setramsize(bus, dhd_dongle_ramsize);
 
-		DHD_ERROR(("DHD: dongle ram size is set to %d(orig %d)\n",
-			bus->ramsize, bus->orig_ramsize));
+		DHD_ERROR(("DHD: dongle ram size is set to %d(orig %d) at 0x%x\n",
+		           bus->ramsize, bus->orig_ramsize, bus->dongle_ram_base));
 
 		bus->srmemsize = si_socram_srmem_size(bus->sih);
 	}
@@ -6194,11 +7342,20 @@ dhdsdio_probe_attach(struct dhd_bus *bus, osl_t *osh, void *sdh, void *regsva,
 	if ((bus->poll = (bool)dhd_poll))
 		bus->pollrate = 1;
 
+#ifdef BCMSDIOH_TXGLOM
+	/* Setting default Glom mode */
+	bus->glom_mode = bcmsdh_set_mode(bus->sdh, SDPCM_DEFGLOM_MODE);
+	/* Setting default Glom size */
+	bus->glomsize = SDPCM_DEFGLOM_SIZE;
+#endif
+
 	return TRUE;
 
 fail:
-	if (bus->sih != NULL)
+	if (bus->sih != NULL) {
 		si_detach(bus->sih);
+		bus->sih = NULL;
+	}
 	return FALSE;
 }
 
@@ -6293,6 +7450,11 @@ dhdsdio_probe_init(dhd_bus_t *bus, osl_t *osh, void *sdh)
 	} else {
 		DHD_INFO(("%s: Initial value for %s is %d\n",
 		          __FUNCTION__, "sd_blocksize", bus->blocksize));
+
+		if ((bus->sih->chip == BCM4335_CHIP_ID) ||
+			(bus->sih->chip == BCM4339_CHIP_ID) ||
+			(bus->sih->chip == BCM4350_CHIP_ID))
+			dhd_overflow_war(bus);
 	}
 	bus->roundup = MIN(max_roundup, bus->blocksize);
 
@@ -6423,10 +7585,10 @@ dhdsdio_release_dongle(dhd_bus_t *bus, osl_t *osh, bool dongle_isolation, bool r
 		return;
 
 	if (bus->sih) {
+#if !defined(BCMLXSDMMC)
 		if (bus->dhd) {
 			dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
 		}
-#if !defined(BCMLXSDMMC)
 		if (KSO_ENAB(bus) && (dongle_isolation == FALSE))
 			si_watchdog(bus->sih, 4);
 #endif /* !defined(BCMLXSDMMC) */
@@ -6434,6 +7596,7 @@ dhdsdio_release_dongle(dhd_bus_t *bus, osl_t *osh, bool dongle_isolation, bool r
 			dhdsdio_clkctl(bus, CLK_NONE, FALSE);
 		}
 		si_detach(bus->sih);
+		bus->sih = NULL;
 		if (bus->vars && bus->varsz)
 			MFREE(osh, bus->vars, bus->varsz);
 		bus->vars = NULL;
@@ -6449,11 +7612,32 @@ dhdsdio_disconnect(void *ptr)
 
 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
 
+#if defined(MULTIPLE_SUPPLICANT)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25))
+	if (mutex_is_locked(&_dhd_sdio_mutex_lock_) == 0) {
+		DHD_ERROR(("%s : no mutex held. set lock\n", __FUNCTION__));
+	}
+	else {
+		DHD_ERROR(("%s : mutex is locked!. wait for unlocking\n", __FUNCTION__));
+	}
+	mutex_lock(&_dhd_sdio_mutex_lock_);
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) */
+#endif /* LINUX */
+
+
 	if (bus) {
 		ASSERT(bus->dhd);
 		dhdsdio_release(bus, bus->dhd->osh);
 	}
 
+#if defined(MULTIPLE_SUPPLICANT)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25))
+	mutex_unlock(&_dhd_sdio_mutex_lock_);
+	DHD_ERROR(("%s : the lock is released.\n", __FUNCTION__));
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) */
+#endif /* LINUX */
+
+
 	DHD_TRACE(("%s: Disconnected\n", __FUNCTION__));
 }
 
@@ -6509,6 +7693,17 @@ dhdsdio_download_code_array(struct dhd_bus *bus)
 
 	/* Download image */
 	while ((offset + MEMBLOCK) < sizeof(dlarray)) {
+		/* check if CR4 */
+		if (si_setcore(bus->sih, ARMCR4_CORE_ID, 0)) {
+			/* if address is 0, store the reset instruction to be written in 0 */
+
+			if (offset == 0) {
+				bus->resetinstr = *(((uint32*)dlarray));
+				/* Add start of RAM address to the address given by user */
+				offset += bus->dongle_ram_base;
+			}
+		}
+
 		bcmerror = dhdsdio_membytes(bus, TRUE, offset,
 			(uint8 *) (dlarray + offset), MEMBLOCK);
 		if (bcmerror) {
@@ -6581,7 +7776,7 @@ dhdsdio_download_code_file(struct dhd_bus *bus, char *pfw_path)
 {
 	int bcmerror = -1;
 	int offset = 0;
-	uint len;
+	int len;
 	void *image = NULL;
 	uint8 *memblock = NULL, *memptr;
 
@@ -6601,6 +7796,22 @@ dhdsdio_download_code_file(struct dhd_bus *bus, char *pfw_path)
 
 	/* Download image */
 	while ((len = dhd_os_get_image_block((char*)memptr, MEMBLOCK, image))) {
+		if (len < 0) {
+			DHD_ERROR(("%s: dhd_os_get_image_block failed (%d)\n", __FUNCTION__, len));
+			bcmerror = BCME_ERROR;
+			goto err;
+		}
+		/* check if CR4 */
+		if (si_setcore(bus->sih, ARMCR4_CORE_ID, 0)) {
+			/* if address is 0, store the reset instruction to be written in 0 */
+
+			if (offset == 0) {
+				bus->resetinstr = *(((uint32*)memptr));
+				/* Add start of RAM address to the address given by user */
+				offset += bus->dongle_ram_base;
+			}
+		}
+
 		bcmerror = dhdsdio_membytes(bus, TRUE, offset, memptr, len);
 		if (bcmerror) {
 			DHD_ERROR(("%s: error %d on writing %d membytes at 0x%08x\n",
@@ -6750,6 +7961,7 @@ _dhdsdio_download_firmware(struct dhd_bus *bus)
 			dlok = TRUE;
 		}
 	}
+
 #ifdef BCMEMBEDIMAGE
 	if (embed) {
 		if (dhdsdio_download_code_array(bus)) {
@@ -6818,6 +8030,20 @@ dhd_bcmsdh_send_buf(dhd_bus_t *bus, uint32 addr, uint fn, uint flags, uint8 *buf
 	return (bcmsdh_send_buf(bus->sdh, addr, fn, flags, buf, nbytes, pkt, complete, handle));
 }
 
+#ifdef BCMSDIOH_TXGLOM
+static void
+dhd_bcmsdh_glom_post(dhd_bus_t *bus, uint8 *frame, void *pkt, uint len)
+{
+	bcmsdh_glom_post(bus->sdh, frame, pkt, len);
+}
+
+static void
+dhd_bcmsdh_glom_clear(dhd_bus_t *bus)
+{
+	bcmsdh_glom_clear(bus->sdh);
+}
+#endif
+
 uint
 dhd_bus_chip(struct dhd_bus *bus)
 {
@@ -6866,13 +8092,16 @@ dhd_bus_devreset(dhd_pub_t *dhdp, uint8 flag)
 #if defined(OOB_INTR_ONLY)
 			/* Clean up any pending IRQ */
 			bcmsdh_set_irq(FALSE);
-#endif /* defined(OOB_INTR_ONLY) */
+#endif 
 
 			/* Clean tx/rx buffer pointers, detach from the dongle */
 			dhdsdio_release_dongle(bus, bus->dhd->osh, TRUE, TRUE);
 
 			bus->dhd->dongle_reset = TRUE;
 			bus->dhd->up = FALSE;
+#ifdef BCMSDIOH_TXGLOM
+			dhd_txglom_enable(dhdp, FALSE);
+#endif
 			dhd_os_sdunlock(dhdp);
 
 			DHD_TRACE(("%s:  WLAN OFF DONE\n", __FUNCTION__));
@@ -6906,7 +8135,7 @@ dhd_bus_devreset(dhd_pub_t *dhdp, uint8 flag)
 #if defined(OOB_INTR_ONLY)
 						bcmsdh_set_irq(TRUE);
 						dhd_enable_oob_intr(bus, TRUE);
-#endif /* defined(OOB_INTR_ONLY) */
+#endif 
 
 						bus->dhd->dongle_reset = FALSE;
 						bus->dhd->up = TRUE;
@@ -6916,7 +8145,12 @@ dhd_bus_devreset(dhd_pub_t *dhdp, uint8 flag)
 						dhd_txflowcontrol(bus->dhd, ALL_INTERFACES, OFF);
 #endif 
 						dhd_os_wd_timer(dhdp, dhd_watchdog_ms);
-
+#ifdef BCMSDIOH_TXGLOM_skip
+						if ((dhdp->busstate == DHD_BUS_DATA) &&
+							bcmsdh_glom_enabled()) {
+							dhd_txglom_enable(dhdp, TRUE);
+						}
+#endif /* BCMSDIOH_TXGLOM */
 						DHD_TRACE(("%s: WLAN ON DONE\n", __FUNCTION__));
 					} else {
 						dhd_bus_stop(bus, FALSE);
@@ -6952,6 +8186,22 @@ uint dhd_bus_chip_id(dhd_pub_t *dhdp)
 
 	return  bus->sih->chip;
 }
+
+/* Get Chip Rev ID version */
+uint dhd_bus_chiprev_id(dhd_pub_t *dhdp)
+{
+	dhd_bus_t *bus = dhdp->bus;
+
+	return bus->sih->chiprev;
+}
+
+/* Get Chip Pkg ID version */
+uint dhd_bus_chippkg_id(dhd_pub_t *dhdp)
+{
+	dhd_bus_t *bus = dhdp->bus;
+
+	return bus->sih->chippkg;
+}
 int
 dhd_bus_membytes(dhd_pub_t *dhdp, bool set, uint32 address, uint8 *data, uint size)
 {
@@ -6960,3 +8210,68 @@ dhd_bus_membytes(dhd_pub_t *dhdp, bool set, uint32 address, uint8 *data, uint si
 	bus = dhdp->bus;
 	return dhdsdio_membytes(bus, set, address, data, size);
 }
+
+int
+dhd_enableOOB(dhd_pub_t *dhd, bool sleep)
+{
+	dhd_bus_t *bus = dhd->bus;
+	sdpcmd_regs_t *regs = bus->regs;
+	uint retries = 0;
+
+	if (sleep) {
+		dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
+		/* Tell device to start using OOB wakeup */
+		W_SDREG(SMB_USE_OOB, &regs->tosbmailbox, retries);
+		if (retries > retry_limit) {
+			DHD_ERROR(("CANNOT SIGNAL CHIP, WILL NOT WAKE UP!!\n"));
+			return BCME_BUSY;
+		}
+		/* Turn off our contribution to the HT clock request */
+		dhdsdio_clkctl(bus, CLK_SDONLY, FALSE);
+	} else {
+		/* Make sure the controller has the bus up */
+		dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
+
+		/* Send misc interrupt to indicate OOB not needed */
+		W_SDREG(0, &regs->tosbmailboxdata, retries);
+		if (retries <= retry_limit)
+			W_SDREG(SMB_DEV_INT, &regs->tosbmailbox, retries);
+
+		if (retries > retry_limit)
+			DHD_ERROR(("CANNOT SIGNAL CHIP TO CLEAR OOB!!\n"));
+
+		/* Make sure we have SD bus access */
+		dhdsdio_clkctl(bus, CLK_SDONLY, FALSE);
+	}
+	return BCME_OK;
+}
+
+void
+dhd_bus_pktq_flush(dhd_pub_t *dhdp)
+{
+	dhd_bus_t *bus = dhdp->bus;
+	/* Clear the data packet queues */
+	pktq_flush(dhdp->osh, &bus->txq, TRUE, NULL, 0);
+}
+
+int
+dhd_sr_config(dhd_pub_t *dhd, bool on)
+{
+	dhd_bus_t *bus = dhd->bus;
+
+	if (!bus->_srenab)
+		return -1;
+
+	return dhdsdio_clk_devsleep_iovar(bus, on);
+}
+
+uint16
+dhd_get_chipid(dhd_pub_t *dhd)
+{
+	dhd_bus_t *bus = dhd->bus;
+
+	if (bus && bus->sih)
+		return (uint16)bus->sih->chip;
+	else
+		return 0;
+}
diff --git a/drivers/net/wireless/bcmdhd/dhd_wlfc.c b/drivers/net/wireless/bcmdhd/dhd_wlfc.c
new file mode 100755
index 0000000..99d6045
--- /dev/null
+++ b/drivers/net/wireless/bcmdhd/dhd_wlfc.c
@@ -0,0 +1,2446 @@
+/*
+ * DHD PROP_TXSTATUS Module.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ * $Id: dhd_wlfc.c 395161 2013-04-05 13:19:38Z $
+ *
+ */
+
+#include <typedefs.h>
+#include <osl.h>
+
+#include <bcmutils.h>
+#include <bcmendian.h>
+
+#include <dngl_stats.h>
+#include <dhd.h>
+
+#include <dhd_bus.h>
+#include <dhd_dbg.h>
+
+#ifdef PROP_TXSTATUS
+#include <wlfc_proto.h>
+#include <dhd_wlfc.h>
+#endif
+
+
+
+
+#define BUS_RETRIES 1	/* # of retries before aborting a bus tx operation */
+
+#ifdef PROP_TXSTATUS
+typedef struct dhd_wlfc_commit_info {
+	uint8					needs_hdr;
+	uint8					ac_fifo_credit_spent;
+	ewlfc_packet_state_t	pkt_type;
+	wlfc_mac_descriptor_t*	mac_entry;
+	void*					p;
+} dhd_wlfc_commit_info_t;
+#endif /* PROP_TXSTATUS */
+
+
+#ifdef PROP_TXSTATUS
+
+#ifdef QMONITOR
+#define DHD_WLFC_QMON_COMPLETE(entry) dhd_qmon_txcomplete(&entry->qmon)
+#else
+#define DHD_WLFC_QMON_COMPLETE(entry)
+#endif /* QMONITOR */
+
+void
+dhd_wlfc_dump(dhd_pub_t *dhdp, struct bcmstrbuf *strbuf)
+{
+	int i;
+	uint8* ea;
+	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
+		dhdp->wlfc_state;
+	wlfc_hanger_t* h;
+	wlfc_mac_descriptor_t* mac_table;
+	wlfc_mac_descriptor_t* interfaces;
+	char* iftypes[] = {"STA", "AP", "WDS", "p2pGO", "p2pCL"};
+
+	if (wlfc == NULL) {
+		bcm_bprintf(strbuf, "wlfc not initialized yet\n");
+		return;
+	}
+	h = (wlfc_hanger_t*)wlfc->hanger;
+	if (h == NULL) {
+		bcm_bprintf(strbuf, "wlfc-hanger not initialized yet\n");
+	}
+
+	mac_table = wlfc->destination_entries.nodes;
+	interfaces = wlfc->destination_entries.interfaces;
+	bcm_bprintf(strbuf, "---- wlfc stats ----\n");
+	if (h) {
+		bcm_bprintf(strbuf, "wlfc hanger (pushed,popped,f_push,"
+			"f_pop,f_slot, pending) = (%d,%d,%d,%d,%d,%d)\n",
+			h->pushed,
+			h->popped,
+			h->failed_to_push,
+			h->failed_to_pop,
+			h->failed_slotfind,
+			(h->pushed - h->popped));
+	}
+
+	bcm_bprintf(strbuf, "wlfc fail(tlv,credit_rqst,mac_update,psmode_update), "
+		"(dq_full,rollback_fail) = (%d,%d,%d,%d), (%d,%d)\n",
+		wlfc->stats.tlv_parse_failed,
+		wlfc->stats.credit_request_failed,
+		wlfc->stats.mac_update_failed,
+		wlfc->stats.psmode_update_failed,
+		wlfc->stats.delayq_full_error,
+		wlfc->stats.rollback_failed);
+
+	bcm_bprintf(strbuf, "PKTS (credit,sent) "
+		"(AC0[%d,%d],AC1[%d,%d],AC2[%d,%d],AC3[%d,%d],BC_MC[%d,%d])\n",
+		wlfc->FIFO_credit[0], wlfc->stats.send_pkts[0],
+		wlfc->FIFO_credit[1], wlfc->stats.send_pkts[1],
+		wlfc->FIFO_credit[2], wlfc->stats.send_pkts[2],
+		wlfc->FIFO_credit[3], wlfc->stats.send_pkts[3],
+		wlfc->FIFO_credit[4], wlfc->stats.send_pkts[4]);
+
+	bcm_bprintf(strbuf, "\n");
+	for (i = 0; i < WLFC_MAX_IFNUM; i++) {
+		if (interfaces[i].occupied) {
+			char* iftype_desc;
+
+			if (interfaces[i].iftype > WLC_E_IF_ROLE_P2P_CLIENT)
+				iftype_desc = "<Unknown";
+			else
+				iftype_desc = iftypes[interfaces[i].iftype];
+
+			ea = interfaces[i].ea;
+			bcm_bprintf(strbuf, "INTERFACE[%d].ea = "
+				"[%02x:%02x:%02x:%02x:%02x:%02x], if:%d, type: %s"
+				"netif_flow_control:%s\n", i,
+				ea[0], ea[1], ea[2], ea[3], ea[4], ea[5],
+				interfaces[i].interface_id,
+				iftype_desc, ((wlfc->hostif_flow_state[i] == OFF)
+				? " OFF":" ON"));
+
+			bcm_bprintf(strbuf, "INTERFACE[%d].DELAYQ(len,state,credit)"
+				"= (%d,%s,%d)\n",
+				i,
+				interfaces[i].psq.len,
+				((interfaces[i].state ==
+				WLFC_STATE_OPEN) ? " OPEN":"CLOSE"),
+				interfaces[i].requested_credit);
+
+			bcm_bprintf(strbuf, "INTERFACE[%d].DELAYQ"
+				"(sup,ac0),(sup,ac1),(sup,ac2),(sup,ac3) = "
+				"(%d,%d),(%d,%d),(%d,%d),(%d,%d)\n",
+				i,
+				interfaces[i].psq.q[0].len,
+				interfaces[i].psq.q[1].len,
+				interfaces[i].psq.q[2].len,
+				interfaces[i].psq.q[3].len,
+				interfaces[i].psq.q[4].len,
+				interfaces[i].psq.q[5].len,
+				interfaces[i].psq.q[6].len,
+				interfaces[i].psq.q[7].len);
+		}
+	}
+
+	bcm_bprintf(strbuf, "\n");
+	for (i = 0; i < WLFC_MAC_DESC_TABLE_SIZE; i++) {
+		if (mac_table[i].occupied) {
+			ea = mac_table[i].ea;
+			bcm_bprintf(strbuf, "MAC_table[%d].ea = "
+				"[%02x:%02x:%02x:%02x:%02x:%02x], if:%d \n", i,
+				ea[0], ea[1], ea[2], ea[3], ea[4], ea[5],
+				mac_table[i].interface_id);
+
+			bcm_bprintf(strbuf, "MAC_table[%d].DELAYQ(len,state,credit)"
+				"= (%d,%s,%d)\n",
+				i,
+				mac_table[i].psq.len,
+				((mac_table[i].state ==
+				WLFC_STATE_OPEN) ? " OPEN":"CLOSE"),
+				mac_table[i].requested_credit);
+#ifdef PROP_TXSTATUS_DEBUG
+			bcm_bprintf(strbuf, "MAC_table[%d]: (opened, closed) = (%d, %d)\n",
+				i, mac_table[i].opened_ct, mac_table[i].closed_ct);
+#endif
+			bcm_bprintf(strbuf, "MAC_table[%d].DELAYQ"
+				"(sup,ac0),(sup,ac1),(sup,ac2),(sup,ac3) = "
+				"(%d,%d),(%d,%d),(%d,%d),(%d,%d)\n",
+				i,
+				mac_table[i].psq.q[0].len,
+				mac_table[i].psq.q[1].len,
+				mac_table[i].psq.q[2].len,
+				mac_table[i].psq.q[3].len,
+				mac_table[i].psq.q[4].len,
+				mac_table[i].psq.q[5].len,
+				mac_table[i].psq.q[6].len,
+				mac_table[i].psq.q[7].len);
+		}
+	}
+
+#ifdef PROP_TXSTATUS_DEBUG
+	{
+		int avg;
+		int moving_avg = 0;
+		int moving_samples;
+
+		if (wlfc->stats.latency_sample_count) {
+			moving_samples = sizeof(wlfc->stats.deltas)/sizeof(uint32);
+
+			for (i = 0; i < moving_samples; i++)
+				moving_avg += wlfc->stats.deltas[i];
+			moving_avg /= moving_samples;
+
+			avg = (100 * wlfc->stats.total_status_latency) /
+				wlfc->stats.latency_sample_count;
+			bcm_bprintf(strbuf, "txstatus latency (average, last, moving[%d]) = "
+				"(%d.%d, %03d, %03d)\n",
+				moving_samples, avg/100, (avg - (avg/100)*100),
+				wlfc->stats.latency_most_recent,
+				moving_avg);
+		}
+	}
+
+	bcm_bprintf(strbuf, "wlfc- fifo[0-5] credit stats: sent = (%d,%d,%d,%d,%d,%d), "
+		"back = (%d,%d,%d,%d,%d,%d)\n",
+		wlfc->stats.fifo_credits_sent[0],
+		wlfc->stats.fifo_credits_sent[1],
+		wlfc->stats.fifo_credits_sent[2],
+		wlfc->stats.fifo_credits_sent[3],
+		wlfc->stats.fifo_credits_sent[4],
+		wlfc->stats.fifo_credits_sent[5],
+
+		wlfc->stats.fifo_credits_back[0],
+		wlfc->stats.fifo_credits_back[1],
+		wlfc->stats.fifo_credits_back[2],
+		wlfc->stats.fifo_credits_back[3],
+		wlfc->stats.fifo_credits_back[4],
+		wlfc->stats.fifo_credits_back[5]);
+	{
+		uint32 fifo_cr_sent = 0;
+		uint32 fifo_cr_acked = 0;
+		uint32 request_cr_sent = 0;
+		uint32 request_cr_ack = 0;
+		uint32 bc_mc_cr_ack = 0;
+
+		for (i = 0; i < sizeof(wlfc->stats.fifo_credits_sent)/sizeof(uint32); i++) {
+			fifo_cr_sent += wlfc->stats.fifo_credits_sent[i];
+		}
+
+		for (i = 0; i < sizeof(wlfc->stats.fifo_credits_back)/sizeof(uint32); i++) {
+			fifo_cr_acked += wlfc->stats.fifo_credits_back[i];
+		}
+
+		for (i = 0; i < WLFC_MAC_DESC_TABLE_SIZE; i++) {
+			if (wlfc->destination_entries.nodes[i].occupied) {
+				request_cr_sent +=
+					wlfc->destination_entries.nodes[i].dstncredit_sent_packets;
+			}
+		}
+		for (i = 0; i < WLFC_MAX_IFNUM; i++) {
+			if (wlfc->destination_entries.interfaces[i].occupied) {
+				request_cr_sent +=
+				wlfc->destination_entries.interfaces[i].dstncredit_sent_packets;
+			}
+		}
+		for (i = 0; i < WLFC_MAC_DESC_TABLE_SIZE; i++) {
+			if (wlfc->destination_entries.nodes[i].occupied) {
+				request_cr_ack +=
+					wlfc->destination_entries.nodes[i].dstncredit_acks;
+			}
+		}
+		for (i = 0; i < WLFC_MAX_IFNUM; i++) {
+			if (wlfc->destination_entries.interfaces[i].occupied) {
+				request_cr_ack +=
+					wlfc->destination_entries.interfaces[i].dstncredit_acks;
+			}
+		}
+		bcm_bprintf(strbuf, "wlfc- (sent, status) => pq(%d,%d), vq(%d,%d),"
+			"other:%d, bc_mc:%d, signal-only, (sent,freed): (%d,%d)",
+			fifo_cr_sent, fifo_cr_acked,
+			request_cr_sent, request_cr_ack,
+			wlfc->destination_entries.other.dstncredit_acks,
+			bc_mc_cr_ack,
+			wlfc->stats.signal_only_pkts_sent, wlfc->stats.signal_only_pkts_freed);
+	}
+#endif /* PROP_TXSTATUS_DEBUG */
+	bcm_bprintf(strbuf, "\n");
+	bcm_bprintf(strbuf, "wlfc- pkt((in,2bus,txstats,hdrpull),(dropped,hdr_only,wlc_tossed)"
+		"(freed,free_err,rollback)) = "
+		"((%d,%d,%d,%d),(%d,%d,%d),(%d,%d,%d))\n",
+		wlfc->stats.pktin,
+		wlfc->stats.pkt2bus,
+		wlfc->stats.txstatus_in,
+		wlfc->stats.dhd_hdrpulls,
+
+		wlfc->stats.pktdropped,
+		wlfc->stats.wlfc_header_only_pkt,
+		wlfc->stats.wlc_tossed_pkts,
+
+		wlfc->stats.pkt_freed,
+		wlfc->stats.pkt_free_err, wlfc->stats.rollback);
+
+	bcm_bprintf(strbuf, "wlfc- suppress((d11,wlc,err),enq(d11,wl,hq,mac?),retx(d11,wlc,hq)) = "
+		"((%d,%d,%d),(%d,%d,%d,%d),(%d,%d,%d))\n",
+
+		wlfc->stats.d11_suppress,
+		wlfc->stats.wl_suppress,
+		wlfc->stats.bad_suppress,
+
+		wlfc->stats.psq_d11sup_enq,
+		wlfc->stats.psq_wlsup_enq,
+		wlfc->stats.psq_hostq_enq,
+		wlfc->stats.mac_handle_notfound,
+
+		wlfc->stats.psq_d11sup_retx,
+		wlfc->stats.psq_wlsup_retx,
+		wlfc->stats.psq_hostq_retx);
+	bcm_bprintf(strbuf, "wlfc- generic error: %d", wlfc->stats.generic_error);
+
+	return;
+}
+
+/* Create a place to store all packet pointers submitted to the firmware until
+	a status comes back, suppress or otherwise.
+
+	hang-er: noun, a contrivance on which things are hung, as a hook.
+*/
+static void*
+dhd_wlfc_hanger_create(osl_t *osh, int max_items)
+{
+	int i;
+	wlfc_hanger_t* hanger;
+
+	/* allow only up to a specific size for now */
+	ASSERT(max_items == WLFC_HANGER_MAXITEMS);
+
+	if ((hanger = (wlfc_hanger_t*)MALLOC(osh, WLFC_HANGER_SIZE(max_items))) == NULL)
+		return NULL;
+
+	memset(hanger, 0, WLFC_HANGER_SIZE(max_items));
+	hanger->max_items = max_items;
+
+	for (i = 0; i < hanger->max_items; i++) {
+		hanger->items[i].state = WLFC_HANGER_ITEM_STATE_FREE;
+	}
+	return hanger;
+}
+
+static int
+dhd_wlfc_hanger_delete(osl_t *osh, void* hanger)
+{
+	wlfc_hanger_t* h = (wlfc_hanger_t*)hanger;
+
+	if (h) {
+		MFREE(osh, h, WLFC_HANGER_SIZE(h->max_items));
+		return BCME_OK;
+	}
+	return BCME_BADARG;
+}
+
+static uint16
+dhd_wlfc_hanger_get_free_slot(void* hanger)
+{
+	uint32 i;
+	wlfc_hanger_t* h = (wlfc_hanger_t*)hanger;
+
+	if (h) {
+		i = h->slot_pos + 1;
+		if (i == h->max_items) {
+			i = 0;
+		}
+		while (i != h->slot_pos) {
+			if (h->items[i].state == WLFC_HANGER_ITEM_STATE_FREE) {
+				h->slot_pos = i;
+				return (uint16)i;
+			}
+			i++;
+			if (i == h->max_items)
+				i = 0;
+		}
+		h->failed_slotfind++;
+	}
+	return WLFC_HANGER_MAXITEMS;
+}
+
+static int
+dhd_wlfc_hanger_get_genbit(void* hanger, void* pkt, uint32 slot_id, int* gen)
+{
+	int rc = BCME_OK;
+	wlfc_hanger_t* h = (wlfc_hanger_t*)hanger;
+
+	*gen = 0xff;
+
+	/* this packet was not pushed at the time it went to the firmware */
+	if (slot_id == WLFC_HANGER_MAXITEMS)
+		return BCME_NOTFOUND;
+
+	if (h) {
+		if ((h->items[slot_id].state == WLFC_HANGER_ITEM_STATE_INUSE) ||
+			(h->items[slot_id].state == WLFC_HANGER_ITEM_STATE_INUSE_SUPPRESSED)) {
+			*gen = h->items[slot_id].gen;
+		}
+		else {
+			rc = BCME_NOTFOUND;
+		}
+	}
+	else
+		rc = BCME_BADARG;
+	return rc;
+}
+
+static int
+dhd_wlfc_hanger_pushpkt(void* hanger, void* pkt, uint32 slot_id)
+{
+	int rc = BCME_OK;
+	wlfc_hanger_t* h = (wlfc_hanger_t*)hanger;
+
+	if (h && (slot_id < WLFC_HANGER_MAXITEMS)) {
+		if (h->items[slot_id].state == WLFC_HANGER_ITEM_STATE_FREE) {
+			h->items[slot_id].state = WLFC_HANGER_ITEM_STATE_INUSE;
+			h->items[slot_id].pkt = pkt;
+			h->items[slot_id].identifier = slot_id;
+			h->pushed++;
+		}
+		else {
+			h->failed_to_push++;
+			rc = BCME_NOTFOUND;
+		}
+	}
+	else
+		rc = BCME_BADARG;
+	return rc;
+}
+
+static int
+dhd_wlfc_hanger_poppkt(void* hanger, uint32 slot_id, void** pktout, int remove_from_hanger)
+{
+	int rc = BCME_OK;
+	wlfc_hanger_t* h = (wlfc_hanger_t*)hanger;
+
+	/* this packet was not pushed at the time it went to the firmware */
+	if (slot_id == WLFC_HANGER_MAXITEMS)
+		return BCME_NOTFOUND;
+
+	if (h) {
+		if (h->items[slot_id].state != WLFC_HANGER_ITEM_STATE_FREE) {
+			*pktout = h->items[slot_id].pkt;
+			if (remove_from_hanger) {
+				h->items[slot_id].state =
+					WLFC_HANGER_ITEM_STATE_FREE;
+				h->items[slot_id].pkt = NULL;
+				h->items[slot_id].identifier = 0;
+				h->items[slot_id].gen = 0xff;
+				h->popped++;
+			}
+		}
+		else {
+			h->failed_to_pop++;
+			rc = BCME_NOTFOUND;
+		}
+	}
+	else
+		rc = BCME_BADARG;
+	return rc;
+}
+
+static int
+dhd_wlfc_hanger_mark_suppressed(void* hanger, uint32 slot_id, uint8 gen)
+{
+	int rc = BCME_OK;
+	wlfc_hanger_t* h = (wlfc_hanger_t*)hanger;
+
+	/* this packet was not pushed at the time it went to the firmware */
+	if (slot_id == WLFC_HANGER_MAXITEMS)
+		return BCME_NOTFOUND;
+	if (h) {
+		h->items[slot_id].gen = gen;
+		if (h->items[slot_id].state == WLFC_HANGER_ITEM_STATE_INUSE) {
+			h->items[slot_id].state = WLFC_HANGER_ITEM_STATE_INUSE_SUPPRESSED;
+		}
+		else
+			rc = BCME_BADARG;
+	}
+	else
+		rc = BCME_BADARG;
+
+	return rc;
+}
+
+static int
+_dhd_wlfc_pushheader(athost_wl_status_info_t* ctx, void* p, bool tim_signal,
+	uint8 tim_bmp, uint8 mac_handle, uint32 htodtag)
+{
+	uint32 wl_pktinfo = 0;
+	uint8* wlh;
+	uint8 dataOffset;
+	uint8 fillers;
+	uint8 tim_signal_len = 0;
+
+	struct bdc_header *h;
+
+	if (tim_signal) {
+		tim_signal_len = 1 + 1 + WLFC_CTL_VALUE_LEN_PENDING_TRAFFIC_BMP;
+	}
+
+	/* +2 is for Type[1] and Len[1] in TLV, plus TIM signal */
+	dataOffset = WLFC_CTL_VALUE_LEN_PKTTAG + 2 + tim_signal_len;
+	fillers = ROUNDUP(dataOffset, 4) - dataOffset;
+	dataOffset += fillers;
+
+	PKTPUSH(ctx->osh, p, dataOffset);
+	wlh = (uint8*) PKTDATA(ctx->osh, p);
+
+	wl_pktinfo = htol32(htodtag);
+
+	wlh[0] = WLFC_CTL_TYPE_PKTTAG;
+	wlh[1] = WLFC_CTL_VALUE_LEN_PKTTAG;
+	memcpy(&wlh[2], &wl_pktinfo, sizeof(uint32));
+
+	if (tim_signal_len) {
+		wlh[dataOffset - fillers - tim_signal_len ] =
+			WLFC_CTL_TYPE_PENDING_TRAFFIC_BMP;
+		wlh[dataOffset - fillers - tim_signal_len + 1] =
+			WLFC_CTL_VALUE_LEN_PENDING_TRAFFIC_BMP;
+		wlh[dataOffset - fillers - tim_signal_len + 2] = mac_handle;
+		wlh[dataOffset - fillers - tim_signal_len + 3] = tim_bmp;
+	}
+	if (fillers)
+		memset(&wlh[dataOffset - fillers], WLFC_CTL_TYPE_FILLER, fillers);
+
+	PKTPUSH(ctx->osh, p, BDC_HEADER_LEN);
+	h = (struct bdc_header *)PKTDATA(ctx->osh, p);
+	h->flags = (BDC_PROTO_VER << BDC_FLAG_VER_SHIFT);
+	if (PKTSUMNEEDED(p))
+		h->flags |= BDC_FLAG_SUM_NEEDED;
+
+
+	h->priority = (PKTPRIO(p) & BDC_PRIORITY_MASK);
+	h->flags2 = 0;
+	h->dataOffset = dataOffset >> 2;
+	BDC_SET_IF_IDX(h, DHD_PKTTAG_IF(PKTTAG(p)));
+	return BCME_OK;
+}
+
+static int
+_dhd_wlfc_pullheader(athost_wl_status_info_t* ctx, void* pktbuf)
+{
+	struct bdc_header *h;
+
+	if (PKTLEN(ctx->osh, pktbuf) < BDC_HEADER_LEN) {
+		WLFC_DBGMESG(("%s: rx data too short (%d < %d)\n", __FUNCTION__,
+		           PKTLEN(ctx->osh, pktbuf), BDC_HEADER_LEN));
+		return BCME_ERROR;
+	}
+	h = (struct bdc_header *)PKTDATA(ctx->osh, pktbuf);
+
+	/* pull BDC header */
+	PKTPULL(ctx->osh, pktbuf, BDC_HEADER_LEN);
+
+	if (PKTLEN(ctx->osh, pktbuf) < (h->dataOffset << 2)) {
+		WLFC_DBGMESG(("%s: rx data too short (%d < %d)\n", __FUNCTION__,
+		           PKTLEN(ctx->osh, pktbuf), (h->dataOffset << 2)));
+		return BCME_ERROR;
+	}
+
+	/* pull wl-header */
+	PKTPULL(ctx->osh, pktbuf, (h->dataOffset << 2));
+	return BCME_OK;
+}
+
+static wlfc_mac_descriptor_t*
+_dhd_wlfc_find_table_entry(athost_wl_status_info_t* ctx, void* p)
+{
+	int i;
+	wlfc_mac_descriptor_t* table = ctx->destination_entries.nodes;
+	uint8 ifid = DHD_PKTTAG_IF(PKTTAG(p));
+	uint8* dstn = DHD_PKTTAG_DSTN(PKTTAG(p));
+	wlfc_mac_descriptor_t* entry = NULL;
+	int iftype = ctx->destination_entries.interfaces[ifid].iftype;
+
+	/* Multicast destination and P2P clients get the interface entry.
+	 * STA gets the interface entry if there is no exact match. For
+	 * example, TDLS destinations have their own entry.
+	 */
+	if ((iftype == WLC_E_IF_ROLE_STA || ETHER_ISMULTI(dstn) ||
+		iftype == WLC_E_IF_ROLE_P2P_CLIENT) &&
+		(ctx->destination_entries.interfaces[ifid].occupied)) {
+			entry = &ctx->destination_entries.interfaces[ifid];
+	}
+
+	if (entry != NULL && ETHER_ISMULTI(dstn))
+		return entry;
+
+	for (i = 0; i < WLFC_MAC_DESC_TABLE_SIZE; i++) {
+		if (table[i].occupied) {
+			if (table[i].interface_id == ifid) {
+				if (!memcmp(table[i].ea, dstn, ETHER_ADDR_LEN)) {
+					entry = &table[i];
+					break;
+				}
+			}
+		}
+	}
+
+	return entry != NULL ? entry : &ctx->destination_entries.other;
+}
+
+static int
+_dhd_wlfc_rollback_packet_toq(athost_wl_status_info_t* ctx,
+	void* p, ewlfc_packet_state_t pkt_type, uint32 hslot)
+{
+	/*
+	put the packet back to the head of queue
+
+	- suppressed packet goes back to suppress sub-queue
+	- pull out the header, if new or delayed packet
+
+	Note: hslot is used only when header removal is done.
+	*/
+	wlfc_mac_descriptor_t* entry;
+	void* pktout;
+	int rc = BCME_OK;
+	int prec;
+
+	entry = _dhd_wlfc_find_table_entry(ctx, p);
+	prec = DHD_PKTTAG_FIFO(PKTTAG(p));
+	if (entry != NULL) {
+		if (pkt_type == eWLFC_PKTTYPE_SUPPRESSED) {
+			/* wl-header is saved for suppressed packets */
+			if (WLFC_PKTQ_PENQ_HEAD(&entry->psq, ((prec << 1) + 1), p) == NULL) {
+				WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
+				rc = BCME_ERROR;
+			}
+		}
+		else {
+			/* remove header first */
+			rc = _dhd_wlfc_pullheader(ctx, p);
+			if (rc != BCME_OK)          {
+				WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
+				/* free the hanger slot */
+				dhd_wlfc_hanger_poppkt(ctx->hanger, hslot, &pktout, 1);
+				PKTFREE(ctx->osh, p, TRUE);
+				ctx->stats.rollback_failed++;
+				return BCME_ERROR;
+			}
+
+			if (pkt_type == eWLFC_PKTTYPE_DELAYED) {
+				/* delay-q packets are going to delay-q */
+				if (WLFC_PKTQ_PENQ_HEAD(&entry->psq, (prec << 1), p) == NULL) {
+					WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
+					rc = BCME_ERROR;
+				}
+			}
+
+			/* free the hanger slot */
+			dhd_wlfc_hanger_poppkt(ctx->hanger, hslot, &pktout, 1);
+
+			/* decrement sequence count */
+			WLFC_DECR_SEQCOUNT(entry, prec);
+		}
+		/*
+		if this packet did not count against FIFO credit, it must have
+		taken a requested_credit from the firmware (for pspoll etc.)
+		*/
+		if (!DHD_PKTTAG_CREDITCHECK(PKTTAG(p))) {
+			entry->requested_credit++;
+		}
+	}
+	else {
+		WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
+		rc = BCME_ERROR;
+	}
+	if (rc != BCME_OK)
+		ctx->stats.rollback_failed++;
+	else
+		ctx->stats.rollback++;
+
+	return rc;
+}
+
+static void
+_dhd_wlfc_flow_control_check(athost_wl_status_info_t* ctx, struct pktq* pq, uint8 if_id)
+{
+	dhd_pub_t *dhdp;
+
+	ASSERT(ctx);
+
+	dhdp = (dhd_pub_t *)ctx->dhdp;
+
+	if (dhdp && dhdp->skip_fc && dhdp->skip_fc())
+		return;
+
+	if ((pq->len <= WLFC_FLOWCONTROL_LOWATER) && (ctx->hostif_flow_state[if_id] == ON)) {
+		/* start traffic */
+		ctx->hostif_flow_state[if_id] = OFF;
+		/*
+		WLFC_DBGMESG(("qlen:%02d, if:%02d, ->OFF, start traffic %s()\n",
+		pq->len, if_id, __FUNCTION__));
+		*/
+		WLFC_DBGMESG(("F"));
+
+		dhd_txflowcontrol(ctx->dhdp, if_id, OFF);
+
+		ctx->toggle_host_if = 0;
+	}
+	if ((pq->len >= WLFC_FLOWCONTROL_HIWATER) && (ctx->hostif_flow_state[if_id] == OFF)) {
+		/* stop traffic */
+		ctx->hostif_flow_state[if_id] = ON;
+		/*
+		WLFC_DBGMESG(("qlen:%02d, if:%02d, ->ON, stop traffic   %s()\n",
+		pq->len, if_id, __FUNCTION__));
+		*/
+		WLFC_DBGMESG(("N"));
+
+		dhd_txflowcontrol(ctx->dhdp, if_id, ON);
+
+		ctx->host_ifidx = if_id;
+		ctx->toggle_host_if = 1;
+	}
+
+	return;
+}
+
+static int
+_dhd_wlfc_send_signalonly_packet(athost_wl_status_info_t* ctx, wlfc_mac_descriptor_t* entry,
+	uint8 ta_bmp)
+{
+	int rc = BCME_OK;
+	void* p = NULL;
+	int dummylen = ((dhd_pub_t *)ctx->dhdp)->hdrlen+ 12;
+
+	/* allocate a dummy packet */
+	p = PKTGET(ctx->osh, dummylen, TRUE);
+	if (p) {
+		PKTPULL(ctx->osh, p, dummylen);
+		DHD_PKTTAG_SET_H2DTAG(PKTTAG(p), 0);
+		_dhd_wlfc_pushheader(ctx, p, TRUE, ta_bmp, entry->mac_handle, 0);
+		DHD_PKTTAG_SETSIGNALONLY(PKTTAG(p), 1);
+#ifdef PROP_TXSTATUS_DEBUG
+		ctx->stats.signal_only_pkts_sent++;
+#endif
+		rc = dhd_bus_txdata(((dhd_pub_t *)ctx->dhdp)->bus, p);
+		if (rc != BCME_OK) {
+			PKTFREE(ctx->osh, p, TRUE);
+		}
+	}
+	else {
+		DHD_ERROR(("%s: couldn't allocate new %d-byte packet\n",
+		           __FUNCTION__, dummylen));
+		rc = BCME_NOMEM;
+	}
+	return rc;
+}
+
+/* Return TRUE if traffic availability changed */
+static bool
+_dhd_wlfc_traffic_pending_check(athost_wl_status_info_t* ctx, wlfc_mac_descriptor_t* entry,
+	int prec)
+{
+	bool rc = FALSE;
+
+	if (entry->state == WLFC_STATE_CLOSE) {
+		if ((pktq_plen(&entry->psq, (prec << 1)) == 0) &&
+			(pktq_plen(&entry->psq, ((prec << 1) + 1)) == 0)) {
+
+			if (entry->traffic_pending_bmp & NBITVAL(prec)) {
+				rc = TRUE;
+				entry->traffic_pending_bmp =
+					entry->traffic_pending_bmp & ~ NBITVAL(prec);
+			}
+		}
+		else {
+			if (!(entry->traffic_pending_bmp & NBITVAL(prec))) {
+				rc = TRUE;
+				entry->traffic_pending_bmp =
+					entry->traffic_pending_bmp | NBITVAL(prec);
+			}
+		}
+	}
+	if (rc) {
+		/* request a TIM update to firmware at the next piggyback opportunity */
+		if (entry->traffic_lastreported_bmp != entry->traffic_pending_bmp) {
+			entry->send_tim_signal = 1;
+			_dhd_wlfc_send_signalonly_packet(ctx, entry, entry->traffic_pending_bmp);
+			entry->traffic_lastreported_bmp = entry->traffic_pending_bmp;
+			entry->send_tim_signal = 0;
+		}
+		else {
+			rc = FALSE;
+		}
+	}
+	return rc;
+}
+
+static int
+_dhd_wlfc_enque_suppressed(athost_wl_status_info_t* ctx, int prec, void* p)
+{
+	wlfc_mac_descriptor_t* entry;
+
+	entry = _dhd_wlfc_find_table_entry(ctx, p);
+	if (entry == NULL) {
+		WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
+		return BCME_NOTFOUND;
+	}
+	/*
+	- suppressed packets go to sub_queue[2*prec + 1] AND
+	- delayed packets go to sub_queue[2*prec + 0] to ensure
+	order of delivery.
+	*/
+	if (WLFC_PKTQ_PENQ(&entry->psq, ((prec << 1) + 1), p) == NULL) {
+		ctx->stats.delayq_full_error++;
+		/* WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__)); */
+		WLFC_DBGMESG(("s"));
+		return BCME_ERROR;
+	}
+	/* A packet has been pushed, update traffic availability bitmap, if applicable */
+	_dhd_wlfc_traffic_pending_check(ctx, entry, prec);
+	_dhd_wlfc_flow_control_check(ctx, &entry->psq, DHD_PKTTAG_IF(PKTTAG(p)));
+	return BCME_OK;
+}
+
+static int
+_dhd_wlfc_pretx_pktprocess(athost_wl_status_info_t* ctx,
+	wlfc_mac_descriptor_t* entry, void* p, int header_needed, uint32* slot)
+{
+	int rc = BCME_OK;
+	int hslot = WLFC_HANGER_MAXITEMS;
+	bool send_tim_update = FALSE;
+	uint32 htod = 0;
+	uint8 free_ctr;
+
+	*slot = hslot;
+
+	if (entry == NULL) {
+		entry = _dhd_wlfc_find_table_entry(ctx, p);
+	}
+
+	if (entry == NULL) {
+		WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
+		return BCME_ERROR;
+	}
+	if (entry->send_tim_signal) {
+		send_tim_update = TRUE;
+		entry->send_tim_signal = 0;
+		entry->traffic_lastreported_bmp = entry->traffic_pending_bmp;
+	}
+	if (header_needed) {
+		hslot = dhd_wlfc_hanger_get_free_slot(ctx->hanger);
+		free_ctr = WLFC_SEQCOUNT(entry, DHD_PKTTAG_FIFO(PKTTAG(p)));
+		DHD_PKTTAG_SET_H2DTAG(PKTTAG(p), htod);
+		WLFC_PKTFLAG_SET_GENERATION(htod, entry->generation);
+		entry->transit_count++;
+	}
+	else {
+		hslot = WLFC_PKTID_HSLOT_GET(DHD_PKTTAG_H2DTAG(PKTTAG(p)));
+		free_ctr = WLFC_PKTID_FREERUNCTR_GET(DHD_PKTTAG_H2DTAG(PKTTAG(p)));
+	}
+	WLFC_PKTID_HSLOT_SET(htod, hslot);
+	WLFC_PKTID_FREERUNCTR_SET(htod, free_ctr);
+	DHD_PKTTAG_SETPKTDIR(PKTTAG(p), 1);
+	WL_TXSTATUS_SET_FLAGS(htod, WLFC_PKTFLAG_PKTFROMHOST);
+	WL_TXSTATUS_SET_FIFO(htod, DHD_PKTTAG_FIFO(PKTTAG(p)));
+
+
+	if (!DHD_PKTTAG_CREDITCHECK(PKTTAG(p))) {
+		/*
+		Indicate that this packet is being sent in response to an
+		explicit request from the firmware side.
+		*/
+		WLFC_PKTFLAG_SET_PKTREQUESTED(htod);
+	}
+	else {
+		WLFC_PKTFLAG_CLR_PKTREQUESTED(htod);
+	}
+	if (header_needed) {
+		rc = _dhd_wlfc_pushheader(ctx, p, send_tim_update,
+			entry->traffic_lastreported_bmp, entry->mac_handle, htod);
+		if (rc == BCME_OK) {
+			DHD_PKTTAG_SET_H2DTAG(PKTTAG(p), htod);
+			/*
+			a new header was created for this packet.
+			push to hanger slot and scrub q. Since bus
+			send succeeded, increment seq number as well.
+			*/
+			rc = dhd_wlfc_hanger_pushpkt(ctx->hanger, p, hslot);
+			if (rc == BCME_OK) {
+				/* increment free running sequence count */
+				WLFC_INCR_SEQCOUNT(entry, DHD_PKTTAG_FIFO(PKTTAG(p)));
+#ifdef PROP_TXSTATUS_DEBUG
+				((wlfc_hanger_t*)(ctx->hanger))->items[hslot].push_time =
+					OSL_SYSUPTIME();
+#endif
+			}
+			else {
+				WLFC_DBGMESG(("%s() hanger_pushpkt() failed, rc: %d\n",
+					__FUNCTION__, rc));
+			}
+		}
+	}
+	else {
+		int gen;
+
+		/* remove old header */
+		rc = _dhd_wlfc_pullheader(ctx, p);
+		if (rc == BCME_OK) {
+			hslot = WLFC_PKTID_HSLOT_GET(DHD_PKTTAG_H2DTAG(PKTTAG(p)));
+			dhd_wlfc_hanger_get_genbit(ctx->hanger, p, hslot, &gen);
+
+			WLFC_PKTFLAG_SET_GENERATION(htod, gen);
+			free_ctr = WLFC_PKTID_FREERUNCTR_GET(DHD_PKTTAG_H2DTAG(PKTTAG(p)));
+			/* push new header */
+			_dhd_wlfc_pushheader(ctx, p, send_tim_update,
+				entry->traffic_lastreported_bmp, entry->mac_handle, htod);
+		}
+	}
+	*slot = hslot;
+	return rc;
+}
+
+static int
+_dhd_wlfc_is_destination_closed(athost_wl_status_info_t* ctx,
+	wlfc_mac_descriptor_t* entry, int prec)
+{
+	if (ctx->destination_entries.interfaces[entry->interface_id].iftype ==
+		WLC_E_IF_ROLE_P2P_GO) {
+		/* - destination interface is of type p2p GO.
+		For a p2pGO interface, if the destination is OPEN but the interface is
+		CLOSEd, do not send traffic. But if the dstn is CLOSEd while there is
+		destination-specific-credit left send packets. This is because the
+		firmware storing the destination-specific-requested packet in queue.
+		*/
+		if ((entry->state == WLFC_STATE_CLOSE) && (entry->requested_credit == 0) &&
+			(entry->requested_packet == 0))
+			return 1;
+	}
+	/* AP, p2p_go -> unicast desc entry, STA/p2p_cl -> interface desc. entry */
+	if (((entry->state == WLFC_STATE_CLOSE) && (entry->requested_credit == 0) &&
+		(entry->requested_packet == 0)) ||
+		(!(entry->ac_bitmap & (1 << prec))))
+		return 1;
+
+	return 0;
+}
+
+static void*
+_dhd_wlfc_deque_delayedq(athost_wl_status_info_t* ctx,
+	int prec, uint8* ac_credit_spent, uint8* needs_hdr, wlfc_mac_descriptor_t** entry_out)
+{
+	wlfc_mac_descriptor_t* entry;
+	wlfc_mac_descriptor_t* table;
+	uint8 token_pos;
+	int total_entries;
+	void* p = NULL;
+	int pout;
+	int i;
+
+	*entry_out = NULL;
+	token_pos = ctx->token_pos[prec];
+	/* most cases a packet will count against FIFO credit */
+	*ac_credit_spent = 1;
+	*needs_hdr = 1;
+
+	/* search all entries, include nodes as well as interfaces */
+	table = (wlfc_mac_descriptor_t*)&ctx->destination_entries;
+	total_entries = sizeof(ctx->destination_entries)/sizeof(wlfc_mac_descriptor_t);
+
+	for (i = 0; i < total_entries; i++) {
+		entry = &table[(token_pos + i) % total_entries];
+		if (entry->occupied && !entry->deleting) {
+			if (!_dhd_wlfc_is_destination_closed(ctx, entry, prec)) {
+				p = pktq_mdeq(&entry->psq,
+					/* higher precedence will be picked up first,
+					 * i.e. suppressed packets before delayed ones
+					 */
+					NBITVAL((prec << 1) + 1), &pout);
+					*needs_hdr = 0;
+
+				if (p == NULL) {
+					if (entry->suppressed == TRUE) {
+						if ((entry->suppr_transit_count <=
+							entry->suppress_count)) {
+							entry->suppressed = FALSE;
+						} else {
+							return NULL;
+						}
+					}
+					/* De-Q from delay Q */
+					p = pktq_mdeq(&entry->psq,
+						NBITVAL((prec << 1)),
+						&pout);
+					*needs_hdr = 1;
+				}
+
+				if (p != NULL) {
+					/* did the packet come from suppress sub-queue? */
+					if (entry->requested_credit > 0) {
+						entry->requested_credit--;
+#ifdef PROP_TXSTATUS_DEBUG
+						entry->dstncredit_sent_packets++;
+#endif
+						/*
+						if the packet was pulled out while destination is in
+						closed state but had a non-zero packets requested,
+						then this should not count against the FIFO credit.
+						That is due to the fact that the firmware will
+						most likely hold onto this packet until a suitable
+						time later to push it to the appropriate  AC FIFO.
+						*/
+						if (entry->state == WLFC_STATE_CLOSE)
+							*ac_credit_spent = 0;
+					}
+					else if (entry->requested_packet > 0) {
+						entry->requested_packet--;
+						DHD_PKTTAG_SETONETIMEPKTRQST(PKTTAG(p));
+						if (entry->state == WLFC_STATE_CLOSE)
+							*ac_credit_spent = 0;
+					}
+					/* move token to ensure fair round-robin */
+					ctx->token_pos[prec] =
+						(token_pos + i + 1) % total_entries;
+					*entry_out = entry;
+					_dhd_wlfc_flow_control_check(ctx, &entry->psq,
+						DHD_PKTTAG_IF(PKTTAG(p)));
+					/*
+					A packet has been picked up, update traffic
+					availability bitmap, if applicable
+					*/
+					_dhd_wlfc_traffic_pending_check(ctx, entry, prec);
+					return p;
+				}
+			}
+		}
+	}
+	return NULL;
+}
+
+void *
+_dhd_wlfc_pktq_peek_tail(struct pktq *pq, int *prec_out)
+{
+	int prec;
+
+	ASSERT(pq);
+
+	if (pq->len == 0)
+		return NULL;
+
+	for (prec = 0; prec < pq->hi_prec; prec++)
+		/* only pick packets from dealyed-q */
+		if (((prec & 1) == 0) && pq->q[prec].head)
+			break;
+
+	if (prec_out)
+		*prec_out = prec;
+
+	return (pq->q[prec].tail);
+}
+
+bool
+_dhd_wlfc_prec_enq_with_drop(dhd_pub_t *dhdp, struct pktq *pq, void *pkt, int prec)
+{
+	void *p = NULL;
+	int eprec = -1;		/* precedence to evict from */
+
+	ASSERT(dhdp && pq && pkt);
+	ASSERT(prec >= 0 && prec < pq->num_prec);
+
+	/* Fast case, precedence queue is not full and we are also not
+	 * exceeding total queue length
+	 */
+	if (!pktq_pfull(pq, prec) && !pktq_full(pq)) {
+		pktq_penq(pq, prec, pkt);
+		return TRUE;
+	}
+
+	/* Determine precedence from which to evict packet, if any */
+	if (pktq_pfull(pq, prec))
+		eprec = prec;
+	else if (pktq_full(pq)) {
+		p = _dhd_wlfc_pktq_peek_tail(pq, &eprec);
+		if (!p) {
+			WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
+			return FALSE;
+		}
+		if ((eprec > prec) || (eprec < 0)) {
+			if (!pktq_pempty(pq, prec)) {
+				eprec = prec;
+			} else {
+				return FALSE;
+			}
+		}
+	}
+
+	/* Evict if needed */
+	if (eprec >= 0) {
+		/* Detect queueing to unconfigured precedence */
+		ASSERT(!pktq_pempty(pq, eprec));
+		/* Evict all fragmented frames */
+		dhd_prec_drop_pkts(dhdp->osh, pq, eprec);
+	}
+
+	/* Enqueue */
+	p = pktq_penq(pq, prec, pkt);
+	if (!p) {
+		WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static int
+_dhd_wlfc_enque_delayq(athost_wl_status_info_t* ctx, void* pktbuf, int prec)
+{
+	wlfc_mac_descriptor_t* entry;
+
+	if (pktbuf != NULL) {
+		entry = _dhd_wlfc_find_table_entry(ctx, pktbuf);
+
+		if (entry == NULL) {
+			WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
+			return BCME_ERROR;
+		}
+
+		/*
+		- suppressed packets go to sub_queue[2*prec + 1] AND
+		- delayed packets go to sub_queue[2*prec + 0] to ensure
+		order of delivery.
+		*/
+		if (_dhd_wlfc_prec_enq_with_drop(ctx->dhdp, &entry->psq, pktbuf, (prec << 1))
+			== FALSE) {
+			WLFC_DBGMESG(("D"));
+			/* dhd_txcomplete(ctx->dhdp, pktbuf, FALSE); */
+			PKTFREE(ctx->osh, pktbuf, TRUE);
+			ctx->stats.delayq_full_error++;
+			return BCME_ERROR;
+		}
+		/*
+		A packet has been pushed, update traffic availability bitmap,
+		if applicable
+		*/
+		_dhd_wlfc_traffic_pending_check(ctx, entry, prec);
+
+	}
+	return BCME_OK;
+}
+
+bool ifpkt_fn(void* p, int ifid)
+{
+	return (ifid == DHD_PKTTAG_IF(PKTTAG(p)));
+}
+
+static int
+_dhd_wlfc_mac_entry_update(athost_wl_status_info_t* ctx, wlfc_mac_descriptor_t* entry,
+	ewlfc_mac_entry_action_t action, uint8 ifid, uint8 iftype, uint8* ea)
+{
+	int rc = BCME_OK;
+
+#ifdef QMONITOR
+	dhd_qmon_reset(&entry->qmon);
+#endif
+
+	if (action == eWLFC_MAC_ENTRY_ACTION_ADD) {
+		entry->occupied = 1;
+		entry->state = WLFC_STATE_OPEN;
+		entry->requested_credit = 0;
+		entry->interface_id = ifid;
+		entry->iftype = iftype;
+		entry->ac_bitmap = 0xff; /* update this when handling APSD */
+		/* for an interface entry we may not care about the MAC address */
+		if (ea != NULL)
+			memcpy(&entry->ea[0], ea, ETHER_ADDR_LEN);
+		pktq_init(&entry->psq, WLFC_PSQ_PREC_COUNT, WLFC_PSQ_LEN);
+	}
+	else if (action == eWLFC_MAC_ENTRY_ACTION_UPDATE) {
+		entry->occupied = 1;
+		entry->state = WLFC_STATE_OPEN;
+		entry->requested_credit = 0;
+		entry->interface_id = ifid;
+		entry->iftype = iftype;
+		entry->ac_bitmap = 0xff; /* update this when handling APSD */
+		/* for an interface entry we may not care about the MAC address */
+		if (ea != NULL)
+			memcpy(&entry->ea[0], ea, ETHER_ADDR_LEN);
+	}
+	else if (action == eWLFC_MAC_ENTRY_ACTION_DEL) {
+		/* When the entry is deleted, the packets that are queued in the entry must be
+		   cleanup. The cleanup action should be before the occupied is set as 0. The
+		   flag deleting is set to avoid de-queue action when these queues are being
+		   cleanup
+		*/
+		entry->deleting = 1;
+		dhd_wlfc_cleanup(ctx->dhdp, ifpkt_fn, ifid);
+		_dhd_wlfc_flow_control_check(ctx, &entry->psq, ifid);
+		entry->deleting = 0;
+
+		entry->occupied = 0;
+		entry->suppressed = 0;
+		entry->state = WLFC_STATE_CLOSE;
+		entry->requested_credit = 0;
+
+		/* enable after packets are queued-deqeued properly.
+		pktq_flush(dhd->osh, &entry->psq, FALSE, NULL, 0);
+		*/
+	}
+	return rc;
+}
+
+int
+_dhd_wlfc_borrow_credit(athost_wl_status_info_t* ctx, uint8 available_credit_map, int borrower_ac)
+{
+	int lender_ac;
+	int rc = BCME_ERROR;
+
+	if (ctx == NULL || available_credit_map == 0) {
+		WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
+		return BCME_BADARG;
+	}
+
+	/* Borrow from lowest priority available AC (including BC/MC credits) */
+	for (lender_ac = 0; lender_ac <= AC_COUNT; lender_ac++) {
+		if ((available_credit_map && (1 << lender_ac)) &&
+		   (ctx->FIFO_credit[lender_ac] > 0)) {
+			ctx->credits_borrowed[borrower_ac][lender_ac]++;
+			ctx->FIFO_credit[lender_ac]--;
+			rc = BCME_OK;
+			break;
+		}
+	}
+
+	return rc;
+}
+
+int
+dhd_wlfc_interface_entry_update(void* state,
+	ewlfc_mac_entry_action_t action, uint8 ifid, uint8 iftype, uint8* ea)
+{
+	athost_wl_status_info_t* ctx = (athost_wl_status_info_t*)state;
+	wlfc_mac_descriptor_t* entry;
+	int ret;
+
+	if (ifid >= WLFC_MAX_IFNUM)
+		return BCME_BADARG;
+
+	entry = &ctx->destination_entries.interfaces[ifid];
+	ret = _dhd_wlfc_mac_entry_update(ctx, entry, action, ifid, iftype, ea);
+	return ret;
+}
+
+int
+dhd_wlfc_FIFOcreditmap_update(void* state, uint8* credits)
+{
+	athost_wl_status_info_t* ctx = (athost_wl_status_info_t*)state;
+
+	/* update the AC FIFO credit map */
+	ctx->FIFO_credit[0] = credits[0];
+	ctx->FIFO_credit[1] = credits[1];
+	ctx->FIFO_credit[2] = credits[2];
+	ctx->FIFO_credit[3] = credits[3];
+	/* credit for bc/mc packets */
+	ctx->FIFO_credit[4] = credits[4];
+	/* credit for ATIM FIFO is not used yet. */
+	ctx->FIFO_credit[5] = 0;
+	return BCME_OK;
+}
+
+int
+_dhd_wlfc_handle_packet_commit(athost_wl_status_info_t* ctx, int ac,
+    dhd_wlfc_commit_info_t *commit_info, f_commitpkt_t fcommit, void* commit_ctx)
+{
+	uint32 hslot;
+	int	rc;
+
+	/*
+		if ac_fifo_credit_spent = 0
+
+		This packet will not count against the FIFO credit.
+		To ensure the txstatus corresponding to this packet
+		does not provide an implied credit (default behavior)
+		mark the packet accordingly.
+
+		if ac_fifo_credit_spent = 1
+
+		This is a normal packet and it counts against the FIFO
+		credit count.
+	*/
+	DHD_PKTTAG_SETCREDITCHECK(PKTTAG(commit_info->p), commit_info->ac_fifo_credit_spent);
+	rc = _dhd_wlfc_pretx_pktprocess(ctx, commit_info->mac_entry, commit_info->p,
+	     commit_info->needs_hdr, &hslot);
+
+	if (rc == BCME_OK)
+		rc = fcommit(commit_ctx, commit_info->p);
+	else
+		ctx->stats.generic_error++;
+
+	if (rc == BCME_OK) {
+		ctx->stats.pkt2bus++;
+		if (commit_info->ac_fifo_credit_spent) {
+			ctx->stats.send_pkts[ac]++;
+			WLFC_HOST_FIFO_CREDIT_INC_SENTCTRS(ctx, ac);
+		}
+	} else if (rc == BCME_NORESOURCE)
+		rc = BCME_ERROR;
+	else {
+		/*
+		   bus commit has failed, rollback.
+		   - remove wl-header for a delayed packet
+		   - save wl-header header for suppressed packets
+		*/
+		rc = _dhd_wlfc_rollback_packet_toq(ctx,	commit_info->p,
+		     (commit_info->pkt_type), hslot);
+
+		rc = BCME_ERROR;
+	}
+
+	return rc;
+}
+
+
+#ifdef QMONITOR
+void
+dhd_wlfc_qmon_tx(void* state, void *pktbuf)
+{
+	athost_wl_status_info_t* ctx = (athost_wl_status_info_t*)state;
+
+	if (!ctx) {
+		wlfc_mac_descriptor_t* entry =  _dhd_wlfc_find_table_entry(ctx, pktbuf);
+		if (entry)
+			dhd_qmon_tx(&entry->qmon);
+	}
+}
+#endif /* QMONITOR */
+
+
+int
+dhd_wlfc_commit_packets(void* state, f_commitpkt_t fcommit, void* commit_ctx, void *pktbuf)
+{
+	int ac;
+	int credit;
+	int rc;
+	dhd_wlfc_commit_info_t  commit_info;
+	athost_wl_status_info_t* ctx = (athost_wl_status_info_t*)state;
+	int credit_count = 0;
+	int bus_retry_count = 0;
+	uint8 ac_available = 0;  /* Bitmask for 4 ACs + BC/MC */
+
+	if ((state == NULL) ||
+		(fcommit == NULL)) {
+		WLFC_DBGMESG(("Error: %s():%d\n", __FUNCTION__, __LINE__));
+		return BCME_BADARG;
+	}
+
+	memset(&commit_info, 0, sizeof(commit_info));
+
+	/*
+	Commit packets for regular AC traffic. Higher priority first.
+	First, use up FIFO credits available to each AC. Based on distribution
+	and credits left, borrow from other ACs as applicable
+
+	-NOTE:
+	If the bus between the host and firmware is overwhelmed by the
+	traffic from host, it is possible that higher priority traffic
+	starves the lower priority queue. If that occurs often, we may
+	have to employ weighted round-robin or ucode scheme to avoid
+	low priority packet starvation.
+	*/
+
+	if (pktbuf) {
+		ac = DHD_PKTTAG_FIFO(PKTTAG(pktbuf));
+		if (ETHER_ISMULTI(DHD_PKTTAG_DSTN(PKTTAG(pktbuf)))) {
+				ASSERT(ac == AC_COUNT);
+			commit_info.needs_hdr = 1;
+			commit_info.mac_entry = NULL;
+			commit_info.pkt_type = eWLFC_PKTTYPE_NEW;
+			commit_info.p = pktbuf;
+			if (ctx->FIFO_credit[ac]) {
+				rc = _dhd_wlfc_handle_packet_commit(ctx, ac, &commit_info,
+					fcommit, commit_ctx);
+
+			/* Bus commits may fail (e.g. flow control); abort after retries */
+				if (rc == BCME_OK) {
+					if (commit_info.ac_fifo_credit_spent) {
+						(void) _dhd_wlfc_borrow_credit(ctx,
+							ac_available, ac);
+						credit_count--;
+					}
+				} else {
+					bus_retry_count++;
+					if (bus_retry_count >= BUS_RETRIES) {
+						DHD_ERROR((" %s: bus error %d\n",
+							__FUNCTION__, rc));
+						return rc;
+					}
+				}
+			}
+		}
+		else {
+			/* en-queue the packets to respective queue. */
+			rc = _dhd_wlfc_enque_delayq(ctx, pktbuf, ac);
+		}
+	}
+
+	for (ac = AC_COUNT; ac >= 0; ac--) {
+
+		int initial_credit_count = ctx->FIFO_credit[ac];
+
+		/* packets from delayQ with less priority are fresh and they'd need header and
+		  * have no MAC entry
+		  */
+		commit_info.needs_hdr = 1;
+		commit_info.mac_entry = NULL;
+		commit_info.pkt_type = eWLFC_PKTTYPE_NEW;
+
+		for (credit = 0; credit < ctx->FIFO_credit[ac];) {
+			commit_info.p = _dhd_wlfc_deque_delayedq(ctx, ac,
+			                &(commit_info.ac_fifo_credit_spent),
+			                &(commit_info.needs_hdr),
+			                &(commit_info.mac_entry));
+
+			if (commit_info.p == NULL)
+				break;
+
+			commit_info.pkt_type = (commit_info.needs_hdr) ? eWLFC_PKTTYPE_DELAYED :
+				eWLFC_PKTTYPE_SUPPRESSED;
+
+			rc = _dhd_wlfc_handle_packet_commit(ctx, ac, &commit_info,
+			     fcommit, commit_ctx);
+
+			/* Bus commits may fail (e.g. flow control); abort after retries */
+			if (rc == BCME_OK) {
+				if (commit_info.ac_fifo_credit_spent) {
+					credit++;
+				}
+			}
+			else {
+				bus_retry_count++;
+				if (bus_retry_count >= BUS_RETRIES) {
+					DHD_ERROR(("%s: bus error %d\n", __FUNCTION__, rc));
+					ctx->FIFO_credit[ac] -= credit;
+					return rc;
+				}
+			}
+		}
+
+		ctx->FIFO_credit[ac] -= credit;
+
+
+		/* If no credits were used, the queue is idle and can be re-used
+		   Note that resv credits cannot be borrowed
+		   */
+		if (initial_credit_count == ctx->FIFO_credit[ac]) {
+			ac_available |= (1 << ac);
+			credit_count += ctx->FIFO_credit[ac];
+		}
+	}
+
+	/* We borrow only for AC_BE and only if no other traffic seen for DEFER_PERIOD
+
+	   Note that (ac_available & WLFC_AC_BE_TRAFFIC_ONLY) is done to:
+	   a) ignore BC/MC for deferring borrow
+	   b) ignore AC_BE being available along with other ACs
+		  (this should happen only for pure BC/MC traffic)
+
+	   i.e. AC_VI, AC_VO, AC_BK all MUST be available (i.e. no traffic) and
+	   we do not care if AC_BE and BC/MC are available or not
+	   */
+	if ((ac_available & WLFC_AC_BE_TRAFFIC_ONLY) == WLFC_AC_BE_TRAFFIC_ONLY) {
+
+		if (ctx->allow_credit_borrow) {
+			ac = 1;  /* Set ac to AC_BE and borrow credits */
+		}
+		else {
+			int delta;
+			int curr_t = OSL_SYSUPTIME();
+
+			if (curr_t > ctx->borrow_defer_timestamp)
+				delta = curr_t - ctx->borrow_defer_timestamp;
+			else
+				delta = 0xffffffff + curr_t - ctx->borrow_defer_timestamp;
+
+			if (delta >= WLFC_BORROW_DEFER_PERIOD_MS) {
+				/* Reset borrow but defer to next iteration (defensive borrowing) */
+				ctx->allow_credit_borrow = TRUE;
+				ctx->borrow_defer_timestamp = 0;
+			}
+			return BCME_OK;
+		}
+	}
+	else {
+		/* If we have multiple AC traffic, turn off borrowing, mark time and bail out */
+		ctx->allow_credit_borrow = FALSE;
+		ctx->borrow_defer_timestamp = OSL_SYSUPTIME();
+		return BCME_OK;
+	}
+
+	/* At this point, borrow all credits only for "ac" (which should be set above to AC_BE)
+	   Generically use "ac" only in case we extend to all ACs in future
+	   */
+	for (; (credit_count > 0);) {
+
+		commit_info.p = _dhd_wlfc_deque_delayedq(ctx, ac,
+		                &(commit_info.ac_fifo_credit_spent),
+		                &(commit_info.needs_hdr),
+		                &(commit_info.mac_entry));
+		if (commit_info.p == NULL)
+			break;
+
+		commit_info.pkt_type = (commit_info.needs_hdr) ? eWLFC_PKTTYPE_DELAYED :
+			eWLFC_PKTTYPE_SUPPRESSED;
+
+		rc = _dhd_wlfc_handle_packet_commit(ctx, ac, &commit_info,
+		     fcommit, commit_ctx);
+
+		/* Bus commits may fail (e.g. flow control); abort after retries */
+		if (rc == BCME_OK) {
+			if (commit_info.ac_fifo_credit_spent) {
+				(void) _dhd_wlfc_borrow_credit(ctx, ac_available, ac);
+				credit_count--;
+			}
+		}
+		else {
+			bus_retry_count++;
+			if (bus_retry_count >= BUS_RETRIES) {
+				DHD_ERROR(("%s: bus error %d\n", __FUNCTION__, rc));
+				return rc;
+			}
+		}
+	}
+	return BCME_OK;
+}
+
+static uint8
+dhd_wlfc_find_mac_desc_id_from_mac(dhd_pub_t *dhdp, uint8* ea)
+{
+	wlfc_mac_descriptor_t* table =
+		((athost_wl_status_info_t*)dhdp->wlfc_state)->destination_entries.nodes;
+	uint8 table_index;
+
+	if (ea != NULL) {
+		for (table_index = 0; table_index < WLFC_MAC_DESC_TABLE_SIZE; table_index++) {
+			if ((memcmp(ea, &table[table_index].ea[0], ETHER_ADDR_LEN) == 0) &&
+				table[table_index].occupied)
+				return table_index;
+		}
+	}
+	return WLFC_MAC_DESC_ID_INVALID;
+}
+
+void
+dhd_wlfc_txcomplete(dhd_pub_t *dhd, void *txp, bool success)
+{
+	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
+		dhd->wlfc_state;
+	void* p;
+	int fifo_id;
+
+	if (DHD_PKTTAG_SIGNALONLY(PKTTAG(txp))) {
+#ifdef PROP_TXSTATUS_DEBUG
+		wlfc->stats.signal_only_pkts_freed++;
+#endif
+		/* is this a signal-only packet? */
+		if (success)
+			PKTFREE(wlfc->osh, txp, TRUE);
+		return;
+	}
+	if (!success) {
+		WLFC_DBGMESG(("At: %s():%d, bus_complete() failure for %p, htod_tag:0x%08x\n",
+			__FUNCTION__, __LINE__, txp, DHD_PKTTAG_H2DTAG(PKTTAG(txp))));
+		dhd_wlfc_hanger_poppkt(wlfc->hanger, WLFC_PKTID_HSLOT_GET(DHD_PKTTAG_H2DTAG
+			(PKTTAG(txp))), &p, 1);
+
+		/* indicate failure and free the packet */
+		dhd_txcomplete(dhd, txp, FALSE);
+
+		/* return the credit, if necessary */
+		if (DHD_PKTTAG_CREDITCHECK(PKTTAG(txp))) {
+			int lender, credit_returned = 0; /* Note that borrower is fifo_id */
+
+			fifo_id = DHD_PKTTAG_FIFO(PKTTAG(txp));
+
+			/* Return credits to highest priority lender first */
+			for (lender = AC_COUNT; lender >= 0; lender--) {
+				if (wlfc->credits_borrowed[fifo_id][lender] > 0) {
+					wlfc->FIFO_credit[lender]++;
+					wlfc->credits_borrowed[fifo_id][lender]--;
+					credit_returned = 1;
+					break;
+				}
+			}
+
+			if (!credit_returned) {
+				wlfc->FIFO_credit[fifo_id]++;
+			}
+		}
+
+		PKTFREE(wlfc->osh, txp, TRUE);
+	}
+	return;
+}
+
+static int
+dhd_wlfc_compressed_txstatus_update(dhd_pub_t *dhd, uint8* pkt_info, uint8 len)
+{
+	uint8 	status_flag;
+	uint32	status;
+	int		ret;
+	int		remove_from_hanger = 1;
+	void*	pktbuf;
+	uint8	fifo_id;
+	uint8 count = 0;
+	uint32 status_g;
+	uint32 hslot, hcnt;
+	wlfc_mac_descriptor_t* entry = NULL;
+	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
+		dhd->wlfc_state;
+
+	memcpy(&status, pkt_info, sizeof(uint32));
+	status_flag = WL_TXSTATUS_GET_FLAGS(status);
+	status_g = status & 0xff000000;
+	hslot = (status & 0x00ffff00) >> 8;
+	hcnt = status & 0xff;
+	len =	pkt_info[4];
+
+	wlfc->stats.txstatus_in++;
+
+	if (status_flag == WLFC_CTL_PKTFLAG_DISCARD) {
+		wlfc->stats.pkt_freed++;
+	}
+
+	else if (status_flag == WLFC_CTL_PKTFLAG_D11SUPPRESS) {
+		wlfc->stats.d11_suppress++;
+		remove_from_hanger = 0;
+	}
+
+	else if (status_flag == WLFC_CTL_PKTFLAG_WLSUPPRESS) {
+		wlfc->stats.wl_suppress++;
+		remove_from_hanger = 0;
+	}
+
+	else if (status_flag == WLFC_CTL_PKTFLAG_TOSSED_BYWLC) {
+		wlfc->stats.wlc_tossed_pkts++;
+	}
+	while (count < len) {
+		status = (status_g << 24) | (hslot << 8) | (hcnt);
+		count++;
+		hslot++;
+		hcnt++;
+
+		ret = dhd_wlfc_hanger_poppkt(wlfc->hanger,
+			WLFC_PKTID_HSLOT_GET(status), &pktbuf, remove_from_hanger);
+		if (ret != BCME_OK) {
+			/* do something */
+			continue;
+		}
+
+		entry = _dhd_wlfc_find_table_entry(wlfc, pktbuf);
+
+		if (!remove_from_hanger) {
+			/* this packet was suppressed */
+			if (!entry->suppressed || entry->generation != WLFC_PKTID_GEN(status)) {
+				entry->suppressed = TRUE;
+				entry->suppress_count = pktq_mlen(&entry->psq,
+					NBITVAL((WL_TXSTATUS_GET_FIFO(status) << 1) + 1));
+				entry->suppr_transit_count = entry->transit_count;
+			}
+			entry->generation = WLFC_PKTID_GEN(status);
+		}
+
+#ifdef PROP_TXSTATUS_DEBUG
+		{
+			uint32 new_t = OSL_SYSUPTIME();
+			uint32 old_t;
+			uint32 delta;
+			old_t = ((wlfc_hanger_t*)(wlfc->hanger))->items[
+				WLFC_PKTID_HSLOT_GET(status)].push_time;
+
+
+			wlfc->stats.latency_sample_count++;
+			if (new_t > old_t)
+				delta = new_t - old_t;
+			else
+				delta = 0xffffffff + new_t - old_t;
+			wlfc->stats.total_status_latency += delta;
+			wlfc->stats.latency_most_recent = delta;
+
+			wlfc->stats.deltas[wlfc->stats.idx_delta++] = delta;
+			if (wlfc->stats.idx_delta == sizeof(wlfc->stats.deltas)/sizeof(uint32))
+				wlfc->stats.idx_delta = 0;
+		}
+#endif /* PROP_TXSTATUS_DEBUG */
+
+		fifo_id = DHD_PKTTAG_FIFO(PKTTAG(pktbuf));
+
+		/* pick up the implicit credit from this packet */
+		if (DHD_PKTTAG_CREDITCHECK(PKTTAG(pktbuf))) {
+			if (wlfc->proptxstatus_mode == WLFC_FCMODE_IMPLIED_CREDIT) {
+
+				int lender, credit_returned = 0; /* Note that borrower is fifo_id */
+
+				/* Return credits to highest priority lender first */
+				for (lender = AC_COUNT; lender >= 0; lender--)	{
+					if (wlfc->credits_borrowed[fifo_id][lender] > 0) {
+						wlfc->FIFO_credit[lender]++;
+						wlfc->credits_borrowed[fifo_id][lender]--;
+						credit_returned = 1;
+						break;
+					}
+				}
+
+				if (!credit_returned) {
+					wlfc->FIFO_credit[fifo_id]++;
+				}
+			}
+		}
+		else {
+			/*
+			if this packet did not count against FIFO credit, it must have
+			taken a requested_credit from the destination entry (for pspoll etc.)
+			*/
+			if (!entry) {
+
+				entry = _dhd_wlfc_find_table_entry(wlfc, pktbuf);
+			}
+			if (!DHD_PKTTAG_ONETIMEPKTRQST(PKTTAG(pktbuf)))
+				entry->requested_credit++;
+#ifdef PROP_TXSTATUS_DEBUG
+			entry->dstncredit_acks++;
+#endif
+		}
+		if ((status_flag == WLFC_CTL_PKTFLAG_D11SUPPRESS) ||
+			(status_flag == WLFC_CTL_PKTFLAG_WLSUPPRESS)) {
+
+			ret = _dhd_wlfc_enque_suppressed(wlfc, fifo_id, pktbuf);
+			if (ret != BCME_OK) {
+				/* delay q is full, drop this packet */
+				dhd_wlfc_hanger_poppkt(wlfc->hanger, WLFC_PKTID_HSLOT_GET(status),
+				&pktbuf, 1);
+
+				/* indicate failure and free the packet */
+				dhd_txcomplete(dhd, pktbuf, FALSE);
+				entry->transit_count--;
+				DHD_WLFC_QMON_COMPLETE(entry);
+				/* packet is transmitted Successfully by dongle
+				 * after first suppress.
+				 */
+				if (entry->suppressed) {
+					entry->suppr_transit_count--;
+				}
+				PKTFREE(wlfc->osh, pktbuf, TRUE);
+			} else {
+				/* Mark suppressed to avoid a double free during wlfc cleanup */
+
+				dhd_wlfc_hanger_mark_suppressed(wlfc->hanger,
+				WLFC_PKTID_HSLOT_GET(status), WLFC_PKTID_GEN(status));
+				entry->suppress_count++;
+			}
+		}
+		else {
+			dhd_txcomplete(dhd, pktbuf, TRUE);
+			entry->transit_count--;
+			DHD_WLFC_QMON_COMPLETE(entry);
+
+			/* This packet is transmitted Successfully by dongle
+			 * even after first suppress.
+			 */
+			if (entry->suppressed) {
+				entry->suppr_transit_count--;
+			}
+			/* free the packet */
+			PKTFREE(wlfc->osh, pktbuf, TRUE);
+		}
+	}
+	return BCME_OK;
+}
+
+/* Handle discard or suppress indication */
+static int
+dhd_wlfc_txstatus_update(dhd_pub_t *dhd, uint8* pkt_info)
+{
+	uint8 	status_flag;
+	uint32	status;
+	int		ret;
+	int		remove_from_hanger = 1;
+	void*	pktbuf;
+	uint8	fifo_id;
+	wlfc_mac_descriptor_t* entry = NULL;
+	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
+		dhd->wlfc_state;
+
+	memcpy(&status, pkt_info, sizeof(uint32));
+	status_flag = WL_TXSTATUS_GET_FLAGS(status);
+	wlfc->stats.txstatus_in++;
+
+	if (status_flag == WLFC_CTL_PKTFLAG_DISCARD) {
+		wlfc->stats.pkt_freed++;
+	}
+
+	else if (status_flag == WLFC_CTL_PKTFLAG_D11SUPPRESS) {
+		wlfc->stats.d11_suppress++;
+		remove_from_hanger = 0;
+	}
+
+	else if (status_flag == WLFC_CTL_PKTFLAG_WLSUPPRESS) {
+		wlfc->stats.wl_suppress++;
+		remove_from_hanger = 0;
+	}
+
+	else if (status_flag == WLFC_CTL_PKTFLAG_TOSSED_BYWLC) {
+		wlfc->stats.wlc_tossed_pkts++;
+	}
+
+	ret = dhd_wlfc_hanger_poppkt(wlfc->hanger,
+		WLFC_PKTID_HSLOT_GET(status), &pktbuf, remove_from_hanger);
+	if (ret != BCME_OK) {
+		/* do something */
+		return ret;
+	}
+
+	entry = _dhd_wlfc_find_table_entry(wlfc, pktbuf);
+
+	if (!remove_from_hanger) {
+		/* this packet was suppressed */
+		if (!entry->suppressed || entry->generation != WLFC_PKTID_GEN(status)) {
+			entry->suppressed = TRUE;
+			entry->suppress_count = pktq_mlen(&entry->psq,
+				NBITVAL((WL_TXSTATUS_GET_FIFO(status) << 1) + 1));
+			entry->suppr_transit_count = entry->transit_count;
+		}
+		entry->generation = WLFC_PKTID_GEN(status);
+	}
+
+#ifdef PROP_TXSTATUS_DEBUG
+	{
+		uint32 new_t = OSL_SYSUPTIME();
+		uint32 old_t;
+		uint32 delta;
+		old_t = ((wlfc_hanger_t*)(wlfc->hanger))->items[
+			WLFC_PKTID_HSLOT_GET(status)].push_time;
+
+
+		wlfc->stats.latency_sample_count++;
+		if (new_t > old_t)
+			delta = new_t - old_t;
+		else
+			delta = 0xffffffff + new_t - old_t;
+		wlfc->stats.total_status_latency += delta;
+		wlfc->stats.latency_most_recent = delta;
+
+		wlfc->stats.deltas[wlfc->stats.idx_delta++] = delta;
+		if (wlfc->stats.idx_delta == sizeof(wlfc->stats.deltas)/sizeof(uint32))
+			wlfc->stats.idx_delta = 0;
+	}
+#endif /* PROP_TXSTATUS_DEBUG */
+
+	fifo_id = DHD_PKTTAG_FIFO(PKTTAG(pktbuf));
+
+	/* pick up the implicit credit from this packet */
+	if (DHD_PKTTAG_CREDITCHECK(PKTTAG(pktbuf))) {
+		if (wlfc->proptxstatus_mode == WLFC_FCMODE_IMPLIED_CREDIT) {
+
+			int lender, credit_returned = 0; /* Note that borrower is fifo_id */
+
+			/* Return credits to highest priority lender first */
+			for (lender = AC_COUNT; lender >= 0; lender--)	{
+				if (wlfc->credits_borrowed[fifo_id][lender] > 0) {
+					wlfc->FIFO_credit[lender]++;
+					wlfc->credits_borrowed[fifo_id][lender]--;
+					credit_returned = 1;
+					break;
+				}
+			}
+
+			if (!credit_returned) {
+				wlfc->FIFO_credit[fifo_id]++;
+			}
+		}
+	}
+	else {
+		/*
+		if this packet did not count against FIFO credit, it must have
+		taken a requested_credit from the destination entry (for pspoll etc.)
+		*/
+		if (!entry) {
+
+			entry = _dhd_wlfc_find_table_entry(wlfc, pktbuf);
+		}
+		if (!DHD_PKTTAG_ONETIMEPKTRQST(PKTTAG(pktbuf)))
+			entry->requested_credit++;
+#ifdef PROP_TXSTATUS_DEBUG
+		entry->dstncredit_acks++;
+#endif
+	}
+	if ((status_flag == WLFC_CTL_PKTFLAG_D11SUPPRESS) ||
+		(status_flag == WLFC_CTL_PKTFLAG_WLSUPPRESS)) {
+
+		ret = _dhd_wlfc_enque_suppressed(wlfc, fifo_id, pktbuf);
+		if (ret != BCME_OK) {
+			/* delay q is full, drop this packet */
+			dhd_wlfc_hanger_poppkt(wlfc->hanger, WLFC_PKTID_HSLOT_GET(status),
+			&pktbuf, 1);
+
+			/* indicate failure and free the packet */
+			dhd_txcomplete(dhd, pktbuf, FALSE);
+			entry->transit_count--;
+			DHD_WLFC_QMON_COMPLETE(entry);
+			/* This packet is transmitted Successfully by
+			 *  dongle even after first suppress.
+			 */
+			if (entry->suppressed) {
+				entry->suppr_transit_count--;
+			}
+			PKTFREE(wlfc->osh, pktbuf, TRUE);
+		} else {
+			/* Mark suppressed to avoid a double free during wlfc cleanup */
+
+			dhd_wlfc_hanger_mark_suppressed(wlfc->hanger,
+			WLFC_PKTID_HSLOT_GET(status), WLFC_PKTID_GEN(status));
+			entry->suppress_count++;
+		}
+	}
+	else {
+		dhd_txcomplete(dhd, pktbuf, TRUE);
+		entry->transit_count--;
+		DHD_WLFC_QMON_COMPLETE(entry);
+
+		/* This packet is transmitted Successfully by dongle even after first suppress. */
+		if (entry->suppressed) {
+			entry->suppr_transit_count--;
+		}
+		/* free the packet */
+		PKTFREE(wlfc->osh, pktbuf, TRUE);
+	}
+	return BCME_OK;
+}
+
+static int
+dhd_wlfc_fifocreditback_indicate(dhd_pub_t *dhd, uint8* credits)
+{
+	int i;
+	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
+		dhd->wlfc_state;
+	for (i = 0; i < WLFC_CTL_VALUE_LEN_FIFO_CREDITBACK; i++) {
+#ifdef PROP_TXSTATUS_DEBUG
+		wlfc->stats.fifo_credits_back[i] += credits[i];
+#endif
+		/* update FIFO credits */
+		if (wlfc->proptxstatus_mode == WLFC_FCMODE_EXPLICIT_CREDIT)
+		{
+			int lender; /* Note that borrower is i */
+
+			/* Return credits to highest priority lender first */
+			for (lender = AC_COUNT; (lender >= 0) && (credits[i] > 0); lender--) {
+				if (wlfc->credits_borrowed[i][lender] > 0) {
+					if (credits[i] >= wlfc->credits_borrowed[i][lender]) {
+						credits[i] -= wlfc->credits_borrowed[i][lender];
+						wlfc->FIFO_credit[lender] +=
+						    wlfc->credits_borrowed[i][lender];
+						wlfc->credits_borrowed[i][lender] = 0;
+					}
+					else {
+						wlfc->credits_borrowed[i][lender] -= credits[i];
+						wlfc->FIFO_credit[lender] += credits[i];
+						credits[i] = 0;
+					}
+				}
+			}
+
+			/* If we have more credits left over, these must belong to the AC */
+			if (credits[i] > 0) {
+				wlfc->FIFO_credit[i] += credits[i];
+			}
+		}
+	}
+
+	return BCME_OK;
+}
+
+static int
+dhd_wlfc_dbg_senum_check(dhd_pub_t *dhd, uint8 *value)
+{
+	uint32 timestamp;
+
+	(void)dhd;
+
+	bcopy(&value[2], &timestamp, sizeof(uint32));
+	DHD_INFO(("RXPKT: SEQ: %d, timestamp %d\n", value[1], timestamp));
+	return BCME_OK;
+}
+
+
+static int
+dhd_wlfc_rssi_indicate(dhd_pub_t *dhd, uint8* rssi)
+{
+	(void)dhd;
+	(void)rssi;
+	return BCME_OK;
+}
+
+static int
+dhd_wlfc_mac_table_update(dhd_pub_t *dhd, uint8* value, uint8 type)
+{
+	int rc;
+	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
+		dhd->wlfc_state;
+	wlfc_mac_descriptor_t* table;
+	uint8 existing_index;
+	uint8 table_index;
+	uint8 ifid;
+	uint8* ea;
+
+	WLFC_DBGMESG(("%s(), mac [%02x:%02x:%02x:%02x:%02x:%02x],%s,idx:%d,id:0x%02x\n",
+		__FUNCTION__, value[2], value[3], value[4], value[5], value[6], value[7],
+		((type == WLFC_CTL_TYPE_MACDESC_ADD) ? "ADD":"DEL"),
+		WLFC_MAC_DESC_GET_LOOKUP_INDEX(value[0]), value[0]));
+
+	table = wlfc->destination_entries.nodes;
+	table_index = WLFC_MAC_DESC_GET_LOOKUP_INDEX(value[0]);
+	ifid = value[1];
+	ea = &value[2];
+
+	if (type == WLFC_CTL_TYPE_MACDESC_ADD) {
+		existing_index = dhd_wlfc_find_mac_desc_id_from_mac(dhd, &value[2]);
+		if (existing_index == WLFC_MAC_DESC_ID_INVALID) {
+			/* this MAC entry does not exist, create one */
+			if (!table[table_index].occupied) {
+				table[table_index].mac_handle = value[0];
+				rc = _dhd_wlfc_mac_entry_update(wlfc, &table[table_index],
+				eWLFC_MAC_ENTRY_ACTION_ADD, ifid,
+				wlfc->destination_entries.interfaces[ifid].iftype,
+				ea);
+			}
+			else {
+				/* the space should have been empty, but it's not */
+				wlfc->stats.mac_update_failed++;
+			}
+		}
+		else {
+			/*
+			there is an existing entry, move it to new index
+			if necessary.
+			*/
+			if (existing_index != table_index) {
+				/* if we already have an entry, free the old one */
+				table[existing_index].occupied = 0;
+				table[existing_index].state = WLFC_STATE_CLOSE;
+				table[existing_index].requested_credit = 0;
+				table[existing_index].interface_id = 0;
+				/* enable after packets are queued-deqeued properly.
+				pktq_flush(dhd->osh, &table[existing_index].psq, FALSE, NULL, 0);
+				*/
+			}
+		}
+	}
+	if (type == WLFC_CTL_TYPE_MACDESC_DEL) {
+		if (table[table_index].occupied) {
+				rc = _dhd_wlfc_mac_entry_update(wlfc, &table[table_index],
+					eWLFC_MAC_ENTRY_ACTION_DEL, ifid,
+					wlfc->destination_entries.interfaces[ifid].iftype,
+					ea);
+		}
+		else {
+			/* the space should have been occupied, but it's not */
+			wlfc->stats.mac_update_failed++;
+		}
+	}
+	BCM_REFERENCE(rc);
+	return BCME_OK;
+}
+
+static int
+dhd_wlfc_psmode_update(dhd_pub_t *dhd, uint8* value, uint8 type)
+{
+	/* Handle PS on/off indication */
+	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
+		dhd->wlfc_state;
+	wlfc_mac_descriptor_t* table;
+	wlfc_mac_descriptor_t* desc;
+	uint8 mac_handle = value[0];
+	int i;
+
+	table = wlfc->destination_entries.nodes;
+	desc = &table[WLFC_MAC_DESC_GET_LOOKUP_INDEX(mac_handle)];
+	if (desc->occupied) {
+		/* a fresh PS mode should wipe old ps credits? */
+		desc->requested_credit = 0;
+		if (type == WLFC_CTL_TYPE_MAC_OPEN) {
+			desc->state = WLFC_STATE_OPEN;
+			DHD_WLFC_CTRINC_MAC_OPEN(desc);
+		}
+		else {
+			desc->state = WLFC_STATE_CLOSE;
+			DHD_WLFC_CTRINC_MAC_CLOSE(desc);
+			/*
+			Indicate to firmware if there is any traffic pending.
+			*/
+			for (i = AC_BE; i < AC_COUNT; i++) {
+				_dhd_wlfc_traffic_pending_check(wlfc, desc, i);
+			}
+		}
+	}
+	else {
+		wlfc->stats.psmode_update_failed++;
+	}
+	return BCME_OK;
+}
+
+static int
+dhd_wlfc_interface_update(dhd_pub_t *dhd, uint8* value, uint8 type)
+{
+	/* Handle PS on/off indication */
+	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
+		dhd->wlfc_state;
+	wlfc_mac_descriptor_t* table;
+	uint8 if_id = value[0];
+
+	if (if_id < WLFC_MAX_IFNUM) {
+		table = wlfc->destination_entries.interfaces;
+		if (table[if_id].occupied) {
+			if (type == WLFC_CTL_TYPE_INTERFACE_OPEN) {
+				table[if_id].state = WLFC_STATE_OPEN;
+				/* WLFC_DBGMESG(("INTERFACE[%d] OPEN\n", if_id)); */
+			}
+			else {
+				table[if_id].state = WLFC_STATE_CLOSE;
+				/* WLFC_DBGMESG(("INTERFACE[%d] CLOSE\n", if_id)); */
+			}
+			return BCME_OK;
+		}
+	}
+	wlfc->stats.interface_update_failed++;
+
+	return BCME_OK;
+}
+
+static int
+dhd_wlfc_credit_request(dhd_pub_t *dhd, uint8* value)
+{
+	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
+		dhd->wlfc_state;
+	wlfc_mac_descriptor_t* table;
+	wlfc_mac_descriptor_t* desc;
+	uint8 mac_handle;
+	uint8 credit;
+
+	table = wlfc->destination_entries.nodes;
+	mac_handle = value[1];
+	credit = value[0];
+
+	desc = &table[WLFC_MAC_DESC_GET_LOOKUP_INDEX(mac_handle)];
+	if (desc->occupied) {
+		desc->requested_credit = credit;
+
+		desc->ac_bitmap = value[2];
+	}
+	else {
+		wlfc->stats.credit_request_failed++;
+	}
+	return BCME_OK;
+}
+
+static int
+dhd_wlfc_packet_request(dhd_pub_t *dhd, uint8* value)
+{
+	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
+		dhd->wlfc_state;
+	wlfc_mac_descriptor_t* table;
+	wlfc_mac_descriptor_t* desc;
+	uint8 mac_handle;
+	uint8 packet_count;
+
+	table = wlfc->destination_entries.nodes;
+	mac_handle = value[1];
+	packet_count = value[0];
+
+	desc = &table[WLFC_MAC_DESC_GET_LOOKUP_INDEX(mac_handle)];
+	if (desc->occupied) {
+		desc->requested_packet = packet_count;
+
+		desc->ac_bitmap = value[2];
+	}
+	else {
+		wlfc->stats.packet_request_failed++;
+	}
+	return BCME_OK;
+}
+
+static void
+dhd_wlfc_reorderinfo_indicate(uint8 *val, uint8 len, uchar *info_buf, uint *info_len)
+{
+	if (info_len) {
+		if (info_buf) {
+			bcopy(val, info_buf, len);
+			*info_len = len;
+		}
+		else
+			*info_len = 0;
+	}
+}
+
+int
+dhd_wlfc_parse_header_info(dhd_pub_t *dhd, void* pktbuf, int tlv_hdr_len, uchar *reorder_info_buf,
+	uint *reorder_info_len)
+{
+	uint8 type, len;
+	uint8* value;
+	uint8* tmpbuf;
+	uint16 remainder = tlv_hdr_len;
+	uint16 processed = 0;
+	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
+		dhd->wlfc_state;
+	tmpbuf = (uint8*)PKTDATA(dhd->osh, pktbuf);
+	if (remainder) {
+		while ((processed < (WLFC_MAX_PENDING_DATALEN * 2)) && (remainder > 0)) {
+			type = tmpbuf[processed];
+			if (type == WLFC_CTL_TYPE_FILLER) {
+				remainder -= 1;
+				processed += 1;
+				continue;
+			}
+
+			len  = tmpbuf[processed + 1];
+			value = &tmpbuf[processed + 2];
+
+			if (remainder < (2 + len))
+				break;
+
+			remainder -= 2 + len;
+			processed += 2 + len;
+			if (type == WLFC_CTL_TYPE_TXSTATUS)
+				dhd_wlfc_txstatus_update(dhd, value);
+			if (type == WLFC_CTL_TYPE_COMP_TXSTATUS)
+				dhd_wlfc_compressed_txstatus_update(dhd, value, len);
+
+			else if (type == WLFC_CTL_TYPE_HOST_REORDER_RXPKTS)
+				dhd_wlfc_reorderinfo_indicate(value, len, reorder_info_buf,
+					reorder_info_len);
+			else if (type == WLFC_CTL_TYPE_FIFO_CREDITBACK)
+				dhd_wlfc_fifocreditback_indicate(dhd, value);
+
+			else if (type == WLFC_CTL_TYPE_RSSI)
+				dhd_wlfc_rssi_indicate(dhd, value);
+
+			else if (type == WLFC_CTL_TYPE_MAC_REQUEST_CREDIT)
+				dhd_wlfc_credit_request(dhd, value);
+
+			else if (type == WLFC_CTL_TYPE_MAC_REQUEST_PACKET)
+				dhd_wlfc_packet_request(dhd, value);
+
+			else if ((type == WLFC_CTL_TYPE_MAC_OPEN) ||
+				(type == WLFC_CTL_TYPE_MAC_CLOSE))
+				dhd_wlfc_psmode_update(dhd, value, type);
+
+			else if ((type == WLFC_CTL_TYPE_MACDESC_ADD) ||
+				(type == WLFC_CTL_TYPE_MACDESC_DEL))
+				dhd_wlfc_mac_table_update(dhd, value, type);
+
+			else if (type == WLFC_CTL_TYPE_TRANS_ID)
+				dhd_wlfc_dbg_senum_check(dhd, value);
+
+			else if ((type == WLFC_CTL_TYPE_INTERFACE_OPEN) ||
+				(type == WLFC_CTL_TYPE_INTERFACE_CLOSE)) {
+				dhd_wlfc_interface_update(dhd, value, type);
+			}
+		}
+		if (remainder != 0) {
+			/* trouble..., something is not right */
+			wlfc->stats.tlv_parse_failed++;
+		}
+	}
+	return BCME_OK;
+}
+
+int
+dhd_wlfc_init(dhd_pub_t *dhd)
+{
+	char iovbuf[12]; /* Room for "tlv" + '\0' + parameter */
+	/* enable all signals & indicate host proptxstatus logic is active */
+	uint32 tlv = dhd->wlfc_enabled?
+		WLFC_FLAGS_RSSI_SIGNALS |
+		WLFC_FLAGS_XONXOFF_SIGNALS |
+		WLFC_FLAGS_CREDIT_STATUS_SIGNALS |
+		WLFC_FLAGS_HOST_PROPTXSTATUS_ACTIVE |
+		WLFC_FLAGS_HOST_RXRERODER_ACTIVE : 0;
+		/* WLFC_FLAGS_HOST_PROPTXSTATUS_ACTIVE | WLFC_FLAGS_HOST_RXRERODER_ACTIVE : 0; */
+
+
+	/*
+	try to enable/disable signaling by sending "tlv" iovar. if that fails,
+	fallback to no flow control? Print a message for now.
+	*/
+
+	/* enable proptxtstatus signaling by default */
+	bcm_mkiovar("tlv", (char *)&tlv, 4, iovbuf, sizeof(iovbuf));
+	if (dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0) < 0) {
+		DHD_ERROR(("dhd_wlfc_init(): failed to enable/disable bdcv2 tlv signaling\n"));
+	}
+	else {
+		/*
+		Leaving the message for now, it should be removed after a while; once
+		the tlv situation is stable.
+		*/
+		DHD_ERROR(("dhd_wlfc_init(): successfully %s bdcv2 tlv signaling, %d\n",
+			dhd->wlfc_enabled?"enabled":"disabled", tlv));
+	}
+	return BCME_OK;
+}
+
+int
+dhd_wlfc_enable(dhd_pub_t *dhd)
+{
+	int i;
+	athost_wl_status_info_t* wlfc;
+
+	if (!dhd->wlfc_enabled || dhd->wlfc_state)
+		return BCME_OK;
+
+	/* allocate space to track txstatus propagated from firmware */
+	dhd->wlfc_state = MALLOC(dhd->osh, sizeof(athost_wl_status_info_t));
+	if (dhd->wlfc_state == NULL)
+		return BCME_NOMEM;
+
+	/* initialize state space */
+	wlfc = (athost_wl_status_info_t*)dhd->wlfc_state;
+	memset(wlfc, 0, sizeof(athost_wl_status_info_t));
+
+	/* remember osh & dhdp */
+	wlfc->osh = dhd->osh;
+	wlfc->dhdp = dhd;
+
+	wlfc->hanger =
+		dhd_wlfc_hanger_create(dhd->osh, WLFC_HANGER_MAXITEMS);
+	if (wlfc->hanger == NULL) {
+		MFREE(dhd->osh, dhd->wlfc_state, sizeof(athost_wl_status_info_t));
+		dhd->wlfc_state = NULL;
+		return BCME_NOMEM;
+	}
+
+	/* initialize all interfaces to accept traffic */
+	for (i = 0; i < WLFC_MAX_IFNUM; i++) {
+		wlfc->hostif_flow_state[i] = OFF;
+	}
+
+	wlfc->destination_entries.other.state = WLFC_STATE_OPEN;
+	/* bc/mc FIFO is always open [credit aside], i.e. b[5] */
+	wlfc->destination_entries.other.ac_bitmap = 0x1f;
+	wlfc->destination_entries.other.interface_id = 0;
+
+	wlfc->proptxstatus_mode = WLFC_FCMODE_EXPLICIT_CREDIT;
+
+	wlfc->allow_credit_borrow = TRUE;
+	wlfc->borrow_defer_timestamp = 0;
+
+	if (dhd->plat_enable)
+		dhd->plat_enable((void *)dhd);
+
+	return BCME_OK;
+}
+
+/* release all packet resources */
+void
+dhd_wlfc_cleanup(dhd_pub_t *dhd, ifpkt_cb_t fn, int arg)
+{
+	int i;
+	int total_entries;
+	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
+		dhd->wlfc_state;
+	wlfc_mac_descriptor_t* table;
+	wlfc_hanger_t* h;
+	int prec;
+	void *pkt = NULL;
+	struct pktq *txq = NULL;
+	if (dhd->wlfc_state == NULL)
+		return;
+	/* flush bus->txq */
+	txq = dhd_bus_txq(dhd->bus);
+	/* any in the hanger? */
+	h = (wlfc_hanger_t*)wlfc->hanger;
+	total_entries = sizeof(wlfc->destination_entries)/sizeof(wlfc_mac_descriptor_t);
+	/* search all entries, include nodes as well as interfaces */
+	table = (wlfc_mac_descriptor_t*)&wlfc->destination_entries;
+
+	for (i = 0; i < total_entries; i++) {
+		if (table[i].occupied && (fn == NULL || (arg == table[i].interface_id))) {
+			if (table[i].psq.len) {
+				WLFC_DBGMESG(("%s(): DELAYQ[%d].len = %d\n",
+					__FUNCTION__, i, table[i].psq.len));
+				/* release packets held in DELAYQ */
+				pktq_flush(wlfc->osh, &table[i].psq, TRUE, fn, arg);
+			}
+			if (fn == NULL)
+				table[i].occupied = 0;
+		}
+	}
+	for (prec = 0; prec < txq->num_prec; prec++) {
+		pkt = pktq_pdeq_with_fn(txq, prec, fn, arg);
+		while (pkt) {
+			for (i = 0; i < h->max_items; i++) {
+				if (pkt == h->items[i].pkt) {
+					if (h->items[i].state == WLFC_HANGER_ITEM_STATE_INUSE) {
+						PKTFREE(wlfc->osh, h->items[i].pkt, TRUE);
+						h->items[i].state = WLFC_HANGER_ITEM_STATE_FREE;
+					} else if (h->items[i].state ==
+						WLFC_HANGER_ITEM_STATE_INUSE_SUPPRESSED) {
+						/* These are already freed from the psq */
+						h->items[i].state = WLFC_HANGER_ITEM_STATE_FREE;
+					}
+					break;
+				}
+			}
+			pkt = pktq_pdeq(txq, prec);
+		}
+	}
+	/* flush remained pkt in hanger queue, not in bus->txq */
+	for (i = 0; i < h->max_items; i++) {
+		if (h->items[i].state == WLFC_HANGER_ITEM_STATE_INUSE) {
+			if (fn == NULL || (*fn)(h->items[i].pkt, arg)) {
+				PKTFREE(wlfc->osh, h->items[i].pkt, TRUE);
+				h->items[i].state = WLFC_HANGER_ITEM_STATE_FREE;
+			}
+		} else if (h->items[i].state == WLFC_HANGER_ITEM_STATE_INUSE_SUPPRESSED) {
+			if (fn == NULL || (*fn)(h->items[i].pkt, arg)) {
+				/* These are freed from the psq so no need to free again */
+				h->items[i].state = WLFC_HANGER_ITEM_STATE_FREE;
+			}
+		}
+	}
+	return;
+}
+
+void
+dhd_wlfc_deinit(dhd_pub_t *dhd)
+{
+	/* cleanup all psq related resources */
+	athost_wl_status_info_t* wlfc = (athost_wl_status_info_t*)
+		dhd->wlfc_state;
+
+	dhd_os_wlfc_block(dhd);
+	if (dhd->wlfc_state == NULL) {
+		dhd_os_wlfc_unblock(dhd);
+		return;
+	}
+
+#ifdef PROP_TXSTATUS_DEBUG
+	{
+		int i;
+		wlfc_hanger_t* h = (wlfc_hanger_t*)wlfc->hanger;
+		for (i = 0; i < h->max_items; i++) {
+			if (h->items[i].state != WLFC_HANGER_ITEM_STATE_FREE) {
+				WLFC_DBGMESG(("%s() pkt[%d] = 0x%p, FIFO_credit_used:%d\n",
+					__FUNCTION__, i, h->items[i].pkt,
+					DHD_PKTTAG_CREDITCHECK(PKTTAG(h->items[i].pkt))));
+			}
+		}
+	}
+#endif
+	/* delete hanger */
+	dhd_wlfc_hanger_delete(dhd->osh, wlfc->hanger);
+
+	/* free top structure */
+	MFREE(dhd->osh, dhd->wlfc_state, sizeof(athost_wl_status_info_t));
+	dhd->wlfc_state = NULL;
+	dhd_os_wlfc_unblock(dhd);
+
+	if (dhd->plat_deinit)
+		dhd->plat_deinit((void *)dhd);
+	return;
+}
+#endif /* PROP_TXSTATUS */
diff --git a/drivers/net/wireless/bcmdhd/dhd_wlfc.h b/drivers/net/wireless/bcmdhd/dhd_wlfc.h
old mode 100644
new mode 100755
index 09275a2..f99876b
--- a/drivers/net/wireless/bcmdhd/dhd_wlfc.h
+++ b/drivers/net/wireless/bcmdhd/dhd_wlfc.h
@@ -1,34 +1,22 @@
 /*
-* Copyright (C) 1999-2012, Broadcom Corporation
-* 
-*      Unless you and Broadcom execute a separate written software license
-* agreement governing use of this software, this software is licensed to you
-* under the terms of the GNU General Public License version 2 (the "GPL"),
-* available at http://www.broadcom.com/licenses/GPLv2.php, with the
-* following added to such license:
-* 
-*      As a special exception, the copyright holders of this software give you
-* permission to link this software with independent modules, and to copy and
-* distribute the resulting executable under terms of your choice, provided that
-* you also meet, for each linked independent module, the terms and conditions of
-* the license of that module.  An independent module is a module which is not
-* derived from this software.  The special exception does not apply to any
-* modifications of the software.
-* 
-*      Notwithstanding the above, under no circumstances may you combine this
-* software in any way with any other Broadcom software provided under a license
-* other than the GPL, without Broadcom's express prior written consent.
-* $Id: dhd_wlfc.h 328424 2012-04-19 05:23:09Z $
+* $Copyright Open 2009 Broadcom Corporation$
+* $Id: dhd_wlfc.h 395161 2013-04-05 13:19:38Z $
 *
 */
 #ifndef __wlfc_host_driver_definitions_h__
 #define __wlfc_host_driver_definitions_h__
 
+#ifdef QMONITOR
+#include <dhd_qmon.h>
+#endif
+
+
 /* 16 bits will provide an absolute max of 65536 slots */
 #define WLFC_HANGER_MAXITEMS 1024
 
-#define WLFC_HANGER_ITEM_STATE_FREE		1
-#define WLFC_HANGER_ITEM_STATE_INUSE	2
+#define WLFC_HANGER_ITEM_STATE_FREE				1
+#define WLFC_HANGER_ITEM_STATE_INUSE			2
+#define WLFC_HANGER_ITEM_STATE_INUSE_SUPPRESSED	3
 
 #define WLFC_PKTID_HSLOT_MASK			0xffff /* allow 16 bits only */
 #define WLFC_PKTID_HSLOT_SHIFT			8
@@ -68,7 +56,8 @@ typedef enum ewlfc_mac_entry_action {
 
 typedef struct wlfc_hanger_item {
 	uint8	state;
-	uint8	pad[3];
+	uint8   gen;
+	uint8	pad[2];
 	uint32	identifier;
 	void*	pkt;
 #ifdef PROP_TXSTATUS_DEBUG
@@ -83,6 +72,7 @@ typedef struct wlfc_hanger {
 	uint32 failed_to_push;
 	uint32 failed_to_pop;
 	uint32 failed_slotfind;
+	uint32 slot_pos;
 	wlfc_hanger_item_t items[1];
 } wlfc_hanger_t;
 
@@ -93,13 +83,11 @@ typedef struct wlfc_hanger {
 #define WLFC_STATE_CLOSE	2
 
 #define WLFC_PSQ_PREC_COUNT		((AC_COUNT + 1) * 2) /* 2 for each AC traffic and bc/mc */
-#define WLFC_PSQ_LEN			256
-#define WLFC_SENDQ_LEN			128
-
 
-#define WLFC_FLOWCONTROL_HIWATER	128
-#define WLFC_FLOWCONTROL_LOWATER	64
+#define WLFC_PSQ_LEN			2048
 
+#define WLFC_FLOWCONTROL_HIWATER	(2048 - 256)
+#define WLFC_FLOWCONTROL_LOWATER	256
 
 typedef struct wlfc_mac_descriptor {
 	uint8 occupied;
@@ -124,6 +112,22 @@ typedef struct wlfc_mac_descriptor {
 	/* 1= send on next opportunity */
 	uint8 send_tim_signal;
 	uint8 mac_handle;
+	/* Number of packets in transit for this entry. */
+	uint transit_count;
+	/* Numbe of suppression to wait before evict from delayQ */
+	uint suppr_transit_count;
+	/* Used when a new suppress is detected to track the number of
+	 * packets getting suppressed
+	 */
+	uint suppress_count;
+	/* flag. TRUE when in suppress state */
+	uint8 suppressed;
+	uint8 deleting;
+
+#ifdef QMONITOR
+	dhd_qmon_t qmon;
+#endif /* QMONITOR */
+
 #ifdef PROP_TXSTATUS_DEBUG
 	uint32 dstncredit_sent_packets;
 	uint32 dstncredit_acks;
@@ -145,7 +149,6 @@ typedef struct athost_wl_stat_counters {
 	uint32	tlv_parse_failed;
 	uint32	rollback;
 	uint32	rollback_failed;
-	uint32	sendq_full_error;
 	uint32	delayq_full_error;
 	uint32	credit_request_failed;
 	uint32	packet_request_failed;
@@ -170,7 +173,7 @@ typedef struct athost_wl_stat_counters {
 	uint32	dhd_hdrpulls;
 	uint32	generic_error;
 	/* an extra one for bc/mc traffic */
-	uint32	sendq_pkts[AC_COUNT + 1];
+	uint32	send_pkts[AC_COUNT + 1];
 #ifdef PROP_TXSTATUS_DEBUG
 	/* all pkt2bus -> txstatus latency accumulated */
 	uint32	latency_sample_count;
@@ -229,8 +232,6 @@ typedef struct athost_wl_status_info {
 	/* Credit borrow counts for each FIFO from each of the other FIFOs */
 	int		credits_borrowed[AC_COUNT + 2][AC_COUNT + 2];
 
-	struct  pktq SENDQ;
-
 	/* packet hanger and MAC->handle lookup table */
 	void*	hanger;
 	struct {
@@ -275,4 +276,17 @@ int dhd_wlfc_event(struct dhd_info *dhd);
 int dhd_os_wlfc_block(dhd_pub_t *pub);
 int dhd_os_wlfc_unblock(dhd_pub_t *pub);
 
+void dhd_wlfc_dump(dhd_pub_t *dhdp, struct bcmstrbuf *strbuf);
+int dhd_wlfc_init(dhd_pub_t *dhd);
+void dhd_wlfc_deinit(dhd_pub_t *dhd);
+int dhd_wlfc_parse_header_info(dhd_pub_t *dhd, void* pktbuf, int tlv_hdr_len,
+	uchar *reorder_info_buf, uint *reorder_info_len);
+
+#ifdef QMONITOR
+void dhd_wlfc_qmon_tx(void* state, void *pktbuf);
+#endif
+int dhd_wlfc_commit_packets(void* state, f_commitpkt_t fcommit,
+	void* commit_ctx, void *pktbuf);
+void dhd_wlfc_cleanup(dhd_pub_t *dhd, ifpkt_cb_t fn, int arg);
+bool ifpkt_fn(void* p, int ifid);
 #endif /* __wlfc_host_driver_definitions_h__ */
diff --git a/drivers/net/wireless/bcmdhd/dngl_stats.h b/drivers/net/wireless/bcmdhd/dngl_stats.h
old mode 100644
new mode 100755
index 5e5a2e2..46e1e46
--- a/drivers/net/wireless/bcmdhd/dngl_stats.h
+++ b/drivers/net/wireless/bcmdhd/dngl_stats.h
@@ -2,25 +2,7 @@
  * Common stats definitions for clients of dongle
  * ports
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * $Id: dngl_stats.h 241182 2011-02-17 21:50:03Z $
  */
diff --git a/drivers/net/wireless/bcmdhd/dngl_wlhdr.h b/drivers/net/wireless/bcmdhd/dngl_wlhdr.h
old mode 100644
new mode 100755
index 0e37df6..2891207
--- a/drivers/net/wireless/bcmdhd/dngl_wlhdr.h
+++ b/drivers/net/wireless/bcmdhd/dngl_wlhdr.h
@@ -1,25 +1,7 @@
 /*
  * Dongle WL Header definitions
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * $Id: dngl_wlhdr.h 241182 2011-02-17 21:50:03Z $
  */
diff --git a/drivers/net/wireless/bcmdhd/hndpmu.c b/drivers/net/wireless/bcmdhd/hndpmu.c
old mode 100644
new mode 100755
index eeee5ea..fc2f73a
--- a/drivers/net/wireless/bcmdhd/hndpmu.c
+++ b/drivers/net/wireless/bcmdhd/hndpmu.c
@@ -2,27 +2,18 @@
  * Misc utility routines for accessing PMU corerev specific features
  * of the SiliconBackplane-based Broadcom chips.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: hndpmu.c 324060 2012-03-27 23:26:47Z $
+ * $Id: hndpmu.c 385540 2013-02-15 23:14:50Z $
+ */
+
+/*
+ * Note: this file contains PLL/FLL related functions. A chip can contain multiple PLLs/FLLs.
+ * However, in the context of this file the baseband ('BB') PLL/FLL is referred to.
+ *
+ * Throughout this code, the prefixes 'pmu0_', 'pmu1_' and 'pmu2_' are used.
+ * They refer to different revisions of the PMU (which is at revision 18 @ Apr 25, 2012)
+ * pmu2_ marks the transition from PLL to ADFLL (Digital Frequency Locked Loop)
  */
 
 #include <bcm_cfg.h>
@@ -109,17 +100,61 @@ static const sdiod_drive_str_t sdiod_drive_strength_tab5_1v8[] = {
 
 /* SDIO Drive Strength to sel value table for PMU Rev 13 (3.3v) */
 
+/* SDIO Drive Strength to sel value table for PMU Rev 17 (1.8v) */
+static const sdiod_drive_str_t sdiod_drive_strength_tab6_1v8[] = {
+	{3, 0x3},
+	{2, 0x2},
+	{1, 0x1},
+	{0, 0x0} };
+
+
+/*
+ * SDIO Drive Strength to sel value table for 43143 PMU Rev 17, see Confluence 43143 Toplevel
+ * architecture page, section 'PMU Chip Control 1 Register definition', click link to picture
+ * BCM43143_sel_sdio_signals.jpg. Valid after PMU Chip Control 0 Register, bit31 (override) has
+ * been written '1'.
+ */
+#if !defined(BCM_SDIO_VDDIO) || BCM_SDIO_VDDIO == 33
+
+static const sdiod_drive_str_t sdiod_drive_strength_tab7_3v3[] = {
+	/* note: for 14, 10, 6 and 2mA hw timing is not met according to rtl team */
+	{16, 0x7},
+	{12, 0x5},
+	{8,  0x3},
+	{4,  0x1} }; /* note: 43143 does not support tristate */
+
+#else
+
+static const sdiod_drive_str_t sdiod_drive_strength_tab7_1v8[] = {
+	/* note: for 7, 5, 3 and 1mA hw timing is not met according to rtl team */
+	{8, 0x7},
+	{6, 0x5},
+	{4,  0x3},
+	{2,  0x1} }; /* note: 43143 does not support tristate */
+
+#endif /* BCM_SDIO_VDDIO */
 
 #define SDIOD_DRVSTR_KEY(chip, pmu)	(((chip) << 16) | (pmu))
 
+/**
+ * Balance between stable SDIO operation and power consumption is achieved using this function.
+ * Note that each drive strength table is for a specific VDDIO of the SDIO pads, ideally this
+ * function should read the VDDIO itself to select the correct table. For now it has been solved
+ * with the 'BCM_SDIO_VDDIO' preprocessor constant.
+ *
+ * 'drivestrength': desired pad drive strength in mA. Drive strength of 0 requests tri-state (if
+ *		    hardware supports this), if no hw support drive strength is not programmed.
+ */
 void
 si_sdiod_drive_strength_init(si_t *sih, osl_t *osh, uint32 drivestrength)
 {
 	chipcregs_t *cc;
 	uint origidx, intr_val = 0;
 	sdiod_drive_str_t *str_tab = NULL;
-	uint32 str_mask = 0;
+	uint32 str_mask = 0;	/* only alter desired bits in PMU chipcontrol 1 register */
 	uint32 str_shift = 0;
+	uint32 str_ovr_pmuctl = PMU_CHIPCTL0; /* PMU chipcontrol register containing override bit */
+	uint32 str_ovr_pmuval = 0;            /* position of bit within this register */
 
 	if (!(sih->cccaps & CC_CAP_PMU)) {
 		return;
@@ -162,14 +197,31 @@ si_sdiod_drive_strength_init(si_t *sih, osl_t *osh, uint32 drivestrength)
 		str_mask = 0x00003800;
 		str_shift = 11;
 		break;
+	case SDIOD_DRVSTR_KEY(BCM4334_CHIP_ID, 17):
+		str_tab = (sdiod_drive_str_t *)&sdiod_drive_strength_tab6_1v8;
+		str_mask = 0x00001800;
+		str_shift = 11;
+		break;
+	case SDIOD_DRVSTR_KEY(BCM43143_CHIP_ID, 17):
+#if !defined(BCM_SDIO_VDDIO) || BCM_SDIO_VDDIO == 33
+		if (drivestrength >=  ARRAYLAST(sdiod_drive_strength_tab7_3v3)->strength) {
+			str_tab = (sdiod_drive_str_t *)&sdiod_drive_strength_tab7_3v3;
+		}
+#else
+		if (drivestrength >=  ARRAYLAST(sdiod_drive_strength_tab7_1v8)->strength) {
+			str_tab = (sdiod_drive_str_t *)&sdiod_drive_strength_tab7_1v8;
+		}
+#endif /* BCM_SDIO_VDDIO */
+		str_mask = 0x00000007;
+		str_ovr_pmuval = PMU43143_CC0_SDIO_DRSTR_OVR;
+		break;
 	default:
 		PMU_MSG(("No SDIO Drive strength init done for chip %s rev %d pmurev %d\n",
 		         bcm_chipname(sih->chip, chn, 8), sih->chiprev, sih->pmurev));
-
 		break;
 	}
 
-	if (str_tab != NULL) {
+	if (str_tab != NULL && cc != NULL) {
 		uint32 cc_data_temp;
 		int i;
 
@@ -182,16 +234,19 @@ si_sdiod_drive_strength_init(si_t *sih, osl_t *osh, uint32 drivestrength)
 		if (i > 0 && drivestrength > str_tab[i].strength)
 			i--;
 
-		W_REG(osh, &cc->chipcontrol_addr, 1);
+		W_REG(osh, &cc->chipcontrol_addr, PMU_CHIPCTL1);
 		cc_data_temp = R_REG(osh, &cc->chipcontrol_data);
 		cc_data_temp &= ~str_mask;
 		cc_data_temp |= str_tab[i].sel << str_shift;
 		W_REG(osh, &cc->chipcontrol_data, cc_data_temp);
-
+		if (str_ovr_pmuval) { /* enables the selected drive strength */
+			W_REG(osh,  &cc->chipcontrol_addr, str_ovr_pmuctl);
+			OR_REG(osh, &cc->chipcontrol_data, str_ovr_pmuval);
+		}
 		PMU_MSG(("SDIO: %dmA drive strength requested; set to %dmA\n",
 		         drivestrength, str_tab[i].strength));
 	}
 
 	/* Return to original core */
 	si_restore_core(sih, origidx, intr_val);
-}
+} /* si_sdiod_drive_strength_init */
diff --git a/drivers/net/wireless/bcmdhd/include/Makefile b/drivers/net/wireless/bcmdhd/include/Makefile
deleted file mode 100644
index 42b3b68..0000000
--- a/drivers/net/wireless/bcmdhd/include/Makefile
+++ /dev/null
@@ -1,53 +0,0 @@
-#!/bin/bash
-#
-# This script serves following purpose:
-#
-# 1. It generates native version information by querying
-#    automerger maintained database to see where src/include
-#    came from
-# 2. For select components, as listed in compvers.sh
-#    it generates component version files
-#
-# Copyright 2005, Broadcom, Inc.
-#
-# $Id: Makefile 241686 2011-02-19 00:22:45Z $
-#
-
-SRCBASE := ..
-
-TARGETS := epivers.h
-
-ifdef VERBOSE
-export VERBOSE
-endif
-
-all release: epivers compvers
-
-# Generate epivers.h for native branch version
-epivers:
-	bash epivers.sh
-
-# Generate epivers.h for native branch version
-compvers:
-	@if [ -s "compvers.sh" ]; then \
-		echo "Generating component versions, if any"; \
-		bash compvers.sh; \
-	else \
-		echo "Skipping component version generation"; \
-	fi
-
-# Generate epivers.h for native branch version
-clean_compvers:
-	@if [ -s "compvers.sh" ]; then \
-		echo "bash compvers.sh clean"; \
-		bash compvers.sh clean; \
-	else \
-		echo "Skipping component version clean"; \
-	fi
-
-clean:
-	rm -f $(TARGETS) *.prev
-
-clean_all: clean clean_compvers
-
-.PHONY: all release clean epivers compvers clean_compvers
diff --git a/drivers/net/wireless/bcmdhd/include/aidmp.h b/drivers/net/wireless/bcmdhd/include/aidmp.h
old mode 100644
new mode 100755
index 63513e6..6b4b8ff
--- a/drivers/net/wireless/bcmdhd/include/aidmp.h
+++ b/drivers/net/wireless/bcmdhd/include/aidmp.h
@@ -1,27 +1,9 @@
 /*
  * Broadcom AMBA Interconnect definitions.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: aidmp.h 241182 2011-02-17 21:50:03Z $
+ * $Id: aidmp.h 385510 2013-02-15 21:02:07Z $
  */
 
 #ifndef	_AIDMP_H
@@ -372,4 +354,15 @@ typedef volatile struct _aidmp {
 #define OOB_SEL_OUTEN_B_5	15
 #define OOB_SEL_OUTEN_B_6	23
 
+
+#define AI_OOBSEL_MASK		0x1F
+#define AI_OOBSEL_0_SHIFT	0
+#define AI_OOBSEL_1_SHIFT	8
+#define AI_OOBSEL_2_SHIFT	16
+#define AI_OOBSEL_3_SHIFT	24
+#define AI_OOBSEL_4_SHIFT	0
+#define AI_OOBSEL_5_SHIFT	8
+#define AI_OOBSEL_6_SHIFT	16
+#define AI_OOBSEL_7_SHIFT	24
+
 #endif	
diff --git a/drivers/net/wireless/bcmdhd/include/bcm_android_types.h b/drivers/net/wireless/bcmdhd/include/bcm_android_types.h
deleted file mode 100644
index fd8aea7..0000000
--- a/drivers/net/wireless/bcmdhd/include/bcm_android_types.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Android related remote wl declarations
- *
- * Copyright (C) 2012, Broadcom Corporation
- * All Rights Reserved.
- * 
- * This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;
- * the contents of this file may not be disclosed to third parties, copied
- * or duplicated in any form, in whole or in part, without the prior
- * written permission of Broadcom Corporation.
- * $Id: bcm_android_types.h 241182 2011-02-17 21:50:03Z $
- *
- */
-#ifndef _wlu_android_h
-#define _wlu_android_h
-#define  __fd_mask unsigned long
-typedef struct
-	{
-	
-#ifdef __USE_XOPEN
-    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];
-# define __FDS_BITS(set) ((set)->fds_bits)
-#else
-    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];
-# define __FDS_BITS(set) ((set)->__fds_bits)
-#endif
-	} fd_set1;
-#define fd_set fd_set1
-
-#define htons(x) BCMSWAP16(x)
-#define htonl(x) BCMSWAP32(x)
-#define __FD_ZERO(s) \
-	do {                                                                        \
-    unsigned int __i;                                                         \
-    fd_set *__arr = (s);                                                      \
-    for (__i = 0; __i < sizeof (fd_set) / sizeof (__fd_mask); ++__i)          \
-	__FDS_BITS(__arr)[__i] = 0;                                            \
-	} while (0)
-#define __FD_SET(d, s)     (__FDS_BITS (s)[__FDELT(d)] |= __FDMASK(d))
-#define __FD_CLR(d, s)     (__FDS_BITS (s)[__FDELT(d)] &= ~__FDMASK(d))
-#define __FD_ISSET(d, s)   ((__FDS_BITS (s)[__FDELT(d)] & __FDMASK(d)) != 0)
-#define MCL_CURRENT 1
-#define MCL_FUTURE 2
-#endif 
diff --git a/drivers/net/wireless/bcmdhd/include/bcm_cfg.h b/drivers/net/wireless/bcmdhd/include/bcm_cfg.h
old mode 100644
new mode 100755
index 26da752..eaea1cc
--- a/drivers/net/wireless/bcmdhd/include/bcm_cfg.h
+++ b/drivers/net/wireless/bcmdhd/include/bcm_cfg.h
@@ -1,27 +1,9 @@
 /*
  * BCM common config options
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: bcm_cfg.h 294399 2011-11-07 03:31:22Z $
+ * $Id: bcm_cfg.h 351867 2012-08-21 18:46:16Z $
  */
 
 #ifndef _bcm_cfg_h_
diff --git a/drivers/net/wireless/bcmdhd/include/bcm_mpool_pub.h b/drivers/net/wireless/bcmdhd/include/bcm_mpool_pub.h
old mode 100644
new mode 100755
index 8fe3de7..30ab58b
--- a/drivers/net/wireless/bcmdhd/include/bcm_mpool_pub.h
+++ b/drivers/net/wireless/bcmdhd/include/bcm_mpool_pub.h
@@ -35,25 +35,7 @@
  *              and instrumentation on top of the heap, without modifying the heap
  *              allocation implementation.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * $Id$
  */
diff --git a/drivers/net/wireless/bcmdhd/include/bcmcdc.h b/drivers/net/wireless/bcmdhd/include/bcmcdc.h
old mode 100644
new mode 100755
index 9bae1c2..7d00f1e
--- a/drivers/net/wireless/bcmdhd/include/bcmcdc.h
+++ b/drivers/net/wireless/bcmdhd/include/bcmcdc.h
@@ -4,25 +4,7 @@
  *
  * Definitions subject to change without notice.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * $Id: bcmcdc.h 318308 2012-03-02 02:23:42Z $
  */
diff --git a/drivers/net/wireless/bcmdhd/include/bcmdefs.h b/drivers/net/wireless/bcmdhd/include/bcmdefs.h
old mode 100644
new mode 100755
index a35ed72..9a2d23d
--- a/drivers/net/wireless/bcmdhd/include/bcmdefs.h
+++ b/drivers/net/wireless/bcmdhd/include/bcmdefs.h
@@ -1,27 +1,9 @@
 /*
  * Misc system wide definitions
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: bcmdefs.h 316830 2012-02-23 20:29:22Z $
+ * $Id: bcmdefs.h 381895 2013-01-30 07:06:40Z $
  */
 
 #ifndef	_bcmdefs_h_
@@ -53,9 +35,19 @@
 #define	BCMNMIATTACHFN(_fn)	_fn
 #define	BCMNMIATTACHDATA(_data)	_data
 #define CONST	const
+#if defined(__ARM_ARCH_7A__)
+#define BCM47XX_CA9
+#else
+#undef BCM47XX_CA9
+#endif
 #ifndef BCMFASTPATH
+#if defined(BCM47XX_CA9)
+#define BCMFASTPATH		__attribute__ ((__section__ (".text.fastpath")))
+#define BCMFASTPATH_HOST	__attribute__ ((__section__ (".text.fastpath_host")))
+#else
 #define BCMFASTPATH
 #define BCMFASTPATH_HOST
+#endif
 #endif 
 
 
@@ -177,9 +169,13 @@ typedef struct {
 
 #if defined(BCM_RPC_NOCOPY) || defined(BCM_RCP_TXNOCOPY)
 
-#define BCMEXTRAHDROOM 220
+#define BCMEXTRAHDROOM 260
 #else 
-#define BCMEXTRAHDROOM 172
+#if defined(BCM47XX_CA9)
+#define BCMEXTRAHDROOM 224
+#else
+#define BCMEXTRAHDROOM 204
+#endif 
 #endif 
 
 
diff --git a/drivers/net/wireless/bcmdhd/include/bcmdevs.h b/drivers/net/wireless/bcmdhd/include/bcmdevs.h
old mode 100644
new mode 100755
index 7b0f9b1..96c47d0
--- a/drivers/net/wireless/bcmdhd/include/bcmdevs.h
+++ b/drivers/net/wireless/bcmdhd/include/bcmdevs.h
@@ -1,27 +1,9 @@
 /*
  * Broadcom device-specific manifest constants.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: bcmdevs.h 327007 2012-04-11 22:45:50Z $
+ * $Id: bcmdevs.h 387183 2013-02-24 07:42:07Z $
  */
 
 #ifndef	_BCMDEVS_H
@@ -63,6 +45,12 @@
 #define BCM_DNGL_BL_PID_43239   0xbd1b
 #define BCM_DNGL_BL_PID_4324	0xbd1c
 #define BCM_DNGL_BL_PID_4360	0xbd1d
+#define BCM_DNGL_BL_PID_43143	0xbd1e
+#define BCM_DNGL_BL_PID_43242	0xbd1f
+#define BCM_DNGL_BL_PID_43342	0xbd21
+#define BCM_DNGL_BL_PID_4335	0xbd20
+#define BCM_DNGL_BL_PID_4350	0xbd23
+#define BCM_DNGL_BL_PID_43341	0xbd22
 
 #define BCM_DNGL_BDC_PID	0x0bdc
 #define BCM_DNGL_JTAG_PID	0x4a44
@@ -131,6 +119,8 @@
 #define BCM4330_D11N5G_ID       0x4362          
 #define BCM4336_D11N_ID		0x4343		
 #define BCM6362_D11N_ID		0x435f		
+#define BCM6362_D11N2G_ID	0x433f		
+#define BCM6362_D11N5G_ID	0x434f		
 #define BCM4331_D11N_ID		0x4331		
 #define BCM4331_D11N2G_ID	0x4332		
 #define BCM4331_D11N5G_ID	0x4333		
@@ -146,25 +136,42 @@
 #define BCM43131_D11N2G_ID	0x43aa		
 #define BCM4314_D11N2G_ID	0x4364		
 #define BCM43142_D11N2G_ID	0x4365		
+#define BCM43143_D11N2G_ID	0x4366		
 #define BCM4334_D11N_ID		0x4380		
 #define BCM4334_D11N2G_ID	0x4381		
 #define BCM4334_D11N5G_ID	0x4382		
+#define BCM43342_D11N_ID	0x4383		
+#define BCM43342_D11N2G_ID	0x4384		
+#define BCM43342_D11N5G_ID	0x4385		
+#define BCM43341_D11N_ID	0x4386		
+#define BCM43341_D11N2G_ID	0x4387		
+#define BCM43341_D11N5G_ID	0x4388		
 #define BCM4360_D11AC_ID	0x43a0
 #define BCM4360_D11AC2G_ID	0x43a1
 #define BCM4360_D11AC5G_ID	0x43a2
+#define BCM4335_D11AC_ID	0x43ae
+#define BCM4335_D11AC2G_ID	0x43af
+#define BCM4335_D11AC5G_ID	0x43b0
+#define BCM4352_D11AC_ID	0x43b1		
+#define BCM4352_D11AC2G_ID	0x43b2		
+#define BCM4352_D11AC5G_ID	0x43b3		
 
 
 #define BCM943228HMB_SSID_VEN1	0x0607
 #define BCM94313HMGBL_SSID_VEN1	0x0608
 #define BCM94313HMG_SSID_VEN1	0x0609
+#define BCM943142HM_SSID_VEN1	0x0611
 
+#define BCM43143_D11N2G_ID	0x4366		
+
+#define BCM43242_D11N_ID	0x4367		
+#define BCM43242_D11N2G_ID	0x4368		
+#define BCM43242_D11N5G_ID	0x4369		
+
+#define BCM4350_D11AC_ID	0x43a3
+#define BCM4350_D11AC2G_ID	0x43a4
+#define BCM4350_D11AC5G_ID	0x43a5
 
-#define BCM4335_D11AC_ID	0x43ae
-#define BCM4335_D11AC2G_ID	0x43af
-#define BCM4335_D11AC5G_ID	0x43b0
-#define BCM4352_D11AC_ID	0x43b1		
-#define BCM4352_D11AC2G_ID	0x43b2		
-#define BCM4352_D11AC5G_ID	0x43b3		
 
 #define	BCMGPRS_UART_ID		0x4333		
 #define	BCMGPRS2_UART_ID	0x4344		
@@ -202,6 +209,8 @@
 #define	BCM47XX_GIGETH_ID	0x471f		
 #define	BCM4712_MIPS_ID		0x4720		
 #define	BCM4716_DEVICE_ID	0x4722		
+#define	BCM47XX_USB30H_ID	0x472a		
+#define	BCM47XX_USB30D_ID	0x472b		
 #define BCM47XX_SMBUS_EMU_ID	0x47fe		
 #define	BCM47XX_XOR_EMU_ID	0x47ff		
 #define	EPI41210_DEVICE_ID	0xa0fa		
@@ -257,19 +266,29 @@
 #define BCM6362_CHIP_ID		0x6362		
 #define BCM4314_CHIP_ID		0x4314		
 #define BCM43142_CHIP_ID	43142		
+#define BCM43143_CHIP_ID	43143		
 #define	BCM4324_CHIP_ID		0x4324		
 #define	BCM43242_CHIP_ID	43242		
+#define	BCM43243_CHIP_ID	43243		
 #define BCM4334_CHIP_ID		0x4334		
+#define BCM4335_CHIP_ID		0x4335		
+#define BCM4339_CHIP_ID		0x4339		/* 4339 chipcommon chipid */
 #define BCM4360_CHIP_ID		0x4360          
 #define BCM4352_CHIP_ID		0x4352          
 #define BCM43526_CHIP_ID	0xAA06
-
+#define BCM43340_CHIP_ID    43340       
+#define BCM43341_CHIP_ID	43341		
+#define BCM43342_CHIP_ID	43342		
 #define BCM4335_CHIP_ID         0x4335
+#define BCM4350_CHIP_ID		0x4350          
 
 #define	BCM4342_CHIP_ID		4342		
 #define	BCM4402_CHIP_ID		0x4402		
 #define	BCM4704_CHIP_ID		0x4704		
 #define	BCM4706_CHIP_ID		0x5300		
+#define BCM4707_CHIP_ID		53010		
+#define BCM53018_CHIP_ID	53018		
+#define BCM4707_CHIP(chipid)	(((chipid) == BCM4707_CHIP_ID) || ((chipid) == BCM53018_CHIP_ID))
 #define	BCM4710_CHIP_ID		0x4710		
 #define	BCM4712_CHIP_ID		0x4712		
 #define	BCM4716_CHIP_ID		0x4716		
@@ -331,27 +350,38 @@
 #define BCM4314SDIO_FPBGA_PKG_ID	(8 | 4)	
 #define BCM4314DEV_PKG_ID		(8 | 6)	
 
+#define BCM4707_PKG_ID		1		
+#define BCM4708_PKG_ID		2		
+#define BCM4709_PKG_ID		0		
+
 #define PCIXX21_FLASHMEDIA0_ID	0x8033		
 #define PCIXX21_SDIOH0_ID	0x8034		
 
+#define BCM4335_WLCSP_PKG_ID	(0x0)	
+#define BCM4335_FCBGA_PKG_ID	(0x1)	
+#define BCM4335_WLBGA_PKG_ID	(0x2)	
+#define BCM4335_FCBGAD_PKG_ID	(0x3)	
+#define BCM4335_PKG_MASK	(0x3)
+
 
 #define	BFL_BTC2WIRE		0x00000001  
 #define BFL_BTCOEX      0x00000001      
 #define	BFL_PACTRL		0x00000002  
 #define BFL_AIRLINEMODE	0x00000004  
 #define	BFL_ADCDIV		0x00000008  
-#define	BFL_RFPLL	        0x00000008  
+#define BFL_DIS_256QAM		0x00000008
 #define	BFL_ENETROBO		0x00000010  
 #define	BFL_NOPLLDOWN		0x00000020  
 #define	BFL_CCKHIPWR		0x00000040  
 #define	BFL_ENETADM		0x00000080  
 #define	BFL_ENETVLAN		0x00000100  
-#define	BFL_UNUSED		0x00000200
+#define	BFL_LTECOEX		0x00000200  
 #define BFL_NOPCI		0x00000400  
 #define BFL_FEM			0x00000800  
 #define BFL_EXTLNA		0x00001000  
 #define BFL_HGPA		0x00002000  
-#define	BFL_BTC2WIRE_ALTGPIO	0x00004000  
+#define	BFL_BTC2WIRE_ALTGPIO	0x00004000
+
 #define	BFL_ALTIQ		0x00008000  
 #define BFL_NOPA		0x00010000  
 #define BFL_RSSIINV		0x00020000  
@@ -360,6 +390,7 @@
 #define BFL_PHASESHIFT		0x00100000  
 #define BFL_BUCKBOOST		0x00200000  
 #define BFL_FEM_BT		0x00400000  
+#define BFL_RXCHAIN_OFF_BT 0x00400000 
 #define BFL_NOCBUCK		0x00800000  
 #define BFL_CCKFAVOREVM		0x01000000  
 #define BFL_PALDO		0x02000000  
@@ -368,6 +399,7 @@
 #define BFL_UCPWRCTL_MININDX	0x08000000  
 #define BFL_EXTLNA_5GHz		0x10000000  
 #define BFL_TRSW_1by2		0x20000000  
+#define BFL_GAINBOOSTA01        0x20000000  
 #define BFL_LO_TRSW_R_5GHz	0x40000000  
 #define BFL_ELNA_GAINDEF	0x80000000  
 #define BFL_EXTLNA_TX	0x20000000	
@@ -400,7 +432,8 @@
 #define BFL2_ANAPACTRL_2G	0x00100000  
 #define BFL2_ANAPACTRL_5G	0x00200000  
 #define BFL2_ELNACTRL_TRSW_2G	0x00400000  
-#define BFL2_BT_SHARE_ANT0	0x00800000  
+#define BFL2_BT_SHARE_ANT0	0x00800000 
+#define BFL2_BT_SHARE_BM_BIT0	0x00800000  
 #define BFL2_TEMPSENSE_HIGHER	0x01000000  
 #define BFL2_BTC3WIREONLY       0x02000000  
 #define BFL2_PWR_NOMINAL	0x04000000  
@@ -408,7 +441,46 @@
 						
 #define BFL2_4313_RADIOREG	0x10000000
 									   
-#define BFL2_SDR_EN		0x20000000	
+#define BFL2_DYNAMIC_VMID	0x10000000  
+#define BFL2_SDR_EN		0x20000000  
+#define BFL2_LNA1BYPFORTR2G  	0x40000000  
+#define BFL2_LNA1BYPFORTR5G  	0x80000000  
+
+
+#define BFL_SROM11_BTCOEX  0x00000001  
+#define BFL_SROM11_WLAN_BT_SH_XTL  0x00000002  
+#define BFL_SROM11_EXTLNA	0x00001000  
+#define BFL_SROM11_EXTLNA_5GHz	0x10000000  
+#define BFL_SROM11_GAINBOOSTA01	0x20000000  
+#define BFL2_SROM11_APLL_WAR	0x00000002  
+#define BFL2_SROM11_ANAPACTRL_2G  0x00100000  
+#define BFL2_SROM11_ANAPACTRL_5G  0x00200000  
+
+
+#define BFL3_FEMCTRL_SUB	0x00000007  
+#define BFL3_RCAL_WAR		0x00000008  
+#define BFL3_TXGAINTBLID	0x00000070  
+#define BFL3_TXGAINTBLID_SHIFT	0x4         
+#define BFL3_TSSI_DIV_WAR	0x00000080  
+#define BFL3_TSSI_DIV_WAR_SHIFT	0x7         
+#define BFL3_FEMTBL_FROM_NVRAM  0x00000100  
+#define BFL3_FEMTBL_FROM_NVRAM_SHIFT  0x8         
+#define BFL3_AGC_CFG_2G         0x00000200  
+#define BFL3_AGC_CFG_5G         0x00000400  
+#define BFL3_PPR_BIT_EXT        0x00000800  
+#define BFL3_PPR_BIT_EXT_SHIFT  11          
+#define BFL3_BBPLL_SPR_MODE_DIS 0x00001000  
+#define BFL3_RCAL_OTP_VAL_EN    0x00002000  
+#define BFL3_2GTXGAINTBL_BLANK  0x00004000  
+#define BFL3_2GTXGAINTBL_BLANK_SHIFT 14     
+#define BFL3_5GTXGAINTBL_BLANK  0x00008000  
+#define BFL3_5GTXGAINTBL_BLANK_SHIFT 15     
+#define BFL3_BT_SHARE_BM_BIT1   0x40000000  
+#define BFL3_PHASETRACK_MAX_ALPHABETA	  0x00010000  
+#define BFL3_PHASETRACK_MAX_ALPHABETA_SHIFT 16       
+#define BFL3_BT_SHARE_BM_BIT1 0x40000000 
+#define BFL3_EN_NONBRCM_TXBF      0x10000000  
+#define BFL3_EN_P2PLINK_TXBF      0x20000000  
 
 
 #define	BOARD_GPIO_BTC3W_IN	0x850	
@@ -449,6 +521,12 @@
 
 
 
+#define BCM943341WLABGS_SSID	0x062d
+
+
+#define BCM943342FCAGBI_SSID	0x0641
+
+
 #define GPIO_NUMPINS		32
 
 
@@ -462,6 +540,14 @@
 #define RDL_RAM_BASE_4328 0x80000000
 #define RDL_RAM_SIZE_4322 0x60000
 #define RDL_RAM_BASE_4322 0x60000000
+#define RDL_RAM_SIZE_4360  0xA0000
+#define RDL_RAM_BASE_4360  0x60000000
+#define RDL_RAM_SIZE_43242  0x90000
+#define RDL_RAM_BASE_43242  0x60000000
+#define RDL_RAM_SIZE_43143  0x70000
+#define RDL_RAM_BASE_43143  0x60000000
+#define RDL_RAM_SIZE_4350  0xC0000
+#define RDL_RAM_BASE_4350  0x180800
 
 
 #define MUXENAB_UART		0x00000001
diff --git a/drivers/net/wireless/bcmdhd/include/bcmendian.h b/drivers/net/wireless/bcmdhd/include/bcmendian.h
old mode 100644
new mode 100755
index 22eb7db..ace1896
--- a/drivers/net/wireless/bcmdhd/include/bcmendian.h
+++ b/drivers/net/wireless/bcmdhd/include/bcmendian.h
@@ -1,25 +1,7 @@
 /*
  * Byte order utilities
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  *  $Id: bcmendian.h 241182 2011-02-17 21:50:03Z $
  *
diff --git a/drivers/net/wireless/bcmdhd/include/bcmnvram.h b/drivers/net/wireless/bcmdhd/include/bcmnvram.h
deleted file mode 100644
index ce0e035..0000000
--- a/drivers/net/wireless/bcmdhd/include/bcmnvram.h
+++ /dev/null
@@ -1,179 +0,0 @@
-/*
- * NVRAM variable manipulation
- *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
- *
- * $Id: bcmnvram.h 320632 2012-03-12 19:22:42Z $
- */
-
-#ifndef _bcmnvram_h_
-#define _bcmnvram_h_
-
-#ifndef _LANGUAGE_ASSEMBLY
-
-#include <typedefs.h>
-#include <bcmdefs.h>
-
-struct nvram_header {
-	uint32 magic;
-	uint32 len;
-	uint32 crc_ver_init;	
-	uint32 config_refresh;	
-	uint32 config_ncdl;	
-};
-
-struct nvram_tuple {
-	char *name;
-	char *value;
-	struct nvram_tuple *next;
-};
-
-
-extern char *nvram_default_get(const char *name);
-
-
-extern int nvram_init(void *sih);
-
-
-extern int nvram_append(void *si, char *vars, uint varsz);
-
-extern void nvram_get_global_vars(char **varlst, uint *varsz);
-
-
-
-extern int nvram_reset(void *sih);
-
-
-extern void nvram_exit(void *sih);
-
-
-extern char * nvram_get(const char *name);
-
-
-extern int nvram_resetgpio_init(void *sih);
-
-
-static INLINE char *
-nvram_safe_get(const char *name)
-{
-	char *p = nvram_get(name);
-	return p ? p : "";
-}
-
-
-static INLINE int
-nvram_match(char *name, char *match)
-{
-	const char *value = nvram_get(name);
-	return (value && !strcmp(value, match));
-}
-
-
-static INLINE int
-nvram_invmatch(char *name, char *invmatch)
-{
-	const char *value = nvram_get(name);
-	return (value && strcmp(value, invmatch));
-}
-
-
-extern int nvram_set(const char *name, const char *value);
-
-
-extern int nvram_unset(const char *name);
-
-
-extern int nvram_commit(void);
-
-
-extern int nvram_getall(char *nvram_buf, int count);
-
-
-uint8 nvram_calc_crc(struct nvram_header * nvh);
-
-#endif 
-
-
-#define NVRAM_SOFTWARE_VERSION	"1"
-
-#define NVRAM_MAGIC		0x48534C46	
-#define NVRAM_CLEAR_MAGIC	0x0
-#define NVRAM_INVALID_MAGIC	0xFFFFFFFF
-#define NVRAM_VERSION		1
-#define NVRAM_HEADER_SIZE	20
-#define NVRAM_SPACE		0x8000
-
-#define NVRAM_MAX_VALUE_LEN 255
-#define NVRAM_MAX_PARAM_LEN 64
-
-#define NVRAM_CRC_START_POSITION	9 
-#define NVRAM_CRC_VER_MASK	0xffffff00 
-
-
-#define NVRAM_START_COMPRESSED	0x400
-#define NVRAM_START		0x1000
-
-#define BCM_JUMBO_NVRAM_DELIMIT '\n'
-#define BCM_JUMBO_START "Broadcom Jumbo Nvram file"
-
-#if (defined(FAILSAFE_UPGRADE) || defined(CONFIG_FAILSAFE_UPGRADE) || \
-	defined(__CONFIG_FAILSAFE_UPGRADE_SUPPORT__))
-#define IMAGE_SIZE "image_size"
-#define BOOTPARTITION "bootpartition"
-#define IMAGE_BOOT BOOTPARTITION
-#define PARTIALBOOTS "partialboots"
-#define MAXPARTIALBOOTS "maxpartialboots"
-#define IMAGE_1ST_FLASH_TRX "flash0.trx"
-#define IMAGE_1ST_FLASH_OS "flash0.os"
-#define IMAGE_2ND_FLASH_TRX "flash0.trx2"
-#define IMAGE_2ND_FLASH_OS "flash0.os2"
-#define IMAGE_FIRST_OFFSET "image_first_offset"
-#define IMAGE_SECOND_OFFSET "image_second_offset"
-#define LINUX_FIRST "linux"
-#define LINUX_SECOND "linux2"
-#endif
-
-#if (defined(DUAL_IMAGE) || defined(CONFIG_DUAL_IMAGE) || \
-	defined(__CONFIG_DUAL_IMAGE_FLASH_SUPPORT__))
-
-#define IMAGE_BOOT "image_boot"
-#define BOOTPARTITION IMAGE_BOOT
-
-#define IMAGE_1ST_FLASH_TRX "flash0.trx"
-#define IMAGE_1ST_FLASH_OS "flash0.os"
-#define IMAGE_2ND_FLASH_TRX "flash0.trx2"
-#define IMAGE_2ND_FLASH_OS "flash0.os2"
-#define IMAGE_SIZE "image_size"
-
-
-#define IMAGE_FIRST_OFFSET "image_first_offset"
-#define IMAGE_SECOND_OFFSET "image_second_offset"
-
-
-#define LINUX_FIRST "linux"
-#define LINUX_SECOND "linux2"
-#define POLICY_TOGGLE "toggle"
-#define LINUX_PART_TO_FLASH "linux_to_flash"
-#define LINUX_FLASH_POLICY "linux_flash_policy"
-
-#endif 
-
-#endif 
diff --git a/drivers/net/wireless/bcmdhd/include/bcmpcispi.h b/drivers/net/wireless/bcmdhd/include/bcmpcispi.h
old mode 100644
new mode 100755
index 44b263c..d95f812
--- a/drivers/net/wireless/bcmdhd/include/bcmpcispi.h
+++ b/drivers/net/wireless/bcmdhd/include/bcmpcispi.h
@@ -1,25 +1,7 @@
 /*
  * Broadcom PCI-SPI Host Controller Register Definitions
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $ Copyright Open Broadcom Corporation $
  *
  * $Id: bcmpcispi.h 241182 2011-02-17 21:50:03Z $
  */
diff --git a/drivers/net/wireless/bcmdhd/include/bcmperf.h b/drivers/net/wireless/bcmdhd/include/bcmperf.h
old mode 100644
new mode 100755
index 7438307..39cfc45
--- a/drivers/net/wireless/bcmdhd/include/bcmperf.h
+++ b/drivers/net/wireless/bcmdhd/include/bcmperf.h
@@ -1,25 +1,7 @@
 /*
  * Performance counters software interface.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * $Id: bcmperf.h 241182 2011-02-17 21:50:03Z $
  */
diff --git a/drivers/net/wireless/bcmdhd/include/bcmsdbus.h b/drivers/net/wireless/bcmdhd/include/bcmsdbus.h
old mode 100644
new mode 100755
index 36c3604..9b50239
--- a/drivers/net/wireless/bcmdhd/include/bcmsdbus.h
+++ b/drivers/net/wireless/bcmdhd/include/bcmsdbus.h
@@ -2,27 +2,9 @@
  * Definitions for API from sdio common code (bcmsdh) to individual
  * host controller drivers.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: bcmsdbus.h 320190 2012-03-09 19:13:53Z $
+ * $Id: bcmsdbus.h 387187 2013-02-24 09:19:34Z $
  */
 
 #ifndef	_sdio_api_h_
@@ -46,6 +28,30 @@
 #define SDIOH_DATA_PIO          0       /* PIO mode */
 #define SDIOH_DATA_DMA          1       /* DMA mode */
 
+#ifdef BCMSDIOH_TXGLOM
+/* Max number of glommed pkts */
+#ifdef CUSTOM_MAX_TXGLOM_SIZE
+#define SDPCM_MAXGLOM_SIZE  CUSTOM_MAX_TXGLOM_SIZE
+#else
+#define SDPCM_MAXGLOM_SIZE	10
+#endif /* CUSTOM_MAX_TXGLOM_SIZE */
+
+#define SDPCM_TXGLOM_CPY 0			/* SDIO 2.0 should use copy mode */
+#define SDPCM_TXGLOM_MDESC	1		/* SDIO 3.0 should use multi-desc mode */
+
+#ifdef BCMSDIOH_TXGLOM_HIGHSPEED
+#define SDPCM_DEFGLOM_MODE	SDPCM_TXGLOM_MDESC
+#ifdef CUSTOM_TXGLOM_SIZE
+#define SDPCM_DEFGLOM_SIZE  CUSTOM_TXGLOM_SIZE
+#else
+#define SDPCM_DEFGLOM_SIZE  10
+#endif /* CUSTOM_TXGLOM_SIZE */
+#else
+#define SDPCM_DEFGLOM_MODE	SDPCM_TXGLOM_CPY
+#define SDPCM_DEFGLOM_SIZE  3
+#endif /* BCMSDIOH_TXGLOM_HIGHSPEED */
+#endif /* BCMSDIOH_TXGLOM */
+
 
 typedef int SDIOH_API_RC;
 
@@ -86,6 +92,18 @@ extern SDIOH_API_RC sdioh_request_buffer(sdioh_info_t *si, uint pio_dma, uint fi
 	uint rw, uint fnc_num, uint32 addr, uint regwidth, uint32 buflen, uint8 *buffer,
 	void *pkt);
 
+#ifdef BCMSDIOH_TXGLOM
+extern void	sdioh_glom_post(sdioh_info_t *sd, uint8 *frame, void *pkt, uint len);
+extern void sdioh_glom_clear(sdioh_info_t *sd);
+extern uint sdioh_set_mode(sdioh_info_t *sd, uint mode);
+extern bool sdioh_glom_enabled(void);
+#else
+#define sdioh_glom_post(a, b, c, d)
+#define sdioh_glom_clear(a)
+#define sdioh_set_mode(a) (0)
+#define sdioh_glom_enabled() (FALSE)
+#endif
+
 /* get cis data */
 extern SDIOH_API_RC sdioh_cis_read(sdioh_info_t *si, uint fuc, uint8 *cis, uint32 length);
 
diff --git a/drivers/net/wireless/bcmdhd/include/bcmsdh.h b/drivers/net/wireless/bcmdhd/include/bcmsdh.h
old mode 100644
new mode 100755
index b1d9355..51d33e8
--- a/drivers/net/wireless/bcmdhd/include/bcmsdh.h
+++ b/drivers/net/wireless/bcmdhd/include/bcmsdh.h
@@ -3,27 +3,9 @@
  *     export functions to client drivers
  *     abstract OS and BUS specific details of SDIO
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $ Copyright Open License Broadcom Corporation $
  *
- * $Id: bcmsdh.h 327460 2012-04-13 18:38:41Z $
+ * $Id: bcmsdh.h 391577 2013-03-18 21:28:17Z $
  */
 
 /**
@@ -48,6 +30,8 @@ extern const uint bcmsdh_msglevel;
 typedef struct bcmsdh_info bcmsdh_info_t;
 typedef void (*bcmsdh_cb_fn_t)(void *);
 
+extern struct device *pm_dev;
+
 /* Attach and build an interface to the underlying SD host driver.
  *  - Allocates resources (structs, arrays, mem, OS handles, etc) needed by bcmsdh.
  *  - Returns the bcmsdh handle and virtual address base for register access.
@@ -55,13 +39,7 @@ typedef void (*bcmsdh_cb_fn_t)(void *);
  *    implementation may maintain a single "default" handle (e.g. the first or
  *    most recent one) to enable single-instance implementations to pass NULL.
  */
-
-#if 0 && (NDISVER >= 0x0630) && 1
-extern bcmsdh_info_t *bcmsdh_attach(osl_t *osh, void *cfghdl,
-	void **regsva, uint irq, shared_info_t *sh);
-#else
 extern bcmsdh_info_t *bcmsdh_attach(osl_t *osh, void *cfghdl, void **regsva, uint irq);
-#endif
 
 /* Detach - freeup resources allocated in attach */
 extern int bcmsdh_detach(osl_t *osh, void *sdh);
@@ -145,6 +123,10 @@ extern int bcmsdh_recv_buf(void *sdh, uint32 addr, uint fn, uint flags,
                            uint8 *buf, uint nbytes, void *pkt,
                            bcmsdh_cmplt_fn_t complete_fn, void *handle);
 
+extern void bcmsdh_glom_post(void *sdh, uint8 *frame, void *pkt, uint len);
+extern void bcmsdh_glom_clear(void *sdh);
+extern uint bcmsdh_set_mode(void *sdh, uint mode);
+extern bool bcmsdh_glom_enabled(void);
 /* Flags bits */
 #define SDIO_REQ_4BYTE	0x1	/* Four-byte target (backplane) width (vs. two-byte) */
 #define SDIO_REQ_FIXED	0x2	/* Fixed address (FIFO) (vs. incrementing address) */
@@ -215,7 +197,7 @@ extern void bcmsdh_unreg_sdio_notify(void);
 extern int bcmsdh_register_oob_intr(void * dhdp);
 extern void bcmsdh_unregister_oob_intr(void);
 extern void bcmsdh_oob_intr_set(bool enable);
-#endif /* defined(OOB_INTR_ONLY) */
+#endif 
 
 /* Function to pass device-status bits to DHD. */
 extern uint32 bcmsdh_get_dstatus(void *sdh);
diff --git a/drivers/net/wireless/bcmdhd/include/bcmsdh_sdmmc.h b/drivers/net/wireless/bcmdhd/include/bcmsdh_sdmmc.h
old mode 100644
new mode 100755
index 80f3900..601b83e
--- a/drivers/net/wireless/bcmdhd/include/bcmsdh_sdmmc.h
+++ b/drivers/net/wireless/bcmdhd/include/bcmsdh_sdmmc.h
@@ -1,7 +1,7 @@
 /*
  * BCMSDH Function Driver for the native SDIO/MMC driver in the Linux Kernel
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
+ * Copyright (C) 1999-2013, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmsdh_sdmmc.h 313732 2012-02-08 19:49:00Z $
+ * $Id: bcmsdh_sdmmc.h 393685 2013-03-28 11:04:06Z $
  */
 
 #ifndef __BCMSDH_SDMMC_H__
@@ -59,10 +59,19 @@ extern void sdioh_sdmmc_osfree(sdioh_info_t *sd);
 
 /* private bus modes */
 #define SDIOH_MODE_SD4		2
-#define CLIENT_INTR 		0x100	/* Get rid of this! */
+#define CLIENT_INTR			0x100	/* Get rid of this! */
+
+#ifdef BCMSDIOH_TXGLOM
+
+typedef struct glom_buf {
+	void *glom_pkt_head;
+	void *glom_pkt_tail;
+	uint32 count;				/* Total number of pkts queued */
+} glom_buf_t;
+#endif /* BCMSDIOH_TXGLOM */
 
 struct sdioh_info {
-	osl_t 		*osh;			/* osh handler */
+	osl_t		*osh;			/* osh handler */
 	bool		client_intr_enabled;	/* interrupt connnected flag */
 	bool		intr_handler_valid;	/* client driver interrupt handler valid */
 	sdioh_cb_fn_t	intr_handler;		/* registered interrupt handler */
@@ -70,22 +79,27 @@ struct sdioh_info {
 	uint16		intmask;		/* Current active interrupts */
 	void		*sdos_info;		/* Pointer to per-OS private data */
 
-	uint 		irq;			/* Client irq */
-	int 		intrcount;		/* Client interrupts */
+	uint		irq;			/* Client irq */
+	int			intrcount;		/* Client interrupts */
 
 	bool		sd_use_dma;		/* DMA on CMD53 */
-	bool 		sd_blockmode;		/* sd_blockmode == FALSE => 64 Byte Cmd 53s. */
+	bool		sd_blockmode;		/* sd_blockmode == FALSE => 64 Byte Cmd 53s. */
 						/*  Must be on for sd_multiblock to be effective */
 	bool 		use_client_ints;	/* If this is false, make sure to restore */
 	int 		sd_mode;		/* SD1/SD4/SPI */
 	int 		client_block_size[SDIOD_MAX_IOFUNCS];		/* Blocksize */
 	uint8 		num_funcs;		/* Supported funcs on client */
 	uint32 		com_cis_ptr;
-	uint32 		func_cis_ptr[SDIOD_MAX_IOFUNCS];
+	uint32		func_cis_ptr[SDIOD_MAX_IOFUNCS];
 
 #define SDIOH_SDMMC_MAX_SG_ENTRIES	32
 	struct scatterlist sg_list[SDIOH_SDMMC_MAX_SG_ENTRIES];
 	bool		use_rxchain;
+
+#ifdef BCMSDIOH_TXGLOM
+	glom_buf_t glom_info;		/* pkt information used for glomming */
+	uint	txglom_mode;		/* Txglom mode: 0 - copy, 1 - multi-descriptor */
+#endif
 };
 
 /************************************************************
diff --git a/drivers/net/wireless/bcmdhd/include/bcmsdpcm.h b/drivers/net/wireless/bcmdhd/include/bcmsdpcm.h
old mode 100644
new mode 100755
index 80c0a3d..c8e5cbb
--- a/drivers/net/wireless/bcmdhd/include/bcmsdpcm.h
+++ b/drivers/net/wireless/bcmdhd/include/bcmsdpcm.h
@@ -2,27 +2,9 @@
  * Broadcom SDIO/PCMCIA
  * Software-specific definitions shared between device and host side
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open 2005 Broadcom Corporation$
  *
- * $Id: bcmsdpcm.h 291086 2011-10-21 01:17:24Z $
+ * $Id: bcmsdpcm.h 364353 2012-10-23 20:31:46Z $
  */
 
 #ifndef	_bcmsdpcm_h_
@@ -146,16 +128,23 @@
 #define SDPCM_GLOMDESC(p)	(((uint8 *)p)[1] & 0x80)
 
 /* For TEST_CHANNEL packets, define another 4-byte header */
-#define SDPCM_TEST_HDRLEN	4	/* Generally: Cmd(1), Ext(1), Len(2);
-					 * Semantics of Ext byte depend on command.
-					 * Len is current or requested frame length, not
-					 * including test header; sent little-endian.
-					 */
-#define SDPCM_TEST_DISCARD	0x01	/* Receiver discards. Ext is a pattern id. */
-#define SDPCM_TEST_ECHOREQ	0x02	/* Echo request. Ext is a pattern id. */
-#define SDPCM_TEST_ECHORSP	0x03	/* Echo response. Ext is a pattern id. */
-#define SDPCM_TEST_BURST	0x04	/* Receiver to send a burst. Ext is a frame count */
-#define SDPCM_TEST_SEND		0x05	/* Receiver sets send mode. Ext is boolean on/off */
+#define SDPCM_TEST_HDRLEN		4	/* Generally: Cmd(1), Ext(1), Len(2);
+						 * Semantics of Ext byte depend on command.
+						 * Len is current or requested frame length, not
+						 * including test header; sent little-endian.
+						 */
+#define SDPCM_TEST_PKT_CNT_FLD_LEN	4	/* Packet count filed legth */
+#define SDPCM_TEST_DISCARD		0x01	/* Receiver discards. Ext is a pattern id. */
+#define SDPCM_TEST_ECHOREQ		0x02	/* Echo request. Ext is a pattern id. */
+#define SDPCM_TEST_ECHORSP		0x03	/* Echo response. Ext is a pattern id. */
+#define SDPCM_TEST_BURST		0x04	/* Receiver to send a burst. Ext is a frame count
+						 * (Backward compatabilty) Set frame count in a
+						 * 4 byte filed adjacent to the HDR
+						 */
+#define SDPCM_TEST_SEND			0x05	/* Receiver sets send mode. Ext is boolean on/off
+						 * Set frame count in a 4 byte filed adjacent to
+						 * the HDR
+						 */
 
 /* Handy macro for filling in datagen packets with a pattern */
 #define SDPCM_TEST_FILL(byteno, id)	((uint8)(id + byteno))
diff --git a/drivers/net/wireless/bcmdhd/include/bcmsdspi.h b/drivers/net/wireless/bcmdhd/include/bcmsdspi.h
old mode 100644
new mode 100755
index 3d444f3..9c082ec1
--- a/drivers/net/wireless/bcmdhd/include/bcmsdspi.h
+++ b/drivers/net/wireless/bcmdhd/include/bcmsdspi.h
@@ -1,25 +1,7 @@
 /*
  * SD-SPI Protocol Conversion - BCMSDH->SPI Translation Layer
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $ Copyright Open Broadcom Corporation $
  *
  * $Id: bcmsdspi.h 294363 2011-11-06 23:02:20Z $
  */
diff --git a/drivers/net/wireless/bcmdhd/include/bcmsdstd.h b/drivers/net/wireless/bcmdhd/include/bcmsdstd.h
old mode 100644
new mode 100755
index 8acc004..f27b685
--- a/drivers/net/wireless/bcmdhd/include/bcmsdstd.h
+++ b/drivers/net/wireless/bcmdhd/include/bcmsdstd.h
@@ -1,27 +1,9 @@
 /*
  *  'Standard' SDIO HOST CONTROLLER driver
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $ Copyright Open Broadcom Corporation $
  *
- * $Id: bcmsdstd.h 324797 2012-03-30 11:02:00Z $
+ * $Id: bcmsdstd.h 343301 2012-07-06 13:07:32Z $
  */
 #ifndef	_BCM_SD_STD_H
 #define	_BCM_SD_STD_H
@@ -92,6 +74,18 @@ extern void sdstd_osfree(sdioh_info_t *sd);
 #define HC_INTR_RETUNING	0x1000
 
 
+#ifdef BCMSDIOH_TXGLOM
+/* Setting the MAX limit to 10 */
+#define SDIOH_MAXGLOM_SIZE	10
+
+typedef struct glom_buf {
+	uint32 count;				/* Total number of pkts queued */
+	void *dma_buf_arr[SDIOH_MAXGLOM_SIZE];	/* Frame address */
+	ulong dma_phys_arr[SDIOH_MAXGLOM_SIZE]; /* DMA_MAPed address of frames */
+	uint16 nbytes[SDIOH_MAXGLOM_SIZE];	/* Size of each frame */
+} glom_buf_t;
+#endif
+
 struct sdioh_info {
 	uint cfg_bar;                   	/* pci cfg address for bar */
 	uint32 caps;                    	/* cached value of capabilities reg */
@@ -161,6 +155,10 @@ struct sdioh_info {
 	volatile int	sd3_tun_state; 		/* tuning state used for retuning check */
 	bool	sd3_tuning_reqd; 	/* tuning requirement parameter */
 	uint32	caps3;			/* cached value of 32 MSbits capabilities reg (SDIO 3.0) */
+#ifdef BCMSDIOH_TXGLOM
+	glom_buf_t glom_info;		/* pkt information used for glomming */
+	uint	txglom_mode;		/* Txglom mode: 0 - copy, 1 - multi-descriptor */
+#endif
 };
 
 #define DMA_MODE_NONE	0
diff --git a/drivers/net/wireless/bcmdhd/include/bcmspi.h b/drivers/net/wireless/bcmdhd/include/bcmspi.h
old mode 100644
new mode 100755
index e226cb1..bb0ee15
--- a/drivers/net/wireless/bcmdhd/include/bcmspi.h
+++ b/drivers/net/wireless/bcmdhd/include/bcmspi.h
@@ -1,25 +1,7 @@
 /*
  * Broadcom SPI Low-Level Hardware Driver API
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $ Copyright Open Broadcom Corporation $
  *
  * $Id: bcmspi.h 241182 2011-02-17 21:50:03Z $
  */
diff --git a/drivers/net/wireless/bcmdhd/include/bcmspibrcm.h b/drivers/net/wireless/bcmdhd/include/bcmspibrcm.h
deleted file mode 100644
index 0975dc8..0000000
--- a/drivers/net/wireless/bcmdhd/include/bcmspibrcm.h
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * SD-SPI Protocol Conversion - BCMSDH->gSPI Translation Layer
- *
- * Copyright (C) 2012, Broadcom Corporation
- * All Rights Reserved.
- * 
- * This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;
- * the contents of this file may not be disclosed to third parties, copied
- * or duplicated in any form, in whole or in part, without the prior
- * written permission of Broadcom Corporation.
- *
- * $Id: bcmspibrcm.h 241182 2011-02-17 21:50:03Z $
- */
-#ifndef	_BCM_SPI_BRCM_H
-#define	_BCM_SPI_BRCM_H
-
-/* global msglevel for debug messages - bitvals come from sdiovar.h */
-
-#define sd_err(x)
-#define sd_trace(x)
-#define sd_info(x)
-#define sd_debug(x)
-#define sd_data(x)
-#define sd_ctrl(x)
-
-#define sd_log(x)
-
-#define SDIOH_ASSERT(exp) \
-	do { if (!(exp)) \
-		printf("!!!ASSERT fail: file %s lines %d", __FILE__, __LINE__); \
-	} while (0)
-
-#define BLOCK_SIZE_F1		64
-#define BLOCK_SIZE_F2 		2048
-#define BLOCK_SIZE_F3 		2048
-
-/* internal return code */
-#define SUCCESS	0
-#undef ERROR
-#define ERROR	1
-#define ERROR_UF	2
-#define ERROR_OF	3
-
-/* private bus modes */
-#define SDIOH_MODE_SPI		0
-
-#define USE_BLOCKMODE		0x2	/* Block mode can be single block or multi */
-#define USE_MULTIBLOCK		0x4
-
-struct sdioh_info {
-	uint 		cfg_bar;		/* pci cfg address for bar */
-	uint32		caps;			/* cached value of capabilities reg */
-	void		*bar0;			/* BAR0 for PCI Device */
-	osl_t 		*osh;			/* osh handler */
-	void		*controller;	/* Pointer to SPI Controller's private data struct */
-
-	uint		lockcount; 		/* nest count of spi_lock() calls */
-	bool		client_intr_enabled;	/* interrupt connnected flag */
-	bool		intr_handler_valid;	/* client driver interrupt handler valid */
-	sdioh_cb_fn_t	intr_handler;		/* registered interrupt handler */
-	void		*intr_handler_arg;	/* argument to call interrupt handler */
-	bool		initialized;		/* card initialized */
-	uint32		target_dev;		/* Target device ID */
-	uint32		intmask;		/* Current active interrupts */
-	void		*sdos_info;		/* Pointer to per-OS private data */
-
-	uint32		controller_type;	/* Host controller type */
-	uint8		version;		/* Host Controller Spec Compliance Version */
-	uint 		irq;			/* Client irq */
-	uint32 		intrcount;		/* Client interrupts */
-	uint32 		local_intrcount;	/* Controller interrupts */
-	bool 		host_init_done;		/* Controller initted */
-	bool 		card_init_done;		/* Client SDIO interface initted */
-	bool 		polled_mode;		/* polling for command completion */
-
-	bool		sd_use_dma;		/* DMA on CMD53 */
-	bool 		sd_blockmode;		/* sd_blockmode == FALSE => 64 Byte Cmd 53s. */
-						/*  Must be on for sd_multiblock to be effective */
-	bool 		use_client_ints;	/* If this is false, make sure to restore */
-						/*  polling hack in wl_linux.c:wl_timer() */
-	int 		adapter_slot;		/* Maybe dealing with multiple slots/controllers */
-	int 		sd_mode;		/* SD1/SD4/SPI */
-	int 		client_block_size[SPI_MAX_IOFUNCS];		/* Blocksize */
-	uint32 		data_xfer_count;	/* Current transfer */
-	uint16 		card_rca;		/* Current Address */
-	uint8 		num_funcs;		/* Supported funcs on client */
-	uint32 		card_dstatus;		/* 32bit device status */
-	uint32 		com_cis_ptr;
-	uint32 		func_cis_ptr[SPI_MAX_IOFUNCS];
-	void		*dma_buf;
-	ulong		dma_phys;
-	int 		r_cnt;			/* rx count */
-	int 		t_cnt;			/* tx_count */
-	uint32		wordlen;			/* host processor 16/32bits */
-	uint32		prev_fun;
-	uint32		chip;
-	uint32		chiprev;
-	bool		resp_delay_all;
-	bool		dwordmode;
-	bool		resp_delay_new;
-
-	struct spierrstats_t spierrstats;
-};
-
-/************************************************************
- * Internal interfaces: per-port references into bcmspibrcm.c
- */
-
-/* Global message bits */
-extern uint sd_msglevel;
-
-/**************************************************************
- * Internal interfaces: bcmspibrcm.c references to per-port code
- */
-
-/* Interrupt (de)registration routines */
-extern int spi_register_irq(sdioh_info_t *sd, uint irq);
-extern void spi_free_irq(uint irq, sdioh_info_t *sd);
-
-/* OS-specific interrupt wrappers (atomic interrupt enable/disable) */
-extern void spi_lock(sdioh_info_t *sd);
-extern void spi_unlock(sdioh_info_t *sd);
-
-/* Allocate/init/free per-OS private data */
-extern int spi_osinit(sdioh_info_t *sd);
-extern void spi_osfree(sdioh_info_t *sd);
-
-#define SPI_RW_FLAG_M			BITFIELD_MASK(1)	/* Bit [31] - R/W Command Bit */
-#define SPI_RW_FLAG_S			31
-#define SPI_ACCESS_M			BITFIELD_MASK(1)	/* Bit [30] - Fixed/Incr Access */
-#define SPI_ACCESS_S			30
-#define SPI_FUNCTION_M			BITFIELD_MASK(2)	/* Bit [29:28] - Function Number */
-#define SPI_FUNCTION_S			28
-#define SPI_REG_ADDR_M			BITFIELD_MASK(17)	/* Bit [27:11] - Address */
-#define SPI_REG_ADDR_S			11
-#define SPI_LEN_M			BITFIELD_MASK(11)	/* Bit [10:0] - Packet length */
-#define SPI_LEN_S			0
-
-#endif /* _BCM_SPI_BRCM_H */
diff --git a/drivers/net/wireless/bcmdhd/include/bcmsrom_fmt.h b/drivers/net/wireless/bcmdhd/include/bcmsrom_fmt.h
deleted file mode 100644
index f5246a5..0000000
--- a/drivers/net/wireless/bcmdhd/include/bcmsrom_fmt.h
+++ /dev/null
@@ -1,607 +0,0 @@
-/*
- * SROM format definition.
- *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
- *
- * $Id: bcmsrom_fmt.h 327439 2012-04-13 17:44:48Z $
- */
-
-#ifndef	_bcmsrom_fmt_h_
-#define	_bcmsrom_fmt_h_
-
-#define SROM_MAXREV		11	/* max revisiton supported by driver */
-
-/* Maximum srom: 6 Kilobits == 768 bytes */
-#define	SROM_MAX		768
-#define SROM_MAXW		384
-#define VARS_MAX		4096
-
-/* PCI fields */
-#define PCI_F0DEVID		48
-
-
-#define	SROM_WORDS		64
-
-#define SROM3_SWRGN_OFF		28	/* s/w region offset in words */
-
-#define	SROM_SSID		2
-
-#define	SROM_WL1LHMAXP		29
-
-#define	SROM_WL1LPAB0		30
-#define	SROM_WL1LPAB1		31
-#define	SROM_WL1LPAB2		32
-
-#define	SROM_WL1HPAB0		33
-#define	SROM_WL1HPAB1		34
-#define	SROM_WL1HPAB2		35
-
-#define	SROM_MACHI_IL0		36
-#define	SROM_MACMID_IL0		37
-#define	SROM_MACLO_IL0		38
-#define	SROM_MACHI_ET0		39
-#define	SROM_MACMID_ET0		40
-#define	SROM_MACLO_ET0		41
-#define	SROM_MACHI_ET1		42
-#define	SROM_MACMID_ET1		43
-#define	SROM_MACLO_ET1		44
-#define	SROM3_MACHI		37
-#define	SROM3_MACMID		38
-#define	SROM3_MACLO		39
-
-#define	SROM_BXARSSI2G		40
-#define	SROM_BXARSSI5G		41
-
-#define	SROM_TRI52G		42
-#define	SROM_TRI5GHL		43
-
-#define	SROM_RXPO52G		45
-
-#define	SROM2_ENETPHY		45
-
-#define	SROM_AABREV		46
-/* Fields in AABREV */
-#define	SROM_BR_MASK		0x00ff
-#define	SROM_CC_MASK		0x0f00
-#define	SROM_CC_SHIFT		8
-#define	SROM_AA0_MASK		0x3000
-#define	SROM_AA0_SHIFT		12
-#define	SROM_AA1_MASK		0xc000
-#define	SROM_AA1_SHIFT		14
-
-#define	SROM_WL0PAB0		47
-#define	SROM_WL0PAB1		48
-#define	SROM_WL0PAB2		49
-
-#define	SROM_LEDBH10		50
-#define	SROM_LEDBH32		51
-
-#define	SROM_WL10MAXP		52
-
-#define	SROM_WL1PAB0		53
-#define	SROM_WL1PAB1		54
-#define	SROM_WL1PAB2		55
-
-#define	SROM_ITT		56
-
-#define	SROM_BFL		57
-#define	SROM_BFL2		28
-#define	SROM3_BFL2		61
-
-#define	SROM_AG10		58
-
-#define	SROM_CCODE		59
-
-#define	SROM_OPO		60
-
-#define	SROM3_LEDDC		62
-
-#define	SROM_CRCREV		63
-
-/* SROM Rev 4: Reallocate the software part of the srom to accomodate
- * MIMO features. It assumes up to two PCIE functions and 440 bytes
- * of useable srom i.e. the useable storage in chips with OTP that
- * implements hardware redundancy.
- */
-
-#define	SROM4_WORDS		220
-
-#define	SROM4_SIGN		32
-#define	SROM4_SIGNATURE		0x5372
-
-#define	SROM4_BREV		33
-
-#define	SROM4_BFL0		34
-#define	SROM4_BFL1		35
-#define	SROM4_BFL2		36
-#define	SROM4_BFL3		37
-#define	SROM5_BFL0		37
-#define	SROM5_BFL1		38
-#define	SROM5_BFL2		39
-#define	SROM5_BFL3		40
-
-#define	SROM4_MACHI		38
-#define	SROM4_MACMID		39
-#define	SROM4_MACLO		40
-#define	SROM5_MACHI		41
-#define	SROM5_MACMID		42
-#define	SROM5_MACLO		43
-
-#define	SROM4_CCODE		41
-#define	SROM4_REGREV		42
-#define	SROM5_CCODE		34
-#define	SROM5_REGREV		35
-
-#define	SROM4_LEDBH10		43
-#define	SROM4_LEDBH32		44
-#define	SROM5_LEDBH10		59
-#define	SROM5_LEDBH32		60
-
-#define	SROM4_LEDDC		45
-#define	SROM5_LEDDC		45
-
-#define	SROM4_AA		46
-#define	SROM4_AA2G_MASK		0x00ff
-#define	SROM4_AA2G_SHIFT	0
-#define	SROM4_AA5G_MASK		0xff00
-#define	SROM4_AA5G_SHIFT	8
-
-#define	SROM4_AG10		47
-#define	SROM4_AG32		48
-
-#define	SROM4_TXPID2G		49
-#define	SROM4_TXPID5G		51
-#define	SROM4_TXPID5GL		53
-#define	SROM4_TXPID5GH		55
-
-#define SROM4_TXRXC		61
-#define SROM4_TXCHAIN_MASK	0x000f
-#define SROM4_TXCHAIN_SHIFT	0
-#define SROM4_RXCHAIN_MASK	0x00f0
-#define SROM4_RXCHAIN_SHIFT	4
-#define SROM4_SWITCH_MASK	0xff00
-#define SROM4_SWITCH_SHIFT	8
-
-
-/* Per-path fields */
-#define	MAX_PATH_SROM		4
-#define	SROM4_PATH0		64
-#define	SROM4_PATH1		87
-#define	SROM4_PATH2		110
-#define	SROM4_PATH3		133
-
-#define	SROM4_2G_ITT_MAXP	0
-#define	SROM4_2G_PA		1
-#define	SROM4_5G_ITT_MAXP	5
-#define	SROM4_5GLH_MAXP		6
-#define	SROM4_5G_PA		7
-#define	SROM4_5GL_PA		11
-#define	SROM4_5GH_PA		15
-
-/* Fields in the ITT_MAXP and 5GLH_MAXP words */
-#define	B2G_MAXP_MASK		0xff
-#define	B2G_ITT_SHIFT		8
-#define	B5G_MAXP_MASK		0xff
-#define	B5G_ITT_SHIFT		8
-#define	B5GH_MAXP_MASK		0xff
-#define	B5GL_MAXP_SHIFT		8
-
-/* All the miriad power offsets */
-#define	SROM4_2G_CCKPO		156
-#define	SROM4_2G_OFDMPO		157
-#define	SROM4_5G_OFDMPO		159
-#define	SROM4_5GL_OFDMPO	161
-#define	SROM4_5GH_OFDMPO	163
-#define	SROM4_2G_MCSPO		165
-#define	SROM4_5G_MCSPO		173
-#define	SROM4_5GL_MCSPO		181
-#define	SROM4_5GH_MCSPO		189
-#define	SROM4_CDDPO		197
-#define	SROM4_STBCPO		198
-#define	SROM4_BW40PO		199
-#define	SROM4_BWDUPPO		200
-
-#define	SROM4_CRCREV		219
-
-
-/* SROM Rev 8: Make space for a 48word hardware header for PCIe rev >= 6.
- * This is acombined srom for both MIMO and SISO boards, usable in
- * the .130 4Kilobit OTP with hardware redundancy.
- */
-
-#define	SROM8_SIGN		64
-
-#define	SROM8_BREV		65
-
-#define	SROM8_BFL0		66
-#define	SROM8_BFL1		67
-#define	SROM8_BFL2		68
-#define	SROM8_BFL3		69
-
-#define	SROM8_MACHI		70
-#define	SROM8_MACMID		71
-#define	SROM8_MACLO		72
-
-#define	SROM8_CCODE		73
-#define	SROM8_REGREV		74
-
-#define	SROM8_LEDBH10		75
-#define	SROM8_LEDBH32		76
-
-#define	SROM8_LEDDC		77
-
-#define	SROM8_AA		78
-
-#define	SROM8_AG10		79
-#define	SROM8_AG32		80
-
-#define	SROM8_TXRXC		81
-
-#define	SROM8_BXARSSI2G		82
-#define	SROM8_BXARSSI5G		83
-#define	SROM8_TRI52G		84
-#define	SROM8_TRI5GHL		85
-#define	SROM8_RXPO52G		86
-
-#define SROM8_FEM2G		87
-#define SROM8_FEM5G		88
-#define SROM8_FEM_ANTSWLUT_MASK		0xf800
-#define SROM8_FEM_ANTSWLUT_SHIFT	11
-#define SROM8_FEM_TR_ISO_MASK		0x0700
-#define SROM8_FEM_TR_ISO_SHIFT		8
-#define SROM8_FEM_PDET_RANGE_MASK	0x00f8
-#define SROM8_FEM_PDET_RANGE_SHIFT	3
-#define SROM8_FEM_EXTPA_GAIN_MASK	0x0006
-#define SROM8_FEM_EXTPA_GAIN_SHIFT	1
-#define SROM8_FEM_TSSIPOS_MASK		0x0001
-#define SROM8_FEM_TSSIPOS_SHIFT		0
-
-#define SROM8_THERMAL		89
-
-/* Temp sense related entries */
-#define SROM8_MPWR_RAWTS		90
-#define SROM8_TS_SLP_OPT_CORRX	91
-/* FOC: freiquency offset correction, HWIQ: H/W IOCAL enable, IQSWP: IQ CAL swap disable */
-#define SROM8_FOC_HWIQ_IQSWP	92
-
-#define SROM8_EXTLNAGAIN        93
-
-/* Temperature delta for PHY calibration */
-#define SROM8_PHYCAL_TEMPDELTA	94
-
-/* Measured power 1 & 2, 0-13 bits at offset 95, MSB 2 bits are unused for now. */
-#define SROM8_MPWR_1_AND_2	95
-
-
-/* Per-path offsets & fields */
-#define	SROM8_PATH0		96
-#define	SROM8_PATH1		112
-#define	SROM8_PATH2		128
-#define	SROM8_PATH3		144
-
-#define	SROM8_2G_ITT_MAXP	0
-#define	SROM8_2G_PA		1
-#define	SROM8_5G_ITT_MAXP	4
-#define	SROM8_5GLH_MAXP		5
-#define	SROM8_5G_PA		6
-#define	SROM8_5GL_PA		9
-#define	SROM8_5GH_PA		12
-
-/* All the miriad power offsets */
-#define	SROM8_2G_CCKPO		160
-
-#define	SROM8_2G_OFDMPO		161
-#define	SROM8_5G_OFDMPO		163
-#define	SROM8_5GL_OFDMPO	165
-#define	SROM8_5GH_OFDMPO	167
-
-#define	SROM8_2G_MCSPO		169
-#define	SROM8_5G_MCSPO		177
-#define	SROM8_5GL_MCSPO		185
-#define	SROM8_5GH_MCSPO		193
-
-#define	SROM8_CDDPO		201
-#define	SROM8_STBCPO		202
-#define	SROM8_BW40PO		203
-#define	SROM8_BWDUPPO		204
-
-/* SISO PA parameters are in the path0 spaces */
-#define	SROM8_SISO		96
-
-/* Legacy names for SISO PA paramters */
-#define	SROM8_W0_ITTMAXP	(SROM8_SISO + SROM8_2G_ITT_MAXP)
-#define	SROM8_W0_PAB0		(SROM8_SISO + SROM8_2G_PA)
-#define	SROM8_W0_PAB1		(SROM8_SISO + SROM8_2G_PA + 1)
-#define	SROM8_W0_PAB2		(SROM8_SISO + SROM8_2G_PA + 2)
-#define	SROM8_W1_ITTMAXP	(SROM8_SISO + SROM8_5G_ITT_MAXP)
-#define	SROM8_W1_MAXP_LCHC	(SROM8_SISO + SROM8_5GLH_MAXP)
-#define	SROM8_W1_PAB0		(SROM8_SISO + SROM8_5G_PA)
-#define	SROM8_W1_PAB1		(SROM8_SISO + SROM8_5G_PA + 1)
-#define	SROM8_W1_PAB2		(SROM8_SISO + SROM8_5G_PA + 2)
-#define	SROM8_W1_PAB0_LC	(SROM8_SISO + SROM8_5GL_PA)
-#define	SROM8_W1_PAB1_LC	(SROM8_SISO + SROM8_5GL_PA + 1)
-#define	SROM8_W1_PAB2_LC	(SROM8_SISO + SROM8_5GL_PA + 2)
-#define	SROM8_W1_PAB0_HC	(SROM8_SISO + SROM8_5GH_PA)
-#define	SROM8_W1_PAB1_HC	(SROM8_SISO + SROM8_5GH_PA + 1)
-#define	SROM8_W1_PAB2_HC	(SROM8_SISO + SROM8_5GH_PA + 2)
-
-#define	SROM8_CRCREV		219
-
-/* SROM REV 9 */
-#define SROM9_2GPO_CCKBW20	160
-#define SROM9_2GPO_CCKBW20UL	161
-#define SROM9_2GPO_LOFDMBW20	162
-#define SROM9_2GPO_LOFDMBW20UL	164
-
-#define SROM9_5GLPO_LOFDMBW20	166
-#define SROM9_5GLPO_LOFDMBW20UL	168
-#define SROM9_5GMPO_LOFDMBW20	170
-#define SROM9_5GMPO_LOFDMBW20UL	172
-#define SROM9_5GHPO_LOFDMBW20	174
-#define SROM9_5GHPO_LOFDMBW20UL	176
-
-#define SROM9_2GPO_MCSBW20	178
-#define SROM9_2GPO_MCSBW20UL	180
-#define SROM9_2GPO_MCSBW40	182
-
-#define SROM9_5GLPO_MCSBW20	184
-#define SROM9_5GLPO_MCSBW20UL	186
-#define SROM9_5GLPO_MCSBW40	188
-#define SROM9_5GMPO_MCSBW20	190
-#define SROM9_5GMPO_MCSBW20UL	192
-#define SROM9_5GMPO_MCSBW40	194
-#define SROM9_5GHPO_MCSBW20	196
-#define SROM9_5GHPO_MCSBW20UL	198
-#define SROM9_5GHPO_MCSBW40	200
-
-#define SROM9_PO_MCS32		202
-#define SROM9_PO_LOFDM40DUP	203
-#define SROM8_RXGAINERR_2G	205
-#define SROM8_RXGAINERR_5GL	206
-#define SROM8_RXGAINERR_5GM	207
-#define SROM8_RXGAINERR_5GH	208
-#define SROM8_RXGAINERR_5GU	209
-#define SROM8_SUBBAND_PPR	210
-#define SROM8_PCIEINGRESS_WAR	211
-#define SROM9_SAR		212
-
-#define SROM8_NOISELVL_2G	213
-#define SROM8_NOISELVL_5GL	214
-#define SROM8_NOISELVL_5GM	215
-#define SROM8_NOISELVL_5GH	216
-#define SROM8_NOISELVL_5GU	217
-
-#define SROM9_REV_CRC		219
-
-#define SROM10_CCKPWROFFSET	218
-#define SROM10_SIGN		219
-#define SROM10_SWCTRLMAP_2G	220
-#define SROM10_CRCREV		229
-
-#define	SROM10_WORDS		230
-#define	SROM10_SIGNATURE	SROM4_SIGNATURE
-
-
-/* SROM REV 11 */
-#define SROM11_BREV			65
-
-#define SROM11_BFL0			66
-#define SROM11_BFL1			67
-#define SROM11_BFL2			68
-#define SROM11_BFL3			69
-#define SROM11_BFL4			70
-#define SROM11_BFL5			71
-
-#define SROM11_MACHI			72
-#define SROM11_MACMID			73
-#define SROM11_MACLO			74
-
-#define SROM11_CCODE			75
-#define SROM11_REGREV			76
-
-#define SROM11_LEDBH10			77
-#define SROM11_LEDBH32			78
-
-#define SROM11_LEDDC			79
-
-#define SROM11_AA			80
-
-#define SROM11_AGBG10			81
-#define SROM11_AGBG2A0			82
-#define SROM11_AGA21			83
-
-#define SROM11_TXRXC			84
-
-#define SROM11_FEM_CFG1			85
-#define SROM11_FEM_CFG2			86
-
-/* Masks and offsets for FEM_CFG */
-#define SROM11_FEMCTRL_MASK		0xf800
-#define SROM11_FEMCTRL_SHIFT		11
-#define SROM11_PAPDCAP_MASK		0x0400
-#define SROM11_PAPDCAP_SHIFT		10
-#define SROM11_TWORANGETSSI_MASK	0x0200
-#define SROM11_TWORANGETSSI_SHIFT	9
-#define SROM11_PDGAIN_MASK		0x01f0
-#define SROM11_PDGAIN_SHIFT		4
-#define SROM11_EPAGAIN_MASK		0x000e
-#define SROM11_EPAGAIN_SHIFT		1
-#define SROM11_TSSIPOSSLOPE_MASK	0x0001
-#define SROM11_TSSIPOSSLOPE_SHIFT	0
-#define SROM11_GAINCTRLSPH_MASK		0xf800
-#define SROM11_GAINCTRLSPH_SHIFT	11
-
-#define SROM11_THERMAL			87
-#define SROM11_MPWR_RAWTS		88
-#define SROM11_TS_SLP_OPT_CORRX		89
-#define SROM11_PHYCAL_TEMPDELTA  	92
-#define SROM11_MPWR_1_AND_2 		93
-
-/* Masks and offsets for Terrmal parameters */
-#define SROM11_TEMPS_PERIOD_MASK	0xf0
-#define SROM11_TEMPS_PERIOD_SHIFT	4
-#define SROM11_TEMPS_HYSTERESIS_MASK	0x0f
-#define SROM11_TEMPS_HYSTERESIS_SHIFT	0
-#define SROM11_TEMPCORRX_MASK		0xfc
-#define SROM11_TEMPCORRX_SHIFT		2
-#define SROM11_TEMPSENSE_OPTION_MASK	0x3
-#define SROM11_TEMPSENSE_OPTION_SHIFT	0
-
-#define SROM11_PDOFF_40M_A0		101
-#define SROM11_PDOFF_40M_A1		102
-#define SROM11_PDOFF_40M_A2		103
-#define SROM11_PDOFF_80M_A0		104
-#define SROM11_PDOFF_80M_A1		105
-#define SROM11_PDOFF_80M_A2		106
-
-#define SROM11_SUBBAND5GVER 		107
-
-/* Per-path fields and offset */
-#define	MAX_PATH_SROM_11		3
-#define SROM11_PATH0			108
-#define SROM11_PATH1			128
-#define SROM11_PATH2			148
-
-#define	SROM11_2G_MAXP			0
-#define	SROM11_2G_PA			1
-#define	SROM11_RXGAINS1			4
-#define	SROM11_RXGAINS			5
-#define	SROM11_5GB1B0_MAXP		6
-#define	SROM11_5GB3B2_MAXP		7
-#define	SROM11_5GB0_PA			8
-#define	SROM11_5GB1_PA			11
-#define	SROM11_5GB2_PA			14
-#define	SROM11_5GB3_PA			17
-
-/* Masks and offsets for rxgains */
-#define SROM11_RXGAINS5GTRELNABYPA_MASK		0x8000
-#define SROM11_RXGAINS5GTRELNABYPA_SHIFT	15
-#define SROM11_RXGAINS5GTRISOA_MASK		0x7800
-#define SROM11_RXGAINS5GTRISOA_SHIFT		11
-#define SROM11_RXGAINS5GELNAGAINA_MASK		0x0700
-#define SROM11_RXGAINS5GELNAGAINA_SHIFT		8
-#define SROM11_RXGAINS2GTRELNABYPA_MASK		0x0080
-#define SROM11_RXGAINS2GTRELNABYPA_SHIFT	7
-#define SROM11_RXGAINS2GTRISOA_MASK		0x0078
-#define SROM11_RXGAINS2GTRISOA_SHIFT		3
-#define SROM11_RXGAINS2GELNAGAINA_MASK		0x0007
-#define SROM11_RXGAINS2GELNAGAINA_SHIFT		0
-#define SROM11_RXGAINS5GHTRELNABYPA_MASK	0x8000
-#define SROM11_RXGAINS5GHTRELNABYPA_SHIFT	15
-#define SROM11_RXGAINS5GHTRISOA_MASK		0x7800
-#define SROM11_RXGAINS5GHTRISOA_SHIFT		11
-#define SROM11_RXGAINS5GHELNAGAINA_MASK		0x0700
-#define SROM11_RXGAINS5GHELNAGAINA_SHIFT	8
-#define SROM11_RXGAINS5GMTRELNABYPA_MASK	0x0080
-#define SROM11_RXGAINS5GMTRELNABYPA_SHIFT	7
-#define SROM11_RXGAINS5GMTRISOA_MASK		0x0078
-#define SROM11_RXGAINS5GMTRISOA_SHIFT		3
-#define SROM11_RXGAINS5GMELNAGAINA_MASK		0x0007
-#define SROM11_RXGAINS5GMELNAGAINA_SHIFT	0
-
-/* Power per rate */
-#define SROM11_CCKBW202GPO		168
-#define SROM11_CCKBW20UL2GPO		169
-#define SROM11_MCSBW202GPO		170
-#define SROM11_MCSBW202GPO_1		171
-#define SROM11_MCSBW402GPO		172
-#define SROM11_MCSBW402GPO_1		173
-#define SROM11_DOT11AGOFDMHRBW202GPO	174
-#define SROM11_OFDMLRBW202GPO		175
-
-#define SROM11_MCSBW205GLPO 		176
-#define SROM11_MCSBW205GLPO_1		177
-#define SROM11_MCSBW405GLPO 		178
-#define SROM11_MCSBW405GLPO_1		179
-#define SROM11_MCSBW805GLPO 		180
-#define SROM11_MCSBW805GLPO_1		181
-#define SROM11_MCSBW1605GLPO		182
-#define SROM11_MCSBW1605GLPO_1		183
-#define SROM11_MCSBW205GMPO 		184
-#define SROM11_MCSBW205GMPO_1		185
-#define SROM11_MCSBW405GMPO 		186
-#define SROM11_MCSBW405GMPO_1		187
-#define SROM11_MCSBW805GMPO 		188
-#define SROM11_MCSBW805GMPO_1		189
-#define SROM11_MCSBW1605GMPO		190
-#define SROM11_MCSBW1605GMPO_1		191
-#define SROM11_MCSBW205GHPO 		192
-#define SROM11_MCSBW205GHPO_1		193
-#define SROM11_MCSBW405GHPO 		194
-#define SROM11_MCSBW405GHPO_1		195
-#define SROM11_MCSBW805GHPO 		196
-#define SROM11_MCSBW805GHPO_1		197
-#define SROM11_MCSBW1605GHPO		198
-#define SROM11_MCSBW1605GHPO_1		199
-
-#define SROM11_MCSLR5GLPO		200
-#define SROM11_MCSLR5GMPO		201
-#define SROM11_MCSLR5GHPO		202
-
-#define SROM11_SB20IN40HRPO		203
-#define SROM11_SB20IN80AND160HR5GLPO 	204
-#define SROM11_SB40AND80HR5GLPO		205
-#define SROM11_SB20IN80AND160HR5GMPO 	206
-#define SROM11_SB40AND80HR5GMPO		207
-#define SROM11_SB20IN80AND160HR5GHPO 	208
-#define SROM11_SB40AND80HR5GHPO		209
-#define SROM11_SB20IN40LRPO 		210
-#define SROM11_SB20IN80AND160LR5GLPO	211
-#define SROM11_SB40AND80LR5GLPO		212
-#define SROM11_SB20IN80AND160LR5GMPO	213
-#define SROM11_SB40AND80LR5GMPO		214
-#define SROM11_SB20IN80AND160LR5GHPO	215
-#define SROM11_SB40AND80LR5GHPO		216
-
-#define SROM11_DOT11AGDUPHRPO 		217
-#define SROM11_DOT11AGDUPLRPO		218
-
-/* MISC */
-#define SROM11_PCIEINGRESS_WAR		220
-#define SROM11_SAR			221
-
-#define SROM11_NOISELVL_2G		222
-#define SROM11_NOISELVL_5GL 		223
-#define SROM11_NOISELVL_5GM 		224
-#define SROM11_NOISELVL_5GH 		225
-#define SROM11_NOISELVL_5GU 		226
-
-#define SROM11_RXGAINERR_2G		227
-#define SROM11_RXGAINERR_5GL		228
-#define SROM11_RXGAINERR_5GM		229
-#define SROM11_RXGAINERR_5GH		230
-#define SROM11_RXGAINERR_5GU		231
-
-#define SROM11_SIGN 			64
-#define SROM11_CRCREV 			233
-
-#define	SROM11_WORDS			234
-#define	SROM11_SIGNATURE		0x0634
-
-typedef struct {
-	uint8 tssipos;		/* TSSI positive slope, 1: positive, 0: negative */
-	uint8 extpagain;	/* Ext PA gain-type: full-gain: 0, pa-lite: 1, no_pa: 2 */
-	uint8 pdetrange;	/* support 32 combinations of different Pdet dynamic ranges */
-	uint8 triso;		/* TR switch isolation */
-	uint8 antswctrllut;	/* antswctrl lookup table configuration: 32 possible choices */
-} srom_fem_t;
-
-#endif	/* _bcmsrom_fmt_h_ */
diff --git a/drivers/net/wireless/bcmdhd/include/bcmsrom_tbl.h b/drivers/net/wireless/bcmdhd/include/bcmsrom_tbl.h
deleted file mode 100644
index 040ae6a..0000000
--- a/drivers/net/wireless/bcmdhd/include/bcmsrom_tbl.h
+++ /dev/null
@@ -1,900 +0,0 @@
-/*
- * Table that encodes the srom formats for PCI/PCIe NICs.
- *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
- *
- * $Id: bcmsrom_tbl.h 327694 2012-04-16 13:22:24Z $
- */
-
-#ifndef	_bcmsrom_tbl_h_
-#define	_bcmsrom_tbl_h_
-
-#include "sbpcmcia.h"
-#include "wlioctl.h"
-
-typedef struct {
-	const char *name;
-	uint32	revmask;
-	uint32	flags;
-	uint16	off;
-	uint16	mask;
-} sromvar_t;
-
-#define SRFL_MORE	1		/* value continues as described by the next entry */
-#define	SRFL_NOFFS	2		/* value bits can't be all one's */
-#define	SRFL_PRHEX	4		/* value is in hexdecimal format */
-#define	SRFL_PRSIGN	8		/* value is in signed decimal format */
-#define	SRFL_CCODE	0x10		/* value is in country code format */
-#define	SRFL_ETHADDR	0x20		/* value is an Ethernet address */
-#define SRFL_LEDDC	0x40		/* value is an LED duty cycle */
-#define SRFL_NOVAR	0x80		/* do not generate a nvram param, entry is for mfgc */
-#define SRFL_ARRAY	0x100		/* value is in an array. All elements EXCEPT FOR THE LAST
-					 * ONE in the array should have this flag set.
-					 */
-
-
-/* Assumptions:
- * - Ethernet address spans across 3 consective words
- *
- * Table rules:
- * - Add multiple entries next to each other if a value spans across multiple words
- *   (even multiple fields in the same word) with each entry except the last having
- *   it's SRFL_MORE bit set.
- * - Ethernet address entry does not follow above rule and must not have SRFL_MORE
- *   bit set. Its SRFL_ETHADDR bit implies it takes multiple words.
- * - The last entry's name field must be NULL to indicate the end of the table. Other
- *   entries must have non-NULL name.
- */
-
-static const sromvar_t pci_sromvars[] = {
-	{"devid",	0xffffff00,	SRFL_PRHEX|SRFL_NOVAR,	PCI_F0DEVID,	0xffff},
-	{"boardrev",	0x0000000e,	SRFL_PRHEX,	SROM_AABREV,		SROM_BR_MASK},
-	{"boardrev",	0x000000f0,	SRFL_PRHEX,	SROM4_BREV,		0xffff},
-	{"boardrev",	0xffffff00,	SRFL_PRHEX,	SROM8_BREV,		0xffff},
-	{"boardflags",	0x00000002,	SRFL_PRHEX,	SROM_BFL,		0xffff},
-	{"boardflags",	0x00000004,	SRFL_PRHEX|SRFL_MORE,	SROM_BFL,	0xffff},
-	{"",		0,		0,		SROM_BFL2,		0xffff},
-	{"boardflags",	0x00000008,	SRFL_PRHEX|SRFL_MORE,	SROM_BFL,	0xffff},
-	{"",		0,		0,		SROM3_BFL2,		0xffff},
-	{"boardflags",	0x00000010,	SRFL_PRHEX|SRFL_MORE,	SROM4_BFL0,	0xffff},
-	{"",		0,		0,		SROM4_BFL1,		0xffff},
-	{"boardflags",	0x000000e0,	SRFL_PRHEX|SRFL_MORE,	SROM5_BFL0,	0xffff},
-	{"",		0,		0,		SROM5_BFL1,		0xffff},
-	{"boardflags",	0xffffff00,	SRFL_PRHEX|SRFL_MORE,	SROM8_BFL0,	0xffff},
-	{"",		0,		0,		SROM8_BFL1,		0xffff},
-	{"boardflags2", 0x00000010,	SRFL_PRHEX|SRFL_MORE,	SROM4_BFL2,	0xffff},
-	{"",		0,		0,		SROM4_BFL3,		0xffff},
-	{"boardflags2", 0x000000e0,	SRFL_PRHEX|SRFL_MORE,	SROM5_BFL2,	0xffff},
-	{"",		0,		0,		SROM5_BFL3,		0xffff},
-	{"boardflags2", 0xffffff00,	SRFL_PRHEX|SRFL_MORE,	SROM8_BFL2,	0xffff},
-	{"",		0,		0,		SROM8_BFL3,		0xffff},
-	{"boardtype",	0xfffffffc,	SRFL_PRHEX,	SROM_SSID,		0xffff},
-
-	{"boardnum",	0x00000006,	0,		SROM_MACLO_IL0,		0xffff},
-	{"boardnum",	0x00000008,	0,		SROM3_MACLO,		0xffff},
-	{"boardnum",	0x00000010,	0,		SROM4_MACLO,		0xffff},
-	{"boardnum",	0x000000e0,	0,		SROM5_MACLO,		0xffff},
-	{"boardnum",	0x00000700,	0,		SROM8_MACLO,		0xffff},
-	{"cc",		0x00000002,	0,		SROM_AABREV,		SROM_CC_MASK},
-	{"regrev",	0x00000008,	0,		SROM_OPO,		0xff00},
-	{"regrev",	0x00000010,	0,		SROM4_REGREV,		0x00ff},
-	{"regrev",	0x000000e0,	0,		SROM5_REGREV,		0x00ff},
-	{"regrev",	0x00000700,	0,		SROM8_REGREV,		0x00ff},
-	{"ledbh0",	0x0000000e,	SRFL_NOFFS,	SROM_LEDBH10,		0x00ff},
-	{"ledbh1",	0x0000000e,	SRFL_NOFFS,	SROM_LEDBH10,		0xff00},
-	{"ledbh2",	0x0000000e,	SRFL_NOFFS,	SROM_LEDBH32,		0x00ff},
-	{"ledbh3",	0x0000000e,	SRFL_NOFFS,	SROM_LEDBH32,		0xff00},
-	{"ledbh0",	0x00000010,	SRFL_NOFFS,	SROM4_LEDBH10,		0x00ff},
-	{"ledbh1",	0x00000010,	SRFL_NOFFS,	SROM4_LEDBH10,		0xff00},
-	{"ledbh2",	0x00000010,	SRFL_NOFFS,	SROM4_LEDBH32,		0x00ff},
-	{"ledbh3",	0x00000010,	SRFL_NOFFS,	SROM4_LEDBH32,		0xff00},
-	{"ledbh0",	0x000000e0,	SRFL_NOFFS,	SROM5_LEDBH10,		0x00ff},
-	{"ledbh1",	0x000000e0,	SRFL_NOFFS,	SROM5_LEDBH10,		0xff00},
-	{"ledbh2",	0x000000e0,	SRFL_NOFFS,	SROM5_LEDBH32,		0x00ff},
-	{"ledbh3",	0x000000e0,	SRFL_NOFFS,	SROM5_LEDBH32,		0xff00},
-	{"ledbh0",	0x00000700,	SRFL_NOFFS,	SROM8_LEDBH10,		0x00ff},
-	{"ledbh1",	0x00000700,	SRFL_NOFFS,	SROM8_LEDBH10,		0xff00},
-	{"ledbh2",	0x00000700,	SRFL_NOFFS,	SROM8_LEDBH32,		0x00ff},
-	{"ledbh3",	0x00000700,	SRFL_NOFFS,	SROM8_LEDBH32,		0xff00},
-	{"pa0b0",	0x0000000e,	SRFL_PRHEX,	SROM_WL0PAB0,		0xffff},
-	{"pa0b1",	0x0000000e,	SRFL_PRHEX,	SROM_WL0PAB1,		0xffff},
-	{"pa0b2",	0x0000000e,	SRFL_PRHEX,	SROM_WL0PAB2,		0xffff},
-	{"pa0itssit",	0x0000000e,	0,		SROM_ITT,		0x00ff},
-	{"pa0maxpwr",	0x0000000e,	0,		SROM_WL10MAXP,		0x00ff},
-	{"pa0b0",	0x00000700,	SRFL_PRHEX,	SROM8_W0_PAB0,		0xffff},
-	{"pa0b1",	0x00000700,	SRFL_PRHEX,	SROM8_W0_PAB1,		0xffff},
-	{"pa0b2",	0x00000700,	SRFL_PRHEX,	SROM8_W0_PAB2,		0xffff},
-	{"pa0itssit",	0x00000700,	0,		SROM8_W0_ITTMAXP,	0xff00},
-	{"pa0maxpwr",	0x00000700,	0,		SROM8_W0_ITTMAXP,	0x00ff},
-	{"opo",		0x0000000c,	0,		SROM_OPO,		0x00ff},
-	{"opo",		0x00000700,	0,		SROM8_2G_OFDMPO,	0x00ff},
-	{"aa2g",	0x0000000e,	0,		SROM_AABREV,		SROM_AA0_MASK},
-	{"aa2g",	0x000000f0,	0,		SROM4_AA,		0x00ff},
-	{"aa2g",	0x00000700,	0,		SROM8_AA,		0x00ff},
-	{"aa5g",	0x0000000e,	0,		SROM_AABREV,		SROM_AA1_MASK},
-	{"aa5g",	0x000000f0,	0,		SROM4_AA,		0xff00},
-	{"aa5g",	0x00000700,	0,		SROM8_AA,		0xff00},
-	{"ag0",		0x0000000e,	0,		SROM_AG10,		0x00ff},
-	{"ag1",		0x0000000e,	0,		SROM_AG10,		0xff00},
-	{"ag0",		0x000000f0,	0,		SROM4_AG10,		0x00ff},
-	{"ag1",		0x000000f0,	0,		SROM4_AG10,		0xff00},
-	{"ag2",		0x000000f0,	0,		SROM4_AG32,		0x00ff},
-	{"ag3",		0x000000f0,	0,		SROM4_AG32,		0xff00},
-	{"ag0",		0x00000700,	0,		SROM8_AG10,		0x00ff},
-	{"ag1",		0x00000700,	0,		SROM8_AG10,		0xff00},
-	{"ag2",		0x00000700,	0,		SROM8_AG32,		0x00ff},
-	{"ag3",		0x00000700,	0,		SROM8_AG32,		0xff00},
-	{"pa1b0",	0x0000000e,	SRFL_PRHEX,	SROM_WL1PAB0,		0xffff},
-	{"pa1b1",	0x0000000e,	SRFL_PRHEX,	SROM_WL1PAB1,		0xffff},
-	{"pa1b2",	0x0000000e,	SRFL_PRHEX,	SROM_WL1PAB2,		0xffff},
-	{"pa1lob0",	0x0000000c,	SRFL_PRHEX,	SROM_WL1LPAB0,		0xffff},
-	{"pa1lob1",	0x0000000c,	SRFL_PRHEX,	SROM_WL1LPAB1,		0xffff},
-	{"pa1lob2",	0x0000000c,	SRFL_PRHEX,	SROM_WL1LPAB2,		0xffff},
-	{"pa1hib0",	0x0000000c,	SRFL_PRHEX,	SROM_WL1HPAB0,		0xffff},
-	{"pa1hib1",	0x0000000c,	SRFL_PRHEX,	SROM_WL1HPAB1,		0xffff},
-	{"pa1hib2",	0x0000000c,	SRFL_PRHEX,	SROM_WL1HPAB2,		0xffff},
-	{"pa1itssit",	0x0000000e,	0,		SROM_ITT,		0xff00},
-	{"pa1maxpwr",	0x0000000e,	0,		SROM_WL10MAXP,		0xff00},
-	{"pa1lomaxpwr",	0x0000000c,	0,		SROM_WL1LHMAXP,		0xff00},
-	{"pa1himaxpwr",	0x0000000c,	0,		SROM_WL1LHMAXP,		0x00ff},
-	{"pa1b0",	0x00000700,	SRFL_PRHEX,	SROM8_W1_PAB0,		0xffff},
-	{"pa1b1",	0x00000700,	SRFL_PRHEX,	SROM8_W1_PAB1,		0xffff},
-	{"pa1b2",	0x00000700,	SRFL_PRHEX,	SROM8_W1_PAB2,		0xffff},
-	{"pa1lob0",	0x00000700,	SRFL_PRHEX,	SROM8_W1_PAB0_LC,	0xffff},
-	{"pa1lob1",	0x00000700,	SRFL_PRHEX,	SROM8_W1_PAB1_LC,	0xffff},
-	{"pa1lob2",	0x00000700,	SRFL_PRHEX,	SROM8_W1_PAB2_LC,	0xffff},
-	{"pa1hib0",	0x00000700,	SRFL_PRHEX,	SROM8_W1_PAB0_HC,	0xffff},
-	{"pa1hib1",	0x00000700,	SRFL_PRHEX,	SROM8_W1_PAB1_HC,	0xffff},
-	{"pa1hib2",	0x00000700,	SRFL_PRHEX,	SROM8_W1_PAB2_HC,	0xffff},
-	{"pa1itssit",	0x00000700,	0,		SROM8_W1_ITTMAXP,	0xff00},
-	{"pa1maxpwr",	0x00000700,	0,		SROM8_W1_ITTMAXP,	0x00ff},
-	{"pa1lomaxpwr",	0x00000700,	0,		SROM8_W1_MAXP_LCHC,	0xff00},
-	{"pa1himaxpwr",	0x00000700,	0,		SROM8_W1_MAXP_LCHC,	0x00ff},
-	{"bxa2g",	0x00000008,	0,		SROM_BXARSSI2G,		0x1800},
-	{"rssisav2g",	0x00000008,	0,		SROM_BXARSSI2G,		0x0700},
-	{"rssismc2g",	0x00000008,	0,		SROM_BXARSSI2G,		0x00f0},
-	{"rssismf2g",	0x00000008,	0,		SROM_BXARSSI2G,		0x000f},
-	{"bxa2g",	0x00000700,	0,		SROM8_BXARSSI2G,	0x1800},
-	{"rssisav2g",	0x00000700,	0,		SROM8_BXARSSI2G,	0x0700},
-	{"rssismc2g",	0x00000700,	0,		SROM8_BXARSSI2G,	0x00f0},
-	{"rssismf2g",	0x00000700,	0,		SROM8_BXARSSI2G,	0x000f},
-	{"bxa5g",	0x00000008,	0,		SROM_BXARSSI5G,		0x1800},
-	{"rssisav5g",	0x00000008,	0,		SROM_BXARSSI5G,		0x0700},
-	{"rssismc5g",	0x00000008,	0,		SROM_BXARSSI5G,		0x00f0},
-	{"rssismf5g",	0x00000008,	0,		SROM_BXARSSI5G,		0x000f},
-	{"bxa5g",	0x00000700,	0,		SROM8_BXARSSI5G,	0x1800},
-	{"rssisav5g",	0x00000700,	0,		SROM8_BXARSSI5G,	0x0700},
-	{"rssismc5g",	0x00000700,	0,		SROM8_BXARSSI5G,	0x00f0},
-	{"rssismf5g",	0x00000700,	0,		SROM8_BXARSSI5G,	0x000f},
-	{"tri2g",	0x00000008,	0,		SROM_TRI52G,		0x00ff},
-	{"tri5g",	0x00000008,	0,		SROM_TRI52G,		0xff00},
-	{"tri5gl",	0x00000008,	0,		SROM_TRI5GHL,		0x00ff},
-	{"tri5gh",	0x00000008,	0,		SROM_TRI5GHL,		0xff00},
-	{"tri2g",	0x00000700,	0,		SROM8_TRI52G,		0x00ff},
-	{"tri5g",	0x00000700,	0,		SROM8_TRI52G,		0xff00},
-	{"tri5gl",	0x00000700,	0,		SROM8_TRI5GHL,		0x00ff},
-	{"tri5gh",	0x00000700,	0,		SROM8_TRI5GHL,		0xff00},
-	{"rxpo2g",	0x00000008,	SRFL_PRSIGN,	SROM_RXPO52G,		0x00ff},
-	{"rxpo5g",	0x00000008,	SRFL_PRSIGN,	SROM_RXPO52G,		0xff00},
-	{"rxpo2g",	0x00000700,	SRFL_PRSIGN,	SROM8_RXPO52G,		0x00ff},
-	{"rxpo5g",	0x00000700,	SRFL_PRSIGN,	SROM8_RXPO52G,		0xff00},
-	{"txchain",	0x000000f0,	SRFL_NOFFS,	SROM4_TXRXC,		SROM4_TXCHAIN_MASK},
-	{"rxchain",	0x000000f0,	SRFL_NOFFS,	SROM4_TXRXC,		SROM4_RXCHAIN_MASK},
-	{"antswitch",	0x000000f0,	SRFL_NOFFS,	SROM4_TXRXC,		SROM4_SWITCH_MASK},
-	{"txchain",	0x00000700,	SRFL_NOFFS,	SROM8_TXRXC,		SROM4_TXCHAIN_MASK},
-	{"rxchain",	0x00000700,	SRFL_NOFFS,	SROM8_TXRXC,		SROM4_RXCHAIN_MASK},
-	{"antswitch",	0x00000700,	SRFL_NOFFS,	SROM8_TXRXC,		SROM4_SWITCH_MASK},
-	{"tssipos2g",	0x00000700,	0,		SROM8_FEM2G,	SROM8_FEM_TSSIPOS_MASK},
-	{"extpagain2g",	0x00000700,	0,		SROM8_FEM2G,	SROM8_FEM_EXTPA_GAIN_MASK},
-	{"pdetrange2g",	0x00000700,	0,		SROM8_FEM2G,	SROM8_FEM_PDET_RANGE_MASK},
-	{"triso2g",	0x00000700,	0,		SROM8_FEM2G,	SROM8_FEM_TR_ISO_MASK},
-	{"antswctl2g",	0x00000700,	0,		SROM8_FEM2G,	SROM8_FEM_ANTSWLUT_MASK},
-	{"tssipos5g",	0x00000700,	0,		SROM8_FEM5G,	SROM8_FEM_TSSIPOS_MASK},
-	{"extpagain5g",	0x00000700,	0,		SROM8_FEM5G,	SROM8_FEM_EXTPA_GAIN_MASK},
-	{"pdetrange5g",	0x00000700,	0,		SROM8_FEM5G,	SROM8_FEM_PDET_RANGE_MASK},
-	{"triso5g",	0x00000700,	0,		SROM8_FEM5G,	SROM8_FEM_TR_ISO_MASK},
-	{"antswctl5g",	0x00000700,	0,		SROM8_FEM5G,	SROM8_FEM_ANTSWLUT_MASK},
-	{"txpid2ga0",	0x000000f0,	0,		SROM4_TXPID2G,		0x00ff},
-	{"txpid2ga1",	0x000000f0,	0,		SROM4_TXPID2G,		0xff00},
-	{"txpid2ga2",	0x000000f0,	0,		SROM4_TXPID2G + 1,	0x00ff},
-	{"txpid2ga3",	0x000000f0,	0,		SROM4_TXPID2G + 1,	0xff00},
-	{"txpid5ga0",	0x000000f0,	0,		SROM4_TXPID5G,		0x00ff},
-	{"txpid5ga1",	0x000000f0,	0,		SROM4_TXPID5G,		0xff00},
-	{"txpid5ga2",	0x000000f0,	0,		SROM4_TXPID5G + 1,	0x00ff},
-	{"txpid5ga3",	0x000000f0,	0,		SROM4_TXPID5G + 1,	0xff00},
-	{"txpid5gla0",	0x000000f0,	0,		SROM4_TXPID5GL,		0x00ff},
-	{"txpid5gla1",	0x000000f0,	0,		SROM4_TXPID5GL,		0xff00},
-	{"txpid5gla2",	0x000000f0,	0,		SROM4_TXPID5GL + 1,	0x00ff},
-	{"txpid5gla3",	0x000000f0,	0,		SROM4_TXPID5GL + 1,	0xff00},
-	{"txpid5gha0",	0x000000f0,	0,		SROM4_TXPID5GH,		0x00ff},
-	{"txpid5gha1",	0x000000f0,	0,		SROM4_TXPID5GH,		0xff00},
-	{"txpid5gha2",	0x000000f0,	0,		SROM4_TXPID5GH + 1,	0x00ff},
-	{"txpid5gha3",	0x000000f0,	0,		SROM4_TXPID5GH + 1,	0xff00},
-
-	{"ccode",	0x0000000f,	SRFL_CCODE,	SROM_CCODE,		0xffff},
-	{"ccode",	0x00000010,	SRFL_CCODE,	SROM4_CCODE,		0xffff},
-	{"ccode",	0x000000e0,	SRFL_CCODE,	SROM5_CCODE,		0xffff},
-	{"ccode",	0x00000700,	SRFL_CCODE,	SROM8_CCODE,		0xffff},
-	{"macaddr",	0x00000700,	SRFL_ETHADDR,	SROM8_MACHI,		0xffff},
-	{"macaddr",	0x000000e0,	SRFL_ETHADDR,	SROM5_MACHI,		0xffff},
-	{"macaddr",	0x00000010,	SRFL_ETHADDR,	SROM4_MACHI,		0xffff},
-	{"macaddr",	0x00000008,	SRFL_ETHADDR,	SROM3_MACHI,		0xffff},
-	{"il0macaddr",	0x00000007,	SRFL_ETHADDR,	SROM_MACHI_IL0,		0xffff},
-	{"et1macaddr",	0x00000007,	SRFL_ETHADDR,	SROM_MACHI_ET1,		0xffff},
-	{"leddc",	0x00000700,	SRFL_NOFFS|SRFL_LEDDC,	SROM8_LEDDC,	0xffff},
-	{"leddc",	0x000000e0,	SRFL_NOFFS|SRFL_LEDDC,	SROM5_LEDDC,	0xffff},
-	{"leddc",	0x00000010,	SRFL_NOFFS|SRFL_LEDDC,	SROM4_LEDDC,	0xffff},
-	{"leddc",	0x00000008,	SRFL_NOFFS|SRFL_LEDDC,	SROM3_LEDDC,	0xffff},
-
-	{"tempthresh",	0x00000700,	0,		SROM8_THERMAL,		0xff00},
-	{"tempoffset",	0x00000700,	0,		SROM8_THERMAL,		0x00ff},
-	{"rawtempsense", 0x00000700,	SRFL_PRHEX,	SROM8_MPWR_RAWTS,	0x01ff},
-	{"measpower",	0x00000700,	SRFL_PRHEX,	SROM8_MPWR_RAWTS,	0xfe00},
-	{"tempsense_slope",	0x00000700,	SRFL_PRHEX, 	SROM8_TS_SLP_OPT_CORRX,	0x00ff},
-	{"tempcorrx",	0x00000700,	SRFL_PRHEX, 	SROM8_TS_SLP_OPT_CORRX,	0xfc00},
-	{"tempsense_option",	0x00000700,	SRFL_PRHEX,	SROM8_TS_SLP_OPT_CORRX,	0x0300},
-	{"freqoffset_corr",	0x00000700,	SRFL_PRHEX,	SROM8_FOC_HWIQ_IQSWP,	0x000f},
-	{"iqcal_swp_dis",	0x00000700,	SRFL_PRHEX,	SROM8_FOC_HWIQ_IQSWP,	0x0010},
-	{"hw_iqcal_en",	0x00000700,	SRFL_PRHEX,	SROM8_FOC_HWIQ_IQSWP,	0x0020},
-	{"elna2g",      0x00000700,     0,              SROM8_EXTLNAGAIN,       0x00ff},
-	{"elna5g",      0x00000700,     0,              SROM8_EXTLNAGAIN,       0xff00},
-	{"phycal_tempdelta",	0x00000700,	0,	SROM8_PHYCAL_TEMPDELTA,	0x00ff},
-	{"temps_period",	0x00000700,	0,	SROM8_PHYCAL_TEMPDELTA,	0x0f00},
-	{"temps_hysteresis",	0x00000700,	0,	SROM8_PHYCAL_TEMPDELTA,	0xf000},
-	{"measpower1", 0x00000700,	SRFL_PRHEX, SROM8_MPWR_1_AND_2, 	0x007f},
-	{"measpower2",	0x00000700, 	SRFL_PRHEX, SROM8_MPWR_1_AND_2, 	0x3f80},
-
-	{"cck2gpo",	0x000000f0,	0,		SROM4_2G_CCKPO,		0xffff},
-	{"cck2gpo",	0x00000100,	0,		SROM8_2G_CCKPO,		0xffff},
-	{"ofdm2gpo",	0x000000f0,	SRFL_MORE,	SROM4_2G_OFDMPO,	0xffff},
-	{"",		0,		0,		SROM4_2G_OFDMPO + 1,	0xffff},
-	{"ofdm5gpo",	0x000000f0,	SRFL_MORE,	SROM4_5G_OFDMPO,	0xffff},
-	{"",		0,		0,		SROM4_5G_OFDMPO + 1,	0xffff},
-	{"ofdm5glpo",	0x000000f0,	SRFL_MORE,	SROM4_5GL_OFDMPO,	0xffff},
-	{"",		0,		0,		SROM4_5GL_OFDMPO + 1,	0xffff},
-	{"ofdm5ghpo",	0x000000f0,	SRFL_MORE,	SROM4_5GH_OFDMPO,	0xffff},
-	{"",		0,		0,		SROM4_5GH_OFDMPO + 1,	0xffff},
-	{"ofdm2gpo",	0x00000100,	SRFL_MORE,	SROM8_2G_OFDMPO,	0xffff},
-	{"",		0,		0,		SROM8_2G_OFDMPO + 1,	0xffff},
-	{"ofdm5gpo",	0x00000100,	SRFL_MORE,	SROM8_5G_OFDMPO,	0xffff},
-	{"",		0,		0,		SROM8_5G_OFDMPO + 1,	0xffff},
-	{"ofdm5glpo",	0x00000100,	SRFL_MORE,	SROM8_5GL_OFDMPO,	0xffff},
-	{"",		0,		0,		SROM8_5GL_OFDMPO + 1,	0xffff},
-	{"ofdm5ghpo",	0x00000100,	SRFL_MORE,	SROM8_5GH_OFDMPO,	0xffff},
-	{"",		0,		0,		SROM8_5GH_OFDMPO + 1,	0xffff},
-	{"mcs2gpo0",	0x000000f0,	0,		SROM4_2G_MCSPO,		0xffff},
-	{"mcs2gpo1",	0x000000f0,	0,		SROM4_2G_MCSPO + 1,	0xffff},
-	{"mcs2gpo2",	0x000000f0,	0,		SROM4_2G_MCSPO + 2,	0xffff},
-	{"mcs2gpo3",	0x000000f0,	0,		SROM4_2G_MCSPO + 3,	0xffff},
-	{"mcs2gpo4",	0x000000f0,	0,		SROM4_2G_MCSPO + 4,	0xffff},
-	{"mcs2gpo5",	0x000000f0,	0,		SROM4_2G_MCSPO + 5,	0xffff},
-	{"mcs2gpo6",	0x000000f0,	0,		SROM4_2G_MCSPO + 6,	0xffff},
-	{"mcs2gpo7",	0x000000f0,	0,		SROM4_2G_MCSPO + 7,	0xffff},
-	{"mcs5gpo0",	0x000000f0,	0,		SROM4_5G_MCSPO,		0xffff},
-	{"mcs5gpo1",	0x000000f0,	0,		SROM4_5G_MCSPO + 1,	0xffff},
-	{"mcs5gpo2",	0x000000f0,	0,		SROM4_5G_MCSPO + 2,	0xffff},
-	{"mcs5gpo3",	0x000000f0,	0,		SROM4_5G_MCSPO + 3,	0xffff},
-	{"mcs5gpo4",	0x000000f0,	0,		SROM4_5G_MCSPO + 4,	0xffff},
-	{"mcs5gpo5",	0x000000f0,	0,		SROM4_5G_MCSPO + 5,	0xffff},
-	{"mcs5gpo6",	0x000000f0,	0,		SROM4_5G_MCSPO + 6,	0xffff},
-	{"mcs5gpo7",	0x000000f0,	0,		SROM4_5G_MCSPO + 7,	0xffff},
-	{"mcs5glpo0",	0x000000f0,	0,		SROM4_5GL_MCSPO,	0xffff},
-	{"mcs5glpo1",	0x000000f0,	0,		SROM4_5GL_MCSPO + 1,	0xffff},
-	{"mcs5glpo2",	0x000000f0,	0,		SROM4_5GL_MCSPO + 2,	0xffff},
-	{"mcs5glpo3",	0x000000f0,	0,		SROM4_5GL_MCSPO + 3,	0xffff},
-	{"mcs5glpo4",	0x000000f0,	0,		SROM4_5GL_MCSPO + 4,	0xffff},
-	{"mcs5glpo5",	0x000000f0,	0,		SROM4_5GL_MCSPO + 5,	0xffff},
-	{"mcs5glpo6",	0x000000f0,	0,		SROM4_5GL_MCSPO + 6,	0xffff},
-	{"mcs5glpo7",	0x000000f0,	0,		SROM4_5GL_MCSPO + 7,	0xffff},
-	{"mcs5ghpo0",	0x000000f0,	0,		SROM4_5GH_MCSPO,	0xffff},
-	{"mcs5ghpo1",	0x000000f0,	0,		SROM4_5GH_MCSPO + 1,	0xffff},
-	{"mcs5ghpo2",	0x000000f0,	0,		SROM4_5GH_MCSPO + 2,	0xffff},
-	{"mcs5ghpo3",	0x000000f0,	0,		SROM4_5GH_MCSPO + 3,	0xffff},
-	{"mcs5ghpo4",	0x000000f0,	0,		SROM4_5GH_MCSPO + 4,	0xffff},
-	{"mcs5ghpo5",	0x000000f0,	0,		SROM4_5GH_MCSPO + 5,	0xffff},
-	{"mcs5ghpo6",	0x000000f0,	0,		SROM4_5GH_MCSPO + 6,	0xffff},
-	{"mcs5ghpo7",	0x000000f0,	0,		SROM4_5GH_MCSPO + 7,	0xffff},
-	{"mcs2gpo0",	0x00000100,	0,		SROM8_2G_MCSPO,		0xffff},
-	{"mcs2gpo1",	0x00000100,	0,		SROM8_2G_MCSPO + 1,	0xffff},
-	{"mcs2gpo2",	0x00000100,	0,		SROM8_2G_MCSPO + 2,	0xffff},
-	{"mcs2gpo3",	0x00000100,	0,		SROM8_2G_MCSPO + 3,	0xffff},
-	{"mcs2gpo4",	0x00000100,	0,		SROM8_2G_MCSPO + 4,	0xffff},
-	{"mcs2gpo5",	0x00000100,	0,		SROM8_2G_MCSPO + 5,	0xffff},
-	{"mcs2gpo6",	0x00000100,	0,		SROM8_2G_MCSPO + 6,	0xffff},
-	{"mcs2gpo7",	0x00000100,	0,		SROM8_2G_MCSPO + 7,	0xffff},
-	{"mcs5gpo0",	0x00000100,	0,		SROM8_5G_MCSPO,		0xffff},
-	{"mcs5gpo1",	0x00000100,	0,		SROM8_5G_MCSPO + 1,	0xffff},
-	{"mcs5gpo2",	0x00000100,	0,		SROM8_5G_MCSPO + 2,	0xffff},
-	{"mcs5gpo3",	0x00000100,	0,		SROM8_5G_MCSPO + 3,	0xffff},
-	{"mcs5gpo4",	0x00000100,	0,		SROM8_5G_MCSPO + 4,	0xffff},
-	{"mcs5gpo5",	0x00000100,	0,		SROM8_5G_MCSPO + 5,	0xffff},
-	{"mcs5gpo6",	0x00000100,	0,		SROM8_5G_MCSPO + 6,	0xffff},
-	{"mcs5gpo7",	0x00000100,	0,		SROM8_5G_MCSPO + 7,	0xffff},
-	{"mcs5glpo0",	0x00000100,	0,		SROM8_5GL_MCSPO,	0xffff},
-	{"mcs5glpo1",	0x00000100,	0,		SROM8_5GL_MCSPO + 1,	0xffff},
-	{"mcs5glpo2",	0x00000100,	0,		SROM8_5GL_MCSPO + 2,	0xffff},
-	{"mcs5glpo3",	0x00000100,	0,		SROM8_5GL_MCSPO + 3,	0xffff},
-	{"mcs5glpo4",	0x00000100,	0,		SROM8_5GL_MCSPO + 4,	0xffff},
-	{"mcs5glpo5",	0x00000100,	0,		SROM8_5GL_MCSPO + 5,	0xffff},
-	{"mcs5glpo6",	0x00000100,	0,		SROM8_5GL_MCSPO + 6,	0xffff},
-	{"mcs5glpo7",	0x00000100,	0,		SROM8_5GL_MCSPO + 7,	0xffff},
-	{"mcs5ghpo0",	0x00000100,	0,		SROM8_5GH_MCSPO,	0xffff},
-	{"mcs5ghpo1",	0x00000100,	0,		SROM8_5GH_MCSPO + 1,	0xffff},
-	{"mcs5ghpo2",	0x00000100,	0,		SROM8_5GH_MCSPO + 2,	0xffff},
-	{"mcs5ghpo3",	0x00000100,	0,		SROM8_5GH_MCSPO + 3,	0xffff},
-	{"mcs5ghpo4",	0x00000100,	0,		SROM8_5GH_MCSPO + 4,	0xffff},
-	{"mcs5ghpo5",	0x00000100,	0,		SROM8_5GH_MCSPO + 5,	0xffff},
-	{"mcs5ghpo6",	0x00000100,	0,		SROM8_5GH_MCSPO + 6,	0xffff},
-	{"mcs5ghpo7",	0x00000100,	0,		SROM8_5GH_MCSPO + 7,	0xffff},
-	{"cddpo",	0x000000f0,	0,		SROM4_CDDPO,		0xffff},
-	{"stbcpo",	0x000000f0,	0,		SROM4_STBCPO,		0xffff},
-	{"bw40po",	0x000000f0,	0,		SROM4_BW40PO,		0xffff},
-	{"bwduppo",	0x000000f0,	0,		SROM4_BWDUPPO,		0xffff},
-	{"cddpo",	0x00000100,	0,		SROM8_CDDPO,		0xffff},
-	{"stbcpo",	0x00000100,	0,		SROM8_STBCPO,		0xffff},
-	{"bw40po",	0x00000100,	0,		SROM8_BW40PO,		0xffff},
-	{"bwduppo",	0x00000100,	0,		SROM8_BWDUPPO,		0xffff},
-
-	/* power per rate from sromrev 9 */
-	{"cckbw202gpo",		0x00000600,	0,	SROM9_2GPO_CCKBW20,		0xffff},
-	{"cckbw20ul2gpo",	0x00000600,	0,	SROM9_2GPO_CCKBW20UL,		0xffff},
-	{"legofdmbw202gpo",	0x00000600,	SRFL_MORE, SROM9_2GPO_LOFDMBW20,	0xffff},
-	{"",			0,		0,	SROM9_2GPO_LOFDMBW20 + 1,	0xffff},
-	{"legofdmbw20ul2gpo",	0x00000600,	SRFL_MORE, SROM9_2GPO_LOFDMBW20UL,	0xffff},
-	{"",			0,		0,	SROM9_2GPO_LOFDMBW20UL + 1,	0xffff},
-	{"legofdmbw205glpo",	0x00000600,	SRFL_MORE, SROM9_5GLPO_LOFDMBW20,	0xffff},
-	{"",			0,		0,	SROM9_5GLPO_LOFDMBW20 + 1,	0xffff},
-	{"legofdmbw20ul5glpo",	0x00000600,	SRFL_MORE, SROM9_5GLPO_LOFDMBW20UL,	0xffff},
-	{"",			0,		0,	SROM9_5GLPO_LOFDMBW20UL + 1,	0xffff},
-	{"legofdmbw205gmpo",	0x00000600,	SRFL_MORE, SROM9_5GMPO_LOFDMBW20,	0xffff},
-	{"",			0,		0,	SROM9_5GMPO_LOFDMBW20 + 1,	0xffff},
-	{"legofdmbw20ul5gmpo",	0x00000600,	SRFL_MORE, SROM9_5GMPO_LOFDMBW20UL,	0xffff},
-	{"",			0,		0,	SROM9_5GMPO_LOFDMBW20UL + 1,	0xffff},
-	{"legofdmbw205ghpo",	0x00000600,	SRFL_MORE, SROM9_5GHPO_LOFDMBW20,	0xffff},
-	{"",			0,		0,	SROM9_5GHPO_LOFDMBW20 + 1,	0xffff},
-	{"legofdmbw20ul5ghpo",	0x00000600,	SRFL_MORE, SROM9_5GHPO_LOFDMBW20UL,	0xffff},
-	{"",			0,		0,	SROM9_5GHPO_LOFDMBW20UL + 1,	0xffff},
-	{"mcsbw202gpo",		0x00000600,	SRFL_MORE, SROM9_2GPO_MCSBW20,		0xffff},
-	{"",			0,		0,	SROM9_2GPO_MCSBW20 + 1,		0xffff},
-	{"mcsbw20ul2gpo",      	0x00000600,	SRFL_MORE, SROM9_2GPO_MCSBW20UL,	0xffff},
-	{"",			0,		0,	SROM9_2GPO_MCSBW20UL + 1,	0xffff},
-	{"mcsbw402gpo",		0x00000600,	SRFL_MORE, SROM9_2GPO_MCSBW40,		0xffff},
-	{"",			0,		0,	SROM9_2GPO_MCSBW40 + 1,		0xffff},
-	{"mcsbw205glpo",	0x00000600,	SRFL_MORE, SROM9_5GLPO_MCSBW20,		0xffff},
-	{"",			0,		0,	SROM9_5GLPO_MCSBW20 + 1,	0xffff},
-	{"mcsbw20ul5glpo",	0x00000600,	SRFL_MORE, SROM9_5GLPO_MCSBW20UL,	0xffff},
-	{"",			0,		0,	SROM9_5GLPO_MCSBW20UL + 1,	0xffff},
-	{"mcsbw405glpo",	0x00000600,	SRFL_MORE, SROM9_5GLPO_MCSBW40,		0xffff},
-	{"",			0,		0,	SROM9_5GLPO_MCSBW40 + 1,	0xffff},
-	{"mcsbw205gmpo",	0x00000600,	SRFL_MORE, SROM9_5GMPO_MCSBW20,		0xffff},
-	{"",			0,		0,	SROM9_5GMPO_MCSBW20 + 1,	0xffff},
-	{"mcsbw20ul5gmpo",	0x00000600,	SRFL_MORE, SROM9_5GMPO_MCSBW20UL,	0xffff},
-	{"",			0,		0,	SROM9_5GMPO_MCSBW20UL + 1,	0xffff},
-	{"mcsbw405gmpo",	0x00000600,	SRFL_MORE, SROM9_5GMPO_MCSBW40,		0xffff},
-	{"",			0,		0,	SROM9_5GMPO_MCSBW40 + 1,	0xffff},
-	{"mcsbw205ghpo",	0x00000600,	SRFL_MORE, SROM9_5GHPO_MCSBW20,		0xffff},
-	{"",			0,		0,	SROM9_5GHPO_MCSBW20 + 1,	0xffff},
-	{"mcsbw20ul5ghpo",	0x00000600,	SRFL_MORE, SROM9_5GHPO_MCSBW20UL,	0xffff},
-	{"",			0,		0,	SROM9_5GHPO_MCSBW20UL + 1,	0xffff},
-	{"mcsbw405ghpo",	0x00000600,	SRFL_MORE, SROM9_5GHPO_MCSBW40,		0xffff},
-	{"",			0,		0,	SROM9_5GHPO_MCSBW40 + 1,	0xffff},
-	{"mcs32po",		0x00000600,	0,	SROM9_PO_MCS32,			0xffff},
-	{"legofdm40duppo",	0x00000600,	0,	SROM9_PO_LOFDM40DUP,	0xffff},
-	{"pcieingress_war",	0x00000700,	0,	SROM8_PCIEINGRESS_WAR,	0xf},
-	{"rxgainerr2ga0",	0x00000700,	0,	SROM8_RXGAINERR_2G,		0x003f},
-	{"rxgainerr2ga1",	0x00000700,	0,	SROM8_RXGAINERR_2G,		0x07c0},
-	{"rxgainerr2ga2",	0x00000700,	0,	SROM8_RXGAINERR_2G,		0xf800},
-	{"rxgainerr5gla0",	0x00000700,	0,	SROM8_RXGAINERR_5GL,	0x003f},
-	{"rxgainerr5gla1",	0x00000700,	0,	SROM8_RXGAINERR_5GL,	0x07c0},
-	{"rxgainerr5gla2",	0x00000700,	0,	SROM8_RXGAINERR_5GL,	0xf800},
-	{"rxgainerr5gma0",	0x00000700,	0,	SROM8_RXGAINERR_5GM,	0x003f},
-	{"rxgainerr5gma1",	0x00000700,	0,	SROM8_RXGAINERR_5GM,	0x07c0},
-	{"rxgainerr5gma2",	0x00000700,	0,	SROM8_RXGAINERR_5GM,	0xf800},
-	{"rxgainerr5gha0",	0x00000700,	0,	SROM8_RXGAINERR_5GH,	0x003f},
-	{"rxgainerr5gha1",	0x00000700,	0,	SROM8_RXGAINERR_5GH,	0x07c0},
-	{"rxgainerr5gha2",	0x00000700,	0,	SROM8_RXGAINERR_5GH,	0xf800},
-	{"rxgainerr5gua0",	0x00000700,	0,	SROM8_RXGAINERR_5GU,	0x003f},
-	{"rxgainerr5gua1",	0x00000700,	0,	SROM8_RXGAINERR_5GU,	0x07c0},
-	{"rxgainerr5gua2",	0x00000700,	0,	SROM8_RXGAINERR_5GU,	0xf800},
-	{"sar2g",       	0x00000600,	0,	SROM9_SAR,          	0x00ff},
-	{"sar5g",           0x00000600,	0,	SROM9_SAR,	            0xff00},
-	{"noiselvl2ga0",	0x00000700,	0,	SROM8_NOISELVL_2G,		0x001f},
-	{"noiselvl2ga1",	0x00000700,	0,	SROM8_NOISELVL_2G,		0x03e0},
-	{"noiselvl2ga2",	0x00000700,	0,	SROM8_NOISELVL_2G,		0x7c00},
-	{"noiselvl5gla0",	0x00000700,	0,	SROM8_NOISELVL_5GL,		0x001f},
-	{"noiselvl5gla1",	0x00000700,	0,	SROM8_NOISELVL_5GL,		0x03e0},
-	{"noiselvl5gla2",	0x00000700,	0,	SROM8_NOISELVL_5GL,		0x7c00},
-	{"noiselvl5gma0",	0x00000700,	0,	SROM8_NOISELVL_5GM,		0x001f},
-	{"noiselvl5gma1",	0x00000700,	0,	SROM8_NOISELVL_5GM,		0x03e0},
-	{"noiselvl5gma2",	0x00000700,	0,	SROM8_NOISELVL_5GM,		0x7c00},
-	{"noiselvl5gha0",	0x00000700,	0,	SROM8_NOISELVL_5GH,		0x001f},
-	{"noiselvl5gha1",	0x00000700,	0,	SROM8_NOISELVL_5GH,		0x03e0},
-	{"noiselvl5gha2",	0x00000700,	0,	SROM8_NOISELVL_5GH,		0x7c00},
-	{"noiselvl5gua0",	0x00000700,	0,	SROM8_NOISELVL_5GU,		0x001f},
-	{"noiselvl5gua1",	0x00000700,	0,	SROM8_NOISELVL_5GU,		0x03e0},
-	{"noiselvl5gua2",	0x00000700,	0,	SROM8_NOISELVL_5GU,		0x7c00},
-	{"subband5gver",	0x00000700,	0,	SROM8_SUBBAND_PPR,		0x7},
-
-	{"cckPwrOffset",	0x00000400,	0,	SROM10_CCKPWROFFSET,		0xffff},
-	/* swctrlmap_2g array, note that the last element doesn't have SRFL_ARRAY flag set */
-	{"swctrlmap_2g", 0x00000400, SRFL_MORE|SRFL_PRHEX|SRFL_ARRAY, SROM10_SWCTRLMAP_2G, 0xffff},
-	{"",	0x00000400, SRFL_ARRAY,	SROM10_SWCTRLMAP_2G + 1,			0xffff},
-	{"",	0x00000400, SRFL_MORE|SRFL_PRHEX|SRFL_ARRAY, SROM10_SWCTRLMAP_2G + 2, 	0xffff},
-	{"",	0x00000400, SRFL_ARRAY,	SROM10_SWCTRLMAP_2G + 3,			0xffff},
-	{"",	0x00000400, SRFL_MORE|SRFL_PRHEX|SRFL_ARRAY, SROM10_SWCTRLMAP_2G + 4,	0xffff},
-	{"",	0x00000400, SRFL_ARRAY,	SROM10_SWCTRLMAP_2G + 5,			0xffff},
-	{"",	0x00000400, SRFL_MORE|SRFL_PRHEX|SRFL_ARRAY, SROM10_SWCTRLMAP_2G + 6,	0xffff},
-	{"",	0x00000400, SRFL_ARRAY,	SROM10_SWCTRLMAP_2G + 7,			0xffff},
-	{"",	0x00000400, SRFL_PRHEX,	SROM10_SWCTRLMAP_2G + 8,			0xffff},
-
-	/* sromrev 11 */
-	{"boardflags3",	0xfffff800,	SRFL_PRHEX|SRFL_MORE,	SROM11_BFL3,	0xffff},
-	{"",		0,		0,			SROM11_BFL3,	0xffff},
-	{"boardnum",	0xfffff800,	0,			SROM11_MACLO,	0xffff},
-	{"macaddr",	0xfffff800,	SRFL_ETHADDR,		SROM11_MACHI,	0xffff},
-	{"ccode",	0xfffff800,	SRFL_CCODE,		SROM11_CCODE,	0xffff},
-	{"regrev",	0xfffff800,	0,			SROM11_REGREV,	0x00ff},
-	{"ledbh0",	0xfffff800,	SRFL_NOFFS,		SROM11_LEDBH10,	0x00ff},
-	{"ledbh1",	0xfffff800,	SRFL_NOFFS,		SROM11_LEDBH10,	0xff00},
-	{"ledbh2",	0xfffff800,	SRFL_NOFFS,		SROM11_LEDBH32,	0x00ff},
-	{"ledbh3",	0xfffff800,	SRFL_NOFFS,		SROM11_LEDBH32,	0xff00},
-	{"leddc",	0xfffff800,	SRFL_NOFFS|SRFL_LEDDC,	SROM11_LEDDC,	0xffff},
-	{"aa2g",	0xfffff800,	0,			SROM11_AA,	0x00ff},
-	{"aa5g",	0xfffff800,	0,			SROM11_AA,	0xff00},
-	{"agbg0",	0xfffff800,	0,			SROM11_AGBG10,  0x00ff},
-	{"agbg1",	0xfffff800,	0,			SROM11_AGBG10,	0xff00},
-	{"agbg2",	0xfffff800,	0,			SROM11_AGBG2A0,	0x00ff},
-	{"aga0",	0xfffff800,	0,			SROM11_AGBG2A0,	0xff00},
-	{"aga1",	0xfffff800,	0,			SROM11_AGA21,   0x00ff},
-	{"aga2",	0xfffff800,	0,			SROM11_AGA21,	0xff00},
-	{"txchain",	0xfffff800,	SRFL_NOFFS,	SROM11_TXRXC,	SROM4_TXCHAIN_MASK},
-	{"rxchain",	0xfffff800,	SRFL_NOFFS,	SROM11_TXRXC,	SROM4_RXCHAIN_MASK},
-	{"antswitch",	0xfffff800,	SRFL_NOFFS,	SROM11_TXRXC,	SROM4_SWITCH_MASK},
-
-	{"tssiposslope2g",	0xfffff800,	0,		SROM11_FEM_CFG1, 	0x0001},
-	{"epagain2g",		0xfffff800,	0,		SROM11_FEM_CFG1, 	0x000e},
-	{"pdgain2g",		0xfffff800,	0,		SROM11_FEM_CFG1, 	0x01f0},
-	{"tworangetssi2g",	0xfffff800,	0,		SROM11_FEM_CFG1, 	0x0200},
-	{"papdcap2g",		0xfffff800,	0,		SROM11_FEM_CFG1, 	0x0400},
-	{"femctrl",		0xfffff800,	0,		SROM11_FEM_CFG1, 	0xf800},
-
-	{"tssiposslope5g",	0xfffff800,	0,		SROM11_FEM_CFG2, 	0x0001},
-	{"epagain5g",		0xfffff800,	0,		SROM11_FEM_CFG2, 	0x000e},
-	{"pdgain5g",		0xfffff800,	0,		SROM11_FEM_CFG2, 	0x01f0},
-	{"tworangetssi5g",	0xfffff800,	0,		SROM11_FEM_CFG2, 	0x0200},
-	{"papdcap5g",		0xfffff800,	0,		SROM11_FEM_CFG2, 	0x0400},
-	{"gainctrlsph",		0xfffff800,	0,		SROM11_FEM_CFG2, 	0xf800},
-
-	{"tempthresh",		0xfffff800,	0,		SROM11_THERMAL,		0xff00},
-	{"tempoffset",		0xfffff800,	0,		SROM11_THERMAL,		0x00ff},
-	{"rawtempsense", 	0xfffff800,	SRFL_PRHEX,	SROM11_MPWR_RAWTS,	0x01ff},
-	{"measpower",		0xfffff800,	SRFL_PRHEX,	SROM11_MPWR_RAWTS,	0xfe00},
-	{"tempsense_slope",	0xfffff800,	SRFL_PRHEX, 	SROM11_TS_SLP_OPT_CORRX, 0x00ff},
-	{"tempcorrx",		0xfffff800,	SRFL_PRHEX, 	SROM11_TS_SLP_OPT_CORRX, 0xfc00},
-	{"tempsense_option",	0xfffff800,	SRFL_PRHEX,	SROM11_TS_SLP_OPT_CORRX, 0x0300},
-	{"phycal_tempdelta",	0xfffff800,	0,		SROM11_PHYCAL_TEMPDELTA, 0x00ff},
-	{"temps_period",	0xfffff800,	0,		SROM11_PHYCAL_TEMPDELTA, 0x0f00},
-	{"temps_hysteresis",	0xfffff800,	0,		SROM11_PHYCAL_TEMPDELTA, 0xf000},
-	{"measpower1", 		0xfffff800,	SRFL_PRHEX,	SROM11_MPWR_1_AND_2, 	0x007f},
-	{"measpower2",		0xfffff800, 	SRFL_PRHEX,	SROM11_MPWR_1_AND_2, 	0x3f80},
-	{"pdoffset40ma0",      	0xfffff800,	0,		SROM11_PDOFF_40M_A0,   	0xffff},
-	{"pdoffset40ma1",      	0xfffff800,	0,		SROM11_PDOFF_40M_A1,   	0xffff},
-	{"pdoffset40ma2",      	0xfffff800,	0,		SROM11_PDOFF_40M_A2,   	0xffff},
-	{"pdoffset80ma0",      	0xfffff800,	0,		SROM11_PDOFF_80M_A0,   	0xffff},
-	{"pdoffset80ma1",      	0xfffff800,	0,		SROM11_PDOFF_80M_A1,   	0xffff},
-	{"pdoffset80ma2",      	0xfffff800,	0,		SROM11_PDOFF_80M_A2,   	0xffff},
-
-	{"subband5gver",	0xfffff800, 	SRFL_PRHEX,	SROM11_SUBBAND5GVER, 	0xffff},
-
-	/* power per rate */
-	{"cckbw202gpo",		0xfffff800,	0,		SROM11_CCKBW202GPO, 	0xffff},
-	{"cckbw20ul2gpo",	0xfffff800,	0,		SROM11_CCKBW20UL2GPO, 	0xffff},
-	{"mcsbw202gpo",		0xfffff800,	SRFL_MORE,	SROM11_MCSBW202GPO,   	0xffff},
-	{"",            	0xfffff800, 	0,          	SROM11_MCSBW202GPO_1, 	0xffff},
-	{"mcsbw402gpo",		0xfffff800,	SRFL_MORE,	SROM11_MCSBW402GPO,   	0xffff},
-	{"",            	0xfffff800, 	0,   		SROM11_MCSBW402GPO_1, 	0xffff},
-	{"dot11agofdmhrbw202gpo", 0xfffff800, 	0, 	SROM11_DOT11AGOFDMHRBW202GPO, 	0xffff},
-	{"ofdmlrbw202gpo",	0xfffff800, 	0, 		SROM11_OFDMLRBW202GPO,	0xffff},
-	{"mcsbw205glpo",	0xfffff800,	SRFL_MORE,	SROM11_MCSBW205GLPO, 	0xffff},
-	{"",           		0xfffff800, 	0,   		SROM11_MCSBW205GLPO_1, 	0xffff},
-	{"mcsbw405glpo",	0xfffff800,	SRFL_MORE,	SROM11_MCSBW405GLPO, 	0xffff},
-	{"",           		0xfffff800, 	0,     		SROM11_MCSBW405GLPO_1, 	0xffff},
-	{"mcsbw805glpo",	0xfffff800,	SRFL_MORE,	SROM11_MCSBW805GLPO, 	0xffff},
-	{"",           		0xfffff800, 	0,    		SROM11_MCSBW805GLPO_1, 	0xffff},
-	{"mcsbw1605glpo",	0xfffff800,	SRFL_MORE,	SROM11_MCSBW1605GLPO, 	0xffff},
-	{"",           		0xfffff800, 	0,    		SROM11_MCSBW1605GLPO_1, 0xffff},
-	{"mcsbw205gmpo",	0xfffff800,	SRFL_MORE,	SROM11_MCSBW205GMPO, 	0xffff},
-	{"",           		0xfffff800, 	0,     		SROM11_MCSBW205GMPO_1, 	0xffff},
-	{"mcsbw405gmpo",	0xfffff800,	SRFL_MORE,	SROM11_MCSBW405GMPO, 	0xffff},
-	{"",           		0xfffff800, 	0,     		SROM11_MCSBW405GMPO_1, 	0xffff},
-	{"mcsbw805gmpo",	0xfffff800,	SRFL_MORE,	SROM11_MCSBW805GMPO, 	0xffff},
-	{"",           		0xfffff800, 	0,   		SROM11_MCSBW805GMPO_1, 	0xffff},
-	{"mcsbw1605gmpo",	0xfffff800,	SRFL_MORE,	SROM11_MCSBW1605GMPO, 	0xffff},
-	{"",           		0xfffff800, 	0,  		SROM11_MCSBW1605GMPO_1, 0xffff},
-	{"mcsbw205ghpo",	0xfffff800,	SRFL_MORE,	SROM11_MCSBW205GHPO, 	0xffff},
-	{"",           		0xfffff800, 	0,  		SROM11_MCSBW205GHPO_1, 	0xffff},
-	{"mcsbw405ghpo",	0xfffff800,	SRFL_MORE,	SROM11_MCSBW405GHPO, 	0xffff},
-	{"",           		0xfffff800, 	0,   		SROM11_MCSBW405GHPO_1, 	0xffff},
-	{"mcsbw805ghpo",	0xfffff800,	SRFL_MORE,	SROM11_MCSBW805GHPO, 	0xffff},
-	{"",           		0xfffff800, 	0,    		SROM11_MCSBW805GHPO_1, 	0xffff},
-	{"mcsbw1605ghpo",	0xfffff800,	SRFL_MORE,	SROM11_MCSBW1605GHPO, 	0xffff},
-	{"",           		0xfffff800, 	0,    		SROM11_MCSBW1605GHPO_1, 0xffff},
-	{"mcslr5glpo",		0xfffff800,	0,		SROM11_MCSLR5GLPO, 	0xffff},
-	{"mcslr5gmpo",		0xfffff800,	0,		SROM11_MCSLR5GMPO, 	0xffff},
-	{"mcslr5ghpo",		0xfffff800,	0,		SROM11_MCSLR5GHPO, 	0xffff},
-	{"sb20in40hrrpo", 	0xfffff800,	0,	SROM11_SB20IN40HRPO,		0xffff},
-	{"sb20in80and160hr5glpo", 0xfffff800, 	0, 	SROM11_SB20IN80AND160HR5GLPO, 	0xffff},
-	{"sb40and80hr5glpo",	  0xfffff800, 	0,	SROM11_SB40AND80HR5GLPO,	0xffff},
-	{"sb20in80and160hr5gmpo", 0xfffff800, 	0,	SROM11_SB20IN80AND160HR5GMPO, 	0xffff},
-	{"sb40and80hr5gmpo",	  0xfffff800, 	0,	SROM11_SB40AND80HR5GMPO,	0xffff},
-	{"sb20in80and160hr5ghpo", 0xfffff800, 	0,	SROM11_SB20IN80AND160HR5GHPO, 	0xffff},
-	{"sb40and80hr5ghpo",	  0xfffff800, 	0,	SROM11_SB40AND80HR5GHPO,	0xffff},
-	{"sb20in40lrpo",	  0xfffff800, 	0,	SROM11_SB20IN40LRPO,		0xffff},
-	{"sb20in80and160lr5glpo", 0xfffff800, 	0,	SROM11_SB20IN80AND160LR5GLPO, 	0xffff},
-	{"sb40and80lr5glpo",	  0xfffff800, 	0,	SROM11_SB40AND80LR5GLPO,	0xffff},
-	{"sb20in80and160lr5gmpo", 0xfffff800, 	0,	SROM11_SB20IN80AND160LR5GMPO, 	0xffff},
-	{"sb40and80lr5gmpo",	  0xfffff800, 	0,	SROM11_SB40AND80LR5GMPO,	0xffff},
-	{"sb20in80and160lr5ghpo", 0xfffff800, 	0,	SROM11_SB20IN80AND160LR5GHPO, 	0xffff},
-	{"sb40and80lr5ghpo",	  0xfffff800, 	0,	SROM11_SB40AND80LR5GHPO,	0xffff},
-	{"dot11agduphrpo",	  0xfffff800, 	0,	SROM11_DOT11AGDUPHRPO,		0xffff},
-	{"dot11agduplrpo",	  0xfffff800, 	0,	SROM11_DOT11AGDUPLRPO,		0xffff},
-
-	/* Misc */
-	{"pcieingress_war",	0xfffff800,	0,	SROM11_PCIEINGRESS_WAR,	0xf},
-	{"sar2g",       	0xfffff800,	0,	SROM11_SAR,          	0x00ff},
-	{"sar5g",           	0xfffff800,	0,	SROM11_SAR,		0xff00},
-
-	{"noiselvl2ga0",	0xfffff800,	0,		SROM11_NOISELVL_2G,	0x001f},
-	{"noiselvl2ga1",	0xfffff800,	0,		SROM11_NOISELVL_2G,	0x03e0},
-	{"noiselvl2ga2",	0xfffff800,	0,		SROM11_NOISELVL_2G,	0x7c00},
-	{"noiselvl5ga0",	0xfffff800,	SRFL_ARRAY,	SROM11_NOISELVL_5GL,	0x001f},
-	{"",			0xfffff800,	SRFL_ARRAY,	SROM11_NOISELVL_5GM,	0x001f},
-	{"",			0xfffff800,	SRFL_ARRAY,	SROM11_NOISELVL_5GH,	0x001f},
-	{"",			0xfffff800,	0,		SROM11_NOISELVL_5GU,	0x001f},
-	{"noiselvl5ga1",	0xfffff800,	SRFL_ARRAY,	SROM11_NOISELVL_5GL,	0x03e0},
-	{"",			0xfffff800,	SRFL_ARRAY,	SROM11_NOISELVL_5GM,	0x03e0},
-	{"",			0xfffff800,	SRFL_ARRAY,	SROM11_NOISELVL_5GH,	0x03e0},
-	{"",			0xfffff800,	0,		SROM11_NOISELVL_5GU,	0x03e0},
-	{"noiselvl5ga2",	0xfffff800,	SRFL_ARRAY,	SROM11_NOISELVL_5GL,	0x7c00},
-	{"",			0xfffff800,	SRFL_ARRAY,	SROM11_NOISELVL_5GM,	0x7c00},
-	{"",			0xfffff800,	SRFL_ARRAY,	SROM11_NOISELVL_5GH,	0x7c00},
-	{"",			0xfffff800,	0,		SROM11_NOISELVL_5GU,	0x7c00},
-
-	{"rxgainerr2ga0", 	0xfffff800, 	0,    		SROM11_RXGAINERR_2G,    0x003f},
-	{"rxgainerr2ga1", 	0xfffff800, 	0,    		SROM11_RXGAINERR_2G,    0x07c0},
-	{"rxgainerr2ga2", 	0xfffff800, 	0,    		SROM11_RXGAINERR_2G,    0xf800},
-	{"rxgainerr5ga0",      	0xfffff800, 	SRFL_ARRAY,    	SROM11_RXGAINERR_5GL,   0x003f},
-	{"",      		0xfffff800, 	SRFL_ARRAY,    	SROM11_RXGAINERR_5GM,   0x003f},
-	{"",      		0xfffff800, 	SRFL_ARRAY,    	SROM11_RXGAINERR_5GH,   0x003f},
-	{"",      		0xfffff800, 	0,    		SROM11_RXGAINERR_5GU,   0x003f},
-	{"rxgainerr5ga1",      	0xfffff800, 	SRFL_ARRAY,    	SROM11_RXGAINERR_5GL,   0x07c0},
-	{"",      		0xfffff800, 	SRFL_ARRAY,    	SROM11_RXGAINERR_5GM,   0x07c0},
-	{"",      		0xfffff800, 	SRFL_ARRAY,    	SROM11_RXGAINERR_5GH,   0x07c0},
-	{"",      		0xfffff800, 	0,    		SROM11_RXGAINERR_5GU,   0x07c0},
-	{"rxgainerr5ga2",      	0xfffff800, 	SRFL_ARRAY,    	SROM11_RXGAINERR_5GL,   0xf800},
-	{"",      		0xfffff800, 	SRFL_ARRAY,    	SROM11_RXGAINERR_5GM,   0xf800},
-	{"",      		0xfffff800, 	SRFL_ARRAY,    	SROM11_RXGAINERR_5GH,   0xf800},
-	{"",      		0xfffff800, 	0,    		SROM11_RXGAINERR_5GU,   0xf800},
-
-	{NULL,		0,		0,		0,			0}
-};
-
-static const sromvar_t perpath_pci_sromvars[] = {
-	{"maxp2ga",	0x000000f0,	0,		SROM4_2G_ITT_MAXP,	0x00ff},
-	{"itt2ga",	0x000000f0,	0,		SROM4_2G_ITT_MAXP,	0xff00},
-	{"itt5ga",	0x000000f0,	0,		SROM4_5G_ITT_MAXP,	0xff00},
-	{"pa2gw0a",	0x000000f0,	SRFL_PRHEX,	SROM4_2G_PA,		0xffff},
-	{"pa2gw1a",	0x000000f0,	SRFL_PRHEX,	SROM4_2G_PA + 1,	0xffff},
-	{"pa2gw2a",	0x000000f0,	SRFL_PRHEX,	SROM4_2G_PA + 2,	0xffff},
-	{"pa2gw3a",	0x000000f0,	SRFL_PRHEX,	SROM4_2G_PA + 3,	0xffff},
-	{"maxp5ga",	0x000000f0,	0,		SROM4_5G_ITT_MAXP,	0x00ff},
-	{"maxp5gha",	0x000000f0,	0,		SROM4_5GLH_MAXP,	0x00ff},
-	{"maxp5gla",	0x000000f0,	0,		SROM4_5GLH_MAXP,	0xff00},
-	{"pa5gw0a",	0x000000f0,	SRFL_PRHEX,	SROM4_5G_PA,		0xffff},
-	{"pa5gw1a",	0x000000f0,	SRFL_PRHEX,	SROM4_5G_PA + 1,	0xffff},
-	{"pa5gw2a",	0x000000f0,	SRFL_PRHEX,	SROM4_5G_PA + 2,	0xffff},
-	{"pa5gw3a",	0x000000f0,	SRFL_PRHEX,	SROM4_5G_PA + 3,	0xffff},
-	{"pa5glw0a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GL_PA,		0xffff},
-	{"pa5glw1a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GL_PA + 1,	0xffff},
-	{"pa5glw2a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GL_PA + 2,	0xffff},
-	{"pa5glw3a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GL_PA + 3,	0xffff},
-	{"pa5ghw0a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GH_PA,		0xffff},
-	{"pa5ghw1a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GH_PA + 1,	0xffff},
-	{"pa5ghw2a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GH_PA + 2,	0xffff},
-	{"pa5ghw3a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GH_PA + 3,	0xffff},
-	{"maxp2ga",	0x00000700,	0,		SROM8_2G_ITT_MAXP,	0x00ff},
-	{"itt2ga",	0x00000700,	0,		SROM8_2G_ITT_MAXP,	0xff00},
-	{"itt5ga",	0x00000700,	0,		SROM8_5G_ITT_MAXP,	0xff00},
-	{"pa2gw0a",	0x00000700,	SRFL_PRHEX,	SROM8_2G_PA,		0xffff},
-	{"pa2gw1a",	0x00000700,	SRFL_PRHEX,	SROM8_2G_PA + 1,	0xffff},
-	{"pa2gw2a",	0x00000700,	SRFL_PRHEX,	SROM8_2G_PA + 2,	0xffff},
-	{"maxp5ga",	0x00000700,	0,		SROM8_5G_ITT_MAXP,	0x00ff},
-	{"maxp5gha",	0x00000700,	0,		SROM8_5GLH_MAXP,	0x00ff},
-	{"maxp5gla",	0x00000700,	0,		SROM8_5GLH_MAXP,	0xff00},
-	{"pa5gw0a",	0x00000700,	SRFL_PRHEX,	SROM8_5G_PA,		0xffff},
-	{"pa5gw1a",	0x00000700,	SRFL_PRHEX,	SROM8_5G_PA + 1,	0xffff},
-	{"pa5gw2a",	0x00000700,	SRFL_PRHEX,	SROM8_5G_PA + 2,	0xffff},
-	{"pa5glw0a",	0x00000700,	SRFL_PRHEX,	SROM8_5GL_PA,		0xffff},
-	{"pa5glw1a",	0x00000700,	SRFL_PRHEX,	SROM8_5GL_PA + 1,	0xffff},
-	{"pa5glw2a",	0x00000700,	SRFL_PRHEX,	SROM8_5GL_PA + 2,	0xffff},
-	{"pa5ghw0a",	0x00000700,	SRFL_PRHEX,	SROM8_5GH_PA,		0xffff},
-	{"pa5ghw1a",	0x00000700,	SRFL_PRHEX,	SROM8_5GH_PA + 1,	0xffff},
-	{"pa5ghw2a",	0x00000700,	SRFL_PRHEX,	SROM8_5GH_PA + 2,	0xffff},
-
-	/* sromrev 11 */
-	{"maxp2ga",	0xfffff800,	0,			 SROM11_2G_MAXP,	0x00ff},
-	{"pa2ga",	0xfffff800,	SRFL_PRHEX | SRFL_ARRAY, SROM11_2G_PA,		0xffff},
-	{"",		0xfffff800,	SRFL_PRHEX | SRFL_ARRAY, SROM11_2G_PA + 1,	0xffff},
-	{"",		0xfffff800,	SRFL_PRHEX,		 SROM11_2G_PA + 2,	0xffff},
-	{"rxgains5gmelnagaina",	0xfffff800,	0,		 SROM11_RXGAINS1,	0x0007},
-	{"rxgains5gmtrisoa",	0xfffff800,	0,		 SROM11_RXGAINS1,	0x0078},
-	{"rxgains5gmtrelnabypa", 0xfffff800,	0,		 SROM11_RXGAINS1,	0x0080},
-	{"rxgains5ghelnagaina",	0xfffff800,	0,		 SROM11_RXGAINS1,	0x0700},
-	{"rxgains5ghtrisoa",	0xfffff800,	0,		 SROM11_RXGAINS1,	0x7800},
-	{"rxgains5ghtrelnabypa", 0xfffff800,	0,		 SROM11_RXGAINS1,	0x8000},
-	{"rxgains2gelnagaina",	0xfffff800,	0,		 SROM11_RXGAINS,	0x0007},
-	{"rxgains2gtrisoa",	0xfffff800,	0,		 SROM11_RXGAINS,	0x0078},
-	{"rxgains2gtrelnabypa",	0xfffff800,	0,		 SROM11_RXGAINS,	0x0080},
-	{"rxgains5gelnagaina",	0xfffff800,	0,		 SROM11_RXGAINS,	0x0700},
-	{"rxgains5gtrisoa",	0xfffff800,	0,		 SROM11_RXGAINS,	0x7800},
-	{"rxgains5gtrelnabypa",	0xfffff800,	0,		 SROM11_RXGAINS,	0x8000},
-	{"maxp5ga",	0xfffff800,	SRFL_ARRAY,		 SROM11_5GB1B0_MAXP,	0x00ff},
-	{"",		0xfffff800,	SRFL_ARRAY,		 SROM11_5GB1B0_MAXP,	0xff00},
-	{"",		0xfffff800,	SRFL_ARRAY,		 SROM11_5GB3B2_MAXP,	0x00ff},
-	{"",		0xfffff800,	0,			 SROM11_5GB3B2_MAXP,	0xff00},
-	{"pa5ga",	0xfffff800,	SRFL_PRHEX | SRFL_ARRAY, SROM11_5GB0_PA,	0xffff},
-	{"",		0xfffff800,	SRFL_PRHEX | SRFL_ARRAY, SROM11_5GB0_PA + 1,	0xffff},
-	{"",		0xfffff800,	SRFL_PRHEX | SRFL_ARRAY, SROM11_5GB0_PA + 2,	0xffff},
-	{"",		0xfffff800,	SRFL_PRHEX | SRFL_ARRAY, SROM11_5GB1_PA,	0xffff},
-	{"",		0xfffff800,	SRFL_PRHEX | SRFL_ARRAY, SROM11_5GB1_PA + 1,	0xffff},
-	{"",		0xfffff800,	SRFL_PRHEX | SRFL_ARRAY, SROM11_5GB1_PA + 2,	0xffff},
-	{"",		0xfffff800,	SRFL_PRHEX | SRFL_ARRAY, SROM11_5GB2_PA,	0xffff},
-	{"",		0xfffff800,	SRFL_PRHEX | SRFL_ARRAY, SROM11_5GB2_PA + 1,	0xffff},
-	{"",		0xfffff800,	SRFL_PRHEX | SRFL_ARRAY, SROM11_5GB2_PA + 2,	0xffff},
-	{"",		0xfffff800,	SRFL_PRHEX | SRFL_ARRAY, SROM11_5GB3_PA,	0xffff},
-	{"",		0xfffff800,	SRFL_PRHEX | SRFL_ARRAY, SROM11_5GB3_PA + 1,	0xffff},
-	{"",		0xfffff800,	SRFL_PRHEX,		 SROM11_5GB3_PA + 2,	0xffff},
-
-	{NULL,		0,		0,		0, 			0}
-};
-
-#if !(defined(PHY_TYPE_HT) && defined(PHY_TYPE_N) && defined(PHY_TYPE_LP))
-#define	PHY_TYPE_HT		7	/* HT-Phy value */
-#define	PHY_TYPE_N		4	/* N-Phy value */
-#define	PHY_TYPE_LP		5	/* LP-Phy value */
-#endif /* !(defined(PHY_TYPE_HT) && defined(PHY_TYPE_N) && defined(PHY_TYPE_LP)) */
-#if !defined(PHY_TYPE_AC)
-#define	PHY_TYPE_AC		11	/* AC-Phy value */
-#endif /* !defined(PHY_TYPE_AC) */
-#if !defined(PHY_TYPE_NULL)
-#define	PHY_TYPE_NULL		0xf	/* Invalid Phy value */
-#endif /* !defined(PHY_TYPE_NULL) */
-
-typedef struct {
-	uint16	phy_type;
-	uint16	bandrange;
-	uint16	chain;
-	const char *vars;
-} pavars_t;
-
-static const pavars_t pavars[] = {
-	/* HTPHY */
-	{PHY_TYPE_HT, WL_CHAN_FREQ_RANGE_2G,  0, "pa2gw0a0 pa2gw1a0 pa2gw2a0"},
-	{PHY_TYPE_HT, WL_CHAN_FREQ_RANGE_2G,  1, "pa2gw0a1 pa2gw1a1 pa2gw2a1"},
-	{PHY_TYPE_HT, WL_CHAN_FREQ_RANGE_2G,  2, "pa2gw0a2 pa2gw1a2 pa2gw2a2"},
-	{PHY_TYPE_HT, WL_CHAN_FREQ_RANGE_5G_BAND0, 0, "pa5glw0a0 pa5glw1a0 pa5glw2a0"},
-	{PHY_TYPE_HT, WL_CHAN_FREQ_RANGE_5G_BAND0, 1, "pa5glw0a1 pa5glw1a1 pa5glw2a1"},
-	{PHY_TYPE_HT, WL_CHAN_FREQ_RANGE_5G_BAND0, 2, "pa5glw0a2 pa5glw1a2 pa5glw2a2"},
-	{PHY_TYPE_HT, WL_CHAN_FREQ_RANGE_5G_BAND1, 0, "pa5gw0a0 pa5gw1a0 pa5gw2a0"},
-	{PHY_TYPE_HT, WL_CHAN_FREQ_RANGE_5G_BAND1, 1, "pa5gw0a1 pa5gw1a1 pa5gw2a1"},
-	{PHY_TYPE_HT, WL_CHAN_FREQ_RANGE_5G_BAND1, 2, "pa5gw0a2 pa5gw1a2 pa5gw2a2"},
-	{PHY_TYPE_HT, WL_CHAN_FREQ_RANGE_5G_BAND2, 0, "pa5ghw0a0 pa5ghw1a0 pa5ghw2a0"},
-	{PHY_TYPE_HT, WL_CHAN_FREQ_RANGE_5G_BAND2, 1, "pa5ghw0a1 pa5ghw1a1 pa5ghw2a1"},
-	{PHY_TYPE_HT, WL_CHAN_FREQ_RANGE_5G_BAND2, 2, "pa5ghw0a2 pa5ghw1a2 pa5ghw2a2"},
-	{PHY_TYPE_HT, WL_CHAN_FREQ_RANGE_5G_BAND3, 0, "pa5gw0a3 pa5gw1a3 pa5gw2a3"},
-	{PHY_TYPE_HT, WL_CHAN_FREQ_RANGE_5G_BAND3, 1,  "pa5glw0a3 pa5glw1a3 pa5glw2a3"},
-	{PHY_TYPE_HT, WL_CHAN_FREQ_RANGE_5G_BAND3, 2, "pa5ghw0a3 pa5ghw1a3 pa5ghw2a3"},
-	/* NPHY */
-	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_2G,  0, "pa2gw0a0 pa2gw1a0 pa2gw2a0"},
-	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_2G,  1, "pa2gw0a1 pa2gw1a1 pa2gw2a1"},
-	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_5G_BAND0, 0, "pa5glw0a0 pa5glw1a0 pa5glw2a0"},
-	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_5G_BAND0, 1, "pa5glw0a1 pa5glw1a1 pa5glw2a1"},
-	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_5G_BAND1, 0, "pa5gw0a0 pa5gw1a0 pa5gw2a0"},
-	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_5G_BAND1, 1, "pa5gw0a1 pa5gw1a1 pa5gw2a1"},
-	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_5G_BAND2, 0, "pa5ghw0a0 pa5ghw1a0 pa5ghw2a0"},
-	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_5G_BAND2, 1, "pa5ghw0a1 pa5ghw1a1 pa5ghw2a1"},
-	/* LPPHY */
-	{PHY_TYPE_LP, WL_CHAN_FREQ_RANGE_2G,  0, "pa0b0 pa0b1 pa0b2"},
-	{PHY_TYPE_LP, WL_CHAN_FREQ_RANGE_5GL, 0, "pa1lob0 pa1lob1 pa1lob2"},
-	{PHY_TYPE_LP, WL_CHAN_FREQ_RANGE_5GM, 0, "pa1b0 pa1b1 pa1b2"},
-	{PHY_TYPE_LP, WL_CHAN_FREQ_RANGE_5GH, 0, "pa1hib0 pa1hib1 pa1hib2"},
-	/* ACPHY */
-	{PHY_TYPE_AC, WL_CHAN_FREQ_RANGE_2G,  0, "pa2ga0"},
-	{PHY_TYPE_AC, WL_CHAN_FREQ_RANGE_2G,  1, "pa2ga1"},
-	{PHY_TYPE_AC, WL_CHAN_FREQ_RANGE_2G,  2, "pa2ga2"},
-	{PHY_TYPE_AC, WL_CHAN_FREQ_RANGE_5G_4BAND,  0, "pa5ga0"},
-	{PHY_TYPE_AC, WL_CHAN_FREQ_RANGE_5G_4BAND,  1, "pa5ga1"},
-	{PHY_TYPE_AC, WL_CHAN_FREQ_RANGE_5G_4BAND,  2, "pa5ga2"},
-	{PHY_TYPE_NULL, 0, 0, ""}
-};
-
-typedef struct {
-	uint16	phy_type;
-	uint16	bandrange;
-	const char *vars;
-} povars_t;
-
-static const povars_t povars[] = {
-	/* NPHY */
-	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_2G,  "mcs2gpo0 mcs2gpo1 mcs2gpo2 mcs2gpo3 "
-	"mcs2gpo4 mcs2gpo5 mcs2gpo6 mcs2gpo7"},
-	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_5GL, "mcs5glpo0 mcs5glpo1 mcs5glpo2 mcs5glpo3 "
-	"mcs5glpo4 mcs5glpo5 mcs5glpo6 mcs5glpo7"},
-	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_5GM, "mcs5gpo0 mcs5gpo1 mcs5gpo2 mcs5gpo3 "
-	"mcs5gpo4 mcs5gpo5 mcs5gpo6 mcs5gpo7"},
-	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_5GH, "mcs5ghpo0 mcs5ghpo1 mcs5ghpo2 mcs5ghpo3 "
-	"mcs5ghpo4 mcs5ghpo5 mcs5ghpo6 mcs5ghpo7"},
-	{PHY_TYPE_NULL, 0, ""}
-};
-
-typedef struct {
-	uint8	tag;		/* Broadcom subtag name */
-	uint32	revmask;	/* Supported cis_sromrev */
-	uint8	len;		/* Length field of the tuple, note that it includes the
-				 * subtag name (1 byte): 1 + tuple content length
-				 */
-	const char *params;
-} cis_tuple_t;
-
-#define OTP_RAW		(0xff - 1)	/* Reserved tuple number for wrvar Raw input */
-#define OTP_VERS_1	(0xff - 2)	/* CISTPL_VERS_1 */
-#define OTP_MANFID	(0xff - 3)	/* CISTPL_MANFID */
-#define OTP_RAW1	(0xff - 4)	/* Like RAW, but comes first */
-
-static const cis_tuple_t cis_hnbuvars[] = {
-	{OTP_RAW1,		0xffffffff, 0, ""},	/* special case */
-	{OTP_VERS_1,	0xffffffff, 0, "smanf sproductname"},	/* special case (non BRCM tuple) */
-	{OTP_MANFID,	0xffffffff, 4, "2manfid 2prodid"},	/* special case (non BRCM tuple) */
-	/* Unified OTP: tupple to embed USB manfid inside SDIO CIS */
-	{HNBU_UMANFID,		0xffffffff, 8, "8usbmanfid"},
-	{HNBU_SROMREV,		0xffffffff, 2, "1sromrev"},
-	/* NOTE: subdevid is also written to boardtype.
-	 *       Need to write HNBU_BOARDTYPE to change it if it is different.
-	 */
-	{HNBU_CHIPID,		0xffffffff, 11, "2vendid 2devid 2chiprev 2subvendid 2subdevid"},
-	{HNBU_BOARDREV,		0xffffffff, 3, "2boardrev"},
-	{HNBU_PAPARMS,		0xffffffff, 10, "2pa0b0 2pa0b1 2pa0b2 1pa0itssit 1pa0maxpwr 1opo"},
-	{HNBU_AA,		0xffffffff, 3, "1aa2g 1aa5g"},
-	{HNBU_AA,		0xffffffff, 3, "1aa0 1aa1"}, /* backward compatibility */
-	{HNBU_AG,		0xffffffff, 5, "1ag0 1ag1 1ag2 1ag3"},
-	{HNBU_BOARDFLAGS,	0xffffffff, 13, "4boardflags 4boardflags2 4boardflags3"},
-	{HNBU_LEDS,		0xffffffff, 5, "1ledbh0 1ledbh1 1ledbh2 1ledbh3"},
-	{HNBU_CCODE,		0xffffffff, 4, "2ccode 1cctl"},
-	{HNBU_CCKPO,		0xffffffff, 3, "2cckpo"},
-	{HNBU_OFDMPO,		0xffffffff, 5, "4ofdmpo"},
-	{HNBU_PAPARMS5G,	0xffffffff, 23, "2pa1b0 2pa1b1 2pa1b2 2pa1lob0 2pa1lob1 2pa1lob2 "
-	"2pa1hib0 2pa1hib1 2pa1hib2 1pa1itssit "
-	"1pa1maxpwr 1pa1lomaxpwr 1pa1himaxpwr"},
-	{HNBU_RDLID,		0xffffffff, 3, "2rdlid"},
-	{HNBU_RSSISMBXA2G, 0xffffffff, 3, "0rssismf2g 0rssismc2g "
-	"0rssisav2g 0bxa2g"}, /* special case */
-	{HNBU_RSSISMBXA5G, 0xffffffff, 3, "0rssismf5g 0rssismc5g "
-	"0rssisav5g 0bxa5g"}, /* special case */
-	{HNBU_XTALFREQ,		0xffffffff, 5, "4xtalfreq"},
-	{HNBU_TRI2G,		0xffffffff, 2, "1tri2g"},
-	{HNBU_TRI5G,		0xffffffff, 4, "1tri5gl 1tri5g 1tri5gh"},
-	{HNBU_RXPO2G,		0xffffffff, 2, "1rxpo2g"},
-	{HNBU_RXPO5G,		0xffffffff, 2, "1rxpo5g"},
-	{HNBU_BOARDNUM,		0xffffffff, 3, "2boardnum"},
-	{HNBU_MACADDR,		0xffffffff, 7, "6macaddr"},	/* special case */
-	{HNBU_RDLSN,		0xffffffff, 3, "2rdlsn"},
-	{HNBU_BOARDTYPE,	0xffffffff, 3, "2boardtype"},
-	{HNBU_LEDDC,		0xffffffff, 3, "2leddc"},
-	{HNBU_RDLRNDIS,		0xffffffff, 2, "1rdlndis"},
-	{HNBU_CHAINSWITCH,	0xffffffff, 5, "1txchain 1rxchain 2antswitch"},
-	{HNBU_REGREV,		0xffffffff, 2, "1regrev"},
-	{HNBU_FEM,		0x000007fe, 5, "0antswctl2g 0triso2g 0pdetrange2g 0extpagain2g "
-	"0tssipos2g 0antswctl5g 0triso5g 0pdetrange5g 0extpagain5g 0tssipos5g"}, /* special case */
-	{HNBU_PAPARMS_C0,	0x000007fe, 31, "1maxp2ga0 1itt2ga0 2pa2gw0a0 2pa2gw1a0 "
-	"2pa2gw2a0 1maxp5ga0 1itt5ga0 1maxp5gha0 1maxp5gla0 2pa5gw0a0 2pa5gw1a0 2pa5gw2a0 "
-	"2pa5glw0a0 2pa5glw1a0 2pa5glw2a0 2pa5ghw0a0 2pa5ghw1a0 2pa5ghw2a0"},
-	{HNBU_PAPARMS_C1,	0x000007fe, 31, "1maxp2ga1 1itt2ga1 2pa2gw0a1 2pa2gw1a1 "
-	"2pa2gw2a1 1maxp5ga1 1itt5ga1 1maxp5gha1 1maxp5gla1 2pa5gw0a1 2pa5gw1a1 2pa5gw2a1 "
-	"2pa5glw0a1 2pa5glw1a1 2pa5glw2a1 2pa5ghw0a1 2pa5ghw1a1 2pa5ghw2a1"},
-	{HNBU_PO_CCKOFDM,	0xffffffff, 19, "2cck2gpo 4ofdm2gpo 4ofdm5gpo 4ofdm5glpo "
-	"4ofdm5ghpo"},
-	{HNBU_PO_MCS2G,		0xffffffff, 17, "2mcs2gpo0 2mcs2gpo1 2mcs2gpo2 2mcs2gpo3 "
-	"2mcs2gpo4 2mcs2gpo5 2mcs2gpo6 2mcs2gpo7"},
-	{HNBU_PO_MCS5GM,	0xffffffff, 17, "2mcs5gpo0 2mcs5gpo1 2mcs5gpo2 2mcs5gpo3 "
-	"2mcs5gpo4 2mcs5gpo5 2mcs5gpo6 2mcs5gpo7"},
-	{HNBU_PO_MCS5GLH,	0xffffffff, 33, "2mcs5glpo0 2mcs5glpo1 2mcs5glpo2 2mcs5glpo3 "
-	"2mcs5glpo4 2mcs5glpo5 2mcs5glpo6 2mcs5glpo7 "
-	"2mcs5ghpo0 2mcs5ghpo1 2mcs5ghpo2 2mcs5ghpo3 "
-	"2mcs5ghpo4 2mcs5ghpo5 2mcs5ghpo6 2mcs5ghpo7"},
-	{HNBU_CCKFILTTYPE,	0xffffffff, 2, "1cckdigfilttype"},
-	{HNBU_PO_CDD,		0xffffffff, 3, "2cddpo"},
-	{HNBU_PO_STBC,		0xffffffff, 3, "2stbcpo"},
-	{HNBU_PO_40M,		0xffffffff, 3, "2bw40po"},
-	{HNBU_PO_40MDUP,	0xffffffff, 3, "2bwduppo"},
-	{HNBU_RDLRWU,		0xffffffff, 2, "1rdlrwu"},
-	{HNBU_WPS,		0xffffffff, 3, "1wpsgpio 1wpsled"},
-	{HNBU_USBFS,		0xffffffff, 2, "1usbfs"},
-	{HNBU_ELNA2G,           0xffffffff, 2, "1elna2g"},
-	{HNBU_ELNA5G,           0xffffffff, 2, "1elna5g"},
-	{HNBU_CUSTOM1,		0xffffffff, 5, "4customvar1"},
-	{OTP_RAW,		0xffffffff, 0, ""},	/* special case */
-	{HNBU_OFDMPO5G,		0xffffffff, 13, "4ofdm5gpo 4ofdm5glpo 4ofdm5ghpo"},
-	{HNBU_USBEPNUM,		0xffffffff, 3, "2usbepnum"},
-	{HNBU_CCKBW202GPO,	0xffffffff, 5, "2cckbw202gpo 2cckbw20ul2gpo"},
-	{HNBU_LEGOFDMBW202GPO,	0xffffffff, 9, "4legofdmbw202gpo 4legofdmbw20ul2gp"},
-	{HNBU_LEGOFDMBW205GPO,	0xffffffff, 25, "4legofdmbw205glpo 4legofdmbw20ul5glpo "
-	"4legofdmbw205gmpo 4legofdmbw20ul5gmpo 4legofdmbw205ghpo 4legofdmbw20ul5ghpo"},
-	{HNBU_MCS2GPO,	0xffffffff, 13,	"4mcsbw202gpo 4mcsbw20ul2gpo 4mcsbw402gpo"},
-	{HNBU_MCS5GLPO,	0xffffffff, 13,	"4mcsbw205glpo 4mcsbw20ul5glpo 4mcsbw405glpo"},
-	{HNBU_MCS5GMPO,	0xffffffff, 13,	"4mcsbw205gmpo 4mcsbw20ul5gmpo 4mcsbw405gmpo"},
-	{HNBU_MCS5GHPO,	0xffffffff, 13,	"4mcsbw205ghpo 4mcsbw20ul5ghpo 4mcsbw405ghpo"},
-	{HNBU_MCS32PO,	0xffffffff, 3,	"2mcs32po"},
-	{HNBU_LEG40DUPPO, 	0xffffffff, 3,	"2legofdm40duppo"},
-	{HNBU_TEMPTHRESH, 	0xffffffff, 7,	"1tempthresh 0temps_period 0temps_hysteresis "
-	"1tempoffset 1tempsense_slope 0tempcorrx 0tempsense_option "
-	"1phycal_tempdelta"}, /* special case */
-	{HNBU_MUXENAB,		0xffffffff, 2,	"1muxenab"},
-	{HNBU_FEM_CFG,		0xfffff800, 5,	"0femctrl 0papdcap2g 0tworangetssi2g 0pdgain2g "
-	"0epagain2g 0tssiposslope2g 0gainctrlsph 0papdcap5g 0tworangetssi5g 0pdgain5g 0epagain5g "
-	"0tssiposslope5g"}, /* special case */
-	{HNBU_ACPA_C0,		0xfffff800, 39,	"2subband5gver 2maxp2ga0 2*3pa2ga0 "
-	"1*4maxp5ga0 2*12pa5ga0"},
-	{HNBU_ACPA_C1,		0xfffff800, 37,	"2maxp2ga1 2*3pa2ga1 1*4maxp5ga1 2*12pa5ga1"},
-	{HNBU_ACPA_C2,		0xfffff800, 37,	"2maxp2ga2 2*3pa2ga2 1*4maxp5ga2 2*12pa5ga2"},
-	{HNBU_MEAS_PWR,		0xfffff800, 5,	"1measpower 1measpower1 1measpower2 2rawtempsense"},
-	{HNBU_PDOFF,		0xfffff800, 13,	"2pdoffset40ma0 2pdoffset40ma1 2pdoffset40ma2 "
-	"2pdoffset80ma0 2pdoffset80ma1 2pdoffset80ma2"},
-	{HNBU_ACPPR_2GPO,	0xfffff800, 5,	"2dot11agofdmhrbw202gpo 2ofdmlrbw202gpo"},
-	{HNBU_ACPPR_5GPO,	0xfffff800, 31,	"4mcsbw805glpo 4mcsbw1605glpo 4mcsbw805gmpo "
-	"4mcsbw1605gmpo 4mcsbw805ghpo 4mcsbw1605ghpo 2mcslr5rlpo 2mcslr5gmpo 2mcslr5ghpo"},
-	{HNBU_ACPPR_SBPO,	0xfffff800, 33,	"2sb20in40hrrpo 2sb20in80and160hr5glpo "
-	"2sb40and80hr5glpo 2sb20in80and160hr5gmpo 2sb40and80hr5gmpo 2sb20in80and160hr5ghpo "
-	"2sb40and80hr5ghpo 2sb20in40lrpo 2sb20in80and160lr5glpo 2sb40and80lr5glpo "
-	"2sb20in80and160lr5gmpo 2sb40and80lr5gmpo 2sb20in80and160lr5ghpo 2sb40and80lr5ghpo "
-	"2dot11agduphrpo 2dot11agduplrpo"},
-	{HNBU_NOISELVL,		0xfffff800, 16, "1noiselvl2ga0 1noiselvl2ga1 1noiselvl2ga2 "
-	"1*4noiselvl5ga0 1*4noiselvl5ga1 1*4noiselvl5ga2"},
-	{HNBU_RXGAIN_ERR,	0xfffff800, 16, "1rxgainerr2ga0 1rxgainerr2ga1 1rxgainerr2ga2 "
-	"1*4rxgainerr5ga0 1*4rxgainerr5ga1 1*4rxgainerr5ga2"},
-	{HNBU_AGBGA,		0xfffff800, 7, "1agbg0 1agbg1 1agbg2 1aga0 1aga1 1aga2"},
-	{HNBU_UUID, 		0xffffffff, 17,	"16uuid"},
-	{HNBU_WOWLGPIO,		0xffffffff, 2,  "1wowl_gpio"},
-	{HNBU_ACRXGAINS_C0,	0xfffff800, 5, "0rxgains5gtrelnabypa0 0rxgains5gtrisoa0 "
-	"0rxgains5gelnagaina0 0rxgains2gtrelnabypa0 0rxgains2gtrisoa0 0rxgains2gelnagaina0 "
-	"0rxgains5ghtrelnabypa0 0rxgains5ghtrisoa0 0rxgains5ghelnagaina0 0rxgains5gmtrelnabypa0 "
-	"0rxgains5gmtrisoa0 0rxgains5gmelnagaina0"},	/* special case */
-	{HNBU_ACRXGAINS_C1,	0xfffff800, 5, "0rxgains5gtrelnabypa1 0rxgains5gtrisoa1 "
-	"0rxgains5gelnagaina1 0rxgains2gtrelnabypa1 0rxgains2gtrisoa1 0rxgains2gelnagaina1 "
-	"0rxgains5ghtrelnabypa1 0rxgains5ghtrisoa1 0rxgains5ghelnagaina1 0rxgains5gmtrelnabypa1 "
-	"0rxgains5gmtrisoa1 0rxgains5gmelnagaina1"},	/* special case */
-	{HNBU_ACRXGAINS_C2,	0xfffff800, 5, "0rxgains5gtrelnabypa2 0rxgains5gtrisoa2 "
-	"0rxgains5gelnagaina2 0rxgains2gtrelnabypa2 0rxgains2gtrisoa2 0rxgains2gelnagaina2 "
-	"0rxgains5ghtrelnabypa2 0rxgains5ghtrisoa2 0rxgains5ghelnagaina2 0rxgains5gmtrelnabypa2 "
-	"0rxgains5gmtrisoa2 0rxgains5gmelnagaina2"},	/* special case */
-	{0xFF,			0xffffffff, 0, ""}
-};
-
-#endif /* _bcmsrom_tbl_h_ */
diff --git a/drivers/net/wireless/bcmdhd/include/bcmutils.h b/drivers/net/wireless/bcmdhd/include/bcmutils.h
old mode 100644
new mode 100755
index 29f8dd7..b80a6f5
--- a/drivers/net/wireless/bcmdhd/include/bcmutils.h
+++ b/drivers/net/wireless/bcmdhd/include/bcmutils.h
@@ -1,27 +1,9 @@
 /*
  * Misc useful os-independent macros and functions.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: bcmutils.h 328848 2012-04-21 00:43:57Z $
+ * $Id: bcmutils.h 382763 2013-02-04 10:21:08Z $
  */
 
 #ifndef	_bcmutils_h_
@@ -121,6 +103,8 @@ typedef struct {
 	uint32 max_avail;    
 	uint32 max_used;     
 	uint32 queue_capacity; 
+	uint32 rtsfail;        
+	uint32 acked;          
 } pktq_counters_t;
 #endif 
 
@@ -137,7 +121,9 @@ struct pktq {
 	
 	struct pktq_prec q[PKTQ_MAX_PREC];
 #ifdef PKTQ_LOG
-	pktq_counters_t	_prec_cnt[PKTQ_MAX_PREC];		
+	pktq_counters_t	_prec_cnt[PKTQ_MAX_PREC];     
+	pktq_counters_t _prec_bytes[PKTQ_MAX_PREC];   
+	uint32 _logtime;                   
 #endif
 };
 
@@ -155,11 +141,7 @@ typedef bool (*ifpkt_cb_t)(void*, int);
 
 #ifdef BCMPKTPOOL
 #define POOL_ENAB(pool)		((pool) && (pool)->inited)
-#if defined(BCM4329C0)
-#define SHARED_POOL		(pktpool_shared_ptr)
-#else
 #define SHARED_POOL		(pktpool_shared)
-#endif 
 #else 
 #define POOL_ENAB(bus)		0
 #define SHARED_POOL		((struct pktpool *)NULL)
@@ -231,11 +213,7 @@ typedef struct pktpool {
 #endif
 } pktpool_t;
 
-#if defined(BCM4329C0)
-extern pktpool_t *pktpool_shared_ptr;
-#else
 extern pktpool_t *pktpool_shared;
-#endif 
 
 extern int pktpool_init(osl_t *osh, pktpool_t *pktp, int *pktplen, int plen, bool istx);
 extern int pktpool_deinit(osl_t *osh, pktpool_t *pktp);
@@ -289,6 +267,7 @@ extern void *pktq_penq(struct pktq *pq, int prec, void *p);
 extern void *pktq_penq_head(struct pktq *pq, int prec, void *p);
 extern void *pktq_pdeq(struct pktq *pq, int prec);
 extern void *pktq_pdeq_prev(struct pktq *pq, int prec, void *prev_p);
+extern void *pktq_pdeq_with_fn(struct pktq *pq, int prec, ifpkt_cb_t fn, int arg);
 extern void *pktq_pdeq_tail(struct pktq *pq, int prec);
 
 extern void pktq_pflush(osl_t *osh, struct pktq *pq, int prec, bool dir,
@@ -335,7 +314,8 @@ extern uint pkttotlen(osl_t *osh, void *p);
 extern void *pktlast(osl_t *osh, void *p);
 extern uint pktsegcnt(osl_t *osh, void *p);
 extern uint pktsegcnt_war(osl_t *osh, void *p);
-extern uint8 *pktoffset(osl_t *osh, void *p,  uint offset);
+extern uint8 *pktdataoffset(osl_t *osh, void *p,  uint offset);
+extern void *pktoffset(osl_t *osh, void *p,  uint offset);
 
 
 #define	PKTPRIO_VDSCP	0x100		
@@ -507,7 +487,11 @@ extern int bcm_format_ssid(char* buf, const uchar ssid[], uint ssid_len);
 #define BCME_NODEVICE			-40 	
 #define BCME_NMODE_DISABLED		-41 	
 #define BCME_NONRESIDENT		-42 
-#define BCME_LAST			BCME_NONRESIDENT
+#define BCME_SCANREJECT			-43 	
+#define BCME_USAGE_ERROR                -44     
+#define BCME_IOCTL_ERROR                -45     
+#define BCME_SERIAL_PORT_ERR            -46     
+#define BCME_LAST			BCME_SERIAL_PORT_ERR
 
 
 #define BCMERRSTRINGTABLE {		\
@@ -554,6 +538,10 @@ extern int bcm_format_ssid(char* buf, const uchar ssid[], uint ssid_len);
 	"Device Not Present",		\
 	"NMODE Disabled",		\
 	"Nonresident overlay access", \
+	"Scan Rejected",		\
+	"WLCMD usage error",		\
+	"WLCMD ioctl error",		\
+	"RWL serial port error", 	\
 }
 
 #ifndef ABS
@@ -568,6 +556,24 @@ extern int bcm_format_ssid(char* buf, const uchar ssid[], uint ssid_len);
 #define	MAX(a, b)		(((a) > (b)) ? (a) : (b))
 #endif 
 
+
+#ifndef LIMIT_TO_RANGE
+#define LIMIT_TO_RANGE(x, min, max) \
+	((x) < (min) ? (min) : ((x) > (max) ? (max) : (x)))
+#endif 
+
+
+#ifndef LIMIT_TO_MAX
+#define LIMIT_TO_MAX(x, max) \
+	(((x) > (max) ? (max) : (x)))
+#endif 
+
+
+#ifndef LIMIT_TO_MIN
+#define LIMIT_TO_MIN(x, min) \
+	(((x) < (min) ? (min) : (x)))
+#endif 
+
 #define CEIL(x, y)		(((x) + ((y) - 1)) / (y))
 #define	ROUNDUP(x, y)		((((x) + ((y) - 1)) / (y)) * (y))
 #define	ISALIGNED(a, x)		(((uintptr)(a) & ((x) - 1)) == 0)
@@ -592,21 +598,34 @@ extern int bcm_format_ssid(char* buf, const uchar ssid[], uint ssid_len);
 #define ARRAYSIZE(a)		(sizeof(a) / sizeof(a[0]))
 #endif
 
+#ifndef ARRAYLAST         
+#define ARRAYLAST(a)		(&a[ARRAYSIZE(a)-1])
+#endif
+
 
 extern void *_bcmutils_dummy_fn;
 #define REFERENCE_FUNCTION(f)	(_bcmutils_dummy_fn = (void *)(f))
 
 
 #ifndef setbit
-#ifndef NBBY		      
+#ifndef NBBY		        
 #define	NBBY	8	
 #endif 
+#ifdef BCMUTILS_BIT_MACROS_USE_FUNCS
+extern void setbit(void *array, uint bit);
+extern void clrbit(void *array, uint bit);
+extern bool isset(const void *array, uint bit);
+extern bool isclr(const void *array, uint bit);
+#else
 #define	setbit(a, i)	(((uint8 *)a)[(i) / NBBY] |= 1 << ((i) % NBBY))
 #define	clrbit(a, i)	(((uint8 *)a)[(i) / NBBY] &= ~(1 << ((i) % NBBY)))
 #define	isset(a, i)	(((const uint8 *)a)[(i) / NBBY] & (1 << ((i) % NBBY)))
 #define	isclr(a, i)	((((const uint8 *)a)[(i) / NBBY] & (1 << ((i) % NBBY))) == 0)
+#endif
 #endif 
 
+#define	isbitset(a, i)	(((a) & (1 << (i))) != 0)
+
 #define	NBITS(type)	(sizeof(type) * 8)
 #define NBITVAL(nbits)	(1 << (nbits))
 #define MAXBITVAL(nbits)	((1 << (nbits)) - 1)
@@ -657,6 +676,13 @@ extern void *_bcmutils_dummy_fn;
 							(ea).octet[3], \
 							(ea).octet[4], \
 							(ea).octet[5]
+#if !defined(SIMPLE_MAC_PRINT)
+#define MACDBG "%02x:%02x:%02x:%02x:%02x:%02x"
+#define MAC2STRDBG(ea) (ea)[0], (ea)[1], (ea)[2], (ea)[3], (ea)[4], (ea)[5]
+#else
+#define MACDBG				"%02x:%02x:%02x"
+#define MAC2STRDBG(ea) (ea)[0], (ea)[4], (ea)[5]
+#endif 
 
 
 typedef struct bcm_bit_desc {
@@ -665,6 +691,13 @@ typedef struct bcm_bit_desc {
 } bcm_bit_desc_t;
 
 
+typedef struct bcm_bit_desc_ex {
+	uint32 mask;
+	const bcm_bit_desc_t *bitfield;
+} bcm_bit_desc_ex_t;
+
+
+
 typedef struct bcm_tlv {
 	uint8	id;
 	uint8	len;
@@ -710,6 +743,9 @@ extern uint32 hndcrc32(uint8 *p, uint nbytes, uint32 crc);
 
 #if defined(DHD_DEBUG) || defined(WLMSG_PRHDRS) || defined(WLMSG_PRPKT) || \
 	defined(WLMSG_ASSOC)
+
+extern int bcm_format_field(const bcm_bit_desc_ex_t *bd, uint32 field, char* buf, int len);
+
 extern int bcm_format_flags(const bcm_bit_desc_t *bd, uint32 flags, char* buf, int len);
 #endif
 
@@ -731,7 +767,7 @@ extern bcm_tlv_t *bcm_parse_ordered_tlvs(void *buf, int buflen, uint key);
 
 
 extern const char *bcmerrorstr(int bcmerror);
-extern bcm_tlv_t *bcm_parse_tlvs(void *buf, int buflen, uint key);
+
 
 
 typedef uint32 mbool;
@@ -767,6 +803,13 @@ extern uint8 bcm_mw_to_qdbm(uint16 mw);
 extern uint bcm_mkiovar(char *name, char *data, uint datalen, char *buf, uint len);
 
 unsigned int process_nvram_vars(char *varbuf, unsigned int len);
+extern bcm_tlv_t *find_vendor_ie(void *tlvs, int tlvs_len,
+	const char *voui, uint8 *type, int type_len);
+
+
+extern void bcm_uint64_multiple_add(uint32* r_high, uint32* r_low, uint32 a, uint32 b, uint32 c);
+
+extern void bcm_uint64_divide(uint32* r, uint32 a_high, uint32 a_low, uint32 b);
 
 #ifdef __cplusplus
 	}
diff --git a/drivers/net/wireless/bcmdhd/include/bcmwifi_channels.h b/drivers/net/wireless/bcmdhd/include/bcmwifi_channels.h
new file mode 100755
index 0000000..a5eb066
--- /dev/null
+++ b/drivers/net/wireless/bcmdhd/include/bcmwifi_channels.h
@@ -0,0 +1,340 @@
+/*
+ * Misc utility routines for WL and Apps
+ * This header file housing the define and function prototype use by
+ * both the wl driver, tools & Apps.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ * $Id: bcmwifi_channels.h 309193 2012-01-19 00:03:57Z $
+ */
+
+#ifndef	_bcmwifi_channels_h_
+#define	_bcmwifi_channels_h_
+
+
+
+typedef uint16 chanspec_t;
+
+
+#define CH_UPPER_SB			0x01
+#define CH_LOWER_SB			0x02
+#define CH_EWA_VALID			0x04
+#define CH_80MHZ_APART			16
+#define CH_40MHZ_APART			8
+#define CH_20MHZ_APART			4
+#define CH_10MHZ_APART			2
+#define CH_5MHZ_APART			1	
+#define CH_MAX_2G_CHANNEL		14	
+#define	MAXCHANNEL		224	
+#define CHSPEC_CTLOVLP(sp1, sp2, sep)	(ABS(wf_chspec_ctlchan(sp1) - wf_chspec_ctlchan(sp2)) < \
+				  (sep))
+
+
+#undef  D11AC_IOTYPES
+#define D11AC_IOTYPES
+
+#ifndef D11AC_IOTYPES
+
+#define WL_CHANSPEC_CHAN_MASK		0x00ff
+#define WL_CHANSPEC_CHAN_SHIFT		0
+
+#define WL_CHANSPEC_CTL_SB_MASK		0x0300
+#define WL_CHANSPEC_CTL_SB_SHIFT	     8
+#define WL_CHANSPEC_CTL_SB_LOWER	0x0100
+#define WL_CHANSPEC_CTL_SB_UPPER	0x0200
+#define WL_CHANSPEC_CTL_SB_NONE		0x0300
+
+#define WL_CHANSPEC_BW_MASK		0x0C00
+#define WL_CHANSPEC_BW_SHIFT		    10
+#define WL_CHANSPEC_BW_10		0x0400
+#define WL_CHANSPEC_BW_20		0x0800
+#define WL_CHANSPEC_BW_40		0x0C00
+
+#define WL_CHANSPEC_BAND_MASK		0xf000
+#define WL_CHANSPEC_BAND_SHIFT		12
+#ifdef WL_CHANSPEC_BAND_5G
+#undef WL_CHANSPEC_BAND_5G
+#endif
+#ifdef WL_CHANSPEC_BAND_2G
+#undef WL_CHANSPEC_BAND_2G
+#endif
+#define WL_CHANSPEC_BAND_5G		0x1000
+#define WL_CHANSPEC_BAND_2G		0x2000
+#define INVCHANSPEC			255
+
+
+#define LOWER_20_SB(channel)	(((channel) > CH_10MHZ_APART) ? ((channel) - CH_10MHZ_APART) : 0)
+#define UPPER_20_SB(channel)	(((channel) < (MAXCHANNEL - CH_10MHZ_APART)) ? \
+				((channel) + CH_10MHZ_APART) : 0)
+
+#define LL_20_SB(channel) (((channel) > 3 * CH_10MHZ_APART) ? ((channel) - 3 * CH_10MHZ_APART) : 0)
+#define UU_20_SB(channel) 	(((channel) < (MAXCHANNEL - 3 * CH_10MHZ_APART)) ? \
+				((channel) + 3 * CH_10MHZ_APART) : 0)
+#define LU_20_SB(channel) LOWER_20_SB(channel)
+#define UL_20_SB(channel) UPPER_20_SB(channel)
+
+#define CHSPEC_WLCBANDUNIT(chspec)	(CHSPEC_IS5G(chspec) ? BAND_5G_INDEX : BAND_2G_INDEX)
+#define CH20MHZ_CHSPEC(channel)	(chanspec_t)((chanspec_t)(channel) | WL_CHANSPEC_BW_20 | \
+				WL_CHANSPEC_CTL_SB_NONE | (((channel) <= CH_MAX_2G_CHANNEL) ? \
+				WL_CHANSPEC_BAND_2G : WL_CHANSPEC_BAND_5G))
+#define NEXT_20MHZ_CHAN(channel)	(((channel) < (MAXCHANNEL - CH_20MHZ_APART)) ? \
+					((channel) + CH_20MHZ_APART) : 0)
+#define CH40MHZ_CHSPEC(channel, ctlsb)	(chanspec_t) \
+					((channel) | (ctlsb) | WL_CHANSPEC_BW_40 | \
+					((channel) <= CH_MAX_2G_CHANNEL ? WL_CHANSPEC_BAND_2G : \
+					WL_CHANSPEC_BAND_5G))
+#define CHSPEC_CHANNEL(chspec)	((uint8)((chspec) & WL_CHANSPEC_CHAN_MASK))
+#define CHSPEC_BAND(chspec)	((chspec) & WL_CHANSPEC_BAND_MASK)
+
+
+#define CHSPEC_CTL_SB(chspec)	((chspec) & WL_CHANSPEC_CTL_SB_MASK)
+#define CHSPEC_BW(chspec)	((chspec) & WL_CHANSPEC_BW_MASK)
+
+#ifdef WL11N_20MHZONLY
+
+#define CHSPEC_IS10(chspec)	0
+#define CHSPEC_IS20(chspec)	1
+#ifndef CHSPEC_IS40
+#define CHSPEC_IS40(chspec)	0
+#endif
+
+#else 
+
+#define CHSPEC_IS10(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_10)
+#define CHSPEC_IS20(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_20)
+#ifndef CHSPEC_IS40
+#define CHSPEC_IS40(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_40)
+#endif
+
+#endif 
+
+#define CHSPEC_IS5G(chspec)	(((chspec) & WL_CHANSPEC_BAND_MASK) == WL_CHANSPEC_BAND_5G)
+#define CHSPEC_IS2G(chspec)	(((chspec) & WL_CHANSPEC_BAND_MASK) == WL_CHANSPEC_BAND_2G)
+#define CHSPEC_SB_NONE(chspec)	(((chspec) & WL_CHANSPEC_CTL_SB_MASK) == WL_CHANSPEC_CTL_SB_NONE)
+#define CHSPEC_SB_UPPER(chspec)	(((chspec) & WL_CHANSPEC_CTL_SB_MASK) == WL_CHANSPEC_CTL_SB_UPPER)
+#define CHSPEC_SB_LOWER(chspec)	(((chspec) & WL_CHANSPEC_CTL_SB_MASK) == WL_CHANSPEC_CTL_SB_LOWER)
+#define CHSPEC_CTL_CHAN(chspec)  ((CHSPEC_SB_LOWER(chspec)) ? \
+				  (LOWER_20_SB(((chspec) & WL_CHANSPEC_CHAN_MASK))) : \
+				  (UPPER_20_SB(((chspec) & WL_CHANSPEC_CHAN_MASK))))
+#define CHSPEC2WLC_BAND(chspec) (CHSPEC_IS5G(chspec) ? WLC_BAND_5G : WLC_BAND_2G)
+
+#define CHANSPEC_STR_LEN    8
+
+#else 
+
+#define WL_CHANSPEC_CHAN_MASK		0x00ff
+#define WL_CHANSPEC_CHAN_SHIFT		0
+#define WL_CHANSPEC_CHAN1_MASK		0x000f
+#define WL_CHANSPEC_CHAN1_SHIFT		0
+#define WL_CHANSPEC_CHAN2_MASK		0x00f0
+#define WL_CHANSPEC_CHAN2_SHIFT		4
+
+#define WL_CHANSPEC_CTL_SB_MASK		0x0700
+#define WL_CHANSPEC_CTL_SB_SHIFT	8
+#define WL_CHANSPEC_CTL_SB_LLL		0x0000
+#define WL_CHANSPEC_CTL_SB_LLU		0x0100
+#define WL_CHANSPEC_CTL_SB_LUL		0x0200
+#define WL_CHANSPEC_CTL_SB_LUU		0x0300
+#define WL_CHANSPEC_CTL_SB_ULL		0x0400
+#define WL_CHANSPEC_CTL_SB_ULU		0x0500
+#define WL_CHANSPEC_CTL_SB_UUL		0x0600
+#define WL_CHANSPEC_CTL_SB_UUU		0x0700
+#define WL_CHANSPEC_CTL_SB_LL		WL_CHANSPEC_CTL_SB_LLL
+#define WL_CHANSPEC_CTL_SB_LU		WL_CHANSPEC_CTL_SB_LLU
+#define WL_CHANSPEC_CTL_SB_UL		WL_CHANSPEC_CTL_SB_LUL
+#define WL_CHANSPEC_CTL_SB_UU		WL_CHANSPEC_CTL_SB_LUU
+#define WL_CHANSPEC_CTL_SB_L		WL_CHANSPEC_CTL_SB_LLL
+#define WL_CHANSPEC_CTL_SB_U		WL_CHANSPEC_CTL_SB_LLU
+#define WL_CHANSPEC_CTL_SB_LOWER 	WL_CHANSPEC_CTL_SB_LLL
+#define WL_CHANSPEC_CTL_SB_UPPER	WL_CHANSPEC_CTL_SB_LLU
+
+#define WL_CHANSPEC_BW_MASK		0x3800
+#define WL_CHANSPEC_BW_SHIFT		11
+#define WL_CHANSPEC_BW_5		0x0000
+#define WL_CHANSPEC_BW_10		0x0800
+#define WL_CHANSPEC_BW_20		0x1000
+#define WL_CHANSPEC_BW_40		0x1800
+#define WL_CHANSPEC_BW_80		0x2000
+#define WL_CHANSPEC_BW_160		0x2800
+#define WL_CHANSPEC_BW_8080		0x3000
+
+#define WL_CHANSPEC_BAND_MASK		0xc000
+#define WL_CHANSPEC_BAND_SHIFT		14
+#define WL_CHANSPEC_BAND_2G		0x0000
+#define WL_CHANSPEC_BAND_3G		0x4000
+#define WL_CHANSPEC_BAND_4G		0x8000
+#define WL_CHANSPEC_BAND_5G		0xc000
+#define INVCHANSPEC			255
+
+
+#define LOWER_20_SB(channel)		(((channel) > CH_10MHZ_APART) ? \
+					((channel) - CH_10MHZ_APART) : 0)
+#define UPPER_20_SB(channel)		(((channel) < (MAXCHANNEL - CH_10MHZ_APART)) ? \
+					((channel) + CH_10MHZ_APART) : 0)
+
+#define LL_20_SB(channel) (((channel) > 3 * CH_10MHZ_APART) ? ((channel) - 3 * CH_10MHZ_APART) : 0)
+#define UU_20_SB(channel) 	(((channel) < (MAXCHANNEL - 3 * CH_10MHZ_APART)) ? \
+				((channel) + 3 * CH_10MHZ_APART) : 0)
+#define LU_20_SB(channel) LOWER_20_SB(channel)
+#define UL_20_SB(channel) UPPER_20_SB(channel)
+
+#define LOWER_40_SB(channel)		((channel) - CH_20MHZ_APART)
+#define UPPER_40_SB(channel)		((channel) + CH_20MHZ_APART)
+#define CHSPEC_WLCBANDUNIT(chspec)	(CHSPEC_IS5G(chspec) ? BAND_5G_INDEX : BAND_2G_INDEX)
+#define CH20MHZ_CHSPEC(channel)		(chanspec_t)((chanspec_t)(channel) | WL_CHANSPEC_BW_20 | \
+					(((channel) <= CH_MAX_2G_CHANNEL) ? \
+					WL_CHANSPEC_BAND_2G : WL_CHANSPEC_BAND_5G))
+#define NEXT_20MHZ_CHAN(channel)	(((channel) < (MAXCHANNEL - CH_20MHZ_APART)) ? \
+					((channel) + CH_20MHZ_APART) : 0)
+#define CH40MHZ_CHSPEC(channel, ctlsb)	(chanspec_t) \
+					((channel) | (ctlsb) | WL_CHANSPEC_BW_40 | \
+					((channel) <= CH_MAX_2G_CHANNEL ? WL_CHANSPEC_BAND_2G : \
+					WL_CHANSPEC_BAND_5G))
+#define CH80MHZ_CHSPEC(channel, ctlsb)	(chanspec_t) \
+					((channel) | (ctlsb) | \
+					 WL_CHANSPEC_BW_80 | WL_CHANSPEC_BAND_5G)
+#define CH160MHZ_CHSPEC(channel, ctlsb)	(chanspec_t) \
+					((channel) | (ctlsb) | \
+					 WL_CHANSPEC_BW_160 | WL_CHANSPEC_BAND_5G)
+
+
+#define CHSPEC_CHANNEL(chspec)		((uint8)((chspec) & WL_CHANSPEC_CHAN_MASK))
+#define CHSPEC_CHAN1(chspec)		((chspec) & WL_CHANSPEC_CHAN1_MASK)
+#define CHSPEC_CHAN2(chspec)		((chspec) & WL_CHANSPEC_CHAN2_MASK)
+#define CHSPEC_BAND(chspec)		((chspec) & WL_CHANSPEC_BAND_MASK)
+#define CHSPEC_CTL_SB(chspec)		((chspec) & WL_CHANSPEC_CTL_SB_MASK)
+#define CHSPEC_BW(chspec)		((chspec) & WL_CHANSPEC_BW_MASK)
+
+#ifdef WL11N_20MHZONLY
+
+#define CHSPEC_IS10(chspec)	0
+#define CHSPEC_IS20(chspec)	1
+#ifndef CHSPEC_IS40
+#define CHSPEC_IS40(chspec)	0
+#endif
+#ifndef CHSPEC_IS80
+#define CHSPEC_IS80(chspec)	0
+#endif
+#ifndef CHSPEC_IS160
+#define CHSPEC_IS160(chspec)	0
+#endif
+#ifndef CHSPEC_IS8080
+#define CHSPEC_IS8080(chspec)	0
+#endif
+
+#else 
+
+#define CHSPEC_IS10(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_10)
+#define CHSPEC_IS20(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_20)
+#ifndef CHSPEC_IS40
+#define CHSPEC_IS40(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_40)
+#endif
+#ifndef CHSPEC_IS80
+#define CHSPEC_IS80(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_80)
+#endif
+#ifndef CHSPEC_IS160
+#define CHSPEC_IS160(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_160)
+#endif
+#ifndef CHSPEC_IS8080
+#define CHSPEC_IS8080(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_8080)
+#endif
+
+#endif 
+
+#define CHSPEC_IS5G(chspec)	(((chspec) & WL_CHANSPEC_BAND_MASK) == WL_CHANSPEC_BAND_5G)
+#define CHSPEC_IS2G(chspec)	(((chspec) & WL_CHANSPEC_BAND_MASK) == WL_CHANSPEC_BAND_2G)
+#define CHSPEC_SB_UPPER(chspec)	\
+	((((chspec) & WL_CHANSPEC_CTL_SB_MASK) == WL_CHANSPEC_CTL_SB_UPPER) && \
+	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_40))
+#define CHSPEC_SB_LOWER(chspec)	\
+	((((chspec) & WL_CHANSPEC_CTL_SB_MASK) == WL_CHANSPEC_CTL_SB_LOWER) && \
+	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_40))
+#define CHSPEC2WLC_BAND(chspec) (CHSPEC_IS5G(chspec) ? WLC_BAND_5G : WLC_BAND_2G)
+
+
+#define CHANSPEC_STR_LEN    20
+
+
+
+#define WL_LCHANSPEC_CHAN_MASK		0x00ff
+#define WL_LCHANSPEC_CHAN_SHIFT		     0
+
+#define WL_LCHANSPEC_CTL_SB_MASK	0x0300
+#define WL_LCHANSPEC_CTL_SB_SHIFT	     8
+#define WL_LCHANSPEC_CTL_SB_LOWER	0x0100
+#define WL_LCHANSPEC_CTL_SB_UPPER	0x0200
+#define WL_LCHANSPEC_CTL_SB_NONE	0x0300
+
+#define WL_LCHANSPEC_BW_MASK		0x0C00
+#define WL_LCHANSPEC_BW_SHIFT		    10
+#define WL_LCHANSPEC_BW_10		0x0400
+#define WL_LCHANSPEC_BW_20		0x0800
+#define WL_LCHANSPEC_BW_40		0x0C00
+
+#define WL_LCHANSPEC_BAND_MASK		0xf000
+#define WL_LCHANSPEC_BAND_SHIFT		    12
+#define WL_LCHANSPEC_BAND_5G		0x1000
+#define WL_LCHANSPEC_BAND_2G		0x2000
+
+#define LCHSPEC_CHANNEL(chspec)	((uint8)((chspec) & WL_LCHANSPEC_CHAN_MASK))
+#define LCHSPEC_BAND(chspec)	((chspec) & WL_LCHANSPEC_BAND_MASK)
+#define LCHSPEC_CTL_SB(chspec)	((chspec) & WL_LCHANSPEC_CTL_SB_MASK)
+#define LCHSPEC_BW(chspec)	((chspec) & WL_LCHANSPEC_BW_MASK)
+#define LCHSPEC_IS10(chspec)	(((chspec) & WL_LCHANSPEC_BW_MASK) == WL_LCHANSPEC_BW_10)
+#define LCHSPEC_IS20(chspec)	(((chspec) & WL_LCHANSPEC_BW_MASK) == WL_LCHANSPEC_BW_20)
+#define LCHSPEC_IS40(chspec)	(((chspec) & WL_LCHANSPEC_BW_MASK) == WL_LCHANSPEC_BW_40)
+#define LCHSPEC_IS5G(chspec)	(((chspec) & WL_LCHANSPEC_BAND_MASK) == WL_LCHANSPEC_BAND_5G)
+#define LCHSPEC_IS2G(chspec)	(((chspec) & WL_LCHANSPEC_BAND_MASK) == WL_LCHANSPEC_BAND_2G)
+
+#define LCHSPEC_CREATE(chan, band, bw, sb)  ((uint16)((chan) | (sb) | (bw) | (band)))
+
+#endif 
+
+
+
+
+#define WF_CHAN_FACTOR_2_4_G		4814	
+
+
+#define WF_CHAN_FACTOR_5_G		10000	
+
+
+#define WF_CHAN_FACTOR_4_G		8000	
+
+#define WLC_2G_25MHZ_OFFSET		5	
+
+
+extern char * wf_chspec_ntoa(chanspec_t chspec, char *buf);
+
+
+extern chanspec_t wf_chspec_aton(const char *a);
+
+
+extern bool wf_chspec_malformed(chanspec_t chanspec);
+
+
+extern bool wf_chspec_valid(chanspec_t chanspec);
+
+
+extern uint8 wf_chspec_ctlchan(chanspec_t chspec);
+
+
+extern chanspec_t wf_chspec_ctlchspec(chanspec_t chspec);
+
+
+extern chanspec_t wf_chspec_primary40_chspec(chanspec_t chspec);
+
+
+extern int wf_mhz2channel(uint freq, uint start_factor);
+
+
+extern int wf_channel2mhz(uint channel, uint start_factor);
+
+
+extern uint16 wf_channel2chspec(uint ctl_ch, uint bw);
+
+extern uint wf_channel2freq(uint channel);
+extern uint wf_freq2channel(uint freq);
+
+
+#endif	
diff --git a/drivers/net/wireless/bcmdhd/include/bcmwifi_rates.h b/drivers/net/wireless/bcmdhd/include/bcmwifi_rates.h
new file mode 100755
index 0000000..7b824f9
--- /dev/null
+++ b/drivers/net/wireless/bcmdhd/include/bcmwifi_rates.h
@@ -0,0 +1,417 @@
+/*
+ * Indices for 802.11 a/b/g/n/ac 1-3 chain symmetric transmit rates
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ * $Id: bcmwifi_rates.h 5187 2012-06-29 06:17:50Z $
+ */
+
+#ifndef _bcmwifi_rates_h_
+#define _bcmwifi_rates_h_
+
+#ifdef __cplusplus
+extern "C" {
+#endif 
+
+
+#define WL_RATESET_SZ_DSSS		4
+#define WL_RATESET_SZ_OFDM		8
+#define WL_RATESET_SZ_HT_MCS	8
+#define WL_RATESET_SZ_VHT_MCS	10
+
+#define WL_TX_CHAINS_MAX	3
+
+#define WL_RATE_DISABLED		(-128) 
+
+
+typedef enum wl_tx_bw {
+	WL_TX_BW_20,
+	WL_TX_BW_40,
+	WL_TX_BW_80,
+	WL_TX_BW_20IN40,
+	WL_TX_BW_20IN80,
+	WL_TX_BW_40IN80
+} wl_tx_bw_t;
+
+
+
+typedef enum wl_tx_mode {
+	WL_TX_MODE_NONE,
+	WL_TX_MODE_STBC,
+	WL_TX_MODE_CDD,
+	WL_TX_MODE_TXBF,
+	WL_NUM_TX_MODES
+} wl_tx_mode_t;
+
+
+
+typedef enum wl_tx_chains {
+	WL_TX_CHAINS_1 = 1,
+	WL_TX_CHAINS_2,
+	WL_TX_CHAINS_3
+} wl_tx_chains_t;
+
+
+
+typedef enum wl_tx_nss {
+	WL_TX_NSS_1 = 1,
+	WL_TX_NSS_2,
+	WL_TX_NSS_3
+} wl_tx_nss_t;
+
+
+typedef enum clm_rates {
+	
+
+	
+	WL_RATE_1X1_DSSS_1         = 0,
+	WL_RATE_1X1_DSSS_2         = 1,
+	WL_RATE_1X1_DSSS_5_5       = 2,
+	WL_RATE_1X1_DSSS_11        = 3,
+
+	WL_RATE_1X1_OFDM_6         = 4,
+	WL_RATE_1X1_OFDM_9         = 5,
+	WL_RATE_1X1_OFDM_12        = 6,
+	WL_RATE_1X1_OFDM_18        = 7,
+	WL_RATE_1X1_OFDM_24        = 8,
+	WL_RATE_1X1_OFDM_36        = 9,
+	WL_RATE_1X1_OFDM_48        = 10,
+	WL_RATE_1X1_OFDM_54        = 11,
+
+	WL_RATE_1X1_MCS0           = 12,
+	WL_RATE_1X1_MCS1           = 13,
+	WL_RATE_1X1_MCS2           = 14,
+	WL_RATE_1X1_MCS3           = 15,
+	WL_RATE_1X1_MCS4           = 16,
+	WL_RATE_1X1_MCS5           = 17,
+	WL_RATE_1X1_MCS6           = 18,
+	WL_RATE_1X1_MCS7           = 19,
+
+	WL_RATE_1X1_VHT0SS1        = 12,
+	WL_RATE_1X1_VHT1SS1        = 13,
+	WL_RATE_1X1_VHT2SS1        = 14,
+	WL_RATE_1X1_VHT3SS1        = 15,
+	WL_RATE_1X1_VHT4SS1        = 16,
+	WL_RATE_1X1_VHT5SS1        = 17,
+	WL_RATE_1X1_VHT6SS1        = 18,
+	WL_RATE_1X1_VHT7SS1        = 19,
+	WL_RATE_1X1_VHT8SS1        = 20,
+	WL_RATE_1X1_VHT9SS1        = 21,
+
+
+	
+
+	
+	WL_RATE_1X2_DSSS_1         = 22,
+	WL_RATE_1X2_DSSS_2         = 23,
+	WL_RATE_1X2_DSSS_5_5       = 24,
+	WL_RATE_1X2_DSSS_11        = 25,
+
+	WL_RATE_1X2_CDD_OFDM_6     = 26,
+	WL_RATE_1X2_CDD_OFDM_9     = 27,
+	WL_RATE_1X2_CDD_OFDM_12    = 28,
+	WL_RATE_1X2_CDD_OFDM_18    = 29,
+	WL_RATE_1X2_CDD_OFDM_24    = 30,
+	WL_RATE_1X2_CDD_OFDM_36    = 31,
+	WL_RATE_1X2_CDD_OFDM_48    = 32,
+	WL_RATE_1X2_CDD_OFDM_54    = 33,
+
+	WL_RATE_1X2_CDD_MCS0       = 34,
+	WL_RATE_1X2_CDD_MCS1       = 35,
+	WL_RATE_1X2_CDD_MCS2       = 36,
+	WL_RATE_1X2_CDD_MCS3       = 37,
+	WL_RATE_1X2_CDD_MCS4       = 38,
+	WL_RATE_1X2_CDD_MCS5       = 39,
+	WL_RATE_1X2_CDD_MCS6       = 40,
+	WL_RATE_1X2_CDD_MCS7       = 41,
+
+	WL_RATE_1X2_VHT0SS1        = 34,
+	WL_RATE_1X2_VHT1SS1        = 35,
+	WL_RATE_1X2_VHT2SS1        = 36,
+	WL_RATE_1X2_VHT3SS1        = 37,
+	WL_RATE_1X2_VHT4SS1        = 38,
+	WL_RATE_1X2_VHT5SS1        = 39,
+	WL_RATE_1X2_VHT6SS1        = 40,
+	WL_RATE_1X2_VHT7SS1        = 41,
+	WL_RATE_1X2_VHT8SS1        = 42,
+	WL_RATE_1X2_VHT9SS1        = 43,
+
+	
+	WL_RATE_2X2_STBC_MCS0      = 44,
+	WL_RATE_2X2_STBC_MCS1      = 45,
+	WL_RATE_2X2_STBC_MCS2      = 46,
+	WL_RATE_2X2_STBC_MCS3      = 47,
+	WL_RATE_2X2_STBC_MCS4      = 48,
+	WL_RATE_2X2_STBC_MCS5      = 49,
+	WL_RATE_2X2_STBC_MCS6      = 50,
+	WL_RATE_2X2_STBC_MCS7      = 51,
+
+	WL_RATE_2X2_STBC_VHT0SS1   = 44,
+	WL_RATE_2X2_STBC_VHT1SS1   = 45,
+	WL_RATE_2X2_STBC_VHT2SS1   = 46,
+	WL_RATE_2X2_STBC_VHT3SS1   = 47,
+	WL_RATE_2X2_STBC_VHT4SS1   = 48,
+	WL_RATE_2X2_STBC_VHT5SS1   = 49,
+	WL_RATE_2X2_STBC_VHT6SS1   = 50,
+	WL_RATE_2X2_STBC_VHT7SS1   = 51,
+	WL_RATE_2X2_STBC_VHT8SS1   = 52,
+	WL_RATE_2X2_STBC_VHT9SS1   = 53,
+
+	WL_RATE_2X2_SDM_MCS8       = 54,
+	WL_RATE_2X2_SDM_MCS9       = 55,
+	WL_RATE_2X2_SDM_MCS10      = 56,
+	WL_RATE_2X2_SDM_MCS11      = 57,
+	WL_RATE_2X2_SDM_MCS12      = 58,
+	WL_RATE_2X2_SDM_MCS13      = 59,
+	WL_RATE_2X2_SDM_MCS14      = 60,
+	WL_RATE_2X2_SDM_MCS15      = 61,
+
+	WL_RATE_2X2_VHT0SS2        = 54,
+	WL_RATE_2X2_VHT1SS2        = 55,
+	WL_RATE_2X2_VHT2SS2        = 56,
+	WL_RATE_2X2_VHT3SS2        = 57,
+	WL_RATE_2X2_VHT4SS2        = 58,
+	WL_RATE_2X2_VHT5SS2        = 59,
+	WL_RATE_2X2_VHT6SS2        = 60,
+	WL_RATE_2X2_VHT7SS2        = 61,
+	WL_RATE_2X2_VHT8SS2        = 62,
+	WL_RATE_2X2_VHT9SS2        = 63,
+
+	
+
+	
+	WL_RATE_1X3_DSSS_1         = 64,
+	WL_RATE_1X3_DSSS_2         = 65,
+	WL_RATE_1X3_DSSS_5_5       = 66,
+	WL_RATE_1X3_DSSS_11        = 67,
+
+	WL_RATE_1X3_CDD_OFDM_6     = 68,
+	WL_RATE_1X3_CDD_OFDM_9     = 69,
+	WL_RATE_1X3_CDD_OFDM_12    = 70,
+	WL_RATE_1X3_CDD_OFDM_18    = 71,
+	WL_RATE_1X3_CDD_OFDM_24    = 72,
+	WL_RATE_1X3_CDD_OFDM_36    = 73,
+	WL_RATE_1X3_CDD_OFDM_48    = 74,
+	WL_RATE_1X3_CDD_OFDM_54    = 75,
+
+	WL_RATE_1X3_CDD_MCS0       = 76,
+	WL_RATE_1X3_CDD_MCS1       = 77,
+	WL_RATE_1X3_CDD_MCS2       = 78,
+	WL_RATE_1X3_CDD_MCS3       = 79,
+	WL_RATE_1X3_CDD_MCS4       = 80,
+	WL_RATE_1X3_CDD_MCS5       = 81,
+	WL_RATE_1X3_CDD_MCS6       = 82,
+	WL_RATE_1X3_CDD_MCS7       = 83,
+
+	WL_RATE_1X3_VHT0SS1        = 76,
+	WL_RATE_1X3_VHT1SS1        = 77,
+	WL_RATE_1X3_VHT2SS1        = 78,
+	WL_RATE_1X3_VHT3SS1        = 79,
+	WL_RATE_1X3_VHT4SS1        = 80,
+	WL_RATE_1X3_VHT5SS1        = 81,
+	WL_RATE_1X3_VHT6SS1        = 82,
+	WL_RATE_1X3_VHT7SS1        = 83,
+	WL_RATE_1X3_VHT8SS1        = 84,
+	WL_RATE_1X3_VHT9SS1        = 85,
+
+	
+	WL_RATE_2X3_STBC_MCS0      = 86,
+	WL_RATE_2X3_STBC_MCS1      = 87,
+	WL_RATE_2X3_STBC_MCS2      = 88,
+	WL_RATE_2X3_STBC_MCS3      = 89,
+	WL_RATE_2X3_STBC_MCS4      = 90,
+	WL_RATE_2X3_STBC_MCS5      = 91,
+	WL_RATE_2X3_STBC_MCS6      = 92,
+	WL_RATE_2X3_STBC_MCS7      = 93,
+
+	WL_RATE_2X3_STBC_VHT0SS1   = 86,
+	WL_RATE_2X3_STBC_VHT1SS1   = 87,
+	WL_RATE_2X3_STBC_VHT2SS1   = 88,
+	WL_RATE_2X3_STBC_VHT3SS1   = 89,
+	WL_RATE_2X3_STBC_VHT4SS1   = 90,
+	WL_RATE_2X3_STBC_VHT5SS1   = 91,
+	WL_RATE_2X3_STBC_VHT6SS1   = 92,
+	WL_RATE_2X3_STBC_VHT7SS1   = 93,
+	WL_RATE_2X3_STBC_VHT8SS1   = 94,
+	WL_RATE_2X3_STBC_VHT9SS1   = 95,
+
+	WL_RATE_2X3_SDM_MCS8       = 96,
+	WL_RATE_2X3_SDM_MCS9       = 97,
+	WL_RATE_2X3_SDM_MCS10      = 98,
+	WL_RATE_2X3_SDM_MCS11      = 99,
+	WL_RATE_2X3_SDM_MCS12      = 100,
+	WL_RATE_2X3_SDM_MCS13      = 101,
+	WL_RATE_2X3_SDM_MCS14      = 102,
+	WL_RATE_2X3_SDM_MCS15      = 103,
+
+	WL_RATE_2X3_VHT0SS2        = 96,
+	WL_RATE_2X3_VHT1SS2        = 97,
+	WL_RATE_2X3_VHT2SS2        = 98,
+	WL_RATE_2X3_VHT3SS2        = 99,
+	WL_RATE_2X3_VHT4SS2        = 100,
+	WL_RATE_2X3_VHT5SS2        = 101,
+	WL_RATE_2X3_VHT6SS2        = 102,
+	WL_RATE_2X3_VHT7SS2        = 103,
+	WL_RATE_2X3_VHT8SS2        = 104,
+	WL_RATE_2X3_VHT9SS2        = 105,
+
+	
+	WL_RATE_3X3_SDM_MCS16      = 106,
+	WL_RATE_3X3_SDM_MCS17      = 107,
+	WL_RATE_3X3_SDM_MCS18      = 108,
+	WL_RATE_3X3_SDM_MCS19      = 109,
+	WL_RATE_3X3_SDM_MCS20      = 110,
+	WL_RATE_3X3_SDM_MCS21      = 111,
+	WL_RATE_3X3_SDM_MCS22      = 112,
+	WL_RATE_3X3_SDM_MCS23      = 113,
+
+	WL_RATE_3X3_VHT0SS3        = 106,
+	WL_RATE_3X3_VHT1SS3        = 107,
+	WL_RATE_3X3_VHT2SS3        = 108,
+	WL_RATE_3X3_VHT3SS3        = 109,
+	WL_RATE_3X3_VHT4SS3        = 110,
+	WL_RATE_3X3_VHT5SS3        = 111,
+	WL_RATE_3X3_VHT6SS3        = 112,
+	WL_RATE_3X3_VHT7SS3        = 113,
+	WL_RATE_3X3_VHT8SS3        = 114,
+	WL_RATE_3X3_VHT9SS3        = 115,
+
+
+	
+
+	
+
+	WL_RATE_1X2_TXBF_OFDM_6    = 116,
+	WL_RATE_1X2_TXBF_OFDM_9    = 117,
+	WL_RATE_1X2_TXBF_OFDM_12   = 118,
+	WL_RATE_1X2_TXBF_OFDM_18   = 119,
+	WL_RATE_1X2_TXBF_OFDM_24   = 120,
+	WL_RATE_1X2_TXBF_OFDM_36   = 121,
+	WL_RATE_1X2_TXBF_OFDM_48   = 122,
+	WL_RATE_1X2_TXBF_OFDM_54   = 123,
+
+	WL_RATE_1X2_TXBF_MCS0      = 124,
+	WL_RATE_1X2_TXBF_MCS1      = 125,
+	WL_RATE_1X2_TXBF_MCS2      = 126,
+	WL_RATE_1X2_TXBF_MCS3      = 127,
+	WL_RATE_1X2_TXBF_MCS4      = 128,
+	WL_RATE_1X2_TXBF_MCS5      = 129,
+	WL_RATE_1X2_TXBF_MCS6      = 130,
+	WL_RATE_1X2_TXBF_MCS7      = 131,
+
+	WL_RATE_1X2_TXBF_VHT0SS1   = 124,
+	WL_RATE_1X2_TXBF_VHT1SS1   = 125,
+	WL_RATE_1X2_TXBF_VHT2SS1   = 126,
+	WL_RATE_1X2_TXBF_VHT3SS1   = 127,
+	WL_RATE_1X2_TXBF_VHT4SS1   = 128,
+	WL_RATE_1X2_TXBF_VHT5SS1   = 129,
+	WL_RATE_1X2_TXBF_VHT6SS1   = 130,
+	WL_RATE_1X2_TXBF_VHT7SS1   = 131,
+	WL_RATE_1X2_TXBF_VHT8SS1   = 132,
+	WL_RATE_1X2_TXBF_VHT9SS1   = 133,
+
+	
+
+	WL_RATE_2X2_TXBF_SDM_MCS8  = 134,
+	WL_RATE_2X2_TXBF_SDM_MCS9  = 135,
+	WL_RATE_2X2_TXBF_SDM_MCS10 = 136,
+	WL_RATE_2X2_TXBF_SDM_MCS11 = 137,
+	WL_RATE_2X2_TXBF_SDM_MCS12 = 138,
+	WL_RATE_2X2_TXBF_SDM_MCS13 = 139,
+	WL_RATE_2X2_TXBF_SDM_MCS14 = 140,
+	WL_RATE_2X2_TXBF_SDM_MCS15 = 141,
+
+	WL_RATE_2X2_TXBF_VHT0SS2   = 134,
+	WL_RATE_2X2_TXBF_VHT1SS2   = 135,
+	WL_RATE_2X2_TXBF_VHT2SS2   = 136,
+	WL_RATE_2X2_TXBF_VHT3SS2   = 137,
+	WL_RATE_2X2_TXBF_VHT4SS2   = 138,
+	WL_RATE_2X2_TXBF_VHT5SS2   = 139,
+	WL_RATE_2X2_TXBF_VHT6SS2   = 140,
+	WL_RATE_2X2_TXBF_VHT7SS2   = 141,
+
+
+	
+
+	
+
+	WL_RATE_1X3_TXBF_OFDM_6    = 142,
+	WL_RATE_1X3_TXBF_OFDM_9    = 143,
+	WL_RATE_1X3_TXBF_OFDM_12   = 144,
+	WL_RATE_1X3_TXBF_OFDM_18   = 145,
+	WL_RATE_1X3_TXBF_OFDM_24   = 146,
+	WL_RATE_1X3_TXBF_OFDM_36   = 147,
+	WL_RATE_1X3_TXBF_OFDM_48   = 148,
+	WL_RATE_1X3_TXBF_OFDM_54   = 149,
+
+	WL_RATE_1X3_TXBF_MCS0      = 150,
+	WL_RATE_1X3_TXBF_MCS1      = 151,
+	WL_RATE_1X3_TXBF_MCS2      = 152,
+	WL_RATE_1X3_TXBF_MCS3      = 153,
+	WL_RATE_1X3_TXBF_MCS4      = 154,
+	WL_RATE_1X3_TXBF_MCS5      = 155,
+	WL_RATE_1X3_TXBF_MCS6      = 156,
+	WL_RATE_1X3_TXBF_MCS7      = 157,
+
+	WL_RATE_1X3_TXBF_VHT0SS1   = 150,
+	WL_RATE_1X3_TXBF_VHT1SS1   = 151,
+	WL_RATE_1X3_TXBF_VHT2SS1   = 152,
+	WL_RATE_1X3_TXBF_VHT3SS1   = 153,
+	WL_RATE_1X3_TXBF_VHT4SS1   = 154,
+	WL_RATE_1X3_TXBF_VHT5SS1   = 155,
+	WL_RATE_1X3_TXBF_VHT6SS1   = 156,
+	WL_RATE_1X3_TXBF_VHT7SS1   = 157,
+	WL_RATE_1X3_TXBF_VHT8SS1   = 158,
+	WL_RATE_1X3_TXBF_VHT9SS1   = 159,
+
+	
+
+	WL_RATE_2X3_TXBF_SDM_MCS8  = 160,
+	WL_RATE_2X3_TXBF_SDM_MCS9  = 161,
+	WL_RATE_2X3_TXBF_SDM_MCS10 = 162,
+	WL_RATE_2X3_TXBF_SDM_MCS11 = 163,
+	WL_RATE_2X3_TXBF_SDM_MCS12 = 164,
+	WL_RATE_2X3_TXBF_SDM_MCS13 = 165,
+	WL_RATE_2X3_TXBF_SDM_MCS14 = 166,
+	WL_RATE_2X3_TXBF_SDM_MCS15 = 167,
+
+	WL_RATE_2X3_TXBF_VHT0SS2   = 160,
+	WL_RATE_2X3_TXBF_VHT1SS2   = 161,
+	WL_RATE_2X3_TXBF_VHT2SS2   = 162,
+	WL_RATE_2X3_TXBF_VHT3SS2   = 163,
+	WL_RATE_2X3_TXBF_VHT4SS2   = 164,
+	WL_RATE_2X3_TXBF_VHT5SS2   = 165,
+	WL_RATE_2X3_TXBF_VHT6SS2   = 166,
+	WL_RATE_2X3_TXBF_VHT7SS2   = 167,
+	WL_RATE_2X3_TXBF_VHT8SS2   = 168,
+	WL_RATE_2X3_TXBF_VHT9SS2   = 169,
+
+	
+
+	WL_RATE_3X3_TXBF_SDM_MCS16 = 170,
+	WL_RATE_3X3_TXBF_SDM_MCS17 = 171,
+	WL_RATE_3X3_TXBF_SDM_MCS18 = 172,
+	WL_RATE_3X3_TXBF_SDM_MCS19 = 173,
+	WL_RATE_3X3_TXBF_SDM_MCS20 = 174,
+	WL_RATE_3X3_TXBF_SDM_MCS21 = 175,
+	WL_RATE_3X3_TXBF_SDM_MCS22 = 176,
+	WL_RATE_3X3_TXBF_SDM_MCS23 = 177,
+
+	WL_RATE_3X3_TXBF_VHT0SS3   = 170,
+	WL_RATE_3X3_TXBF_VHT1SS3   = 171,
+	WL_RATE_3X3_TXBF_VHT2SS3   = 172,
+	WL_RATE_3X3_TXBF_VHT3SS3   = 173,
+	WL_RATE_3X3_TXBF_VHT4SS3   = 174,
+	WL_RATE_3X3_TXBF_VHT5SS3   = 175,
+	WL_RATE_3X3_TXBF_VHT6SS3   = 176,
+	WL_RATE_3X3_TXBF_VHT7SS3   = 177
+} clm_rates_t;
+
+
+#define WL_NUMRATES 178
+
+#ifdef __cplusplus
+}
+#endif 
+
+#endif 
diff --git a/drivers/net/wireless/bcmdhd/include/dbus.h b/drivers/net/wireless/bcmdhd/include/dbus.h
deleted file mode 100644
index c5ea223..0000000
--- a/drivers/net/wireless/bcmdhd/include/dbus.h
+++ /dev/null
@@ -1,571 +0,0 @@
-/*
- * Dongle BUS interface Abstraction layer
- *   target serial buses like USB, SDIO, SPI, etc.
- *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
- *
- * $Id: dbus.h 323680 2012-03-26 17:52:31Z $
- */
-
-#ifndef __DBUS_H__
-#define __DBUS_H__
-
-#include "typedefs.h"
-
-#define DBUSTRACE(args)
-#define DBUSERR(args)
-#define DBUSINFO(args)
-#define DBUSTRACE(args)
-#define DBUSDBGLOCK(args)
-
-enum {
-	DBUS_OK = 0,
-	DBUS_ERR = -200,
-	DBUS_ERR_TIMEOUT,
-	DBUS_ERR_DISCONNECT,
-	DBUS_ERR_NODEVICE,
-	DBUS_ERR_UNSUPPORTED,
-	DBUS_ERR_PENDING,
-	DBUS_ERR_NOMEM,
-	DBUS_ERR_TXFAIL,
-	DBUS_ERR_TXTIMEOUT,
-	DBUS_ERR_TXDROP,
-	DBUS_ERR_RXFAIL,
-	DBUS_ERR_RXDROP,
-	DBUS_ERR_TXCTLFAIL,
-	DBUS_ERR_RXCTLFAIL,
-	DBUS_ERR_REG_PARAM,
-	DBUS_STATUS_CANCELLED,
-	DBUS_ERR_NVRAM,
-	DBUS_JUMBO_NOMATCH,
-	DBUS_JUMBO_BAD_FORMAT,
-	DBUS_NVRAM_NONTXT
-};
-
-#define BCM_OTP_SIZE_43236  84	/* number of 16 bit values */
-#define BCM_OTP_SW_RGN_43236	24  /* start offset of SW config region */
-#define BCM_OTP_ADDR_43236 0x18000800 /* address of otp base */
-
-#define ERR_CBMASK_TXFAIL		0x00000001
-#define ERR_CBMASK_RXFAIL		0x00000002
-#define ERR_CBMASK_ALL			0xFFFFFFFF
-
-#define DBUS_CBCTL_WRITE			0
-#define DBUS_CBCTL_READ				1
-#if defined(INTR_EP_ENABLE)
-#define DBUS_CBINTR_POLL			2
-#endif /* defined(INTR_EP_ENABLE) */
-
-#define DBUS_TX_RETRY_LIMIT		3		/* retries for failed txirb */
-#define DBUS_TX_TIMEOUT_INTERVAL	250		/* timeout for txirb complete, in ms */
-
-#define DBUS_BUFFER_SIZE_TX	16000
-#define DBUS_BUFFER_SIZE_RX	5000
-
-#define DBUS_BUFFER_SIZE_TX_NOAGG	2048
-#define DBUS_BUFFER_SIZE_RX_NOAGG	2048
-
-/* DBUS types */
-enum {
-	DBUS_USB,
-	DBUS_SDIO,
-	DBUS_SPI,
-	DBUS_UNKNOWN
-};
-
-enum dbus_state {
-	DBUS_STATE_DL_PENDING,
-	DBUS_STATE_DL_DONE,
-	DBUS_STATE_UP,
-	DBUS_STATE_DOWN,
-	DBUS_STATE_PNP_FWDL,
-	DBUS_STATE_DISCONNECT,
-	DBUS_STATE_SLEEP
-};
-
-enum dbus_pnp_state {
-	DBUS_PNP_DISCONNECT,
-	DBUS_PNP_SLEEP,
-	DBUS_PNP_RESUME
-};
-
-enum dbus_file {
-    DBUS_FIRMWARE,
-    DBUS_NVFILE
-};
-
-typedef enum _DEVICE_SPEED {
-	INVALID_SPEED = -1,
-	LOW_SPEED     =  1,	/* USB 1.1: 1.5 Mbps */
-	FULL_SPEED,     	/* USB 1.1: 12  Mbps */
-	HIGH_SPEED,		/* USB 2.0: 480 Mbps */
-	SUPER_SPEED,		/* USB 3.0: 4.8 Gbps */
-} DEVICE_SPEED;
-
-typedef struct {
-	int bustype;
-	int vid;
-	int pid;
-	int devid;
-	int chiprev; /* chip revsion number */
-	int mtu;
-	int nchan; /* Data Channels */
-	int has_2nd_bulk_in_ep;
-} dbus_attrib_t;
-
-/* FIX: Account for errors related to DBUS;
- * Let upper layer account for packets/bytes
- */
-typedef struct {
-	uint32 rx_errors;
-	uint32 tx_errors;
-	uint32 rx_dropped;
-	uint32 tx_dropped;
-} dbus_stats_t;
-
-/*
- * Configurable BUS parameters
- */
-typedef struct {
-	bool rxctl_deferrespok;
-} dbus_config_t;
-
-/*
- * External Download Info
- */
-typedef struct dbus_extdl {
-	uint8 *fw;
-	int fwlen;
-	uint8 *vars;
-	int varslen;
-} dbus_extdl_t;
-
-struct dbus_callbacks;
-struct exec_parms;
-
-typedef void *(*probe_cb_t)(void *arg, const char *desc, uint32 bustype, uint32 hdrlen);
-typedef void (*disconnect_cb_t)(void *arg);
-typedef void *(*exec_cb_t)(struct exec_parms *args);
-
-/* Client callbacks registered during dbus_attach() */
-typedef struct dbus_callbacks {
-	void (*send_complete)(void *cbarg, void *info, int status);
-	void (*recv_buf)(void *cbarg, uint8 *buf, int len);
-	void (*recv_pkt)(void *cbarg, void *pkt);
-	void (*txflowcontrol)(void *cbarg, bool onoff);
-	void (*errhandler)(void *cbarg, int err);
-	void (*ctl_complete)(void *cbarg, int type, int status);
-	void (*state_change)(void *cbarg, int state);
-	void *(*pktget)(void *cbarg, uint len, bool send);
-	void (*pktfree)(void *cbarg, void *p, bool send);
-} dbus_callbacks_t;
-
-struct dbus_pub;
-struct bcmstrbuf;
-struct dbus_irb;
-struct dbus_irb_rx;
-struct dbus_irb_tx;
-struct dbus_intf_callbacks;
-
-typedef struct {
-	void* (*attach)(struct dbus_pub *pub, void *cbarg, struct dbus_intf_callbacks *cbs);
-	void (*detach)(struct dbus_pub *pub, void *bus);
-
-	int (*up)(void *bus);
-	int (*down)(void *bus);
-	int (*send_irb)(void *bus, struct dbus_irb_tx *txirb);
-	int (*recv_irb)(void *bus, struct dbus_irb_rx *rxirb);
-	int (*cancel_irb)(void *bus, struct dbus_irb_tx *txirb);
-	int (*send_ctl)(void *bus, uint8 *buf, int len);
-	int (*recv_ctl)(void *bus, uint8 *buf, int len);
-	int (*get_stats)(void *bus, dbus_stats_t *stats);
-	int (*get_attrib)(void *bus, dbus_attrib_t *attrib);
-
-	int (*pnp)(void *bus, int evnt);
-	int (*remove)(void *bus);
-	int (*resume)(void *bus);
-	int (*suspend)(void *bus);
-	int (*stop)(void *bus);
-	int (*reset)(void *bus);
-
-	/* Access to bus buffers directly */
-	void *(*pktget)(void *bus, int len);
-	void (*pktfree)(void *bus, void *pkt);
-
-	int  (*iovar_op)(void *bus, const char *name, void *params, int plen, void *arg, int len,
-		bool set);
-	void (*dump)(void *bus, struct bcmstrbuf *strbuf);
-	int  (*set_config)(void *bus, dbus_config_t *config);
-	int  (*get_config)(void *bus, dbus_config_t *config);
-
-	bool (*device_exists)(void *bus);
-	bool (*dlneeded)(void *bus);
-	int  (*dlstart)(void *bus, uint8 *fw, int len);
-	int  (*dlrun)(void *bus);
-	bool (*recv_needed)(void *bus);
-
-	void *(*exec_rxlock)(void *bus, exec_cb_t func, struct exec_parms *args);
-	void *(*exec_txlock)(void *bus, exec_cb_t func, struct exec_parms *args);
-
-	int (*tx_timer_init)(void *bus);
-	int (*tx_timer_start)(void *bus, uint timeout);
-	int (*tx_timer_stop)(void *bus);
-
-	int (*sched_dpc)(void *bus);
-	int (*lock)(void *bus);
-	int (*unlock)(void *bus);
-	int (*sched_probe_cb)(void *bus);
-
-	int (*shutdown)(void *bus);
-
-	int (*recv_stop)(void *bus);
-	int (*recv_resume)(void *bus);
-
-	int (*recv_irb_from_ep)(void *bus, struct dbus_irb_rx *rxirb, uint ep_idx);
-
-	int (*readreg)(void *bus, uint32 regaddr, int datalen, uint32 *value);
-
-	/* Add from the bottom */
-} dbus_intf_t;
-
-typedef struct dbus_pub {
-	struct osl_info *osh;
-	dbus_stats_t stats;
-	dbus_attrib_t attrib;
-	enum dbus_state busstate;
-	DEVICE_SPEED device_speed;
-	int ntxq, nrxq, rxsize;
-	void *bus;
-	struct shared_info *sh;
-    void *dev_info;
-} dbus_pub_t;
-
-#define BUS_INFO(bus, type) (((type *) bus)->pub->bus)
-
-#define	ALIGNED_LOCAL_VARIABLE(var, align)					\
-	uint8	buffer[SDALIGN+64];						\
-	uint8	*var = (uint8 *)(((uintptr)&buffer[0]) & ~(align-1)) + align;
-
-/*
- * Public Bus Function Interface
- */
-
-/*
- * FIX: Is there better way to pass OS/Host handles to DBUS but still
- *      maintain common interface for all OS??
- * Under NDIS, param1 needs to be MiniportHandle
- *  For NDIS60, param2 is WdfDevice
- * Under Linux, param1 and param2 are NULL;
- */
-extern int dbus_register(int vid, int pid, probe_cb_t prcb, disconnect_cb_t discb, void *prarg,
-	void *param1, void *param2);
-extern int dbus_deregister(void);
-
-extern dbus_pub_t *dbus_attach(struct osl_info *osh, int rxsize, int nrxq, int ntxq,
-	void *cbarg, dbus_callbacks_t *cbs, dbus_extdl_t *extdl, struct shared_info *sh);
-extern void dbus_detach(dbus_pub_t *pub);
-
-extern int dbus_up(dbus_pub_t *pub);
-extern int dbus_down(dbus_pub_t *pub);
-extern int dbus_stop(dbus_pub_t *pub);
-extern int dbus_shutdown(dbus_pub_t *pub);
-extern void dbus_flowctrl_rx(dbus_pub_t *pub, bool on);
-
-extern int dbus_send_txdata(dbus_pub_t *dbus, void *pktbuf);
-extern int dbus_send_buf(dbus_pub_t *pub, uint8 *buf, int len, void *info);
-extern int dbus_send_pkt(dbus_pub_t *pub, void *pkt, void *info);
-extern int dbus_send_ctl(dbus_pub_t *pub, uint8 *buf, int len);
-extern int dbus_recv_ctl(dbus_pub_t *pub, uint8 *buf, int len);
-extern int dbus_recv_bulk(dbus_pub_t *pub, uint32 ep_idx);
-extern int dbus_poll_intr(dbus_pub_t *pub);
-
-extern int dbus_get_stats(dbus_pub_t *pub, dbus_stats_t *stats);
-extern int dbus_get_attrib(dbus_pub_t *pub, dbus_attrib_t *attrib);
-extern int dbus_get_device_speed(dbus_pub_t *pub);
-extern int dbus_set_config(dbus_pub_t *pub, dbus_config_t *config);
-extern int dbus_get_config(dbus_pub_t *pub, dbus_config_t *config);
-extern void * dbus_get_devinfo(dbus_pub_t *pub);
-
-extern void *dbus_pktget(dbus_pub_t *pub, int len);
-extern void dbus_pktfree(dbus_pub_t *pub, void* pkt);
-
-extern int dbus_set_errmask(dbus_pub_t *pub, uint32 mask);
-extern int dbus_pnp_sleep(dbus_pub_t *pub);
-extern int dbus_pnp_resume(dbus_pub_t *pub, int *fw_reload);
-extern int dbus_pnp_disconnect(dbus_pub_t *pub);
-
-extern int dbus_iovar_op(dbus_pub_t *pub, const char *name,
-	void *params, int plen, void *arg, int len, bool set);
-
-extern void *dhd_dbus_txq(const dbus_pub_t *pub);
-extern uint dhd_dbus_hdrlen(const dbus_pub_t *pub);
-
-/*
- * Private Common Bus Interface
- */
-
-/* IO Request Block (IRB) */
-typedef struct dbus_irb {
-	struct dbus_irb *next;	/* it's casted from dbus_irb_tx or dbus_irb_rx struct */
-} dbus_irb_t;
-
-typedef struct dbus_irb_rx {
-	struct dbus_irb irb; /* Must be first */
-	uint8 *buf;
-	int buf_len;
-	int actual_len;
-	void *pkt;
-	void *info;
-	void *arg;
-} dbus_irb_rx_t;
-
-typedef struct dbus_irb_tx {
-	struct dbus_irb irb; /* Must be first */
-	uint8 *buf;
-	int len;
-	void *pkt;
-	int retry_count;
-	void *info;
-	void *arg;
-	void *send_buf; /* linear  bufffer for LINUX when aggreagtion is enabled */
-} dbus_irb_tx_t;
-
-/* DBUS interface callbacks are different from user callbacks
- * so, internally, different info can be passed to upper layer
- */
-typedef struct dbus_intf_callbacks {
-	void (*send_irb_timeout)(void *cbarg, dbus_irb_tx_t *txirb);
-	void (*send_irb_complete)(void *cbarg, dbus_irb_tx_t *txirb, int status);
-	void (*recv_irb_complete)(void *cbarg, dbus_irb_rx_t *rxirb, int status);
-	void (*errhandler)(void *cbarg, int err);
-	void (*ctl_complete)(void *cbarg, int type, int status);
-	void (*state_change)(void *cbarg, int state);
-	bool (*isr)(void *cbarg, bool *wantdpc);
-	bool (*dpc)(void *cbarg, bool bounded);
-	void (*watchdog)(void *cbarg);
-	void *(*pktget)(void *cbarg, uint len, bool send);
-	void (*pktfree)(void *cbarg, void *p, bool send);
-	struct dbus_irb* (*getirb)(void *cbarg, bool send);
-	void (*rxerr_indicate)(void *cbarg, bool on);
-} dbus_intf_callbacks_t;
-
-/*
- * Porting: To support new bus, port these functions below
- */
-
-/*
- * Bus specific Interface
- * Implemented by dbus_usb.c/dbus_sdio.c
- */
-extern int dbus_bus_register(int vid, int pid, probe_cb_t prcb, disconnect_cb_t discb, void *prarg,
-	dbus_intf_t **intf, void *param1, void *param2);
-extern int dbus_bus_deregister(void);
-extern void dbus_bus_fw_get(void *bus, uint8 **fw, int *fwlen, int *decomp);
-
-/*
- * Bus-specific and OS-specific Interface
- * Implemented by dbus_usb_[linux/ndis].c/dbus_sdio_[linux/ndis].c
- */
-extern int dbus_bus_osl_register(int vid, int pid, probe_cb_t prcb, disconnect_cb_t discb,
-	void *prarg, dbus_intf_t **intf, void *param1, void *param2);
-extern int dbus_bus_osl_deregister(void);
-
-/*
- * Bus-specific, OS-specific, HW-specific Interface
- * Mainly for SDIO Host HW controller
- */
-extern int dbus_bus_osl_hw_register(int vid, int pid, probe_cb_t prcb, disconnect_cb_t discb,
-	void *prarg, dbus_intf_t **intf);
-extern int dbus_bus_osl_hw_deregister(void);
-
-extern uint usbdev_bulkin_eps(void);
-#if defined(BCM_REQUEST_FW)
-extern void *dbus_get_fw_nvfile(int devid, uint8 **fw, int *fwlen, int type,
-  uint16 boardtype, uint16 boardrev);
-extern void dbus_release_fw_nvfile(void *firmware);
-#endif  /* #if defined(BCM_REQUEST_FW) */
-
-
-#if defined(EHCI_FASTPATH_TX) || defined(EHCI_FASTPATH_RX)
-
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0))
-	/* Backward compatibility */
-	typedef unsigned int gfp_t;
-
-	#define dma_pool pci_pool
-	#define dma_pool_create(name, dev, size, align, alloc) \
-		pci_pool_create(name, dev, size, align, alloc, GFP_DMA | GFP_ATOMIC)
-	#define dma_pool_destroy(pool) pci_pool_destroy(pool)
-	#define dma_pool_alloc(pool, flags, handle) pci_pool_alloc(pool, flags, handle)
-	#define dma_pool_free(pool, vaddr, addr) pci_pool_free(pool, vaddr, addr)
-
-	#define dma_map_single(dev, addr, size, dir)	pci_map_single(dev, addr, size, dir)
-	#define dma_unmap_single(dev, hnd, size, dir)	pci_unmap_single(dev, hnd, size, dir)
-	#define DMA_FROM_DEVICE PCI_DMA_FROMDEVICE
-	#define DMA_TO_DEVICE PCI_DMA_TODEVICE
-#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)) */
-
-/* Availability of these functions varies (when present, they have two arguments) */
-#ifndef hc32_to_cpu
-	#define hc32_to_cpu(x)	le32_to_cpu(x)
-	#define cpu_to_hc32(x)	cpu_to_le32(x)
-	typedef unsigned int __hc32;
-#else
-	#error Two-argument functions needed
-#endif
-
-/* Private USB opcode base */
-#define EHCI_FASTPATH		0x31
-#define	EHCI_SET_EP_BYPASS	EHCI_FASTPATH
-#define	EHCI_SET_BYPASS_CB	(EHCI_FASTPATH + 1)
-#define	EHCI_SET_BYPASS_DEV	(EHCI_FASTPATH + 2)
-#define	EHCI_DUMP_STATE		(EHCI_FASTPATH + 3)
-#define	EHCI_SET_BYPASS_POOL	(EHCI_FASTPATH + 4)
-#define	EHCI_CLR_EP_BYPASS	(EHCI_FASTPATH + 5)
-
-/*
- * EHCI QTD structure (hardware and extension)
- * NOTE that is does not need to (and does not) match its kernel counterpart
- */
-#define EHCI_QTD_NBUFFERS       5
-#define EHCI_QTD_ALIGN  	32
-#define EHCI_BULK_PACKET_SIZE	512
-#define EHCI_QTD_XACTERR_MAX	32
-
-struct ehci_qtd {
-	/* Hardware map */
-	volatile uint32_t	qtd_next;
-	volatile uint32_t	qtd_altnext;
-	volatile uint32_t	qtd_status;
-#define	EHCI_QTD_GET_BYTES(x)	(((x)>>16) & 0x7fff)
-#define	EHCI_QTD_IOC            0x00008000
-#define	EHCI_QTD_GET_CERR(x)	(((x)>>10) & 0x3)
-#define EHCI_QTD_SET_CERR(x)    ((x) << 10)
-#define	EHCI_QTD_GET_PID(x)	(((x)>>8) & 0x3)
-#define EHCI_QTD_SET_PID(x)     ((x) <<  8)
-#define EHCI_QTD_ACTIVE         0x80
-#define EHCI_QTD_HALTED         0x40
-#define EHCI_QTD_BUFERR         0x20
-#define EHCI_QTD_BABBLE         0x10
-#define EHCI_QTD_XACTERR        0x08
-#define EHCI_QTD_MISSEDMICRO    0x04
-	volatile uint32_t 	qtd_buffer[EHCI_QTD_NBUFFERS];
-	volatile uint32_t 	qtd_buffer_hi[EHCI_QTD_NBUFFERS];
-
-	/* Implementation extension */
-	dma_addr_t		qtd_self;		/* own hardware address */
-	struct ehci_qtd		*obj_next;		/* software link to the next QTD */
-	void			*rpc;			/* pointer to the rpc buffer */
-	size_t			length;			/* length of the data in the buffer */
-	void			*buff;			/* pointer to the reassembly buffer */
-	int			xacterrs;		/* retry counter for qtd xact error */
-} __attribute__ ((aligned(EHCI_QTD_ALIGN)));
-
-#define	EHCI_NULL	__constant_cpu_to_le32(1) /* HW null pointer shall be odd */
-
-#define SHORT_READ_Q(token) (EHCI_QTD_GET_BYTES(token) != 0 && EHCI_QTD_GET_PID(token) == 1)
-
-/* Queue Head */
-/* NOTE This structure is slightly different from the one in the kernel; but needs to stay
- * compatible
- */
-struct ehci_qh {
-	/* Hardware map */
-	volatile uint32_t 	qh_link;
-	volatile uint32_t 	qh_endp;
-	volatile uint32_t 	qh_endphub;
-	volatile uint32_t 	qh_curqtd;
-
-	/* QTD overlay */
-	volatile uint32_t	ow_next;
-	volatile uint32_t	ow_altnext;
-	volatile uint32_t	ow_status;
-	volatile uint32_t	ow_buffer [EHCI_QTD_NBUFFERS];
-	volatile uint32_t	ow_buffer_hi [EHCI_QTD_NBUFFERS];
-
-	/* Extension (should match the kernel layout) */
-	dma_addr_t		unused0;
-	void 			*unused1;
-	struct list_head	unused2;
-	struct ehci_qtd		*dummy;
-	struct ehci_qh		*unused3;
-
-	struct ehci_hcd		*unused4;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))
-	struct kref		unused5;
-	unsigned		unused6;
-
-	uint8_t			unused7;
-
-	/* periodic schedule info */
-	uint8_t			unused8;
-	uint8_t			unused9;
-	uint8_t			unused10;
-	uint16_t		unused11;
-	uint16_t		unused12;
-	uint16_t		unused13;
-	struct usb_device	*unused14;
-#else
-	unsigned		unused5;
-
-	u8			unused6;
-
-	/* periodic schedule info */
-	u8			unused7;
-	u8			unused8;
-	u8			unused9;
-	unsigned short		unused10;
-	unsigned short		unused11;
-#define NO_FRAME ((unsigned short)~0)
-#ifdef EHCI_QUIRK_FIX
-	struct usb_device	*unused12;
-#endif /* EHCI_QUIRK_FIX */
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)) */
-	struct ehci_qtd		*first_qtd;
-		/* Link to the first QTD; this is an optimized equivalent of the qtd_list field */
-		/* NOTE that ehci_qh in ehci.h shall reserve this word */
-} __attribute__ ((aligned(EHCI_QTD_ALIGN)));
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0))
-/* The corresponding structure in the kernel is used to get the QH */
-struct hcd_dev {	/* usb_device.hcpriv points to this */
-	struct list_head	unused0;
-	struct list_head	unused1;
-
-	/* array of QH pointers */
-	void			*ep[32];
-};
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)) */
-
-int optimize_qtd_fill_with_rpc(const dbus_pub_t *pub,  int epn, struct ehci_qtd *qtd, void *rpc,
-	int token, int len);
-int optimize_qtd_fill_with_data(const dbus_pub_t *pub, int epn, struct ehci_qtd *qtd, void *data,
-	int token, int len);
-int optimize_submit_async(struct ehci_qtd *qtd, int epn);
-void inline optimize_ehci_qtd_init(struct ehci_qtd *qtd, dma_addr_t dma);
-struct ehci_qtd *optimize_ehci_qtd_alloc(gfp_t flags);
-void optimize_ehci_qtd_free(struct ehci_qtd *qtd);
-void optimize_submit_rx_request(const dbus_pub_t *pub, int epn, struct ehci_qtd *qtd_in, void *buf);
-#endif /* EHCI_FASTPATH_TX || EHCI_FASTPATH_RX */
-
-void  dbus_flowctrl_tx(void *dbi, bool on);
-#endif /* __DBUS_H__ */
diff --git a/drivers/net/wireless/bcmdhd/include/dhdioctl.h b/drivers/net/wireless/bcmdhd/include/dhdioctl.h
old mode 100644
new mode 100755
index 03c44ad..308a575
--- a/drivers/net/wireless/bcmdhd/include/dhdioctl.h
+++ b/drivers/net/wireless/bcmdhd/include/dhdioctl.h
@@ -5,27 +5,9 @@
  *
  * Definitions subject to change without notice.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: dhdioctl.h 327460 2012-04-13 18:38:41Z $
+ * $Id: dhdioctl.h 390859 2013-03-14 01:09:31Z $
  */
 
 #ifndef _dhdioctl_h_
@@ -85,14 +67,12 @@ enum {
 #define DHD_GLOM_VAL	0x0400
 #define DHD_EVENT_VAL	0x0800
 #define DHD_BTA_VAL	0x1000
-#if 0 && (NDISVER >= 0x0630) && 1
-#define DHD_SCAN_VAL	0x2000
-#else
 #define DHD_ISCAN_VAL	0x2000
-#endif
 #define DHD_ARPOE_VAL	0x4000
 #define DHD_REORDER_VAL	0x8000
 #define DHD_WL_VAL		0x10000
+#define DHD_NOCHECKDIED_VAL		0x20000 /* UTF WAR */
+#define DHD_WL_VAL2		0x40000
 
 #ifdef SDTEST
 /* For pktgen iovar */
diff --git a/drivers/net/wireless/bcmdhd/include/epivers.h b/drivers/net/wireless/bcmdhd/include/epivers.h
old mode 100644
new mode 100755
index 8fcf87c..f9cd98b
--- a/drivers/net/wireless/bcmdhd/include/epivers.h
+++ b/drivers/net/wireless/bcmdhd/include/epivers.h
@@ -1,23 +1,5 @@
 /*
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * $Id: epivers.h.in,v 13.33 2010-09-08 22:08:53 $
  *
@@ -28,21 +10,21 @@
 
 #define	EPI_MAJOR_VERSION	1
 
-#define	EPI_MINOR_VERSION	27
+#define	EPI_MINOR_VERSION	88
 
-#define	EPI_RC_NUMBER		0
+#define	EPI_RC_NUMBER		10
 
 #define	EPI_INCREMENTAL_NUMBER	0
 
 #define	EPI_BUILD_NUMBER	0
 
-#define	EPI_VERSION		1, 27, 0, 0
+#define	EPI_VERSION		1, 88, 10, 0
 
-#define	EPI_VERSION_NUM		0x011b0000
+#define	EPI_VERSION_NUM		0x01580a00
 
-#define EPI_VERSION_DEV		1.27.0
+#define EPI_VERSION_DEV		1.88.10
 
 
-#define	EPI_VERSION_STR		"1.27 (r329705)"
+#define	EPI_VERSION_STR		"1.88.10 (r395294)"
 
 #endif 
diff --git a/drivers/net/wireless/bcmdhd/include/hndpmu.h b/drivers/net/wireless/bcmdhd/include/hndpmu.h
old mode 100644
new mode 100755
index c41def6..f2f6206
--- a/drivers/net/wireless/bcmdhd/include/hndpmu.h
+++ b/drivers/net/wireless/bcmdhd/include/hndpmu.h
@@ -1,27 +1,9 @@
 /*
  * HND SiliconBackplane PMU support.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: hndpmu.h 241182 2011-02-17 21:50:03Z $
+ * $Id: hndpmu.h 385540 2013-02-15 23:14:50Z $
  */
 
 #ifndef _hndpmu_h_
diff --git a/drivers/net/wireless/bcmdhd/include/hndrte_armtrap.h b/drivers/net/wireless/bcmdhd/include/hndrte_armtrap.h
old mode 100644
new mode 100755
index 90d9799..83adf38
--- a/drivers/net/wireless/bcmdhd/include/hndrte_armtrap.h
+++ b/drivers/net/wireless/bcmdhd/include/hndrte_armtrap.h
@@ -1,25 +1,7 @@
 /*
  * HNDRTE arm trap handling.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * $Id: hndrte_armtrap.h 261365 2011-05-24 20:42:23Z $
  */
diff --git a/drivers/net/wireless/bcmdhd/include/hndrte_cons.h b/drivers/net/wireless/bcmdhd/include/hndrte_cons.h
old mode 100644
new mode 100755
index 57abbbd..0af5d88
--- a/drivers/net/wireless/bcmdhd/include/hndrte_cons.h
+++ b/drivers/net/wireless/bcmdhd/include/hndrte_cons.h
@@ -1,27 +1,9 @@
 /*
  * Console support for hndrte.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: hndrte_cons.h 300516 2011-12-04 17:39:44Z $
+ * $Id: hndrte_cons.h 383834 2013-02-07 23:21:51Z $
  */
 #ifndef	_HNDRTE_CONS_H
 #define	_HNDRTE_CONS_H
@@ -64,4 +46,6 @@ typedef struct {
 	char		cbuf[CBUF_LEN];
 } hndrte_cons_t;
 
+hndrte_cons_t *hndrte_get_active_cons_state(void);
+
 #endif /* _HNDRTE_CONS_H */
diff --git a/drivers/net/wireless/bcmdhd/include/hndsoc.h b/drivers/net/wireless/bcmdhd/include/hndsoc.h
old mode 100644
new mode 100755
index 66640c3..7678945
--- a/drivers/net/wireless/bcmdhd/include/hndsoc.h
+++ b/drivers/net/wireless/bcmdhd/include/hndsoc.h
@@ -1,27 +1,9 @@
 /*
  * Broadcom HND chip & on-chip-interconnect-related definitions.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: hndsoc.h 309193 2012-01-19 00:03:57Z $
+ * $Id: hndsoc.h 365041 2012-10-26 09:10:35Z $
  */
 
 #ifndef	_HNDSOC_H
@@ -46,10 +28,8 @@
 
 #define SI_WRAP_BASE    	0x18100000	/* Wrapper space base */
 #define SI_CORE_SIZE    	0x1000		/* each core gets 4Kbytes for registers */
-#define	SI_MAXCORES		16		/* Max cores (this is arbitrary, for software
-						 * convenience and could be changed if we
-						 * make any larger chips
-						 */
+
+#define	SI_MAXCORES		32		/* NorthStar has more cores */
 
 #define	SI_FASTRAM		0x19000000	/* On-chip RAM on chips that also have DDR */
 #define	SI_FASTRAM_SWAPPED	0x19800000
@@ -59,6 +39,13 @@
 #define	SI_ARMCM3_ROM		0x1e000000	/* ARM Cortex-M3 ROM */
 #define	SI_FLASH1		0x1fc00000	/* MIPS Flash Region 1 */
 #define	SI_FLASH1_SZ		0x00400000	/* MIPS Size of Flash Region 1 */
+#define	SI_FLASH_WINDOW		0x01000000	/* Flash XIP Window */
+
+#define SI_NS_NANDFLASH		0x1c000000	/* NorthStar NAND flash base */
+#define SI_NS_NORFLASH		0x1e000000	/* NorthStar NOR flash base */
+#define SI_NS_ROM		0xfffd0000	/* NorthStar ROM */
+#define	SI_NS_FLASH_WINDOW	0x02000000	/* Flash XIP Window */
+
 #define	SI_ARM7S_ROM		0x20000000	/* ARM7TDMI-S ROM */
 #define	SI_ARMCR4_ROM		0x000f0000	/* ARM Cortex-R4 ROM */
 #define	SI_ARMCM3_SRAM2		0x60000000	/* ARM Cortex-M3 SRAM Region 2 */
@@ -147,7 +134,21 @@
 						 */
 
 #define CC_4706_CORE_ID		0x500		/* chipcommon core */
+#define NS_PCIEG2_CORE_ID	0x501		/* PCIE Gen 2 core */
+#define NS_DMA_CORE_ID		0x502		/* DMA core */
+#define NS_SDIO3_CORE_ID	0x503		/* SDIO3 core */
+#define NS_USB20_CORE_ID	0x504		/* USB2.0 core */
+#define NS_USB30_CORE_ID	0x505		/* USB3.0 core */
+#define NS_A9JTAG_CORE_ID	0x506		/* ARM Cortex A9 JTAG core */
+#define NS_DDR23_CORE_ID	0x507		/* Denali DDR2/DDR3 memory controller */
+#define NS_ROM_CORE_ID		0x508		/* ROM core */
+#define NS_NAND_CORE_ID		0x509		/* NAND flash controller core */
+#define NS_QSPI_CORE_ID		0x50a		/* SPI flash controller core */
+#define NS_CCB_CORE_ID		0x50b		/* ChipcommonB core */
 #define SOCRAM_4706_CORE_ID	0x50e		/* internal memory core */
+#define NS_SOCRAM_CORE_ID	SOCRAM_4706_CORE_ID
+#define	ARMCA9_CORE_ID		0x510		/* ARM Cortex A9 core (ihost) */
+#define	NS_IHOST_CORE_ID	ARMCA9_CORE_ID	/* ARM Cortex A9 core (ihost) */
 #define GMAC_COMMON_4706_CORE_ID	0x5dc		/* Gigabit MAC core */
 #define GMAC_4706_CORE_ID	0x52d		/* Gigabit MAC core */
 #define AMEMC_CORE_ID		0x52e		/* DDR1/2 memory controller core */
@@ -172,6 +173,7 @@
 #define	SOCI_SB			0
 #define	SOCI_AI			1
 #define	SOCI_UBUS		2
+#define	SOCI_NAI		3
 
 /* Common core control flags */
 #define	SICF_BIST_EN		0x8000
@@ -187,6 +189,14 @@
 #define	SISF_DMA64		0x1000
 #define	SISF_CORE_BITS		0x0fff
 
+/* Norstar core status flags */
+#define SISF_NS_BOOTDEV_MASK	0x0003	/* ROM core */
+#define SISF_NS_BOOTDEV_NOR	0x0000	/* ROM core */
+#define SISF_NS_BOOTDEV_NAND	0x0001	/* ROM core */
+#define SISF_NS_BOOTDEV_ROM	0x0002	/* ROM core */
+#define SISF_NS_BOOTDEV_OFFLOAD	0x0003	/* ROM core */
+#define SISF_NS_SKUVEC_MASK	0x000c	/* ROM core */
+
 /* A register that is common to all cores to
  * communicate w/PMU regarding clock control.
  */
@@ -232,4 +242,18 @@
 #define	BISZ_BSSEND_IDX		6		/*	6: bss end */
 #define BISZ_SIZE		7		/* descriptor size in 32-bit integers */
 
+/* Boot/Kernel related defintion and functions */
+#define	SOC_BOOTDEV_ROM		0x00000001
+#define	SOC_BOOTDEV_PFLASH	0x00000002
+#define	SOC_BOOTDEV_SFLASH	0x00000004
+#define	SOC_BOOTDEV_NANDFLASH	0x00000008
+
+#define	SOC_KNLDEV_NORFLASH	0x00000002
+#define	SOC_KNLDEV_NANDFLASH	0x00000004
+
+#ifndef _LANGUAGE_ASSEMBLY
+int soc_boot_dev(void *sih);
+int soc_knl_dev(void *sih);
+#endif	/* _LANGUAGE_ASSEMBLY */
+
 #endif /* _HNDSOC_H */
diff --git a/drivers/net/wireless/bcmdhd/include/linux_osl.h b/drivers/net/wireless/bcmdhd/include/linux_osl.h
old mode 100644
new mode 100755
index 257aaf6..8dbeca4
--- a/drivers/net/wireless/bcmdhd/include/linux_osl.h
+++ b/drivers/net/wireless/bcmdhd/include/linux_osl.h
@@ -1,27 +1,9 @@
 /*
  * Linux OS Independent Layer
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: linux_osl.h 326751 2012-04-10 20:13:19Z $
+ * $Id: linux_osl.h 386902 2013-02-22 09:10:37Z $
  */
 
 #ifndef _linux_osl_h_
@@ -92,7 +74,6 @@ extern struct pci_dev *osl_pci_device(osl_t *osh);
 
 typedef struct {
 	bool pkttag;
-	uint pktalloced; 	
 	bool mmbus;		
 	pktfree_cb_fn_t tx_fn;  
 	void *tx_ctx;		
@@ -139,7 +120,8 @@ extern void osl_dma_free_consistent(osl_t *osh, void *va, uint size, ulong pa);
 
 #define	DMA_UNMAP(osh, pa, size, direction, p, dmah) \
 	osl_dma_unmap((osh), (pa), (size), (direction))
-extern uint osl_dma_map(osl_t *osh, void *va, uint size, int direction);
+extern uint osl_dma_map(osl_t *osh, void *va, uint size, int direction, void *p,
+	hnddma_seg_map_t *txp_dmah);
 extern void osl_dma_unmap(osl_t *osh, uint pa, uint size, int direction);
 
 
@@ -165,8 +147,11 @@ extern int osl_error(int bcmerror);
 #include <linuxver.h>           
 #include <linux/kernel.h>       
 #include <linux/string.h>       
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 29)
+#define OSL_SYSUPTIME()		((uint32)jiffies_to_msecs(jiffies))
+#else
 #define OSL_SYSUPTIME()		((uint32)jiffies * (1000 / HZ))
+#endif 
 #define	printf(fmt, args...)	printk(fmt , ## args)
 #include <linux/kernel.h>	
 #include <linux/string.h>	
@@ -218,6 +203,9 @@ extern int osl_error(int bcmerror);
 #define OSL_UNCACHED(va)	((void *)va)
 #define OSL_CACHED(va)		((void *)va)
 
+
+#define OSL_CACHE_FLUSH(va, len)
+
 #define OSL_PREF_RANGE_LD(va, sz)
 #define OSL_PREF_RANGE_ST(va, sz)
 
@@ -248,30 +236,77 @@ extern int osl_error(int bcmerror);
 #include <linuxver.h>		
 
 
+#ifdef BCMDBG_CTRACE
+#define	PKTGET(osh, len, send)		osl_pktget((osh), (len), __LINE__, __FILE__)
+#define	PKTDUP(osh, skb)		osl_pktdup((osh), (skb), __LINE__, __FILE__)
+#else
 #define	PKTGET(osh, len, send)		osl_pktget((osh), (len))
 #define	PKTDUP(osh, skb)		osl_pktdup((osh), (skb))
+#endif 
 #define PKTLIST_DUMP(osh, buf)
 #define PKTDBG_TRACE(osh, pkt, bit)
 #define	PKTFREE(osh, skb, send)		osl_pktfree((osh), (skb), (send))
 #ifdef CONFIG_DHD_USE_STATIC_BUF
 #define	PKTGET_STATIC(osh, len, send)		osl_pktget_static((osh), (len))
 #define	PKTFREE_STATIC(osh, skb, send)		osl_pktfree_static((osh), (skb), (send))
+#else
+#define	PKTGET_STATIC	PKTGET
+#define	PKTFREE_STATIC	PKTFREE
 #endif 
 #define	PKTDATA(osh, skb)		(((struct sk_buff*)(skb))->data)
 #define	PKTLEN(osh, skb)		(((struct sk_buff*)(skb))->len)
 #define PKTHEADROOM(osh, skb)		(PKTDATA(osh, skb)-(((struct sk_buff*)(skb))->head))
-#define PKTTAILROOM(osh, skb) ((((struct sk_buff*)(skb))->end)-(((struct sk_buff*)(skb))->tail))
+#define PKTTAILROOM(osh, skb)		skb_tailroom((struct sk_buff*)(skb))
+#define PKTPADTAILROOM(osh, skb, padlen)		skb_pad((struct sk_buff*)(skb), (padlen))
 #define	PKTNEXT(osh, skb)		(((struct sk_buff*)(skb))->next)
 #define	PKTSETNEXT(osh, skb, x)		(((struct sk_buff*)(skb))->next = (struct sk_buff*)(x))
 #define	PKTSETLEN(osh, skb, len)	__skb_trim((struct sk_buff*)(skb), (len))
 #define	PKTPUSH(osh, skb, bytes)	skb_push((struct sk_buff*)(skb), (bytes))
 #define	PKTPULL(osh, skb, bytes)	skb_pull((struct sk_buff*)(skb), (bytes))
 #define	PKTTAG(skb)			((void*)(((struct sk_buff*)(skb))->cb))
-#define PKTALLOCED(osh)			((osl_pubinfo_t *)(osh))->pktalloced
 #define PKTSETPOOL(osh, skb, x, y)	do {} while (0)
 #define PKTPOOL(osh, skb)		FALSE
 #define PKTSHRINK(osh, m)		(m)
 
+#ifdef BCMDBG_CTRACE
+#define	DEL_CTRACE(zosh, zskb) { \
+	unsigned long zflags; \
+	spin_lock_irqsave(&(zosh)->ctrace_lock, zflags); \
+	list_del(&(zskb)->ctrace_list); \
+	(zosh)->ctrace_num--; \
+	(zskb)->ctrace_start = 0; \
+	(zskb)->ctrace_count = 0; \
+	spin_unlock_irqrestore(&(zosh)->ctrace_lock, zflags); \
+}
+
+#define	UPDATE_CTRACE(zskb, zfile, zline) { \
+	struct sk_buff *_zskb = (struct sk_buff *)(zskb); \
+	if (_zskb->ctrace_count < CTRACE_NUM) { \
+		_zskb->func[_zskb->ctrace_count] = zfile; \
+		_zskb->line[_zskb->ctrace_count] = zline; \
+		_zskb->ctrace_count++; \
+	} \
+	else { \
+		_zskb->func[_zskb->ctrace_start] = zfile; \
+		_zskb->line[_zskb->ctrace_start] = zline; \
+		_zskb->ctrace_start++; \
+		if (_zskb->ctrace_start >= CTRACE_NUM) \
+			_zskb->ctrace_start = 0; \
+	} \
+}
+
+#define	ADD_CTRACE(zosh, zskb, zfile, zline) { \
+	unsigned long zflags; \
+	spin_lock_irqsave(&(zosh)->ctrace_lock, zflags); \
+	list_add(&(zskb)->ctrace_list, &(zosh)->ctrace_list); \
+	(zosh)->ctrace_num++; \
+	UPDATE_CTRACE(zskb, zfile, zline); \
+	spin_unlock_irqrestore(&(zosh)->ctrace_lock, zflags); \
+}
+
+#define PKTCALLER(zskb)	UPDATE_CTRACE((struct sk_buff *)zskb, (char *)__FUNCTION__, __LINE__)
+#endif 
+
 #ifdef CTFPOOL
 #define	CTFPOOL_REFILL_THRESH	3
 typedef struct ctfpool {
@@ -285,66 +320,116 @@ typedef struct ctfpool {
 	uint 		fast_frees;
 	uint 		slow_allocs;
 } ctfpool_t;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22)
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+#define	FASTBUF	(1 << 0)
+#define	PKTSETFAST(osh, skb)	((((struct sk_buff*)(skb))->pktc_flags) |= FASTBUF)
+#define	PKTCLRFAST(osh, skb)	((((struct sk_buff*)(skb))->pktc_flags) &= (~FASTBUF))
+#define	PKTISFAST(osh, skb)	((((struct sk_buff*)(skb))->pktc_flags) & FASTBUF)
+#define	PKTFAST(osh, skb)	(((struct sk_buff*)(skb))->pktc_flags)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22)
 #define	FASTBUF	(1 << 16)
-#define	CTFBUF	(1 << 17)
 #define	PKTSETFAST(osh, skb)	((((struct sk_buff*)(skb))->mac_len) |= FASTBUF)
 #define	PKTCLRFAST(osh, skb)	((((struct sk_buff*)(skb))->mac_len) &= (~FASTBUF))
-#define	PKTSETCTF(osh, skb)	((((struct sk_buff*)(skb))->mac_len) |= CTFBUF)
-#define	PKTCLRCTF(osh, skb)	((((struct sk_buff*)(skb))->mac_len) &= (~CTFBUF))
 #define	PKTISFAST(osh, skb)	((((struct sk_buff*)(skb))->mac_len) & FASTBUF)
-#define	PKTISCTF(osh, skb)	((((struct sk_buff*)(skb))->mac_len) & CTFBUF)
 #define	PKTFAST(osh, skb)	(((struct sk_buff*)(skb))->mac_len)
 #else
 #define	FASTBUF	(1 << 0)
-#define	CTFBUF	(1 << 1)
 #define	PKTSETFAST(osh, skb)	((((struct sk_buff*)(skb))->__unused) |= FASTBUF)
 #define	PKTCLRFAST(osh, skb)	((((struct sk_buff*)(skb))->__unused) &= (~FASTBUF))
-#define	PKTSETCTF(osh, skb)	((((struct sk_buff*)(skb))->__unused) |= CTFBUF)
-#define	PKTCLRCTF(osh, skb)	((((struct sk_buff*)(skb))->__unused) &= (~CTFBUF))
 #define	PKTISFAST(osh, skb)	((((struct sk_buff*)(skb))->__unused) & FASTBUF)
-#define	PKTISCTF(osh, skb)	((((struct sk_buff*)(skb))->__unused) & CTFBUF)
 #define	PKTFAST(osh, skb)	(((struct sk_buff*)(skb))->__unused)
 #endif 
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+#define	CTFPOOLPTR(osh, skb)	(((struct sk_buff*)(skb))->ctfpool)
+#define	CTFPOOLHEAD(osh, skb)	(((ctfpool_t *)((struct sk_buff*)(skb))->ctfpool)->head)
+#else
 #define	CTFPOOLPTR(osh, skb)	(((struct sk_buff*)(skb))->sk)
 #define	CTFPOOLHEAD(osh, skb)	(((ctfpool_t *)((struct sk_buff*)(skb))->sk)->head)
+#endif
 
 extern void *osl_ctfpool_add(osl_t *osh);
 extern void osl_ctfpool_replenish(osl_t *osh, uint thresh);
 extern int32 osl_ctfpool_init(osl_t *osh, uint numobj, uint size);
 extern void osl_ctfpool_cleanup(osl_t *osh);
 extern void osl_ctfpool_stats(osl_t *osh, void *b);
+#else 
+#define	PKTSETFAST(osh, skb)
+#define	PKTCLRFAST(osh, skb)
+#define	PKTISFAST(osh, skb)	(FALSE)
 #endif 
 
+#define	PKTSETCTF(osh, skb)
+#define	PKTCLRCTF(osh, skb)
+#define	PKTISCTF(osh, skb)	(FALSE)
 
 #ifdef HNDCTF
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22)
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+#define	SKIPCT	(1 << 2)
+#define	CHAINED	(1 << 3)
+#define	PKTSETSKIPCT(osh, skb)	(((struct sk_buff*)(skb))->pktc_flags |= SKIPCT)
+#define	PKTCLRSKIPCT(osh, skb)	(((struct sk_buff*)(skb))->pktc_flags &= (~SKIPCT))
+#define	PKTSKIPCT(osh, skb)	(((struct sk_buff*)(skb))->pktc_flags & SKIPCT)
+#define	PKTSETCHAINED(osh, skb)	(((struct sk_buff*)(skb))->pktc_flags |= CHAINED)
+#define	PKTCLRCHAINED(osh, skb)	(((struct sk_buff*)(skb))->pktc_flags &= (~CHAINED))
+#define	PKTISCHAINED(skb)	(((struct sk_buff*)(skb))->pktc_flags & CHAINED)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22)
 #define	SKIPCT	(1 << 18)
+#define	CHAINED	(1 << 19)
 #define	PKTSETSKIPCT(osh, skb)	(((struct sk_buff*)(skb))->mac_len |= SKIPCT)
 #define	PKTCLRSKIPCT(osh, skb)	(((struct sk_buff*)(skb))->mac_len &= (~SKIPCT))
 #define	PKTSKIPCT(osh, skb)	(((struct sk_buff*)(skb))->mac_len & SKIPCT)
+#define	PKTSETCHAINED(osh, skb)	(((struct sk_buff*)(skb))->mac_len |= CHAINED)
+#define	PKTCLRCHAINED(osh, skb)	(((struct sk_buff*)(skb))->mac_len &= (~CHAINED))
+#define	PKTISCHAINED(skb)	(((struct sk_buff*)(skb))->mac_len & CHAINED)
 #else 
 #define	SKIPCT	(1 << 2)
+#define	CHAINED	(1 << 3)
 #define	PKTSETSKIPCT(osh, skb)	(((struct sk_buff*)(skb))->__unused |= SKIPCT)
 #define	PKTCLRSKIPCT(osh, skb)	(((struct sk_buff*)(skb))->__unused &= (~SKIPCT))
 #define	PKTSKIPCT(osh, skb)	(((struct sk_buff*)(skb))->__unused & SKIPCT)
+#define	PKTSETCHAINED(osh, skb)	(((struct sk_buff*)(skb))->__unused |= CHAINED)
+#define	PKTCLRCHAINED(osh, skb)	(((struct sk_buff*)(skb))->__unused &= (~CHAINED))
+#define	PKTISCHAINED(skb)	(((struct sk_buff*)(skb))->__unused & CHAINED)
 #endif 
+typedef struct ctf_mark {
+	uint32	value;
+}	ctf_mark_t;
+#define CTF_MARK(m)				(m.value)
 #else 
 #define	PKTSETSKIPCT(osh, skb)
 #define	PKTCLRSKIPCT(osh, skb)
 #define	PKTSKIPCT(osh, skb)
+#define CTF_MARK(m)				0
 #endif 
 
 extern void osl_pktfree(osl_t *osh, void *skb, bool send);
 extern void *osl_pktget_static(osl_t *osh, uint len);
 extern void osl_pktfree_static(osl_t *osh, void *skb, bool send);
 
+#ifdef BCMDBG_CTRACE
+#define PKT_CTRACE_DUMP(osh, b)	osl_ctrace_dump((osh), (b))
+extern void *osl_pktget(osl_t *osh, uint len, int line, char *file);
+extern void *osl_pkt_frmnative(osl_t *osh, void *skb, int line, char *file);
+extern int osl_pkt_is_frmnative(osl_t *osh, struct sk_buff *pkt);
+extern void *osl_pktdup(osl_t *osh, void *skb, int line, char *file);
+struct bcmstrbuf;
+extern void osl_ctrace_dump(osl_t *osh, struct bcmstrbuf *b);
+#else
 extern void *osl_pkt_frmnative(osl_t *osh, void *skb);
 extern void *osl_pktget(osl_t *osh, uint len);
 extern void *osl_pktdup(osl_t *osh, void *skb);
+#endif 
 extern struct sk_buff *osl_pkt_tonative(osl_t *osh, void *pkt);
+#ifdef BCMDBG_CTRACE
+#define PKTFRMNATIVE(osh, skb)  osl_pkt_frmnative(((osl_t *)osh), \
+				(struct sk_buff*)(skb), __LINE__, __FILE__)
+#define	PKTISFRMNATIVE(osh, skb) osl_pkt_is_frmnative((osl_t *)(osh), (struct sk_buff *)(skb))
+#else
 #define PKTFRMNATIVE(osh, skb)	osl_pkt_frmnative(((osl_t *)osh), (struct sk_buff*)(skb))
+#endif 
 #define PKTTONATIVE(osh, pkt)		osl_pkt_tonative((osl_t *)(osh), (pkt))
 
 #define	PKTLINK(skb)			(((struct sk_buff*)(skb))->prev)
@@ -357,8 +442,24 @@ extern struct sk_buff *osl_pkt_tonative(osl_t *osh, void *pkt);
 
 #define PKTSHARED(skb)                  (((struct sk_buff*)(skb))->cloned)
 
+#ifdef CONFIG_NF_CONNTRACK_MARK
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))
+#define PKTMARK(p)                     (((struct sk_buff *)(p))->mark)
+#define PKTSETMARK(p, m)               ((struct sk_buff *)(p))->mark = (m)
+#else 
+#define PKTMARK(p)                     (((struct sk_buff *)(p))->nfmark)
+#define PKTSETMARK(p, m)               ((struct sk_buff *)(p))->nfmark = (m)
+#endif 
+#else 
+#define PKTMARK(p)                     0
+#define PKTSETMARK(p, m)
+#endif 
+
+#define PKTALLOCED(osh)		osl_pktalloced(osh)
+extern uint osl_pktalloced(osl_t *osh);
+
 #define	DMA_MAP(osh, va, size, direction, p, dmah) \
-	osl_dma_map((osh), (va), (size), (direction))
+	osl_dma_map((osh), (va), (size), (direction), (p), (dmah))
 
 #ifdef PKTC
 
@@ -367,33 +468,52 @@ struct chain_node {
 	unsigned int	flags:3, pkts:9, bytes:20;
 };
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 14)
-#define CHAIN_NODE(skb)		((struct chain_node*)&(((struct sk_buff*)skb)->tstamp))
-#else
-#define CHAIN_NODE(skb)		((struct chain_node*)&(((struct sk_buff*)skb)->stamp))
-#endif
+#define CHAIN_NODE(skb)		((struct chain_node*)(((struct sk_buff*)skb)->pktc_cb))
 
+#define	PKTCSETATTR(s, f, p, b)	({CHAIN_NODE(s)->flags = (f); CHAIN_NODE(s)->pkts = (p); \
+	                         CHAIN_NODE(s)->bytes = (b);})
+#define	PKTCCLRATTR(s)		({CHAIN_NODE(s)->flags = CHAIN_NODE(s)->pkts = \
+	                         CHAIN_NODE(s)->bytes = 0;})
+#define	PKTCGETATTR(s)		(CHAIN_NODE(s)->flags << 29 | CHAIN_NODE(s)->pkts << 20 | \
+	                         CHAIN_NODE(s)->bytes)
 #define	PKTCCNT(skb)		(CHAIN_NODE(skb)->pkts)
 #define	PKTCLEN(skb)		(CHAIN_NODE(skb)->bytes)
+#define	PKTCGETFLAGS(skb)	(CHAIN_NODE(skb)->flags)
+#define	PKTCSETFLAGS(skb, f)	(CHAIN_NODE(skb)->flags = (f))
+#define	PKTCCLRFLAGS(skb)	(CHAIN_NODE(skb)->flags = 0)
 #define	PKTCFLAGS(skb)		(CHAIN_NODE(skb)->flags)
-#define	PKTCSETCNT(skb, c)	(CHAIN_NODE(skb)->pkts = (c) & ((1 << 9) - 1))
-#define	PKTCSETLEN(skb, l)	(CHAIN_NODE(skb)->bytes = (l) & ((1 << 20) - 1))
+#define	PKTCSETCNT(skb, c)	(CHAIN_NODE(skb)->pkts = (c))
+#define	PKTCINCRCNT(skb)	(CHAIN_NODE(skb)->pkts++)
+#define	PKTCADDCNT(skb, c)	(CHAIN_NODE(skb)->pkts += (c))
+#define	PKTCSETLEN(skb, l)	(CHAIN_NODE(skb)->bytes = (l))
+#define	PKTCADDLEN(skb, l)	(CHAIN_NODE(skb)->bytes += (l))
 #define	PKTCSETFLAG(skb, fb)	(CHAIN_NODE(skb)->flags |= (fb))
 #define	PKTCCLRFLAG(skb, fb)	(CHAIN_NODE(skb)->flags &= ~(fb))
 #define	PKTCLINK(skb)		(CHAIN_NODE(skb)->link)
 #define	PKTSETCLINK(skb, x)	(CHAIN_NODE(skb)->link = (struct sk_buff*)(x))
-#define	PKTISCHAINED(skb)	(PKTCLINK(skb) != NULL)
 #define FOREACH_CHAINED_PKT(skb, nskb) \
 	for (; (skb) != NULL; (skb) = (nskb)) \
-		if ((nskb) = PKTCLINK(skb), PKTSETCLINK((skb), NULL), 1)
+		if ((nskb) = (PKTISCHAINED(skb) ? PKTCLINK(skb) : NULL), \
+		    PKTSETCLINK((skb), NULL), 1)
 #define	PKTCFREE(osh, skb, send) \
 do { \
 	void *nskb; \
 	ASSERT((skb) != NULL); \
 	FOREACH_CHAINED_PKT((skb), nskb) { \
+		PKTCLRCHAINED((osh), (skb)); \
+		PKTCCLRFLAGS((skb)); \
 		PKTFREE((osh), (skb), (send)); \
 	} \
 } while (0)
+#define PKTCENQTAIL(h, t, p) \
+do { \
+	if ((t) == NULL) { \
+		(h) = (t) = (p); \
+	} else { \
+		PKTSETCLINK((t), (p)); \
+		(t) = (p); \
+	} \
+} while (0)
 #endif 
 
 #else 
diff --git a/drivers/net/wireless/bcmdhd/include/linuxver.h b/drivers/net/wireless/bcmdhd/include/linuxver.h
old mode 100644
new mode 100755
index e59ac88..396d1ab
--- a/drivers/net/wireless/bcmdhd/include/linuxver.h
+++ b/drivers/net/wireless/bcmdhd/include/linuxver.h
@@ -2,27 +2,9 @@
  * Linux-specific abstractions to gain some independence from linux kernel versions.
  * Pave over some 2.2 versus 2.4 versus 2.6 kernel differences.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: linuxver.h 315203 2012-02-16 00:58:00Z $
+ * $Id: linuxver.h 389248 2013-03-06 02:00:33Z $
  */
 
 #ifndef _linuxver_h_
@@ -95,18 +77,20 @@
 #ifndef flush_scheduled_work
 #define flush_scheduled_work() flush_scheduled_tasks()
 #endif
-#endif
+#endif	
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))
 #define DAEMONIZE(a) daemonize(a); \
 	allow_signal(SIGKILL); \
 	allow_signal(SIGTERM);
-#else /* Linux 2.4 (w/o preemption patch) */
+#else 
+#define RAISE_RX_SOFTIRQ() \
+	cpu_raise_softirq(smp_processor_id(), NET_RX_SOFTIRQ)
 #define DAEMONIZE(a) daemonize(); \
 	do { if (a) \
-		strncpy(current->comm, a, MIN(sizeof(current->comm), (strlen(a)
+		strncpy(current->comm, a, MIN(sizeof(current->comm), (strlen(a)))); \
 	} while (0);
-#endif /* LINUX_VERSION_CODE  */
+#endif 
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
 #define	MY_INIT_WORK(_work, _func)	INIT_WORK(_work, _func)
@@ -162,6 +146,7 @@ typedef irqreturn_t(*FN_ISR) (int irq, void *dev_id, struct pt_regs *ptregs);
 #endif 
 
 
+
 #ifndef __exit
 #define __exit
 #endif
@@ -481,6 +466,7 @@ pci_restore_state(struct pci_dev *dev, u32 *buffer)
 
 typedef struct {
 	void 	*parent;  
+	char 	*proc_name;
 	struct	task_struct *p_task;
 	long 	thr_pid;
 	int 	prio; 
@@ -504,18 +490,34 @@ typedef struct {
 #define SMP_RD_BARRIER_DEPENDS(x) smp_rmb(x)
 #endif
 
-
-#define PROC_START(thread_func, owner, tsk_ctl, flags) \
+#ifdef USE_KTHREAD_API
+#define PROC_START(thread_func, owner, tsk_ctl, flags, name) \
+{ \
+	sema_init(&((tsk_ctl)->sema), 0); \
+	init_completion(&((tsk_ctl)->completed)); \
+	(tsk_ctl)->parent = owner; \
+	(tsk_ctl)->proc_name = name;  \
+	(tsk_ctl)->terminated = FALSE; \
+	(tsk_ctl)->p_task  = kthread_run(thread_func, tsk_ctl, (char*)name); \
+	(tsk_ctl)->thr_pid = (tsk_ctl)->p_task->pid; \
+	DBG_THR(("%s(): thread:%s:%lx started\n", __FUNCTION__, \
+		(tsk_ctl)->proc_name, (tsk_ctl)->thr_pid)); \
+}
+#else
+#define PROC_START(thread_func, owner, tsk_ctl, flags, name) \
 { \
 	sema_init(&((tsk_ctl)->sema), 0); \
 	init_completion(&((tsk_ctl)->completed)); \
 	(tsk_ctl)->parent = owner; \
+	(tsk_ctl)->proc_name = name;  \
 	(tsk_ctl)->terminated = FALSE; \
 	(tsk_ctl)->thr_pid = kernel_thread(thread_func, tsk_ctl, flags); \
 	if ((tsk_ctl)->thr_pid > 0) \
 		wait_for_completion(&((tsk_ctl)->completed)); \
-	DBG_THR(("%s thr:%lx started\n", __FUNCTION__, (tsk_ctl)->thr_pid)); \
+	DBG_THR(("%s(): thread:%s:%lx started\n", __FUNCTION__, \
+		(tsk_ctl)->proc_name, (tsk_ctl)->thr_pid)); \
 }
+#endif 
 
 #define PROC_STOP(tsk_ctl) \
 { \
@@ -523,7 +525,8 @@ typedef struct {
 	smp_wmb(); \
 	up(&((tsk_ctl)->sema));	\
 	wait_for_completion(&((tsk_ctl)->completed)); \
-	DBG_THR(("%s thr:%lx terminated OK\n", __FUNCTION__, (tsk_ctl)->thr_pid)); \
+	DBG_THR(("%s(): thread:%s:%lx terminated OK\n", __FUNCTION__, \
+			 (tsk_ctl)->proc_name, (tsk_ctl)->thr_pid)); \
 	(tsk_ctl)->thr_pid = -1; \
 }
 
diff --git a/drivers/net/wireless/bcmdhd/include/miniopt.h b/drivers/net/wireless/bcmdhd/include/miniopt.h
old mode 100644
new mode 100755
index c1eca68..6c13070
--- a/drivers/net/wireless/bcmdhd/include/miniopt.h
+++ b/drivers/net/wireless/bcmdhd/include/miniopt.h
@@ -1,25 +1,7 @@
 /*
  * Command line options parser.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  * $Id: miniopt.h 241182 2011-02-17 21:50:03Z $
  */
 
diff --git a/drivers/net/wireless/bcmdhd/include/msgtrace.h b/drivers/net/wireless/bcmdhd/include/msgtrace.h
old mode 100644
new mode 100755
index 7c5fd81..3f18463
--- a/drivers/net/wireless/bcmdhd/include/msgtrace.h
+++ b/drivers/net/wireless/bcmdhd/include/msgtrace.h
@@ -1,27 +1,9 @@
 /*
  * Trace messages sent over HBUS
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: msgtrace.h 281527 2011-09-02 17:12:53Z $
+ * $Id: msgtrace.h 369735 2012-11-19 22:50:22Z $
  */
 
 #ifndef	_MSGTRACE_H
@@ -40,11 +22,14 @@
 /* Message trace header */
 typedef BWL_PRE_PACKED_STRUCT struct msgtrace_hdr {
 	uint8	version;
-	uint8   spare;
+	uint8   trace_type;
+#define MSGTRACE_HDR_TYPE_MSG 0
+#define MSGTRACE_HDR_TYPE_LOG 1
 	uint16	len;	/* Len of the trace */
 	uint32	seqnum;	/* Sequence number of message. Useful if the messsage has been lost
 			 * because of DMA error or a bus reset (ex: SDIO Func2)
 			 */
+	/* Msgtrace type  only */
 	uint32  discarded_bytes;  /* Number of discarded bytes because of trace overflow  */
 	uint32  discarded_printf; /* Number of discarded printf because of trace overflow */
 } BWL_POST_PACKED_STRUCT msgtrace_hdr_t;
@@ -63,7 +48,7 @@ typedef void (*msgtrace_func_send_t)(void *hdl1, void *hdl2, uint8 *hdr,
                                      uint16 hdrlen, uint8 *buf, uint16 buflen);
 extern void msgtrace_start(void);
 extern void msgtrace_stop(void);
-extern void msgtrace_sent(void);
+extern int msgtrace_sent(void);
 extern void msgtrace_put(char *buf, int count);
 extern void msgtrace_init(void *hdl1, void *hdl2, msgtrace_func_send_t func_send);
 extern bool msgtrace_event_enabled(void);
diff --git a/drivers/net/wireless/bcmdhd/include/osl.h b/drivers/net/wireless/bcmdhd/include/osl.h
old mode 100644
new mode 100755
index ca171d8..aeeed83
--- a/drivers/net/wireless/bcmdhd/include/osl.h
+++ b/drivers/net/wireless/bcmdhd/include/osl.h
@@ -1,27 +1,9 @@
 /*
  * OS Abstraction Layer
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: osl.h 320905 2012-03-13 15:33:25Z $
+ * $Id: osl.h 370064 2012-11-20 21:00:25Z $
  */
 
 #ifndef _osl_h_
@@ -69,20 +51,33 @@ typedef void  (*osl_wreg_fn_t)(void *ctx, volatile void *reg, unsigned int val,
 #endif 
 
 #if !defined(PKTC)
-#define	PKTCCNT(skb)		(0)
-#define	PKTCLEN(skb)		(0)
+#define	PKTCGETATTR(s)		(0)
+#define	PKTCSETATTR(skb, f, p, b)
+#define	PKTCCLRATTR(skb)
+#define	PKTCCNT(skb)		(1)
+#define	PKTCLEN(skb)		PKTLEN(NULL, skb)
+#define	PKTCGETFLAGS(skb)	(0)
+#define	PKTCSETFLAGS(skb, f)
+#define	PKTCCLRFLAGS(skb)
 #define	PKTCFLAGS(skb)		(0)
 #define	PKTCSETCNT(skb, c)
+#define	PKTCINCRCNT(skb)
+#define	PKTCADDCNT(skb, c)
 #define	PKTCSETLEN(skb, l)
+#define	PKTCADDLEN(skb, l)
 #define	PKTCSETFLAG(skb, fb)
 #define	PKTCCLRFLAG(skb, fb)
-#define	PKTCLINK(skb)		PKTLINK(skb)
-#define	PKTSETCLINK(skb, x)	PKTSETLINK((skb), (x))
-#define	PKTISCHAINED(skb)	FALSE
+#define	PKTCLINK(skb)		NULL
+#define	PKTSETCLINK(skb, x)
 #define FOREACH_CHAINED_PKT(skb, nskb) \
 	for ((nskb) = NULL; (skb) != NULL; (skb) = (nskb))
 #define	PKTCFREE		PKTFREE
-#endif
+#endif 
 
+#ifndef HNDCTF
+#define PKTSETCHAINED(osh, skb)
+#define PKTCLRCHAINED(osh, skb)
+#define PKTISCHAINED(skb)	(FALSE)
+#endif
 
 #endif	
diff --git a/drivers/net/wireless/bcmdhd/include/packed_section_end.h b/drivers/net/wireless/bcmdhd/include/packed_section_end.h
old mode 100644
new mode 100755
index 24ff467..761838c
--- a/drivers/net/wireless/bcmdhd/include/packed_section_end.h
+++ b/drivers/net/wireless/bcmdhd/include/packed_section_end.h
@@ -15,25 +15,7 @@
  * #include <packed_section_end.h>
  *
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  * $Id: packed_section_end.h 241182 2011-02-17 21:50:03Z $
  */
 
diff --git a/drivers/net/wireless/bcmdhd/include/packed_section_start.h b/drivers/net/wireless/bcmdhd/include/packed_section_start.h
old mode 100644
new mode 100755
index 7fce0dd..ba00dbd
--- a/drivers/net/wireless/bcmdhd/include/packed_section_start.h
+++ b/drivers/net/wireless/bcmdhd/include/packed_section_start.h
@@ -15,25 +15,7 @@
  * #include <packed_section_end.h>
  *
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  * $Id: packed_section_start.h 286783 2011-09-29 06:18:57Z $
  */
 
diff --git a/drivers/net/wireless/bcmdhd/include/pcicfg.h b/drivers/net/wireless/bcmdhd/include/pcicfg.h
old mode 100644
new mode 100755
index 5f7df6a..312027c6
--- a/drivers/net/wireless/bcmdhd/include/pcicfg.h
+++ b/drivers/net/wireless/bcmdhd/include/pcicfg.h
@@ -1,27 +1,9 @@
 /*
  * pcicfg.h: PCI configuration constants and structures.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: pcicfg.h 309193 2012-01-19 00:03:57Z $
+ * $Id: pcicfg.h 346935 2012-07-25 00:24:55Z $
  */
 
 #ifndef	_h_pcicfg_
@@ -55,6 +37,7 @@
 #define	PCI_CFG_PIN		0x3d
 #define	PCI_CFG_MINGNT		0x3e
 #define	PCI_CFG_MAXLAT		0x3f
+#define	PCI_CFG_DEVCTRL		0xd8
 #define	PCI_BAR0_WIN		0x80	
 #define	PCI_BAR1_WIN		0x84	
 #define	PCI_SPROM_CONTROL	0x88	
diff --git a/drivers/net/wireless/bcmdhd/include/proto/802.11.h b/drivers/net/wireless/bcmdhd/include/proto/802.11.h
old mode 100644
new mode 100755
index bd0942e..143f979
--- a/drivers/net/wireless/bcmdhd/include/proto/802.11.h
+++ b/drivers/net/wireless/bcmdhd/include/proto/802.11.h
@@ -1,27 +1,9 @@
 /*
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * Fundamental types and constants relating to 802.11
  *
- * $Id: 802.11.h 328824 2012-04-20 22:51:46Z $
+ * $Id: 802.11.h 386067 2013-02-19 15:24:20Z $
  */
 
 #ifndef _802_11_H_
@@ -294,6 +276,12 @@ BWL_PRE_PACKED_STRUCT struct dot11_action_sa_query {
 	uint16	id;
 } BWL_POST_PACKED_STRUCT;
 
+BWL_PRE_PACKED_STRUCT struct dot11_action_vht_oper_mode {
+	uint8	category;
+	uint8	action;
+	uint8	mode;
+} BWL_POST_PACKED_STRUCT;
+
 #define SM_PWRSAVE_ENABLE	1
 #define SM_PWRSAVE_MODE		2
 
@@ -410,6 +398,36 @@ BWL_PRE_PACKED_STRUCT struct dot11y_action_ext_csa {
 	struct dot11_csa_body b;	
 } BWL_POST_PACKED_STRUCT;
 
+
+BWL_PRE_PACKED_STRUCT struct dot11_wide_bw_channel_switch {
+	uint8 id;				
+	uint8 len;				
+	uint8 channel_width;			
+	uint8 center_frequency_segment_0;	
+	uint8 center_frequency_segment_1;	
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_wide_bw_channel_switch dot11_wide_bw_chan_switch_ie_t;
+
+#define DOT11_WIDE_BW_SWITCH_IE_LEN     3       
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_channel_switch_wrapper {
+	uint8 id;				
+	uint8 len;				
+	dot11_wide_bw_chan_switch_ie_t wb_chan_switch_ie;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_channel_switch_wrapper dot11_chan_switch_wrapper_ie_t;
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_vht_transmit_power_envelope {
+	uint8 id;				
+	uint8 len;				
+	uint8 transmit_power_info;
+	uint8 local_max_transmit_power_20;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_vht_transmit_power_envelope dot11_vht_transmit_power_envelope_ie_t;
+
+
 BWL_PRE_PACKED_STRUCT struct dot11_obss_coex {
 	uint8	id;
 	uint8	len;
@@ -438,25 +456,40 @@ BWL_PRE_PACKED_STRUCT struct dot11_extcap_ie {
 } BWL_POST_PACKED_STRUCT;
 typedef struct dot11_extcap_ie dot11_extcap_ie_t;
 
-#define DOT11_EXTCAP_LEN_MAX	7
+#define DOT11_EXTCAP_LEN_MAX	8
+
 #define DOT11_EXTCAP_LEN_COEX	1
 #define DOT11_EXTCAP_LEN_BT	3
 #define DOT11_EXTCAP_LEN_IW	4
 #define DOT11_EXTCAP_LEN_SI	6
 
 #define DOT11_EXTCAP_LEN_TDLS	5
+#define DOT11_11AC_EXTCAP_LEN_TDLS	8
+
+#define DOT11_EXTCAP_LEN_FMS			2
+#define DOT11_EXTCAP_LEN_PROXY_ARP		2
+#define DOT11_EXTCAP_LEN_TFS			3
+#define DOT11_EXTCAP_LEN_WNM_SLEEP		3
+#define DOT11_EXTCAP_LEN_TIMBC			3
+#define DOT11_EXTCAP_LEN_BSSTRANS		3
+#define DOT11_EXTCAP_LEN_DMS			4
+#define DOT11_EXTCAP_LEN_WNM_NOTIFICATION	6
+#define DOT11_EXTCAP_LEN_TDLS_WBW		8
+#define DOT11_EXTCAP_LEN_OPMODE_NOTIFICATION	8
+
 BWL_PRE_PACKED_STRUCT struct dot11_extcap {
-	uint8 extcap[DOT11_EXTCAP_LEN_TDLS];
+	uint8 extcap[DOT11_EXTCAP_LEN_MAX];
 } BWL_POST_PACKED_STRUCT;
 typedef struct dot11_extcap dot11_extcap_t;
 
 
-#define TDLS_CAP_TDLS			37		
-#define TDLS_CAP_PU_BUFFER_STA	28		
-#define TDLS_CAP_PEER_PSM		20		
-#define TDLS_CAP_CH_SW			30		
-#define TDLS_CAP_PROH			38		
-#define TDLS_CAP_CH_SW_PROH		39		
+#define DOT11_TDLS_CAP_TDLS			37		
+#define DOT11_TDLS_CAP_PU_BUFFER_STA	28		
+#define DOT11_TDLS_CAP_PEER_PSM		20		
+#define DOT11_TDLS_CAP_CH_SW			30		
+#define DOT11_TDLS_CAP_PROH			38		
+#define DOT11_TDLS_CAP_CH_SW_PROH		39		
+#define DOT11_TDLS_CAP_TDLS_WIDER_BW	61	
 
 #define TDLS_CAP_MAX_BIT		39		
 
@@ -469,7 +502,7 @@ typedef struct dot11_extcap dot11_extcap_t;
 #define DOT11_MEASURE_TYPE_NOISE		4	
 #define DOT11_MEASURE_TYPE_BEACON		5	
 #define DOT11_MEASURE_TYPE_FRAME	6	
-#define DOT11_MEASURE_TYPE_STATS		7	
+#define DOT11_MEASURE_TYPE_STAT		7	
 #define DOT11_MEASURE_TYPE_LCI		8	
 #define DOT11_MEASURE_TYPE_TXSTREAM		9	
 #define DOT11_MEASURE_TYPE_PAUSE		255	
@@ -847,6 +880,7 @@ typedef struct ti_ie ti_ie_t;
 #define FC_SUBTYPE_ANY_NULL(s)		(((s) & 4) != 0)
 #define FC_SUBTYPE_ANY_CF_POLL(s)	(((s) & 2) != 0)
 #define FC_SUBTYPE_ANY_CF_ACK(s)	(((s) & 1) != 0)
+#define FC_SUBTYPE_ANY_PSPOLL(s)	(((s) & 10) != 0)
 
 
 #define FC_KIND_MASK		(FC_TYPE_MASK | FC_SUBTYPE_MASK)	
@@ -990,10 +1024,11 @@ typedef struct ti_ie ti_ie_t;
 #define DOT11_SC_ASSOC_BAD_SUP_CHANNELS	24	
 #define DOT11_SC_ASSOC_SHORTSLOT_REQUIRED	25	
 #define DOT11_SC_ASSOC_ERPBCC_REQUIRED	26	
-#define DOT11_SC_ASSOC_DSSOFDM_REQUIRED	27	
+#define DOT11_SC_ASSOC_DSSSOFDM_REQUIRED	27	
 #define DOT11_SC_ASSOC_R0KH_UNREACHABLE	28	
 #define DOT11_SC_ASSOC_TRY_LATER	30	
 #define DOT11_SC_ASSOC_MFP_VIOLATION	31	
+#define DOT11_SC_ASSOC_HT_REQUIRED	32	
 
 #define	DOT11_SC_DECLINED		37	
 #define	DOT11_SC_INVALID_PARAMS		38	
@@ -1005,9 +1040,19 @@ typedef struct ti_ie ti_ie_t;
 #define	DOT11_SC_INVALID_MDID		54	
 #define	DOT11_SC_INVALID_FTIE		55	
 
+#define DOT11_SC_ADV_PROTO_NOT_SUPPORTED	59	
+#define DOT11_SC_NO_OUTSTAND_REQ			60	
+#define DOT11_SC_RSP_NOT_RX_FROM_SERVER		61	
+#define DOT11_SC_TIMEOUT					62	
+#define DOT11_SC_QUERY_RSP_TOO_LARGE		63	
+#define DOT11_SC_SERVER_UNREACHABLE			65	
+
 #define DOT11_SC_UNEXP_MSG			70	
 #define DOT11_SC_INVALID_SNONCE		71	
 #define DOT11_SC_INVALID_RSNIE		72	
+#define DOT11_SC_ASSOC_VHT_REQUIRED	104	
+
+#define DOT11_SC_TRANSMIT_FAILURE	79	
 
 
 #define DOT11_MNG_DS_PARAM_LEN			1	
@@ -1040,6 +1085,8 @@ typedef struct ti_ie ti_ie_t;
 #define DOT11_MNG_REQUEST_ID			10	
 #define DOT11_MNG_QBSS_LOAD_ID 			11	
 #define DOT11_MNG_EDCA_PARAM_ID			12	
+#define DOT11_MNG_TSPEC_ID			13	
+#define DOT11_MNG_TCLAS_ID			14	
 #define DOT11_MNG_CHALLENGE_ID			16	
 #define DOT11_MNG_PWR_CONSTRAINT_ID		32	
 #define DOT11_MNG_PWR_CAP_ID			33	
@@ -1053,31 +1100,50 @@ typedef struct ti_ie ti_ie_t;
 #define DOT11_MNG_IBSS_DFS_ID			41	
 #define DOT11_MNG_ERP_ID			42	
 #define DOT11_MNG_TS_DELAY_ID			43	
+#define DOT11_MNG_TCLAS_PROC_ID			44	
 #define	DOT11_MNG_HT_CAP			45	
 #define DOT11_MNG_QOS_CAP_ID			46	
 #define DOT11_MNG_NONERP_ID			47	
 #define DOT11_MNG_RSN_ID			48	
 #define DOT11_MNG_EXT_RATES_ID			50	
-#define DOT11_MNG_AP_CHREP_ID		51	
-#define DOT11_MNG_NBR_REP_ID		52	
-#define DOT11_MNG_MDIE_ID		54	
-#define DOT11_MNG_FTIE_ID		55	
-#define DOT11_MNG_FT_TI_ID		56	
+#define DOT11_MNG_AP_CHREP_ID			51	
+#define DOT11_MNG_NEIGHBOR_REP_ID		52	
+#define DOT11_MNG_RCPI_ID			53	
+#define DOT11_MNG_MDIE_ID			54	
+#define DOT11_MNG_FTIE_ID			55	
+#define DOT11_MNG_FT_TI_ID			56	
+#define DOT11_MNG_RDE_ID			57	
 #define	DOT11_MNG_REGCLASS_ID			59	
 #define DOT11_MNG_EXT_CSA_ID			60	
 #define	DOT11_MNG_HT_ADD			61	
 #define	DOT11_MNG_EXT_CHANNEL_OFFSET		62	
+#define DOT11_MNG_BSS_AVR_ACCESS_DELAY_ID	63	
+#define DOT11_MNG_ANTENNA_ID			64	
+#define DOT11_MNG_RSNI_ID			65	
+#define DOT11_MNG_MEASUREMENT_PILOT_TX_ID	66	
+#define DOT11_MNG_BSS_AVAL_ADMISSION_CAP_ID	67	
+#define DOT11_MNG_BSS_AC_ACCESS_DELAY_ID	68	
 #define DOT11_MNG_WAPI_ID			68	
 #define DOT11_MNG_TIME_ADVERTISE_ID	69	
 #define DOT11_MNG_RRM_CAP_ID		70	
+#define DOT11_MNG_MULTIPLE_BSSID_ID		71	
 #define	DOT11_MNG_HT_BSS_COEXINFO_ID		72	
 #define	DOT11_MNG_HT_BSS_CHANNEL_REPORT_ID	73	
 #define	DOT11_MNG_HT_OBSS_ID			74	
-#define DOT11_MNG_CHANNEL_USAGE			97 
+#define DOT11_MNG_MMIE_ID			76	
+#define DOT11_MNG_BSS_MAX_IDLE_PERIOD_ID	90	
+#define DOT11_MNG_TFS_REQUEST_ID		91	
+#define DOT11_MNG_TFS_RESPONSE_ID		92	
+#define DOT11_MNG_WNM_SLEEP_MODE_ID		93	
+#define DOT11_MNG_TIMBC_REQ_ID			94	
+#define DOT11_MNG_TIMBC_RESP_ID			95	
+#define DOT11_MNG_CHANNEL_USAGE			97	
 #define DOT11_MNG_TIME_ZONE_ID			98	
-#define DOT11_MNG_LINK_IDENTIFIER_ID	101	
-#define DOT11_MNG_WAKEUP_SCHEDULE_ID	102 
-#define DOT11_MNG_CHANNEL_SWITCH_TIMING_ID	104 
+#define DOT11_MNG_DMS_REQUEST_ID		99	
+#define DOT11_MNG_DMS_RESPONSE_ID		100	
+#define DOT11_MNG_LINK_IDENTIFIER_ID		101	
+#define DOT11_MNG_WAKEUP_SCHEDULE_ID		102	
+#define DOT11_MNG_CHANNEL_SWITCH_TIMING_ID	104	
 #define DOT11_MNG_PTI_CONTROL_ID		105	
 #define DOT11_MNG_PU_BUFFER_STATUS_ID	106	
 #define DOT11_MNG_INTERWORKING_ID		107	
@@ -1086,9 +1152,15 @@ typedef struct ti_ie ti_ie_t;
 #define DOT11_MNG_QOS_MAP_ID			110	
 #define DOT11_MNG_ROAM_CONSORT_ID		111	
 #define DOT11_MNG_EMERGCY_ALERT_ID		112	
-#define	DOT11_MNG_EXT_CAP_ID		127	
-#define	DOT11_MNG_VHT_CAP_ID		191	
-#define	DOT11_MNG_VHT_OPERATION_ID	192	
+#define	DOT11_MNG_EXT_CAP_ID			127	
+#define	DOT11_MNG_VHT_CAP_ID			191	
+#define	DOT11_MNG_VHT_OPERATION_ID		192	
+#define DOT11_MNG_WIDE_BW_CHANNEL_SWITCH_ID		194	
+#define DOT11_MNG_VHT_TRANSMIT_POWER_ENVELOPE_ID	195	
+#define DOT11_MNG_CHANNEL_SWITCH_WRAPPER_ID		196	
+#define DOT11_MNG_AID_ID					197	
+#define	DOT11_MNG_OPER_MODE_NOTIF_ID	199	
+
 
 #define DOT11_MNG_WPA_ID			221	
 #define DOT11_MNG_PROPR_ID			221	
@@ -1096,8 +1168,30 @@ typedef struct ti_ie ti_ie_t;
 #define DOT11_MNG_VS_ID				221	
 
 
-#define DOT11_RATE_BASIC			0x80	
-#define DOT11_RATE_MASK				0x7F	
+
+
+
+#define DOT11_RATE_1M   2       
+#define DOT11_RATE_2M   4       
+#define DOT11_RATE_5M5  11      
+#define DOT11_RATE_11M  22      
+#define DOT11_RATE_6M   12      
+#define DOT11_RATE_9M   18      
+#define DOT11_RATE_12M  24      
+#define DOT11_RATE_18M  36      
+#define DOT11_RATE_24M  48      
+#define DOT11_RATE_36M  72      
+#define DOT11_RATE_48M  96      
+#define DOT11_RATE_54M  108     
+#define DOT11_RATE_MAX  108     
+
+
+#define DOT11_RATE_BASIC                0x80 
+#define DOT11_RATE_MASK                 0x7F 
+
+
+#define DOT11_BSS_MEMBERSHIP_HT         0xFF  
+#define DOT11_BSS_MEMBERSHIP_VHT        0xFE  
 
 
 #define DOT11_MNG_ERP_LEN			1	
@@ -1118,22 +1212,95 @@ typedef struct ti_ie ti_ie_t;
 #define DOT11_CAP_PBCC				0x0040	
 #define DOT11_CAP_AGILITY			0x0080	
 #define DOT11_CAP_SPECTRUM			0x0100	
+#define DOT11_CAP_QOS				0x0200	
 #define DOT11_CAP_SHORTSLOT			0x0400	
-#define DOT11_CAP_RRM			0x1000	
+#define DOT11_CAP_APSD				0x0800	
+#define DOT11_CAP_RRM				0x1000	
 #define DOT11_CAP_CCK_OFDM			0x2000	
+#define DOT11_CAP_DELAY_BA			0x4000	
+#define DOT11_CAP_IMMEDIATE_BA			0x8000	
 
 
 
 #define DOT11_EXT_CAP_OBSS_COEX_MGMT		0
 
-#define DOT11_EXT_CAP_SPSMP					6
+#define DOT11_EXT_CAP_SPSMP			6
+
+#define DOT11_EXT_CAP_FMS			11
+
+#define DOT11_EXT_CAP_PROXY_ARP			12
+
+#define DOT11_EXT_CAP_TFS			16
 
-#define DOT11_EXT_CAP_BSS_TRANSITION_MGMT	19
+#define DOT11_EXT_CAP_WNM_SLEEP			17
 
-#define DOT11_EXT_CAP_IW						31
+#define DOT11_EXT_CAP_TIMBC			18
 
-#define DOT11_EXT_CAP_SI						41
-#define DOT11_EXT_CAP_SI_MASK					0x0E
+#define DOT11_EXT_CAP_BSSTRANS_MGMT		19
+
+#define DOT11_EXT_CAP_DMS			26
+
+#define DOT11_EXT_CAP_IW			31
+
+#define DOT11_EXT_CAP_SI			41
+#define DOT11_EXT_CAP_SI_MASK			0x0E
+
+#define DOT11_EXT_CAP_WNM_NOTIF			46
+
+#define DOT11_EXT_CAP_OPER_MODE_NOTIF		62
+
+
+#define DOT11_OPER_MODE_CHANNEL_WIDTH_SHIFT 0
+#define DOT11_OPER_MODE_CHANNEL_WIDTH_MASK 0x3
+#define DOT11_OPER_MODE_RXNSS_SHIFT 4
+#define DOT11_OPER_MODE_RXNSS_MASK 0x70
+#define DOT11_OPER_MODE_RXNSS_TYPE_SHIFT 7
+#define DOT11_OPER_MODE_RXNSS_TYPE_MASK 0x80
+
+#define DOT11_OPER_MODE(type, nss, chanw) (\
+	((type) << DOT11_OPER_MODE_RXNSS_TYPE_SHIFT &\
+		 DOT11_OPER_MODE_RXNSS_TYPE_MASK) |\
+	(((nss) - 1) << DOT11_OPER_MODE_RXNSS_SHIFT & DOT11_OPER_MODE_RXNSS_MASK) |\
+	((chanw) << DOT11_OPER_MODE_CHANNEL_WIDTH_SHIFT &\
+		 DOT11_OPER_MODE_CHANNEL_WIDTH_MASK))
+
+#define DOT11_OPER_MODE_CHANNEL_WIDTH(mode) \
+	(((mode) & DOT11_OPER_MODE_CHANNEL_WIDTH_MASK)\
+		>> DOT11_OPER_MODE_CHANNEL_WIDTH_SHIFT)
+#define DOT11_OPER_MODE_RXNSS(mode) \
+	((((mode) & DOT11_OPER_MODE_RXNSS_MASK)		\
+		>> DOT11_OPER_MODE_RXNSS_SHIFT) + 1)
+#define DOT11_OPER_MODE_RXNSS_TYPE(mode) \
+	(((mode) & DOT11_OPER_MODE_RXNSS_TYPE_MASK)\
+		>> DOT11_OPER_MODE_RXNSS_TYPE_SHIFT)
+
+#define DOT11_OPER_MODE_20MHZ 0
+#define DOT11_OPER_MODE_40MHZ 1
+#define DOT11_OPER_MODE_80MHZ 2
+#define DOT11_OPER_MODE_160MHZ 3
+#define DOT11_OPER_MODE_8080MHZ 3
+
+#define DOT11_OPER_MODE_CHANNEL_WIDTH_20MHZ(mode) (\
+	((mode) & DOT11_OPER_MODE_CHANNEL_WIDTH_MASK) == DOT11_OPER_MODE_20MHZ)
+#define DOT11_OPER_MODE_CHANNEL_WIDTH_40MHZ(mode) (\
+	((mode) & DOT11_OPER_MODE_CHANNEL_WIDTH_MASK) == DOT11_OPER_MODE_40MHZ)
+#define DOT11_OPER_MODE_CHANNEL_WIDTH_80MHZ(mode) (\
+	((mode) & DOT11_OPER_MODE_CHANNEL_WIDTH_MASK) == DOT11_OPER_MODE_80MHZ)
+#define DOT11_OPER_MODE_CHANNEL_WIDTH_160MHZ(mode) (\
+	((mode) & DOT11_OPER_MODE_CHANNEL_WIDTH_MASK) == DOT11_OPER_MODE_160MHZ)
+#define DOT11_OPER_MODE_CHANNEL_WIDTH_8080MHZ(mode) (\
+	((mode) & DOT11_OPER_MODE_CHANNEL_WIDTH_MASK) == DOT11_OPER_MODE_8080MHZ)
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_oper_mode_notif_ie {
+	uint8 mode;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_oper_mode_notif_ie dot11_oper_mode_notif_ie_t;
+
+#define DOT11_OPER_MODE_NOTIF_IE_LEN 1
+
+
+#define DOT11_OBSS_COEX_MNG_SUPPORT	0x01	
 
 
 #define DOT11_ACTION_HDR_LEN		2	
@@ -1153,8 +1320,10 @@ typedef struct ti_ie ti_ie_t;
 #define DOT11_ACTION_CAT_HT		7	
 #define	DOT11_ACTION_CAT_SA_QUERY	8	
 #define	DOT11_ACTION_CAT_PDPA		9	
-#define DOT11_ACTION_CAT_BSSMGMT	10	
+#define DOT11_ACTION_CAT_WNM		10	
+#define DOT11_ACTION_CAT_UWNM		11	
 #define DOT11_ACTION_NOTIFICATION	17
+#define DOT11_ACTION_CAT_VHT		21	
 #define DOT11_ACTION_CAT_VSP		126	
 #define DOT11_ACTION_CAT_VS		127	
 
@@ -1199,43 +1368,52 @@ typedef struct ti_ie ti_ie_t;
 #define DOT11_FT_ACTION_FT_ACK			4	
 
 
-#define DOT11_DLS_ACTION_REQ				0	
-#define DOT11_DLS_ACTION_RESP				1	
-#define DOT11_DLS_ACTION_TD				2	
+#define DOT11_DLS_ACTION_REQ			0	
+#define DOT11_DLS_ACTION_RESP			1	
+#define DOT11_DLS_ACTION_TD			2	
 
 
-#define DOT11_WNM_ACTION_EVENT_REQ			0
-#define DOT11_WNM_ACTION_EVENT_REP			1
-#define DOT11_WNM_ACTION_DIAG_REQ			2
-#define DOT11_WNM_ACTION_DIAG_REP			3
+#define DOT11_WNM_ACTION_EVENT_REQ		0
+#define DOT11_WNM_ACTION_EVENT_REP		1
+#define DOT11_WNM_ACTION_DIAG_REQ		2
+#define DOT11_WNM_ACTION_DIAG_REP		3
 #define DOT11_WNM_ACTION_LOC_CFG_REQ		4
 #define DOT11_WNM_ACTION_LOC_RFG_RESP		5
-#define DOT11_WNM_ACTION_BSS_TRANS_QURY		6
-#define DOT11_WNM_ACTION_BSS_TRANS_REQ		7
-#define DOT11_WNM_ACTION_BSS_TRANS_RESP		8
-#define DOT11_WNM_ACTION_FMS_REQ			9
-#define DOT11_WNM_ACTION_FMS_RESP			10
+#define DOT11_WNM_ACTION_BSSTRANS_QUERY		6
+#define DOT11_WNM_ACTION_BSSTRANS_REQ		7
+#define DOT11_WNM_ACTION_BSSTRANS_RESP		8
+#define DOT11_WNM_ACTION_FMS_REQ		9
+#define DOT11_WNM_ACTION_FMS_RESP		10
 #define DOT11_WNM_ACTION_COL_INTRFRNCE_REQ	11
 #define DOT11_WNM_ACTION_COL_INTRFRNCE_REP	12
-#define DOT11_WNM_ACTION_TFS_REQ			13
-#define DOT11_WNM_ACTION_TFS_RESP			14
-#define DOT11_WNM_ACTION_TFS_NOTIFY			15
+#define DOT11_WNM_ACTION_TFS_REQ		13
+#define DOT11_WNM_ACTION_TFS_RESP		14
+#define DOT11_WNM_ACTION_TFS_NOTIFY		15
 #define DOT11_WNM_ACTION_WNM_SLEEP_REQ		16
 #define DOT11_WNM_ACTION_WNM_SLEEP_RESP		17
-#define DOT11_WNM_ACTION_TIM_BCAST_REQ		18
-#define DOT11_WNM_ACTION_TIM_BCAST_RESP		19
+#define DOT11_WNM_ACTION_TIMBC_REQ		18
+#define DOT11_WNM_ACTION_TIMBC_RESP		19
 #define DOT11_WNM_ACTION_QOS_TRFC_CAP_UPD	20
 #define DOT11_WNM_ACTION_CHAN_USAGE_REQ		21
 #define DOT11_WNM_ACTION_CHAN_USAGE_RESP	22
-#define DOT11_WNM_ACTION_DMS_REQ			23
-#define DOT11_WNM_ACTION_DMS_RESP			24
+#define DOT11_WNM_ACTION_DMS_REQ		23
+#define DOT11_WNM_ACTION_DMS_RESP		24
 #define DOT11_WNM_ACTION_TMNG_MEASUR_REQ	25
 #define DOT11_WNM_ACTION_NOTFCTN_REQ		26
-#define DOT11_WNM_ACTION_NOTFCTN_RES		27
+#define DOT11_WNM_ACTION_NOTFCTN_RESP		27
+
+
+#define DOT11_UWNM_ACTION_TIM			0
+#define DOT11_UWNM_ACTION_TIMING_MEASUREMENT	1
 
 #define DOT11_MNG_COUNTRY_ID_LEN 3
 
 
+#define DOT11_VHT_ACTION_CBF				0	
+#define DOT11_VHT_ACTION_GID_MGMT			1	
+#define DOT11_VHT_ACTION_OPER_MODE_NOTIF	2	
+
+
 BWL_PRE_PACKED_STRUCT struct dot11_dls_req {
 	uint8 category;			
 	uint8 action;				
@@ -1262,83 +1440,528 @@ typedef struct dot11_dls_resp dot11_dls_resp_t;
 
 
 
-BWL_PRE_PACKED_STRUCT struct dot11_bss_trans_query {
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_bsstrans_query {
+	uint8 category;			
+	uint8 action;			
+	uint8 token;			
+	uint8 reason;			
+	uint8 data[1];			
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_bsstrans_query dot11_bsstrans_query_t;
+#define DOT11_BSSTRANS_QUERY_LEN 4	
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_bsstrans_req {
+	uint8 category;			
+	uint8 action;			
+	uint8 token;			
+	uint8 reqmode;			
+	uint16 disassoc_tmr;		
+	uint8 validity_intrvl;		
+	uint8 data[1];			
+						
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_bsstrans_req dot11_bsstrans_req_t;
+#define DOT11_BSSTRANS_REQ_LEN 7	
+
+
+#define DOT11_BSSTRANS_REQMODE_PREF_LIST_INCL		0x01
+#define DOT11_BSSTRANS_REQMODE_ABRIDGED			0x02
+#define DOT11_BSSTRANS_REQMODE_DISASSOC_IMMINENT	0x04
+#define DOT11_BSSTRANS_REQMODE_BSS_TERM_INCL		0x08
+#define DOT11_BSSTRANS_REQMODE_ESS_DISASSOC_IMNT	0x10
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_bsstrans_resp {
+	uint8 category;			
+	uint8 action;			
+	uint8 token;			
+	uint8 status;			
+	uint8 term_delay;		
+	uint8 data[1];			
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_bsstrans_resp dot11_bsstrans_resp_t;
+#define DOT11_BSSTRANS_RESP_LEN 5	
+
+
+#define DOT11_BSSTRANS_RESP_STATUS_ACCEPT			0
+#define DOT11_BSSTRANS_RESP_STATUS_REJECT			1
+#define DOT11_BSSTRANS_RESP_STATUS_REJ_INSUFF_BCN		2
+#define DOT11_BSSTRANS_RESP_STATUS_REJ_INSUFF_CAP		3
+#define DOT11_BSSTRANS_RESP_STATUS_REJ_TERM_UNDESIRED		4
+#define DOT11_BSSTRANS_RESP_STATUS_REJ_TERM_DELAY_REQ		5
+#define DOT11_BSSTRANS_RESP_STATUS_REJ_BSS_LIST_PROVIDED	6
+#define DOT11_BSSTRANS_RESP_STATUS_REJ_NO_SUITABLE_BSS		7
+#define DOT11_BSSTRANS_RESP_STATUS_REJ_LEAVING_ESS		8
+
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_bss_max_idle_period_ie {
+	uint8 id;				
+	uint8 len;
+	uint16 max_idle_period;			
+	uint8 idle_opt;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_bss_max_idle_period_ie dot11_bss_max_idle_period_ie_t;
+#define DOT11_BSS_MAX_IDLE_PERIOD_IE_LEN	3	
+#define DOT11_BSS_MAX_IDLE_PERIOD_OPT_PROTECTED	1	
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_timbc_req_ie {
+	uint8 id;				
+	uint8 len;
+	uint8 interval;				
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_timbc_req_ie dot11_timbc_req_ie_t;
+#define DOT11_TIMBC_REQ_IE_LEN		1	
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_timbc_req {
+	uint8 category;				
+	uint8 action;				
+	uint8 token;				
+	uint8 data[1];				
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_timbc_req dot11_timbc_req_t;
+#define DOT11_TIMBC_REQ_LEN		3	
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_timbc_resp_ie {
+	uint8 id;				
+	uint8 len;
+	uint8 status;				
+	uint8 interval;				
+	int32 offset;				
+	uint16 high_rate;			
+	uint16 low_rate;			
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_timbc_resp_ie dot11_timbc_resp_ie_t;
+#define DOT11_TIMBC_DENY_RESP_IE_LEN	1	
+#define DOT11_TIMBC_ACCEPT_RESP_IE_LEN	10	
+
+#define DOT11_TIMBC_STATUS_ACCEPT		0
+#define DOT11_TIMBC_STATUS_ACCEPT_TSTAMP	1
+#define DOT11_TIMBC_STATUS_DENY			2
+#define DOT11_TIMBC_STATUS_OVERRIDDEN		3
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_timbc_resp {
+	uint8 category;			
+	uint8 action;			
+	uint8 token;			
+	uint8 data[1];			
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_timbc_resp dot11_timbc_resp_t;
+#define DOT11_TIMBC_RESP_LEN	3	
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_tim_ie {
+	uint8 id;			
+	uint8 len;			
+	uint8 dtim_count;		
+	uint8 dtim_period;		
+	uint8 bitmap_control;	
+	uint8 pvb[1];		
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_tim_ie dot11_tim_ie_t;
+#define DOT11_TIM_IE_FIXED_LEN	3	
+#define DOT11_TIM_IE_FIXED_TOTAL_LEN	5	
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_timbc {
+	uint8 category;			
+	uint8 action;			
+	uint8 check_beacon;		
+	uint8 tsf[8];			
+	dot11_tim_ie_t tim_ie;		
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_timbc dot11_timbc_t;
+#define DOT11_TIMBC_HDR_LEN	(sizeof(dot11_timbc_t) - sizeof(dot11_tim_ie_t))
+#define DOT11_TIMBC_FIXED_LEN	(sizeof(dot11_timbc_t) - 1)	
+#define DOT11_TIMBC_LEN			11	
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_tclas_fc_hdr {
+	uint8 type;
+	uint8 mask;
+	uint8 data[1];
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_tclas_fc_hdr dot11_tclas_fc_hdr_t;
+#define DOT11_TCLAS_FC_HDR_LEN		2	
+
+#define DOT11_TCLAS_MASK_0		0x1
+#define DOT11_TCLAS_MASK_1		0x2
+#define DOT11_TCLAS_MASK_2		0x4
+#define DOT11_TCLAS_MASK_3		0x8
+#define DOT11_TCLAS_MASK_4		0x10
+#define DOT11_TCLAS_MASK_5		0x20
+#define DOT11_TCLAS_MASK_6		0x40
+#define DOT11_TCLAS_MASK_7		0x80
+
+#define DOT11_TCLAS_FC_0_ETH		0
+#define DOT11_TCLAS_FC_1_IP		1
+#define DOT11_TCLAS_FC_2_8021Q		2
+#define DOT11_TCLAS_FC_3_OFFSET		3
+#define DOT11_TCLAS_FC_4_IP_HIGHER	4
+#define DOT11_TCLAS_FC_5_8021D		5
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_tclas_fc_0_eth {
+	uint8 type;
+	uint8 mask;
+	uint8 sa[ETHER_ADDR_LEN];
+	uint8 da[ETHER_ADDR_LEN];
+	uint16 eth_type;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_tclas_fc_0_eth dot11_tclas_fc_0_eth_t;
+#define DOT11_TCLAS_FC_0_ETH_LEN	16
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_tclas_fc_1_ipv4 {
+	uint8 type;
+	uint8 mask;
+	uint8 version;
+	uint32 src_ip;
+	uint32 dst_ip;
+	uint16 src_port;
+	uint16 dst_port;
+	uint8 dscp;
+	uint8 protocol;
+	uint8 reserved;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_tclas_fc_1_ipv4 dot11_tclas_fc_1_ipv4_t;
+#define DOT11_TCLAS_FC_1_IPV4_LEN	18
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_tclas_fc_2_8021q {
+	uint8 type;
+	uint8 mask;
+	uint16 tci;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_tclas_fc_2_8021q dot11_tclas_fc_2_8021q_t;
+#define DOT11_TCLAS_FC_2_8021Q_LEN	4
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_tclas_fc_3_filter {
+	uint8 type;
+	uint8 mask;
+	uint16 offset;
+	uint8 data[1];
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_tclas_fc_3_filter dot11_tclas_fc_3_filter_t;
+#define DOT11_TCLAS_FC_3_FILTER_LEN	4
+
+
+typedef struct dot11_tclas_fc_1_ipv4 dot11_tclas_fc_4_ipv4_t;
+#define DOT11_TCLAS_FC_4_IPV4_LEN	DOT11_TCLAS_FC_1_IPV4_LEN
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_tclas_fc_4_ipv6 {
+	uint8 type;
+	uint8 mask;
+	uint8 version;
+	uint8 saddr[16];
+	uint8 daddr[16];
+	uint16 src_port;
+	uint16 dst_port;
+	uint8 dscp;
+	uint8 nexthdr;
+	uint8 flow_lbl[3];
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_tclas_fc_4_ipv6 dot11_tclas_fc_4_ipv6_t;
+#define DOT11_TCLAS_FC_4_IPV6_LEN	44
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_tclas_fc_5_8021d {
+	uint8 type;
+	uint8 mask;
+	uint8 pcp;
+	uint8 cfi;
+	uint16 vid;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_tclas_fc_5_8021d dot11_tclas_fc_5_8021d_t;
+#define DOT11_TCLAS_FC_5_8021D_LEN	6
+
+
+BWL_PRE_PACKED_STRUCT union dot11_tclas_fc {
+	uint8 data[1];
+	dot11_tclas_fc_hdr_t hdr;
+	dot11_tclas_fc_0_eth_t t0_eth;
+	dot11_tclas_fc_1_ipv4_t	t1_ipv4;
+	dot11_tclas_fc_2_8021q_t t2_8021q;
+	dot11_tclas_fc_3_filter_t t3_filter;
+	dot11_tclas_fc_4_ipv4_t	t4_ipv4;
+	dot11_tclas_fc_4_ipv6_t	t4_ipv6;
+	dot11_tclas_fc_5_8021d_t t5_8021d;
+} BWL_POST_PACKED_STRUCT;
+typedef union dot11_tclas_fc dot11_tclas_fc_t;
+
+#define DOT11_TCLAS_FC_MIN_LEN		4
+#define DOT11_TCLAS_FC_MAX_LEN		254
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_tclas_ie {
+	uint8 id;				
+	uint8 len;
+	uint8 user_priority;
+	dot11_tclas_fc_t fc;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_tclas_ie dot11_tclas_ie_t;
+#define DOT11_TCLAS_IE_LEN		3	
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_tclas_proc_ie {
+	uint8 id;				
+	uint8 len;
+	uint8 process;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_tclas_proc_ie dot11_tclas_proc_ie_t;
+#define DOT11_TCLAS_PROC_IE_LEN		3	
+
+#define DOT11_TCLAS_PROC_MATCHALL	0	
+#define DOT11_TCLAS_PROC_MATCHONE	1	
+#define DOT11_TCLAS_PROC_NONMATCH	2	
+
+
+
+#define DOT11_TSPEC_IE_LEN		57	
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_tfs_req_ie {
+	uint8 id;				
+	uint8 len;
+	uint8 tfs_id;
+	uint8 tfs_actcode;
+	uint8 data[1];
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_tfs_req_ie dot11_tfs_req_ie_t;
+#define DOT11_TFS_REQ_IE_LEN		4	
+
+#define DOT11_TFS_ACTCODE_DELETE	1
+#define DOT11_TFS_ACTCODE_MODIFY	2
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_tfs_req_se {
+	uint8 sub_id;
+	uint8 length;
+	uint8 data[1];
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_tfs_req_se dot11_tfs_req_se_t;
+
+BWL_PRE_PACKED_STRUCT struct dot11_tfs_se {
+	uint8 sub_id;
+	uint8 len;
+	uint8 data[1];
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_tfs_se dot11_tfs_se_t;
+#define DOT11_TFS_REQ_SUBELEM_LEN	2	
+
+#define DOT11_TFS_SUBELEM_ID_TFS	1
+#define DOT11_TFS_SUBELEM_ID_VENDOR	221
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_tfs_resp_ie {
+	uint8 id;				
+	uint8 len;
+	uint8 data[1];
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_tfs_resp_ie dot11_tfs_resp_ie_t;
+#define DOT11_TFS_RESP_IE_LEN		2	
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_tfs_status_se {
+	uint8 id;				
+	uint8 len;
+	uint8 resp_st;
+	uint8 tfs_id;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_tfs_status_se dot11_tfs_status_se_t;
+
+#define DOT11_TFS_STATUS_SE_LEN		4	
+#define DOT11_TFS_STATUS_SE_DATA_LEN	2	
+
+#define DOT11_TFS_STATUS_SE_ID_TFS_ST	1
+#define DOT11_TFS_STATUS_SE_ID_TFS	2
+#define DOT11_TFS_STATUS_SE_ID_VENDOR	221
+
+#define DOT11_TFS_RESP_ST_ACCEPT	0
+#define DOT11_TFS_RESP_ST_DENY_FORMAT	1
+#define DOT11_TFS_RESP_ST_DENY_RESOURCE	2
+#define DOT11_TFS_RESP_ST_DENY_POLICY	4
+#define DOT11_TFS_RESP_ST_PREFERRED_AP_INCAP	14
+
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_tfs_req {
 	uint8 category;				
 	uint8 action;				
 	uint8 token;				
-	uint8 reason;				
 	uint8 data[1];				
 } BWL_POST_PACKED_STRUCT;
-typedef struct dot11_bss_trans_query dot11_bss_trans_query_t;
-#define DOT11_BSS_TRANS_QUERY_LEN 4	
+typedef struct dot11_tfs_req dot11_tfs_req_t;
+#define DOT11_TFS_REQ_LEN		3	
 
 
-BWL_PRE_PACKED_STRUCT struct dot11_bss_trans_req {
+BWL_PRE_PACKED_STRUCT struct dot11_tfs_resp {
 	uint8 category;				
 	uint8 action;				
 	uint8 token;				
-	uint8 reqmode;				
-	uint16 disassoc_tmr;		
-	uint8 validity_intrvl;		
 	uint8 data[1];				
-								
 } BWL_POST_PACKED_STRUCT;
-typedef struct dot11_bss_trans_req dot11_bss_trans_req_t;
-#define DOT11_BSS_TRANS_REQ_LEN 7	
+typedef struct dot11_tfs_resp dot11_tfs_resp_t;
+#define DOT11_TFS_RESP_LEN		3	
 
-#define DOT11_BSS_TERM_DUR_LEN 12	
 
+BWL_PRE_PACKED_STRUCT struct dot11_tfs_notify {
+	uint8 category;				
+	uint8 action;				
+	uint8 num_tfs_id;			
+	uint8 data[1];				
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_tfs_notify dot11_tfs_notify_t;
+#define DOT11_TFS_NOTIFY_LEN		3	
 
+#define DOT11_TFS_NOTIFY_ACT_DEL	1
+#define DOT11_TFS_NOTIFY_ACT_NOTIFY	2
 
-#define DOT11_BSS_TRNS_REQMODE_PREF_LIST_INCL		0x01
-#define DOT11_BSS_TRNS_REQMODE_ABRIDGED				0x02
-#define DOT11_BSS_TRNS_REQMODE_DISASSOC_IMMINENT	0x04
-#define DOT11_BSS_TRNS_REQMODE_BSS_TERM_INCL		0x08
-#define DOT11_BSS_TRNS_REQMODE_ESS_DISASSOC_IMNT	0x10
 
+BWL_PRE_PACKED_STRUCT struct dot11_wnm_sleep_req {
+	uint8 category;				
+	uint8 action;				
+	uint8 token;				
+	uint8 data[1];				
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_wnm_sleep_req dot11_wnm_sleep_req_t;
+#define DOT11_WNM_SLEEP_REQ_LEN		3	
 
 
-BWL_PRE_PACKED_STRUCT struct dot11_bss_trans_res {
+BWL_PRE_PACKED_STRUCT struct dot11_wnm_sleep_resp {
 	uint8 category;				
 	uint8 action;				
 	uint8 token;				
-	uint8 status;				
-	uint8 term_delay;			
+	uint16 key_len;				
 	uint8 data[1];				
-								
 } BWL_POST_PACKED_STRUCT;
-typedef struct dot11_bss_trans_res dot11_bss_trans_res_t;
-#define DOT11_BSS_TRANS_RES_LEN 5	
+typedef struct dot11_wnm_sleep_resp dot11_wnm_sleep_resp_t;
+#define DOT11_WNM_SLEEP_RESP_LEN	5	
+
+#define DOT11_WNM_SLEEP_SUBELEM_ID_GTK	0
+#define DOT11_WNM_SLEEP_SUBELEM_ID_IGTK	1
+
+BWL_PRE_PACKED_STRUCT struct dot11_wnm_sleep_subelem_gtk {
+	uint8 sub_id;
+	uint8 len;
+	uint16 key_info;
+	uint8 key_length;
+	uint8 rsc[8];
+	uint8 key[1];
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_wnm_sleep_subelem_gtk dot11_wnm_sleep_subelem_gtk_t;
+#define DOT11_WNM_SLEEP_SUBELEM_GTK_FIXED_LEN	11	
+#define DOT11_WNM_SLEEP_SUBELEM_GTK_MAX_LEN	43	
 
+BWL_PRE_PACKED_STRUCT struct dot11_wnm_sleep_subelem_igtk {
+	uint8 sub_id;
+	uint8 len;
+	uint16 key_id;
+	uint8 pn[6];
+	uint8 key[16];
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_wnm_sleep_subelem_igtk dot11_wnm_sleep_subelem_igtk_t;
+#define DOT11_WNM_SLEEP_SUBELEM_IGTK_LEN 24	
 
-#define DOT11_BSS_TRNS_RES_STATUS_ACCEPT				0
-#define DOT11_BSS_TRNS_RES_STATUS_REJECT				1
-#define DOT11_BSS_TRNS_RES_STATUS_REJ_INSUFF_BCN		2
-#define DOT11_BSS_TRNS_RES_STATUS_REJ_INSUFF_CAP		3
-#define DOT11_BSS_TRNS_RES_STATUS_REJ_TERM_UNDESIRED	4
-#define DOT11_BSS_TRNS_RES_STATUS_REJ_TERM_DELAY_REQ	5
-#define DOT11_BSS_TRNS_RES_STATUS_REJ_BSS_LIST_PROVIDED	6
-#define DOT11_BSS_TRNS_RES_STATUS_REJ_NO_SUITABLE_BSS	7
-#define DOT11_BSS_TRNS_RES_STATUS_REJ_LEAVING_ESS		8
+BWL_PRE_PACKED_STRUCT struct dot11_wnm_sleep_ie {
+	uint8 id;				
+	uint8 len;
+	uint8 act_type;
+	uint8 resp_status;
+	uint16 interval;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_wnm_sleep_ie dot11_wnm_sleep_ie_t;
+#define DOT11_WNM_SLEEP_IE_LEN		4	
+
+#define DOT11_WNM_SLEEP_ACT_TYPE_ENTER	0
+#define DOT11_WNM_SLEEP_ACT_TYPE_EXIT	1
+
+#define DOT11_WNM_SLEEP_RESP_ACCEPT	0
+#define DOT11_WNM_SLEEP_RESP_UPDATE	1
+#define DOT11_WNM_SLEEP_RESP_DENY	2
+#define DOT11_WNM_SLEEP_RESP_DENY_TEMP	3
+#define DOT11_WNM_SLEEP_RESP_DENY_KEY	4
+#define DOT11_WNM_SLEEP_RESP_DENY_INUSE	5
+#define DOT11_WNM_SLEEP_RESP_LAST	6
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_dms_req {
+	uint8 category;				
+	uint8 action;				
+	uint8 token;				
+	uint8 data[1];				
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_dms_req dot11_dms_req_t;
+#define DOT11_DMS_REQ_LEN		3	
 
 
+BWL_PRE_PACKED_STRUCT struct dot11_dms_resp {
+	uint8 category;				
+	uint8 action;				
+	uint8 token;				
+	uint8 data[1];				
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_dms_resp dot11_dms_resp_t;
+#define DOT11_DMS_RESP_LEN		3	
 
-#define DOT11_NBR_RPRT_BSSID_INFO_REACHABILTY		0x0003
-#define DOT11_NBR_RPRT_BSSID_INFO_SEC				0x0004
-#define DOT11_NBR_RPRT_BSSID_INFO_KEY_SCOPE			0x0008
-#define DOT11_NBR_RPRT_BSSID_INFO_CAP				0x03f0
 
-#define DOT11_NBR_RPRT_BSSID_INFO_CAP_SPEC_MGMT		0x0010
-#define DOT11_NBR_RPRT_BSSID_INFO_CAP_QOS			0x0020
-#define DOT11_NBR_RPRT_BSSID_INFO_CAP_APSD			0x0040
-#define DOT11_NBR_RPRT_BSSID_INFO_CAP_RDIO_MSMT		0x0080
-#define DOT11_NBR_RPRT_BSSID_INFO_CAP_DEL_BA		0x0100
-#define DOT11_NBR_RPRT_BSSID_INFO_CAP_IMM_BA		0x0200
+BWL_PRE_PACKED_STRUCT struct dot11_dms_req_ie {
+	uint8 id;				
+	uint8 len;
+	uint8 data[1];
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_dms_req_ie dot11_dms_req_ie_t;
+#define DOT11_DMS_REQ_IE_LEN		2	
 
 
-#define DOT11_NBR_RPRT_SUBELEM_BSS_CANDDT_PREF_ID	3
+BWL_PRE_PACKED_STRUCT struct dot11_dms_resp_ie {
+	uint8 id;				
+	uint8 len;
+	uint8 data[1];
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_dms_resp_ie dot11_dms_resp_ie_t;
+#define DOT11_DMS_RESP_IE_LEN		2	
 
 
+BWL_PRE_PACKED_STRUCT struct dot11_dms_req_desc {
+	uint8 dms_id;
+	uint8 len;
+	uint8 type;
+	uint8 data[1];
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_dms_req_desc dot11_dms_req_desc_t;
+#define DOT11_DMS_REQ_DESC_LEN		3	
+
+#define DOT11_DMS_REQ_TYPE_ADD		0
+#define DOT11_DMS_REQ_TYPE_REMOVE	1
+#define DOT11_DMS_REQ_TYPE_CHANGE	2
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_dms_resp_st {
+	uint8 dms_id;
+	uint8 len;
+	uint8 type;
+	uint16 lsc;
+	uint8 data[1];
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_dms_resp_st dot11_dms_resp_st_t;
+#define DOT11_DMS_RESP_STATUS_LEN	5	
+
+#define DOT11_DMS_RESP_TYPE_ACCEPT	0
+#define DOT11_DMS_RESP_TYPE_DENY	1
+#define DOT11_DMS_RESP_TYPE_TERM	2
+
+#define DOT11_DMS_RESP_LSC_UNSUPPORTED	0xFFFF
+
 BWL_PRE_PACKED_STRUCT struct dot11_addba_req {
 	uint8 category;				
 	uint8 action;				
@@ -1406,11 +2029,26 @@ typedef struct dot11_ft_res dot11_ft_res_t;
 #define DOT11_FT_RES_FIXED_LEN 16
 
 
+BWL_PRE_PACKED_STRUCT struct dot11_rde_ie {
+	uint8 id;			
+	uint8 length;
+	uint8 rde_id;			
+	uint8 rd_count;			
+	uint16 status;			
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_rde_ie dot11_rde_ie_t;
+
+
+#define DOT11_MNG_RDE_IE_LEN sizeof(dot11_rde_ie_t)
+
+
 
 
 
 
 #define DOT11_RRM_CAP_LEN		5	
+#define RCPI_IE_LEN 1
+#define RSNI_IE_LEN 1
 BWL_PRE_PACKED_STRUCT struct dot11_rrm_cap_ie {
 	uint8 cap[DOT11_RRM_CAP_LEN];
 } BWL_POST_PACKED_STRUCT;
@@ -1431,6 +2069,13 @@ typedef struct dot11_rrm_cap_ie dot11_rrm_cap_ie_t;
 
 #define DOT11_OP_CLASS_NONE			255
 
+BWL_PRE_PACKED_STRUCT struct do11_ap_chrep {
+	uint8 id;
+	uint8 len;
+	uint8 reg;
+	uint8 chanlist[1];
+} BWL_POST_PACKED_STRUCT;
+typedef struct do11_ap_chrep dot11_ap_chrep_t;
 
 
 #define DOT11_RM_ACTION_RM_REQ		0	
@@ -1455,6 +2100,7 @@ BWL_PRE_PACKED_STRUCT struct dot11_rmreq {
 	uint8 action;				
 	uint8 token;				
 	uint16 reps;				
+	uint8 data[1];
 } BWL_POST_PACKED_STRUCT;
 typedef struct dot11_rmreq dot11_rmreq_t;
 #define DOT11_RMREQ_LEN	5
@@ -1518,11 +2164,11 @@ typedef struct dot11_rmrep_bcn dot11_rmrep_bcn_t;
 #define DOT11_RMREQ_BCN_TABLE	2
 
 
-#define DOT11_RMREQ_BCN_SSID_ID	0
-#define DOT11_RMREQ_BCN_REPINFO_ID	1
-#define DOT11_RMREQ_BCN_REPDET_ID	2
-#define DOT11_RMREQ_BCN_REQUEST_ID	10
-#define DOT11_RMREQ_BCN_APCHREP_ID	51
+#define DOT11_RMREQ_BCN_SSID_ID 0
+#define DOT11_RMREQ_BCN_REPINFO_ID  1
+#define DOT11_RMREQ_BCN_REPDET_ID   2
+#define DOT11_RMREQ_BCN_REQUEST_ID  10
+#define DOT11_RMREQ_BCN_APCHREP_ID  DOT11_MNG_AP_CHREP_ID
 
 
 #define DOT11_RMREQ_BCN_REPDET_FIXED	0	
@@ -1533,16 +2179,241 @@ typedef struct dot11_rmrep_bcn dot11_rmrep_bcn_t;
 #define DOT11_RMREP_BCN_FRM_BODY	1
 
 
-BWL_PRE_PACKED_STRUCT struct dot11_rmrep_nbr {
-	struct ether_addr	bssid;
-	uint32	bssid_info;
+#define DOT11_RMREP_FRAME_COUNT_REPORT 1
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_rmreq_chanload {
+	uint8 id;
+	uint8 len;
+	uint8 token;
+	uint8 mode;
+	uint8 type;
+	uint8 reg;
+	uint8 channel;
+	uint16 interval;
+	uint16 duration;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_rmreq_chanload dot11_rmreq_chanload_t;
+#define DOT11_RMREQ_CHANLOAD_LEN	11
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_rmrep_chanload {
+	uint8 reg;
+	uint8 channel;
+	uint32 starttime[2];
+	uint16 duration;
+	uint8 channel_load;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_rmrep_chanload dot11_rmrep_chanload_t;
+#define DOT11_RMREP_CHANLOAD_LEN	13
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_rmreq_noise {
+	uint8 id;
+	uint8 len;
+	uint8 token;
+	uint8 mode;
+	uint8 type;
+	uint8 reg;
+	uint8 channel;
+	uint16 interval;
+	uint16 duration;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_rmreq_noise dot11_rmreq_noise_t;
+#define DOT11_RMREQ_NOISE_LEN 11
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_rmrep_noise {
+	uint8 reg;
+	uint8 channel;
+	uint32 starttime[2];
+	uint16 duration;
+	uint8 antid;
+	uint8 anpi;
+	uint8 ipi0_dens;
+	uint8 ipi1_dens;
+	uint8 ipi2_dens;
+	uint8 ipi3_dens;
+	uint8 ipi4_dens;
+	uint8 ipi5_dens;
+	uint8 ipi6_dens;
+	uint8 ipi7_dens;
+	uint8 ipi8_dens;
+	uint8 ipi9_dens;
+	uint8 ipi10_dens;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_rmrep_noise dot11_rmrep_noise_t;
+#define DOT11_RMREP_NOISE_LEN 25
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_rmreq_frame {
+	uint8 id;
+	uint8 len;
+	uint8 token;
+	uint8 mode;
+	uint8 type;
+	uint8 reg;
+	uint8 channel;
+	uint16 interval;
+	uint16 duration;
+	uint8 req_type;
+	struct ether_addr	ta;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_rmreq_frame dot11_rmreq_frame_t;
+#define DOT11_RMREQ_FRAME_LEN 18
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_rmrep_frame {
 	uint8 reg;
 	uint8 channel;
+	uint32 starttime[2];
+	uint16 duration;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_rmrep_frame dot11_rmrep_frame_t;
+#define DOT11_RMREP_FRAME_LEN 12
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_rmrep_frmentry {
+	struct ether_addr	ta;
+	struct ether_addr	bssid;
+	uint8 phy_type;
+	uint8 avg_rcpi;
+	uint8 last_rsni;
+	uint8 last_rcpi;
+	uint8 ant_id;
+	uint16 frame_cnt;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_rmrep_frmentry dot11_rmrep_frmentry_t;
+#define DOT11_RMREP_FRMENTRY_LEN 19
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_rmreq_stat {
+	uint8 id;
+	uint8 len;
+	uint8 token;
+	uint8 mode;
+	uint8 type;
+	struct ether_addr	peer;
+	uint16 interval;
+	uint16 duration;
+	uint8 group_id;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_rmreq_stat dot11_rmreq_stat_t;
+#define DOT11_RMREQ_STAT_LEN 16
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_rmrep_stat {
+	uint16 duration;
+	uint8 group_id;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_rmrep_stat dot11_rmrep_stat_t;
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_rmreq_tx_stream {
+	uint8 id;
+	uint8 len;
+	uint8 token;
+	uint8 mode;
+	uint8 type;
+	uint16 interval;
+	uint16 duration;
+	struct ether_addr	peer;
+	uint8 traffic_id;
+	uint8 bin0_range;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_rmreq_tx_stream dot11_rmreq_tx_stream_t;
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_rmrep_tx_stream {
+	uint32 starttime[2];
+	uint16 duration;
+	struct ether_addr	peer;
+	uint8 traffic_id;
+	uint8 reason;
+	uint32 txmsdu_cnt;
+	uint32 msdu_discarded_cnt;
+	uint32 msdufailed_cnt;
+	uint32 msduretry_cnt;
+	uint32 cfpolls_lost_cnt;
+	uint32 avrqueue_delay;
+	uint32 avrtx_delay;
+	uint8 bin0_range;
+	uint32 bin0;
+	uint32 bin1;
+	uint32 bin2;
+	uint32 bin3;
+	uint32 bin4;
+	uint32 bin5;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_rmrep_tx_stream dot11_rmrep_tx_stream_t;
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_rmreq_pause_time {
+	uint8 id;
+	uint8 len;
+	uint8 token;
+	uint8 mode;
+	uint8 type;
+	uint16 pause_time;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_rmreq_pause_time dot11_rmreq_pause_time_t;
+
+
+
+#define DOT11_NGBR_TSF_INFO_SE_ID	1
+#define DOT11_NGBR_CCS_SE_ID		2
+#define DOT11_NGBR_BSSTRANS_PREF_SE_ID	3
+#define DOT11_NGBR_BSS_TERM_DUR_SE_ID	4
+#define DOT11_NGBR_BEARING_SE_ID	5
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_ngbr_bsstrans_pref_se {
+	uint8 sub_id;
+	uint8 len;
+	uint8 preference;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_ngbr_bsstrans_pref_se dot11_ngbr_bsstrans_pref_se_t;
+#define DOT11_NGBR_BSSTRANS_PREF_SE_LEN	1
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_ngbr_bss_term_dur_se {
+	uint8 sub_id;
+	uint8 len;
+	uint8 tsf[8];
+	uint16 duration;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_ngbr_bss_term_dur_se dot11_ngbr_bss_term_dur_se_t;
+#define DOT11_NGBR_BSS_TERM_DUR_SE_LEN	10
+
+
+#define DOT11_NGBR_BI_REACHABILTY_UNKN	0x0002
+#define DOT11_NGBR_BI_REACHABILTY	0x0003
+#define DOT11_NGBR_BI_SEC		0x0004
+#define DOT11_NGBR_BI_KEY_SCOPE		0x0008
+#define DOT11_NGBR_BI_CAP		0x03f0
+#define DOT11_NGBR_BI_CAP_SPEC_MGMT	0x0010
+#define DOT11_NGBR_BI_CAP_QOS		0x0020
+#define DOT11_NGBR_BI_CAP_APSD		0x0040
+#define DOT11_NGBR_BI_CAP_RDIO_MSMT	0x0080
+#define DOT11_NGBR_BI_CAP_DEL_BA	0x0100
+#define DOT11_NGBR_BI_CAP_IMM_BA	0x0200
+#define DOT11_NGBR_BI_MOBILITY		0x0400
+#define DOT11_NGBR_BI_HT		0x0800
+
+
+BWL_PRE_PACKED_STRUCT struct dot11_neighbor_rep_ie {
+	uint8 id;
+	uint8 len;
+	struct ether_addr bssid;
+	uint32 bssid_info;
+	uint8 reg;		
+	uint8 channel;
 	uint8 phytype;
-	uchar sub_elements[1]; 	
+	uint8 data[1]; 		
 } BWL_POST_PACKED_STRUCT;
-typedef struct dot11_rmrep_nbr dot11_rmrep_nbr_t;
-#define DOT11_RMREP_NBR_LEN	13
+typedef struct dot11_neighbor_rep_ie dot11_neighbor_rep_ie_t;
+#define DOT11_NEIGHBOR_REP_IE_FIXED_LEN	13
+
 
 
 #define DOT11_BSSTYPE_INFRASTRUCTURE		0	
@@ -1585,42 +2456,56 @@ typedef struct dot11_lmrep dot11_lmrep_t;
 
 
 
-#define HT_SIG1_MCS_MASK	0x00007F
-#define HT_SIG1_CBW		0x000080
-#define HT_SIG1_HT_LENGTH	0xFFFF00
+#define HT_SIG1_MCS_MASK        0x00007F
+#define HT_SIG1_CBW             0x000080
+#define HT_SIG1_HT_LENGTH       0xFFFF00
+
+
+#define HT_SIG2_SMOOTHING       0x000001
+#define HT_SIG2_NOT_SOUNDING    0x000002
+#define HT_SIG2_RESERVED        0x000004
+#define HT_SIG2_AGGREGATION     0x000008
+#define HT_SIG2_STBC_MASK       0x000030
+#define HT_SIG2_STBC_SHIFT      4
+#define HT_SIG2_FEC_CODING      0x000040
+#define HT_SIG2_SHORT_GI        0x000080
+#define HT_SIG2_ESS_MASK        0x000300
+#define HT_SIG2_ESS_SHIFT       8
+#define HT_SIG2_CRC             0x03FC00
+#define HT_SIG2_TAIL            0x1C0000
+
 
+#define HT_T_LEG_PREAMBLE      16
+#define HT_T_L_SIG              4
+#define HT_T_SIG                8
+#define HT_T_LTF1               4
+#define HT_T_GF_LTF1            8
+#define HT_T_LTFs               4
+#define HT_T_STF                4
+#define HT_T_GF_STF             8
+#define HT_T_SYML               4
 
-#define HT_SIG2_SMOOTHING	0x000001
-#define HT_SIG2_NOT_SOUNDING	0x000002
-#define HT_SIG2_RESERVED	0x000004
-#define HT_SIG2_AGGREGATION	0x000008
-#define HT_SIG2_STBC_MASK	0x000030
-#define HT_SIG2_STBC_SHIFT	4
-#define HT_SIG2_FEC_CODING	0x000040
-#define HT_SIG2_SHORT_GI	0x000080
-#define HT_SIG2_ESS_MASK	0x000300
-#define HT_SIG2_ESS_SHIFT	8
-#define HT_SIG2_CRC		0x03FC00
-#define HT_SIG2_TAIL		0x1C0000
+#define HT_N_SERVICE           16       
+#define HT_N_TAIL               6       
 
 
-#define APHY_SLOT_TIME		9	
-#define APHY_SIFS_TIME		16	
-#define APHY_DIFS_TIME		(APHY_SIFS_TIME + (2 * APHY_SLOT_TIME))	
-#define APHY_PREAMBLE_TIME	16	
-#define APHY_SIGNAL_TIME	4	
-#define APHY_SYMBOL_TIME	4	
-#define APHY_SERVICE_NBITS	16	
-#define APHY_TAIL_NBITS		6	
-#define	APHY_CWMIN		15	
+#define APHY_SLOT_TIME          9       
+#define APHY_SIFS_TIME          16      
+#define APHY_DIFS_TIME          (APHY_SIFS_TIME + (2 * APHY_SLOT_TIME))  
+#define APHY_PREAMBLE_TIME      16      
+#define APHY_SIGNAL_TIME        4       
+#define APHY_SYMBOL_TIME        4       
+#define APHY_SERVICE_NBITS      16      
+#define APHY_TAIL_NBITS         6       
+#define APHY_CWMIN              15      
 
 
-#define BPHY_SLOT_TIME		20	
-#define BPHY_SIFS_TIME		10	
-#define BPHY_DIFS_TIME		50	
-#define BPHY_PLCP_TIME		192	
-#define BPHY_PLCP_SHORT_TIME	96	
-#define	BPHY_CWMIN		31	
+#define BPHY_SLOT_TIME          20      
+#define BPHY_SIFS_TIME          10      
+#define BPHY_DIFS_TIME          50      
+#define BPHY_PLCP_TIME          192     
+#define BPHY_PLCP_SHORT_TIME    96      
+#define BPHY_CWMIN              31      
 
 
 #define DOT11_OFDM_SIGNAL_EXTENSION	6	
@@ -1635,30 +2520,36 @@ typedef int vht_group_id_t;
 
 
 
-#define VHT_SIGA1_CONST_MASK 		0x800004
+#define VHT_SIGA1_CONST_MASK            0x800004
 
-#define VHT_SIGA1_20MHZ_VAL 		0x000000
-#define VHT_SIGA1_40MHZ_VAL 		0x000001
-#define VHT_SIGA1_80MHZ_VAL 		0x000002
-#define VHT_SIGA1_160MHZ_VAL 		0x000003
+#define VHT_SIGA1_BW_MASK               0x000003
+#define VHT_SIGA1_20MHZ_VAL             0x000000
+#define VHT_SIGA1_40MHZ_VAL             0x000001
+#define VHT_SIGA1_80MHZ_VAL             0x000002
+#define VHT_SIGA1_160MHZ_VAL            0x000003
 
-#define VHT_SIGA1_STBC 			0x000008
+#define VHT_SIGA1_STBC                  0x000008
 
-#define VHT_SIGA1_GID_MAX_GID 		0x3f
-#define VHT_SIGA1_GID_SHIFT 		4
-#define VHT_SIGA1_GID_TO_AP 		0x00
-#define VHT_SIGA1_GID_NOT_TO_AP 	0x3f
+#define VHT_SIGA1_GID_MASK              0x0003f0
+#define VHT_SIGA1_GID_SHIFT             4
+#define VHT_SIGA1_GID_TO_AP             0x00
+#define VHT_SIGA1_GID_NOT_TO_AP         0x3f
+#define VHT_SIGA1_GID_MAX_GID           0x3f
 
-#define VHT_SIGA1_NSTS_SHIFT 		10
 #define VHT_SIGA1_NSTS_SHIFT_MASK_USER0 0x001C00
+#define VHT_SIGA1_NSTS_SHIFT            10
 
-#define VHT_SIGA1_PARTIAL_AID_SHIFT 13
+#define VHT_SIGA1_PARTIAL_AID_MASK      0x3fe000
+#define VHT_SIGA1_PARTIAL_AID_SHIFT     13
+
+#define VHT_SIGA1_TXOP_PS_NOT_ALLOWED   0x400000
 
 
 #define VHT_SIGA2_GI_NONE               0x000000
 #define VHT_SIGA2_GI_SHORT              0x000001
 #define VHT_SIGA2_GI_W_MOD10            0x000002
 #define VHT_SIGA2_CODING_LDPC           0x000004
+#define VHT_SIGA2_LDPC_EXTRA_OFDM_SYM   0x000008
 #define VHT_SIGA2_BEAMFORM_ENABLE       0x000100
 #define VHT_SIGA2_MCS_SHIFT             4
 
@@ -1666,8 +2557,17 @@ typedef int vht_group_id_t;
 #define VHT_SIGA2_TAIL_MASK             0xfc0000
 #define VHT_SIGA2_TAIL_VALUE            0x000000
 
-#define VHT_SIGA2_SVC_BITS              16
-#define VHT_SIGA2_TAIL_BITS             6
+
+#define VHT_T_LEG_PREAMBLE      16
+#define VHT_T_L_SIG              4
+#define VHT_T_SIG_A              8
+#define VHT_T_LTF                4
+#define VHT_T_STF                4
+#define VHT_T_SIG_B              4
+#define VHT_T_SYML               4
+
+#define VHT_N_SERVICE           16	
+#define VHT_N_TAIL               6	
 
 
 
@@ -1693,6 +2593,9 @@ typedef struct d11cnt {
 
 
 
+#define BRCM_SYSCAP_WET_TUNNEL	0x0100	
+
+
 #define BRCM_OUI		"\x00\x10\x18"	
 
 
@@ -1722,6 +2625,7 @@ typedef	struct brcm_ie brcm_ie_t;
 #define	BRF1_RX_LARGE_AGG	0x10	
 #define BRF1_RFAWARE_DCS	0x20    
 #define BRF1_SOFTAP		0x40    
+#define BRF1_DWDS		0x80    
 
 
 BWL_PRE_PACKED_STRUCT struct vndr_ie {
@@ -1734,7 +2638,37 @@ typedef struct vndr_ie vndr_ie_t;
 
 #define VNDR_IE_HDR_LEN		2	
 #define VNDR_IE_MIN_LEN		3	
-#define VNDR_IE_MAX_LEN		256	
+#define VNDR_IE_FIXED_LEN	(VNDR_IE_HDR_LEN + VNDR_IE_MIN_LEN)
+
+#define VNDR_IE_MAX_LEN		255	
+
+
+BWL_PRE_PACKED_STRUCT struct member_of_brcm_prop_ie {
+	uchar id;
+	uchar len;
+	uchar oui[3];
+	uint8	type;           
+	struct ether_addr ea;   
+} BWL_POST_PACKED_STRUCT;
+typedef struct member_of_brcm_prop_ie member_of_brcm_prop_ie_t;
+
+#define MEMBER_OF_BRCM_PROP_IE_LEN		10	
+#define MEMBER_OF_BRCM_PROP_IE_TYPE		54
+
+
+BWL_PRE_PACKED_STRUCT struct relmcast_brcm_prop_ie {
+	uchar id;
+	uchar len;
+	uchar oui[3];
+	uint8 type;           
+	struct ether_addr ea;   
+	struct ether_addr mcast_ea;  
+	uint8 updtmo; 
+} BWL_POST_PACKED_STRUCT;
+typedef struct relmcast_brcm_prop_ie relmcast_brcm_prop_ie_t;
+
+#define RELMCAST_BRCM_PROP_IE_LEN	(sizeof(relmcast_brcm_prop_ie_t)-2)	
+#define RELMCAST_BRCM_PROP_IE_TYPE	55
 
 
 #define MCSSET_LEN	16	
@@ -1750,6 +2684,13 @@ BWL_PRE_PACKED_STRUCT struct ht_cap_ie {
 } BWL_POST_PACKED_STRUCT;
 typedef struct ht_cap_ie ht_cap_ie_t;
 
+BWL_PRE_PACKED_STRUCT struct dot11_ht_cap_ie {
+	uint8	id;
+	uint8	len;
+	ht_cap_ie_t ht_cap;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_ht_cap_ie dot11_ht_cap_ie_t;
+
 
 
 BWL_PRE_PACKED_STRUCT struct ht_prop_cap_ie {
@@ -1791,6 +2732,37 @@ typedef struct ht_prop_cap_ie ht_prop_cap_ie_t;
 #define HT_CAP_RX_STBC_TWO_STREAM	0x2	
 #define HT_CAP_RX_STBC_THREE_STREAM	0x3	
 
+
+#define HT_CAP_TXBF_CAP_IMPLICIT_TXBF_RX	0x1
+#define HT_CAP_TXBF_CAP_NDP_TX			0x8
+#define HT_CAP_TXBF_CAP_NDP_RX			0x10
+#define HT_CAP_TXBF_CAP_EXPLICIT_CSI		0x100
+#define HT_CAP_TXBF_CAP_EXPLICIT_NC_STEERING	0x200
+#define HT_CAP_TXBF_CAP_EXPLICIT_C_STEERING	0x400
+#define HT_CAP_TXBF_CAP_EXPLICIT_CSI_FB_MASK	0x1800
+#define HT_CAP_TXBF_CAP_EXPLICIT_CSI_FB_SHIFT	11
+#define HT_CAP_TXBF_CAP_EXPLICIT_NC_FB_MASK	0x6000
+#define HT_CAP_TXBF_CAP_EXPLICIT_NC_FB_SHIFT	13
+#define HT_CAP_TXBF_CAP_EXPLICIT_C_FB_MASK	0x18000
+#define HT_CAP_TXBF_CAP_EXPLICIT_C_FB_SHIFT	15
+#define HT_CAP_TXBF_CAP_CSI_BFR_ANT_SHIFT	19
+#define HT_CAP_TXBF_CAP_NC_BFR_ANT_SHIFT	21
+#define HT_CAP_TXBF_CAP_C_BFR_ANT_SHIFT		23
+#define HT_CAP_TXBF_CAP_C_BFR_ANT_MASK		0x1800000
+
+#define HT_CAP_TXBF_CAP_CHAN_ESTIM_SHIFT	27
+#define HT_CAP_TXBF_CAP_CHAN_ESTIM_MASK		0x18000000
+
+#define HT_CAP_TXBF_FB_TYPE_NONE 	0
+#define HT_CAP_TXBF_FB_TYPE_DELAYED 	1
+#define HT_CAP_TXBF_FB_TYPE_IMMEDIATE 	2
+#define HT_CAP_TXBF_FB_TYPE_BOTH 	3
+
+#define HT_CAP_TX_BF_CAP_EXPLICIT_CSI_FB_MASK	0x400
+#define HT_CAP_TX_BF_CAP_EXPLICIT_CSI_FB_SHIFT	10
+#define HT_CAP_TX_BF_CAP_EXPLICIT_COMPRESSED_FB_MASK 0x18000
+#define HT_CAP_TX_BF_CAP_EXPLICIT_COMPRESSED_FB_SHIFT 15
+
 #define VHT_MAX_MPDU		11454	
 #define VHT_MPDU_MSDU_DELTA	56		
 
@@ -1951,6 +2923,8 @@ typedef struct dot11_obss_ie dot11_obss_ie_t;
 
 
 
+
+
 BWL_PRE_PACKED_STRUCT struct vht_cap_ie {
 	uint32  vht_cap_info;
 	
@@ -1961,23 +2935,22 @@ BWL_PRE_PACKED_STRUCT struct vht_cap_ie {
 } BWL_POST_PACKED_STRUCT;
 typedef struct vht_cap_ie vht_cap_ie_t;
 
+
 #define VHT_CAP_IE_LEN 12
 
-#define VHT_CAP_INFO_MAX_MPDU_LEN_MASK			0x00000003
+
+#define VHT_CAP_INFO_MAX_MPDU_LEN_MASK          0x00000003
 #define VHT_CAP_INFO_SUPP_CHAN_WIDTH_MASK       0x0000000c
 #define VHT_CAP_INFO_LDPC                       0x00000010
 #define VHT_CAP_INFO_SGI_80MHZ                  0x00000020
-
 #define VHT_CAP_INFO_SGI_160MHZ                 0x00000040
 #define VHT_CAP_INFO_TX_STBC                    0x00000080
-
 #define VHT_CAP_INFO_RX_STBC_MASK               0x00000700
 #define VHT_CAP_INFO_RX_STBC_SHIFT              8
 #define VHT_CAP_INFO_SU_BEAMFMR                 0x00000800
 #define VHT_CAP_INFO_SU_BEAMFMEE                0x00001000
 #define VHT_CAP_INFO_NUM_BMFMR_ANT_MASK         0x0000e000
 #define VHT_CAP_INFO_NUM_BMFMR_ANT_SHIFT        13
-
 #define VHT_CAP_INFO_NUM_SOUNDING_DIM_MASK      0x00070000
 #define VHT_CAP_INFO_NUM_SOUNDING_DIM_SHIFT     16
 #define VHT_CAP_INFO_MU_BEAMFMR                 0x00080000
@@ -1986,39 +2959,75 @@ typedef struct vht_cap_ie vht_cap_ie_t;
 #define VHT_CAP_INFO_HTCVHT                     0x00400000
 #define VHT_CAP_INFO_AMPDU_MAXLEN_EXP_MASK      0x03800000
 #define VHT_CAP_INFO_AMPDU_MAXLEN_EXP_SHIFT     23
-
 #define VHT_CAP_INFO_LINK_ADAPT_CAP_MASK        0x0c000000
 #define VHT_CAP_INFO_LINK_ADAPT_CAP_SHIFT       26
 
 
-#define VHT_CAP_SUPP_MCS_RX_HIGHEST_RATE_MASK	0x1fff
-#define VHT_CAP_SUPP_MCS_RX_HIGHEST_RATE_SHIFT	0
+#define VHT_CAP_SUPP_MCS_RX_HIGHEST_RATE_MASK   0x1fff
+#define VHT_CAP_SUPP_MCS_RX_HIGHEST_RATE_SHIFT  0
+
+#define VHT_CAP_SUPP_MCS_TX_HIGHEST_RATE_MASK   0x1fff
+#define VHT_CAP_SUPP_MCS_TX_HIGHEST_RATE_SHIFT  0
+
+#define VHT_CAP_MCS_MAP_0_7                     0
+#define VHT_CAP_MCS_MAP_0_8                     1
+#define VHT_CAP_MCS_MAP_0_9                     2
+#define VHT_CAP_MCS_MAP_NONE                    3
+#define VHT_CAP_MCS_MAP_S                       2 
+#define VHT_CAP_MCS_MAP_M                       0x3 
+
+#define VHT_CAP_MCS_MAP_NONE_ALL                0xffff
+
+#define VHT_CAP_MCS_MAP_0_9_NSS3 \
+	        ((VHT_CAP_MCS_MAP_0_9 << VHT_MCS_MAP_GET_SS_IDX(1)) | \
+	         (VHT_CAP_MCS_MAP_0_9 << VHT_MCS_MAP_GET_SS_IDX(2)) | \
+	         (VHT_CAP_MCS_MAP_0_9 << VHT_MCS_MAP_GET_SS_IDX(3)))
+
+#define VHT_CAP_MCS_MAP_NSS_MAX                 8
+
+
+#define VHT_CAP_MCS_MAP_CREATE(mcsmap, nss, mcs) \
+	do { \
+		int i; \
+		for (i = 1; i <= nss; i++) { \
+			VHT_MCS_MAP_SET_MCS_PER_SS(i, mcs, mcsmap); \
+		} \
+	} while (0)
+
 
-#define VHT_CAP_SUPP_MCS_TX_HIGHEST_RATE_MASK	0x1fff
-#define VHT_CAP_SUPP_MCS_TX_HIGHEST_RATE_SHIFT	0
+#define VHT_MCS_CODE_TO_MCS_MAP(mcs_code) \
+	((mcs_code == VHT_CAP_MCS_MAP_0_7) ? 0xff : \
+	 (mcs_code == VHT_CAP_MCS_MAP_0_8) ? 0x1ff : \
+	 (mcs_code == VHT_CAP_MCS_MAP_0_9) ? 0x3ff : 0)
 
-#define VHT_CAP_MCS_MAP_0_7						0
-#define VHT_CAP_MCS_MAP_0_8						1
-#define VHT_CAP_MCS_MAP_0_9						2
-#define VHT_CAP_MCS_MAP_NONE					3
 
-#define VHT_CAP_MCS_MAP_NSS_MAX					8
+#define VHT_MCS_MAP_TO_MCS_CODE(mcs_map) \
+	((mcs_map == 0xff)  ? VHT_CAP_MCS_MAP_0_7 : \
+	 (mcs_map == 0x1ff) ? VHT_CAP_MCS_MAP_0_8 : \
+	 (mcs_map == 0x3ff) ? VHT_CAP_MCS_MAP_0_9 : VHT_CAP_MCS_MAP_NONE)
 
 
 typedef enum vht_cap_chan_width {
-	VHT_CAP_CHAN_WIDTH_20_40  = 0x00,
-	VHT_CAP_CHAN_WIDTH_80	  = 0x04,
-	VHT_CAP_CHAN_WIDTH_160	  = 0x08
+	VHT_CAP_CHAN_WIDTH_SUPPORT_MANDATORY = 0x00,
+	VHT_CAP_CHAN_WIDTH_SUPPORT_160       = 0x04,
+	VHT_CAP_CHAN_WIDTH_SUPPORT_160_8080  = 0x08
 } vht_cap_chan_width_t;
 
 
 typedef enum vht_cap_max_mpdu_len {
-	VHT_CAP_MPDU_MAX_4K		= 0x00,
-	VHT_CAP_MPDU_MAX_8K		= 0x01,
-	VHT_CAP_MPDU_MAX_11K	= 0x02
+	VHT_CAP_MPDU_MAX_4K     = 0x00,
+	VHT_CAP_MPDU_MAX_8K     = 0x01,
+	VHT_CAP_MPDU_MAX_11K    = 0x02
 } vht_cap_max_mpdu_len_t;
 
 
+#define VHT_MPDU_LIMIT_4K        3895
+#define VHT_MPDU_LIMIT_8K        7991
+#define VHT_MPDU_LIMIT_11K      11454
+
+
+
+
 BWL_PRE_PACKED_STRUCT struct vht_op_ie {
 	uint8	chan_width;
 	uint8	chan1;
@@ -2027,6 +3036,7 @@ BWL_PRE_PACKED_STRUCT struct vht_op_ie {
 } BWL_POST_PACKED_STRUCT;
 typedef struct vht_op_ie vht_op_ie_t;
 
+
 #define VHT_OP_IE_LEN 5
 
 typedef enum vht_op_chan_width {
@@ -2037,11 +3047,28 @@ typedef enum vht_op_chan_width {
 } vht_op_chan_width_t;
 
 
-#define VHT_MCS_MAP_GET_SS_IDX(numSpatialStreams) ((numSpatialStreams-1)*2)
-#define VHT_MCS_MAP_GET_MCS_PER_SS(numSpatialStreams, mcsMap) \
-			((mcsMap >> VHT_MCS_MAP_GET_SS_IDX(numSpatialStreams)) & 0x3)
-#define VHT_MCS_MAP_SET_MCS_PER_SS(numSpatialStreams, numMcs, mcsMap) \
-			(mcsMap |= ((numMcs & 0x3) << VHT_MCS_MAP_GET_SS_IDX(numSpatialStreams)))
+#define AID_IE_LEN		2
+
+#define VHT_FEATURES_IE_TYPE	0x4
+BWL_PRE_PACKED_STRUCT struct vht_features_ie_hdr {
+	uint8 oui[3];		
+	uint8 type;		
+	uint8 rate_mask;	
+} BWL_POST_PACKED_STRUCT;
+typedef struct vht_features_ie_hdr vht_features_ie_hdr_t;
+
+
+#define VHT_MCS_MAP_GET_SS_IDX(nss) (((nss)-1) * VHT_CAP_MCS_MAP_S)
+#define VHT_MCS_MAP_GET_MCS_PER_SS(nss, mcsMap) \
+	(((mcsMap) >> VHT_MCS_MAP_GET_SS_IDX(nss)) & VHT_CAP_MCS_MAP_M)
+#define VHT_MCS_MAP_SET_MCS_PER_SS(nss, numMcs, mcsMap) \
+	do { \
+	 (mcsMap) &= (~(VHT_CAP_MCS_MAP_M << VHT_MCS_MAP_GET_SS_IDX(nss))); \
+	 (mcsMap) |= (((numMcs) & VHT_CAP_MCS_MAP_M) << VHT_MCS_MAP_GET_SS_IDX(nss)); \
+	} while (0)
+#define VHT_MCS_SS_SUPPORTED(nss, mcsMap) \
+		 (VHT_MCS_MAP_GET_MCS_PER_SS((nss), (mcsMap)) != VHT_CAP_MCS_MAP_NONE)
+
 
 
 #define WPA_OUI			"\x00\x50\xF2"	
@@ -2069,13 +3096,17 @@ typedef enum vht_op_chan_width {
 #ifdef P2P_IE_OVRD
 #define WFA_OUI_TYPE_P2P	MAC_OUI_TYPE_P2P
 #else
+#define WFA_OUI_TYPE_TPC	8
 #define WFA_OUI_TYPE_P2P	9
 #endif
 
 #define WFA_OUI_TYPE_TPC	8
 #ifdef WLTDLS
+#define WFA_OUI_TYPE_TPQ	4	
+#define WFA_OUI_TYPE_TPS	5	
 #define WFA_OUI_TYPE_WFD	10
 #endif 
+#define WFA_OUI_TYPE_HS20	0x10
 
 
 #define RSN_AKM_NONE		0	
@@ -2109,6 +3140,7 @@ typedef enum vht_op_chan_width {
 #define AES_KEY_SIZE		16	
 #define AES_MIC_SIZE		8	
 #define BIP_KEY_SIZE		16	
+#define BIP_MIC_SIZE		8   
 
 
 #define WCN_OUI			"\x00\x50\xf2"	
@@ -2157,7 +3189,6 @@ BWL_PRE_PACKED_STRUCT struct dot11_timeout_ie {
 typedef struct dot11_timeout_ie dot11_timeout_ie_t;
 
 
-
 BWL_PRE_PACKED_STRUCT struct dot11_gtk_ie {
 	uint8 id;
 	uint8 len;
@@ -2168,6 +3199,16 @@ BWL_PRE_PACKED_STRUCT struct dot11_gtk_ie {
 } BWL_POST_PACKED_STRUCT;
 typedef struct dot11_gtk_ie dot11_gtk_ie_t;
 
+
+BWL_PRE_PACKED_STRUCT struct mmic_ie {
+	uint8   id;					
+	uint8   len;				
+	uint16  key_id;				
+	uint8   ipn[6];				
+	uint8   mic[BIP_MIC_SIZE];	
+} BWL_POST_PACKED_STRUCT;
+typedef struct mmic_ie mmic_ie_t;
+
 #define BSSID_INVALID           "\x00\x00\x00\x00\x00\x00"
 #define BSSID_BROADCAST         "\xFF\xFF\xFF\xFF\xFF\xFF"
 
@@ -2248,6 +3289,156 @@ typedef struct pu_buffer_status_ie pu_buffer_status_ie_t;
 #define TDLS_PU_BUFFER_STATUS_AC_VO		8
 
 
+#define GAS_REQUEST_ACTION_FRAME				10
+#define GAS_RESPONSE_ACTION_FRAME				11
+#define GAS_COMEBACK_REQUEST_ACTION_FRAME		12
+#define GAS_COMEBACK_RESPONSE_ACTION_FRAME		13
+
+
+#define IW_ANT_MASK				0x0f
+#define IW_INTERNET_MASK		0x10
+#define IW_ASRA_MASK			0x20
+#define IW_ESR_MASK				0x40
+#define IW_UESA_MASK			0x80
+
+
+#define IW_ANT_PRIVATE_NETWORK					0
+#define IW_ANT_PRIVATE_NETWORK_WITH_GUEST		1
+#define IW_ANT_CHARGEABLE_PUBLIC_NETWORK		2
+#define IW_ANT_FREE_PUBLIC_NETWORK				3
+#define IW_ANT_PERSONAL_DEVICE_NETWORK			4
+#define IW_ANT_EMERGENCY_SERVICES_NETWORK		5
+#define IW_ANT_TEST_NETWORK						14
+#define IW_ANT_WILDCARD_NETWORK					15
+
+
+#define ADVP_ANQP_PROTOCOL_ID	0
+
+
+#define ADVP_QRL_MASK					0x7f
+#define ADVP_PAME_BI_MASK				0x80
+
+
+#define ADVP_QRL_REQUEST				0x00
+#define ADVP_QRL_RESPONSE				0x7f
+#define ADVP_PAME_BI_DEPENDENT			0x00
+#define ADVP_PAME_BI_INDEPENDENT		ADVP_PAME_BI_MASK
+
+
+#define ANQP_ID_QUERY_LIST							256
+#define ANQP_ID_CAPABILITY_LIST						257
+#define ANQP_ID_VENUE_NAME_INFO						258
+#define ANQP_ID_EMERGENCY_CALL_NUMBER_INFO			259
+#define ANQP_ID_NETWORK_AUTHENTICATION_TYPE_INFO	260
+#define ANQP_ID_ROAMING_CONSORTIUM_LIST				261
+#define ANQP_ID_IP_ADDRESS_TYPE_AVAILABILITY_INFO	262
+#define ANQP_ID_NAI_REALM_LIST						263
+#define ANQP_ID_G3PP_CELLULAR_NETWORK_INFO			264
+#define ANQP_ID_AP_GEOSPATIAL_LOCATION				265
+#define ANQP_ID_AP_CIVIC_LOCATION					266
+#define ANQP_ID_AP_LOCATION_PUBLIC_ID_URI			267
+#define ANQP_ID_DOMAIN_NAME_LIST					268
+#define ANQP_ID_EMERGENCY_ALERT_ID_URI				269
+#define ANQP_ID_EMERGENCY_NAI						271
+#define ANQP_ID_VENDOR_SPECIFIC_LIST				56797
+
+
+#define ANQP_OUI_SUBTYPE	9
+
+
+#define VENUE_LANGUAGE_CODE_SIZE		3
+#define VENUE_NAME_SIZE					255
+
+
+#define VENUE_UNSPECIFIED				0
+#define VENUE_ASSEMBLY					1
+#define VENUE_BUSINESS					2
+#define VENUE_EDUCATIONAL				3
+#define VENUE_FACTORY					4
+#define VENUE_INSTITUTIONAL				5
+#define VENUE_MERCANTILE				6
+#define VENUE_RESIDENTIAL				7
+#define VENUE_STORAGE					8
+#define VENUE_UTILITY					9
+#define VENUE_VEHICULAR					10
+#define VENUE_OUTDOOR					11
+
+
+#define NATI_ACCEPTANCE_OF_TERMS_CONDITIONS			0
+#define NATI_ONLINE_ENROLLMENT_SUPPORTED			1
+#define NATI_HTTP_HTTPS_REDIRECTION					2
+#define NATI_DNS_REDIRECTION						3
+
+
+#define IPA_IPV6_SHIFT						0
+#define IPA_IPV6_MASK						(0x03 << IPA_IPV6_SHIFT)
+#define	IPA_IPV6_NOT_AVAILABLE				0x00
+#define IPA_IPV6_AVAILABLE					0x01
+#define IPA_IPV6_UNKNOWN_AVAILABILITY		0x02
+
+
+#define IPA_IPV4_SHIFT						2
+#define IPA_IPV4_MASK						(0x3f << IPA_IPV4_SHIFT)
+#define	IPA_IPV4_NOT_AVAILABLE				0x00
+#define IPA_IPV4_PUBLIC						0x01
+#define IPA_IPV4_PORT_RESTRICT				0x02
+#define IPA_IPV4_SINGLE_NAT					0x03
+#define IPA_IPV4_DOUBLE_NAT					0x04
+#define IPA_IPV4_PORT_RESTRICT_SINGLE_NAT	0x05
+#define IPA_IPV4_PORT_RESTRICT_DOUBLE_NAT	0x06
+#define IPA_IPV4_UNKNOWN_AVAILABILITY		0x07
+
+
+#define REALM_ENCODING_RFC4282	0
+#define REALM_ENCODING_UTF8		1
+
+
+#define REALM_EAP_TLS					13
+#define REALM_EAP_SIM					18
+#define REALM_EAP_TTLS					21
+#define REALM_EAP_AKA					23
+#define REALM_EAP_PSK					47
+#define REALM_EAP_AKAP					50
+
+
+#define REALM_EXPANDED_EAP						1
+#define REALM_NON_EAP_INNER_AUTHENTICATION		2
+#define REALM_INNER_AUTHENTICATION_EAP			3
+#define REALM_EXPANDED_INNER_EAP				4
+#define REALM_CREDENTIAL						5
+#define REALM_TUNNELED_EAP_CREDENTIAL			6
+#define REALM_VENDOR_SPECIFIC_EAP				221
+
+
+#define REALM_PAP					1
+#define REALM_CHAP					2
+#define REALM_MSCHAP				3
+#define REALM_MSCHAPV2				4
+
+
+#define REALM_SIM					1
+#define REALM_USIM					2
+#define REALM_NFC					3
+#define REALM_HARDWARE_TOKEN		4
+#define REALM_SOFTOKEN				5
+#define REALM_CERTIFICATE			6
+#define REALM_USERNAME_PASSWORD		7
+#define REALM_SERVER_SIDE			8
+
+
+#define G3PP_GUD_VERSION		0
+#define G3PP_PLMN_LIST_IE		0
+
+
+BWL_PRE_PACKED_STRUCT struct hs20_ie {
+	uint8 oui[3];
+	uint8 type;
+	uint8 config;
+} BWL_POST_PACKED_STRUCT;
+typedef struct hs20_ie hs20_ie_t;
+#define HS20_IE_LEN 5	
+
+
 #include <packed_section_end.h>
 
 #endif 
diff --git a/drivers/net/wireless/bcmdhd/include/proto/802.11_bta.h b/drivers/net/wireless/bcmdhd/include/proto/802.11_bta.h
old mode 100644
new mode 100755
index 3ee5a74..1a53542
--- a/drivers/net/wireless/bcmdhd/include/proto/802.11_bta.h
+++ b/drivers/net/wireless/bcmdhd/include/proto/802.11_bta.h
@@ -1,27 +1,9 @@
 /*
  * BT-AMP (BlueTooth Alternate Mac and Phy) 802.11 PAL (Protocol Adaptation Layer)
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: 802.11_bta.h 294267 2011-11-04 23:41:52Z $
+ * $Id: 802.11_bta.h 382882 2013-02-04 23:24:31Z $
 */
 
 #ifndef _802_11_BTA_H_
diff --git a/drivers/net/wireless/bcmdhd/include/proto/802.11e.h b/drivers/net/wireless/bcmdhd/include/proto/802.11e.h
old mode 100644
new mode 100755
index f391e68..914d278
--- a/drivers/net/wireless/bcmdhd/include/proto/802.11e.h
+++ b/drivers/net/wireless/bcmdhd/include/proto/802.11e.h
@@ -1,27 +1,9 @@
 /*
  * 802.11e protocol header file
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: 802.11e.h 241182 2011-02-17 21:50:03Z $
+ * $Id: 802.11e.h 382883 2013-02-04 23:26:09Z $
  */
 
 #ifndef _802_11e_H_
@@ -110,13 +92,20 @@ typedef BWL_PRE_PACKED_STRUCT struct tspec {
 #define QBSS_LOAD_IE_LEN		5	/* QBSS Load IE length */
 #define QBSS_LOAD_AAC_OFF		3	/* AAC offset in IE */
 
-#define CAC_ADDTS_RESP_TIMEOUT		300	/* default ADDTS response timeout in ms */
+#define CAC_ADDTS_RESP_TIMEOUT		1000	/* default ADDTS response timeout in ms */
+						/* DEFVAL dot11ADDTSResponseTimeout = 1s */
 
 /* 802.11e ADDTS status code */
 #define DOT11E_STATUS_ADMISSION_ACCEPTED	0	/* TSPEC Admission accepted status */
 #define DOT11E_STATUS_ADDTS_INVALID_PARAM	1	/* TSPEC invalid parameter status */
 #define DOT11E_STATUS_ADDTS_REFUSED_NSBW	3	/* ADDTS refused (non-sufficient BW) */
 #define DOT11E_STATUS_ADDTS_REFUSED_AWHILE	47	/* ADDTS refused but could retry later */
+#ifdef BCMCCX
+#define CCX_STATUS_ASSOC_DENIED_UNKNOWN    0xc8	/* unspecified QoS related failure */
+#define CCX_STATUS_ASSOC_DENIED_AP_POLICY  0xc9	/* TSPEC refused due to AP policy */
+#define CCX_STATUS_ASSOC_DENIED_NO_BW	   0xca	/* Assoc denied due to AP insufficient BW */
+#define CCX_STATUS_ASSOC_DENIED_BAD_PARAM  0xcb	/* one or more TSPEC with invalid parameter */
+#endif	/* BCMCCX */
 
 /* 802.11e DELTS status code */
 #define DOT11E_STATUS_QSTA_LEAVE_QBSS		36	/* STA leave QBSS */
diff --git a/drivers/net/wireless/bcmdhd/include/proto/802.1d.h b/drivers/net/wireless/bcmdhd/include/proto/802.1d.h
old mode 100644
new mode 100755
index 116a226..f2c6e2d
--- a/drivers/net/wireless/bcmdhd/include/proto/802.1d.h
+++ b/drivers/net/wireless/bcmdhd/include/proto/802.1d.h
@@ -1,27 +1,9 @@
 /*
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * Fundamental types and constants relating to 802.1D
  *
- * $Id: 802.1d.h 241182 2011-02-17 21:50:03Z $
+ * $Id: 802.1d.h 382882 2013-02-04 23:24:31Z $
  */
 
 #ifndef _802_1_D_
diff --git a/drivers/net/wireless/bcmdhd/include/proto/802.3.h b/drivers/net/wireless/bcmdhd/include/proto/802.3.h
new file mode 100755
index 0000000..2fd09fc
--- /dev/null
+++ b/drivers/net/wireless/bcmdhd/include/proto/802.3.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;
+ * the contents of this file may not be disclosed to third parties, copied
+ * or duplicated in any form, in whole or in part, without the prior
+ * written permission of Broadcom Corporation.
+ *
+ * Fundamental constants relating to 802.3
+ *
+ * $Id: 802.3.h 382882 2013-02-04 23:24:31Z $
+ */
+
+#ifndef _802_3_h_
+#define _802_3_h_
+
+/* This marks the start of a packed structure section. */
+#include <packed_section_start.h>
+
+#define SNAP_HDR_LEN	6	/* 802.3 SNAP header length */
+#define DOT3_OUI_LEN	3	/* 802.3 oui length */
+
+BWL_PRE_PACKED_STRUCT struct dot3_mac_llc_snap_header {
+	uint8	ether_dhost[ETHER_ADDR_LEN];	/* dest mac */
+	uint8	ether_shost[ETHER_ADDR_LEN];	/* src mac */
+	uint16	length;				/* frame length incl header */
+	uint8	dsap;				/* always 0xAA */
+	uint8	ssap;				/* always 0xAA */
+	uint8	ctl;				/* always 0x03 */
+	uint8	oui[DOT3_OUI_LEN];		/* RFC1042: 0x00 0x00 0x00
+						 * Bridge-Tunnel: 0x00 0x00 0xF8
+						 */
+	uint16	type;				/* ethertype */
+} BWL_POST_PACKED_STRUCT;
+
+/* This marks the end of a packed structure section. */
+#include <packed_section_end.h>
+
+#endif	/* #ifndef _802_3_h_ */
diff --git a/drivers/net/wireless/bcmdhd/include/proto/bcmeth.h b/drivers/net/wireless/bcmdhd/include/proto/bcmeth.h
old mode 100644
new mode 100755
index e54b2e3..f030584
--- a/drivers/net/wireless/bcmdhd/include/proto/bcmeth.h
+++ b/drivers/net/wireless/bcmdhd/include/proto/bcmeth.h
@@ -1,27 +1,9 @@
 /*
  * Broadcom Ethernettype  protocol definitions
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: bcmeth.h 294352 2011-11-06 19:23:00Z $
+ * $Id: bcmeth.h 382882 2013-02-04 23:24:31Z $
  */
 
 
diff --git a/drivers/net/wireless/bcmdhd/include/proto/bcmevent.h b/drivers/net/wireless/bcmdhd/include/proto/bcmevent.h
old mode 100644
new mode 100755
index 0a337f6..7033dea
--- a/drivers/net/wireless/bcmdhd/include/proto/bcmevent.h
+++ b/drivers/net/wireless/bcmdhd/include/proto/bcmevent.h
@@ -1,29 +1,11 @@
 /*
  * Broadcom Event  protocol definitions
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * Dependencies: proto/bcmeth.h
  *
- * $Id: bcmevent.h 326276 2012-04-06 23:16:42Z $
+ * $Id: bcmevent.h 386716 2013-02-21 18:16:10Z $
  *
  */
 
@@ -36,6 +18,8 @@
 #include <typedefs.h>
 #endif
 
+#include <proto/bcmeth.h>
+
 
 #include <packed_section_start.h>
 
@@ -134,6 +118,10 @@ typedef BWL_PRE_PACKED_STRUCT struct bcm_event {
 #define WLC_E_IBSS_ASSOC	39
 #define WLC_E_RADIO		40
 #define WLC_E_PSM_WATCHDOG	41	
+#if defined(BCMCCX) && defined(CCX_SDK)
+#define WLC_E_CCX_ASSOC_START	42	
+#define WLC_E_CCX_ASSOC_ABORT	43	
+#endif 
 #define WLC_E_PROBREQ_MSG       44      
 #define WLC_E_SCAN_CONFIRM_IND  45
 #define WLC_E_PSK_SUP		46	
@@ -141,7 +129,7 @@ typedef BWL_PRE_PACKED_STRUCT struct bcm_event {
 #define	WLC_E_EXCEEDED_MEDIUM_TIME	48	
 #define WLC_E_ICV_ERROR		49	
 #define WLC_E_UNICAST_DECODE_ERROR	50	
-#define WLC_E_MULTICAST_DECODE_ERROR	51 
+#define WLC_E_MULTICAST_DECODE_ERROR	51	
 #define WLC_E_TRACE		52
 #ifdef WLBTAMP
 #define WLC_E_BTA_HCI_EVENT	53	
@@ -166,9 +154,7 @@ typedef BWL_PRE_PACKED_STRUCT struct bcm_event {
 #define WLC_E_PROBRESP_MSG	71	
 #define WLC_E_P2P_PROBREQ_MSG	72	
 #define WLC_E_DCS_REQUEST	73
-
 #define WLC_E_FIFO_CREDIT_MAP	74	
-
 #define WLC_E_ACTION_FRAME_RX	75	
 #define WLC_E_WAKE_EVENT	76	
 #define WLC_E_RM_COMPLETE	77	
@@ -178,17 +164,50 @@ typedef BWL_PRE_PACKED_STRUCT struct bcm_event {
 #define WLC_E_EXCESS_PM_WAKE_EVENT	81	
 #define WLC_E_PFN_SCAN_NONE		82	
 #define WLC_E_PFN_SCAN_ALLGONE		83	
-#define WLC_E_GTK_PLUMBED 		84
+#define WLC_E_GTK_PLUMBED		84
 #define WLC_E_ASSOC_IND_NDIS		85	
 #define WLC_E_REASSOC_IND_NDIS		86	
-#define WLC_E_ASSOC_REQ_IE 		87
-#define WLC_E_ASSOC_RESP_IE 		88
-#define WLC_E_ASSOC_RECREATED	89	
+#define WLC_E_ASSOC_REQ_IE		87
+#define WLC_E_ASSOC_RESP_IE		88
+#define WLC_E_ASSOC_RECREATED		89	
 #define WLC_E_ACTION_FRAME_RX_NDIS	90	
-#define WLC_E_AUTH_REQ		91	
-#define WLC_E_TDLS_PEER_EVENT 	92	
+#define WLC_E_AUTH_REQ			91	
+#define WLC_E_TDLS_PEER_EVENT		92	
 #define WLC_E_SPEEDY_RECREATE_FAIL	93	
-#define WLC_E_LAST			94	
+#define WLC_E_NATIVE			94	
+#define WLC_E_PKTDELAY_IND		95	
+#define WLC_E_AWDL_AW			96	
+#define WLC_E_AWDL_ROLE			97	
+#define WLC_E_AWDL_EVENT		98	
+#ifdef WLNIC
+#define WLC_E_NIC_AF_TXS		99	
+#define WLC_E_NIC_NIC_REPORT		100	
+#endif
+#define WLC_E_BEACON_FRAME_RX		101
+#define WLC_E_SERVICE_FOUND		102	
+#define WLC_E_GAS_FRAGMENT_RX		103	
+#define WLC_E_GAS_COMPLETE		104	
+#define WLC_E_P2PO_ADD_DEVICE		105	
+#define WLC_E_P2PO_DEL_DEVICE		106	
+#define WLC_E_WNM_STA_SLEEP		107	
+#define WLC_E_NONE			108	
+#define WLC_E_PROXD			109	
+#define WLC_E_IBSS_COALESCE		110	
+#define WLC_E_AWDL_AW_EXT_END		111	
+#define WLC_E_AWDL_AW_EXT_START		112	
+#define WLC_E_AWDL_AW_START		113	
+#define WLC_E_AWDL_RADIO_OFF		114	
+#define WLC_E_AWDL_PEER_STATE		115	
+#define WLC_E_AWDL_SYNC_STATE_CHANGED	116	
+#define WLC_E_AWDL_CHIP_RESET		117	
+#define WLC_E_AWDL_INTERLEAVED_SCAN_START		118
+#define WLC_E_AWDL_INTERLEAVED_SCAN_STOP		119
+#define WLC_E_AWDL_PEER_CACHE_CONTROL			120
+#define WLC_E_CSA_START_IND		121
+#define WLC_E_CSA_DONE_IND		122
+#define WLC_E_CSA_FAILURE_IND		123
+#define WLC_E_CCA_CHAN_QUAL		124	
+#define WLC_E_LAST			125	
 
 
 
@@ -215,6 +234,9 @@ extern const int		bcmevent_names_size;
 #define WLC_E_STATUS_11HQUIET		11	
 #define WLC_E_STATUS_SUPPRESS		12	
 #define WLC_E_STATUS_NOCHANS		13	
+#ifdef BCMCCX
+#define WLC_E_STATUS_CCXFASTRM		14	
+#endif 
 #define WLC_E_STATUS_CS_ABORT		15	
 #define WLC_E_STATUS_ERROR		16	
 
@@ -224,19 +246,19 @@ extern const int		bcmevent_names_size;
 #define WLC_E_REASON_DEAUTH		2	
 #define WLC_E_REASON_DISASSOC		3	
 #define WLC_E_REASON_BCNS_LOST		4	
-#define WLC_E_REASON_MINTXRATE		9	
-#define WLC_E_REASON_TXFAIL		10	
 
 
 #define WLC_E_REASON_FAST_ROAM_FAILED	5	
 #define WLC_E_REASON_DIRECTED_ROAM	6	
 #define WLC_E_REASON_TSPEC_REJECTED	7	
 #define WLC_E_REASON_BETTER_AP		8	
-
+#define WLC_E_REASON_MINTXRATE		9	
+#define WLC_E_REASON_TXFAIL		10	
 
 #define WLC_E_REASON_REQUESTED_ROAM 11	
 
 
+
 #define WLC_E_PRUNE_ENCR_MISMATCH	1	
 #define WLC_E_PRUNE_BCAST_BSSID		2	
 #define WLC_E_PRUNE_MAC_DENY		3	
@@ -247,11 +269,21 @@ extern const int		bcmevent_names_size;
 #define WLC_E_RSN_MISMATCH		8	
 #define WLC_E_PRUNE_NO_COMMON_RATES	9	
 #define WLC_E_PRUNE_BASIC_RATES		10	
+#ifdef BCMCCX
+#define WLC_E_PRUNE_CCXFAST_PREVAP	11	
+#endif 
 #define WLC_E_PRUNE_CIPHER_NA		12	
 #define WLC_E_PRUNE_KNOWN_STA		13	
+#ifdef BCMCCX
+#define WLC_E_PRUNE_CCXFAST_DROAM	14	
+#endif 
 #define WLC_E_PRUNE_WDS_PEER		15	
 #define WLC_E_PRUNE_QBSS_LOAD		16	
 #define WLC_E_PRUNE_HOME_AP		17	
+#ifdef BCMCCX
+#define WLC_E_PRUNE_AP_BLOCKED		18	
+#define WLC_E_PRUNE_NO_DIAG_SUPPORT	19	
+#endif 
 
 
 #define WLC_E_SUP_OTHER			0	
@@ -273,6 +305,14 @@ extern const int		bcmevent_names_size;
 
 
 
+#ifdef WLAWDL
+#define WLC_E_AWDL_SCAN_START		1	
+#define WLC_E_AWDL_SCAN_DONE		0	
+
+#define WLC_E_AWDL_RX_ACT_FRAME					1
+#define WLC_E_AWDL_RX_PRB_RESP					2
+
+#endif
 typedef BWL_PRE_PACKED_STRUCT struct wl_event_rx_frame_data {
 	uint16	version;
 	uint16	channel;	
@@ -287,7 +327,7 @@ typedef BWL_PRE_PACKED_STRUCT struct wl_event_rx_frame_data {
 typedef struct wl_event_data_if {
 	uint8 ifidx;		
 	uint8 opcode;		
-	uint8 reserved;
+	uint8 reserved;		
 	uint8 bssidx;		
 	uint8 role;		
 } wl_event_data_if_t;
@@ -309,6 +349,16 @@ typedef struct wl_event_data_if {
 #endif
 
 
+typedef struct wl_event_data_rssi {
+	int32 rssi;
+	int32 snr;
+	int32 noise;
+} wl_event_data_rssi_t;
+
+
+#define WLC_E_IF_FLAGS_BSSCFG_NOIF	0x1	
+
+
 #define WLC_E_LINK_BCN_LOSS	1	
 #define WLC_E_LINK_DISASSOC	2	
 #define WLC_E_LINK_ASSOC_REC	3	
@@ -323,6 +373,66 @@ typedef struct wl_event_data_if {
 #define WLC_E_TDLS_PEER_CONNECTED		1
 #define WLC_E_TDLS_PEER_DISCONNECTED	2
 
+#ifdef WLAWDL
+
+#define WLC_E_AWDL_SCAN_STATUS	0
+#define WLC_E_AWDL_RX_ACT_FRAME	1
+#define WLC_E_AWDL_RX_PRB_RESP	2
+#define WLC_E_AWDL_PHYCAL_STATUS	3
+#define WLC_E_AWDL_WOWL_NULLPKT	4
+#define WLC_E_AWDL_OOB_AF_STATUS	5
+
+
+#define WLC_E_AWDL_SCAN_START		1	
+#define WLC_E_AWDL_SCAN_DONE		0	
+#define WLC_E_AWDL_PHYCAL_START		1	
+#define WLC_E_AWDL_PHYCAL_DONE		0	
+#endif
+
+
+typedef BWL_PRE_PACKED_STRUCT struct wl_event_gas {
+	uint16	channel;		
+	uint8	dialog_token;	
+	uint8	fragment_id;	
+	uint16	status_code;	
+	uint16 	data_len;		
+	uint8	data[1];		
+} BWL_POST_PACKED_STRUCT wl_event_gas_t;
+
+
+typedef BWL_PRE_PACKED_STRUCT struct wl_sd_tlv {
+	uint16	length;			
+	uint8	protocol;		
+	uint8	transaction_id;		
+	uint8	status_code;		
+	uint8	data[1];		
+} BWL_POST_PACKED_STRUCT wl_sd_tlv_t;
+
+
+typedef BWL_PRE_PACKED_STRUCT struct wl_event_sd {
+	uint16	channel;		
+	uint8	count;			
+	wl_sd_tlv_t	tlv[1];		
+} BWL_POST_PACKED_STRUCT wl_event_sd_t;
+
+
+#define WLC_E_PROXD_FOUND	1	
+#define WLC_E_PROXD_GONE	2	
+
+
+typedef BWL_PRE_PACKED_STRUCT struct awdl_aws_event_data {
+	uint32	fw_time;			
+	struct	ether_addr current_master;	
+	uint16	aw_counter;			
+	uint8	aw_ext_count;			
+	uint8	aw_role;			
+	uint8	flags;				
+	uint16	aw_chan;
+} BWL_POST_PACKED_STRUCT awdl_aws_event_data_t;
+
+
+#define AWDL_AW_LAST_EXT	0x01
+
 
 #include <packed_section_end.h>
 
diff --git a/drivers/net/wireless/bcmdhd/include/proto/bcmip.h b/drivers/net/wireless/bcmdhd/include/proto/bcmip.h
old mode 100644
new mode 100755
index d5c3b76..d274b43
--- a/drivers/net/wireless/bcmdhd/include/proto/bcmip.h
+++ b/drivers/net/wireless/bcmdhd/include/proto/bcmip.h
@@ -1,27 +1,9 @@
 /*
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * Fundamental constants relating to IP Protocol
  *
- * $Id: bcmip.h 290206 2011-10-17 19:13:51Z $
+ * $Id: bcmip.h 384540 2013-02-12 04:28:58Z $
  */
 
 #ifndef _bcmip_h_
@@ -52,15 +34,16 @@
 #define IP_PROT_ICMP6		0x3a	
 
 
-#define IPV4_VER_HL_OFFSET	0	
-#define IPV4_TOS_OFFSET		1	
-#define IPV4_PKTLEN_OFFSET	2	
-#define IPV4_PKTFLAG_OFFSET	6	
-#define IPV4_PROT_OFFSET	9	
-#define IPV4_CHKSUM_OFFSET	10	
-#define IPV4_SRC_IP_OFFSET	12	
-#define IPV4_DEST_IP_OFFSET	16	
-#define IPV4_OPTIONS_OFFSET	20	
+#define IPV4_VER_HL_OFFSET      0       
+#define IPV4_TOS_OFFSET         1       
+#define IPV4_PKTLEN_OFFSET      2       
+#define IPV4_PKTFLAG_OFFSET     6       
+#define IPV4_PROT_OFFSET        9       
+#define IPV4_CHKSUM_OFFSET      10      
+#define IPV4_SRC_IP_OFFSET      12      
+#define IPV4_DEST_IP_OFFSET     16      
+#define IPV4_OPTIONS_OFFSET     20      
+#define IPV4_MIN_HEADER_LEN     20      
 
 
 #define IPV4_VER_MASK		0xf0	
@@ -204,6 +187,8 @@ ipv6_exthdr_len(uint8 *h, uint8 *proto)
 	return len;
 }
 
+#define IPV4_ISMULTI(a) (((a) & 0xf0000000) == 0xe0000000)
+
 
 #include <packed_section_end.h>
 
diff --git a/drivers/net/wireless/bcmdhd/include/proto/bcmipv6.h b/drivers/net/wireless/bcmdhd/include/proto/bcmipv6.h
deleted file mode 100644
index 9533391..0000000
--- a/drivers/net/wireless/bcmdhd/include/proto/bcmipv6.h
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
- *
- * Fundamental constants relating to Neighbor Discovery Protocol
- *
- * $Id: bcmipv6.h 309193 2012-01-19 00:03:57Z $
- */
-
-#ifndef _bcmipv6_h_
-#define _bcmipv6_h_
-
-#ifndef _TYPEDEFS_H_
-#include <typedefs.h>
-#endif
-
-/* This marks the start of a packed structure section. */
-#include <packed_section_start.h>
-
-#define ICMPV6_HEADER_TYPE 	0x3A
-#define ICMPV6_PKT_TYPE_NS	135
-#define ICMPV6_PKT_TYPE_NA	136
-
-#define ICMPV6_ND_OPT_TYPE_TARGET_MAC	2
-#define ICMPV6_ND_OPT_TYPE_SRC_MAC		1
-
-#define IPV6_VERSION 	6
-#define IPV6_HOP_LIMIT 	255
-
-#define IPV6_ADDR_NULL(a)	((a[0] | a[1] | a[2] | a[3] | a[4] | \
-							 a[5] | a[6] | a[7] | a[8] | a[9] | \
-							 a[10] | a[11] | a[12] | a[13] | \
-							 a[14] | a[15]) == 0)
-
-/* IPV6 address */
-BWL_PRE_PACKED_STRUCT struct ipv6_addr {
-		uint8		addr[16];
-} BWL_POST_PACKED_STRUCT;
-
-
-/* ICMPV6 Header */
-BWL_PRE_PACKED_STRUCT struct icmp6_hdr {
-	uint8	icmp6_type;
-	uint8	icmp6_code;
-	uint16	icmp6_cksum;
-	BWL_PRE_PACKED_STRUCT union {
-		uint32 reserved;
-		BWL_PRE_PACKED_STRUCT struct nd_advt {
-			uint32	reserved1:5,
-				override:1,
-				solicited:1,
-				router:1,
-				reserved2:24;
-		} BWL_POST_PACKED_STRUCT nd_advt;
-	} BWL_POST_PACKED_STRUCT opt;
-} BWL_POST_PACKED_STRUCT;
-
-/* Ipv6 Header Format */
-BWL_PRE_PACKED_STRUCT struct ipv6_hdr {
-	uint8	priority:4,
-		version:4;
-	uint8	flow_lbl[3];
-	uint16	payload_len;
-	uint8	nexthdr;
-	uint8 	hop_limit;
-	struct	ipv6_addr	saddr;
-	struct	ipv6_addr	daddr;
-} BWL_POST_PACKED_STRUCT;
-
-/* Neighbor Advertisement/Solicitation Packet Structure */
-BWL_PRE_PACKED_STRUCT struct nd_msg {
-	struct icmp6_hdr	icmph;
-	struct ipv6_addr target;
-} BWL_POST_PACKED_STRUCT;
-
-
-/* Neighibor Solicitation/Advertisement Optional Structure */
-BWL_PRE_PACKED_STRUCT struct nd_msg_opt {
-	uint8 type;
-	uint8 len;
-	uint8 mac_addr[ETHER_ADDR_LEN];
-} BWL_POST_PACKED_STRUCT;
-
-/* This marks the end of a packed structure section. */
-#include <packed_section_end.h>
-
-#endif	/* !defined(_bcmipv6_h_) */
diff --git a/drivers/net/wireless/bcmdhd/include/proto/bt_amp_hci.h b/drivers/net/wireless/bcmdhd/include/proto/bt_amp_hci.h
old mode 100644
new mode 100755
index 8617985..bc91f84
--- a/drivers/net/wireless/bcmdhd/include/proto/bt_amp_hci.h
+++ b/drivers/net/wireless/bcmdhd/include/proto/bt_amp_hci.h
@@ -1,27 +1,9 @@
 /*
  * BT-AMP (BlueTooth Alternate Mac and Phy) HCI (Host/Controller Interface)
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: bt_amp_hci.h 294267 2011-11-04 23:41:52Z $
+ * $Id: bt_amp_hci.h 382882 2013-02-04 23:24:31Z $
 */
 
 #ifndef _bt_amp_hci_h
diff --git a/drivers/net/wireless/bcmdhd/include/proto/eapol.h b/drivers/net/wireless/bcmdhd/include/proto/eapol.h
old mode 100644
new mode 100755
index 8936d16..b59b84f
--- a/drivers/net/wireless/bcmdhd/include/proto/eapol.h
+++ b/drivers/net/wireless/bcmdhd/include/proto/eapol.h
@@ -7,7 +7,7 @@
  *
  * Copyright (C) 2002 Broadcom Corporation
  *
- * $Id: eapol.h 241182 2011-02-17 21:50:03Z $
+ * $Id: eapol.h 382882 2013-02-04 23:24:31Z $
  */
 
 #ifndef _eapol_h_
diff --git a/drivers/net/wireless/bcmdhd/include/proto/ethernet.h b/drivers/net/wireless/bcmdhd/include/proto/ethernet.h
old mode 100644
new mode 100755
index e455185..54b5561
--- a/drivers/net/wireless/bcmdhd/include/proto/ethernet.h
+++ b/drivers/net/wireless/bcmdhd/include/proto/ethernet.h
@@ -1,30 +1,12 @@
 /*
  * From FreeBSD 2.2.7: Fundamental constants relating to ethernet.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: ethernet.h 309193 2012-01-19 00:03:57Z $
+ * $Id: ethernet.h 384540 2013-02-12 04:28:58Z $
  */
 
-#ifndef _NET_ETHERNET_H_	      
+#ifndef _NET_ETHERNET_H_	        
 #define _NET_ETHERNET_H_
 
 #ifndef _TYPEDEFS_H_
@@ -67,11 +49,16 @@
 #define	ETHER_TYPE_IPV6		0x86dd		
 #define	ETHER_TYPE_BRCM		0x886c		
 #define	ETHER_TYPE_802_1X	0x888e		
+#ifdef PLC
+#define	ETHER_TYPE_88E1		0x88e1		
+#define	ETHER_TYPE_8912		0x8912		
+#define ETHER_TYPE_GIGLED	0xffff		
+#endif 
 #define	ETHER_TYPE_802_1X_PREAUTH 0x88c7	
 #define ETHER_TYPE_WAI		0x88b4		
 #define ETHER_TYPE_89_0D	0x890d		
 
-#define ETHER_TYPE_IPV6		0x86dd		
+#define ETHER_TYPE_PPP_SES	0x8864		
 
 
 #define	ETHER_BRCM_SUBTYPE_LEN	4	
@@ -94,7 +81,7 @@
 		((uint8 *)ea)[5] = ((mgrp_ip) >>  0) & 0xff;	\
 }
 
-#ifndef __INCif_etherh       
+#ifndef __INCif_etherh         
 
 BWL_PRE_PACKED_STRUCT struct ether_header {
 	uint8	ether_dhost[ETHER_ADDR_LEN];
@@ -122,32 +109,53 @@ BWL_PRE_PACKED_STRUCT struct	ether_addr {
 
 
 
-#define	ether_cmp(a, b)	(!(((short*)(a))[0] == ((short*)(b))[0]) | \
-			 !(((short*)(a))[1] == ((short*)(b))[1]) | \
-			 !(((short*)(a))[2] == ((short*)(b))[2]))
+#define eacmp(a, b)	((((const uint16 *)(a))[0] ^ ((const uint16 *)(b))[0]) | \
+	                 (((const uint16 *)(a))[1] ^ ((const uint16 *)(b))[1]) | \
+	                 (((const uint16 *)(a))[2] ^ ((const uint16 *)(b))[2]))
+
+#define	ether_cmp(a, b)	eacmp(a, b)
+
+
+#define eacopy(s, d) \
+do { \
+	((uint16 *)(d))[0] = ((const uint16 *)(s))[0]; \
+	((uint16 *)(d))[1] = ((const uint16 *)(s))[1]; \
+	((uint16 *)(d))[2] = ((const uint16 *)(s))[2]; \
+} while (0)
+
+#define	ether_copy(s, d) eacopy(s, d)
+
 
+#define	ether_rcopy(s, d) \
+do { \
+	((uint16 *)(d))[2] = ((uint16 *)(s))[2]; \
+	((uint16 *)(d))[1] = ((uint16 *)(s))[1]; \
+	((uint16 *)(d))[0] = ((uint16 *)(s))[0]; \
+} while (0)
 
-#define	ether_copy(s, d) { \
-		((short*)(d))[0] = ((const short*)(s))[0]; \
-		((short*)(d))[1] = ((const short*)(s))[1]; \
-		((short*)(d))[2] = ((const short*)(s))[2]; }
 
 
 static const struct ether_addr ether_bcast = {{255, 255, 255, 255, 255, 255}};
 static const struct ether_addr ether_null = {{0, 0, 0, 0, 0, 0}};
-
-#define ETHER_ISBCAST(ea)	((((uint8 *)(ea))[0] &		\
-	                          ((uint8 *)(ea))[1] &		\
-				  ((uint8 *)(ea))[2] &		\
-				  ((uint8 *)(ea))[3] &		\
-				  ((uint8 *)(ea))[4] &		\
-				  ((uint8 *)(ea))[5]) == 0xff)
-#define ETHER_ISNULLADDR(ea)	((((uint8 *)(ea))[0] |		\
-				  ((uint8 *)(ea))[1] |		\
-				  ((uint8 *)(ea))[2] |		\
-				  ((uint8 *)(ea))[3] |		\
-				  ((uint8 *)(ea))[4] |		\
-				  ((uint8 *)(ea))[5]) == 0)
+static const struct ether_addr ether_ipv6_mcast = {{0x33, 0x33, 0x00, 0x00, 0x00, 0x01}};
+
+#define ETHER_ISBCAST(ea)	((((const uint8 *)(ea))[0] &		\
+	                          ((const uint8 *)(ea))[1] &		\
+				  ((const uint8 *)(ea))[2] &		\
+				  ((const uint8 *)(ea))[3] &		\
+				  ((const uint8 *)(ea))[4] &		\
+				  ((const uint8 *)(ea))[5]) == 0xff)
+#define ETHER_ISNULLADDR(ea)	((((const uint8 *)(ea))[0] |		\
+				  ((const uint8 *)(ea))[1] |		\
+				  ((const uint8 *)(ea))[2] |		\
+				  ((const uint8 *)(ea))[3] |		\
+				  ((const uint8 *)(ea))[4] |		\
+				  ((const uint8 *)(ea))[5]) == 0)
+
+#define ETHER_ISNULLDEST(da)	((((const uint16 *)(da))[0] |           \
+				  ((const uint16 *)(da))[1] |           \
+				  ((const uint16 *)(da))[2]) == 0)
+#define ETHER_ISNULLSRC(sa)	ETHER_ISNULLDEST(sa)
 
 #define ETHER_MOVE_HDR(d, s) \
 do { \
@@ -156,6 +164,8 @@ do { \
 	*(struct ether_header *)(d) = t; \
 } while (0)
 
+#define  ETHER_ISUCAST(ea) ((((uint8 *)(ea))[0] & 0x01) == 0)
+
 
 #include <packed_section_end.h>
 
diff --git a/drivers/net/wireless/bcmdhd/include/proto/p2p.h b/drivers/net/wireless/bcmdhd/include/proto/p2p.h
old mode 100644
new mode 100755
index 19493eb..4d6756e
--- a/drivers/net/wireless/bcmdhd/include/proto/p2p.h
+++ b/drivers/net/wireless/bcmdhd/include/proto/p2p.h
@@ -1,27 +1,9 @@
 /*
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * Fundamental types and constants relating to WFA P2P (aka WiFi Direct)
  *
- * $Id: p2p.h 326276 2012-04-06 23:16:42Z $
+ * $Id: p2p.h 384536 2013-02-12 04:13:09Z $
  */
 
 #ifndef _P2P_H_
@@ -376,6 +358,7 @@ typedef struct wifi_p2p_pub_act_frame wifi_p2p_pub_act_frame_t;
 #define P2P_PAF_DEVDIS_RSP	6	
 #define P2P_PAF_PROVDIS_REQ	7	
 #define P2P_PAF_PROVDIS_RSP	8	
+#define P2P_PAF_SUBTYPE_INVALID	255	
 
 
 #define P2P_TYPE_MNREQ		P2P_PAF_GON_REQ
@@ -402,6 +385,8 @@ typedef struct wifi_p2p_noa_se wifi_p2p_noa_se_t;
 
 #define P2P_NOA_SE_FIXED_LEN	5
 
+#define P2P_NOA_SE_MAX_DESC	2	
+
 
 #define P2P_NOA_DESC_CNT_RESERVED	0	
 #define P2P_NOA_DESC_CNT_REPEAT		255	
diff --git a/drivers/net/wireless/bcmdhd/include/proto/sdspi.h b/drivers/net/wireless/bcmdhd/include/proto/sdspi.h
old mode 100644
new mode 100755
index a4900ed..647a217
--- a/drivers/net/wireless/bcmdhd/include/proto/sdspi.h
+++ b/drivers/net/wireless/bcmdhd/include/proto/sdspi.h
@@ -1,27 +1,9 @@
 /*
  * SD-SPI Protocol Standard
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $ Copyright Open Broadcom Corporation $
  *
- * $Id: sdspi.h 241182 2011-02-17 21:50:03Z $
+ * $Id: sdspi.h 382882 2013-02-04 23:24:31Z $
  */
 #ifndef	_SD_SPI_H
 #define	_SD_SPI_H
diff --git a/drivers/net/wireless/bcmdhd/include/proto/vlan.h b/drivers/net/wireless/bcmdhd/include/proto/vlan.h
old mode 100644
new mode 100755
index 9c94985..bf48965
--- a/drivers/net/wireless/bcmdhd/include/proto/vlan.h
+++ b/drivers/net/wireless/bcmdhd/include/proto/vlan.h
@@ -1,27 +1,9 @@
 /*
  * 802.1Q VLAN protocol definitions
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: vlan.h 241182 2011-02-17 21:50:03Z $
+ * $Id: vlan.h 382883 2013-02-04 23:26:09Z $
  */
 
 #ifndef _vlan_h_
@@ -34,17 +16,28 @@
 
 #include <packed_section_start.h>
 
+#ifndef	 VLAN_VID_MASK
 #define VLAN_VID_MASK		0xfff	
+#endif
+
 #define	VLAN_CFI_SHIFT		12	
 #define VLAN_PRI_SHIFT		13	
 
 #define VLAN_PRI_MASK		7	
 
+#define	VLAN_TPID_OFFSET	12	
+#define	VLAN_TCI_OFFSET		14	
+
 #define	VLAN_TAG_LEN		4
 #define	VLAN_TAG_OFFSET		(2 * ETHER_ADDR_LEN)	
 
 #define VLAN_TPID		0x8100	
 
+struct vlan_header {
+	uint16	vlan_type;		
+	uint16	vlan_tag;		
+};
+
 struct ethervlan_header {
 	uint8	ether_dhost[ETHER_ADDR_LEN];
 	uint8	ether_shost[ETHER_ADDR_LEN];
@@ -53,6 +46,19 @@ struct ethervlan_header {
 	uint16	ether_type;
 };
 
+struct dot3_mac_llc_snapvlan_header {
+	uint8	ether_dhost[ETHER_ADDR_LEN];	
+	uint8	ether_shost[ETHER_ADDR_LEN];	
+	uint16	length;				
+	uint8	dsap;				
+	uint8	ssap;				
+	uint8	ctl;				
+	uint8	oui[3];				
+	uint16	vlan_type;			
+	uint16	vlan_tag;			
+	uint16	ether_type;			
+};
+
 #define	ETHERVLAN_HDR_LEN	(ETHER_HDR_LEN + VLAN_TAG_LEN)
 
 
diff --git a/drivers/net/wireless/bcmdhd/include/proto/wpa.h b/drivers/net/wireless/bcmdhd/include/proto/wpa.h
old mode 100644
new mode 100755
index cc2ff5b..519df36
--- a/drivers/net/wireless/bcmdhd/include/proto/wpa.h
+++ b/drivers/net/wireless/bcmdhd/include/proto/wpa.h
@@ -1,27 +1,9 @@
 /*
  * Fundamental types and constants relating to WPA
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: wpa.h 261155 2011-05-23 23:51:32Z $
+ * $Id: wpa.h 384536 2013-02-12 04:13:09Z $
  */
 
 #ifndef _proto_wpa_h_
@@ -115,6 +97,15 @@ typedef BWL_PRE_PACKED_STRUCT struct
 #define WPA_CIPHER_WEP_104	5	
 #define WPA_CIPHER_BIP		6	
 #define WPA_CIPHER_TPK		7	
+#ifdef BCMCCX
+#define WPA_CIPHER_CKIP		8	
+#define WPA_CIPHER_CKIP_MMH	9	
+#define WPA_CIPHER_WEP_MMH	10	
+
+#define IS_CCX_CIPHER(cipher)	((cipher) == WPA_CIPHER_CKIP || \
+				 (cipher) == WPA_CIPHER_CKIP_MMH || \
+				 (cipher) == WPA_CIPHER_WEP_MMH)
+#endif
 
 #ifdef BCMWAPI_WAI
 #define WAPI_CIPHER_NONE	WPA_CIPHER_NONE
@@ -161,10 +152,10 @@ typedef BWL_PRE_PACKED_STRUCT struct
 #define RSN_CAP_2_REPLAY_CNTRS		1
 #define RSN_CAP_4_REPLAY_CNTRS		2
 #define RSN_CAP_16_REPLAY_CNTRS		3
-#ifdef MFP
 #define RSN_CAP_MFPR			0x0040
 #define RSN_CAP_MFPC			0x0080
-#endif
+#define RSN_CAP_SPPC			0x0400
+#define RSN_CAP_SPPR			0x0800
 
 
 #define WPA_CAP_4_REPLAY_CNTRS		RSN_CAP_4_REPLAY_CNTRS
diff --git a/drivers/net/wireless/bcmdhd/include/proto/wps.h b/drivers/net/wireless/bcmdhd/include/proto/wps.h
deleted file mode 100644
index cccbfff..0000000
--- a/drivers/net/wireless/bcmdhd/include/proto/wps.h
+++ /dev/null
@@ -1,379 +0,0 @@
-/*
- * WPS IE definitions
- *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
- *
- * $Id$
- */
-
-#ifndef _WPS_
-#define _WPS_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Data Element Definitions */
-#define WPS_ID_AP_CHANNEL         0x1001
-#define WPS_ID_ASSOC_STATE        0x1002
-#define WPS_ID_AUTH_TYPE          0x1003
-#define WPS_ID_AUTH_TYPE_FLAGS    0x1004
-#define WPS_ID_AUTHENTICATOR      0x1005
-#define WPS_ID_CONFIG_METHODS     0x1008
-#define WPS_ID_CONFIG_ERROR       0x1009
-#define WPS_ID_CONF_URL4          0x100A
-#define WPS_ID_CONF_URL6          0x100B
-#define WPS_ID_CONN_TYPE          0x100C
-#define WPS_ID_CONN_TYPE_FLAGS    0x100D
-#define WPS_ID_CREDENTIAL         0x100E
-#define WPS_ID_DEVICE_NAME        0x1011
-#define WPS_ID_DEVICE_PWD_ID      0x1012
-#define WPS_ID_E_HASH1            0x1014
-#define WPS_ID_E_HASH2            0x1015
-#define WPS_ID_E_SNONCE1          0x1016
-#define WPS_ID_E_SNONCE2          0x1017
-#define WPS_ID_ENCR_SETTINGS      0x1018
-#define WPS_ID_ENCR_TYPE          0x100F
-#define WPS_ID_ENCR_TYPE_FLAGS    0x1010
-#define WPS_ID_ENROLLEE_NONCE     0x101A
-#define WPS_ID_FEATURE_ID         0x101B
-#define WPS_ID_IDENTITY           0x101C
-#define WPS_ID_IDENTITY_PROOF     0x101D
-#define WPS_ID_KEY_WRAP_AUTH      0x101E
-#define WPS_ID_KEY_IDENTIFIER     0x101F
-#define WPS_ID_MAC_ADDR           0x1020
-#define WPS_ID_MANUFACTURER       0x1021
-#define WPS_ID_MSG_TYPE           0x1022
-#define WPS_ID_MODEL_NAME         0x1023
-#define WPS_ID_MODEL_NUMBER       0x1024
-#define WPS_ID_NW_INDEX           0x1026
-#define WPS_ID_NW_KEY             0x1027
-#define WPS_ID_NW_KEY_INDEX       0x1028
-#define WPS_ID_NEW_DEVICE_NAME    0x1029
-#define WPS_ID_NEW_PWD            0x102A
-#define WPS_ID_OOB_DEV_PWD        0x102C
-#define WPS_ID_OS_VERSION         0x102D
-#define WPS_ID_POWER_LEVEL        0x102F
-#define WPS_ID_PSK_CURRENT        0x1030
-#define WPS_ID_PSK_MAX            0x1031
-#define WPS_ID_PUBLIC_KEY         0x1032
-#define WPS_ID_RADIO_ENABLED      0x1033
-#define WPS_ID_REBOOT             0x1034
-#define WPS_ID_REGISTRAR_CURRENT  0x1035
-#define WPS_ID_REGISTRAR_ESTBLSHD 0x1036
-#define WPS_ID_REGISTRAR_LIST     0x1037
-#define WPS_ID_REGISTRAR_MAX      0x1038
-#define WPS_ID_REGISTRAR_NONCE    0x1039
-#define WPS_ID_REQ_TYPE           0x103A
-#define WPS_ID_RESP_TYPE          0x103B
-#define WPS_ID_RF_BAND            0x103C
-#define WPS_ID_R_HASH1            0x103D
-#define WPS_ID_R_HASH2            0x103E
-#define WPS_ID_R_SNONCE1          0x103F
-#define WPS_ID_R_SNONCE2          0x1040
-#define WPS_ID_SEL_REGISTRAR      0x1041
-#define WPS_ID_SERIAL_NUM         0x1042
-#define WPS_ID_SC_STATE           0x1044
-#define WPS_ID_SSID               0x1045
-#define WPS_ID_TOT_NETWORKS       0x1046
-#define WPS_ID_UUID_E             0x1047
-#define WPS_ID_UUID_R             0x1048
-#define WPS_ID_VENDOR_EXT         0x1049
-#define WPS_ID_VERSION            0x104A
-#define WPS_ID_X509_CERT_REQ      0x104B
-#define WPS_ID_X509_CERT          0x104C
-#define WPS_ID_EAP_IDENTITY       0x104D
-#define WPS_ID_MSG_COUNTER        0x104E
-#define WPS_ID_PUBKEY_HASH        0x104F
-#define WPS_ID_REKEY_KEY          0x1050
-#define WPS_ID_KEY_LIFETIME       0x1051
-#define WPS_ID_PERM_CFG_METHODS   0x1052
-#define WPS_ID_SEL_REG_CFG_METHODS 0x1053
-#define WPS_ID_PRIM_DEV_TYPE      0x1054
-#define WPS_ID_SEC_DEV_TYPE_LIST  0x1055
-#define WPS_ID_PORTABLE_DEVICE    0x1056
-#define WPS_ID_AP_SETUP_LOCKED    0x1057
-#define WPS_ID_APP_LIST           0x1058
-#define WPS_ID_EAP_TYPE           0x1059
-#define WPS_ID_INIT_VECTOR        0x1060
-#define WPS_ID_KEY_PROVIDED_AUTO  0x1061
-#define WPS_ID_8021X_ENABLED      0x1062
-#define WPS_ID_WEP_TRANSMIT_KEY   0x1064
-#define WPS_ID_REQ_DEV_TYPE       0x106A
-
-/* WSC 2.0, WFA Vendor Extension Subelements */
-#define WFA_VENDOR_EXT_ID                 "\x00\x37\x2A"
-#define WPS_WFA_SUBID_VERSION2            0x00
-#define WPS_WFA_SUBID_AUTHORIZED_MACS     0x01
-#define WPS_WFA_SUBID_NW_KEY_SHAREABLE    0x02
-#define WPS_WFA_SUBID_REQ_TO_ENROLL       0x03
-#define WPS_WFA_SUBID_SETTINGS_DELAY_TIME 0x04
-
-
-/* WCN-NET Windows Rally Vertical Pairing Vendor Extensions */
-#define MS_VENDOR_EXT_ID           "\x00\x01\x37"
-#define WPS_MS_ID_VPI               0x1001	/* Vertical Pairing Identifier TLV */
-#define WPS_MS_ID_TRANSPORT_UUID    0x1002      /* Transport UUID TLV */
-
-/* Vertical Pairing Identifier TLV Definitions */
-#define WPS_MS_VPI_TRANSPORT_NONE   0x00        /* None */
-#define WPS_MS_VPI_TRANSPORT_DPWS   0x01        /* Devices Profile for Web Services */
-#define WPS_MS_VPI_TRANSPORT_UPNP   0x02        /* uPnP */
-#define WPS_MS_VPI_TRANSPORT_SDNWS  0x03        /* Secure Devices Profile for Web Services */
-#define WPS_MS_VPI_NO_PROFILE_REQ   0x00        /* Wi-Fi profile not requested.
-						 * Not supported in Windows 7
-						 */
-#define WPS_MS_VPI_PROFILE_REQ      0x01        /* Wi-Fi profile requested.  */
-
-/* sizes of the fixed size elements */
-#define WPS_ID_AP_CHANNEL_S       2
-#define WPS_ID_ASSOC_STATE_S      2
-#define WPS_ID_AUTH_TYPE_S        2
-#define WPS_ID_AUTH_TYPE_FLAGS_S  2
-#define WPS_ID_AUTHENTICATOR_S    8
-#define WPS_ID_CONFIG_METHODS_S   2
-#define WPS_ID_CONFIG_ERROR_S     2
-#define WPS_ID_CONN_TYPE_S          1
-#define WPS_ID_CONN_TYPE_FLAGS_S    1
-#define WPS_ID_DEVICE_PWD_ID_S      2
-#define WPS_ID_ENCR_TYPE_S          2
-#define WPS_ID_ENCR_TYPE_FLAGS_S    2
-#define WPS_ID_FEATURE_ID_S         4
-#define WPS_ID_MAC_ADDR_S           6
-#define WPS_ID_MSG_TYPE_S           1
-#define WPS_ID_SC_STATE_S           1
-#define WPS_ID_RF_BAND_S            1
-#define WPS_ID_OS_VERSION_S         4
-#define WPS_ID_VERSION_S            1
-#define WPS_ID_SEL_REGISTRAR_S      1
-#define WPS_ID_SEL_REG_CFG_METHODS_S 2
-#define WPS_ID_REQ_TYPE_S           1
-#define WPS_ID_RESP_TYPE_S          1
-#define WPS_ID_AP_SETUP_LOCKED_S    1
-
-/* WSC 2.0, WFA Vendor Extension Subelements */
-#define WPS_WFA_SUBID_VERSION2_S            1
-#define WPS_WFA_SUBID_NW_KEY_SHAREABLE_S    1
-#define WPS_WFA_SUBID_REQ_TO_ENROLL_S       1
-#define WPS_WFA_SUBID_SETTINGS_DELAY_TIME_S 1
-
-/* Association states */
-#define WPS_ASSOC_NOT_ASSOCIATED  0
-#define WPS_ASSOC_CONN_SUCCESS    1
-#define WPS_ASSOC_CONFIG_FAIL     2
-#define WPS_ASSOC_ASSOC_FAIL      3
-#define WPS_ASSOC_IP_FAIL         4
-
-/* Authentication types */
-#define WPS_AUTHTYPE_OPEN        0x0001
-#define WPS_AUTHTYPE_WPAPSK      0x0002	/* Deprecated in WSC 2.0 */
-#define WPS_AUTHTYPE_SHARED      0x0004	/* Deprecated in WSC 2.0 */
-#define WPS_AUTHTYPE_WPA         0x0008	/* Deprecated in WSC 2.0 */
-#define WPS_AUTHTYPE_WPA2        0x0010
-#define WPS_AUTHTYPE_WPA2PSK     0x0020
-
-/* Config methods */
-#define WPS_CONFMET_USBA            0x0001	/* Deprecated in WSC 2.0 */
-#define WPS_CONFMET_ETHERNET        0x0002	/* Deprecated in WSC 2.0 */
-#define WPS_CONFMET_LABEL           0x0004
-#define WPS_CONFMET_DISPLAY         0x0008
-#define WPS_CONFMET_EXT_NFC_TOK     0x0010
-#define WPS_CONFMET_INT_NFC_TOK     0x0020
-#define WPS_CONFMET_NFC_INTF        0x0040
-#define WPS_CONFMET_PBC             0x0080
-#define WPS_CONFMET_KEYPAD          0x0100
-/* WSC 2.0 */
-#define WPS_CONFMET_VIRT_PBC        0x0280
-#define WPS_CONFMET_PHY_PBC         0x0480
-#define WPS_CONFMET_VIRT_DISPLAY    0x2008
-#define WPS_CONFMET_PHY_DISPLAY     0x4008
-
-/* WPS error messages */
-#define WPS_ERROR_NO_ERROR                0
-#define WPS_ERROR_OOB_INT_READ_ERR        1
-#define WPS_ERROR_DECRYPT_CRC_FAIL        2
-#define WPS_ERROR_CHAN24_NOT_SUPP         3
-#define WPS_ERROR_CHAN50_NOT_SUPP         4
-#define WPS_ERROR_SIGNAL_WEAK             5	/* Deprecated in WSC 2.0 */
-#define WPS_ERROR_NW_AUTH_FAIL            6	/* Deprecated in WSC 2.0 */
-#define WPS_ERROR_NW_ASSOC_FAIL           7	/* Deprecated in WSC 2.0 */
-#define WPS_ERROR_NO_DHCP_RESP            8	/* Deprecated in WSC 2.0 */
-#define WPS_ERROR_FAILED_DHCP_CONF        9	/* Deprecated in WSC 2.0 */
-#define WPS_ERROR_IP_ADDR_CONFLICT        10	/* Deprecated in WSC 2.0 */
-#define WPS_ERROR_FAIL_CONN_REGISTRAR     11
-#define WPS_ERROR_MULTI_PBC_DETECTED      12
-#define WPS_ERROR_ROGUE_SUSPECTED         13
-#define WPS_ERROR_DEVICE_BUSY             14
-#define WPS_ERROR_SETUP_LOCKED            15
-#define WPS_ERROR_MSG_TIMEOUT             16	/* Deprecated in WSC 2.0 */
-#define WPS_ERROR_REG_SESSION_TIMEOUT     17	/* Deprecated in WSC 2.0 */
-#define WPS_ERROR_DEV_PWD_AUTH_FAIL       18
-
-/* Connection types */
-#define WPS_CONNTYPE_ESS    0x01
-#define WPS_CONNTYPE_IBSS   0x02
-
-/* Device password ID */
-#define WPS_DEVICEPWDID_DEFAULT          0x0000
-#define WPS_DEVICEPWDID_USER_SPEC        0x0001
-#define WPS_DEVICEPWDID_MACHINE_SPEC     0x0002
-#define WPS_DEVICEPWDID_REKEY            0x0003
-#define WPS_DEVICEPWDID_PUSH_BTN         0x0004
-#define WPS_DEVICEPWDID_REG_SPEC         0x0005
-
-/* Encryption type */
-#define WPS_ENCRTYPE_NONE    0x0001
-#define WPS_ENCRTYPE_WEP     0x0002	/* Deprecated in WSC 2.0 */
-#define WPS_ENCRTYPE_TKIP    0x0004	/* Deprecated in version 2.0. TKIP can only
-					  * be advertised on the AP when Mixed Mode
-					  * is enabled (Encryption Type is 0x000c).
-					  */
-#define WPS_ENCRTYPE_AES     0x0008
-
-
-/* WPS Message Types */
-#define WPS_ID_BEACON            0x01
-#define WPS_ID_PROBE_REQ         0x02
-#define WPS_ID_PROBE_RESP        0x03
-#define WPS_ID_MESSAGE_M1        0x04
-#define WPS_ID_MESSAGE_M2        0x05
-#define WPS_ID_MESSAGE_M2D       0x06
-#define WPS_ID_MESSAGE_M3        0x07
-#define WPS_ID_MESSAGE_M4        0x08
-#define WPS_ID_MESSAGE_M5        0x09
-#define WPS_ID_MESSAGE_M6        0x0A
-#define WPS_ID_MESSAGE_M7        0x0B
-#define WPS_ID_MESSAGE_M8        0x0C
-#define WPS_ID_MESSAGE_ACK       0x0D
-#define WPS_ID_MESSAGE_NACK      0x0E
-#define WPS_ID_MESSAGE_DONE      0x0F
-
-/* WSP private ID for local use */
-#define WPS_PRIVATE_ID_IDENTITY		(WPS_ID_MESSAGE_DONE + 1)
-#define WPS_PRIVATE_ID_WPS_START	(WPS_ID_MESSAGE_DONE + 2)
-#define WPS_PRIVATE_ID_FAILURE		(WPS_ID_MESSAGE_DONE + 3)
-#define WPS_PRIVATE_ID_FRAG		(WPS_ID_MESSAGE_DONE + 4)
-#define WPS_PRIVATE_ID_FRAG_ACK		(WPS_ID_MESSAGE_DONE + 5)
-#define WPS_PRIVATE_ID_EAPOL_START	(WPS_ID_MESSAGE_DONE + 6)
-
-
-/* Device Type categories for primary and secondary device types */
-#define WPS_DEVICE_TYPE_CAT_COMPUTER        1
-#define WPS_DEVICE_TYPE_CAT_INPUT_DEVICE    2
-#define WPS_DEVICE_TYPE_CAT_PRINTER         3
-#define WPS_DEVICE_TYPE_CAT_CAMERA          4
-#define WPS_DEVICE_TYPE_CAT_STORAGE         5
-#define WPS_DEVICE_TYPE_CAT_NW_INFRA        6
-#define WPS_DEVICE_TYPE_CAT_DISPLAYS        7
-#define WPS_DEVICE_TYPE_CAT_MM_DEVICES      8
-#define WPS_DEVICE_TYPE_CAT_GAME_DEVICES    9
-#define WPS_DEVICE_TYPE_CAT_TELEPHONE       10
-#define WPS_DEVICE_TYPE_CAT_AUDIO_DEVICES   11	/* WSC 2.0 */
-
-/* Device Type sub categories for primary and secondary device types */
-#define WPS_DEVICE_TYPE_SUB_CAT_COMP_PC         1
-#define WPS_DEVICE_TYPE_SUB_CAT_COMP_SERVER     2
-#define WPS_DEVICE_TYPE_SUB_CAT_COMP_MEDIA_CTR  3
-#define WPS_DEVICE_TYPE_SUB_CAT_COMP_UM_PC      4	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_COMP_NOTEBOOK   5	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_COMP_DESKTOP    6	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_COMP_MID        7	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_COMP_NETBOOK    8	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_INP_Keyboard    1	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_INP_MOUSE       2	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_INP_JOYSTICK    3	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_INP_TRACKBALL   4	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_INP_GAM_CTRL    5	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_INP_REMOTE      6	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_INP_TOUCHSCREEN 7	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_INP_BIO_READER  8	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_INP_BAR_READER  9	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_PRTR_PRINTER    1
-#define WPS_DEVICE_TYPE_SUB_CAT_PRTR_SCANNER    2
-#define WPS_DEVICE_TYPE_SUB_CAT_PRTR_FAX        3	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_PRTR_COPIER     4	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_PRTR_ALLINONE   5	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_CAM_DGTL_STILL  1
-#define WPS_DEVICE_TYPE_SUB_CAT_CAM_VIDEO_CAM   2	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_CAM_WEB_CAM     3	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_CAM_SECU_CAM    4	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_STOR_NAS        1
-#define WPS_DEVICE_TYPE_SUB_CAT_NW_AP           1
-#define WPS_DEVICE_TYPE_SUB_CAT_NW_ROUTER       2
-#define WPS_DEVICE_TYPE_SUB_CAT_NW_SWITCH       3
-#define WPS_DEVICE_TYPE_SUB_CAT_NW_GATEWAY      4	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_NW_BRIDGE       5	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_DISP_TV         1
-#define WPS_DEVICE_TYPE_SUB_CAT_DISP_PIC_FRAME  2
-#define WPS_DEVICE_TYPE_SUB_CAT_DISP_PROJECTOR  3
-#define WPS_DEVICE_TYPE_SUB_CAT_DISP_MONITOR    4	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_MM_DAR          1
-#define WPS_DEVICE_TYPE_SUB_CAT_MM_PVR          2
-#define WPS_DEVICE_TYPE_SUB_CAT_MM_MCX          3
-#define WPS_DEVICE_TYPE_SUB_CAT_MM_STB          4	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_MM_MS_ME        5	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_MM_PVP          6	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_GAM_XBOX        1
-#define WPS_DEVICE_TYPE_SUB_CAT_GAM_XBOX_360    2
-#define WPS_DEVICE_TYPE_SUB_CAT_GAM_PS          3
-#define WPS_DEVICE_TYPE_SUB_CAT_GAM_GC          4	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_GAM_PGD         5	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_PHONE_WM        1
-#define WPS_DEVICE_TYPE_SUB_CAT_PHONE_PSM       2	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_PHONE_PDM       3	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_PHONE_SSM       4	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_PHONE_SDM       5	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_AUDIO_TUNER     1	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_AUDIO_SPEAKERS  2	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_AUDIO_PMP       3	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_AUDIO_HEADSET   4	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_AUDIO_HPHONE    5	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_AUDIO_MPHONE    6	/* WSC 2.0 */
-#define WPS_DEVICE_TYPE_SUB_CAT_AUDIO_HTS       7	/* WSC 2.0 */
-
-
-/* Device request/response type */
-#define WPS_MSGTYPE_ENROLLEE_INFO_ONLY    0x00
-#define WPS_MSGTYPE_ENROLLEE_OPEN_8021X   0x01
-#define WPS_MSGTYPE_REGISTRAR             0x02
-#define WPS_MSGTYPE_AP_WLAN_MGR           0x03
-
-/* RF Band */
-#define WPS_RFBAND_24GHZ    0x01
-#define WPS_RFBAND_50GHZ    0x02
-
-/* Simple Config state */
-#define WPS_SCSTATE_UNCONFIGURED    0x01
-#define WPS_SCSTATE_CONFIGURED      0x02
-#define WPS_SCSTATE_OFF 11
-
-/* WPS Vendor extension key */
-#define WPS_OUI_HEADER_LEN 2
-#define WPS_OUI_HEADER_SIZE 4
-#define WPS_OUI_FIXED_HEADER_OFF 16
-#define WPS_WFA_SUBID_V2_OFF 3
-#define WPS_WFA_V2_OFF 5
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _WPS_ */
diff --git a/drivers/net/wireless/bcmdhd/include/rwl_wifi.h b/drivers/net/wireless/bcmdhd/include/rwl_wifi.h
deleted file mode 100644
index 187c2bc..0000000
--- a/drivers/net/wireless/bcmdhd/include/rwl_wifi.h
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * RWL definitions  of
- * Broadcom 802.11bang Networking Device Driver
- *
- * Copyright (C) 2012, Broadcom Corporation
- * All Rights Reserved.
- * 
- * This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;
- * the contents of this file may not be disclosed to third parties, copied
- * or duplicated in any form, in whole or in part, without the prior
- * written permission of Broadcom Corporation.
- *
- * $Id: rwl_wifi.h 281527 2011-09-02 17:12:53Z $
- *
- */
-
-#ifndef _rwl_wifi_h_
-#define _rwl_wifi_h_
-
-#if defined(RWL_WIFI) || defined(WIFI_REFLECTOR) || defined(RFAWARE)
-
-#define RWL_ACTION_WIFI_CATEGORY	127  /* Vendor-specific category value for WiFi */
-#define RWL_WIFI_OUI_BYTE0		0x00 /* BRCM-specific public OUI */
-#define RWL_WIFI_OUI_BYTE1		0x90
-#define RWL_WIFI_OUI_BYTE2		0x4c
-#define RWL_WIFI_ACTION_FRAME_SIZE	sizeof(struct dot11_action_wifi_vendor_specific)
-#define RWL_WIFI_FIND_MY_PEER		0x09 /* Used while finding server */
-#define RWL_WIFI_FOUND_PEER		0x0A /* Server response to the client  */
-#define RWL_WIFI_DEFAULT		0x00
-#define RWL_ACTION_WIFI_FRAG_TYPE	0x55 /* Fragment indicator for receiver */
-
-/*
- * Information about the action frame data fields in the dot11_action_wifi_vendor_specific
- * cdc structure (1 to 16). This does not include the status flag. Since this
- * is not directly visible to the driver code, we can't use sizeof(struct cdc_ioctl).
- * Hence Ref MAC address offset starts from byte 17.
- * REF MAC ADDR (6 bytes (MAC Address len) from byte 17 to 22)
- * DUT MAC ADDR (6 bytes after the REF MAC Address byte 23 to 28)
- * unused (byte 29 to 49)
- * REF/Client Channel offset (50)
- * DUT/Server channel offset (51)
- * ---------------------------------------------------------------------------------------
- * cdc struct|REF MAC ADDR|DUT_MAC_ADDR|un used|REF Channel|DUT channel|Action frame Data|
- * 1---------17-----------23-------------------50----------51----------52----------------1040
- * REF MAC addr after CDC struct without status flag (status flag not used by wifi)
- */
-
-#define RWL_REF_MAC_ADDRESS_OFFSET	17
-#define RWL_DUT_MAC_ADDRESS_OFFSET	23
-#define RWL_WIFI_CLIENT_CHANNEL_OFFSET	50
-#define RWL_WIFI_SERVER_CHANNEL_OFFSET	51
-
-#ifdef WIFI_REFLECTOR
-#include <bcmcdc.h>
-#define REMOTE_FINDSERVER_CMD 	16
-#define RWL_WIFI_ACTION_CMD		"wifiaction"
-#define RWL_WIFI_ACTION_CMD_LEN		11	/* With the NULL terminator */
-#define REMOTE_SET_CMD 		1
-#define REMOTE_GET_CMD 		2
-#define REMOTE_REPLY 			4
-#define RWL_WIFI_DEFAULT_TYPE           0x00
-#define RWL_WIFI_DEFAULT_SUBTYPE        0x00
-#define RWL_ACTION_FRAME_DATA_SIZE      1024	/* fixed size for the wifi frame data */
-#define RWL_WIFI_CDC_HEADER_OFFSET      0
-#define RWL_WIFI_FRAG_DATA_SIZE         960	/* max size of the frag data */
-#define RWL_DEFAULT_WIFI_FRAG_COUNT 	127 	/* maximum fragment count */
-#define RWL_WIFI_RETRY			5       /* CMD retry count for wifi */
-#define RWL_WIFI_SEND			5	/* WIFI frame sent count */
-#define RWL_WIFI_SEND_DELAY		100	/* delay between two frames */
-#define MICROSEC_CONVERTOR_VAL		1000
-#ifndef IFNAMSIZ
-#define IFNAMSIZ			16
-#endif
-
-typedef struct rem_packet {
-	rem_ioctl_t rem_cdc;
-	uchar message [RWL_ACTION_FRAME_DATA_SIZE];
-} rem_packet_t;
-
-struct send_packet {
-	char command [RWL_WIFI_ACTION_CMD_LEN];
-	dot11_action_wifi_vendor_specific_t response;
-} PACKED;
-typedef struct send_packet send_packet_t;
-
-#define REMOTE_SIZE     sizeof(rem_ioctl_t)
-#endif /* WIFI_REFLECTOR */
-
-typedef struct rwl_request {
-	struct rwl_request* next_request;
-	struct dot11_action_wifi_vendor_specific action_frame;
-} rwl_request_t;
-
-
-#endif /* defined(RWL_WIFI) || defined(WIFI_REFLECTOR) */
-#endif	/* _rwl_wifi_h_ */
diff --git a/drivers/net/wireless/bcmdhd/include/sbchipc.h b/drivers/net/wireless/bcmdhd/include/sbchipc.h
old mode 100644
new mode 100755
index 761bc88..132d28b
--- a/drivers/net/wireless/bcmdhd/include/sbchipc.h
+++ b/drivers/net/wireless/bcmdhd/include/sbchipc.h
@@ -5,27 +5,9 @@
  * JTAG, 0/1/2 UARTs, clock frequency control, a watchdog interrupt timer,
  * GPIO interface, extbus, and support for serial and parallel flashes.
  *
- * $Id: sbchipc.h 328358 2012-04-18 23:14:31Z $
+ * $Id: sbchipc.h 385540 2013-02-15 23:14:50Z $
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  */
 
 #ifndef	_SBCHIPC_H
@@ -289,8 +271,13 @@ typedef volatile struct {
 	uint32	pllcontrol_data;
 	uint32	pmustrapopt;		
 	uint32	pmu_xtalfreq;		
-	uint32	PAD[100];
+	uint32  retention_ctl;		
+	uint32  PAD[3];
+	uint32  retention_grpidx;	
+	uint32  retention_grpctl;	
+	uint32  PAD[94];
 	uint16	sromotp[512];		
+#ifdef NFLASH_SUPPORT
 	
 	uint32	nand_revision;		
 	uint32	nand_cmd_start;
@@ -353,6 +340,58 @@ typedef volatile struct {
 	uint32	nand_cache_data;
 	uint32	nand_ctrl_config;
 	uint32	nand_ctrl_status;
+#endif 
+	uint32  gci_corecaps0; 
+	uint32  gci_corecaps1;
+	uint32  gci_corecaps2;
+	uint32  gci_corectrl;
+	uint32  gci_corestat; 
+	uint32  gci_intstat; 
+	uint32  gci_intmask; 
+	uint32  gci_wakemask; 
+	uint32  gci_levelintstat; 
+	uint32  gci_eventintstat; 
+	uint32  PAD[6];
+	uint32  gci_indirect_addr; 
+	uint32  gci_gpioctl; 
+	uint32  PAD;
+	uint32  gci_gpiomask; 
+	uint32  PAD;
+	uint32  gci_miscctl; 
+	uint32  PAD[2];
+	uint32  gci_input[32]; 
+	uint32  gci_event[32]; 
+	uint32  gci_output[4]; 
+	uint32  gci_control_0; 
+	uint32  gci_control_1; 
+	uint32  gci_level_polreg; 
+	uint32  gci_levelintmask; 
+	uint32  gci_eventintmask; 
+	uint32  PAD[3];
+	uint32  gci_inbandlevelintmask; 
+	uint32  gci_inbandeventintmask; 
+	uint32  PAD[2];
+	uint32  gci_seciauxtx; 
+	uint32  gci_seciauxrx; 
+	uint32  gci_secitx_datatag; 
+	uint32  gci_secirx_datatag; 
+	uint32  gci_secitx_datamask; 
+	uint32  gci_seciusef0tx_reg; 
+	uint32  gci_secif0tx_offset; 
+	uint32  gci_secif0rx_offset; 
+	uint32  gci_secif1tx_offset; 
+	uint32  PAD[3];
+	uint32  gci_uartescval; 
+	uint32  PAD[3];
+	uint32  gci_secibauddiv; 
+	uint32  gci_secifcr; 
+	uint32  gci_secilcr; 
+	uint32  gci_secimcr; 
+	uint32  PAD[2];
+	uint32  gci_baudadj; 
+	uint32  PAD;
+	uint32  gci_chipctrl; 
+	uint32  gci_chipsts; 
 } chipcregs_t;
 
 #endif 
@@ -399,6 +438,10 @@ typedef volatile struct {
 #define PMU_PLL_CONTROL_ADDR 	0x660
 #define PMU_PLL_CONTROL_DATA 	0x664
 #define	CC_SROM_OTP		0x800		
+#define CC_GCI_INDIRECT_ADDR_REG	0xC40
+#define CC_GCI_CHIP_CTRL_REG	0xE00
+#define CC_GCI_CC_OFFSET_2	2
+#define CC_GCI_CC_OFFSET_5	5
 
 #ifdef NFLASH_SUPPORT
 
@@ -454,9 +497,12 @@ typedef volatile struct {
 #define	CC_CAP2_GSIO		0x00000002	
 
 
-#define CC_CAP_EXT_SECI_PRESENT   0x00000001    
+#define CC_CAP_EXT_SECI_PRESENT	0x00000001    
+#define CC_CAP_EXT_GCI_PRESENT  0x00000004    
 
 
+#define GCI_WL_CHN_INFO_MASK 	(0xFF00)
+
 #define PLL_NONE		0x00000000
 #define PLL_TYPE1		0x00010000	
 #define PLL_TYPE2		0x00020000	
@@ -472,6 +518,28 @@ typedef volatile struct {
 
 #define	ALP_CLOCK		20000000
 
+#ifdef CFG_SIM
+#define NS_ALP_CLOCK		84922
+#define NS_SLOW_ALP_CLOCK	84922
+#define NS_CPU_CLOCK		534500
+#define NS_SLOW_CPU_CLOCK	534500
+#define NS_SI_CLOCK		271750
+#define NS_SLOW_SI_CLOCK	271750
+#define NS_FAST_MEM_CLOCK	271750
+#define NS_MEM_CLOCK		271750
+#define NS_SLOW_MEM_CLOCK	271750
+#else
+#define NS_ALP_CLOCK		125000000
+#define NS_SLOW_ALP_CLOCK	100000000
+#define NS_CPU_CLOCK		1000000000
+#define NS_SLOW_CPU_CLOCK	800000000
+#define NS_SI_CLOCK		250000000
+#define NS_SLOW_SI_CLOCK	200000000
+#define NS_FAST_MEM_CLOCK	800000000
+#define NS_MEM_CLOCK		533000000
+#define NS_SLOW_MEM_CLOCK	400000000
+#endif 
+
 
 #define	HT_CLOCK		80000000
 
@@ -789,6 +857,33 @@ typedef volatile struct {
 #define	PCTL_LPO_SEL		0x00000001
 
 
+#define PMU_RCTL_CLK_DIV_SHIFT		0
+#define PMU_RCTL_CHAIN_LEN_SHIFT	12
+#define PMU_RCTL_MACPHY_DISABLE_SHIFT	26
+#define PMU_RCTL_MACPHY_DISABLE_MASK	(1 << 26)
+#define PMU_RCTL_LOGIC_DISABLE_SHIFT	27
+#define PMU_RCTL_LOGIC_DISABLE_MASK	(1 << 27)
+#define PMU_RCTL_MEMSLP_LOG_SHIFT	28
+#define PMU_RCTL_MEMSLP_LOG_MASK	(1 << 28)
+#define PMU_RCTL_MEMRETSLP_LOG_SHIFT	29
+#define PMU_RCTL_MEMRETSLP_LOG_MASK	(1 << 29)
+
+
+#define PMU_RCTLGRP_CHAIN_LEN_SHIFT	0
+#define PMU_RCTLGRP_RMODE_ENABLE_SHIFT	14
+#define PMU_RCTLGRP_RMODE_ENABLE_MASK	(1 << 14)
+#define PMU_RCTLGRP_DFT_ENABLE_SHIFT	15
+#define PMU_RCTLGRP_DFT_ENABLE_MASK	(1 << 15)
+#define PMU_RCTLGRP_NSRST_DISABLE_SHIFT	16
+#define PMU_RCTLGRP_NSRST_DISABLE_MASK	(1 << 16)
+
+#define PMU4334_RCTLGRP_CHAIN_LEN_GRP0	338
+#define PMU4334_RCTLGRP_CHAIN_LEN_GRP1	315
+
+#define PMU43341_RCTLGRP_CHAIN_LEN_GRP0	366
+#define PMU43341_RCTLGRP_CHAIN_LEN_GRP1	330
+
+
 #define CSTRETCH_HT		0xffff0000
 #define CSTRETCH_ALP		0x0000ffff
 
@@ -855,6 +950,8 @@ typedef volatile struct {
 #define SFLASH_AT		0x200		
 #define NFLASH			0x300
 #define	PFLASH			0x700		
+#define QSPIFLASH_ST		0x800
+#define QSPIFLASH_AT		0x900
 
 
 #define	CC_CFG_EN		0x0001		
@@ -1046,6 +1143,7 @@ typedef volatile struct {
 
 
 #define	PMU_CHIPCTL0		0
+#define PMU43143_CC0_SDIO_DRSTR_OVR	(1 << 31) 
 
 
 #define PMU_CC1_CLKREQ_TYPE_SHIFT	19
@@ -1080,6 +1178,9 @@ typedef volatile struct {
 #define PMU_CC3_RF_DISABLE_IVALUE_SHIFT   23
 
 
+#define PMU_CHIPCTL5                    5
+
+
 
 
 
@@ -1465,6 +1566,10 @@ typedef volatile struct {
 #define CCTRL43217_EXTPA_C1             (1<<8)  
 
 
+#define CCTRL43228_EXTPA_C0             (1<<14) 
+#define CCTRL43228_EXTPA_C1             (1<<9)  
+
+
 #define RES4328_EXT_SWITCHER_PWM	0	
 #define RES4328_BB_SWITCHER_PWM		1	
 #define RES4328_BB_SWITCHER_BURST	2	
@@ -1707,9 +1812,36 @@ typedef volatile struct {
 #define CST43239_CHIPMODE_GSPI(cs)	(((cs) & (1 << 0)) == (1 << 0))	
 
 
-#define RES4324_OTP_PU				10
+
+#define RES4324_LPLDO_PU			0
+#define RES4324_RESET_PULLDN_DIS		1
+#define RES4324_PMU_BG_PU			2
+#define RES4324_HSIC_LDO_PU			3
+#define RES4324_CBUCK_LPOM_PU			4
+#define RES4324_CBUCK_PFM_PU			5
+#define RES4324_CLDO_PU				6
+#define RES4324_LPLDO2_LVM			7
+#define RES4324_LNLDO1_PU			8
+#define RES4324_LNLDO2_PU			9
+#define RES4324_LDO3P3_PU			10
+#define RES4324_OTP_PU				11
+#define RES4324_XTAL_PU				12
+#define RES4324_BBPLL_PU			13
+#define RES4324_LQ_AVAIL			14
+#define RES4324_WL_CORE_READY			17
+#define RES4324_ILP_REQ				18
+#define RES4324_ALP_AVAIL			19
+#define RES4324_PALDO_PU			20
+#define RES4324_RADIO_PU			21
+#define RES4324_SR_CLK_STABLE			22
+#define RES4324_SR_SAVE_RESTORE			23
+#define RES4324_SR_PHY_PWRSW			24
+#define RES4324_SR_PHY_PIC			25
+#define RES4324_SR_SUBCORE_PWRSW		26
+#define RES4324_SR_SUBCORE_PIC			27
+#define RES4324_SR_MEM_PM0			28
 #define RES4324_HT_AVAIL			29
-#define RES4324_MACPHY_CLKAVAIL		30
+#define RES4324_MACPHY_CLKAVAIL			30
 
 
 #define CST4324_SPROM_MASK			0x00000080
@@ -1721,6 +1853,9 @@ typedef volatile struct {
 #define CST4324_CHIPMODE_USB20D(cs)	(((cs) & CST4324_CHIPMODE_MASK) == 0x6)	
 
 
+#define CST43242_SFLASH_MASK                    0x00000008
+
+
 #define RES4331_REGULATOR		0
 #define RES4331_ILP_REQUEST		1
 #define RES4331_XTAL_PU			2
@@ -1955,6 +2090,42 @@ typedef volatile struct {
 #define PMU_VREG0_DISABLE_PULLD_BT_SHIFT	2
 #define PMU_VREG0_DISABLE_PULLD_WL_SHIFT	3
 
+#define PMU_VREG4_ADDR			4
+
+#define PMU_VREG4_CLDO_PWM_SHIFT	4
+#define PMU_VREG4_CLDO_PWM_MASK		0x7
+
+#define PMU_VREG4_LPLDO1_SHIFT		15
+#define PMU_VREG4_LPLDO1_MASK		0x7
+#define PMU_VREG4_LPLDO1_1p20V		0
+#define PMU_VREG4_LPLDO1_1p15V		1
+#define PMU_VREG4_LPLDO1_1p10V		2
+#define PMU_VREG4_LPLDO1_1p25V		3
+#define PMU_VREG4_LPLDO1_1p05V		4
+#define PMU_VREG4_LPLDO1_1p00V		5
+#define PMU_VREG4_LPLDO1_0p95V		6
+#define PMU_VREG4_LPLDO1_0p90V		7
+
+#define PMU_VREG4_LPLDO2_LVM_SHIFT	18
+#define PMU_VREG4_LPLDO2_LVM_MASK	0x7
+#define PMU_VREG4_LPLDO2_HVM_SHIFT	21
+#define PMU_VREG4_LPLDO2_HVM_MASK	0x7
+#define PMU_VREG4_LPLDO2_LVM_HVM_MASK	0x3f
+#define PMU_VREG4_LPLDO2_1p00V		0
+#define PMU_VREG4_LPLDO2_1p15V		1
+#define PMU_VREG4_LPLDO2_1p20V		2
+#define PMU_VREG4_LPLDO2_1p10V		3
+#define PMU_VREG4_LPLDO2_0p90V		4	
+
+#define PMU_VREG4_HSICLDO_BYPASS_SHIFT	27
+#define PMU_VREG4_HSICLDO_BYPASS_MASK	0x1
+
+#define PMU_VREG5_ADDR			5
+#define PMU_VREG5_HSICAVDD_PD_SHIFT	6
+#define PMU_VREG5_HSICAVDD_PD_MASK	0x1
+#define PMU_VREG5_HSICDVDD_PD_SHIFT	11
+#define PMU_VREG5_HSICDVDD_PD_MASK	0x1
+
 
 #define RES4334_LPLDO_PU		0
 #define RES4334_RESET_PULLDN_DIS	1
@@ -2010,14 +2181,80 @@ typedef volatile struct {
 #define PCTL_4334_GPIO3_ENAB    (1  << 3)
 
 
+#define CCTRL4334_PMU_WAKEUP_GPIO1	(1  << 0)
+#define CCTRL4334_PMU_WAKEUP_HSIC	(1  << 1)
+#define CCTRL4334_PMU_WAKEUP_AOS	(1  << 2)
+#define CCTRL4334_HSIC_WAKE_MODE	(1  << 3)
+#define CCTRL4334_HSIC_INBAND_GPIO1	(1  << 4)
 #define CCTRL4334_HSIC_LDO_PU		(1  << 23)
 
 
+#define CCTRL4334_BLOCK_EXTRNL_WAKE		(1  << 4)
+#define CCTRL4334_SAVERESTORE_FIX		(1  << 5)
+
+
+#define CCTRL43341_BLOCK_EXTRNL_WAKE		(1  << 13)
+#define CCTRL43341_SAVERESTORE_FIX		(1  << 14)
+#define CCTRL43341_BT_ISO_SEL			(1  << 16)
+
+
+#define CCTRL1_4334_GPIO_SEL		(1 << 0)    
+#define CCTRL1_4334_ERCX_SEL		(1 << 1)    
+#define CCTRL1_4334_SDIO_HOST_WAKE (1 << 2)  
+#define CCTRL1_4334_JTAG_DISABLE	(1 << 3)    
+#define CCTRL1_4334_UART_ON_4_5	(1 << 28)  	
+
+
 #define CCTRL1_4324_GPIO_SEL            (1 << 0)    
 #define CCTRL1_4324_SDIO_HOST_WAKE (1 << 2)  
 
 
 
+#define CST43143_REMAP_TO_ROM	 (3 << 0)    
+#define CST43143_SDIO_EN	 (1 << 2)    
+#define CST43143_SDIO_ISO	 (1 << 3)    
+#define CST43143_USB_CPU_LESS	 (1 << 4)   
+#define CST43143_CBUCK_MODE	 (3 << 6)   
+#define CST43143_POK_CBUCK	 (1 << 8)   
+#define CST43143_PMU_OVRSPIKE	 (1 << 9)
+#define CST43143_PMU_OVRTEMP	 (0xF << 10)
+#define CST43143_SR_FLL_CAL_DONE (1 << 14)
+#define CST43143_USB_PLL_LOCKDET (1 << 15)
+#define CST43143_PMU_PLL_LOCKDET (1 << 16)
+#define CST43143_CHIPMODE_SDIOD(cs)	(((cs) & CST43143_SDIO_EN) != 0) 
+
+
+
+#define CCTRL_43143_SECI		(1<<0)
+#define CCTRL_43143_BT_LEGACY		(1<<1)
+#define CCTRL_43143_I2S_MODE		(1<<2)	
+#define CCTRL_43143_I2S_MASTER		(1<<3)	
+#define CCTRL_43143_I2S_FULL		(1<<4)	
+#define CCTRL_43143_GSIO		(1<<5)	
+#define CCTRL_43143_RF_SWCTRL_MASK	(7<<6)	
+#define CCTRL_43143_RF_SWCTRL_0		(1<<6)
+#define CCTRL_43143_RF_SWCTRL_1		(2<<6)
+#define CCTRL_43143_RF_SWCTRL_2		(4<<6)
+#define CCTRL_43143_RF_XSWCTRL		(1<<9)	
+#define CCTRL_43143_HOST_WAKE0		(1<<11)	
+#define CCTRL_43143_HOST_WAKE1		(1<<12)	
+
+
+#define RES43143_EXT_SWITCHER_PWM	0	
+#define RES43143_XTAL_PU		1	
+#define RES43143_ILP_REQUEST		2	
+#define RES43143_ALP_AVAIL		3	
+#define RES43143_WL_CORE_READY		4	
+#define RES43143_BBPLL_PWRSW_PU		5	
+#define RES43143_HT_AVAIL		6	
+#define RES43143_RADIO_PU		7	
+#define RES43143_MACPHY_CLK_AVAIL	8	
+#define RES43143_OTP_PU			9	
+#define RES43143_LQ_AVAIL		10	
+
+#define PMU43143_XTAL_CORE_SIZE_MASK	0x3F
+
+
 #define	RES4313_BB_PU_RSRC		0
 #define	RES4313_ILP_REQ_RSRC		1
 #define	RES4313_XTAL_PU_RSRC		2
@@ -2118,11 +2355,19 @@ typedef volatile struct {
 #define FLSTRCF4706_1ST_MADDR_SEG_256MB		0x00000070	
 
 
+#define CCTRL4360_I2C_MODE			(1 << 0)
+#define CCTRL4360_UART_MODE			(1 << 1)
 #define CCTRL4360_SECI_MODE			(1 << 2)
 #define CCTRL4360_BTSWCTRL_MODE			(1 << 3)
+#define CCTRL4360_DISCRETE_FEMCTRL_MODE		(1 << 4)
+#define CCTRL4360_DIGITAL_PACTRL_MODE		(1 << 5)
+#define CCTRL4360_BTSWCTRL_AND_DIGPA_PRESENT	(1 << 6)
+#define CCTRL4360_EXTRA_GPIO_MODE		(1 << 7)
 #define CCTRL4360_EXTRA_FEMCTRL_MODE		(1 << 8)
 #define CCTRL4360_BT_LGCY_MODE			(1 << 9)
 #define CCTRL4360_CORE2FEMCTRL4_ON		(1 << 21)
+#define CCTRL4360_SECI_ON_GPIO01		(1 << 24)
+
 
 
 #define RES4360_REGULATOR          0
@@ -2154,6 +2399,365 @@ typedef volatile struct {
 #define CCTRL_4360_UART_SEL	0x2
 
 
+#define CHIP_HOSTIF_PCIEMODE	0x1
+#define CHIP_HOSTIF_USBMODE	0x2
+#define CHIP_HOSTIF_SDIOMODE	0x4
+#define CHIP_HOSTIF_PCIE(sih)	(si_chip_hostif(sih) == CHIP_HOSTIF_PCIEMODE)
+#define CHIP_HOSTIF_SDIO(sih)	(si_chip_hostif(sih) == CHIP_HOSTIF_SDIOMODE)
+
+
+#define RES4335_LPLDO_PO           0
+#define RES4335_PMU_BG_PU          1
+#define RES4335_PMU_SLEEP          2
+#define RES4335_RSVD_3             3
+#define RES4335_CBUCK_LPOM_PU		4
+#define RES4335_CBUCK_PFM_PU		5
+#define RES4335_RSVD_6             6
+#define RES4335_RSVD_7             7
+#define RES4335_LNLDO_PU           8
+#define RES4335_XTALLDO_PU         9
+#define RES4335_LDO3P3_PU			10
+#define RES4335_OTP_PU				11
+#define RES4335_XTAL_PU				12
+#define RES4335_SR_CLK_START       13
+#define RES4335_LQ_AVAIL			14
+#define RES4335_LQ_START           15
+#define RES4335_RSVD_16            16
+#define RES4335_WL_CORE_RDY        17
+#define RES4335_ILP_REQ				18
+#define RES4335_ALP_AVAIL			19
+#define RES4335_MINI_PMU           20
+#define RES4335_RADIO_PU			21
+#define RES4335_SR_CLK_STABLE		22
+#define RES4335_SR_SAVE_RESTORE		23
+#define RES4335_SR_PHY_PWRSW		24
+#define RES4335_SR_VDDM_PWRSW      25
+#define RES4335_SR_SUBCORE_PWRSW	26
+#define RES4335_SR_SLEEP           27
+#define RES4335_HT_START           28
+#define RES4335_HT_AVAIL			29
+#define RES4335_MACPHY_CLKAVAIL		30
+
+
+#define CST4335_SPROM_MASK			0x00000020
+#define CST4335_SFLASH_MASK			0x00000040
+#define	CST4335_RES_INIT_MODE_SHIFT	7
+#define	CST4335_RES_INIT_MODE_MASK	0x00000180
+#define CST4335_CHIPMODE_MASK		0xF
+#define CST4335_CHIPMODE_SDIOD(cs)	(((cs) & (1 << 0)) != 0)	
+#define CST4335_CHIPMODE_GSPI(cs)	(((cs) & (1 << 1)) != 0)	
+#define CST4335_CHIPMODE_USB20D(cs)	(((cs) & (1 << 2)) != 0)	
+#define CST4335_CHIPMODE_PCIE(cs)	(((cs) & (1 << 3)) != 0)	
+
+
+#define CCTRL1_4335_GPIO_SEL		(1 << 0)    
+#define CCTRL1_4335_SDIO_HOST_WAKE (1 << 2)  
+
+#define CR4_4335_RAM_BASE                    (0x180000)
+#define PATCHTBL_SIZE			(0x800)
+#define CR4_4350_RAM_BASE                    (0x180000)
+#define CR4_4360_RAM_BASE                    (0x0)
+
+
+
+#define SPROM4335_OTP_SELECT	0x00000010
+#define SPROM4335_OTP_PRESENT	0x00000020
+
+
+#define CC4335_GCI_STRAP_OVERRIDE_SFLASH_PRESENT	(1 << 24)
+#define CC4335_GCI_STRAP_OVERRIDE_SFLASH_TYPE	25
+#define CC4335_GCI_FUNC_SEL_PAD_SDIO	0x00707770
+
+
+#define CC4335_SFLASH_CLKDIV_MASK	0x1F000000
+#define CC4335_SFLASH_CLKDIV_SHIFT	25
+
+
+#define CC4335_SROM_OTP_SFLASH	40
+#define CC4335_SROM_OTP_SFLASH_PRESENT	0x1
+#define CC4335_SROM_OTP_SFLASH_TYPE	0x2
+#define CC4335_SROM_OTP_SFLASH_CLKDIV_MASK	0x003C
+#define CC4335_SROM_OTP_SFLASH_CLKDIV_SHIFT	2
+
+
+
+
+
+#define CST4350_SDIO_MODE		0x00000001
+#define CST4350_HSIC20D_MODE		0x00000002
+#define CST4350_BP_ON_HSIC_CLK		0x00000004
+#define CST4350_PCIE_MODE		0x00000008
+#define CST4350_USB20D_MODE		0x00000010
+#define CST4350_USB30D_MODE		0x00000020
+#define CST4350_SPROM_PRESENT		0x00000040
+#define CST4350_RSRC_INIT_MODE_0	0x00000080
+#define CST4350_RSRC_INIT_MODE_1	0x00000100
+#define CST4350_SEL0_SDIO		0x00000200
+#define CST4350_SEL1_SDIO		0x00000400
+#define CST4350_SDIO_PAD_MODE		0x00000800
+#define CST4350_BBPLL_LOCKED		0x00001000
+#define CST4350_USBPLL_LOCKED		0x00002000
+#define CST4350_LINE_STATE		0x0000C000
+#define CST4350_SERDES_PIPE_PLLLOCK	0x00010000
+#define CST4350_BT_READY		0x00020000
+#define CST4350_SFLASH_PRESENT		0x00040000
+#define CST4350_CPULESS_ENABLE		0x00080000
+#define CST4350_STRAP_HOST_IFC_1	0x00100000
+#define CST4350_STRAP_HOST_IFC_2	0x00200000
+#define CST4350_STRAP_HOST_IFC_3	0x00400000
+#define CST4350_RAW_SPROM_PRESENT	0x00800000
+#define CST4350_APP_CLK_SWITCH_SEL_RDBACK	0x01000000
+#define CST4350_RAW_RSRC_INIT_MODE_0	0x02000000
+#define CST4350_SDIO_PAD_VDDIO		0x04000000
+#define CST4350_GSPI_MODE		0x08000000
+#define CST4350_PACKAGE_OPTION		0xF0000000
+
+
+#define CST4350_HOST_IFC_MASK		0x00700000
+#define CST4350_HOST_IFC_SHIFT		20
+
+
+#define CST4350_IFC_MODE_SDIOD			0x0
+#define CST4350_IFC_MODE_HSIC20D		0x1
+#define CST4350_IFC_MODE_HSIC30D		0x2
+#define CST4350_IFC_MODE_PCIE			0x3
+#define CST4350_IFC_MODE_USB20D			0x4
+#define CST4350_IFC_MODE_USB30D			0x5
+#define CST4350_IFC_MODE_USB30D_WL		0x6
+#define CST4350_IFC_MODE_USB30D_BT		0x7
+
+#define CST4350_IFC_MODE(cs)	((cs & CST4350_HOST_IFC_MASK) >> CST4350_HOST_IFC_SHIFT)
+
+#define CST4350_CHIPMODE_SDIOD(cs)	(CST4350_IFC_MODE(cs) == (CST4350_IFC_MODE_SDIOD))
+#define CST4350_CHIPMODE_USB20D(cs)	((CST4350_IFC_MODE(cs)) == (CST4350_IFC_MODE_USB20D))
+#define CST4350_CHIPMODE_HSIC20D(cs)	(CST4350_IFC_MODE(cs) == (CST4350_IFC_MODE_HSIC20D))
+#define CST4350_CHIPMODE_HSIC30D(cs)	(CST4350_IFC_MODE(cs) == (CST4350_IFC_MODE_HSIC30D))
+#define CST4350_CHIPMODE_USB30D(cs)	(CST4350_IFC_MODE(cs) == (CST4350_IFC_MODE_USB30D))
+#define CST4350_CHIPMODE_USB30D_WL(cs)	(CST4350_IFC_MODE(cs) == (CST4350_IFC_MODE_USB30D_WL))
+#define CST4350_CHIPMODE_PCIE(cs)	(CST4350_IFC_MODE(cs) == (CST4350_IFC_MODE_PCIE))
+
+
+#define RES4350_LPLDO_PU	0
+#define RES4350_PMU_BG_PU	1
+#define RES4350_PMU_SLEEP	2
+#define RES4350_RSVD_3		3
+#define RES4350_CBUCK_LPOM_PU	4
+#define RES4350_CBUCK_PFM_PU	5
+#define RES4350_COLD_START_WAIT	6
+#define RES4350_RSVD_7		7
+#define RES4350_LNLDO_PU	8
+#define RES4350_XTALLDO_PU	9
+#define RES4350_LDO3P3_PU	10
+#define RES4350_OTP_PU		11
+#define RES4350_XTAL_PU		12
+#define RES4350_SR_CLK_START	13
+#define RES4350_LQ_AVAIL	14
+#define RES4350_LQ_START	15
+#define RES4350_RSVD_16		16
+#define RES4350_WL_CORE_RDY	17
+#define RES4350_ILP_REQ		18
+#define RES4350_ALP_AVAIL	19
+#define RES4350_MINI_PMU	20
+#define RES4350_RADIO_PU	21
+#define RES4350_SR_CLK_STABLE	22
+#define RES4350_SR_SAVE_RESTORE	23
+#define RES4350_SR_PHY_PWRSW	24
+#define RES4350_SR_VDDM_PWRSW	25
+#define RES4350_SR_SUBCORE_PWRSW	26
+#define RES4350_SR_SLEEP	27
+#define RES4350_HT_START	28
+#define RES4350_HT_AVAIL	29
+#define RES4350_MACPHY_CLKAVAIL	30
+
+#define MUXENAB4350_UART_MASK		(0x0000000f)
+
+
+#define CC4350_FNSEL_HWDEF		(0)
+#define CC4350_FNSEL_SAMEASPIN		(1)
+#define CC4350_FNSEL_UART		(2)
+#define CC4350_FNSEL_SFLASH		(3)
+#define CC4350_FNSEL_SPROM		(4)
+#define CC4350_FNSEL_I2C		(5)
+#define CC4350_FNSEL_MISC0		(6)
+#define CC4350_FNSEL_GCI		(7)
+#define CC4350_FNSEL_MISC1		(8)
+#define CC4350_FNSEL_MISC2		(9)
+#define CC4350_FNSEL_PWDOG 		(10)
+#define CC4350_FNSEL_IND		(12)
+#define CC4350_FNSEL_PDN		(13)
+#define CC4350_FNSEL_PUP		(14)
+#define CC4350_FNSEL_TRISTATE		(15)
+
+
+#define CC4350_PIN_GPIO_00		(0)
+#define CC4350_PIN_GPIO_01		(1)
+#define CC4350_PIN_GPIO_02		(2)
+#define CC4350_PIN_GPIO_03		(3)
+#define CC4350_PIN_GPIO_04		(4)
+#define CC4350_PIN_GPIO_05		(5)
+#define CC4350_PIN_GPIO_06		(6)
+#define CC4350_PIN_GPIO_07		(7)
+#define CC4350_PIN_GPIO_08		(8)
+#define CC4350_PIN_GPIO_09		(9)
+#define CC4350_PIN_GPIO_10		(10)
+#define CC4350_PIN_GPIO_11		(11)
+#define CC4350_PIN_GPIO_12		(12)
+#define CC4350_PIN_GPIO_13		(13)
+#define CC4350_PIN_GPIO_14		(14)
+#define CC4350_PIN_GPIO_15		(15)
+
+#define CC2_4350_MEMLPLDO_PWRSW_EN_MASK		(1 << 21)
+#define CC2_4350_MEMLPLDO_PWRSW_EN_SHIFT	(21)
+#define CC2_4350_SDIO_AOS_WAKEUP_MASK		(1 << 24)
+#define CC2_4350_SDIO_AOS_WAKEUP_SHIFT		(24)
+
+
+#define CC3_SR_CLK_SR_MEM_MASK			(1 << 0)
+#define CC3_SR_CLK_SR_MEM_SHIFT			(0)
+#define CC3_SR_BIT1_TBD_MASK			(1 << 1)
+#define CC3_SR_BIT1_TBD_SHIFT			(1)
+#define CC3_SR_ENGINE_ENABLE_MASK		(1 << 2)
+#define CC3_SR_ENGINE_ENABLE_SHIFT		(2)
+#define CC3_SR_BIT3_TBD_MASK			(1 << 3)
+#define CC3_SR_BIT3_TBD_SHIFT			(3)
+#define CC3_SR_MINDIV_FAST_CLK_MASK		(0xF << 4)
+#define CC3_SR_MINDIV_FAST_CLK_SHIFT		(4)
+#define CC3_SR_R23_SR2_RISE_EDGE_TRIG_MASK	(1 << 8)
+#define CC3_SR_R23_SR2_RISE_EDGE_TRIG_SHIFT	(8)
+#define CC3_SR_R23_SR2_FALL_EDGE_TRIG_MASK	(1 << 9)
+#define CC3_SR_R23_SR2_FALL_EDGE_TRIG_SHIFT	(9)
+#define CC3_SR_R23_SR_RISE_EDGE_TRIG_MASK	(1 << 10)
+#define CC3_SR_R23_SR_RISE_EDGE_TRIG_SHIFT	(10)
+#define CC3_SR_R23_SR_FALL_EDGE_TRIG_MASK	(1 << 11)
+#define CC3_SR_R23_SR_FALL_EDGE_TRIG_SHIFT	(11)
+#define CC3_SR_NUM_CLK_HIGH_MASK		(0x7 << 12)
+#define CC3_SR_NUM_CLK_HIGH_SHIFT		(12)
+#define CC3_SR_BIT15_TBD_MASK			(1 << 15)
+#define CC3_SR_BIT15_TBD_SHIFT			(15)
+#define CC3_SR_PHY_FUNC_PIC_MASK		(1 << 16)
+#define CC3_SR_PHY_FUNC_PIC_SHIFT		(16)
+#define CC3_SR_BIT17_19_TBD_MASK		(0x7 << 17)
+#define CC3_SR_BIT17_19_TBD_SHIFT		(17)
+#define CC3_SR_CHIP_TRIGGER_1_MASK		(1 << 20)
+#define CC3_SR_CHIP_TRIGGER_1_SHIFT		(20)
+#define CC3_SR_CHIP_TRIGGER_2_MASK		(1 << 21)
+#define CC3_SR_CHIP_TRIGGER_2_SHIFT		(21)
+#define CC3_SR_CHIP_TRIGGER_3_MASK		(1 << 22)
+#define CC3_SR_CHIP_TRIGGER_3_SHIFT		(22)
+#define CC3_SR_CHIP_TRIGGER_4_MASK		(1 << 23)
+#define CC3_SR_CHIP_TRIGGER_4_SHIFT		(23)
+#define CC3_SR_ALLOW_SBC_FUNC_PIC_MASK		(1 << 24)
+#define CC3_SR_ALLOW_SBC_FUNC_PIC_SHIFT		(24)
+#define CC3_SR_BIT25_26_TBD_MASK		(0x3 << 25)
+#define CC3_SR_BIT25_26_TBD_SHIFT		(25)
+#define CC3_SR_ALLOW_SBC_STBY_MASK		(1 << 27)
+#define CC3_SR_ALLOW_SBC_STBY_SHIFT		(27)
+#define CC3_SR_GPIO_MUX_MASK			(0xF << 28)
+#define CC3_SR_GPIO_MUX_SHIFT			(28)
+
+
+#define CC4_SR_INIT_ADDR_MASK		(0x3FF0000)
+#define 	CC4_4350_SR_ASM_ADDR	(0x30)
+#define 	CC4_4335_SR_ASM_ADDR	(0x48)
+#define CC4_SR_INIT_ADDR_SHIFT		(16)
+
+#define CC4_4350_EN_SR_CLK_ALP_MASK	(1 << 30)
+#define CC4_4350_EN_SR_CLK_ALP_SHIFT	(30)
+#define CC4_4350_EN_SR_CLK_HT_MASK	(1 << 31)
+#define CC4_4350_EN_SR_CLK_HT_SHIFT	(31)
+
+#define VREG4_4350_MEMLPDO_PU_MASK	(1 << 31)
+#define VREG4_4350_MEMLPDO_PU_SHIFT	31
+
+#define CC6_4350_PCIE_CLKREQ_WAKEUP_MASK	(1 << 4)
+#define CC6_4350_PCIE_CLKREQ_WAKEUP_SHIFT	(4)
+#define CC6_4350_PMU_WAKEUP_ALPAVAIL_MASK	(1 << 6)
+#define CC6_4350_PMU_WAKEUP_ALPAVAIL_SHIFT	(6)
+
+
+#define CC_GCI_CHIPCTRL_00	(0)
+#define CC_GCI_CHIPCTRL_01	(1)
+#define CC_GCI_CHIPCTRL_02	(2)
+#define CC_GCI_CHIPCTRL_03	(3)
+#define CC_GCI_CHIPCTRL_04	(4)
+#define CC_GCI_CHIPCTRL_05	(5)
+#define CC_GCI_CHIPCTRL_06	(6)
+#define CC_GCI_CHIPCTRL_07	(7)
+#define CC_GCI_CHIPCTRL_08	(8)
+
+#define CC_GCI_06_JTAG_SEL_SHIFT	4
+#define CC_GCI_06_JTAG_SEL_MASK		(1 << 4)
+
+#define CC_GCI_NUMCHIPCTRLREGS(cap1)	((cap1 & 0xF00) >> 8)
+
+
+#define CC4335_PIN_GPIO_00		(0)
+#define CC4335_PIN_GPIO_01		(1)
+#define CC4335_PIN_GPIO_02		(2)
+#define CC4335_PIN_GPIO_03		(3)
+#define CC4335_PIN_GPIO_04		(4)
+#define CC4335_PIN_GPIO_05		(5)
+#define CC4335_PIN_GPIO_06		(6)
+#define CC4335_PIN_GPIO_07		(7)
+#define CC4335_PIN_GPIO_08		(8)
+#define CC4335_PIN_GPIO_09		(9)
+#define CC4335_PIN_GPIO_10		(10)
+#define CC4335_PIN_GPIO_11		(11)
+#define CC4335_PIN_GPIO_12		(12)
+#define CC4335_PIN_GPIO_13		(13)
+#define CC4335_PIN_GPIO_14		(14)
+#define CC4335_PIN_GPIO_15		(15)
+#define CC4335_PIN_SDIO_CLK		(16)
+#define CC4335_PIN_SDIO_CMD		(17)
+#define CC4335_PIN_SDIO_DATA0	(18)
+#define CC4335_PIN_SDIO_DATA1	(19)
+#define CC4335_PIN_SDIO_DATA2	(20)
+#define CC4335_PIN_SDIO_DATA3	(21)
+#define CC4335_PIN_RF_SW_CTRL_0	(22)
+#define CC4335_PIN_RF_SW_CTRL_1	(23)
+#define CC4335_PIN_RF_SW_CTRL_2	(24)
+#define CC4335_PIN_RF_SW_CTRL_3	(25)
+#define CC4335_PIN_RF_SW_CTRL_4	(26)
+#define CC4335_PIN_RF_SW_CTRL_5	(27)
+#define CC4335_PIN_RF_SW_CTRL_6	(28)
+#define CC4335_PIN_RF_SW_CTRL_7	(29)
+#define CC4335_PIN_RF_SW_CTRL_8	(30)
+#define CC4335_PIN_RF_SW_CTRL_9	(31)
+
+
+#define CC4335_FNSEL_HWDEF		(0)
+#define CC4335_FNSEL_SAMEASPIN	(1)
+#define CC4335_FNSEL_GPIO0		(2)
+#define CC4335_FNSEL_GPIO1		(3)
+#define CC4335_FNSEL_GCI0		(4)
+#define CC4335_FNSEL_GCI1		(5)
+#define CC4335_FNSEL_UART		(6)
+#define CC4335_FNSEL_SFLASH		(7)
+#define CC4335_FNSEL_SPROM		(8)
+#define CC4335_FNSEL_MISC0		(9)
+#define CC4335_FNSEL_MISC1		(10)
+#define CC4335_FNSEL_MISC2		(11)
+#define CC4335_FNSEL_IND		(12)
+#define CC4335_FNSEL_PDN		(13)
+#define CC4335_FNSEL_PUP		(14)
+#define CC4335_FNSEL_TRI		(15)
+
+
+#define GCIMASK(pos)  (((uint32)0xF) << pos)
+
+
+#define GCIPOSVAL(val, pos)  ((((uint32)val) << pos) & GCIMASK(pos))
+
+
+#define MUXENAB4335_UART_MASK		(0x0000000f)
+
+#define MUXENAB4335_UART_SHIFT		0
+#define MUXENAB4335_HOSTWAKE_MASK	(0x000000f0)	
+#define MUXENAB4335_HOSTWAKE_SHIFT	4
+#define MUXENAB4335_GETIX(val, name) \
+	((((val) & MUXENAB4335_ ## name ## _MASK) >> MUXENAB4335_ ## name ## _SHIFT) - 1)
+
+
 #define CHIP_HOSTIF_USB(sih)	(si_chip_hostif(sih) & CST4360_MODE_USB)
 
 
diff --git a/drivers/net/wireless/bcmdhd/include/sbconfig.h b/drivers/net/wireless/bcmdhd/include/sbconfig.h
old mode 100644
new mode 100755
index 44d6832..1ee5a8c
--- a/drivers/net/wireless/bcmdhd/include/sbconfig.h
+++ b/drivers/net/wireless/bcmdhd/include/sbconfig.h
@@ -1,25 +1,7 @@
 /*
  * Broadcom SiliconBackplane hardware register definitions.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * $Id: sbconfig.h 241182 2011-02-17 21:50:03Z $
  */
diff --git a/drivers/net/wireless/bcmdhd/include/sbhnddma.h b/drivers/net/wireless/bcmdhd/include/sbhnddma.h
old mode 100644
new mode 100755
index da1f1a1..ddcc711
--- a/drivers/net/wireless/bcmdhd/include/sbhnddma.h
+++ b/drivers/net/wireless/bcmdhd/include/sbhnddma.h
@@ -2,27 +2,9 @@
  * Generic Broadcom Home Networking Division (HND) DMA engine HW interface
  * This supports the following chips: BCM42xx, 44xx, 47xx .
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: sbhnddma.h 309193 2012-01-19 00:03:57Z $
+ * $Id: sbhnddma.h 373617 2012-12-07 23:03:08Z $
  */
 
 #ifndef	_sbhnddma_h_
@@ -233,11 +215,29 @@ typedef volatile struct {
 
 #define D64RINGALIGN_BITS	13
 #define	D64MAXRINGSZ		(1 << D64RINGALIGN_BITS)
-#define	D64RINGALIGN		(1 << D64RINGALIGN_BITS)
+#define	D64RINGBOUNDARY		(1 << D64RINGALIGN_BITS)
 
 #define	D64MAXDD	(D64MAXRINGSZ / sizeof (dma64dd_t))
 
 
+#define	D64MAXDD_LARGE		((1 << 16) / sizeof (dma64dd_t))
+
+
+#define	D64RINGBOUNDARY_LARGE	(1 << 16)
+
+
+#define D64_DEF_USBBURSTLEN     2
+#define D64_DEF_SDIOBURSTLEN    1
+
+
+#ifndef D64_USBBURSTLEN
+#define D64_USBBURSTLEN	DMA_BL_64
+#endif
+#ifndef D64_SDIOBURSTLEN
+#define D64_SDIOBURSTLEN	DMA_BL_32
+#endif
+
+
 #define	D64_XC_XE		0x00000001	
 #define	D64_XC_SE		0x00000002	
 #define	D64_XC_LE		0x00000004	
@@ -258,7 +258,7 @@ typedef volatile struct {
 #define	D64_XP_LD_MASK		0x00001fff	
 
 
-#define	D64_XS0_CD_MASK		0x00001fff	
+#define	D64_XS0_CD_MASK		(di->d64_xs0_cd_mask)	
 #define	D64_XS0_XS_MASK		0xf0000000     	
 #define	D64_XS0_XS_SHIFT		28
 #define	D64_XS0_XS_DISABLED	0x00000000	
@@ -267,7 +267,7 @@ typedef volatile struct {
 #define	D64_XS0_XS_STOPPED	0x30000000	
 #define	D64_XS0_XS_SUSP		0x40000000	
 
-#define	D64_XS1_AD_MASK		0x00001fff	
+#define	D64_XS1_AD_MASK		(di->d64_xs1_ad_mask)	
 #define	D64_XS1_XE_MASK		0xf0000000     	
 #define	D64_XS1_XE_SHIFT		28
 #define	D64_XS1_XE_NOERR	0x00000000	
@@ -285,6 +285,7 @@ typedef volatile struct {
 #define	D64_RC_SH		0x00000200	
 #define	D64_RC_OC		0x00000400	
 #define	D64_RC_PD		0x00000800	
+#define D64_RC_GE		0x00004000	
 #define	D64_RC_AE		0x00030000	
 #define	D64_RC_AE_SHIFT		16
 #define D64_RC_BL_MASK		0x001C0000	
@@ -306,7 +307,7 @@ typedef volatile struct {
 #define	D64_RP_LD_MASK		0x00001fff	
 
 
-#define	D64_RS0_CD_MASK		0x00001fff	
+#define	D64_RS0_CD_MASK		(di->d64_rs0_cd_mask)	
 #define	D64_RS0_RS_MASK		0xf0000000     	
 #define	D64_RS0_RS_SHIFT		28
 #define	D64_RS0_RS_DISABLED	0x00000000	
diff --git a/drivers/net/wireless/bcmdhd/include/sbpcmcia.h b/drivers/net/wireless/bcmdhd/include/sbpcmcia.h
old mode 100644
new mode 100755
index 6ad98b5..2bc1fbd
--- a/drivers/net/wireless/bcmdhd/include/sbpcmcia.h
+++ b/drivers/net/wireless/bcmdhd/include/sbpcmcia.h
@@ -1,27 +1,9 @@
 /*
  * BCM43XX Sonics SiliconBackplane PCMCIA core hardware definitions.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: sbpcmcia.h 326494 2012-04-09 13:29:57Z $
+ * $Id: sbpcmcia.h 381094 2013-01-25 04:45:06Z $
  */
 
 #ifndef	_SBPCMCIA_H
diff --git a/drivers/net/wireless/bcmdhd/include/sbsdio.h b/drivers/net/wireless/bcmdhd/include/sbsdio.h
old mode 100644
new mode 100755
index 4b5a1cf..1395c32
--- a/drivers/net/wireless/bcmdhd/include/sbsdio.h
+++ b/drivers/net/wireless/bcmdhd/include/sbsdio.h
@@ -4,27 +4,9 @@
  *
  * SDIO core support 1bit, 4 bit SDIO mode as well as SPI mode.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open 2003 Broadcom Corporation$
  *
- * $Id: sbsdio.h 308945 2012-01-18 02:15:27Z $
+ * $Id: sbsdio.h 383835 2013-02-07 23:32:39Z $
  */
 
 #ifndef	_SBSDIO_H
@@ -101,6 +83,7 @@
  * => busy signal is asserted between data blocks.
 */
 #define SBSDIO_MESBUSYCTRL_MASK		0x7f
+#define SBSDIO_MESBUSYCTRL_ENAB		0x80		/* Enable busy capability for MES access */
 
 /* SBSDIO_DEVICE_CTL */
 #define SBSDIO_DEVCTL_SETBUSY		0x01		/* 1: device will assert busy signal when
@@ -116,11 +99,9 @@
 							 * external pads in tri-state; requires
 							 * sdio bus power cycle to clear (rev 9)
 							 */
-#define SBSDIO_DEVCTL_SB_RST_CTL	0x30		/* Force SD->SB reset mapping (rev 11) */
-#define SBSDIO_DEVCTL_RST_CORECTL	0x00		/*   Determined by CoreControl bit */
-#define SBSDIO_DEVCTL_RST_BPRESET	0x10		/*   Force backplane reset */
-#define SBSDIO_DEVCTL_RST_NOBPRESET	0x20		/*   Force no backplane reset */
-
+#define SBSDIO_DEVCTL_EN_F2_BLK_WATERMARK 0x10  /* Enable function 2 tx for each block */
+#define SBSDIO_DEVCTL_F2WM_ENAB		0x10		/* Enable F2 Watermark */
+#define SBSDIO_DEVCTL_NONDAT_PADS_ISO 	0x20		/* Isolate sdio clk and cmd (non-data) */
 
 /* SBSDIO_FUNC1_CHIPCLKCSR */
 #define SBSDIO_FORCE_ALP		0x01		/* Force ALP request to backplane */
diff --git a/drivers/net/wireless/bcmdhd/include/sbsdpcmdev.h b/drivers/net/wireless/bcmdhd/include/sbsdpcmdev.h
old mode 100644
new mode 100755
index 2c59535..3f759c4
--- a/drivers/net/wireless/bcmdhd/include/sbsdpcmdev.h
+++ b/drivers/net/wireless/bcmdhd/include/sbsdpcmdev.h
@@ -2,27 +2,9 @@
  * Broadcom SiliconBackplane SDIO/PCMCIA hardware-specific
  * device core support
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open 2005 Broadcom Corporation$
  *
- * $Id: sbsdpcmdev.h 241182 2011-02-17 21:50:03Z $
+ * $Id: sbsdpcmdev.h 336848 2012-06-05 11:28:07Z $
  */
 
 #ifndef	_sbsdpcmdev_h_
@@ -290,4 +272,6 @@ typedef volatile struct {
 /* HW frame tag */
 #define SDPCM_FRAMETAG_LEN	4	/* HW frametag: 2 bytes len, 2 bytes check val */
 
+#define SDPCM_HWEXT_LEN	8
+
 #endif	/* _sbsdpcmdev_h_ */
diff --git a/drivers/net/wireless/bcmdhd/include/sbsocram.h b/drivers/net/wireless/bcmdhd/include/sbsocram.h
old mode 100644
new mode 100755
index 852d1151b..fcf10da
--- a/drivers/net/wireless/bcmdhd/include/sbsocram.h
+++ b/drivers/net/wireless/bcmdhd/include/sbsocram.h
@@ -1,25 +1,7 @@
 /*
  * BCM47XX Sonics SiliconBackplane embedded ram core
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * $Id: sbsocram.h 271781 2011-07-13 20:00:06Z $
  */
diff --git a/drivers/net/wireless/bcmdhd/include/sdio.h b/drivers/net/wireless/bcmdhd/include/sdio.h
old mode 100644
new mode 100755
index b8eee1f..e92c4fe
--- a/drivers/net/wireless/bcmdhd/include/sdio.h
+++ b/drivers/net/wireless/bcmdhd/include/sdio.h
@@ -2,25 +2,7 @@
  * SDIO spec header file
  * Protocol and standard (common) device definitions
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * $Id: sdio.h 308973 2012-01-18 04:19:34Z $
  */
diff --git a/drivers/net/wireless/bcmdhd/include/sdioh.h b/drivers/net/wireless/bcmdhd/include/sdioh.h
old mode 100644
new mode 100755
index e847a52..fdb43f2
--- a/drivers/net/wireless/bcmdhd/include/sdioh.h
+++ b/drivers/net/wireless/bcmdhd/include/sdioh.h
@@ -2,27 +2,9 @@
  * SDIO Host Controller Spec header file
  * Register map and definitions for the Standard Host Controller
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: sdioh.h 299859 2011-12-01 03:53:27Z $
+ * $Id: sdioh.h 345499 2012-07-18 06:59:05Z $
  */
 
 #ifndef	_SDIOH_H
@@ -89,6 +71,10 @@
 #define SD3_PresetVal_SDR50		0x06a
 #define SD3_PresetVal_SDR104	0x06c
 #define SD3_PresetVal_DDR50		0x06e
+/* SDIO3.0 Revx specific Registers */
+#define SD3_Tuning_Info_Register 0x0EC
+#define SD3_WL_BT_reset_register 0x0F0
+
 
 /* preset value indices */
 #define SD3_PRESETVAL_INITIAL_IX	0
diff --git a/drivers/net/wireless/bcmdhd/include/sdiovar.h b/drivers/net/wireless/bcmdhd/include/sdiovar.h
old mode 100644
new mode 100755
index 83f82de..2795647
--- a/drivers/net/wireless/bcmdhd/include/sdiovar.h
+++ b/drivers/net/wireless/bcmdhd/include/sdiovar.h
@@ -2,25 +2,7 @@
  * Structure used by apps whose drivers access SDIO drivers.
  * Pulled out separately so dhdu and wlu can both use it.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $ Copyright Open Broadcom Corporation $
  *
  * $Id: sdiovar.h 241182 2011-02-17 21:50:03Z $
  */
diff --git a/drivers/net/wireless/bcmdhd/include/siutils.h b/drivers/net/wireless/bcmdhd/include/siutils.h
old mode 100644
new mode 100755
index ac52bc1..3e99fcd
--- a/drivers/net/wireless/bcmdhd/include/siutils.h
+++ b/drivers/net/wireless/bcmdhd/include/siutils.h
@@ -2,27 +2,9 @@
  * Misc utility routines for accessing the SOC Interconnects
  * of Broadcom HNBU chips.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: siutils.h 321982 2012-03-19 06:58:08Z $
+ * $Id: siutils.h 385510 2013-02-15 21:02:07Z $
  */
 
 #ifndef	_siutils_h_
@@ -125,6 +107,21 @@ typedef void (*gpio_handler_t)(uint32 stat, void *arg);
 
 
 
+#define SI_CR4_CAP			(0x04)
+#define SI_CR4_BANKIDX		(0x40)
+#define SI_CR4_BANKINFO		(0x44)
+
+#define	ARMCR4_TCBBNB_MASK	0xf0
+#define	ARMCR4_TCBBNB_SHIFT	4
+#define	ARMCR4_TCBANB_MASK	0xf
+#define	ARMCR4_TCBANB_SHIFT	0
+
+#define	SICF_CPUHALT		(0x0020)
+#define	ARMCR4_BSZ_MASK		0x3f
+#define	ARMCR4_BSZ_MULT		8192
+
+
+
 extern si_t *si_attach(uint pcidev, osl_t *osh, void *regs, uint bustype,
                        void *sdh, char **vars, uint *varsz);
 extern si_t *si_kattach(osl_t *osh);
@@ -134,6 +131,7 @@ extern bool si_pci_war16165(si_t *sih);
 extern uint si_corelist(si_t *sih, uint coreid[]);
 extern uint si_coreid(si_t *sih);
 extern uint si_flag(si_t *sih);
+extern uint si_flag_alt(si_t *sih);
 extern uint si_intflag(si_t *sih);
 extern uint si_coreidx(si_t *sih);
 extern uint si_coreunit(si_t *sih);
@@ -144,6 +142,8 @@ extern void si_setosh(si_t *sih, osl_t *osh);
 extern uint si_corereg(si_t *sih, uint coreidx, uint regoff, uint mask, uint val);
 extern void *si_coreregs(si_t *sih);
 extern uint si_wrapperreg(si_t *sih, uint32 offset, uint32 mask, uint32 val);
+extern uint si_core_wrapperreg(si_t *sih, uint32 coreidx, uint32 offset, uint32 mask, uint32 val);
+extern void *si_wrapperregs(si_t *sih);
 extern uint32 si_core_cflags(si_t *sih, uint32 mask, uint32 val);
 extern void si_core_cflags_wo(si_t *sih, uint32 mask, uint32 val);
 extern uint32 si_core_sflags(si_t *sih, uint32 mask, uint32 val);
@@ -161,6 +161,7 @@ extern int si_corebist(si_t *sih);
 extern void si_core_reset(si_t *sih, uint32 bits, uint32 resetbits);
 extern void si_core_disable(si_t *sih, uint32 bits);
 extern uint32 si_clock_rate(uint32 pll_type, uint32 n, uint32 m);
+extern uint si_chip_hostif(si_t *sih);
 extern bool si_read_pmu_autopll(si_t *sih);
 extern uint32 si_clock(si_t *sih);
 extern uint32 si_alp_clock(si_t *sih);
@@ -232,6 +233,8 @@ static INLINE void * si_eci_init(si_t *sih) {return NULL;}
 #define si_seci_upd(sih, a)	do {} while (0)
 static INLINE void * si_seci_init(si_t *sih, uint8 use_seci) {return NULL;}
 #define si_seci_down(sih) do {} while (0)
+#define si_gci(sih) 0
+static INLINE void * si_gci_init(si_t *sih) {return NULL;}
 
 
 extern bool si_is_otp_disabled(si_t *sih);
@@ -267,6 +270,8 @@ extern char *si_coded_devpathvar(si_t *sih, char *varname, int var_len, const ch
 
 extern uint8 si_pcieclkreq(si_t *sih, uint32 mask, uint32 val);
 extern uint32 si_pcielcreg(si_t *sih, uint32 mask, uint32 val);
+extern uint8 si_pcieltrenable(si_t *sih, uint32 mask, uint32 val);
+extern void si_pcie_set_error_injection(si_t *sih, uint32 mode);
 extern void si_war42780_clkreq(si_t *sih, bool clkreq);
 extern void si_pci_down(si_t *sih);
 extern void si_pci_up(si_t *sih);
@@ -290,6 +295,7 @@ extern void si_btc_enable_chipcontrol(si_t *sih);
 extern void si_btcombo_p250_4313_war(si_t *sih);
 extern void si_btcombo_43228_war(si_t *sih);
 extern void si_clk_pmu_htavail_set(si_t *sih, bool set_clear);
+extern void si_pmu_synth_pwrsw_4313_war(si_t *sih);
 extern uint si_pll_reset(si_t *sih);
 
 
@@ -297,10 +303,13 @@ extern bool si_taclear(si_t *sih, bool details);
 
 
 
+extern uint32 si_ccreg(si_t *sih, uint32 offset, uint32 mask, uint32 val);
 extern uint32 si_pciereg(si_t *sih, uint32 offset, uint32 mask, uint32 val, uint type);
 extern uint32 si_pcieserdesreg(si_t *sih, uint32 mdioslave, uint32 offset, uint32 mask, uint32 val);
 extern void si_pcie_set_request_size(si_t *sih, uint16 size);
 extern uint16 si_pcie_get_request_size(si_t *sih);
+extern void si_pcie_set_maxpayload_size(si_t *sih, uint16 size);
+extern uint16 si_pcie_get_maxpayload_size(si_t *sih);
 extern uint16 si_pcie_get_ssid(si_t *sih);
 extern uint32 si_pcie_get_bar0(si_t *sih);
 extern int si_pcie_configspace_cache(si_t *sih);
@@ -310,4 +319,31 @@ extern int si_pcie_configspace_get(si_t *sih, uint8 *buf, uint size);
 char *si_getnvramflvar(si_t *sih, const char *name);
 
 
+extern uint32 si_tcm_size(si_t *sih);
+
+extern int si_set_sromctl(si_t *sih, uint32 value);
+extern uint32 si_get_sromctl(si_t *sih);
+
+extern uint32 si_gci_direct(si_t *sih, uint offset, uint32 mask, uint32 val);
+extern void si_gci_reset(si_t *sih);
+extern void si_gci_set_functionsel(si_t *sih, uint32 pin, uint8 fnsel);
+extern uint8 si_gci_get_chipctrlreg_idx(uint32 pin, uint32 *regidx, uint32 *pos);
+extern uint32 si_gci_chipcontrol(si_t *sih, uint reg, uint32 mask, uint32 val);
+
+#define CHIPCTRLREG2 0x2
+#define CHIPCTRLREG3 0x3
+#define CHIPCTRLREG4 0x4
+#define MINRESMASKREG 0x618
+#define CHIPCTRLADDR 0x650
+#define CHIPCTRLDATA 0x654
+#define RSRCTABLEADDR 0x620
+#define RSRCUPDWNTIME 0x628
+#define PMUREG_RESREQ_MASK 0x68c
+
+void
+si_update_masks(si_t *sih);
+
+void
+si_force_islanding(si_t *sih, bool enable);
+
 #endif	
diff --git a/drivers/net/wireless/bcmdhd/include/spid.h b/drivers/net/wireless/bcmdhd/include/spid.h
deleted file mode 100644
index ccae977..0000000
--- a/drivers/net/wireless/bcmdhd/include/spid.h
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * SPI device spec header file
- *
- * Copyright (C) 2012, Broadcom Corporation
- * All Rights Reserved.
- * 
- * This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;
- * the contents of this file may not be disclosed to third parties, copied
- * or duplicated in any form, in whole or in part, without the prior
- * written permission of Broadcom Corporation.
- *
- * $Id: spid.h 241182 2011-02-17 21:50:03Z $
- */
-
-#ifndef	_SPI_H
-#define	_SPI_H
-
-/*
- * Brcm SPI Device Register Map.
- *
- */
-
-typedef volatile struct {
-	uint8	config;			/* 0x00, len, endian, clock, speed, polarity, wakeup */
-	uint8	response_delay;		/* 0x01, read response delay in bytes (corerev < 3) */
-	uint8	status_enable;		/* 0x02, status-enable, intr with status, response_delay
-					 * function selection, command/data error check
-					 */
-	uint8	reset_bp;		/* 0x03, reset on wlan/bt backplane reset (corerev >= 1) */
-	uint16	intr_reg;		/* 0x04, Intr status register */
-	uint16	intr_en_reg;		/* 0x06, Intr mask register */
-	uint32	status_reg;		/* 0x08, RO, Status bits of last spi transfer */
-	uint16	f1_info_reg;		/* 0x0c, RO, enabled, ready for data transfer, blocksize */
-	uint16	f2_info_reg;		/* 0x0e, RO, enabled, ready for data transfer, blocksize */
-	uint16	f3_info_reg;		/* 0x10, RO, enabled, ready for data transfer, blocksize */
-	uint32	test_read;		/* 0x14, RO 0xfeedbead signature */
-	uint32	test_rw;		/* 0x18, RW */
-	uint8	resp_delay_f0;		/* 0x1c, read resp delay bytes for F0 (corerev >= 3) */
-	uint8	resp_delay_f1;		/* 0x1d, read resp delay bytes for F1 (corerev >= 3) */
-	uint8	resp_delay_f2;		/* 0x1e, read resp delay bytes for F2 (corerev >= 3) */
-	uint8	resp_delay_f3;		/* 0x1f, read resp delay bytes for F3 (corerev >= 3) */
-} spi_regs_t;
-
-/* SPI device register offsets */
-#define SPID_CONFIG			0x00
-#define SPID_RESPONSE_DELAY		0x01
-#define SPID_STATUS_ENABLE		0x02
-#define SPID_RESET_BP			0x03	/* (corerev >= 1) */
-#define SPID_INTR_REG			0x04	/* 16 bits - Interrupt status */
-#define SPID_INTR_EN_REG		0x06	/* 16 bits - Interrupt mask */
-#define SPID_STATUS_REG			0x08	/* 32 bits */
-#define SPID_F1_INFO_REG		0x0C	/* 16 bits */
-#define SPID_F2_INFO_REG		0x0E	/* 16 bits */
-#define SPID_F3_INFO_REG		0x10	/* 16 bits */
-#define SPID_TEST_READ			0x14	/* 32 bits */
-#define SPID_TEST_RW			0x18	/* 32 bits */
-#define SPID_RESP_DELAY_F0		0x1c	/* 8 bits (corerev >= 3) */
-#define SPID_RESP_DELAY_F1		0x1d	/* 8 bits (corerev >= 3) */
-#define SPID_RESP_DELAY_F2		0x1e	/* 8 bits (corerev >= 3) */
-#define SPID_RESP_DELAY_F3		0x1f	/* 8 bits (corerev >= 3) */
-
-/* Bit masks for SPID_CONFIG device register */
-#define WORD_LENGTH_32	0x1	/* 0/1 16/32 bit word length */
-#define ENDIAN_BIG	0x2	/* 0/1 Little/Big Endian */
-#define CLOCK_PHASE	0x4	/* 0/1 clock phase delay */
-#define CLOCK_POLARITY	0x8	/* 0/1 Idle state clock polarity is low/high */
-#define HIGH_SPEED_MODE	0x10	/* 1/0 High Speed mode / Normal mode */
-#define INTR_POLARITY	0x20	/* 1/0 Interrupt active polarity is high/low */
-#define WAKE_UP		0x80	/* 0/1 Wake-up command from Host to WLAN */
-
-/* Bit mask for SPID_RESPONSE_DELAY device register */
-#define RESPONSE_DELAY_MASK	0xFF	/* Configurable rd response delay in multiples of 8 bits */
-
-/* Bit mask for SPID_STATUS_ENABLE device register */
-#define STATUS_ENABLE		0x1	/* 1/0 Status sent/not sent to host after read/write */
-#define INTR_WITH_STATUS	0x2	/* 0/1 Do-not / do-interrupt if status is sent */
-#define RESP_DELAY_ALL		0x4	/* Applicability of resp delay to F1 or all func's read */
-#define DWORD_PKT_LEN_EN	0x8	/* Packet len denoted in dwords instead of bytes */
-#define CMD_ERR_CHK_EN		0x20	/* Command error check enable */
-#define DATA_ERR_CHK_EN		0x40	/* Data error check enable */
-
-/* Bit mask for SPID_RESET_BP device register */
-#define RESET_ON_WLAN_BP_RESET	0x4	/* enable reset for WLAN backplane */
-#define RESET_ON_BT_BP_RESET	0x8	/* enable reset for BT backplane */
-#define RESET_SPI		0x80	/* reset the above enabled logic */
-
-/* Bit mask for SPID_INTR_REG device register */
-#define DATA_UNAVAILABLE	0x0001	/* Requested data not available; Clear by writing a "1" */
-#define F2_F3_FIFO_RD_UNDERFLOW	0x0002
-#define F2_F3_FIFO_WR_OVERFLOW	0x0004
-#define COMMAND_ERROR		0x0008	/* Cleared by writing 1 */
-#define DATA_ERROR		0x0010	/* Cleared by writing 1 */
-#define F2_PACKET_AVAILABLE	0x0020
-#define F3_PACKET_AVAILABLE	0x0040
-#define F1_OVERFLOW		0x0080	/* Due to last write. Bkplane has pending write requests */
-#define MISC_INTR0		0x0100
-#define MISC_INTR1		0x0200
-#define MISC_INTR2		0x0400
-#define MISC_INTR3		0x0800
-#define MISC_INTR4		0x1000
-#define F1_INTR			0x2000
-#define F2_INTR			0x4000
-#define F3_INTR			0x8000
-
-/* Bit mask for 32bit SPID_STATUS_REG device register */
-#define STATUS_DATA_NOT_AVAILABLE	0x00000001
-#define STATUS_UNDERFLOW		0x00000002
-#define STATUS_OVERFLOW			0x00000004
-#define STATUS_F2_INTR			0x00000008
-#define STATUS_F3_INTR			0x00000010
-#define STATUS_F2_RX_READY		0x00000020
-#define STATUS_F3_RX_READY		0x00000040
-#define STATUS_HOST_CMD_DATA_ERR	0x00000080
-#define STATUS_F2_PKT_AVAILABLE		0x00000100
-#define STATUS_F2_PKT_LEN_MASK		0x000FFE00
-#define STATUS_F2_PKT_LEN_SHIFT		9
-#define STATUS_F3_PKT_AVAILABLE		0x00100000
-#define STATUS_F3_PKT_LEN_MASK		0xFFE00000
-#define STATUS_F3_PKT_LEN_SHIFT		21
-
-/* Bit mask for 16 bits SPID_F1_INFO_REG device register */
-#define F1_ENABLED 			0x0001
-#define F1_RDY_FOR_DATA_TRANSFER	0x0002
-#define F1_MAX_PKT_SIZE			0x01FC
-
-/* Bit mask for 16 bits SPID_F2_INFO_REG device register */
-#define F2_ENABLED 			0x0001
-#define F2_RDY_FOR_DATA_TRANSFER	0x0002
-#define F2_MAX_PKT_SIZE			0x3FFC
-
-/* Bit mask for 16 bits SPID_F3_INFO_REG device register */
-#define F3_ENABLED 			0x0001
-#define F3_RDY_FOR_DATA_TRANSFER	0x0002
-#define F3_MAX_PKT_SIZE			0x3FFC
-
-/* Bit mask for 32 bits SPID_TEST_READ device register read in 16bit LE mode */
-#define TEST_RO_DATA_32BIT_LE		0xFEEDBEAD
-
-/* Maximum number of I/O funcs */
-#define SPI_MAX_IOFUNCS		4
-
-#define SPI_MAX_PKT_LEN		(2048*4)
-
-/* Misc defines */
-#define SPI_FUNC_0		0
-#define SPI_FUNC_1		1
-#define SPI_FUNC_2		2
-#define SPI_FUNC_3		3
-
-#define WAIT_F2RXFIFORDY	100
-#define WAIT_F2RXFIFORDY_DELAY	20
-
-#endif /* _SPI_H */
diff --git a/drivers/net/wireless/bcmdhd/include/trxhdr.h b/drivers/net/wireless/bcmdhd/include/trxhdr.h
old mode 100644
new mode 100755
index bf92a56..249527c
--- a/drivers/net/wireless/bcmdhd/include/trxhdr.h
+++ b/drivers/net/wireless/bcmdhd/include/trxhdr.h
@@ -1,27 +1,9 @@
 /*
  * TRX image file header format.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: trxhdr.h 260898 2011-05-20 23:11:12Z $
+ * $Id: trxhdr.h 349211 2012-08-07 09:45:24Z $
  */
 
 #ifndef _TRX_HDR_H
@@ -30,23 +12,62 @@
 #include <typedefs.h>
 
 #define TRX_MAGIC	0x30524448	/* "HDR0" */
-#define TRX_VERSION	1		/* Version 1 */
 #define TRX_MAX_LEN	0x3B0000	/* Max length */
 #define TRX_NO_HEADER	1		/* Do not write TRX header */
 #define TRX_GZ_FILES	0x2     /* Contains up to TRX_MAX_OFFSET individual gzip files */
 #define TRX_EMBED_UCODE	0x8	/* Trx contains embedded ucode image */
 #define TRX_ROMSIM_IMAGE	0x10	/* Trx contains ROM simulation image */
 #define TRX_UNCOMP_IMAGE	0x20	/* Trx contains uncompressed rtecdc.bin image */
-#define TRX_MAX_OFFSET	3		/* Max number of individual files */
+#define TRX_BOOTLOADER		0x40	/* the image is a bootloader */
 
+#define TRX_V1		1
+#define TRX_V1_MAX_OFFSETS	3		/* V1: Max number of individual files */
+
+#ifndef BCMTRXV2
+#define TRX_VERSION	TRX_V1		/* Version 1 */
+#define TRX_MAX_OFFSET TRX_V1_MAX_OFFSETS
+#endif
+
+/* BMAC Host driver/application like bcmdl need to support both Ver 1 as well as
+ * Ver 2 of trx header. To make it generic, trx_header is structure is modified
+ * as below where size of "offsets" field will vary as per the TRX version.
+ * Currently, BMAC host driver and bcmdl are modified to support TRXV2 as well.
+ * To make sure, other applications like "dhdl" which are yet to be enhanced to support
+ * TRXV2 are not broken, new macro and structure defintion take effect only when BCMTRXV2
+ * is defined.
+ */
 struct trx_header {
 	uint32 magic;		/* "HDR0" */
 	uint32 len;		/* Length of file including header */
 	uint32 crc32;		/* 32-bit CRC from flag_version to end of file */
 	uint32 flag_version;	/* 0:15 flags, 16:31 version */
+#ifndef BCMTRXV2
 	uint32 offsets[TRX_MAX_OFFSET];	/* Offsets of partitions from start of header */
+#else
+	uint32 offsets[1];	/* Offsets of partitions from start of header */
+#endif
 };
 
+#ifdef BCMTRXV2
+#define TRX_VERSION		TRX_V2		/* Version 2 */
+#define TRX_MAX_OFFSET  TRX_V2_MAX_OFFSETS
+
+#define TRX_V2		2
+/* V2: Max number of individual files
+ * To support SDR signature + Config data region
+ */
+#define TRX_V2_MAX_OFFSETS	5
+#define SIZEOF_TRXHDR_V1	(sizeof(struct trx_header)+(TRX_V1_MAX_OFFSETS-1)*sizeof(uint32))
+#define SIZEOF_TRXHDR_V2	(sizeof(struct trx_header)+(TRX_V2_MAX_OFFSETS-1)*sizeof(uint32))
+#define TRX_VER(trx)		(trx->flag_version>>16)
+#define ISTRX_V1(trx)		(TRX_VER(trx) == TRX_V1)
+#define ISTRX_V2(trx)		(TRX_VER(trx) == TRX_V2)
+/* For V2, return size of V2 size: others, return V1 size */
+#define SIZEOF_TRX(trx)	    (ISTRX_V2(trx) ? SIZEOF_TRXHDR_V2: SIZEOF_TRXHDR_V1)
+#else
+#define SIZEOF_TRX(trx)	    (sizeof(struct trx_header))
+#endif /* BCMTRXV2 */
+
 /* Compatibility */
 typedef struct trx_header TRXHDR, *PTRXHDR;
 
diff --git a/drivers/net/wireless/bcmdhd/include/typedefs.h b/drivers/net/wireless/bcmdhd/include/typedefs.h
old mode 100644
new mode 100755
index 4eee5ba..e8bd5d0
--- a/drivers/net/wireless/bcmdhd/include/typedefs.h
+++ b/drivers/net/wireless/bcmdhd/include/typedefs.h
@@ -1,23 +1,5 @@
 /*
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  * $Id: typedefs.h 286783 2011-09-29 06:18:57Z $
  */
 
diff --git a/drivers/net/wireless/bcmdhd/include/usbrdl.h b/drivers/net/wireless/bcmdhd/include/usbrdl.h
deleted file mode 100644
index c90dccd..0000000
--- a/drivers/net/wireless/bcmdhd/include/usbrdl.h
+++ /dev/null
@@ -1,203 +0,0 @@
-/*
- * Broadcom USB remote download definitions
- *
- * Copyright (C) 2012, Broadcom Corporation
- * All Rights Reserved.
- * 
- * This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;
- * the contents of this file may not be disclosed to third parties, copied
- * or duplicated in any form, in whole or in part, without the prior
- * written permission of Broadcom Corporation.
- *
- * $Id: usbrdl.h 296577 2011-11-16 03:09:51Z $
- */
-
-#ifndef _USB_RDL_H
-#define _USB_RDL_H
-
-/* Control messages: bRequest values */
-#define DL_GETSTATE		0	/* returns the rdl_state_t struct */
-#define DL_CHECK_CRC		1	/* currently unused */
-#define DL_GO			2	/* execute downloaded image */
-#define DL_START		3	/* initialize dl state */
-#define DL_REBOOT		4	/* reboot the device in 2 seconds */
-#define DL_GETVER		5	/* returns the bootrom_id_t struct */
-#define DL_GO_PROTECTED		6	/* execute the downloaded code and set reset event
-					 * to occur in 2 seconds.  It is the responsibility
-					 * of the downloaded code to clear this event
-					 */
-#define DL_EXEC			7	/* jump to a supplied address */
-#define DL_RESETCFG		8	/* To support single enum on dongle
-					 * - Not used by bootloader
-					 */
-#define DL_DEFER_RESP_OK	9	/* Potentially defer the response to setup
-					 * if resp unavailable
-					 */
-
-#define	DL_HWCMD_MASK		0xfc	/* Mask for hardware read commands: */
-#define	DL_RDHW			0x10	/* Read a hardware address (Ctl-in) */
-#define	DL_RDHW32		0x10	/* Read a 32 bit word */
-#define	DL_RDHW16		0x11	/* Read 16 bits */
-#define	DL_RDHW8		0x12	/* Read an 8 bit byte */
-#define	DL_WRHW			0x14	/* Write a hardware address (Ctl-out) */
-#define DL_WRHW_BLK 	0x13	/* Block write to hardware access */
-
-#define DL_CMD_RDHW		1	/* read data from a backplane address */
-#define DL_CMD_WRHW		2	/* write data to a backplane address */
-
-#ifndef LINUX_POSTMOGRIFY_REMOVAL
-#define	DL_JTCONF		0x15	/* Get JTAG configuration (Ctl_in)
-					 *  Set JTAG configuration (Ctl-out)
-					 */
-#define	DL_JTON			0x16	/* Turn on jtag master (Ctl-in) */
-#define	DL_JTOFF		0x17	/* Turn on jtag master (Ctl-in) */
-#define	DL_RDRJT		0x18	/* Read a JTAG register (Ctl-in) */
-#define	DL_WRJT			0x19	/* Write a hardware address over JTAG (Ctl/Bulk-out) */
-#define	DL_WRRJT		0x1a	/* Write a JTAG register (Ctl/Bulk-out) */
-#define	DL_JTRST		0x1b	/* Reset jtag fsm on jtag DUT (Ctl-in) */
-
-#define	DL_RDJT			0x1c	/* Read a hardware address over JTAG (Ctl-in) */
-#define	DL_RDJT32		0x1c	/* Read 32 bits */
-#define	DL_RDJT16		0x1e	/* Read 16 bits (sz = 4 - low bits) */
-#define	DL_RDJT8		0x1f	/* Read 8 bits */
-
-#define	DL_MRDJT		0x20	/* Multiple read over JTAG (Ctl-out+Bulk-in) */
-#define	DL_MRDJT32		0x20	/* M-read 32 bits */
-#define	DL_MRDJT16		0x22	/* M-read 16 bits (sz = 4 - low bits) */
-#define	DL_MRDJT6		0x23	/* M-read 8 bits */
-#define	DL_MRDIJT		0x24	/* M-read over JTAG (Ctl-out+Bulk-in) with auto-increment */
-#define	DL_MRDIJT32		0x24	/* M-read 32 bits w/ai */
-#define	DL_MRDIJT16		0x26	/* M-read 16 bits w/ai (sz = 4 - low bits) */
-#define	DL_MRDIJT8		0x27	/* M-read 8 bits w/ai */
-#define	DL_MRDDJT		0x28	/* M-read over JTAG (Ctl-out+Bulk-in) with auto-decrement */
-#define	DL_MRDDJT32		0x28	/* M-read 32 bits w/ad */
-#define	DL_MRDDJT16		0x2a	/* M-read 16 bits w/ad (sz = 4 - low bits) */
-#define	DL_MRDDJT8		0x2b	/* M-read 8 bits w/ad */
-#define	DL_MWRJT		0x2c	/* Multiple write over JTAG (Bulk-out) */
-#define	DL_MWRIJT		0x2d	/*	With auto-increment */
-#define	DL_MWRDJT		0x2e	/*	With auto-decrement */
-#define	DL_VRDJT		0x2f	/* Vector read over JTAG (Bulk-out+Bulk-in) */
-#define	DL_VWRJT		0x30	/* Vector write over JTAG (Bulk-out+Bulk-in) */
-#define	DL_SCJT			0x31	/* Jtag scan (Bulk-out+Bulk-in) */
-
-#define	DL_CFRD			0x33	/* Reserved for dmamem use */
-#define	DL_CFWR			0x34	/* Reserved for dmamem use */
-#define DL_GET_NVRAM            0x35    /* Query nvram parameter */
-
-#define	DL_DBGTRIG		0xFF	/* Trigger bRequest type to aid debug */
-
-#define	DL_JTERROR		0x80000000
-#endif /* LINUX_POSTMOGRIFY_REMOVAL */
-
-/* states */
-#define DL_WAITING	0	/* waiting to rx first pkt that includes the hdr info */
-#define DL_READY	1	/* hdr was good, waiting for more of the compressed image */
-#define DL_BAD_HDR	2	/* hdr was corrupted */
-#define DL_BAD_CRC	3	/* compressed image was corrupted */
-#define DL_RUNNABLE	4	/* download was successful, waiting for go cmd */
-#define DL_START_FAIL	5	/* failed to initialize correctly */
-#define DL_NVRAM_TOOBIG	6	/* host specified nvram data exceeds DL_NVRAM value */
-#define DL_IMAGE_TOOBIG	7	/* download image too big (exceeds DATA_START for rdl) */
-
-#define TIMEOUT		5000	/* Timeout for usb commands */
-
-struct bcm_device_id {
-	char	*name;
-	uint32	vend;
-	uint32	prod;
-};
-
-typedef struct {
-	uint32	state;
-	uint32	bytes;
-} rdl_state_t;
-
-typedef struct {
-	uint32	chip;		/* Chip id */
-	uint32	chiprev;	/* Chip rev */
-	uint32  ramsize;    /* Size of RAM */
-	uint32  remapbase;   /* Current remap base address */
-	uint32  boardtype;   /* Type of board */
-	uint32  boardrev;    /* Board revision */
-} bootrom_id_t;
-
-/* struct for backplane & jtag accesses */
-typedef struct {
-	uint32	cmd;		/* tag to identify the cmd */
-	uint32	addr;		/* backplane address for write */
-	uint32	len;		/* length of data: 1, 2, 4 bytes */
-	uint32	data;		/* data to write */
-} hwacc_t;
-
-/* struct for backplane */
-typedef struct {
-	uint32  cmd;            /* tag to identify the cmd */
-	uint32  addr;           /* backplane address for write */
-	uint32  len;            /* length of data: 1, 2, 4 bytes */
-	uint8   data[1];                /* data to write */
-} hwacc_blk_t;
-
-#ifndef LINUX_POSTMOGRIFY_REMOVAL
-typedef struct {
-	uint32  chip;           /* Chip id */
-	uint32  chiprev;        /* Chip rev */
-	uint32  ccrev;          /* Chipcommon core rev */
-	uint32  siclock;        /* Backplane clock */
-} jtagd_id_t;
-
-/* Jtag configuration structure */
-typedef struct {
-	uint32	cmd;		/* tag to identify the cmd */
-	uint8	clkd;		/* Jtag clock divisor */
-	uint8	disgpio;	/* Gpio to disable external driver */
-	uint8	irsz;		/* IR size for readreg/writereg */
-	uint8	drsz;		/* DR size for readreg/writereg */
-
-	uint8	bigend;		/* Big endian */
-	uint8	mode;		/* Current mode */
-	uint16	delay;		/* Delay between jtagm "simple commands" */
-
-	uint32	retries;	/* Number of retries for jtagm operations */
-	uint32	ctrl;		/* Jtag control reg copy */
-	uint32	ir_lvbase;	/* Bits to add to IR values in LV tap */
-	uint32	dretries;	/* Number of retries for dma operations */
-} jtagconf_t;
-
-/* struct for jtag scan */
-#define MAX_USB_IR_BITS	256
-#define MAX_USB_DR_BITS	3072
-#define USB_IR_WORDS	(MAX_USB_IR_BITS / 32)
-#define USB_DR_WORDS	(MAX_USB_DR_BITS / 32)
-typedef struct {
-	uint32	cmd;		/* tag to identify the cmd */
-	uint32	irsz;		/* IR size in bits */
-	uint32	drsz;		/* DR size in bits */
-	uint32	ts;		/* Terminal state (def, pause, rti) */
-	uint32	data[USB_IR_WORDS + USB_DR_WORDS];	/* IR & DR data */
-} scjt_t;
-#endif /* LINUX_POSTMOGRIFY_REMOVAL */
-
-/* struct for querying nvram params from bootloader */
-#define QUERY_STRING_MAX 32
-typedef struct {
-	uint32  cmd;                    /* tag to identify the cmd */
-	char    var[QUERY_STRING_MAX];  /* param name */
-} nvparam_t;
-
-typedef void (*exec_fn_t)(void *sih);
-
-#define USB_CTRL_IN (USB_TYPE_VENDOR | 0x80 | USB_RECIP_INTERFACE)
-#define USB_CTRL_OUT (USB_TYPE_VENDOR | 0 | USB_RECIP_INTERFACE)
-
-#define USB_CTRL_EP_TIMEOUT 500 /* Timeout used in USB control_msg transactions. */
-
-#define RDL_CHUNK	1500  /* size of each dl transfer */
-
-/* bootloader makes special use of trx header "offsets" array */
-#define TRX_OFFSETS_DLFWLEN_IDX	0	/* Size of the fw; used in uncompressed case */
-#define TRX_OFFSETS_JUMPTO_IDX	1	/* RAM address for jumpto after download */
-#define TRX_OFFSETS_NVM_LEN_IDX	2	/* Length of appended NVRAM data */
-
-#define TRX_OFFSETS_DLBASE_IDX  0       /* RAM start address for download */
-
-#endif  /* _USB_RDL_H */
diff --git a/drivers/net/wireless/bcmdhd/include/wlc_extlog_idstr.h b/drivers/net/wireless/bcmdhd/include/wlc_extlog_idstr.h
deleted file mode 100644
index 95f616a..0000000
--- a/drivers/net/wireless/bcmdhd/include/wlc_extlog_idstr.h
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * EXTLOG Module log ID to log Format String mapping table
- *
- * Copyright (C) 2012, Broadcom Corporation
- * All Rights Reserved.
- * 
- * This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;
- * the contents of this file may not be disclosed to third parties, copied
- * or duplicated in any form, in whole or in part, without the prior
- * written permission of Broadcom Corporation.
- *
- * $Id: wlc_extlog_idstr.h 241182 2011-02-17 21:50:03Z $
- */
-#ifndef _WLC_EXTLOG_IDSTR_H_
-#define _WLC_EXTLOG_IDSTR_H_
-
-#include "wlioctl.h"
-
-/* Strings corresponding to the IDs defined in wlioctl.h
- * This file is only included by the apps and not included by the external driver
- * Formats of pre-existing ids should NOT be changed
- */
-log_idstr_t extlog_fmt_str[ ] = {
-	{FMTSTR_DRIVER_UP_ID, 0, LOG_ARGTYPE_NULL,
-	"Driver is Up\n"},
-
-	{FMTSTR_DRIVER_DOWN_ID, 0, LOG_ARGTYPE_NULL,
-	"Driver is Down\n"},
-
-	{FMTSTR_SUSPEND_MAC_FAIL_ID, 0, LOG_ARGTYPE_INT,
-	"wlc_suspend_mac_and_wait() failed with psmdebug 0x%08x\n"},
-
-	{FMTSTR_NO_PROGRESS_ID, 0, LOG_ARGTYPE_INT,
-	"No Progress on TX for %d seconds\n"},
-
-	{FMTSTR_RFDISABLE_ID, 0, LOG_ARGTYPE_INT,
-	"Detected a change in RF Disable Input 0x%x\n"},
-
-	{FMTSTR_REG_PRINT_ID, 0, LOG_ARGTYPE_STR_INT,
-	"Register %s = 0x%x\n"},
-
-	{FMTSTR_EXPTIME_ID, FMTSTRF_USER, LOG_ARGTYPE_NULL,
-	"Strong RF interference detected\n"},
-
-	{FMTSTR_JOIN_START_ID, FMTSTRF_USER, LOG_ARGTYPE_STR,
-	"Searching for networks with ssid %s\n"},
-
-	{FMTSTR_JOIN_COMPLETE_ID, FMTSTRF_USER, LOG_ARGTYPE_STR,
-	"Successfully joined network with BSSID %s\n"},
-
-	{FMTSTR_NO_NETWORKS_ID, FMTSTRF_USER, LOG_ARGTYPE_NULL,
-	"No networks found. Please check if the network exists and is in range\n"},
-
-	{FMTSTR_SECURITY_MISMATCH_ID, FMTSTRF_USER, LOG_ARGTYPE_NULL,
-	"AP rejected due to security mismatch. Change the security settings and try again...\n"},
-
-	{FMTSTR_RATE_MISMATCH_ID, FMTSTRF_USER, LOG_ARGTYPE_NULL,
-	"AP rejected due to rate mismatch\n"},
-
-	{FMTSTR_AP_PRUNED_ID, 0, LOG_ARGTYPE_INT,
-	"AP rejected due to reason %d\n"},
-
-	{FMTSTR_KEY_INSERTED_ID, 0, LOG_ARGTYPE_INT,
-	"Inserting keys for algorithm %d\n"},
-
-	{FMTSTR_DEAUTH_ID, FMTSTRF_USER, LOG_ARGTYPE_STR_INT,
-	"Received Deauth from %s with Reason %d\n"},
-
-	{FMTSTR_DISASSOC_ID, FMTSTRF_USER, LOG_ARGTYPE_STR_INT,
-	"Received Disassoc from %s with Reason %d\n"},
-
-	{FMTSTR_LINK_UP_ID, FMTSTRF_USER, LOG_ARGTYPE_NULL,
-	"Link Up\n"},
-
-	{FMTSTR_LINK_DOWN_ID, FMTSTRF_USER, LOG_ARGTYPE_NULL,
-	"Link Down\n"},
-
-	{FMTSTR_RADIO_HW_OFF_ID, FMTSTRF_USER, LOG_ARGTYPE_NULL,
-	"Radio button is turned OFF. Please turn it on...\n"},
-
-	{FMTSTR_RADIO_HW_ON_ID, FMTSTRF_USER, LOG_ARGTYPE_NULL,
-	"Hardware Radio button is turned ON\n"},
-
-	{FMTSTR_EVENT_DESC_ID, 0, LOG_ARGTYPE_INT_STR,
-	"Generated event id %d: (result status) is (%s)\n"},
-
-	{FMTSTR_PNP_SET_POWER_ID, 0, LOG_ARGTYPE_INT,
-	"Device going into power state %d\n"},
-
-	{FMTSTR_RADIO_SW_OFF_ID, FMTSTRF_USER, LOG_ARGTYPE_NULL,
-	"Software Radio is disabled. Please enable it through the UI...\n"},
-
-	{FMTSTR_RADIO_SW_ON_ID, FMTSTRF_USER, LOG_ARGTYPE_NULL,
-	"Software Radio is enabled\n"},
-
-	{FMTSTR_PWD_MISMATCH_ID, FMTSTRF_USER, LOG_ARGTYPE_NULL,
-	"Potential passphrase mismatch. Please try a different one...\n"},
-
-	{FMTSTR_FATAL_ERROR_ID, 0, LOG_ARGTYPE_INT,
-	"Fatal Error: intstatus 0x%x\n"},
-
-	{FMTSTR_AUTH_FAIL_ID, 0, LOG_ARGTYPE_STR_INT,
-	"Authentication to %s Failed with status %d\n"},
-
-	{FMTSTR_ASSOC_FAIL_ID, 0, LOG_ARGTYPE_STR_INT,
-	"Association to %s Failed with status %d\n"},
-
-	{FMTSTR_IBSS_FAIL_ID, FMTSTRF_USER, LOG_ARGTYPE_NULL,
-	"Unable to start IBSS since PeerNet is already active\n"},
-
-	{FMTSTR_EXTAP_FAIL_ID, FMTSTRF_USER, LOG_ARGTYPE_NULL,
-	"Unable to start Ext-AP since PeerNet is already active\n"},
-
-	{FMTSTR_MAX_ID, 0, 0, "\0"}
-};
-
-#endif /* _WLC_EXTLOG_IDSTR_H_ */
diff --git a/drivers/net/wireless/bcmdhd/include/wlfc_proto.h b/drivers/net/wireless/bcmdhd/include/wlfc_proto.h
old mode 100644
new mode 100755
index 82f29d1..d9e5aa7
--- a/drivers/net/wireless/bcmdhd/include/wlfc_proto.h
+++ b/drivers/net/wireless/bcmdhd/include/wlfc_proto.h
@@ -1,24 +1,6 @@
 /*
-* Copyright (C) 1999-2012, Broadcom Corporation
-* 
-*      Unless you and Broadcom execute a separate written software license
-* agreement governing use of this software, this software is licensed to you
-* under the terms of the GNU General Public License version 2 (the "GPL"),
-* available at http://www.broadcom.com/licenses/GPLv2.php, with the
-* following added to such license:
-* 
-*      As a special exception, the copyright holders of this software give you
-* permission to link this software with independent modules, and to copy and
-* distribute the resulting executable under terms of your choice, provided that
-* you also meet, for each linked independent module, the terms and conditions of
-* the license of that module.  An independent module is a module which is not
-* derived from this software.  The special exception does not apply to any
-* modifications of the software.
-* 
-*      Notwithstanding the above, under no circumstances may you combine this
-* software in any way with any other Broadcom software provided under a license
-* other than the GPL, without Broadcom's express prior written consent.
-* $Id: wlfc_proto.h 328114 2012-04-18 00:02:46Z $
+* $Copyright Open 2009 Broadcom Corporation$
+* $Id: wlfc_proto.h 381382 2013-01-27 07:13:00Z $
 *
 */
 #ifndef __wlfc_proto_definitions_h__
@@ -34,7 +16,8 @@
 	 ---------------------------------------------------------------------------
 	|  3   |   2  | (count, handle, prec_bmp)| Set the credit depth for a MAC dstn
 	 ---------------------------------------------------------------------------
-	|  4   |   4  | see pkttag comments      | TXSTATUS
+	|  4   |   4+ | see pkttag comments      | TXSTATUS
+	|      |      | TX status & timestamps   | Present only when pkt timestamp is enabled
 	 ---------------------------------------------------------------------------
 	|  5   |   4  | see pkttag comments      | PKKTTAG [host->firmware]
 	 ---------------------------------------------------------------------------
@@ -62,11 +45,9 @@
 	|  13  |   3  | (count, handle, prec_bmp)| One time request for packet to a specific
 	|      |      |                          | MAC destination.
 	 ---------------------------------------------------------------------------
-	|  15  |   1  | interface ID             | NIC period start
+	|  15  |  12  | (pkttag, timestamps)     | Send TX timestamp at reception from host
 	 ---------------------------------------------------------------------------
-	|  16  |   1  | interface ID             | NIC period end
-	 ---------------------------------------------------------------------------
-	|  17  |   3  | (ifid, txs)              | Action frame tx status
+	|  16  |  12  | (pkttag, timestamps)     | Send WLAN RX timestamp along with RX frame
 	 ---------------------------------------------------------------------------
 	| 255  |  N/A |  N/A                     | FILLER - This is a special type
 	|      |      |                          | that has no length or value.
@@ -82,7 +63,7 @@
 
 #define WLFC_CTL_TYPE_MACDESC_ADD		6
 #define WLFC_CTL_TYPE_MACDESC_DEL		7
-#define WLFC_CTL_TYPE_RSSI					8
+#define WLFC_CTL_TYPE_RSSI			8
 
 #define WLFC_CTL_TYPE_INTERFACE_OPEN		9
 #define WLFC_CTL_TYPE_INTERFACE_CLOSE		10
@@ -93,9 +74,12 @@
 #define WLFC_CTL_TYPE_MAC_REQUEST_PACKET	13
 #define WLFC_CTL_TYPE_HOST_REORDER_RXPKTS	14
 
-#define WLFC_CTL_TYPE_NIC_PRD_START		15
-#define WLFC_CTL_TYPE_NIC_PRD_END		16
-#define WLFC_CTL_TYPE_AF_TXS			17
+#define WLFC_CTL_TYPE_TX_ENTRY_STAMP		15
+#define WLFC_CTL_TYPE_RX_STAMP			16
+
+#define WLFC_CTL_TYPE_TRANS_ID			18
+#define WLFC_CTL_TYPE_COMP_TXSTATUS		19
+
 
 #define WLFC_CTL_TYPE_FILLER			255
 
@@ -116,10 +100,6 @@
 #define WLFC_CTL_VALUE_LEN_REQUEST_CREDIT	3	/* credit, MAC-handle, prec_bitmap */
 #define WLFC_CTL_VALUE_LEN_REQUEST_PACKET	3	/* credit, MAC-handle, prec_bitmap */
 
-#define WLFC_CTL_VALUE_LEN_NIC_PRD_START	1
-#define WLFC_CTL_VALUE_LEN_NIC_PRD_END		1
-#define WLFC_CTL_VALUE_LEN_AF_TXS		3
-
 
 #define WLFC_PKTID_GEN_MASK		0x80000000
 #define WLFC_PKTID_GEN_SHIFT	31
@@ -226,4 +206,7 @@
 #define WLHOST_REORDERDATA_EXPIDX_VALID		0x08
 #define WLHOST_REORDERDATA_NEW_HOLE		0x10
 
+/* transaction id data len byte 0: rsvd, byte 1: seqnumber, byte 2-5 will be used for timestampe */
+#define WLFC_CTL_TRANS_ID_LEN			6
+
 #endif /* __wlfc_proto_definitions_h__ */
diff --git a/drivers/net/wireless/bcmdhd/include/wlioctl.h b/drivers/net/wireless/bcmdhd/include/wlioctl.h
old mode 100644
new mode 100755
index c25f794..d58cfb7
--- a/drivers/net/wireless/bcmdhd/include/wlioctl.h
+++ b/drivers/net/wireless/bcmdhd/include/wlioctl.h
@@ -4,7 +4,7 @@
  *
  * Definitions subject to change without notice.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
+ * Copyright (C) 1999-2013, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -24,7 +24,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: wlioctl.h 328096 2012-04-17 23:07:20Z $
+ * $Id: wlioctl.h 395294 2013-04-05 23:44:11Z $
  */
 
 #ifndef _wlioctl_h_
@@ -63,6 +63,12 @@ typedef struct remote_ioctl {
 } rem_ioctl_t;
 #define REMOTE_SIZE	sizeof(rem_ioctl_t)
 
+
+typedef struct {
+	uint32 num;
+	chanspec_t list[1];
+} chanspec_list_t;
+
 #define ACTION_FRAME_SIZE 1800
 
 typedef struct wl_action_frame {
@@ -209,8 +215,8 @@ typedef struct wl_bss_info {
 	uint32		nbss_cap;		/* 802.11N+AC BSS Capabilities */
 	uint8		ctl_ch;			/* 802.11N BSS control channel number */
 	uint8		padding1[3];		/* explicit struct alignment padding */
-	uint16		vht_rxmcsmap;		/* VHT rx mcs map */
-	uint16		vht_txmcsmap;		/* VHT tx mcs map */
+	uint16		vht_rxmcsmap;		/* VHT rx mcs map (802.11ac VHT_CAP_MCS_MAP_*) */
+	uint16		vht_txmcsmap;		/* VHT tx mcs map (802.11ac VHT_CAP_MCS_MAP_*) */
 	uint8		flags;			/* flags */
 	uint8		vht_cap;		/* BSS is vht capable */
 	uint8		reserved[2];		/* Reserved for expansion of BSS properties */
@@ -304,7 +310,7 @@ typedef struct wl_clm_dload_info wl_clm_dload_info_t;
 
 typedef struct wlc_ssid {
 	uint32		SSID_len;
-	uchar		SSID[32];
+	uchar		SSID[DOT11_MAX_SSID_LEN];
 } wlc_ssid_t;
 
 #ifndef LINUX_POSTMOGRIFY_REMOVAL
@@ -358,6 +364,8 @@ typedef struct wl_extdscan_params {
 #define WL_SCANFLAGS_PASSIVE	0x01	/* force passive scan */
 #define WL_SCANFLAGS_RESERVED	0x02	/* Reserved */
 #define WL_SCANFLAGS_PROHIBITED	0x04	/* allow scanning prohibited channels */
+#define WL_SCANFLAGS_OFFCHAN	0x08	/* allow scanning/reporting off-channel APs */
+#define WL_SCANFLAGS_HOTSPOT	0x10	/* automatic ANQP to hotspot APs */
 
 #define WL_SCAN_PARAMS_SSID_MAX 	10
 
@@ -441,19 +449,6 @@ typedef struct wl_scan_results {
 /* Used in EXT_STA */
 #define DNGL_RXCTXT_SIZE	45
 
-#if defined(SIMPLE_ISCAN)
-#define ISCAN_RETRY_CNT   5
-#define ISCAN_STATE_IDLE   0
-#define ISCAN_STATE_SCANING 1
-#define ISCAN_STATE_PENDING 2
-
-/* the buf lengh can be WLC_IOCTL_MAXLEN (8K) to reduce iteration */
-#define WLC_IW_ISCAN_MAXLEN   2048
-typedef struct iscan_buf {
-	struct iscan_buf * next;
-	char   iscan_buf[WLC_IW_ISCAN_MAXLEN];
-} iscan_buf_t;
-#endif /* SIMPLE_ISCAN */
 
 #define ESCAN_REQ_VERSION 1
 
@@ -503,6 +498,7 @@ typedef struct wl_rateset_args {
 	uint32	count;			/* # rates in this set */
 	uint8	rates[WL_MAXRATES_IN_SET];	/* rates in 500kbps units w/hi bit set if basic */
 	uint8   mcs[MCSSET_LEN];        /* supported mcs index bit map */
+	uint16 vht_mcs[VHT_CAP_MCS_MAP_NSS_MAX]; /* supported mcs index bit map per nss */
 } wl_rateset_args_t;
 
 /* uint32 list */
@@ -516,6 +512,10 @@ typedef struct wl_uint32_list {
 /* used for association with a specific BSSID and chanspec list */
 typedef struct wl_assoc_params {
 	struct ether_addr bssid;	/* 00:00:00:00:00:00: broadcast scan */
+	uint16 bssid_cnt;		/* 0: use chanspec_num, and the single bssid,
+					 * otherwise count of chanspecs in chanspec_list
+					 * AND paired bssids following chanspec_list
+					 */
 	int32 chanspec_num;		/* 0: all available channels,
 					 * otherwise count of chanspecs in chanspec_list
 					 */
@@ -604,6 +604,7 @@ typedef struct wl_extjoin_params {
 #define WL_RSPEC_BW_MASK        0x00070000      /* bandwidth mask */
 #define WL_RSPEC_BW_SHIFT       16              /* bandwidth shift */
 #define WL_RSPEC_STBC           0x00100000      /* STBC encoding, Nsts = 2 x Nss */
+#define WL_RSPEC_TXBF           0x00200000      /* bit indicates TXBF mode */
 #define WL_RSPEC_LDPC           0x00400000      /* bit indicates adv coding in use */
 #define WL_RSPEC_SGI            0x00800000      /* Short GI mode */
 #define WL_RSPEC_ENCODING_MASK  0x03000000      /* Encoding of Rate/MCS field */
@@ -822,6 +823,29 @@ typedef struct wl_rm_rep {
 } wl_rm_rep_t;
 #define WL_RM_REP_FIXED_LEN	8
 
+#ifdef BCMCCX
+
+#define LEAP_USER_MAX		32
+#define LEAP_DOMAIN_MAX		32
+#define LEAP_PASSWORD_MAX	32
+
+typedef struct wl_leap_info {
+	wlc_ssid_t ssid;
+	uint8 user_len;
+	uchar user[LEAP_USER_MAX];
+	uint8 password_len;
+	uchar password[LEAP_PASSWORD_MAX];
+	uint8 domain_len;
+	uchar domain[LEAP_DOMAIN_MAX];
+} wl_leap_info_t;
+
+typedef struct wl_leap_list {
+	uint32 buflen;
+	uint32 version;
+	uint32 count;
+	wl_leap_info_t leap_info[1];
+} wl_leap_list_t;
+#endif	/* BCMCCX */
 
 typedef enum sup_auth_status {
 	/* Basic supplicant authentication states */
@@ -856,11 +880,19 @@ typedef enum sup_auth_status {
 #define CRYPTO_ALGO_AES_CCM		4
 #define CRYPTO_ALGO_AES_OCB_MSDU	5
 #define CRYPTO_ALGO_AES_OCB_MPDU	6
+#if !defined(BCMCCX) && !defined(BCMEXTCCX)
 #define CRYPTO_ALGO_NALG		7
+#else
+#define CRYPTO_ALGO_CKIP		7
+#define CRYPTO_ALGO_CKIP_MMH		8
+#define CRYPTO_ALGO_WEP_MMH		9
+#define CRYPTO_ALGO_NALG		10
+#endif /* !BCMCCX && !BCMEXTCCX */
 #ifdef BCMWAPI_WPI
 #define CRYPTO_ALGO_SMS4		11
 #endif /* BCMWAPI_WPI */
 #define CRYPTO_ALGO_PMK			12	/* for 802.1x supp to set PMK before 4-way */
+#define CRYPTO_ALGO_BIP			13  /* 802.11w BIP (aes cmac) */
 
 #define WSEC_GEN_MIC_ERROR	0x0001
 #define WSEC_GEN_REPLAY		0x0002
@@ -871,8 +903,13 @@ typedef enum sup_auth_status {
 
 #define WL_SOFT_KEY	(1 << 0)	/* Indicates this key is using soft encrypt */
 #define WL_PRIMARY_KEY	(1 << 1)	/* Indicates this key is the primary (ie tx) key */
+#if defined(BCMCCX) || defined(BCMEXTCCX)
+#define WL_CKIP_KP	(1 << 4)	/* CMIC */
+#define WL_CKIP_MMH	(1 << 5)	/* CKIP */
+#else
 #define WL_KF_RES_4	(1 << 4)	/* Reserved for backward compat */
 #define WL_KF_RES_5	(1 << 5)	/* Reserved for backward compat */
+#endif /* BCMCCX || BCMEXTCCX */
 #define WL_IBSS_PEER_GROUP_KEY	(1 << 6)	/* Indicates a group key for a IBSS PEER */
 
 typedef struct wl_wsec_key {
@@ -913,6 +950,10 @@ typedef struct {
 #define TKIP_ENABLED		0x0002
 #define AES_ENABLED		0x0004
 #define WSEC_SWFLAG		0x0008
+#ifdef BCMCCX
+#define CKIP_KP_ENABLED		0x0010
+#define CKIP_MIC_ENABLED	0x0020
+#endif /* BCMCCX */
 #define SES_OW_ENABLED		0x0040	/* to go into transition mode without setting wep */
 #ifdef BCMWAPI_WPI
 #define SMS4_ENABLED		0x0100
@@ -923,27 +964,45 @@ typedef struct {
 #define WSEC_TKIP_ENABLED(wsec)	((wsec) & TKIP_ENABLED)
 #define WSEC_AES_ENABLED(wsec)	((wsec) & AES_ENABLED)
 
+#ifdef BCMCCX
+#define WSEC_CKIP_KP_ENABLED(wsec)	((wsec) & CKIP_KP_ENABLED)
+#define WSEC_CKIP_MIC_ENABLED(wsec)	((wsec) & CKIP_MIC_ENABLED)
+#define WSEC_CKIP_ENABLED(wsec)	((wsec) & (CKIP_KP_ENABLED|CKIP_MIC_ENABLED))
+
+#ifdef BCMWAPI_WPI
+#define WSEC_ENABLED(wsec) \
+	((wsec) & (WEP_ENABLED | TKIP_ENABLED | AES_ENABLED | CKIP_KP_ENABLED |	\
+	  CKIP_MIC_ENABLED | SMS4_ENABLED))
+#else /* BCMWAPI_WPI */
+#define WSEC_ENABLED(wsec) \
+		((wsec) & \
+		 (WEP_ENABLED | TKIP_ENABLED | AES_ENABLED | CKIP_KP_ENABLED | CKIP_MIC_ENABLED))
+#endif /* BCMWAPI_WPI */
+#else /* defined BCMCCX */
 #ifdef BCMWAPI_WPI
 #define WSEC_ENABLED(wsec)	((wsec) & (WEP_ENABLED | TKIP_ENABLED | AES_ENABLED | SMS4_ENABLED))
 #else /* BCMWAPI_WPI */
 #define WSEC_ENABLED(wsec)	((wsec) & (WEP_ENABLED | TKIP_ENABLED | AES_ENABLED))
 #endif /* BCMWAPI_WPI */
+#endif /* BCMCCX */
 #define WSEC_SES_OW_ENABLED(wsec)	((wsec) & SES_OW_ENABLED)
 #ifdef BCMWAPI_WAI
 #define WSEC_SMS4_ENABLED(wsec)	((wsec) & SMS4_ENABLED)
 #endif /* BCMWAPI_WAI */
 
-#ifdef MFP
 #define MFP_CAPABLE		0x0200
 #define MFP_REQUIRED	0x0400
 #define MFP_SHA256		0x0800 /* a special configuration for STA for WIFI test tool */
-#endif /* MFP */
 
 /* WPA authentication mode bitvec */
 #define WPA_AUTH_DISABLED	0x0000	/* Legacy (i.e., non-WPA) */
 #define WPA_AUTH_NONE		0x0001	/* none (IBSS) */
 #define WPA_AUTH_UNSPECIFIED	0x0002	/* over 802.1x */
 #define WPA_AUTH_PSK		0x0004	/* Pre-shared key */
+#if defined(BCMCCX) || defined(BCMEXTCCX)
+#define WPA_AUTH_CCKM		0x0008	/* CCKM */
+#define WPA2_AUTH_CCKM		0x0010	/* CCKM2 */
+#endif	/* BCMCCX || BCMEXTCCX */
 /* #define WPA_AUTH_8021X 0x0020 */	/* 802.1x, reserved */
 #define WPA2_AUTH_UNSPECIFIED	0x0040	/* over 802.1x */
 #define WPA2_AUTH_PSK		0x0080	/* Pre-shared key */
@@ -1058,6 +1117,32 @@ typedef struct wme_tx_params_s wme_tx_params_t;
 
 #define WL_WME_TX_PARAMS_IO_BYTES (sizeof(wme_tx_params_t) * AC_COUNT)
 
+typedef struct wl_plc_nodelist {
+	uint count;			/* Number of nodes */
+	struct _node {
+		struct ether_addr ea;	/* Node ether address */
+		uint32 node_type;	/* Node type */
+		uint32 cost;		/* PLC affinity */
+	} node[1];
+} wl_plc_nodelist_t;
+
+typedef struct wl_plc_params {
+	uint32	cmd;			/* Command */
+	bool	plc_failover;		/* PLC failover control/status */
+	struct	ether_addr node_ea;	/* Node ether address */
+	uint32	cost;			/* Link cost or mac cost */
+} wl_plc_params_t;
+
+#define	PLC_CMD_FAILOVER	1
+#define	PLC_CMD_MAC_COST	2
+#define	PLC_CMD_LINK_COST	3
+#define	PLC_CMD_NODE_LIST	4
+
+#define NODE_TYPE_UNKNOWN	0	/* Unknown link */
+#define NODE_TYPE_WIFI_ONLY	1	/* Pure Wireless STA node */
+#define NODE_TYPE_PLC_ONLY	2	/* Pure PLC only node */
+#define NODE_TYPE_WIFI_PLC	3	/* WiFi PLC capable node */
+
 /* defines used by poweridx iovar - it controls power in a-band */
 /* current gain setting is maintained */
 #define WL_PWRIDX_PCL_OFF	-2	/* turn off PCL.  */
@@ -1203,7 +1288,7 @@ typedef struct {
 
 /* Get MAC rate histogram response */
 typedef struct {
-	uint32	rate[WLC_MAXRATE + 1];	/* Rates */
+	uint32	rate[DOT11_RATE_MAX + 1];	/* Rates */
 	uint32	mcs[WL_RATESET_SZ_HT_MCS * WL_TX_CHAINS_MAX];	/* MCS counts */
 	uint32	vht[WL_RATESET_SZ_VHT_MCS][WL_TX_CHAINS_MAX];	/* VHT counts */
 	uint32	tsf_timer[2][2];	/* Start and End time for 8bytes value */
@@ -1261,6 +1346,7 @@ typedef struct wlc_rev_info {
 	uint		phyrev;		/* phy revision */
 	uint		anarev;		/* anacore rev */
 	uint		chippkg;	/* chip package info */
+	uint		nvramrev;	/* nvram revision number */
 } wlc_rev_info_t;
 
 #define WL_REV_INFO_LEGACY_LENGTH	48
@@ -1594,7 +1680,9 @@ typedef struct wlc_iov_trx_s {
 #define WLC_NVRAM_SET				265
 #define WLC_NVRAM_DUMP				266
 #define WLC_REBOOT				267
+#endif /* LINUX_POSTMOGRIFY_REMOVAL */
 #define WLC_SET_WSEC_PMK			268
+#ifndef LINUX_POSTMOGRIFY_REMOVAL
 #define WLC_GET_AUTH_MODE			269
 #define WLC_SET_AUTH_MODE			270
 #define WLC_GET_WAKEENTRY			271
@@ -1644,7 +1732,8 @@ typedef struct wlc_iov_trx_s {
 /* #define WLC_SET_WAI_REKEY			315 */	/* for WAPI, deprecated use iovar instead */
 #define WLC_SET_NAT_CONFIG			316	/* for configuring NAT filter driver */
 #define WLC_GET_NAT_STATE			317
-#define WLC_LAST				318
+#define WLC_GET_RSSI_QDB			318 /* qdB portion of the RSSI */
+#define WLC_LAST				319
 
 #ifndef EPICTRL_COOKIE
 #define EPICTRL_COOKIE		0xABADCEDE
@@ -1715,7 +1804,9 @@ typedef struct {
 /* WLC_GET_AUTH, WLC_SET_AUTH values */
 #define WL_AUTH_OPEN_SYSTEM		0	/* d11 open authentication */
 #define WL_AUTH_SHARED_KEY		1	/* d11 shared authentication */
-#define WL_AUTH_OPEN_SHARED     	2   /* try open, then shared if open failed w/rc 13 */
+ /* try open, then shared if open failed w/rc 13 */
+
+#define WL_AUTH_OPEN_SHARED		3	/* try open, then shared if open failed w/rc 13 */
 #endif /* LINUX_POSTMOGRIFY_REMOVAL */
 
 /* Bit masks for radio disabled status - returned by WL_GET_RADIO */
@@ -1728,6 +1819,17 @@ typedef struct {
 #define	WL_SPURAVOID_ON1	1
 #define	WL_SPURAVOID_ON2	2
 
+
+#define WL_4335_SPURAVOID_ON1	1
+#define WL_4335_SPURAVOID_ON2	2
+#define WL_4335_SPURAVOID_ON3	3
+#define WL_4335_SPURAVOID_ON4	4
+#define WL_4335_SPURAVOID_ON5	5
+#define WL_4335_SPURAVOID_ON6	6
+#define WL_4335_SPURAVOID_ON7	7
+#define WL_4335_SPURAVOID_ON8	8
+#define WL_4335_SPURAVOID_ON9	9
+
 /* Override bit for WLC_SET_TXPWR.  if set, ignore other level limits */
 #define WL_TXPWR_OVERRIDE	(1U<<31)
 #define WL_TXPWR_NEG   (1U<<30)
@@ -1736,6 +1838,16 @@ typedef struct {
 #define WL_PHY_PAVARS_LEN	32	/* Phy type, Band range, chain, a1[0], b0[0], b1[0] ... */
 
 #define WL_PHY_PAVAR_VER	1	/* pavars version */
+#define WL_PHY_PAVARS2_NUM	3	/* a1, b0, b1 */
+typedef struct wl_pavars2 {
+	uint16 ver;		/* version of this struct */
+	uint16 len;		/* len of this structure */
+	uint16 inuse;		/* driver return 1 for a1,b0,b1 in current band range */
+	uint16 phy_type;	/* phy type */
+	uint16 bandrange;
+	uint16 chain;
+	uint16 inpa[WL_PHY_PAVARS2_NUM];	/* phy pavars for one band range */
+} wl_pavars2_t;
 
 typedef struct wl_po {
 	uint16	phy_type;	/* Phy type */
@@ -1787,6 +1899,12 @@ typedef struct wl_po {
 #define WL_CHAN_FREQ_RANGE_5GM     2
 #define WL_CHAN_FREQ_RANGE_5GH     3
 
+#define WL_CHAN_FREQ_RANGE_5GLL_5BAND    4
+#define WL_CHAN_FREQ_RANGE_5GLH_5BAND    5
+#define WL_CHAN_FREQ_RANGE_5GML_5BAND    6
+#define WL_CHAN_FREQ_RANGE_5GMH_5BAND    7
+#define WL_CHAN_FREQ_RANGE_5GH_5BAND     8
+
 #define WL_CHAN_FREQ_RANGE_5G_BAND0     1
 #define WL_CHAN_FREQ_RANGE_5G_BAND1     2
 #define WL_CHAN_FREQ_RANGE_5G_BAND2     3
@@ -1923,6 +2041,12 @@ typedef struct wl_po {
 #define	WLAN_AUTO_W_NOISE	4	/* ACI: auto - detect and non 802.11 interference */
 #define AUTO_ACTIVE	(1 << 7) /* Auto is currently active */
 
+/* AP environment */
+#define AP_ENV_DETECT_NOT_USED		0 /* We aren't using AP environment detection */
+#define AP_ENV_DENSE			1 /* "Corporate" or other AP dense environment */
+#define AP_ENV_SPARSE			2 /* "Home" or other sparse environment */
+#define AP_ENV_INDETERMINATE		3 /* AP environment hasn't been identified */
+
 typedef struct wl_aci_args {
 	int enter_aci_thresh; /* Trigger level to start detecting ACI */
 	int exit_aci_thresh; /* Trigger level to exit ACI mode */
@@ -1981,6 +2105,8 @@ typedef struct wl_samplecollect_args {
 	uint8 module_sel1;
 	uint8 module_sel2;
 	uint16 nsamps;
+	int bitStart;
+	uint32 gpioCapMask;
 } wl_samplecollect_args_t;
 
 #define	WL_SAMPLEDATA_HEADER_TYPE	1
@@ -2000,6 +2126,117 @@ typedef struct wl_sampledata {
 	uint32 flag;	/* bit def */
 } wl_sampledata_t;
 
+/* WL_OTA START */
+
+#define WL_OTA_ARG_PARSE_BLK_SIZE 	1200
+#define WL_OTA_TEST_MAX_NUM_RATE	30
+#define WL_OTA_TEST_MAX_NUM_SEQ		100
+
+/* OTA Test Status */
+enum {
+	WL_OTA_TEST_IDLE,	/* Default Idle state */
+	WL_OTA_TEST_ACTIVE,	/* Test Running */
+	WL_OTA_TEST_SUCCESS,	/* Successfully Finished Test */
+	WL_OTA_TEST_FAIL	/* Test Failed in the Middle */
+};
+/* OTA SYNC Status */
+enum {
+	WL_OTA_SYNC_IDLE,	/* Idle state */
+	WL_OTA_SYNC_ACTIVE,	/* Waiting for Sync */
+	WL_OTA_SYNC_FAIL	/* Sync pkt not recieved */
+};
+
+/* Various error states dut can get stuck during test */
+enum {
+	WL_OTA_SKIP_TEST_CAL_FAIL = 1,		/* Phy calibration failed */
+	WL_OTA_SKIP_TEST_SYNCH_FAIL,		/* Sync Packet not recieved */
+	WL_OTA_SKIP_TEST_FILE_DWNLD_FAIL,	/* Cmd flow file download failed */
+	WL_OTA_SKIP_TEST_NO_TEST_FOUND,	/* No test found in Flow file */
+	WL_OTA_SKIP_TEST_WL_NOT_UP,		/* WL UP failed */
+	WL_OTA_SKIP_TEST_UNKNOWN_CALL		/* Unintentional scheduling on ota test */
+};
+
+/* Differentiator for ota_tx and ota_rx */
+enum {
+	WL_OTA_TEST_TX,		/* ota_tx */
+	WL_OTA_TEST_RX		/* ota_rx */
+};
+
+/* Catch 3 modes of operation: 20Mhz, 40Mhz, 20 in 40 Mhz */
+enum {
+	WL_OTA_TEST_BW_20_IN_40MHZ,	/* 20 in 40 operation */
+	WL_OTA_TEST_BW_20MHZ,		/* 20 Mhz operation */
+	WL_OTA_TEST_BW_40MHZ		/* full 40Mhz operation */
+};
+typedef struct ota_rate_info {
+	uint8 rate_cnt;					/* Total number of rates */
+	uint8 rate_val_mbps[WL_OTA_TEST_MAX_NUM_RATE];	/* array of rates from 1mbps to 130mbps */
+							/* for legacy rates : ratein mbps * 2 */
+							/* for HT rates : mcs index */
+} ota_rate_info_t;
+
+typedef struct ota_power_info {
+	int8 pwr_ctrl_on;	/* power control on/off */
+	int8 start_pwr;		/* starting power/index */
+	int8 delta_pwr;		/* delta power/index */
+	int8 end_pwr;		/* end power/index */
+} ota_power_info_t;
+
+typedef struct ota_packetengine {
+	uint16 delay;           /* Inter-packet delay */
+				/* for ota_tx, delay is tx ifs in micro seconds */
+				/* for ota_rx, delay is wait time in milliseconds */
+	uint16 nframes;         /* Number of frames */
+	uint16 length;          /* Packet length */
+} ota_packetengine_t;
+
+/* Test info vector */
+typedef struct wl_ota_test_args {
+	uint8 cur_test;			/* test phase */
+	uint8 chan;			/* channel */
+	uint8 bw;			/* bandwidth */
+	char control_band;		/* control band */
+	uint8 stf_mode;			/* stf mode */
+	ota_rate_info_t rt_info;	/* Rate info */
+	ota_packetengine_t pkteng;	/* packeteng info */
+	uint8 txant;			/* tx antenna */
+	uint8 rxant;			/* rx antenna */
+	ota_power_info_t pwr_info;	/* power sweep info */
+	uint8 wait_for_sync;		/* wait for sync or not */
+} wl_ota_test_args_t;
+
+typedef struct wl_ota_test_vector {
+	wl_ota_test_args_t test_arg[WL_OTA_TEST_MAX_NUM_SEQ];	/* Test argument struct */
+	uint16 test_cnt;					/* Total no of test */
+	bool file_dwnld_valid;					/* File successfully downloaded */
+	uint8 sync_timeout;					/* sync packet timeout */
+	int8 sync_fail_action;					/* sync fail action */
+	struct ether_addr sync_mac;				/* macaddress for sync pkt */
+	struct ether_addr tx_mac;				/* macaddress for tx */
+	struct ether_addr rx_mac;				/* macaddress for rx */
+	int8 loop_test;					/* dbg feature to loop the test */
+} wl_ota_test_vector_t;
+
+
+/* struct copied back form dongle to host to query the status */
+typedef struct wl_ota_test_status {
+	int16 cur_test_cnt;		/* test phase */
+	int8 skip_test_reason;		/* skip test reasoin */
+	wl_ota_test_args_t test_arg;	/* cur test arg details */
+	uint16 test_cnt;		/* total no of test downloaded */
+	bool file_dwnld_valid;		/* file successfully downloaded ? */
+	uint8 sync_timeout;		/* sync timeout */
+	int8 sync_fail_action;		/* sync fail action */
+	struct ether_addr sync_mac;	/* macaddress for sync pkt */
+	struct ether_addr tx_mac;	/* tx mac address */
+	struct ether_addr rx_mac;	/* rx mac address */
+	uint8  test_stage;		/* check the test status */
+	int8 loop_test;		/* Debug feature to puts test enfine in a loop */
+	uint8 sync_status;		/* sync status */
+} wl_ota_test_status_t;
+
+/* WL_OTA END */
+
 /* wl_radar_args_t */
 typedef struct {
 	int npulses; 	/* required number of pulses at n * t_int */
@@ -2179,168 +2416,168 @@ typedef struct {
 
 typedef struct txppr {
 	/* start of 20MHz tx power limits */
-	uint8 b20_1x1dsss[WL_NUM_RATES_CCK];		/* Legacy CCK/DSSS */
-	uint8 b20_1x1ofdm[WL_NUM_RATES_OFDM];		/* Legacy OFDM transmission */
-	uint8 b20_1x1mcs0[WL_NUM_RATES_MCS_1STREAM];		/* SISO MCS 0-7 */
-
-	uint8 b20_1x2dsss[WL_NUM_RATES_CCK];		/* Legacy CCK/DSSS */
-	uint8 b20_1x2cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
-	uint8 b20_1x2cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* CDD MCS 0-7 */
-	uint8 b20_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
-	uint8 b20_2x2sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* MCS 8-15 */
-
-	uint8 b20_1x3dsss[WL_NUM_RATES_CCK];		/* Legacy CCK/DSSS */
-	uint8 b20_1x3cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
-	uint8 b20_1x3cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* 1 Nsts to 3 Tx Chain */
-	uint8 b20_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
-	uint8 b20_2x3sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* 2 Nsts to 3 Tx Chain */
-	uint8 b20_3x3sdm_mcs16[WL_NUM_RATES_MCS_1STREAM];	/* 3 Nsts to 3 Tx Chain */
-
-	uint8 b20_1x1vht[WL_NUM_RATES_EXTRA_VHT];		/* VHT8_9SS1 */
-	uint8 b20_1x2cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD1 */
-	uint8 b20_2x2stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC */
-	uint8 b20_2x2sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2 */
-	uint8 b20_1x3cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD2 */
-	uint8 b20_2x3stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC_SPEXP1 */
-	uint8 b20_2x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2_SPEXP1 */
-	uint8 b20_3x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS3 */
+	int8 b20_1x1dsss[WL_NUM_RATES_CCK];		/* Legacy CCK/DSSS */
+	int8 b20_1x1ofdm[WL_NUM_RATES_OFDM];		/* Legacy OFDM transmission */
+	int8 b20_1x1mcs0[WL_NUM_RATES_MCS_1STREAM];		/* SISO MCS 0-7 */
+
+	int8 b20_1x2dsss[WL_NUM_RATES_CCK];		/* Legacy CCK/DSSS */
+	int8 b20_1x2cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
+	int8 b20_1x2cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* CDD MCS 0-7 */
+	int8 b20_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
+	int8 b20_2x2sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* MCS 8-15 */
+
+	int8 b20_1x3dsss[WL_NUM_RATES_CCK];		/* Legacy CCK/DSSS */
+	int8 b20_1x3cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
+	int8 b20_1x3cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* 1 Nsts to 3 Tx Chain */
+	int8 b20_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
+	int8 b20_2x3sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* 2 Nsts to 3 Tx Chain */
+	int8 b20_3x3sdm_mcs16[WL_NUM_RATES_MCS_1STREAM];	/* 3 Nsts to 3 Tx Chain */
+
+	int8 b20_1x1vht[WL_NUM_RATES_EXTRA_VHT];		/* VHT8_9SS1 */
+	int8 b20_1x2cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD1 */
+	int8 b20_2x2stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC */
+	int8 b20_2x2sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2 */
+	int8 b20_1x3cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD2 */
+	int8 b20_2x3stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC_SPEXP1 */
+	int8 b20_2x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2_SPEXP1 */
+	int8 b20_3x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS3 */
 
 	/* start of 40MHz tx power limits */
-	uint8 b40_dummy1x1dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
-	uint8 b40_1x1ofdm[WL_NUM_RATES_OFDM];		/* Legacy OFDM transmission */
-	uint8 b40_1x1mcs0[WL_NUM_RATES_MCS_1STREAM];		/* SISO MCS 0-7 */
-
-	uint8 b40_dummy1x2dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
-	uint8 b40_1x2cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
-	uint8 b40_1x2cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* CDD MCS 0-7 */
-	uint8 b40_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
-	uint8 b40_2x2sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* MCS 8-15 */
-
-	uint8 b40_dummy1x3dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
-	uint8 b40_1x3cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
-	uint8 b40_1x3cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* 1 Nsts to 3 Tx Chain */
-	uint8 b40_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
-	uint8 b40_2x3sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* 2 Nsts to 3 Tx Chain */
-	uint8 b40_3x3sdm_mcs16[WL_NUM_RATES_MCS_1STREAM];	/* 3 Nsts to 3 Tx Chain */
-
-	uint8 b40_1x1vht[WL_NUM_RATES_EXTRA_VHT];		/* VHT8_9SS1 */
-	uint8 b40_1x2cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD1 */
-	uint8 b40_2x2stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC */
-	uint8 b40_2x2sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2 */
-	uint8 b40_1x3cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD2 */
-	uint8 b40_2x3stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC_SPEXP1 */
-	uint8 b40_2x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2_SPEXP1 */
-	uint8 b40_3x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS3 */
+	int8 b40_dummy1x1dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
+	int8 b40_1x1ofdm[WL_NUM_RATES_OFDM];		/* Legacy OFDM transmission */
+	int8 b40_1x1mcs0[WL_NUM_RATES_MCS_1STREAM];		/* SISO MCS 0-7 */
+
+	int8 b40_dummy1x2dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
+	int8 b40_1x2cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
+	int8 b40_1x2cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* CDD MCS 0-7 */
+	int8 b40_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
+	int8 b40_2x2sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* MCS 8-15 */
+
+	int8 b40_dummy1x3dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
+	int8 b40_1x3cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
+	int8 b40_1x3cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* 1 Nsts to 3 Tx Chain */
+	int8 b40_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
+	int8 b40_2x3sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* 2 Nsts to 3 Tx Chain */
+	int8 b40_3x3sdm_mcs16[WL_NUM_RATES_MCS_1STREAM];	/* 3 Nsts to 3 Tx Chain */
+
+	int8 b40_1x1vht[WL_NUM_RATES_EXTRA_VHT];		/* VHT8_9SS1 */
+	int8 b40_1x2cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD1 */
+	int8 b40_2x2stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC */
+	int8 b40_2x2sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2 */
+	int8 b40_1x3cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD2 */
+	int8 b40_2x3stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC_SPEXP1 */
+	int8 b40_2x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2_SPEXP1 */
+	int8 b40_3x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS3 */
 
 	/* start of 20in40MHz tx power limits */
-	uint8 b20in40_1x1dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
-	uint8 b20in40_1x1ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM transmission */
-	uint8 b20in40_1x1mcs0[WL_NUM_RATES_MCS_1STREAM];	/* SISO MCS 0-7 */
-
-	uint8 b20in40_1x2dsss[WL_NUM_RATES_CCK];		/* Legacy CCK/DSSS */
-	uint8 b20in40_1x2cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
-	uint8 b20in40_1x2cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* CDD MCS 0-7 */
-	uint8 b20in40_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
-	uint8 b20in40_2x2sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* MCS 8-15 */
-
-	uint8 b20in40_1x3dsss[WL_NUM_RATES_CCK];		/* Legacy CCK/DSSS */
-	uint8 b20in40_1x3cdd_ofdm[WL_NUM_RATES_OFDM];	/* 20 in 40 MHz Legacy OFDM CDD */
-	uint8 b20in40_1x3cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* 1 Nsts to 3 Tx Chain */
-	uint8 b20in40_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
-	uint8 b20in40_2x3sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* 2 Nsts to 3 Tx Chain */
-	uint8 b20in40_3x3sdm_mcs16[WL_NUM_RATES_MCS_1STREAM];	/* 3 Nsts to 3 Tx Chain */
-
-	uint8 b20in40_1x1vht[WL_NUM_RATES_EXTRA_VHT];		/* VHT8_9SS1 */
-	uint8 b20in40_1x2cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD1 */
-	uint8 b20in40_2x2stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC */
-	uint8 b20in40_2x2sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2 */
-	uint8 b20in40_1x3cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD2 */
-	uint8 b20in40_2x3stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC_SPEXP1 */
-	uint8 b20in40_2x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2_SPEXP1 */
-	uint8 b20in40_3x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS3 */
+	int8 b20in40_1x1dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
+	int8 b20in40_1x1ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM transmission */
+	int8 b20in40_1x1mcs0[WL_NUM_RATES_MCS_1STREAM];	/* SISO MCS 0-7 */
+
+	int8 b20in40_1x2dsss[WL_NUM_RATES_CCK];		/* Legacy CCK/DSSS */
+	int8 b20in40_1x2cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
+	int8 b20in40_1x2cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* CDD MCS 0-7 */
+	int8 b20in40_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
+	int8 b20in40_2x2sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* MCS 8-15 */
+
+	int8 b20in40_1x3dsss[WL_NUM_RATES_CCK];		/* Legacy CCK/DSSS */
+	int8 b20in40_1x3cdd_ofdm[WL_NUM_RATES_OFDM];	/* 20 in 40 MHz Legacy OFDM CDD */
+	int8 b20in40_1x3cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* 1 Nsts to 3 Tx Chain */
+	int8 b20in40_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
+	int8 b20in40_2x3sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* 2 Nsts to 3 Tx Chain */
+	int8 b20in40_3x3sdm_mcs16[WL_NUM_RATES_MCS_1STREAM];	/* 3 Nsts to 3 Tx Chain */
+
+	int8 b20in40_1x1vht[WL_NUM_RATES_EXTRA_VHT];		/* VHT8_9SS1 */
+	int8 b20in40_1x2cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD1 */
+	int8 b20in40_2x2stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC */
+	int8 b20in40_2x2sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2 */
+	int8 b20in40_1x3cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD2 */
+	int8 b20in40_2x3stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC_SPEXP1 */
+	int8 b20in40_2x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2_SPEXP1 */
+	int8 b20in40_3x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS3 */
 
 	/* start of 80MHz tx power limits */
-	uint8 b80_dummy1x1dsss[WL_NUM_RATES_CCK];		/* Legacy CCK/DSSS */
-	uint8 b80_1x1ofdm[WL_NUM_RATES_OFDM];			/* Legacy OFDM transmission */
-	uint8 b80_1x1mcs0[WL_NUM_RATES_MCS_1STREAM];	/* SISO MCS 0-7 */
-
-	uint8 b80_dummy1x2dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
-	uint8 b80_1x2cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
-	uint8 b80_1x2cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* CDD MCS 0-7 */
-	uint8 b80_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
-	uint8 b80_2x2sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* MCS 8-15 */
-
-	uint8 b80_dummy1x3dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
-	uint8 b80_1x3cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
-	uint8 b80_1x3cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* 1 Nsts to 3 Tx Chain */
-	uint8 b80_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
-	uint8 b80_2x3sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* 2 Nsts to 3 Tx Chain */
-	uint8 b80_3x3sdm_mcs16[WL_NUM_RATES_MCS_1STREAM];	/* 3 Nsts to 3 Tx Chain */
-
-	uint8 b80_1x1vht[WL_NUM_RATES_EXTRA_VHT];		/* VHT8_9SS1 */
-	uint8 b80_1x2cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD1 */
-	uint8 b80_2x2stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC */
-	uint8 b80_2x2sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2 */
-	uint8 b80_1x3cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD2 */
-	uint8 b80_2x3stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC_SPEXP1 */
-	uint8 b80_2x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2_SPEXP1 */
-	uint8 b80_3x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS3 */
+	int8 b80_dummy1x1dsss[WL_NUM_RATES_CCK];		/* Legacy CCK/DSSS */
+	int8 b80_1x1ofdm[WL_NUM_RATES_OFDM];			/* Legacy OFDM transmission */
+	int8 b80_1x1mcs0[WL_NUM_RATES_MCS_1STREAM];	/* SISO MCS 0-7 */
+
+	int8 b80_dummy1x2dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
+	int8 b80_1x2cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
+	int8 b80_1x2cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* CDD MCS 0-7 */
+	int8 b80_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
+	int8 b80_2x2sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* MCS 8-15 */
+
+	int8 b80_dummy1x3dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
+	int8 b80_1x3cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
+	int8 b80_1x3cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* 1 Nsts to 3 Tx Chain */
+	int8 b80_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
+	int8 b80_2x3sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* 2 Nsts to 3 Tx Chain */
+	int8 b80_3x3sdm_mcs16[WL_NUM_RATES_MCS_1STREAM];	/* 3 Nsts to 3 Tx Chain */
+
+	int8 b80_1x1vht[WL_NUM_RATES_EXTRA_VHT];		/* VHT8_9SS1 */
+	int8 b80_1x2cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD1 */
+	int8 b80_2x2stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC */
+	int8 b80_2x2sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2 */
+	int8 b80_1x3cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD2 */
+	int8 b80_2x3stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC_SPEXP1 */
+	int8 b80_2x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2_SPEXP1 */
+	int8 b80_3x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS3 */
 
 	/* start of 20in80MHz tx power limits */
-	uint8 b20in80_1x1dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
-	uint8 b20in80_1x1ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM transmission */
-	uint8 b20in80_1x1mcs0[WL_NUM_RATES_MCS_1STREAM];	/* SISO MCS 0-7 */
-
-	uint8 b20in80_1x2dsss[WL_NUM_RATES_CCK];		/* Legacy CCK/DSSS */
-	uint8 b20in80_1x2cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
-	uint8 b20in80_1x2cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* CDD MCS 0-7 */
-	uint8 b20in80_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
-	uint8 b20in80_2x2sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* MCS 8-15 */
-
-	uint8 b20in80_1x3dsss[WL_NUM_RATES_CCK];		/* Legacy CCK/DSSS */
-	uint8 b20in80_1x3cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
-	uint8 b20in80_1x3cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* 1 Nsts to 3 Tx Chain */
-	uint8 b20in80_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
-	uint8 b20in80_2x3sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* 2 Nsts to 3 Tx Chain */
-	uint8 b20in80_3x3sdm_mcs16[WL_NUM_RATES_MCS_1STREAM];	/* 3 Nsts to 3 Tx Chain */
-
-	uint8 b20in80_1x1vht[WL_NUM_RATES_EXTRA_VHT];		/* VHT8_9SS1 */
-	uint8 b20in80_1x2cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD1 */
-	uint8 b20in80_2x2stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC */
-	uint8 b20in80_2x2sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2 */
-	uint8 b20in80_1x3cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD2 */
-	uint8 b20in80_2x3stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC_SPEXP1 */
-	uint8 b20in80_2x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2_SPEXP1 */
-	uint8 b20in80_3x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS3 */
+	int8 b20in80_1x1dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
+	int8 b20in80_1x1ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM transmission */
+	int8 b20in80_1x1mcs0[WL_NUM_RATES_MCS_1STREAM];	/* SISO MCS 0-7 */
+
+	int8 b20in80_1x2dsss[WL_NUM_RATES_CCK];		/* Legacy CCK/DSSS */
+	int8 b20in80_1x2cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
+	int8 b20in80_1x2cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* CDD MCS 0-7 */
+	int8 b20in80_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
+	int8 b20in80_2x2sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* MCS 8-15 */
+
+	int8 b20in80_1x3dsss[WL_NUM_RATES_CCK];		/* Legacy CCK/DSSS */
+	int8 b20in80_1x3cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
+	int8 b20in80_1x3cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* 1 Nsts to 3 Tx Chain */
+	int8 b20in80_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
+	int8 b20in80_2x3sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* 2 Nsts to 3 Tx Chain */
+	int8 b20in80_3x3sdm_mcs16[WL_NUM_RATES_MCS_1STREAM];	/* 3 Nsts to 3 Tx Chain */
+
+	int8 b20in80_1x1vht[WL_NUM_RATES_EXTRA_VHT];		/* VHT8_9SS1 */
+	int8 b20in80_1x2cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD1 */
+	int8 b20in80_2x2stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC */
+	int8 b20in80_2x2sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2 */
+	int8 b20in80_1x3cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD2 */
+	int8 b20in80_2x3stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC_SPEXP1 */
+	int8 b20in80_2x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2_SPEXP1 */
+	int8 b20in80_3x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS3 */
 
 	/* start of 40in80MHz tx power limits */
-	uint8 b40in80_dummy1x1dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
-	uint8 b40in80_1x1ofdm[WL_NUM_RATES_OFDM];		/* Legacy OFDM transmission */
-	uint8 b40in80_1x1mcs0[WL_NUM_RATES_MCS_1STREAM];	/* SISO MCS 0-7 */
-
-	uint8 b40in80_dummy1x2dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
-	uint8 b40in80_1x2cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
-	uint8 b40in80_1x2cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* CDD MCS 0-7 */
-	uint8 b40in80_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
-	uint8 b40in80_2x2sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* MCS 8-15 */
-
-	uint8 b40in80_dummy1x3dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
-	uint8 b40in80_1x3cdd_ofdm[WL_NUM_RATES_OFDM];	/* MHz Legacy OFDM CDD */
-	uint8 b40in80_1x3cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* 1 Nsts to 3 Tx Chain */
-	uint8 b40in80_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
-	uint8 b40in80_2x3sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* 2 Nsts to 3 Tx Chain */
-	uint8 b40in80_3x3sdm_mcs16[WL_NUM_RATES_MCS_1STREAM];	/* 3 Nsts to 3 Tx Chain */
-
-	uint8 b40in80_1x1vht[WL_NUM_RATES_EXTRA_VHT];		/* VHT8_9SS1 */
-	uint8 b40in80_1x2cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD1 */
-	uint8 b40in80_2x2stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC */
-	uint8 b40in80_2x2sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2 */
-	uint8 b40in80_1x3cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD2 */
-	uint8 b40in80_2x3stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC_SPEXP1 */
-	uint8 b40in80_2x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2_SPEXP1 */
-	uint8 b40in80_3x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS3 */
-
-	uint8 mcs32; /* C_CHECK - THIS NEEDS TO BE REMOVED THROUGHOUT THE CODE */
+	int8 b40in80_dummy1x1dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
+	int8 b40in80_1x1ofdm[WL_NUM_RATES_OFDM];		/* Legacy OFDM transmission */
+	int8 b40in80_1x1mcs0[WL_NUM_RATES_MCS_1STREAM];	/* SISO MCS 0-7 */
+
+	int8 b40in80_dummy1x2dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
+	int8 b40in80_1x2cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
+	int8 b40in80_1x2cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* CDD MCS 0-7 */
+	int8 b40in80_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
+	int8 b40in80_2x2sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* MCS 8-15 */
+
+	int8 b40in80_dummy1x3dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
+	int8 b40in80_1x3cdd_ofdm[WL_NUM_RATES_OFDM];	/* MHz Legacy OFDM CDD */
+	int8 b40in80_1x3cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* 1 Nsts to 3 Tx Chain */
+	int8 b40in80_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
+	int8 b40in80_2x3sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* 2 Nsts to 3 Tx Chain */
+	int8 b40in80_3x3sdm_mcs16[WL_NUM_RATES_MCS_1STREAM];	/* 3 Nsts to 3 Tx Chain */
+
+	int8 b40in80_1x1vht[WL_NUM_RATES_EXTRA_VHT];		/* VHT8_9SS1 */
+	int8 b40in80_1x2cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD1 */
+	int8 b40in80_2x2stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC */
+	int8 b40in80_2x2sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2 */
+	int8 b40in80_1x3cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD2 */
+	int8 b40in80_2x3stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC_SPEXP1 */
+	int8 b40in80_2x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2_SPEXP1 */
+	int8 b40in80_3x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS3 */
+
+	int8 mcs32; /* C_CHECK - THIS NEEDS TO BE REMOVED THROUGHOUT THE CODE */
 } txppr_t;
 
 /* 20MHz */
@@ -2522,45 +2759,35 @@ typedef struct txppr {
 #define WL_TX_POWER_MCS20_SISO_FIRST_SSN	WL_TX_POWER_MCS20_SISO_FIRST
 #define WL_TX_POWER_MCS40_SISO_FIRST_SSN	WL_TX_POWER_MCS40_SISO_FIRST
 
-/* tx_power_t.flags bits */
-#define WL_TX_POWER_F_ENABLED	1
-#define WL_TX_POWER_F_HW	2
-#define WL_TX_POWER_F_MIMO	4
-#define WL_TX_POWER_F_SISO	8
-#define WL_TX_POWER_F_HT	0x10
-
 typedef struct {
 	uint16 ver;				/* version of this struct */
 	uint16 len;				/* length in bytes of this structure */
 	uint32 flags;
 	chanspec_t chanspec;			/* txpwr report for this channel */
 	chanspec_t local_chanspec;		/* channel on which we are associated */
-	uint8 ppr[WL_TX_POWER_RATES];		/* Latest target power */
+	uint32 buflen;				/* ppr buffer length */
+	uint8      pprbuf[1];			/* Latest target power buffer */
 } wl_txppr_t;
 
 #define WL_TXPPR_VERSION	0
 #define WL_TXPPR_LENGTH	(sizeof(wl_txppr_t))
-#define TX_POWER_T_VERSION	43
+#define TX_POWER_T_VERSION	44
 
 /* Defines used with channel_bandwidth for curpower */
 #define WL_BW_20MHZ 		0
 #define WL_BW_40MHZ 		1
 #define WL_BW_80MHZ 		2
+#define WL_BW_160MHZ 		3
 
 /* tx_power_t.flags bits */
-#ifdef PPR_API
-#define WL_TX_POWER2_F_ENABLED	1
-#define WL_TX_POWER2_F_HW		2
-#define WL_TX_POWER2_F_MIMO		4
-#define WL_TX_POWER2_F_SISO		8
-#define WL_TX_POWER2_F_HT		0x10
-#else
+/* use for defined PPR_API */
 #define WL_TX_POWER_F_ENABLED	1
 #define WL_TX_POWER_F_HW		2
 #define WL_TX_POWER_F_MIMO		4
 #define WL_TX_POWER_F_SISO		8
 #define WL_TX_POWER_F_HT		0x10
-#endif
+#define WL_TX_POWER_F_VHT		0x20
+
 typedef struct {
 	uint32 flags;
 	chanspec_t chanspec;			/* txpwr report for this channel */
@@ -2570,9 +2797,7 @@ typedef struct {
 	int8  antgain[2];			/* Ant gain for each band - from SROM */
 	uint8 rf_cores;				/* count of RF Cores being reported */
 	uint8 est_Pout[4];			/* Latest tx power out estimate per RF chain */
-	uint8 est_Pout_act[4];		/* Latest tx power out estimate per RF chain
-	* without adjustment
-	*/
+	uint8 est_Pout_act[4]; /* Latest tx power out estimate per RF chain w/o adjustment */
 	uint8 est_Pout_cck;			/* Latest CCK tx power out estimate */
 	uint8 tx_power_max[4];		/* Maximum target power among all rates */
 	uint tx_power_max_rate_ind[4];		/* Index of the rate with the max target power */
@@ -2586,11 +2811,10 @@ typedef struct {
 	int8 channel_bandwidth;		/* 20, 40 or 80 MHz bandwidth? */
 	uint8 version;				/* Version of the data format wlu <--> driver */
 	uint8 display_core;			/* Displayed curpower core */
-#ifdef PPR_API
-} tx_power_new_t;
-#else
+	int8 target_offsets[4];		/* Target power offsets for current rate per core */
+	uint32 last_tx_ratespec;	/* Ratespec for last transmition */
+	int8 SARLIMIT[MAX_STREAMS_SUPPORTED];
 } tx_power_t;
-#endif
 
 typedef struct tx_inst_power {
 	uint8 txpwr_est_Pout[2];			/* Latest estimate for 2.4 and 5 Ghz */
@@ -2733,7 +2957,20 @@ typedef struct wl_txchain_pwr_offsets {
 #define WL_PSTA_VAL		0x00008000
 #define WL_TBTT_VAL		0x00010000
 #define WL_NIC_VAL		0x00020000
-#define WL_PWRSEL_VAL	0x00040000
+#define WL_PWRSEL_VAL		0x00040000
+#define WL_TRF_MGMT_VAL		0x00080000
+#define WL_L2FILTER_VAL		0x00100000
+#define WL_TSO_VAL		0x00200000
+#define WL_MQ_VAL		0x00400000
+/* These 3 levels are currently not used in trunk but in Aardvark and Phoenix2 with != values */
+#define WL_LPC_VAL	        0x00800000
+#define WL_TXBF_VAL		0x01000000
+#define WL_P2PO_VAL		0x02000000
+/* This level is synchronized with other branches */
+#define WL_WNM_VAL		0x04000000
+/* This level is currently not used in trunk but used in Phoenix2 */
+#define WL_SRSCAN_VAL	0x08000000
+
 /* use top-bit for WL_TIME_STAMP_VAL because this is a modifier
  * rather than a message-type of its own
  */
@@ -2766,7 +3003,9 @@ typedef struct wl_txchain_pwr_offsets {
 #define WL_LED_ASSOC_WITH_SEC 	20		/* when connected with security */
 						/* keep on for 300 sec */
 #define WL_LED_START_OFF 	21		/* off upon boot, could be turned on later */
-#define	WL_LED_NUMBEHAVIOR	22
+#define WL_LED_W6		22		/* off upon boot, could be turned on later */
+#define WL_LED_WI7		23		/* off upon boot, could be turned on later */
+#define	WL_LED_NUMBEHAVIOR	24
 
 /* led behavior numeric value format */
 #define	WL_LED_BEH_MASK		0x7f		/* behavior mask */
@@ -2824,7 +3063,7 @@ typedef struct wl_txchain_pwr_offsets {
  *
  * 4. BAND RSSI - 2 octets
  * offset 0: band types
- * offset 1: +ve RSSI boost balue in dB
+ * offset 1: +ve RSSI boost value in dB
  */
 
 /* join preference types */
@@ -3088,6 +3327,12 @@ typedef struct {
 	uint32  pstatxbcmc;	/* count of bcmc frames transmitted on all psta */
 
 	uint32  cso_passthrough; /* hw cso required but passthrough */
+	uint32	chained;	/* number of frames chained */
+	uint32	chainedsz1;	/* number of chain size 1 frames */
+	uint32	unchained;	/* number of frames not chained */
+	uint32	maxchainsz;	/* max chain size so far */
+	uint32	currchainsz;	/* current chain size */
+	uint32 	cso_normal;	/* hw cso hdr for normal process */
 } wl_cnt_t;
 
 #ifndef LINUX_POSTMOGRIFY_REMOVAL
@@ -3528,13 +3773,14 @@ struct tslist {
 
 #ifdef WLTDLS
 /* different ops for manual end point */
-#define TDLS_MANUAL_EP_CREATE	1	/* create manual dpt endpoint */
-#define TDLS_MANUAL_EP_MODIFY	2	/* modify manual dpt endpoint */
-#define TDLS_MANUAL_EP_DELETE	3	/* delete manual dpt endpoint */
+#define TDLS_MANUAL_EP_CREATE		1	/* create manual dpt endpoint */
+#define TDLS_MANUAL_EP_MODIFY		2	/* modify manual dpt endpoint */
+#define TDLS_MANUAL_EP_DELETE		3	/* delete manual dpt endpoint */
 #define TDLS_MANUAL_EP_PM		4	/*  put dpt endpoint in PM mode */
 #define TDLS_MANUAL_EP_WAKE		5	/* wake up dpt endpoint from PM */
 #define TDLS_MANUAL_EP_DISCOVERY	6	/* discover if endpoint is TDLS capable */
 #define TDLS_MANUAL_EP_CHSW		7	/* channel switch */
+#define TDLS_MANUAL_EP_WFD_TPQ	8	/* WiFi-Display Tunneled Probe reQuest */
 
 /* structure for tdls iovars */
 typedef struct tdls_iovar {
@@ -3545,14 +3791,16 @@ typedef struct tdls_iovar {
 } tdls_iovar_t;
 
 /* modes */
-#define TDLS_WFD_IE_TX 0
-#define TDLS_WFD_IE_RX 1
-#define TDLS_WFD_IE_SIZE 255
+#define TDLS_WFD_IE_TX 			0
+#define TDLS_WFD_IE_RX 			1
+#define TDLS_WFD_PROBE_IE_TX	2
+#define TDLS_WFD_PROBE_IE_RX	3
+#define TDLS_WFD_IE_SIZE 		512
 /* structure for tdls wfd ie */
 typedef struct tdls_wfd_ie_iovar {
 	struct ether_addr ea;		/* Station address */
 	uint8 mode;
-	uint8 length;
+	uint16 length;
 	uint8 data[TDLS_WFD_IE_SIZE];
 } tdls_wfd_ie_iovar_t;
 #endif /* WLTDLS */
@@ -3612,14 +3860,21 @@ typedef	struct wme_max_bandwidth {
 #define TSPEC_UNKNOWN		3	/* TSPEC unknown */
 #define TSPEC_STATUS_MASK	7	/* TSPEC status mask */
 
+#ifdef BCMCCX
+/* "wlan_reason" iovar interface */
+#define WL_WLAN_ASSOC_REASON_NORMAL_NETWORK	0 /* normal WLAN network setup */
+#define WL_WLAN_ASSOC_REASON_ROAM_FROM_CELLULAR_NETWORK	1 /* roam from Cellular network */
+#define WL_WLAN_ASSOC_REASON_ROAM_FROM_LAN	2 /* roam from LAN */
+#define WL_WLAN_ASSOC_REASON_MAX		2 /* largest value allowed */
+#endif /* BCMCCX */
 
 /* Software feature flag defines used by wlfeatureflag */
 #ifdef WLAFTERBURNER
-#define WL_SWFL_ABBFL       0x0001 /* Allow Afterburner on systems w/o hardware BFL */
-#define WL_SWFL_ABENCORE    0x0002 /* Allow AB on non-4318E chips */
+#define WL_SWFL_ABBFL		0x0001 /* Allow Afterburner on systems w/o hardware BFL */
+#define WL_SWFL_ABENCORE	0x0002 /* Allow AB on non-4318E chips */
 #endif /* WLAFTERBURNER */
 #define WL_SWFL_NOHWRADIO	0x0004
-#define WL_SWFL_FLOWCONTROL     0x0008 /* Enable backpressure to OS stack */
+#define WL_SWFL_FLOWCONTROL	0x0008 /* Enable backpressure to OS stack */
 #define WL_SWFL_WLBSSSORT	0x0010 /* Per-port supports sorting of BSS */
 
 #define WL_LIFETIME_MAX 0xFFFF /* Max value in ms */
@@ -3687,8 +3942,8 @@ enum {
 #define ENABLE_NET_OFFLOAD_BIT		10
 
 #define SORT_CRITERIA_MASK		0x0001
-#define AUTO_NET_SWITCH_MASK	0x0002
-#define ENABLE_BKGRD_SCAN_MASK	0x0004
+#define AUTO_NET_SWITCH_MASK		0x0002
+#define ENABLE_BKGRD_SCAN_MASK		0x0004
 #define IMMEDIATE_SCAN_MASK		0x0008
 #define	AUTO_CONNECT_MASK		0x0010
 
@@ -3698,7 +3953,7 @@ enum {
 #define SUPPRESS_SSID_MASK	0x0200
 #define ENABLE_NET_OFFLOAD_MASK	0x0400
 
-#define PFN_VERSION				2
+#define PFN_VERSION		2
 #define PFN_SCANRESULT_VERSION	1
 #define MAX_PFN_LIST_COUNT	16
 
@@ -3708,7 +3963,7 @@ enum {
 #define DEFAULT_BESTN			2
 #define DEFAULT_MSCAN			0
 #define DEFAULT_REPEAT			10
-#define DEFAULT_EXP				2
+#define DEFAULT_EXP			2
 
 /* PFN network info structure */
 typedef struct wl_pfn_subnet_info {
@@ -3736,57 +3991,110 @@ typedef struct wl_pfn_param {
 	int32 version;			/* PNO parameters version */
 	int32 scan_freq;		/* Scan frequency */
 	int32 lost_network_timeout;	/* Timeout in sec. to declare
-					 * discovered network as lost
-					 */
+					* discovered network as lost
+					*/
 	int16 flags;			/* Bit field to control features
-					 * of PFN such as sort criteria auto
-					 * enable switch and background scan
-					 */
+					* of PFN such as sort criteria auto
+					* enable switch and background scan
+					*/
 	int16 rssi_margin;		/* Margin to avoid jitter for choosing a
-					 * PFN based on RSSI sort criteria
-					 */
-	uint8 bestn; /* number of best networks in each scan */
-	uint8 mscan; /* number of scans recorded */
-	uint8 repeat; /* Minimum number of scan intervals
-				     *before scan frequency changes in adaptive scan
-				     */
-	uint8 exp; /* Exponent of 2 for maximum scan interval */
-	int32 slow_freq; /* slow scan period */
+					* PFN based on RSSI sort criteria
+					*/
+	uint8 bestn;			/* number of best networks in each scan */
+	uint8 mscan;			/* number of scans recorded */
+	uint8 repeat;			/* Minimum number of scan intervals
+					*before scan frequency changes in adaptive scan
+					*/
+	uint8 exp;			/* Exponent of 2 for maximum scan interval */
+	int32 slow_freq;		/* slow scan period */
 } wl_pfn_param_t;
 
 typedef struct wl_pfn_bssid {
-	struct ether_addr 	macaddr;
+	struct ether_addr	macaddr;
 	/* Bit4: suppress_lost, Bit3: suppress_found */
-	uint16				flags;
+	uint16			flags;
 } wl_pfn_bssid_t;
 #define WL_PFN_SUPPRESSFOUND_MASK	0x08
 #define WL_PFN_SUPPRESSLOST_MASK	0x10
+#define WL_PFN_RSSI_MASK		0xff00
+#define WL_PFN_RSSI_SHIFT		8
 
 typedef struct wl_pfn_cfg {
-	uint32				reporttype;
-	int32				channel_num;
-	uint16				channel_list[WL_NUMCHANNELS];
+	uint32			reporttype;
+	int32			channel_num;
+	uint16			channel_list[WL_NUMCHANNELS];
 } wl_pfn_cfg_t;
-#define WL_PFN_REPORT_ALLNET 	0
-#define WL_PFN_REPORT_SSIDNET 	1
-#define WL_PFN_REPORT_BSSIDNET 	2
+#define WL_PFN_REPORT_ALLNET    0
+#define WL_PFN_REPORT_SSIDNET   1
+#define WL_PFN_REPORT_BSSIDNET  2
 
 typedef struct wl_pfn {
-	wlc_ssid_t		ssid;			/* ssid name and its length */
-	int32			flags;			/* bit2: hidden */
-	int32			infra;			/* BSS Vs IBSS */
-	int32			auth;			/* Open Vs Closed */
-	int32			wpa_auth;		/* WPA type */
-	int32			wsec;			/* wsec value */
+	wlc_ssid_t		ssid;		/* ssid name and its length */
+	int32			flags;		/* bit2: hidden */
+	int32			infra;		/* BSS Vs IBSS */
+	int32			auth;		/* Open Vs Closed */
+	int32			wpa_auth;	/* WPA type */
+	int32			wsec;		/* wsec value */
 } wl_pfn_t;
-#define WL_PFN_HIDDEN_BIT		2
+#define WL_PFN_HIDDEN_BIT	2
 #define PNO_SCAN_MAX_FW		508*1000	/* max time scan time in msec */
 #define PNO_SCAN_MAX_FW_SEC	PNO_SCAN_MAX_FW/1000 /* max time scan time in SEC */
-#define PNO_SCAN_MIN_FW_SEC	10			/* min time scan time in SEC */
-#define WL_PFN_HIDDEN_MASK		0x4
+#define PNO_SCAN_MIN_FW_SEC	10		/* min time scan time in SEC */
+#define WL_PFN_HIDDEN_MASK	0x4
 
 #endif /* LINUX_POSTMOGRIFY_REMOVAL */
 
+/* Service discovery */
+typedef struct {
+	uint8	transaction_id;	/* Transaction id */
+	uint8	protocol;	/* Service protocol type */
+	uint16	query_len;	/* Length of query */
+	uint16	response_len;	/* Length of response */
+	uint8	qrbuf[1];
+} wl_p2po_qr_t;
+
+typedef struct {
+	uint16			period;			/* extended listen period */
+	uint16			interval;		/* extended listen interval */
+} wl_p2po_listen_t;
+
+/* ANQP offload */
+
+#define ANQPO_MAX_QUERY_SIZE		256
+typedef struct {
+	uint16 max_retransmit;		/* -1 use default, max retransmit on no ACK from peer */
+	uint16 response_timeout;	/* -1 use default, msec to wait for resp after tx packet */
+	uint16 max_comeback_delay;	/* -1 use default, max comeback delay in resp else fail */
+	uint16 max_retries;			/* -1 use default, max retries on failure */
+	uint16 query_len;			/* length of ANQP query */
+	uint8 query_data[1];		/* ANQP encoded query (max ANQPO_MAX_QUERY_SIZE) */
+} wl_anqpo_set_t;
+
+typedef struct {
+	uint16 channel;				/* channel of the peer */
+	struct ether_addr addr;		/* addr of the peer */
+} wl_anqpo_peer_t;
+
+#define ANQPO_MAX_PEER_LIST			64
+typedef struct {
+	uint16 count;				/* number of peers in list */
+	wl_anqpo_peer_t peer[1];	/* max ANQPO_MAX_PEER_LIST */
+} wl_anqpo_peer_list_t;
+
+#define ANQPO_MAX_IGNORE_SSID		64
+typedef struct {
+	bool is_clear;				/* set to clear list (not used on GET) */
+	uint16 count;				/* number of SSID in list */
+	wlc_ssid_t ssid[1];			/* max ANQPO_MAX_IGNORE_SSID */
+} wl_anqpo_ignore_ssid_list_t;
+
+#define ANQPO_MAX_IGNORE_BSSID		64
+typedef struct {
+	bool is_clear;				/* set to clear list (not used on GET) */
+	uint16 count;				/* number of addr in list */
+	struct ether_addr bssid[1];	/* max ANQPO_MAX_IGNORE_BSSID */
+} wl_anqpo_ignore_bssid_list_t;
+
 /* TCP Checksum Offload defines */
 #define TOE_TX_CSUM_OL		0x00000001
 #define TOE_RX_CSUM_OL		0x00000002
@@ -3839,7 +4147,7 @@ struct toe_ol_stats_t {
 #define ARP_ERRTEST_REPLY_HOST	0x2
 
 #define ARP_MULTIHOMING_MAX	8	/* Maximum local host IP addresses */
-#define ND_MULTIHOMING_MAX 8	/* Maximum local host IP addresses */
+#define ND_MULTIHOMING_MAX	10	/* Maximum local host IP addresses */
 
 /* Arp offload statistic counts */
 struct arp_ol_stats_t {
@@ -3947,6 +4255,15 @@ typedef struct wl_pkt_filter_stats {
 	uint32	num_pkts_discarded;	/* # packets discarded by dongle for all filters */
 } wl_pkt_filter_stats_t;
 
+#define RSN_KCK_LENGTH 16
+#define RSN_KEK_LENGTH 16
+#define RSN_REPLAY_LEN 8
+typedef struct _gtkrefresh {
+	uchar	KCK[RSN_KCK_LENGTH];
+	uchar	KEK[RSN_KEK_LENGTH];
+	uchar	ReplayCounter[RSN_REPLAY_LEN];
+} gtk_keyinfo_t, *pgtk_keyinfo_t;
+
 /* Sequential Commands ioctl */
 typedef struct wl_seq_cmd_ioctl {
 	uint32 cmd;		/* common ioctl definition */
@@ -3979,6 +4296,8 @@ typedef struct wl_seq_cmd_ioctl {
 
 #define WL_PKTENG_SYNCHRONOUS			0x100	/* synchronous flag */
 
+#define WL_PKTENG_MAXPKTSZ			16384	/* max pktsz limit for pkteng */
+
 typedef struct wl_pkteng {
 	uint32 flags;
 	uint32 delay;			/* Inter-packet delay */
@@ -3998,6 +4317,7 @@ typedef struct wl_pkteng_stats {
 	int32 rssi;			/* RSSI */
 	int32 snr;			/* signal to noise ratio */
 	uint16 rxpktcnt[NUM_80211_RATES+1];
+	uint8 rssi_qdb; /* qdB portion of the computed rssi */
 } wl_pkteng_stats_t;
 
 
@@ -4021,14 +4341,14 @@ typedef struct wl_pkteng_stats {
 #define MAGIC_PKT_MINLEN 102    /* Magic pkt min length is 6 * 0xFF + 16 * ETHER_ADDR_LEN */
 
 #define WOWL_PATTEN_TYPE_ARP	(1 << 0)	/* ARP offload Pattern */
-#define WOWL_PATTEN_TYPE_NA		(1 << 1)	/* NA offload Pattern */
+#define WOWL_PATTEN_TYPE_NA	(1 << 1)	/* NA offload Pattern */
 
 typedef struct {
 	uint32 masksize;		/* Size of the mask in #of bytes */
 	uint32 offset;			/* Offset to start looking for the packet in # of bytes */
-	uint32 patternoffset;	/* Offset of start of pattern in the structure */
+	uint32 patternoffset;		/* Offset of start of pattern in the structure */
 	uint32 patternsize;		/* Size of the pattern itself in #of bytes */
-	uint32 id;				/* id */
+	uint32 id;			/* id */
 	uint32 reasonsize;		/* Size of the wakeup reason code */
 	uint32 flags;			/* Flags to tell the pattern type and other properties */
 	/* Mask follows the structure above */
@@ -4162,6 +4482,37 @@ typedef struct {
 	uint32 queue_capacity; /* the maximum capacity of the queue */
 } pktq_log_counters_v01_t;
 
+typedef struct {
+	uint32 requested;      /* packets requested to be stored */
+	uint32 stored;         /* packets stored */
+	uint32 saved;          /* packets saved,
+	                          because a lowest priority queue has given away one packet
+	                       */
+	uint32 selfsaved;      /* packets saved,
+	                          because an older packet from the same queue has been dropped
+	                       */
+	uint32 full_dropped;   /* packets dropped,
+	                          because pktq is full with higher precedence packets
+	                       */
+	uint32 dropped;        /* packets dropped because pktq per that precedence is full */
+	uint32 sacrificed;     /* packets dropped,
+	                          in order to save one from a queue of a highest priority
+	                       */
+	uint32 busy;           /* packets droped because of hardware/transmission error */
+	uint32 retry;          /* packets re-sent because they were not received */
+	uint32 ps_retry;       /* packets retried again prior to moving power save mode */
+	uint32 retry_drop;     /* packets finally dropped after retry limit */
+	uint32 max_avail;      /* the high-water mark of the queue capacity for packets -
+	                          goes to zero as queue fills
+	                       */
+	uint32 max_used;       /* the high-water mark of the queue utilisation for packets -
+	                          increases with use ('inverse' of max_avail)
+	                       */
+	uint32 queue_capacity; /* the maximum capacity of the queue */
+	uint32 rtsfail;        /* count of rts attempts that failed to receive cts */
+	uint32 acked;          /* count of packets sent (acked) successfully */
+} pktq_log_counters_v02_t;
+
 #define sacrified sacrificed
 
 typedef struct {
@@ -4170,12 +4521,21 @@ typedef struct {
 	char                 headings[1];
 } pktq_log_format_v01_t;
 
+typedef struct {
+	uint8                num_prec[WL_IOV_MAC_PARAM_LEN];
+	pktq_log_counters_v02_t  counters[WL_IOV_MAC_PARAM_LEN][WL_IOV_PKTQ_LOG_PRECS];
+	uint32               throughput[WL_IOV_MAC_PARAM_LEN][WL_IOV_PKTQ_LOG_PRECS];
+	uint32               time_delta;
+	char                 headings[1];
+} pktq_log_format_v02_t;
+
 
 typedef struct {
 	uint32               version;
 	wl_iov_mac_params_t  params;
 	union {
 		pktq_log_format_v01_t v01;
+		pktq_log_format_v02_t v02;
 	} pktq_log;
 } wl_iov_pktq_log_t;
 
@@ -4333,6 +4693,21 @@ typedef struct {
 #define VNDR_IE_IWAPID_FLAG	0x40 /* vendor IE in IW advertisement protocol ID field */
 #define VNDR_IE_CUSTOM_FLAG	0x100 /* allow custom IE id */
 
+#if defined(WLP2P)
+/* P2P Action Frames flags (spec ordered) */
+#define VNDR_IE_GONREQ_FLAG     0x001000
+#define VNDR_IE_GONRSP_FLAG     0x002000
+#define VNDR_IE_GONCFM_FLAG     0x004000
+#define VNDR_IE_INVREQ_FLAG     0x008000
+#define VNDR_IE_INVRSP_FLAG     0x010000
+#define VNDR_IE_DISREQ_FLAG     0x020000
+#define VNDR_IE_DISRSP_FLAG     0x040000
+#define VNDR_IE_PRDREQ_FLAG     0x080000
+#define VNDR_IE_PRDRSP_FLAG     0x100000
+
+#define VNDR_IE_P2PAF_SHIFT	12
+#endif /* WLP2P */
+
 #define VNDR_IE_INFO_HDR_LEN	(sizeof(uint32))
 
 typedef BWL_PRE_PACKED_STRUCT struct {
@@ -4407,6 +4782,35 @@ typedef BWL_PRE_PACKED_STRUCT struct {
 } BWL_POST_PACKED_STRUCT txfailinfo_t;
 #endif /* WLMEDIA_TXFAILEVENT */
 
+typedef BWL_PRE_PACKED_STRUCT struct {
+	uint32 flags;
+	chanspec_t chanspec;			/* txpwr report for this channel */
+	chanspec_t local_chanspec;		/* channel on which we are associated */
+	uint8 local_max;			/* local max according to the AP */
+	uint8 local_constraint;			/* local constraint according to the AP */
+	int8  antgain[2];			/* Ant gain for each band - from SROM */
+	uint8 rf_cores;				/* count of RF Cores being reported */
+	uint8 est_Pout[4];			/* Latest tx power out estimate per RF chain */
+	uint8 est_Pout_act[4]; /* Latest tx power out estimate per RF chain w/o adjustment */
+	uint8 est_Pout_cck;			/* Latest CCK tx power out estimate */
+	uint8 tx_power_max[4];		/* Maximum target power among all rates */
+	uint tx_power_max_rate_ind[4];		/* Index of the rate with the max target power */
+	int8 clm_limits[WL_NUMRATES];		/* regulatory limits - 20, 40 or 80MHz */
+	int8 clm_limits_subchan1[WL_NUMRATES];	/* regulatory limits - 20in40 or 40in80 */
+	int8 clm_limits_subchan2[WL_NUMRATES];	/* regulatory limits - 20in80MHz */
+	int8 sar;					/* SAR limit for display by wl executable */
+	int8 channel_bandwidth;		/* 20, 40 or 80 MHz bandwidth? */
+	uint8 version;				/* Version of the data format wlu <--> driver */
+	uint8 display_core;			/* Displayed curpower core */
+	int8 target_offsets[4];		/* Target power offsets for current rate per core */
+	uint32 last_tx_ratespec;	/* Ratespec for last transmition */
+	uint   user_target;		/* user limit */
+	uint32 board_limit_len;		/* length of board limit buffer */
+	uint32 target_len;		/* length of target power buffer */
+	int8 SARLIMIT[MAX_STREAMS_SUPPORTED];
+	uint8  pprdata[1];		/* ppr serialization buffer */
+} BWL_POST_PACKED_STRUCT tx_pwr_rpt_t;
+
 #endif /* LINUX_POSTMOGRIFY_REMOVAL */
 
 /* no strict structure packing */
@@ -4459,10 +4863,12 @@ struct wapi_sta_msg_t
 
 /* define for apcs reason code */
 #define APCS_INIT		0
-#define APCS_IOCTL 		1
-#define APCS_CHANIM 	2
+#define APCS_IOCTL		1
+#define APCS_CHANIM		2
 #define APCS_CSTIMER	3
 #define APCS_BTA		4
+#define APCS_TXDLY		5
+#define APCS_NONACSD	6
 
 /* number of ACS record entries */
 #define CHANIM_ACS_RECORD			10
@@ -4734,7 +5140,9 @@ typedef struct wl_nic_cnx {
 	uint8 SSID_len;
 	uint8 SSID[32];
 	struct ether_addr abssid;
-	uint8 join_period;
+	uint16 beacon_interval;
+	uint16 sync_threshold;
+	uint16 beacon_wait_time;
 } wl_nic_cnx_t;
 
 /* opcode */
@@ -4748,16 +5156,23 @@ typedef struct wl_nic_cnx {
 typedef struct wl_nic_cfg {
 	uint8 version;
 	uint8 beacon_mode;
-	uint16 beacon_interval;
 	uint8 diluted_beacon_period;
-	uint8 repeat_EQC;
+	uint8 beacon_probability;
+	uint8 num_awake_window_params;
+	struct {
+		uint8 channel_number;
+		uint8 awake_window_length;
+		uint8 repeat_EQC;
+	} awake_window_params[3];
 	uint8 scan_length;
 	uint8 scan_interval;
 	uint8 scan_probability;
-	uint8 awake_window_length;
-	int8 TSF_correction;
 	uint8 ASID;
 	uint8 channel_usage_mode;
+	uint8 CWmin_af;
+	uint8 NIC_priority;
+	uint8 NIC_data_ind;
+	uint8 allowed_wakeup_delay;
 } wl_nic_cfg_t;
 
 /* version */
@@ -4779,7 +5194,6 @@ typedef struct wl_nic_frm {
 } wl_nic_frm_t;
 
 /* type */
-#define WL_NIC_FRM_MYNET	1
 #define WL_NIC_FRM_ACTION	2
 
 /* i/f query */
@@ -4792,8 +5206,17 @@ typedef struct wl_nic_ifq {
 /* nic_dm iovar */
 typedef struct wl_nic_dm {
 	uint8 enab;
+	uint8 rsvd;
+	/* the following fields are valid when enabling... */
 	chanspec_t chspec;
+	uint8 DATA_priority;
+	uint8 NIC_priority;
 } wl_nic_dm_t;
+
+/* immediate scan request */
+typedef struct wl_nic_isq {
+	uint8 scan_length;
+} wl_nic_isq_t;
 #endif /* WLNIC */
 
 /* RFAWARE def */
@@ -4938,6 +5361,13 @@ enum {
 	SPATIAL_MODE_MAX_IDX
 };
 
+#define WLC_TXCORE_MAX	4	/* max number of txcore supports */
+#define WLC_SUBBAND_MAX	4	/* max number of sub-band supports */
+typedef struct {
+	uint8	band2g[WLC_TXCORE_MAX];
+	uint8	band5g[WLC_SUBBAND_MAX][WLC_TXCORE_MAX];
+} sar_limit_t;
+
 /* IOVAR "mempool" parameter. Used to retrieve a list of memory pool statistics. */
 typedef struct wl_mempool_stats {
 	int	num;		/* Number of memory pools */
@@ -4973,15 +5403,23 @@ typedef struct {
 #define TRF_MGMT_MAX_PRIORITIES                 3
 
 #define TRF_MGMT_FLAG_ADD_DSCP                  0x0001  /* Add DSCP to IP TOS field */
-#define TRF_MGMT_FLAG_DISABLE_SHAPING           0x0002  /* Only support traffic clasification */
-#define TRF_MGMT_FLAG_DISABLE_PRIORITY_TAGGING  0x0004  /* Don't override packet's priority */
+#define TRF_MGMT_FLAG_DISABLE_SHAPING           0x0002  /* Don't shape traffic */
+#define TRF_MGMT_FLAG_MANAGE_LOCAL_TRAFFIC      0x0008  /* Manage traffic over our local subnet */
+#define TRF_MGMT_FLAG_FILTER_ON_MACADDR         0x0010  /* filter on MAC address */
+#define TRF_MGMT_FLAG_NO_RX                     0x0020  /* do not apply fiters to rx packets */
+
+#define TRF_FILTER_MAC_ADDR              0x0001 /* L2 filter use dst mac address for filtering */
+#define TRF_FILTER_IP_ADDR               0x0002 /* L3 filter use ip ddress for filtering */
+#define TRF_FILTER_L4                    0x0004 /* L4 filter use tcp/udp for filtering */
+#define TRF_FILTER_FAVORED               0x0010 /* Tag the packet FAVORED */
 
 /* Traffic management priority classes */
 typedef enum trf_mgmt_priority_class {
-	trf_mgmt_priority_low           = 0,            /* Maps to 802.1p BO */
-	trf_mgmt_priority_medium        = 1,            /* Maps to 802.1p BE */
-	trf_mgmt_priority_high          = 2,            /* Maps to 802.1p VI */
-	trf_mgmt_priority_invalid       = (trf_mgmt_priority_high + 1)
+	trf_mgmt_priority_low           = 0,        /* Maps to 802.1p BK */
+	trf_mgmt_priority_medium        = 1,        /* Maps to 802.1p BE */
+	trf_mgmt_priority_high          = 2,        /* Maps to 802.1p VI */
+	trf_mgmt_priority_nochange	= 3,	    /* do not update the priority */
+	trf_mgmt_priority_invalid       = (trf_mgmt_priority_nochange + 1)
 } trf_mgmt_priority_class_t;
 
 /* Traffic management configuration parameters */
@@ -5063,5 +5501,108 @@ typedef struct powersel_params {
 	uint8		pwr_sel_exp_time; /* Time lapse for expiry of database */
 } powersel_params_t;
 
+/* tx pkt delay statistics */
+#define	SCB_RETRY_SHORT_DEF	7	/* Default Short retry Limit */
+#define WLPKTDLY_HIST_NBINS	16	/* number of bins used in the Delay histogram */
+
+/* structure to store per-AC delay statistics */
+typedef struct scb_delay_stats {
+	uint32 txmpdu_lost;	/* number of MPDUs lost */
+	uint32 txmpdu_cnt[SCB_RETRY_SHORT_DEF]; /* retry times histogram */
+	uint32 delay_sum[SCB_RETRY_SHORT_DEF]; /* cumulative packet latency */
+	uint32 delay_min;	/* minimum packet latency observed */
+	uint32 delay_max;	/* maximum packet latency observed */
+	uint32 delay_avg;	/* packet latency average */
+	uint32 delay_hist[WLPKTDLY_HIST_NBINS];	/* delay histogram */
+} scb_delay_stats_t;
+
+/* structure for txdelay event */
+typedef struct txdelay_event {
+	uint8	status;
+	int		rssi;
+	chanim_stats_t		chanim_stats;
+	scb_delay_stats_t	delay_stats[AC_COUNT];
+} txdelay_event_t;
+
+/* structure for txdelay parameters */
+typedef struct txdelay_params {
+	uint16	ratio;	/* Avg Txdelay Delta */
+	uint8	cnt;	/* Sample cnt */
+	uint8	period;	/* Sample period */
+	uint8	tune;	/* Debug */
+} txdelay_params_t;
+
+#define WL_RELMCAST_MAX_CLIENT 			32
+#define WL_RELMCAST_FLAG_INBLACKLIST	1
+#define WL_RELMCAST_FLAG_ACTIVEACKER	2
+#define WL_RELMCAST_FLAG_RELMCAST		4
+
+#define WL_RELMCAST_VER					1
+
+typedef struct wl_relmcast_client {
+	uint8 flag;
+	int16 rssi;
+	struct ether_addr addr;
+} wl_relmcast_client_t;
+
+typedef struct wl_relmcast_st {
+	uint8 ver;
+	uint8 num;
+	wl_relmcast_client_t clients[WL_RELMCAST_MAX_CLIENT];
+} wl_relmcast_status_t;
+
 #endif /* LINUX_POSTMOGRIFY_REMOVAL */
+
+/* fbt_cap: FBT assoc / reassoc modes. */
+#define WLC_FBT_CAP_DRV_4WAY_AND_REASSOC  1 /* Driver 4-way handshake & reassoc (WLFBT). */
+
+typedef struct bcnreq {
+	uint8 bcn_mode;
+	int dur;
+	int channel;
+	struct ether_addr da;
+	uint16 random_int;
+	wlc_ssid_t ssid;
+	uint16 reps;
+} bcnreq_t;
+
+typedef struct rrmreq {
+	struct ether_addr da;
+	uint8 reg;
+	uint8 chan;
+	uint16 random_int;
+	uint16 dur;
+	uint16 reps;
+} rrmreq_t;
+
+typedef struct framereq {
+	struct ether_addr da;
+	uint8 reg;
+	uint8 chan;
+	uint16 random_int;
+	uint16 dur;
+	struct ether_addr ta;
+	uint16 reps;
+} framereq_t;
+
+typedef struct statreq {
+	struct ether_addr da;
+	struct ether_addr peer;
+	uint16 random_int;
+	uint16 dur;
+	uint8 group_id;
+	uint16 reps;
+} statreq_t;
+
+typedef struct wl_el_set_params_s {
+	uint8 set;	/* Set number */
+	uint32 size;	/* Size to make/expand */
+} wl_el_set_params_t;
+
+typedef struct wl_el_tag_params_s {
+	uint16 tag;
+	uint8 set;
+	uint8 flags;
+} wl_el_tag_params_t;
+
 #endif /* _wlioctl_h_ */
diff --git a/drivers/net/wireless/bcmdhd/linux_osl.c b/drivers/net/wireless/bcmdhd/linux_osl.c
old mode 100644
new mode 100755
index ef9c733..ebe6ea1
--- a/drivers/net/wireless/bcmdhd/linux_osl.c
+++ b/drivers/net/wireless/bcmdhd/linux_osl.c
@@ -1,27 +1,9 @@
 /*
  * Linux OS Independent Layer
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: linux_osl.c 311099 2012-01-27 14:46:59Z $
+ * $Id: linux_osl.c 392927 2013-03-25 19:30:25Z $
  */
 
 #define LINUX_PORT
@@ -35,9 +17,6 @@
 #include <linux/delay.h>
 #include <pcicfg.h>
 
-#ifdef BCMASSERT_LOG
-#include <bcm_assert_log.h>
-#endif
 
 
 #include <linux/fs.h>
@@ -48,6 +27,11 @@
 #define BCM_MEM_FILENAME_LEN 	24		
 
 #ifdef CONFIG_DHD_USE_STATIC_BUF
+#define DHD_SKB_HDRSIZE 		336
+#define DHD_SKB_1PAGE_BUFSIZE	((PAGE_SIZE*1)-DHD_SKB_HDRSIZE)
+#define DHD_SKB_2PAGE_BUFSIZE	((PAGE_SIZE*2)-DHD_SKB_HDRSIZE)
+#define DHD_SKB_4PAGE_BUFSIZE	((PAGE_SIZE*4)-DHD_SKB_HDRSIZE)
+
 #define STATIC_BUF_MAX_NUM	16
 #define STATIC_BUF_SIZE	(PAGE_SIZE*2)
 #define STATIC_BUF_TOTAL_LEN	(STATIC_BUF_MAX_NUM * STATIC_BUF_SIZE)
@@ -61,12 +45,22 @@ typedef struct bcm_static_buf {
 static bcm_static_buf_t *bcm_static_buf = 0;
 
 #define STATIC_PKT_MAX_NUM	8
+#if defined(ENHANCED_STATIC_BUF)
+#define STATIC_PKT_4PAGE_NUM	1
+#define DHD_SKB_MAX_BUFSIZE	DHD_SKB_4PAGE_BUFSIZE
+#else
+#define STATIC_PKT_4PAGE_NUM	0
+#define DHD_SKB_MAX_BUFSIZE DHD_SKB_2PAGE_BUFSIZE
+#endif 
 
 typedef struct bcm_static_pkt {
 	struct sk_buff *skb_4k[STATIC_PKT_MAX_NUM];
 	struct sk_buff *skb_8k[STATIC_PKT_MAX_NUM];
+#ifdef ENHANCED_STATIC_BUF
+	struct sk_buff *skb_16k;
+#endif
 	struct semaphore osl_pkt_sem;
-	unsigned char pkt_use[STATIC_PKT_MAX_NUM * 2];
+	unsigned char pkt_use[STATIC_PKT_MAX_NUM * 2 + STATIC_PKT_4PAGE_NUM];
 } bcm_static_pkt_t;
 
 static bcm_static_pkt_t *bcm_static_skb = 0;
@@ -89,13 +83,29 @@ struct osl_info {
 	uint magic;
 	void *pdev;
 	atomic_t malloced;
+	atomic_t pktalloced; 	
 	uint failed;
 	uint bustype;
 	bcm_mem_link_t *dbgmem_list;
 	spinlock_t dbgmem_lock;
+#ifdef BCMDBG_CTRACE
+	spinlock_t ctrace_lock;
+	struct list_head ctrace_list;
+	int ctrace_num;
+#endif 
 	spinlock_t pktalloc_lock;
 };
 
+#define OSL_PKTTAG_CLEAR(p) \
+do { \
+	struct sk_buff *s = (struct sk_buff *)(p); \
+	ASSERT(OSL_PKTTAG_SZ == 32); \
+	*(uint32 *)(&s->cb[0]) = 0; *(uint32 *)(&s->cb[4]) = 0; \
+	*(uint32 *)(&s->cb[8]) = 0; *(uint32 *)(&s->cb[12]) = 0; \
+	*(uint32 *)(&s->cb[16]) = 0; *(uint32 *)(&s->cb[20]) = 0; \
+	*(uint32 *)(&s->cb[24]) = 0; *(uint32 *)(&s->cb[28]) = 0; \
+} while (0)
+
 
 
 
@@ -145,13 +155,12 @@ static int16 linuxbcmerrormap[] =
 	-ENODEV,		
 	-EINVAL,		
 	-ENODATA,		
+	-EINVAL,		
+	-EINVAL,		
+	-EIO,     		
+	-EIO,			
 
 
-
-#if BCME_LAST != -42
-#error "You need to add a OS error translation in the linuxbcmerrormap \
-	for new error code defined in bcmutils.h"
-#endif
 };
 
 
@@ -173,8 +182,16 @@ osl_t *
 osl_attach(void *pdev, uint bustype, bool pkttag)
 {
 	osl_t *osh;
+	gfp_t flags;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25))
+	flags = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;
+#else
+	flags = GFP_ATOMIC;
+#endif
+	if (!(osh = kmalloc(sizeof(osl_t), flags)))
+		return osh;
 
-	osh = kmalloc(sizeof(osl_t), GFP_ATOMIC);
 	ASSERT(osh);
 
 	bzero(osh, sizeof(osl_t));
@@ -214,6 +231,10 @@ osl_attach(void *pdev, uint bustype, bool pkttag)
 		if (!(bcm_static_buf = (bcm_static_buf_t *)dhd_os_prealloc(osh, 3, STATIC_BUF_SIZE+
 			STATIC_BUF_TOTAL_LEN))) {
 			printk("can not alloc static buf!\n");
+			bcm_static_skb = NULL;
+			ASSERT(osh->magic == OS_HANDLE_MAGIC);
+			kfree(osh);
+			return NULL;
 		}
 		else
 			printk("alloc static buf at %x!\n", (unsigned int)bcm_static_buf);
@@ -229,15 +250,30 @@ osl_attach(void *pdev, uint bustype, bool pkttag)
 		void *skb_buff_ptr = 0;
 		bcm_static_skb = (bcm_static_pkt_t *)((char *)bcm_static_buf + 2048);
 		skb_buff_ptr = dhd_os_prealloc(osh, 4, 0);
+		if (!skb_buff_ptr) {
+			printk("cannot alloc static buf!\n");
+			bcm_static_buf = NULL;
+			bcm_static_skb = NULL;
+			ASSERT(osh->magic == OS_HANDLE_MAGIC);
+			kfree(osh);
+			return NULL;
+		}
 
-		bcopy(skb_buff_ptr, bcm_static_skb, sizeof(struct sk_buff *)*16);
-		for (i = 0; i < STATIC_PKT_MAX_NUM * 2; i++)
+		bcopy(skb_buff_ptr, bcm_static_skb, sizeof(struct sk_buff *) *
+			(STATIC_PKT_MAX_NUM * 2 + STATIC_PKT_4PAGE_NUM));
+		for (i = 0; i < STATIC_PKT_MAX_NUM * 2 + STATIC_PKT_4PAGE_NUM; i++)
 			bcm_static_skb->pkt_use[i] = 0;
 
 		sema_init(&bcm_static_skb->osl_pkt_sem, 1);
 	}
 #endif 
 
+#ifdef BCMDBG_CTRACE
+	spin_lock_init(&osh->ctrace_lock);
+	INIT_LIST_HEAD(&osh->ctrace_list);
+	osh->ctrace_num = 0;
+#endif 
+
 	spin_lock_init(&(osh->pktalloc_lock));
 
 	return osh;
@@ -262,15 +298,17 @@ osl_detach(osl_t *osh)
 	kfree(osh);
 }
 
-static struct sk_buff *osl_alloc_skb(unsigned int len)
+static struct sk_buff *osl_alloc_skb(osl_t *osh, unsigned int len)
 {
+	struct sk_buff *skb;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
-	gfp_t flags = GFP_ATOMIC;
+	gfp_t flags = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;
 
-	return __dev_alloc_skb(len, flags);
+	skb = __dev_alloc_skb(len, flags);
 #else
-	return dev_alloc_skb(len);
-#endif
+	skb = dev_alloc_skb(len);
+#endif 
+	return skb;
 }
 
 #ifdef CTFPOOL
@@ -304,7 +342,7 @@ osl_ctfpool_add(osl_t *osh)
 	}
 
 	
-	skb = osl_alloc_skb(osh->ctfpool->obj_size);
+	skb = osl_alloc_skb(osh, osh->ctfpool->obj_size);
 	if (skb == NULL) {
 		printf("%s: skb alloc of len %d failed\n", __FUNCTION__,
 		       osh->ctfpool->obj_size);
@@ -347,9 +385,15 @@ osl_ctfpool_replenish(osl_t *osh, uint thresh)
 int32
 osl_ctfpool_init(osl_t *osh, uint numobj, uint size)
 {
-	osh->ctfpool = kmalloc(sizeof(ctfpool_t), GFP_ATOMIC);
+	gfp_t flags;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25))
+	flags = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;
+#else
+	flags = GFP_ATOMIC;
+#endif
+	osh->ctfpool = kzalloc(sizeof(ctfpool_t), flags);
 	ASSERT(osh->ctfpool);
-	bzero(osh->ctfpool, sizeof(ctfpool_t));
 
 	osh->ctfpool->max_obj = numobj;
 	osh->ctfpool->obj_size = size;
@@ -458,9 +502,13 @@ osl_pktfastget(osl_t *osh, uint len)
 
 	
 	skb->next = skb->prev = NULL;
+#if defined(__ARM_ARCH_7A__)
+	skb->data = skb->head + NET_SKB_PAD;
+	skb->tail = skb->head + NET_SKB_PAD;
+#else
 	skb->data = skb->head + 16;
 	skb->tail = skb->head + 16;
-
+#endif 
 	skb->len = 0;
 	skb->cloned = 0;
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
@@ -468,6 +516,9 @@ osl_pktfastget(osl_t *osh, uint len)
 #endif
 	atomic_set(&skb->users, 1);
 
+	PKTSETCLINK(skb, NULL);
+	PKTCCLRATTR(skb);
+
 	return skb;
 }
 #endif 
@@ -475,69 +526,95 @@ osl_pktfastget(osl_t *osh, uint len)
 struct sk_buff * BCMFASTPATH
 osl_pkt_tonative(osl_t *osh, void *pkt)
 {
-#ifndef WL_UMK
 	struct sk_buff *nskb;
-	unsigned long flags;
+#ifdef BCMDBG_CTRACE
+	struct sk_buff *nskb1, *nskb2;
 #endif
 
 	if (osh->pub.pkttag)
-		bzero((void*)((struct sk_buff *)pkt)->cb, OSL_PKTTAG_SZ);
+		OSL_PKTTAG_CLEAR(pkt);
 
-#ifndef WL_UMK
 	
 	for (nskb = (struct sk_buff *)pkt; nskb; nskb = nskb->next) {
-		spin_lock_irqsave(&osh->pktalloc_lock, flags);
-		osh->pub.pktalloced--;
-		spin_unlock_irqrestore(&osh->pktalloc_lock, flags);
-	}
+		atomic_sub(PKTISCHAINED(nskb) ? PKTCCNT(nskb) : 1, &osh->pktalloced);
+
+#ifdef BCMDBG_CTRACE
+		for (nskb1 = nskb; nskb1 != NULL; nskb1 = nskb2) {
+			if (PKTISCHAINED(nskb1)) {
+				nskb2 = PKTCLINK(nskb1);
+			}
+			else
+				nskb2 = NULL;
+
+			DEL_CTRACE(osh, nskb1);
+		}
 #endif 
+	}
 	return (struct sk_buff *)pkt;
 }
 
 
+#ifdef BCMDBG_CTRACE
+void * BCMFASTPATH
+osl_pkt_frmnative(osl_t *osh, void *pkt, int line, char *file)
+#else
 void * BCMFASTPATH
 osl_pkt_frmnative(osl_t *osh, void *pkt)
+#endif 
 {
-#ifndef WL_UMK
 	struct sk_buff *nskb;
-	unsigned long flags;
+#ifdef BCMDBG_CTRACE
+	struct sk_buff *nskb1, *nskb2;
 #endif
 
 	if (osh->pub.pkttag)
-		bzero((void*)((struct sk_buff *)pkt)->cb, OSL_PKTTAG_SZ);
+		OSL_PKTTAG_CLEAR(pkt);
 
-#ifndef WL_UMK
 	
 	for (nskb = (struct sk_buff *)pkt; nskb; nskb = nskb->next) {
-		spin_lock_irqsave(&osh->pktalloc_lock, flags);
-		osh->pub.pktalloced++;
-		spin_unlock_irqrestore(&osh->pktalloc_lock, flags);
-	}
+		atomic_add(PKTISCHAINED(nskb) ? PKTCCNT(nskb) : 1, &osh->pktalloced);
+
+#ifdef BCMDBG_CTRACE
+		for (nskb1 = nskb; nskb1 != NULL; nskb1 = nskb2) {
+			if (PKTISCHAINED(nskb1)) {
+				nskb2 = PKTCLINK(nskb1);
+			}
+			else
+				nskb2 = NULL;
+
+			ADD_CTRACE(osh, nskb1, file, line);
+		}
 #endif 
+	}
 	return (void *)pkt;
 }
 
 
+#ifdef BCMDBG_CTRACE
+void * BCMFASTPATH
+osl_pktget(osl_t *osh, uint len, int line, char *file)
+#else
 void * BCMFASTPATH
 osl_pktget(osl_t *osh, uint len)
+#endif 
 {
 	struct sk_buff *skb;
-	unsigned long flags;
 
 #ifdef CTFPOOL
 	
 	skb = osl_pktfastget(osh, len);
-	if ((skb != NULL) || ((skb = osl_alloc_skb(len)) != NULL)) {
+	if ((skb != NULL) || ((skb = osl_alloc_skb(osh, len)) != NULL)) {
 #else 
-	if ((skb = osl_alloc_skb(len))) {
+	if ((skb = osl_alloc_skb(osh, len))) {
 #endif 
-		skb_put(skb, len);
+		skb->tail += len;
+		skb->len  += len;
 		skb->priority = 0;
 
-
-		spin_lock_irqsave(&osh->pktalloc_lock, flags);
-		osh->pub.pktalloced++;
-		spin_unlock_irqrestore(&osh->pktalloc_lock, flags);
+#ifdef BCMDBG_CTRACE
+		ADD_CTRACE(osh, skb, file, line);
+#endif
+		atomic_inc(&osh->pktalloced);
 	}
 
 	return ((void*) skb);
@@ -560,10 +637,17 @@ osl_pktfastfree(osl_t *osh, struct sk_buff *skb)
 
 	
 	skb->dev = NULL;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 36)
 	skb->dst = NULL;
-	memset(skb->cb, 0, sizeof(skb->cb));
+#endif
+	OSL_PKTTAG_CLEAR(skb);
 	skb->ip_summed = 0;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+	skb_orphan(skb);
+#else
 	skb->destructor = NULL;
+#endif
 
 	ctfpool = (ctfpool_t *)CTFPOOLPTR(osh, skb);
 	ASSERT(ctfpool != NULL);
@@ -586,7 +670,6 @@ void BCMFASTPATH
 osl_pktfree(osl_t *osh, void *p, bool send)
 {
 	struct sk_buff *skb, *nskb;
-	unsigned long flags;
 
 	skb = (struct sk_buff*) p;
 
@@ -600,16 +683,21 @@ osl_pktfree(osl_t *osh, void *p, bool send)
 		nskb = skb->next;
 		skb->next = NULL;
 
+#ifdef BCMDBG_CTRACE
+		DEL_CTRACE(osh, skb);
+#endif
 
 
 #ifdef CTFPOOL
-		if ((PKTISFAST(osh, skb)) && (atomic_read(&skb->users) == 1))
+		if (PKTISFAST(osh, skb)) {
+			if (atomic_read(&skb->users) == 1)
+				smp_rmb();
+			else if (!atomic_dec_and_test(&skb->users))
+				goto next_skb;
 			osl_pktfastfree(osh, skb);
-		else {
-#else 
+		} else
+#endif
 		{
-#endif 
-
 			if (skb->destructor)
 				
 				dev_kfree_skb_any(skb);
@@ -617,9 +705,10 @@ osl_pktfree(osl_t *osh, void *p, bool send)
 				
 				dev_kfree_skb(skb);
 		}
-		spin_lock_irqsave(&osh->pktalloc_lock, flags);
-		osh->pub.pktalloced--;
-		spin_unlock_irqrestore(&osh->pktalloc_lock, flags);
+#ifdef CTFPOOL
+next_skb:
+#endif
+		atomic_dec(&osh->pktalloced);
 		skb = nskb;
 	}
 }
@@ -631,14 +720,14 @@ osl_pktget_static(osl_t *osh, uint len)
 	int i = 0;
 	struct sk_buff *skb;
 
-	if (len > (PAGE_SIZE*2)) {
+	if (len > DHD_SKB_MAX_BUFSIZE) {
 		printk("%s: attempt to allocate huge packet (0x%x)\n", __FUNCTION__, len);
 		return osl_pktget(osh, len);
 	}
 
 	down(&bcm_static_skb->osl_pkt_sem);
 
-	if (len <= PAGE_SIZE) {
+	if (len <= DHD_SKB_1PAGE_BUFSIZE) {
 		for (i = 0; i < STATIC_PKT_MAX_NUM; i++) {
 			if (bcm_static_skb->pkt_use[i] == 0)
 				break;
@@ -646,28 +735,46 @@ osl_pktget_static(osl_t *osh, uint len)
 
 		if (i != STATIC_PKT_MAX_NUM) {
 			bcm_static_skb->pkt_use[i] = 1;
-			up(&bcm_static_skb->osl_pkt_sem);
+
 			skb = bcm_static_skb->skb_4k[i];
 			skb->tail = skb->data + len;
 			skb->len = len;
+
+			up(&bcm_static_skb->osl_pkt_sem);
 			return skb;
 		}
 	}
 
+	if (len <= DHD_SKB_2PAGE_BUFSIZE) {
+		for (i = 0; i < STATIC_PKT_MAX_NUM; i++) {
+			if (bcm_static_skb->pkt_use[i + STATIC_PKT_MAX_NUM]
+				== 0)
+				break;
+		}
+
+		if (i != STATIC_PKT_MAX_NUM) {
+			bcm_static_skb->pkt_use[i + STATIC_PKT_MAX_NUM] = 1;
+			skb = bcm_static_skb->skb_8k[i];
+			skb->tail = skb->data + len;
+			skb->len = len;
 
-	for (i = 0; i < STATIC_PKT_MAX_NUM; i++) {
-		if (bcm_static_skb->pkt_use[i+STATIC_PKT_MAX_NUM] == 0)
-			break;
+			up(&bcm_static_skb->osl_pkt_sem);
+			return skb;
+		}
 	}
 
-	if (i != STATIC_PKT_MAX_NUM) {
-		bcm_static_skb->pkt_use[i+STATIC_PKT_MAX_NUM] = 1;
-		up(&bcm_static_skb->osl_pkt_sem);
-		skb = bcm_static_skb->skb_8k[i];
+#if defined(ENHANCED_STATIC_BUF)
+	if (bcm_static_skb->pkt_use[STATIC_PKT_MAX_NUM * 2] == 0) {
+		bcm_static_skb->pkt_use[STATIC_PKT_MAX_NUM * 2] = 1;
+
+		skb = bcm_static_skb->skb_16k;
 		skb->tail = skb->data + len;
 		skb->len = len;
+
+		up(&bcm_static_skb->osl_pkt_sem);
 		return skb;
 	}
+#endif
 
 	up(&bcm_static_skb->osl_pkt_sem);
 	printk("%s: all static pkt in use!\n", __FUNCTION__);
@@ -678,10 +785,14 @@ void
 osl_pktfree_static(osl_t *osh, void *p, bool send)
 {
 	int i;
+	if (!bcm_static_skb) {
+		osl_pktfree(osh, p, send);
+		return;
+	}
 
+	down(&bcm_static_skb->osl_pkt_sem);
 	for (i = 0; i < STATIC_PKT_MAX_NUM; i++) {
 		if (p == bcm_static_skb->skb_4k[i]) {
-			down(&bcm_static_skb->osl_pkt_sem);
 			bcm_static_skb->pkt_use[i] = 0;
 			up(&bcm_static_skb->osl_pkt_sem);
 			return;
@@ -690,14 +801,20 @@ osl_pktfree_static(osl_t *osh, void *p, bool send)
 
 	for (i = 0; i < STATIC_PKT_MAX_NUM; i++) {
 		if (p == bcm_static_skb->skb_8k[i]) {
-			down(&bcm_static_skb->osl_pkt_sem);
 			bcm_static_skb->pkt_use[i + STATIC_PKT_MAX_NUM] = 0;
 			up(&bcm_static_skb->osl_pkt_sem);
 			return;
 		}
 	}
-
-	return osl_pktfree(osh, p, send);
+#ifdef ENHANCED_STATIC_BUF
+	if (p == bcm_static_skb->skb_16k) {
+		bcm_static_skb->pkt_use[STATIC_PKT_MAX_NUM * 2] = 0;
+		up(&bcm_static_skb->osl_pkt_sem);
+		return;
+	}
+#endif
+	up(&bcm_static_skb->osl_pkt_sem);
+	osl_pktfree(osh, p, send);
 }
 #endif 
 
@@ -757,7 +874,11 @@ osl_pci_slot(osl_t *osh)
 {
 	ASSERT(osh && (osh->magic == OS_HANDLE_MAGIC) && osh->pdev);
 
+#if defined(__ARM_ARCH_7A__) && LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35)
+	return PCI_SLOT(((struct pci_dev *)osh->pdev)->devfn) + 1;
+#else
 	return PCI_SLOT(((struct pci_dev *)osh->pdev)->devfn);
+#endif
 }
 
 
@@ -790,6 +911,7 @@ void *
 osl_malloc(osl_t *osh, uint size)
 {
 	void *addr;
+	gfp_t flags;
 
 	
 	if (osh)
@@ -829,7 +951,12 @@ osl_malloc(osl_t *osh, uint size)
 original:
 #endif 
 
-	if ((addr = kmalloc(size, GFP_ATOMIC)) == NULL) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25))
+	flags = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;
+#else
+	flags = GFP_ATOMIC;
+#endif
+	if ((addr = kmalloc(size, flags)) == NULL) {
 		if (osh)
 			osh->failed++;
 		return (NULL);
@@ -896,6 +1023,7 @@ osl_dma_consistent_align(void)
 void*
 osl_dma_alloc_consistent(osl_t *osh, uint size, uint16 align_bits, uint *alloced, ulong *pap)
 {
+	void *va;
 	uint16 align = (1 << align_bits);
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 
@@ -903,7 +1031,14 @@ osl_dma_alloc_consistent(osl_t *osh, uint size, uint16 align_bits, uint *alloced
 		size += align;
 	*alloced = size;
 
-	return (pci_alloc_consistent(osh->pdev, size, (dma_addr_t*)pap));
+#ifdef __ARM_ARCH_7A__
+	va = kmalloc(size, GFP_ATOMIC | __GFP_ZERO);
+	if (va)
+		*pap = (ulong)__virt_to_phys((ulong)va);
+#else
+	va = pci_alloc_consistent(osh->pdev, size, (dma_addr_t*)pap);
+#endif
+	return va;
 }
 
 void
@@ -911,16 +1046,52 @@ osl_dma_free_consistent(osl_t *osh, void *va, uint size, ulong pa)
 {
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 
+#ifdef __ARM_ARCH_7A__
+	kfree(va);
+#else
 	pci_free_consistent(osh->pdev, size, va, (dma_addr_t)pa);
+#endif
 }
 
 uint BCMFASTPATH
-osl_dma_map(osl_t *osh, void *va, uint size, int direction)
+osl_dma_map(osl_t *osh, void *va, uint size, int direction, void *p, hnddma_seg_map_t *dmah)
 {
 	int dir;
 
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 	dir = (direction == DMA_TX)? PCI_DMA_TODEVICE: PCI_DMA_FROMDEVICE;
+
+#if defined(__ARM_ARCH_7A__) && defined(BCMDMASGLISTOSL)
+	if (dmah != NULL) {
+		int32 nsegs, i, totsegs = 0, totlen = 0;
+		struct scatterlist *sg, _sg[MAX_DMA_SEGS * 2];
+		struct sk_buff *skb;
+		for (skb = (struct sk_buff *)p; skb != NULL; skb = PKTNEXT(osh, skb)) {
+			sg = &_sg[totsegs];
+			if (skb_is_nonlinear(skb)) {
+				nsegs = skb_to_sgvec(skb, sg, 0, PKTLEN(osh, skb));
+				ASSERT((nsegs > 0) && (totsegs + nsegs <= MAX_DMA_SEGS));
+				pci_map_sg(osh->pdev, sg, nsegs, dir);
+			} else {
+				nsegs = 1;
+				ASSERT(totsegs + nsegs <= MAX_DMA_SEGS);
+				sg->page_link = 0;
+				sg_set_buf(sg, PKTDATA(osh, skb), PKTLEN(osh, skb));
+				pci_map_single(osh->pdev, PKTDATA(osh, skb), PKTLEN(osh, skb), dir);
+			}
+			totsegs += nsegs;
+			totlen += PKTLEN(osh, skb);
+		}
+		dmah->nsegs = totsegs;
+		dmah->origsize = totlen;
+		for (i = 0, sg = _sg; i < totsegs; i++, sg++) {
+			dmah->segs[i].addr = sg_phys(sg);
+			dmah->segs[i].length = sg->length;
+		}
+		return dmah->segs[0].addr;
+	}
+#endif 
+
 	return (pci_map_single(osh->pdev, va, size, dir));
 }
 
@@ -952,8 +1123,7 @@ osl_assert(const char *exp, const char *file, int line)
 #ifdef BCMASSERT_LOG
 	snprintf(tempbuf, 64, "\"%s\": file \"%s\", line %d\n",
 		exp, basename, line);
-
-	bcm_assert_log(tempbuf);
+	printk("%s", tempbuf);
 #endif 
 
 
@@ -974,16 +1144,26 @@ osl_delay(uint usec)
 
 
 
+#ifdef BCMDBG_CTRACE
+void *
+osl_pktdup(osl_t *osh, void *skb, int line, char *file)
+#else
 void *
 osl_pktdup(osl_t *osh, void *skb)
+#endif 
 {
 	void * p;
-	unsigned long irqflags;
+
+	ASSERT(!PKTISCHAINED(skb));
 
 	
 	PKTCTFMAP(osh, skb);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+	if ((p = pskb_copy((struct sk_buff *)skb, GFP_ATOMIC)) == NULL)
+#else
 	if ((p = skb_clone((struct sk_buff *)skb, GFP_ATOMIC)) == NULL)
+#endif
 		return NULL;
 
 #ifdef CTFPOOL
@@ -1000,20 +1180,92 @@ osl_pktdup(osl_t *osh, void *skb)
 #endif 
 
 	
+	PKTSETCLINK(p, NULL);
+	PKTCCLRFLAGS(p);
+	PKTCSETCNT(p, 1);
+	PKTCSETLEN(p, PKTLEN(osh, skb));
+
+	
 	if (osh->pub.pkttag)
-		bzero((void*)((struct sk_buff *)p)->cb, OSL_PKTTAG_SZ);
+		OSL_PKTTAG_CLEAR(p);
 
 	
-	spin_lock_irqsave(&osh->pktalloc_lock, irqflags);
-	osh->pub.pktalloced++;
-	spin_unlock_irqrestore(&osh->pktalloc_lock, irqflags);
+	atomic_inc(&osh->pktalloced);
+#ifdef BCMDBG_CTRACE
+	ADD_CTRACE(osh, (struct sk_buff *)p, file, line);
+#endif
 	return (p);
 }
 
+#ifdef BCMDBG_CTRACE
+int osl_pkt_is_frmnative(osl_t *osh, struct sk_buff *pkt)
+{
+	unsigned long flags;
+	struct sk_buff *skb;
+	int ck = FALSE;
 
+	spin_lock_irqsave(&osh->ctrace_lock, flags);
 
+	list_for_each_entry(skb, &osh->ctrace_list, ctrace_list) {
+		if (pkt == skb) {
+			ck = TRUE;
+			break;
+		}
+	}
 
+	spin_unlock_irqrestore(&osh->ctrace_lock, flags);
+	return ck;
+}
+
+void osl_ctrace_dump(osl_t *osh, struct bcmstrbuf *b)
+{
+	unsigned long flags;
+	struct sk_buff *skb;
+	int idx = 0;
+	int i, j;
 
+	spin_lock_irqsave(&osh->ctrace_lock, flags);
+
+	if (b != NULL)
+		bcm_bprintf(b, " Total %d sbk not free\n", osh->ctrace_num);
+	else
+		printk(" Total %d sbk not free\n", osh->ctrace_num);
+
+	list_for_each_entry(skb, &osh->ctrace_list, ctrace_list) {
+		if (b != NULL)
+			bcm_bprintf(b, "[%d] skb %p:\n", ++idx, skb);
+		else
+			printk("[%d] skb %p:\n", ++idx, skb);
+
+		for (i = 0; i < skb->ctrace_count; i++) {
+			j = (skb->ctrace_start + i) % CTRACE_NUM;
+			if (b != NULL)
+				bcm_bprintf(b, "    [%s(%d)]\n", skb->func[j], skb->line[j]);
+			else
+				printk("    [%s(%d)]\n", skb->func[j], skb->line[j]);
+		}
+		if (b != NULL)
+			bcm_bprintf(b, "\n");
+		else
+			printk("\n");
+	}
+
+	spin_unlock_irqrestore(&osh->ctrace_lock, flags);
+
+	return;
+}
+#endif 
+
+
+
+
+
+
+uint
+osl_pktalloced(osl_t *osh)
+{
+	return (atomic_read(&osh->pktalloced));
+}
 
 
 void *
@@ -1051,3 +1303,19 @@ osl_os_close_image(void *image)
 	if (image)
 		filp_close((struct file *)image, NULL);
 }
+
+int
+osl_os_image_size(void *image)
+{
+	int len = 0, curroffset;
+
+	if (image) {
+		
+		curroffset = generic_file_llseek(image, 0, 1);
+		
+		len = generic_file_llseek(image, 0, 2);
+		
+		generic_file_llseek(image, curroffset, 0);
+	}
+	return len;
+}
diff --git a/drivers/net/wireless/bcmdhd/sbutils.c b/drivers/net/wireless/bcmdhd/sbutils.c
old mode 100644
new mode 100755
index 68cfcb2..2c4f7a0
--- a/drivers/net/wireless/bcmdhd/sbutils.c
+++ b/drivers/net/wireless/bcmdhd/sbutils.c
@@ -2,27 +2,9 @@
  * Misc utility routines for accessing chip-specific features
  * of the SiliconBackplane-based Broadcom chips.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: sbutils.c 310902 2012-01-26 19:45:33Z $
+ * $Id: sbutils.c 379512 2013-01-17 22:49:08Z $
  */
 
 #include <bcm_cfg.h>
@@ -510,10 +492,11 @@ _sb_scan(si_info_t *sii, uint32 sba, void *regs, uint bus, uint32 sbba, uint num
 			uint32 ccrev = sb_corerev(&sii->pub);
 
 			/* determine numcores - this is the total # cores in the chip */
-			if (((ccrev == 4) || (ccrev >= 6)))
+			if (((ccrev == 4) || (ccrev >= 6))) {
+				ASSERT(cc);
 				numcores = (R_REG(sii->osh, &cc->chipid) & CID_CC_MASK) >>
 				        CID_CC_SHIFT;
-			else {
+			} else {
 				/* Older chips */
 				uint chip = CHIPID(sii->pub.chip);
 
diff --git a/drivers/net/wireless/bcmdhd/siutils.c b/drivers/net/wireless/bcmdhd/siutils.c
old mode 100644
new mode 100755
index dcd0e38..f8fd660
--- a/drivers/net/wireless/bcmdhd/siutils.c
+++ b/drivers/net/wireless/bcmdhd/siutils.c
@@ -2,27 +2,9 @@
  * Misc utility routines for accessing chip-specific features
  * of the SiliconBackplane-based Broadcom chips.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: siutils.c 328733 2012-04-20 14:49:55Z $
+ * $Id: siutils.c 386309 2013-02-20 06:13:57Z $
  */
 
 #include <bcm_cfg.h>
@@ -45,6 +27,7 @@
 #include <bcmsdpcm.h>
 #include <hndpmu.h>
 
+
 #include "siutils_priv.h"
 
 /* local prototypes */
@@ -106,9 +89,10 @@ si_kattach(osl_t *osh)
 	static bool ksii_attached = FALSE;
 
 	if (!ksii_attached) {
-		void *regs;
+		void *regs = NULL;
 		regs = REG_MAP(SI_ENUM_BASE, SI_CORE_SIZE);
 
+		ASSERT(osh);
 		if (si_doattach(&ksii, BCM4710_DEVICE_ID, osh, regs,
 		                SI_BUS, NULL,
 		                osh != SI_OSH ? &ksii.vars : NULL,
@@ -316,7 +300,8 @@ si_doattach(si_info_t *sii, uint devid, osl_t *osh, void *regs,
 	chipcregs_t *cc;
 	char *pvars = NULL;
 	uint origidx;
-
+#if !defined(_CFEZ_) || defined(CFG_WL)
+#endif 
 	ASSERT(GOODREGS(regs));
 
 	bzero((uchar*)sii, sizeof(si_info_t));
@@ -385,8 +370,12 @@ si_doattach(si_info_t *sii, uint devid, osl_t *osh, void *regs,
 	if (CHIPTYPE(sii->pub.socitype) == SOCI_SB) {
 		SI_MSG(("Found chip type SB (0x%08x)\n", w));
 		sb_scan(&sii->pub, regs, devid);
-	} else if (CHIPTYPE(sii->pub.socitype) == SOCI_AI) {
-		SI_MSG(("Found chip type AI (0x%08x)\n", w));
+	} else if ((CHIPTYPE(sii->pub.socitype) == SOCI_AI) ||
+		(CHIPTYPE(sii->pub.socitype) == SOCI_NAI)) {
+		if (CHIPTYPE(sii->pub.socitype) == SOCI_AI)
+			SI_MSG(("Found chip type AI (0x%08x)\n", w));
+		else
+			SI_MSG(("Found chip type NAI (0x%08x)\n", w));
 		/* pass chipc address instead of original core base */
 		ai_scan(&sii->pub, (void *)(uintptr)cc, devid);
 	} else if (CHIPTYPE(sii->pub.socitype) == SOCI_UBUS) {
@@ -409,6 +398,7 @@ si_doattach(si_info_t *sii, uint devid, osl_t *osh, void *regs,
 		goto exit;
 	}
 
+#if !defined(_CFEZ_) || defined(CFG_WL)
 	if (CHIPID(sih->chip) == BCM4322_CHIP_ID && (((sih->chipst & CST4322_SPROM_OTP_SEL_MASK)
 		>> CST4322_SPROM_OTP_SEL_SHIFT) == (CST4322_OTP_PRESENT |
 		CST4322_SPROM_PRESENT))) {
@@ -437,6 +427,7 @@ si_doattach(si_info_t *sii, uint devid, osl_t *osh, void *regs,
 	if (bustype == PCI_BUS) {
 
 	}
+#endif 
 
 	pvars = NULL;
 	BCM_REFERENCE(pvars);
@@ -555,7 +546,7 @@ si_intflag(si_t *sih)
 
 	if (CHIPTYPE(sih->socitype) == SOCI_SB)
 		return sb_intflag(sih);
-	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
+	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
 		return R_REG(sii->osh, ((uint32 *)(uintptr)
 			    (sii->oob_router + OOB_STATUSA)));
 	else {
@@ -569,7 +560,7 @@ si_flag(si_t *sih)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_SB)
 		return sb_flag(sih);
-	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
+	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
 		return ai_flag(sih);
 	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
 		return ub_flag(sih);
@@ -579,12 +570,23 @@ si_flag(si_t *sih)
 	}
 }
 
+uint
+si_flag_alt(si_t *sih)
+{
+	if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
+		return ai_flag_alt(sih);
+	else {
+		ASSERT(0);
+		return 0;
+	}
+}
+
 void
 si_setint(si_t *sih, int siflag)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_SB)
 		sb_setint(sih, siflag);
-	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
+	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
 		ai_setint(sih, siflag);
 	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
 		ub_setint(sih, siflag);
@@ -641,7 +643,7 @@ si_corevendor(si_t *sih)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_SB)
 		return sb_corevendor(sih);
-	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
+	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
 		return ai_corevendor(sih);
 	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
 		return ub_corevendor(sih);
@@ -662,7 +664,7 @@ si_corerev(si_t *sih)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_SB)
 		return sb_corerev(sih);
-	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
+	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
 		return ai_corerev(sih);
 	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
 		return ub_corerev(sih);
@@ -706,6 +708,18 @@ si_corelist(si_t *sih, uint coreid[])
 	return (sii->numcores);
 }
 
+/* return current wrapper mapping */
+void *
+si_wrapperregs(si_t *sih)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+	ASSERT(GOODREGS(sii->curwrap));
+
+	return (sii->curwrap);
+}
+
 /* return current register mapping */
 void *
 si_coreregs(si_t *sih)
@@ -734,7 +748,7 @@ si_setcore(si_t *sih, uint coreid, uint coreunit)
 
 	if (CHIPTYPE(sih->socitype) == SOCI_SB)
 		return sb_setcoreidx(sih, idx);
-	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
+	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
 		return ai_setcoreidx(sih, idx);
 	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
 		return ub_setcoreidx(sih, idx);
@@ -749,7 +763,7 @@ si_setcoreidx(si_t *sih, uint coreidx)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_SB)
 		return sb_setcoreidx(sih, coreidx);
-	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
+	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
 		return ai_setcoreidx(sih, coreidx);
 	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
 		return ub_setcoreidx(sih, coreidx);
@@ -806,7 +820,7 @@ si_numaddrspaces(si_t *sih)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_SB)
 		return sb_numaddrspaces(sih);
-	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
+	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
 		return ai_numaddrspaces(sih);
 	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
 		return ub_numaddrspaces(sih);
@@ -821,7 +835,7 @@ si_addrspace(si_t *sih, uint asidx)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_SB)
 		return sb_addrspace(sih, asidx);
-	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
+	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
 		return ai_addrspace(sih, asidx);
 	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
 		return ub_addrspace(sih, asidx);
@@ -836,7 +850,7 @@ si_addrspacesize(si_t *sih, uint asidx)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_SB)
 		return sb_addrspacesize(sih, asidx);
-	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
+	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
 		return ai_addrspacesize(sih, asidx);
 	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
 		return ub_addrspacesize(sih, asidx);
@@ -850,7 +864,7 @@ void
 si_coreaddrspaceX(si_t *sih, uint asidx, uint32 *addr, uint32 *size)
 {
 	/* Only supported for SOCI_AI */
-	if (CHIPTYPE(sih->socitype) == SOCI_AI)
+	if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
 		ai_coreaddrspaceX(sih, asidx, addr, size);
 	else
 		*size = 0;
@@ -861,7 +875,7 @@ si_core_cflags(si_t *sih, uint32 mask, uint32 val)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_SB)
 		return sb_core_cflags(sih, mask, val);
-	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
+	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
 		return ai_core_cflags(sih, mask, val);
 	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
 		return ub_core_cflags(sih, mask, val);
@@ -876,7 +890,7 @@ si_core_cflags_wo(si_t *sih, uint32 mask, uint32 val)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_SB)
 		sb_core_cflags_wo(sih, mask, val);
-	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
+	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
 		ai_core_cflags_wo(sih, mask, val);
 	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
 		ub_core_cflags_wo(sih, mask, val);
@@ -889,7 +903,7 @@ si_core_sflags(si_t *sih, uint32 mask, uint32 val)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_SB)
 		return sb_core_sflags(sih, mask, val);
-	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
+	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
 		return ai_core_sflags(sih, mask, val);
 	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
 		return ub_core_sflags(sih, mask, val);
@@ -904,7 +918,7 @@ si_iscoreup(si_t *sih)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_SB)
 		return sb_iscoreup(sih);
-	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
+	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
 		return ai_iscoreup(sih);
 	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
 		return ub_iscoreup(sih);
@@ -918,7 +932,7 @@ uint
 si_wrapperreg(si_t *sih, uint32 offset, uint32 mask, uint32 val)
 {
 	/* only for AI back plane chips */
-	if (CHIPTYPE(sih->socitype) == SOCI_AI)
+	if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
 		return (ai_wrap_reg(sih, offset, mask, val));
 	return 0;
 }
@@ -928,7 +942,7 @@ si_corereg(si_t *sih, uint coreidx, uint regoff, uint mask, uint val)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_SB)
 		return sb_corereg(sih, coreidx, regoff, mask, val);
-	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
+	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
 		return ai_corereg(sih, coreidx, regoff, mask, val);
 	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
 		return ub_corereg(sih, coreidx, regoff, mask, val);
@@ -943,7 +957,7 @@ si_core_disable(si_t *sih, uint32 bits)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_SB)
 		sb_core_disable(sih, bits);
-	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
+	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
 		ai_core_disable(sih, bits);
 	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
 		ub_core_disable(sih, bits);
@@ -954,7 +968,7 @@ si_core_reset(si_t *sih, uint32 bits, uint32 resetbits)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_SB)
 		sb_core_reset(sih, bits, resetbits);
-	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
+	else if ((CHIPTYPE(sih->socitype) == SOCI_AI) || (CHIPTYPE(sih->socitype) == SOCI_NAI))
 		ai_core_reset(sih, bits, resetbits);
 	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
 		ub_core_reset(sih, bits, resetbits);
@@ -1084,6 +1098,7 @@ si_clock_rate(uint32 pll_type, uint32 n, uint32 m)
 }
 
 
+
 /* set chip watchdog reset timer to fire in 'ticks' */
 void
 si_watchdog(si_t *sih, uint ticks)
@@ -1092,6 +1107,7 @@ si_watchdog(si_t *sih, uint ticks)
 
 	if (PMUCTL_ENAB(sih)) {
 
+#if !defined(_CFEZ_) || defined(CFG_WL)
 		if ((CHIPID(sih->chip) == BCM4319_CHIP_ID) &&
 		    (CHIPREV(sih->chiprev) == 0) && (ticks != 0)) {
 			si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, clk_ctl_st), ~0, 0x2);
@@ -1099,6 +1115,7 @@ si_watchdog(si_t *sih, uint ticks)
 			si_core_disable(sih, 1);
 			si_setcore(sih, CC_CORE_ID, 0);
 		}
+#endif 
 
 			nb = (sih->ccrev < 26) ? 16 : ((sih->ccrev >= 37) ? 32 : 24);
 		/* The mips compiler uses the sllv instruction,
@@ -1161,6 +1178,7 @@ si_slowclk_src(si_info_t *sii)
 			return (SCC_SS_XTAL);
 	} else if (sii->pub.ccrev < 10) {
 		cc = (chipcregs_t *)si_setcoreidx(&sii->pub, sii->curidx);
+		ASSERT(cc);
 		return (R_REG(sii->osh, &cc->slow_clk_ctl) & SCC_SS_MASK);
 	} else	/* Insta-clock */
 		return (SCC_SS_XTAL);
@@ -1260,6 +1278,8 @@ si_clkctl_init(si_t *sih)
 
 	si_clkctl_setdelay(sii, (void *)(uintptr)cc);
 
+	OSL_DELAY(20000);
+
 	if (!fast)
 		si_setcoreidx(sih, origidx);
 }
@@ -1927,6 +1947,70 @@ done:
 	return memsize;
 }
 
+
+/* Return the TCM-RAM size of the ARMCR4 core. */
+uint32
+si_tcm_size(si_t *sih)
+{
+	si_info_t *sii;
+	uint origidx;
+	uint intr_val = 0;
+	uint8 *regs;
+	bool wasup;
+	uint32 corecap;
+	uint memsize = 0;
+	uint32 nab = 0;
+	uint32 nbb = 0;
+	uint32 totb = 0;
+	uint32 bxinfo = 0;
+	uint32 idx = 0;
+	uint32 *arm_cap_reg;
+	uint32 *arm_bidx;
+	uint32 *arm_binfo;
+
+	sii = SI_INFO(sih);
+
+	/* Block ints and save current core */
+	INTR_OFF(sii, intr_val);
+	origidx = si_coreidx(sih);
+
+	/* Switch to CR4 core */
+	if (!(regs = si_setcore(sih, ARMCR4_CORE_ID, 0)))
+		goto done;
+
+	/* Get info for determining size. If in reset, come out of reset,
+	 * but remain in halt
+	 */
+	if (!(wasup = si_iscoreup(sih)))
+		si_core_reset(sih, SICF_CPUHALT, SICF_CPUHALT);
+
+	arm_cap_reg = (uint32 *)(regs + SI_CR4_CAP);
+	corecap = R_REG(sii->osh, arm_cap_reg);
+
+	nab = (corecap & ARMCR4_TCBANB_MASK) >> ARMCR4_TCBANB_SHIFT;
+	nbb = (corecap & ARMCR4_TCBBNB_MASK) >> ARMCR4_TCBBNB_SHIFT;
+	totb = nab + nbb;
+
+	arm_bidx = (uint32 *)(regs + SI_CR4_BANKIDX);
+	arm_binfo = (uint32 *)(regs + SI_CR4_BANKINFO);
+	for (idx = 0; idx < totb; idx++) {
+		W_REG(sii->osh, arm_bidx, idx);
+
+		bxinfo = R_REG(sii->osh, arm_binfo);
+		memsize += ((bxinfo & ARMCR4_BSZ_MASK) + 1) * ARMCR4_BSZ_MULT;
+	}
+
+	/* Return to previous state and core */
+	if (!wasup)
+		si_core_disable(sih, 0);
+	si_setcoreidx(sih, origidx);
+
+done:
+	INTR_RESTORE(sii, intr_val);
+
+	return memsize;
+}
+
 uint32
 si_socram_srmem_size(si_t *sih)
 {
@@ -1983,6 +2067,7 @@ done:
 }
 
 
+#if !defined(_CFEZ_) || defined(CFG_WL)
 void
 si_btcgpiowar(si_t *sih)
 {
@@ -2179,6 +2264,7 @@ si_chipcontrl_epa4331_wowl(si_t *sih, bool enter_wowl)
 	}
 	si_setcoreidx(sih, origidx);
 }
+#endif 
 
 uint
 si_pll_reset(si_t *sih)
@@ -2213,6 +2299,12 @@ si_clk_pmu_htavail_set(si_t *sih, bool set_clear)
 {
 }
 
+/* Re-enable synth_pwrsw resource in min_res_mask for 4313 */
+void
+si_pmu_synth_pwrsw_4313_war(si_t *sih)
+{
+}
+
 /* WL/BT control for 4313 btcombo boards >= P250 */
 void
 si_btcombo_p250_4313_war(si_t *sih)
@@ -2304,6 +2396,7 @@ si_is_sprom_available(si_t *sih)
 		sii = SI_INFO(sih);
 		origidx = sii->curidx;
 		cc = si_setcoreidx(sih, SI_CC_IDX);
+		ASSERT(cc);
 		sromctrl = R_REG(sii->osh, &cc->sromcontrol);
 		si_setcoreidx(sih, origidx);
 		return (sromctrl & SRC_PRESENT);
@@ -2342,8 +2435,14 @@ si_is_sprom_available(si_t *sih)
 		return ((sih->chipst & CST43239_SPROM_MASK) &&
 			!(sih->chipst & CST43239_SFLASH_MASK));
 	case BCM4324_CHIP_ID:
+	case BCM43242_CHIP_ID:
 		return ((sih->chipst & CST4324_SPROM_MASK) &&
 			!(sih->chipst & CST4324_SFLASH_MASK));
+	case BCM4335_CHIP_ID:
+		return ((sih->chipst & CST4335_SPROM_MASK) &&
+			!(sih->chipst & CST4335_SFLASH_MASK));
+	case BCM4350_CHIP_ID:
+		return (sih->chipst & CST4350_SPROM_PRESENT) != 0;
 	case BCM43131_CHIP_ID:
 	case BCM43217_CHIP_ID:
 	case BCM43227_CHIP_ID:
@@ -2354,3 +2453,63 @@ si_is_sprom_available(si_t *sih)
 		return TRUE;
 	}
 }
+
+
+uint32 si_get_sromctl(si_t *sih)
+{
+	chipcregs_t *cc;
+	uint origidx;
+	uint32 sromctl;
+	osl_t *osh;
+
+	osh = si_osh(sih);
+	origidx = si_coreidx(sih);
+	cc = si_setcoreidx(sih, SI_CC_IDX);
+	ASSERT((uintptr)cc);
+
+	sromctl = R_REG(osh, &cc->sromcontrol);
+
+	/* return to the original core */
+	si_setcoreidx(sih, origidx);
+	return sromctl;
+}
+
+int si_set_sromctl(si_t *sih, uint32 value)
+{
+	chipcregs_t *cc;
+	uint origidx;
+	osl_t *osh;
+
+	osh = si_osh(sih);
+	origidx = si_coreidx(sih);
+	cc = si_setcoreidx(sih, SI_CC_IDX);
+	ASSERT((uintptr)cc);
+
+	/* get chipcommon rev */
+	if (si_corerev(sih) < 32)
+		return BCME_UNSUPPORTED;
+
+	W_REG(osh, &cc->sromcontrol, value);
+
+	/* return to the original core */
+	si_setcoreidx(sih, origidx);
+	return BCME_OK;
+
+}
+
+uint
+si_core_wrapperreg(si_t *sih, uint32 coreidx, uint32 offset, uint32 mask, uint32 val)
+{
+	uint origidx;
+	uint ret_val;
+
+	origidx = si_coreidx(sih);
+
+	si_setcoreidx(sih, coreidx);
+
+	ret_val = si_wrapperreg(sih, offset, mask, val);
+
+	/* return to the original core */
+	si_setcoreidx(sih, origidx);
+	return ret_val;
+}
diff --git a/drivers/net/wireless/bcmdhd/siutils_priv.h b/drivers/net/wireless/bcmdhd/siutils_priv.h
old mode 100644
new mode 100755
index 9a3270f..9866eb0
--- a/drivers/net/wireless/bcmdhd/siutils_priv.h
+++ b/drivers/net/wireless/bcmdhd/siutils_priv.h
@@ -1,27 +1,9 @@
 /*
  * Include file private to the SOC Interconnect support files.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: siutils_priv.h 309193 2012-01-19 00:03:57Z $
+ * $Id: siutils_priv.h 385510 2013-02-15 21:02:07Z $
  */
 
 #ifndef	_siutils_priv_h_
@@ -146,6 +128,7 @@ typedef struct si_info {
 #define	ILP_DIV_5MHZ		0		/* ILP = 5 MHz */
 #define	ILP_DIV_1MHZ		4		/* ILP = 1 MHz */
 
+/* Force fast clock for 4360b0 */
 #define PCI_FORCEHT(si)	\
 	(((PCIE_GEN1(si)) && (si->pub.chip == BCM4311_CHIP_ID) && ((si->pub.chiprev <= 1))) || \
 	((PCI(si) || PCIE_GEN1(si)) && (si->pub.chip == BCM4321_CHIP_ID)) || \
@@ -203,6 +186,7 @@ extern si_t *ai_kattach(osl_t *osh);
 extern void ai_scan(si_t *sih, void *regs, uint devid);
 
 extern uint ai_flag(si_t *sih);
+extern uint ai_flag_alt(si_t *sih);
 extern void ai_setint(si_t *sih, int siflag);
 extern uint ai_coreidx(si_t *sih);
 extern uint ai_corevendor(si_t *sih);
diff --git a/drivers/net/wireless/bcmdhd/uamp_api.h b/drivers/net/wireless/bcmdhd/uamp_api.h
old mode 100644
new mode 100755
index 673dce0..5a92d52
--- a/drivers/net/wireless/bcmdhd/uamp_api.h
+++ b/drivers/net/wireless/bcmdhd/uamp_api.h
@@ -3,25 +3,7 @@
  *
  *  Description: Universal AMP API
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * $Id: uamp_api.h 294267 2011-11-04 23:41:52Z $
  *
diff --git a/drivers/net/wireless/bcmdhd/wl_android.c b/drivers/net/wireless/bcmdhd/wl_android.c
old mode 100644
new mode 100755
index 850694f..3d81724
--- a/drivers/net/wireless/bcmdhd/wl_android.c
+++ b/drivers/net/wireless/bcmdhd/wl_android.c
@@ -1,27 +1,9 @@
 /*
  * Linux cfg80211 driver - Android related functions
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: wl_android.c 323797 2012-03-27 01:27:20Z $
+ * $Id: wl_android.c 394377 2013-04-02 08:43:51Z $
  */
 
 #include <linux/module.h>
@@ -67,16 +49,34 @@
 #define CMD_BTCOEXSCAN_STOP	"BTCOEXSCAN-STOP"
 #define CMD_BTCOEXMODE		"BTCOEXMODE"
 #define CMD_SETSUSPENDOPT	"SETSUSPENDOPT"
+#define CMD_SETSUSPENDMODE      "SETSUSPENDMODE"
 #define CMD_P2P_DEV_ADDR	"P2P_DEV_ADDR"
 #define CMD_SETFWPATH		"SETFWPATH"
 #define CMD_SETBAND		"SETBAND"
 #define CMD_GETBAND		"GETBAND"
 #define CMD_COUNTRY		"COUNTRY"
 #define CMD_P2P_SET_NOA		"P2P_SET_NOA"
+#if !defined WL_ENABLE_P2P_IF
+#define CMD_P2P_GET_NOA			"P2P_GET_NOA"
+#endif
+#define CMD_P2P_SD_OFFLOAD		"P2P_SD_"
 #define CMD_P2P_SET_PS		"P2P_SET_PS"
 #define CMD_SET_AP_WPS_P2P_IE 		"SET_AP_WPS_P2P_IE"
+#define CMD_SETROAMMODE 	"SETROAMMODE"
+#define CMD_MIRACAST		"MIRACAST"
+
+#if defined(WL_SUPPORT_AUTO_CHANNEL)
+#define CMD_GET_BEST_CHANNELS	"GET_BEST_CHANNELS"
+#endif /* WL_SUPPORT_AUTO_CHANNEL */
 
 
+/* CCX Private Commands */
+#ifdef BCMCCX
+#define CMD_GETCCKM_RN		"get cckm_rn"
+#define CMD_SETCCKM_KRK		"set cckm_krk"
+#define CMD_GET_ASSOC_RES_IES	"get assoc_res_ies"
+#endif
+
 #ifdef PNO_SUPPORT
 #define CMD_PNOSSIDCLR_SET	"PNOSSIDCLR"
 #define CMD_PNOSETUP_SET	"PNOSETUP "
@@ -100,18 +100,58 @@ typedef struct cmd_tlv {
 } cmd_tlv_t;
 #endif /* PNO_SUPPORT */
 
+#define CMD_OKC_SET_PMK		"SET_PMK"
+#define CMD_OKC_ENABLE		"OKC_ENABLE"
+
+#define	CMD_HAPD_MAC_FILTER	"HAPD_MAC_FILTER"
+/* hostap mac mode */
+#define MACLIST_MODE_DISABLED   0
+#define MACLIST_MODE_DENY       1
+#define MACLIST_MODE_ALLOW      2
+
+/* max number of assoc list */
+#define MAX_NUM_OF_ASSOCLIST    64
+
+/* max number of mac filter list
+ * restrict max number to 10 as maximum cmd string size is 255
+ */
+#define MAX_NUM_MAC_FILT        10
+
+
+/* miracast related definition */
+#define MIRACAST_MODE_OFF	0
+#define MIRACAST_MODE_SOURCE	1
+#define MIRACAST_MODE_SINK	2
+
+#ifndef MIRACAST_AMPDU_SIZE
+#define MIRACAST_AMPDU_SIZE	8
+#endif
+
+static LIST_HEAD(miracast_resume_list);
+static u8 miracast_cur_mode;
+
+struct io_cfg {
+	s8 *iovar;
+	s32 param;
+	u32 ioctl;
+	void *arg;
+	u32 len;
+	struct list_head list;
+};
+
 typedef struct android_wifi_priv_cmd {
 	char *buf;
 	int used_len;
 	int total_len;
 } android_wifi_priv_cmd;
 
+
 /**
  * Extern function declarations (TODO: move them to dhd_linux.h)
  */
 void dhd_customer_gpio_wlan_ctrl(int onoff);
-uint dhd_dev_reset(struct net_device *dev, uint8 flag);
-void dhd_dev_init_ioctl(struct net_device *dev);
+int dhd_dev_reset(struct net_device *dev, uint8 flag);
+int dhd_dev_init_ioctl(struct net_device *dev);
 #ifdef WL_CFG80211
 int wl_cfg80211_get_p2p_dev_addr(struct net_device *net, struct ether_addr *p2pdev_addr);
 int wl_cfg80211_set_btcoex_dhcp(struct net_device *dev, char *command);
@@ -124,19 +164,31 @@ int wl_cfg80211_get_p2p_noa(struct net_device *net, char* buf, int len)
 { return 0; }
 int wl_cfg80211_set_p2p_ps(struct net_device *net, char* buf, int len)
 { return 0; }
-#endif
+#endif /* WK_CFG80211 */
 extern int dhd_os_check_if_up(void *dhdp);
+#ifdef BCMLXSDMMC
 extern void *bcmsdh_get_drvdata(void);
-#ifdef PROP_TXSTATUS
+#endif /* BCMLXSDMMC */
+#if defined(PROP_TXSTATUS) && !defined(PROP_TXSTATUS_VSDB)
 extern int dhd_wlfc_init(dhd_pub_t *dhd);
 extern void dhd_wlfc_deinit(dhd_pub_t *dhd);
 #endif
 
+
+#ifdef ENABLE_4335BT_WAR
+extern int bcm_bt_lock(int cookie);
+extern void bcm_bt_unlock(int cookie);
+static int lock_cookie_wifi = 'W' | 'i'<<8 | 'F'<<16 | 'i'<<24;	/* cookie is "WiFi" */
+#endif /* ENABLE_4335BT_WAR */
+
 extern bool ap_fw_loaded;
-#ifdef CUSTOMER_HW2
+#if defined(CUSTOMER_HW2)
 extern char iface_name[IFNAMSIZ];
-#endif
+#endif 
 
+#ifndef WIFI_TURNOFF_DELAY
+#define WIFI_TURNOFF_DELAY	0
+#endif
 /**
  * Local (static) functions and variables
  */
@@ -198,19 +250,39 @@ static int wl_android_set_suspendopt(struct net_device *dev, char *command, int
 	int ret_now;
 	int ret = 0;
 
-	suspend_flag = *(command + strlen(CMD_SETSUSPENDOPT) + 1) - '0';
+		suspend_flag = *(command + strlen(CMD_SETSUSPENDOPT) + 1) - '0';
 
+		if (suspend_flag != 0)
+			suspend_flag = 1;
+		ret_now = net_os_set_suspend_disable(dev, suspend_flag);
+
+		if (ret_now != suspend_flag) {
+			if (!(ret = net_os_set_suspend(dev, ret_now, 1)))
+				DHD_INFO(("%s: Suspend Flag %d -> %d\n",
+					__FUNCTION__, ret_now, suspend_flag));
+			else
+				DHD_ERROR(("%s: failed %d\n", __FUNCTION__, ret));
+		}
+	return ret;
+}
+
+static int wl_android_set_suspendmode(struct net_device *dev, char *command, int total_len)
+{
+	int ret = 0;
+
+#if !defined(CONFIG_HAS_EARLYSUSPEND) || !defined(DHD_USE_EARLYSUSPEND)
+	int suspend_flag;
+
+	suspend_flag = *(command + strlen(CMD_SETSUSPENDMODE) + 1) - '0';
 	if (suspend_flag != 0)
 		suspend_flag = 1;
-	ret_now = net_os_set_suspend_disable(dev, suspend_flag);
 
-	if (ret_now != suspend_flag) {
-		if (!(ret = net_os_set_suspend(dev, ret_now)))
-			DHD_INFO(("%s: Suspend Flag %d -> %d\n",
-				__FUNCTION__, ret_now, suspend_flag));
-		else
-			DHD_ERROR(("%s: failed %d\n", __FUNCTION__, ret));
-	}
+	if (!(ret = net_os_set_suspend(dev, suspend_flag, 0)))
+		DHD_INFO(("%s: Suspend Mode %d\n", __FUNCTION__, suspend_flag));
+	else
+		DHD_ERROR(("%s: failed %d\n", __FUNCTION__, ret));
+#endif
+
 	return ret;
 }
 
@@ -227,7 +299,8 @@ static int wl_android_get_band(struct net_device *dev, char *command, int total_
 	return bytes_written;
 }
 
-#ifdef PNO_SUPPORT
+
+#if defined(PNO_SUPPORT) && !defined(WL_SCHED_SCAN)
 static int wl_android_set_pno_setup(struct net_device *dev, char *command, int total_len)
 {
 	wlc_ssid_t ssids_local[MAX_PFN_LIST_COUNT];
@@ -334,7 +407,7 @@ static int wl_android_set_pno_setup(struct net_device *dev, char *command, int t
 exit_proc:
 	return res;
 }
-#endif /* PNO_SUPPORT */
+#endif /* PNO_SUPPORT && !WL_SCHED_SCAN */
 
 static int wl_android_get_p2p_dev_addr(struct net_device *ndev, char *command, int total_len)
 {
@@ -348,6 +421,215 @@ static int wl_android_get_p2p_dev_addr(struct net_device *ndev, char *command, i
 	return bytes_written;
 }
 
+#ifdef BCMCCX
+static int wl_android_get_cckm_rn(struct net_device *dev, char *command)
+{
+	int error, rn;
+
+	WL_TRACE(("%s:wl_android_get_cckm_rn\n", dev->name));
+
+	error = wldev_iovar_getint(dev, "cckm_rn", &rn);
+	if (unlikely(error)) {
+		WL_ERR(("wl_android_get_cckm_rn error (%d)\n", error));
+		return -1;
+	}
+	memcpy(command, &rn, sizeof(int));
+
+	return sizeof(int);
+}
+
+static int wl_android_set_cckm_krk(struct net_device *dev, char *command)
+{
+	int error;
+	unsigned char key[16];
+	static char iovar_buf[WLC_IOCTL_MEDLEN];
+
+	WL_TRACE(("%s: wl_iw_set_cckm_krk\n", dev->name));
+
+	memset(iovar_buf, 0, sizeof(iovar_buf));
+	memcpy(key, command+strlen("set cckm_krk")+1, 16);
+
+	error = wldev_iovar_setbuf(dev, "cckm_krk", key, sizeof(key),
+		iovar_buf, WLC_IOCTL_MEDLEN, NULL);
+	if (unlikely(error))
+	{
+		WL_ERR((" cckm_krk set error (%d)\n", error));
+		return -1;
+	}
+	return 0;
+}
+
+static int wl_android_get_assoc_res_ies(struct net_device *dev, char *command)
+{
+	int error;
+	u8 buf[WL_ASSOC_INFO_MAX];
+	wl_assoc_info_t assoc_info;
+	u32 resp_ies_len = 0;
+	int bytes_written = 0;
+
+	WL_TRACE(("%s: wl_iw_get_assoc_res_ies\n", dev->name));
+
+	error = wldev_iovar_getbuf(dev, "assoc_info", NULL, 0, buf, WL_ASSOC_INFO_MAX, NULL);
+	if (unlikely(error)) {
+		WL_ERR(("could not get assoc info (%d)\n", error));
+		return -1;
+	}
+
+	memcpy(&assoc_info, buf, sizeof(wl_assoc_info_t));
+	assoc_info.req_len = htod32(assoc_info.req_len);
+	assoc_info.resp_len = htod32(assoc_info.resp_len);
+	assoc_info.flags = htod32(assoc_info.flags);
+
+	if (assoc_info.resp_len) {
+		resp_ies_len = assoc_info.resp_len - sizeof(struct dot11_assoc_resp);
+	}
+
+	/* first 4 bytes are ie len */
+	memcpy(command, &resp_ies_len, sizeof(u32));
+	bytes_written = sizeof(u32);
+
+	/* get the association resp IE's if there are any */
+	if (resp_ies_len) {
+		error = wldev_iovar_getbuf(dev, "assoc_resp_ies", NULL, 0,
+			buf, WL_ASSOC_INFO_MAX, NULL);
+		if (unlikely(error)) {
+			WL_ERR(("could not get assoc resp_ies (%d)\n", error));
+			return -1;
+		}
+
+		memcpy(command+sizeof(u32), buf, resp_ies_len);
+		bytes_written += resp_ies_len;
+	}
+	return bytes_written;
+}
+
+#endif /* BCMCCX */
+
+static int
+wl_android_set_ap_mac_list(struct net_device *dev, int macmode, struct maclist *maclist)
+{
+	int i, j, match;
+	int ret	= 0;
+	char mac_buf[MAX_NUM_OF_ASSOCLIST *
+		sizeof(struct ether_addr) + sizeof(uint)] = {0};
+	struct maclist *assoc_maclist = (struct maclist *)mac_buf;
+
+	/* set filtering mode */
+	if ((ret = wldev_ioctl(dev, WLC_SET_MACMODE, &macmode, sizeof(macmode), true)) != 0) {
+		DHD_ERROR(("%s : WLC_SET_MACMODE error=%d\n", __FUNCTION__, ret));
+		return ret;
+	}
+	if (macmode != MACLIST_MODE_DISABLED) {
+		/* set the MAC filter list */
+		if ((ret = wldev_ioctl(dev, WLC_SET_MACLIST, maclist,
+			sizeof(int) + sizeof(struct ether_addr) * maclist->count, true)) != 0) {
+			DHD_ERROR(("%s : WLC_SET_MACLIST error=%d\n", __FUNCTION__, ret));
+			return ret;
+		}
+		/* get the current list of associated STAs */
+		assoc_maclist->count = MAX_NUM_OF_ASSOCLIST;
+		if ((ret = wldev_ioctl(dev, WLC_GET_ASSOCLIST, assoc_maclist,
+			sizeof(mac_buf), false)) != 0) {
+			DHD_ERROR(("%s : WLC_GET_ASSOCLIST error=%d\n", __FUNCTION__, ret));
+			return ret;
+		}
+		/* do we have any STA associated?  */
+		if (assoc_maclist->count) {
+			/* iterate each associated STA */
+			for (i = 0; i < assoc_maclist->count; i++) {
+				match = 0;
+				/* compare with each entry */
+				for (j = 0; j < maclist->count; j++) {
+					DHD_INFO(("%s : associated="MACDBG " list="MACDBG "\n",
+					__FUNCTION__, MAC2STRDBG(assoc_maclist->ea[i].octet),
+					MAC2STRDBG(maclist->ea[j].octet)));
+					if (memcmp(assoc_maclist->ea[i].octet,
+						maclist->ea[j].octet, ETHER_ADDR_LEN) == 0) {
+						match = 1;
+						break;
+					}
+				}
+				/* do conditional deauth */
+				/*   "if not in the allow list" or "if in the deny list" */
+				if ((macmode == MACLIST_MODE_ALLOW && !match) ||
+					(macmode == MACLIST_MODE_DENY && match)) {
+					scb_val_t scbval;
+
+					scbval.val = htod32(1);
+					memcpy(&scbval.ea, &assoc_maclist->ea[i],
+						ETHER_ADDR_LEN);
+					if ((ret = wldev_ioctl(dev,
+						WLC_SCB_DEAUTHENTICATE_FOR_REASON,
+						&scbval, sizeof(scb_val_t), true)) != 0)
+						DHD_ERROR(("%s WLC_SCB_DEAUTHENTICATE error=%d\n",
+							__FUNCTION__, ret));
+				}
+			}
+		}
+	}
+	return ret;
+}
+
+/*
+ * HAPD_MAC_FILTER mac_mode mac_cnt mac_addr1 mac_addr2
+ *
+ */
+static int
+wl_android_set_mac_address_filter(struct net_device *dev, const char* str)
+{
+	int i;
+	int ret = 0;
+	int macnum = 0;
+	int macmode = MACLIST_MODE_DISABLED;
+	struct maclist *list;
+	char eabuf[ETHER_ADDR_STR_LEN];
+
+	/* string should look like below (macmode/macnum/maclist) */
+	/*   1 2 00:11:22:33:44:55 00:11:22:33:44:ff  */
+
+	/* get the MAC filter mode */
+	macmode = bcm_atoi(strsep((char**)&str, " "));
+
+	if (macmode < MACLIST_MODE_DISABLED || macmode > MACLIST_MODE_ALLOW) {
+		DHD_ERROR(("%s : invalid macmode %d\n", __FUNCTION__, macmode));
+		return -1;
+	}
+
+	macnum = bcm_atoi(strsep((char**)&str, " "));
+	if (macnum < 0 || macnum > MAX_NUM_MAC_FILT) {
+		DHD_ERROR(("%s : invalid number of MAC address entries %d\n",
+			__FUNCTION__, macnum));
+		return -1;
+	}
+	/* allocate memory for the MAC list */
+	list = (struct maclist*)kmalloc(sizeof(int) +
+		sizeof(struct ether_addr) * macnum, GFP_KERNEL);
+	if (!list) {
+		DHD_ERROR(("%s : failed to allocate memory\n", __FUNCTION__));
+		return -1;
+	}
+	/* prepare the MAC list */
+	list->count = htod32(macnum);
+	bzero((char *)eabuf, ETHER_ADDR_STR_LEN);
+	for (i = 0; i < list->count; i++) {
+		strncpy(eabuf, strsep((char**)&str, " "), ETHER_ADDR_STR_LEN - 1);
+		if (!(ret = bcm_ether_atoe(eabuf, &list->ea[i]))) {
+			DHD_ERROR(("%s : mac parsing err index=%d, addr=%s\n",
+				__FUNCTION__, i, eabuf));
+			list->count--;
+			break;
+		}
+		DHD_INFO(("%s : %d/%d MACADDR=%s", __FUNCTION__, i, list->count, eabuf));
+	}
+	/* set the list */
+	if ((ret = wl_android_set_ap_mac_list(dev, macmode, list)) != 0)
+		DHD_ERROR(("%s : Setting MAC list failed error=%d\n", __FUNCTION__, ret));
+
+	kfree(list);
+
+	return 0;
+}
+
 /**
  * Global function definitions (declared in wl_android.h)
  */
@@ -380,8 +662,11 @@ int wl_android_wifi_on(struct net_device *dev)
 		}
 		ret = dhd_dev_reset(dev, FALSE);
 		sdioh_start(NULL, 1);
-		dhd_dev_init_ioctl(dev);
-#ifdef PROP_TXSTATUS
+		if (!ret) {
+			if (dhd_dev_init_ioctl(dev) < 0)
+				ret = -EFAULT;
+		}
+#if defined(PROP_TXSTATUS) && !defined(PROP_TXSTATUS_VSDB) && defined(BCMLXSDMMC)
 		dhd_wlfc_init(bcmsdh_get_drvdata());
 #endif
 		g_wifi_on = TRUE;
@@ -405,10 +690,10 @@ int wl_android_wifi_off(struct net_device *dev)
 
 	dhd_net_if_lock(dev);
 	if (g_wifi_on) {
-#ifdef PROP_TXSTATUS
+#if defined(PROP_TXSTATUS) && !defined(PROP_TXSTATUS_VSDB) && defined(BCMLXSDMMC)
 		dhd_wlfc_deinit(bcmsdh_get_drvdata());
 #endif
-		dhd_dev_reset(dev, 1);
+		ret = dhd_dev_reset(dev, TRUE);
 		sdioh_stop(NULL);
 		dhd_customer_gpio_wlan_ctrl(WLAN_RESET_OFF);
 		g_wifi_on = FALSE;
@@ -434,8 +719,218 @@ static int wl_android_set_fwpath(struct net_device *net, char *command, int tota
 	return 0;
 }
 
+
+static int
+wl_android_set_pmk(struct net_device *dev, char *command, int total_len)
+{
+	uchar pmk[33];
+	int error = 0;
+	char smbuf[WLC_IOCTL_SMLEN];
+#ifdef OKC_DEBUG
+	int i = 0;
+#endif
+
+	bzero(pmk, sizeof(pmk));
+	memcpy((char *)pmk, command + strlen("SET_PMK "), 32);
+	error = wldev_iovar_setbuf(dev, "okc_info_pmk", pmk, 32, smbuf, sizeof(smbuf), NULL);
+	if (error) {
+		DHD_ERROR(("Failed to set PMK for OKC, error = %d\n", error));
+	}
+#ifdef OKC_DEBUG
+	DHD_ERROR(("PMK is "));
+	for (i = 0; i < 32; i++)
+		DHD_ERROR(("%02X ", pmk[i]));
+
+	DHD_ERROR(("\n"));
+#endif
+	return error;
+}
+
+static int
+wl_android_okc_enable(struct net_device *dev, char *command, int total_len)
+{
+	int error = 0;
+	char okc_enable = 0;
+
+	okc_enable = command[strlen(CMD_OKC_ENABLE) + 1] - '0';
+	error = wldev_iovar_setint(dev, "okc_enable", okc_enable);
+	if (error) {
+		DHD_ERROR(("Failed to %s OKC, error = %d\n",
+			okc_enable ? "enable" : "disable", error));
+	}
+
+	wldev_iovar_setint(dev, "ccx_enable", 0);
+
+	return error;
+}
+
+
+
+int wl_android_set_roam_mode(struct net_device *dev, char *command, int total_len)
+{
+	int error = 0;
+	int mode = 0;
+
+	if (sscanf(command, "%*s %d", &mode) != 1) {
+		DHD_ERROR(("%s: Failed to get Parameter\n", __FUNCTION__));
+		return -1;
+	}
+
+	error = wldev_iovar_setint(dev, "roam_off", mode);
+	if (error) {
+		DHD_ERROR(("%s: Failed to set roaming Mode %d, error = %d\n",
+		__FUNCTION__, mode, error));
+		return -1;
+	}
+	else
+		DHD_ERROR(("%s: succeeded to set roaming Mode %d, error = %d\n",
+		__FUNCTION__, mode, error));
+	return 0;
+}
+
+static int
+wl_android_iolist_add(struct net_device *dev, struct list_head *head, struct io_cfg *config)
+{
+	struct io_cfg *resume_cfg;
+	s32 ret;
+
+	resume_cfg = kzalloc(sizeof(struct io_cfg), GFP_KERNEL);
+	if (!resume_cfg)
+		return -ENOMEM;
+
+	if (config->iovar) {
+		ret = wldev_iovar_getint(dev, config->iovar, &resume_cfg->param);
+		if (ret) {
+			DHD_ERROR(("%s: Failed to get current %s value\n",
+				__FUNCTION__, config->iovar));
+			goto error;
+		}
+
+		ret = wldev_iovar_setint(dev, config->iovar, config->param);
+		if (ret) {
+			DHD_ERROR(("%s: Failed to set %s to %d\n", __FUNCTION__,
+				config->iovar, config->param));
+			goto error;
+		}
+
+		resume_cfg->iovar = config->iovar;
+	} else {
+		resume_cfg->arg = kzalloc(config->len, GFP_KERNEL);
+		if (!resume_cfg->arg) {
+			ret = -ENOMEM;
+			goto error;
+		}
+		ret = wldev_ioctl(dev, config->ioctl, resume_cfg->arg, config->len, false);
+		if (ret) {
+			DHD_ERROR(("%s: Failed to get ioctl %d\n", __FUNCTION__,
+				config->ioctl));
+			goto error;
+		}
+		ret = wldev_ioctl(dev, config->ioctl + 1, config->arg, config->len, true);
+		if (ret) {
+			DHD_ERROR(("%s: Failed to set %s to %d\n", __FUNCTION__,
+				config->iovar, config->param));
+			goto error;
+		}
+		if (config->ioctl + 1 == WLC_SET_PM)
+			wl_cfg80211_update_power_mode(dev);
+		resume_cfg->ioctl = config->ioctl;
+		resume_cfg->len = config->len;
+	}
+
+	list_add(&resume_cfg->list, head);
+
+	return 0;
+error:
+	kfree(resume_cfg->arg);
+	kfree(resume_cfg);
+	return ret;
+}
+
+static void
+wl_android_iolist_resume(struct net_device *dev, struct list_head *head)
+{
+	struct io_cfg *config;
+	struct list_head *cur, *q;
+
+	list_for_each_safe(cur, q, head) {
+		config = list_entry(cur, struct io_cfg, list);
+		if (config->iovar) {
+			wldev_iovar_setint(dev, config->iovar, config->param);
+		} else {
+			wldev_ioctl(dev, config->ioctl + 1, config->arg, config->len, true);
+			if (config->ioctl + 1 == WLC_SET_PM)
+				wl_cfg80211_update_power_mode(dev);
+			kfree(config->arg);
+		}
+		list_del(cur);
+		kfree(config);
+	}
+}
+
+static int
+wl_android_set_miracast(struct net_device *dev, char *command, int total_len)
+{
+	int mode, val;
+	int ret = 0;
+	struct io_cfg config;
+
+	if (sscanf(command, "%*s %d", &mode) != 1) {
+		DHD_ERROR(("%s: Failed to get Parameter\n", __FUNCTION__));
+		return -1;
+	}
+
+	DHD_INFO(("%s: enter miracast mode %d\n", __FUNCTION__, mode));
+
+	if (miracast_cur_mode == mode)
+		return 0;
+
+	wl_android_iolist_resume(dev, &miracast_resume_list);
+	miracast_cur_mode = MIRACAST_MODE_OFF;
+
+	switch (mode) {
+	case MIRACAST_MODE_SOURCE:
+		/* setting apmdu to platform specific value */
+		config.iovar = "ampdu_mpdu";
+		config.param = MIRACAST_AMPDU_SIZE;
+		ret = wl_android_iolist_add(dev, &miracast_resume_list, &config);
+		if (ret)
+			goto resume;
+	case MIRACAST_MODE_SINK:
+		/* disable internal roaming */
+		config.iovar = "roam_off";
+		config.param = 1;
+		ret = wl_android_iolist_add(dev, &miracast_resume_list, &config);
+		if (ret)
+			goto resume;
+		/* tunr off pm */
+		val = 0;
+		config.iovar = NULL;
+		config.ioctl = WLC_GET_PM;
+		config.arg = &val;
+		config.len = sizeof(int);
+		ret = wl_android_iolist_add(dev, &miracast_resume_list, &config);
+		if (ret)
+			goto resume;
+
+		break;
+	case MIRACAST_MODE_OFF:
+	default:
+		break;
+	}
+	miracast_cur_mode = mode;
+
+	return 0;
+
+resume:
+	DHD_ERROR(("%s: turnoff miracast mode because of err%d\n", __FUNCTION__, ret));
+	wl_android_iolist_resume(dev, &miracast_resume_list);
+	return ret;
+}
+
 int wl_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 {
+#define PRIVATE_COMMAND_MAX_LEN	8192
 	int ret = 0;
 	char *command = NULL;
 	int bytes_written = 0;
@@ -451,7 +946,13 @@ int wl_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		ret = -EFAULT;
 		goto exit;
 	}
-	command = kmalloc(priv_cmd.total_len, GFP_KERNEL);
+	if (priv_cmd.total_len > PRIVATE_COMMAND_MAX_LEN)
+	{
+		DHD_ERROR(("%s: too long priavte command\n", __FUNCTION__));
+		ret = -EINVAL;
+		goto exit;
+	}
+	command = kmalloc((priv_cmd.total_len + 1), GFP_KERNEL);
 	if (!command)
 	{
 		DHD_ERROR(("%s: failed to allocate memory\n", __FUNCTION__));
@@ -462,6 +963,7 @@ int wl_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		ret = -EFAULT;
 		goto exit;
 	}
+	command[priv_cmd.total_len] = '\0';
 
 	DHD_INFO(("%s: Android private cmd \"%s\" on %s\n", __FUNCTION__, command, ifr->ifr_name));
 
@@ -495,11 +997,12 @@ int wl_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 	else if (strnicmp(command, CMD_LINKSPEED, strlen(CMD_LINKSPEED)) == 0) {
 		bytes_written = wl_android_get_link_speed(net, command, priv_cmd.total_len);
 	}
+#ifdef PKT_FILTER_SUPPORT
 	else if (strnicmp(command, CMD_RXFILTER_START, strlen(CMD_RXFILTER_START)) == 0) {
-		bytes_written = net_os_set_packet_filter(net, 1);
+		bytes_written = net_os_enable_packet_filter(net, 1);
 	}
 	else if (strnicmp(command, CMD_RXFILTER_STOP, strlen(CMD_RXFILTER_STOP)) == 0) {
-		bytes_written = net_os_set_packet_filter(net, 0);
+		bytes_written = net_os_enable_packet_filter(net, 0);
 	}
 	else if (strnicmp(command, CMD_RXFILTER_ADD, strlen(CMD_RXFILTER_ADD)) == 0) {
 		int filter_num = *(command + strlen(CMD_RXFILTER_ADD) + 1) - '0';
@@ -509,6 +1012,7 @@ int wl_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		int filter_num = *(command + strlen(CMD_RXFILTER_REMOVE) + 1) - '0';
 		bytes_written = net_os_rxfilter_add_remove(net, FALSE, filter_num);
 	}
+#endif /* PKT_FILTER_SUPPORT */
 	else if (strnicmp(command, CMD_BTCOEXSCAN_START, strlen(CMD_BTCOEXSCAN_START)) == 0) {
 		/* TBD: BTCOEXSCAN-START */
 	}
@@ -516,31 +1020,58 @@ int wl_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		/* TBD: BTCOEXSCAN-STOP */
 	}
 	else if (strnicmp(command, CMD_BTCOEXMODE, strlen(CMD_BTCOEXMODE)) == 0) {
+#ifdef WL_CFG80211
+		bytes_written = wl_cfg80211_set_btcoex_dhcp(net, command);
+#else
+#ifdef PKT_FILTER_SUPPORT
 		uint mode = *(command + strlen(CMD_BTCOEXMODE) + 1) - '0';
 
 		if (mode == 1)
-			net_os_set_packet_filter(net, 0); /* DHCP starts */
+			net_os_enable_packet_filter(net, 0); /* DHCP starts */
 		else
-			net_os_set_packet_filter(net, 1); /* DHCP ends */
-#ifdef WL_CFG80211
-		bytes_written = wl_cfg80211_set_btcoex_dhcp(net, command);
-#endif
+			net_os_enable_packet_filter(net, 1); /* DHCP ends */
+#endif /* PKT_FILTER_SUPPORT */
+#endif /* WL_CFG80211 */
 	}
 	else if (strnicmp(command, CMD_SETSUSPENDOPT, strlen(CMD_SETSUSPENDOPT)) == 0) {
 		bytes_written = wl_android_set_suspendopt(net, command, priv_cmd.total_len);
 	}
+	else if (strnicmp(command, CMD_SETSUSPENDMODE, strlen(CMD_SETSUSPENDMODE)) == 0) {
+		bytes_written = wl_android_set_suspendmode(net, command, priv_cmd.total_len);
+	}
 	else if (strnicmp(command, CMD_SETBAND, strlen(CMD_SETBAND)) == 0) {
 		uint band = *(command + strlen(CMD_SETBAND) + 1) - '0';
+#ifdef WL_HOST_BAND_MGMT
+		s32 ret = 0;
+		if ((ret = wl_cfg80211_set_band(net, band)) < 0) {
+			if (ret == BCME_UNSUPPORTED) {
+				/* If roam_var is unsupported, fallback to the original method */
+				WL_ERR(("WL_HOST_BAND_MGMT defined, "
+					"but roam_band iovar unsupported in the firmware\n"));
+			} else {
+				bytes_written = -1;
+				goto exit;
+			}
+		}
+		if ((band == WLC_BAND_AUTO) || (ret == BCME_UNSUPPORTED))
+			bytes_written = wldev_set_band(net, band);
+#else
 		bytes_written = wldev_set_band(net, band);
+#endif /* WL_HOST_BAND_MGMT */
 	}
 	else if (strnicmp(command, CMD_GETBAND, strlen(CMD_GETBAND)) == 0) {
 		bytes_written = wl_android_get_band(net, command, priv_cmd.total_len);
 	}
+#ifdef WL_CFG80211
+	/* CUSTOMER_SET_COUNTRY feature is define for only GGSM model */
 	else if (strnicmp(command, CMD_COUNTRY, strlen(CMD_COUNTRY)) == 0) {
 		char *country_code = command + strlen(CMD_COUNTRY) + 1;
-		bytes_written = wldev_set_country(net, country_code);
+		bytes_written = wldev_set_country(net, country_code, true, true);
 	}
-#ifdef PNO_SUPPORT
+#endif /* WL_CFG80211 */
+
+
+#if defined(PNO_SUPPORT) && !defined(WL_SCHED_SCAN)
 	else if (strnicmp(command, CMD_PNOSSIDCLR_SET, strlen(CMD_PNOSSIDCLR_SET)) == 0) {
 		bytes_written = dhd_dev_pno_reset(net);
 	}
@@ -551,7 +1082,7 @@ int wl_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		uint pfn_enabled = *(command + strlen(CMD_PNOENABLE_SET) + 1) - '0';
 		bytes_written = dhd_dev_pno_enable(net, pfn_enabled);
 	}
-#endif
+#endif /* PNO_SUPPORT && !WL_SCHED_SCAN */
 	else if (strnicmp(command, CMD_P2P_DEV_ADDR, strlen(CMD_P2P_DEV_ADDR)) == 0) {
 		bytes_written = wl_android_get_p2p_dev_addr(net, command, priv_cmd.total_len);
 	}
@@ -560,6 +1091,11 @@ int wl_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		bytes_written = wl_cfg80211_set_p2p_noa(net, command + skip,
 			priv_cmd.total_len - skip);
 	}
+#if !defined WL_ENABLE_P2P_IF
+	else if (strnicmp(command, CMD_P2P_GET_NOA, strlen(CMD_P2P_GET_NOA)) == 0) {
+		bytes_written = wl_cfg80211_get_p2p_noa(net, command, priv_cmd.total_len);
+	}
+#endif /* WL_ENABLE_P2P_IF */
 	else if (strnicmp(command, CMD_P2P_SET_PS, strlen(CMD_P2P_SET_PS)) == 0) {
 		int skip = strlen(CMD_P2P_SET_PS) + 1;
 		bytes_written = wl_cfg80211_set_p2p_ps(net, command + skip,
@@ -573,6 +1109,36 @@ int wl_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 			priv_cmd.total_len - skip, *(command + skip - 2) - '0');
 	}
 #endif /* WL_CFG80211 */
+	else if (strnicmp(command, CMD_OKC_SET_PMK, strlen(CMD_OKC_SET_PMK)) == 0)
+		bytes_written = wl_android_set_pmk(net, command, priv_cmd.total_len);
+	else if (strnicmp(command, CMD_OKC_ENABLE, strlen(CMD_OKC_ENABLE)) == 0)
+		bytes_written = wl_android_okc_enable(net, command, priv_cmd.total_len);
+#ifdef BCMCCX
+	else if (strnicmp(command, CMD_GETCCKM_RN, strlen(CMD_GETCCKM_RN)) == 0) {
+		bytes_written = wl_android_get_cckm_rn(net, command);
+	}
+	else if (strnicmp(command, CMD_SETCCKM_KRK, strlen(CMD_SETCCKM_KRK)) == 0) {
+		bytes_written = wl_android_set_cckm_krk(net, command);
+	}
+	else if (strnicmp(command, CMD_GET_ASSOC_RES_IES, strlen(CMD_GET_ASSOC_RES_IES)) == 0) {
+		bytes_written = wl_android_get_assoc_res_ies(net, command);
+	}
+#endif /* BCMCCX */
+#if defined(WL_SUPPORT_AUTO_CHANNEL)
+	else if (strnicmp(command, CMD_GET_BEST_CHANNELS,
+		strlen(CMD_GET_BEST_CHANNELS)) == 0) {
+		bytes_written = wl_cfg80211_get_best_channels(net, command,
+			priv_cmd.total_len);
+	}
+#endif /* WL_SUPPORT_AUTO_CHANNEL */
+	else if (strnicmp(command, CMD_HAPD_MAC_FILTER, strlen(CMD_HAPD_MAC_FILTER)) == 0) {
+		int skip = strlen(CMD_HAPD_MAC_FILTER) + 1;
+		wl_android_set_mac_address_filter(net, (const char*)command+skip);
+	}
+	else if (strnicmp(command, CMD_SETROAMMODE, strlen(CMD_SETROAMMODE)) == 0)
+		bytes_written = wl_android_set_roam_mode(net, command, priv_cmd.total_len);
+	else if (strnicmp(command, CMD_MIRACAST, strlen(CMD_MIRACAST)) == 0)
+		bytes_written = wl_android_set_miracast(net, command, priv_cmd.total_len);
 	else {
 		DHD_ERROR(("Unknown PRIVATE command %s - ignored\n", command));
 		snprintf(command, 3, "OK");
@@ -614,12 +1180,14 @@ int wl_android_init(void)
 #ifdef ENABLE_INSMOD_NO_FW_LOAD
 	dhd_download_fw_on_driverload = FALSE;
 #endif /* ENABLE_INSMOD_NO_FW_LOAD */
-#ifdef CUSTOMER_HW2
+#if defined(CUSTOMER_HW2)
 	if (!iface_name[0]) {
 		memset(iface_name, 0, IFNAMSIZ);
 		bcm_strncpy_s(iface_name, IFNAMSIZ, "wlan", IFNAMSIZ);
 	}
-#endif /* CUSTOMER_HW2 */
+#endif 
+
+
 	return ret;
 }
 
@@ -627,22 +1195,32 @@ int wl_android_exit(void)
 {
 	int ret = 0;
 
+
 	return ret;
 }
 
 void wl_android_post_init(void)
 {
+
+#ifdef ENABLE_4335BT_WAR
+	bcm_bt_unlock(lock_cookie_wifi);
+	printk("%s: btlock released\n", __FUNCTION__);
+#endif /* ENABLE_4335BT_WAR */
+
 	if (!dhd_download_fw_on_driverload) {
 		/* Call customer gpio to turn off power with WL_REG_ON signal */
 		dhd_customer_gpio_wlan_ctrl(WLAN_RESET_OFF);
 		g_wifi_on = 0;
 	}
 }
+
+
 /**
  * Functions for Android WiFi card detection
  */
 #if defined(CONFIG_WIFI_CONTROL_FUNC)
 
+bool g_wifi_poweron = FALSE;
 static int g_wifidev_registered = 0;
 static struct semaphore wifi_control_sem;
 static struct wifi_platform_data *wifi_control_data = NULL;
@@ -713,13 +1291,27 @@ int wifi_get_irq_number(unsigned long *irq_flags_ptr)
 
 int wifi_set_power(int on, unsigned long msec)
 {
+	int ret = 0;
 	DHD_ERROR(("%s = %d\n", __FUNCTION__, on));
 	if (wifi_control_data && wifi_control_data->set_power) {
-		wifi_control_data->set_power(on);
+#ifdef ENABLE_4335BT_WAR
+		if (on) {
+			printk("WiFi: trying to acquire BT lock\n");
+			if (bcm_bt_lock(lock_cookie_wifi) != 0)
+				printk("** WiFi: timeout in acquiring bt lock**\n");
+			printk("%s: btlock acquired\n", __FUNCTION__);
+		}
+		else {
+			/* For a exceptional case, release btlock */
+			bcm_bt_unlock(lock_cookie_wifi);
+		}
+#endif /* ENABLE_4335BT_WAR */
+		ret = wifi_control_data->set_power(on);
 	}
-	if (msec)
+
+	if (msec && !ret)
 		msleep(msec);
-	return 0;
+	return ret;
 }
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
@@ -759,6 +1351,7 @@ static int wifi_set_carddetect(int on)
 
 static int wifi_probe(struct platform_device *pdev)
 {
+	int err;
 	struct wifi_platform_data *wifi_ctrl =
 		(struct wifi_platform_data *)(pdev->dev.platform_data);
 
@@ -767,8 +1360,15 @@ static int wifi_probe(struct platform_device *pdev)
 		wifi_irqres = platform_get_resource_byname(pdev,
 			IORESOURCE_IRQ, "bcm4329_wlan_irq");
 	wifi_control_data = wifi_ctrl;
-	wifi_set_power(1, 0);	/* Power On */
-	wifi_set_carddetect(1);	/* CardDetect (0->1) */
+	err = wifi_set_power(1, 200);	/* Power On */
+	if (unlikely(err)) {
+		DHD_ERROR(("%s: set_power failed. err=%d\n", __FUNCTION__, err));
+		wifi_set_power(0, WIFI_TURNOFF_DELAY);
+		/* WL_REG_ON state unknown, Power off forcely */
+	} else {
+		wifi_set_carddetect(1);	/* CardDetect (0->1) */
+		g_wifi_poweron = TRUE;
+	}
 
 	up(&wifi_control_sem);
 	return 0;
@@ -782,8 +1382,11 @@ static int wifi_remove(struct platform_device *pdev)
 	DHD_ERROR(("## %s\n", __FUNCTION__));
 	wifi_control_data = wifi_ctrl;
 
-	wifi_set_power(0, 0);	/* Power Off */
+	if (g_wifi_poweron) {
+	wifi_set_power(0, WIFI_TURNOFF_DELAY);	/* Power Off */
 	wifi_set_carddetect(0);	/* CardDetect (1->0) */
+		g_wifi_poweron = FALSE;
+	}
 
 	up(&wifi_control_sem);
 	return 0;
@@ -830,10 +1433,14 @@ static struct platform_driver wifi_device_legacy = {
 
 static int wifi_add_dev(void)
 {
+	int ret = 0;
 	DHD_TRACE(("## Calling platform_driver_register\n"));
-	platform_driver_register(&wifi_device);
-	platform_driver_register(&wifi_device_legacy);
-	return 0;
+	ret = platform_driver_register(&wifi_device);
+	if (ret)
+		return ret;
+
+	ret = platform_driver_register(&wifi_device_legacy);
+	return ret;
 }
 
 static void wifi_del_dev(void)
diff --git a/drivers/net/wireless/bcmdhd/wl_android.h b/drivers/net/wireless/bcmdhd/wl_android.h
old mode 100644
new mode 100755
index 583a167..1c5d6a8
--- a/drivers/net/wireless/bcmdhd/wl_android.h
+++ b/drivers/net/wireless/bcmdhd/wl_android.h
@@ -1,33 +1,21 @@
 /*
  * Linux cfg80211 driver - Android related functions
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: wl_android.h 307885 2012-01-12 23:30:48Z $
+ * $Id: wl_android.h 367305 2012-11-07 13:49:55Z $
  */
 
 #include <linux/module.h>
 #include <linux/netdevice.h>
 #include <wldev_common.h>
 
+/* If any feature uses the Generic Netlink Interface, put it here to enable WL_GENL
+ * automatically
+ */
+
+
+
 /**
  * Android platform dependent functions, feel free to add Android specific functions here
  * (save the macros in dhd). Please do NOT declare functions that are NOT exposed to dhd
diff --git a/drivers/net/wireless/bcmdhd/wl_cfg80211.c b/drivers/net/wireless/bcmdhd/wl_cfg80211.c
old mode 100644
new mode 100755
index 40f1b2c..e0e3f49
--- a/drivers/net/wireless/bcmdhd/wl_cfg80211.c
+++ b/drivers/net/wireless/bcmdhd/wl_cfg80211.c
@@ -1,29 +1,11 @@
 /*
  * Linux cfg80211 driver
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: wl_cfg80211.c 328984 2012-04-23 14:08:37Z $
+ * $Id: wl_cfg80211.c 395173 2013-04-05 17:27:36Z $
  */
-
+/* */
 #include <typedefs.h>
 #include <linuxver.h>
 #include <osl.h>
@@ -59,6 +41,17 @@
 #include <wldev_common.h>
 #include <wl_cfg80211.h>
 #include <wl_cfgp2p.h>
+#include <wl_android.h>
+
+#ifdef PROP_TXSTATUS
+#include <dhd_wlfc.h>
+#endif
+
+#ifdef WL11U
+#ifndef WL_ENABLE_P2P_IF
+#error "You should enable WL_ENABLE_P2P_IF and Only supported in JB"
+#endif
+#endif /* WL11U */
 
 #ifdef BCMWAPI_WPI
 /* these items should evetually go into wireless.h of the linux system headfile dir */
@@ -93,19 +86,41 @@
 #define IW_WSEC_ENABLED(wsec)   ((wsec) & (WEP_ENABLED | TKIP_ENABLED | AES_ENABLED))
 #endif /* BCMWAPI_WPI */
 
-
 static struct device *cfg80211_parent_dev = NULL;
-static int vsdb_supported = 0;
 struct wl_priv *wlcfg_drv_priv = NULL;
-
+/* patch for roam fail */
+static u8 ap_resp_ie[256];
+static int ap_resp_ie_len = 0;
 u32 wl_dbg_level = WL_DBG_ERR;
 
-#define MAC2STR(a) (a)[0], (a)[1], (a)[2], (a)[3], (a)[4], (a)[5]
-#define MACSTR "%02x:%02x:%02x:%02x:%02x:%02x"
 #define MAX_WAIT_TIME 1500
-#define WL_SCAN_ACTIVE_TIME	 40 /* ms : Embedded default Active setting from DHD Driver */
-#define WL_SCAN_PASSIVE_TIME	130 /* ms: Embedded default Passive setting from DHD Driver */
-#define WL_FRAME_LEN			300
+
+#ifdef VSDB
+/* sleep time to keep STA's connecting or connection for continuous af tx or finding a peer */
+#define DEFAULT_SLEEP_TIME_VSDB 	120
+#define OFF_CHAN_TIME_THRESHOLD_MS	200
+#define AF_RETRY_DELAY_TIME     40
+
+/* if sta is connected or connecting, sleep for a while before retry af tx or finding a peer */
+#define WL_AF_TX_KEEP_PRI_CONNECTION_VSDB(wl)	\
+	do {	\
+		if (wl_get_drv_status(wl, CONNECTED, wl_to_prmry_ndev(wl)) ||	\
+			wl_get_drv_status(wl, CONNECTING, wl_to_prmry_ndev(wl))) {	\
+			msleep(DEFAULT_SLEEP_TIME_VSDB);	\
+		}	\
+	} while (0)
+#else /* VSDB */
+/* if not VSDB, do nothing */
+#define WL_AF_TX_KEEP_PRI_CONNECTION_VSDB(wl)
+#endif /* VSDB */
+
+#ifdef WL_CFG80211_SYNC_GON
+#define WL_DRV_STATUS_SENDING_AF_FRM_EXT(wl) \
+	(wl_get_drv_status_all(wl, SENDING_ACT_FRM) || \
+		wl_get_drv_status_all(wl, WAITING_NEXT_ACT_FRM_LISTEN))
+#else
+#define WL_DRV_STATUS_SENDING_AF_FRM_EXT(wl) wl_get_drv_status_all(wl, SENDING_ACT_FRM)
+#endif /* WL_CFG80211_SYNC_GON */
 
 #define WL_CHANSPEC_CTL_SB_NONE WL_CHANSPEC_CTL_SB_LLL
 
@@ -113,6 +128,10 @@ u32 wl_dbg_level = WL_DBG_ERR;
 #define DNGL_FUNC(func, parameters) func parameters;
 #define COEX_DHCP
 
+#define WLAN_EID_SSID	0
+#define CH_MIN_5G_CHANNEL 34
+#define CH_MIN_2G_CHANNEL 1
+
 /* This is to override regulatory domains defined in cfg80211 module (reg.c)
  * By default world regulatory domain defined in reg.c puts the flags NL80211_RRF_PASSIVE_SCAN
  * and NL80211_RRF_NO_IBSS for 5GHz channels (for 36..48 and 149..165).
@@ -120,30 +139,69 @@ u32 wl_dbg_level = WL_DBG_ERR;
  * All the chnages in world regulatory domain are to be done here.
  */
 static const struct ieee80211_regdomain brcm_regdom = {
-	.n_reg_rules = 5,
+	.n_reg_rules = 4,
 	.alpha2 =  "99",
 	.reg_rules = {
 		/* IEEE 802.11b/g, channels 1..11 */
-		REG_RULE(2412-10, 2462+10, 40, 6, 20, 0),
-		/* IEEE 802.11b/g, channels 12..13. No HT40
-		 * channel fits here.
-		 */
-		REG_RULE(2467-10, 2472+10, 20, 6, 20,
-		NL80211_RRF_PASSIVE_SCAN |
-		NL80211_RRF_NO_IBSS),
+		REG_RULE(2412-10, 2472+10, 40, 6, 20, 0),
+		/* If any */
 		/* IEEE 802.11 channel 14 - Only JP enables
 		 * this and for 802.11b only
 		 */
-		REG_RULE(2484-10, 2484+10, 20, 6, 20,
-		NL80211_RRF_PASSIVE_SCAN |
-		NL80211_RRF_NO_IBSS |
-		NL80211_RRF_NO_OFDM),
+		REG_RULE(2484-10, 2484+10, 20, 6, 20, 0),
 		/* IEEE 802.11a, channel 36..64 */
 		REG_RULE(5150-10, 5350+10, 40, 6, 20, 0),
 		/* IEEE 802.11a, channel 100..165 */
 		REG_RULE(5470-10, 5850+10, 40, 6, 20, 0), }
 };
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)) && \
+	(defined(WL_IFACE_COMB_NUM_CHANNELS) || defined(WL_CFG80211_P2P_DEV_IF))
+static const struct ieee80211_iface_limit softap_limits[] = {
+	{
+	.max = 1,
+	.types = BIT(NL80211_IFTYPE_AP),
+	},
+};
+static const struct ieee80211_iface_limit sta_p2p_limits[] = {
+	{
+	.max = 2,
+	.types = BIT(NL80211_IFTYPE_STATION),
+	},
+	{
+	.max = 2,
+	.types = BIT(NL80211_IFTYPE_P2P_GO) | BIT(NL80211_IFTYPE_P2P_CLIENT),
+	},
+#if defined(WL_CFG80211_P2P_DEV_IF)
+	{
+	.max = 1,
+	.types = BIT(NL80211_IFTYPE_P2P_DEVICE),
+	},
+#endif /* WL_CFG80211_P2P_DEV_IF */
+	{
+	.max = 1,
+	.types = BIT(NL80211_IFTYPE_ADHOC),
+	},
+};
+static const struct ieee80211_iface_combination
+softap_iface_combinations[] = {
+	{
+	.num_different_channels = 1,
+	.max_interfaces = 1,
+	.limits = softap_limits,
+	.n_limits = ARRAY_SIZE(softap_limits),
+	},
+};
+static const struct ieee80211_iface_combination
+sta_p2p_iface_combinations[] = {
+	{
+	.num_different_channels = 2,
+	.max_interfaces = 3,
+	.limits = sta_p2p_limits,
+	.n_limits = ARRAY_SIZE(sta_p2p_limits),
+	},
+};
+#endif /* LINUX_VER >= 3.0 && (WL_IFACE_COMB_NUM_CHANNELS || WL_CFG80211_P2P_DEV_IF) */
 
 /* Data Element Definitions */
 #define WPS_ID_CONFIG_METHODS     0x1008
@@ -178,6 +236,24 @@ static const struct ieee80211_regdomain brcm_regdom = {
 #define WPS_CONFIG_VIRT_DISPLAY 0x2008
 #define WPS_CONFIG_PHY_DISPLAY 0x4008
 
+#define PM_BLOCK 1
+#define PM_ENABLE 0
+
+#ifdef BCMCCX
+#ifndef WLAN_AKM_SUITE_CCKM
+#define WLAN_AKM_SUITE_CCKM 0x00409600
+#endif
+#define DOT11_LEAP_AUTH	0x80 /* LEAP auth frame paylod constants */
+#endif /* BCMCCX */
+
+#ifdef MFP
+#define WL_AKM_SUITE_MFP_1X  0x000FAC05
+#define WL_AKM_SUITE_MFP_PSK 0x000FAC06
+#endif /* MFP */
+
+#ifndef RSSI_OFFSET
+#define RSSI_OFFSET	0
+#endif
 /*
  * cfg80211_ops api/callback list
  */
@@ -223,6 +299,13 @@ static s32 wl_cfg80211_get_key(struct wiphy *wiphy, struct net_device *dev,
 static s32 wl_cfg80211_config_default_mgmt_key(struct wiphy *wiphy,
 	struct net_device *dev,	u8 key_idx);
 static s32 wl_cfg80211_resume(struct wiphy *wiphy);
+#if defined(WL_SUPPORT_BACKPORTED_KPATCHES) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3, \
+	2, 0))
+static s32 wl_cfg80211_mgmt_tx_cancel_wait(struct wiphy *wiphy,
+	struct net_device *dev, u64 cookie);
+static s32 wl_cfg80211_del_station(struct wiphy *wiphy,
+	struct net_device *ndev, u8* mac_addr);
+#endif /* WL_SUPPORT_BACKPORTED_KPATCHES || KERNEL_VER >= KERNEL_VERSION(3, 2, 0)) */
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39)
 static s32 wl_cfg80211_suspend(struct wiphy *wiphy, struct cfg80211_wowlan *wow);
 #else
@@ -234,8 +317,14 @@ static s32 wl_cfg80211_del_pmksa(struct wiphy *wiphy, struct net_device *dev,
 	struct cfg80211_pmksa *pmksa);
 static s32 wl_cfg80211_flush_pmksa(struct wiphy *wiphy,
 	struct net_device *dev);
+static void wl_cfg80211_scan_abort(struct wl_priv *wl);
 static s32 wl_notify_escan_complete(struct wl_priv *wl,
 	struct net_device *ndev, bool aborted, bool fw_abort);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 2, 0)
+static s32 wl_cfg80211_tdls_oper(struct wiphy *wiphy, struct net_device *dev,
+	u8 *peer, enum nl80211_tdls_operation oper);
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(3, 2, 0) */
+
 /*
  * event & event Q handlers for cfg80211 interfaces
  */
@@ -269,6 +358,22 @@ static s32 wl_bss_roaming_done(struct wl_priv *wl, struct net_device *ndev,
 	const wl_event_msg_t *e, void *data);
 static s32 wl_notify_mic_status(struct wl_priv *wl, struct net_device *ndev,
 	const wl_event_msg_t *e, void *data);
+#ifdef WL_SCHED_SCAN
+static s32
+wl_notify_sched_scan_results(struct wl_priv *wl, struct net_device *ndev,
+	const wl_event_msg_t *e, void *data);
+#endif /* WL_SCHED_SCAN */
+#ifdef PNO_SUPPORT
+static s32 wl_notify_pfn_status(struct wl_priv *wl, struct net_device *ndev,
+	const wl_event_msg_t *e, void *data);
+#endif /* PNO_SUPPORT */
+static s32 wl_notifier_change_state(struct wl_priv *wl, struct net_info *_net_info,
+	enum wl_status state, bool set);
+
+#ifdef WLTDLS
+static s32 wl_tdls_event_handler(struct wl_priv *wl, struct net_device *ndev,
+	const wl_event_msg_t *e, void *data);
+#endif /* WLTDLS */
 /*
  * register/deregister parent device
  */
@@ -322,15 +427,35 @@ static __used s32 wl_add_ie(struct wl_priv *wl, u8 t, u8 l, u8 *v);
 static s32 wl_mrg_ie(struct wl_priv *wl, u8 *ie_stream, u16 ie_size);
 static s32 wl_cp_ie(struct wl_priv *wl, u8 *dst, u16 dst_size);
 static u32 wl_get_ielen(struct wl_priv *wl);
+#ifdef MFP
+static int wl_cfg80211_get_rsn_capa(bcm_tlv_t *wpa2ie, u8* capa);
+#endif
 
+#ifdef WL11U
+bcm_tlv_t *
+wl_cfg80211_find_interworking_ie(u8 *parse, u32 len);
+static s32
+wl_cfg80211_add_iw_ie(struct wl_priv *wl, struct net_device *ndev, s32 bssidx, s32 pktflag,
+            uint8 ie_id, uint8 *data, uint8 data_len);
+#endif /* WL11U */
 
-static s32 wl_setup_wiphy(struct wireless_dev *wdev, struct device *dev);
+static s32 wl_setup_wiphy(struct wireless_dev *wdev, struct device *dev, void *data);
 static void wl_free_wdev(struct wl_priv *wl);
+#ifdef CONFIG_CFG80211_INTERNAL_REGDB
+static int
+wl_cfg80211_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request);
+#endif /* CONFIG_CFG80211_INTERNAL_REGDB */
 
 static s32 wl_inform_bss(struct wl_priv *wl);
-static s32 wl_inform_single_bss(struct wl_priv *wl, struct wl_bss_info *bi);
-static s32 wl_update_bss_info(struct wl_priv *wl, struct net_device *ndev);
+static s32 wl_inform_single_bss(struct wl_priv *wl, struct wl_bss_info *bi, u8 is_roam_done);
+static s32 wl_update_bss_info(struct wl_priv *wl, struct net_device *ndev, u8 is_roam_done);
 static chanspec_t wl_cfg80211_get_shared_freq(struct wiphy *wiphy);
+s32 wl_cfg80211_channel_to_freq(u32 channel);
+
+#if defined(DHCP_SCAN_SUPPRESS)
+static void wl_cfg80211_work_handler(struct work_struct *work);
+static void wl_cfg80211_scan_supp_timerfunc(ulong data);
+#endif /* DHCP_SCAN_SUPPRESS */
 
 static s32 wl_add_keyext(struct wiphy *wiphy, struct net_device *dev,
 	u8 key_idx, const u8 *mac_addr,
@@ -360,7 +485,6 @@ static __used bool wl_is_ibssstarter(struct wl_priv *wl);
  */
 static s32 __wl_cfg80211_up(struct wl_priv *wl);
 static s32 __wl_cfg80211_down(struct wl_priv *wl);
-static s32 wl_add_remove_eventmsg(struct net_device *ndev, u16 event, bool add);
 static bool wl_is_linkdown(struct wl_priv *wl, const wl_event_msg_t *e);
 static bool wl_is_linkup(struct wl_priv *wl, const wl_event_msg_t *e, struct net_device *ndev);
 static bool wl_is_nonetwork(struct wl_priv *wl, const wl_event_msg_t *e);
@@ -368,7 +492,6 @@ static void wl_link_up(struct wl_priv *wl);
 static void wl_link_down(struct wl_priv *wl);
 static s32 wl_config_ifmode(struct wl_priv *wl, struct net_device *ndev, s32 iftype);
 static void wl_init_conf(struct wl_conf *conf);
-static s32 wl_update_wiphybands(struct wl_priv *wl);
 
 /*
  * iscan handler
@@ -401,6 +524,10 @@ static __used u32 wl_find_msb(u16 bit16);
  */
 static int wl_setup_rfkill(struct wl_priv *wl, bool setup);
 static int wl_rfkill_set(void *data, bool blocked);
+#ifdef DEBUGFS_CFG80211
+static s32 wl_setup_debugfs(struct wl_priv *wl);
+static s32 wl_free_debugfs(struct wl_priv *wl);
+#endif
 
 static wl_scan_params_t *wl_cfg80211_scan_alloc_params(int channel,
 	int nprobes, int *out_params_size);
@@ -416,10 +543,11 @@ int dhd_monitor_uninit(void);
 int dhd_start_xmit(struct sk_buff *skb, struct net_device *net);
 
 
-#define CHECK_SYS_UP(wlpriv)						\
+
+#define RETURN_EIO_IF_NOT_UP(wlpriv)						\
 do {									\
-	struct net_device *ndev = wl_to_prmry_ndev(wlpriv);       	\
-	if (unlikely(!wl_get_drv_status(wlpriv, READY, ndev))) {	\
+	struct net_device *checkSysUpNDev = wl_to_prmry_ndev(wlpriv);       	\
+	if (unlikely(!wl_get_drv_status(wlpriv, READY, checkSysUpNDev))) {	\
 		WL_INFO(("device is not ready\n"));			\
 		return -EIO;						\
 	}								\
@@ -432,6 +560,12 @@ do {									\
 
 
 extern int dhd_wait_pend8021x(struct net_device *dev);
+#ifdef PROP_TXSTATUS_VSDB
+extern int disable_proptx;
+extern int dhd_wlfc_init(dhd_pub_t *dhd);
+extern void dhd_wlfc_deinit(dhd_pub_t *dhd);
+#endif /* PROP_TXSTATUS_VSDB */
+
 
 #if (WL_DBG_LEVEL > 0)
 #define WL_DBG_ESTR_MAX	50
@@ -489,18 +623,18 @@ static s8 wl_dbg_estr[][WL_DBG_ESTR_MAX] = {
 	}
 
 static struct ieee80211_rate __wl_rates[] = {
-	RATETAB_ENT(WLC_RATE_1M, 0),
-	RATETAB_ENT(WLC_RATE_2M, IEEE80211_RATE_SHORT_PREAMBLE),
-	RATETAB_ENT(WLC_RATE_5M5, IEEE80211_RATE_SHORT_PREAMBLE),
-	RATETAB_ENT(WLC_RATE_11M, IEEE80211_RATE_SHORT_PREAMBLE),
-	RATETAB_ENT(WLC_RATE_6M, 0),
-	RATETAB_ENT(WLC_RATE_9M, 0),
-	RATETAB_ENT(WLC_RATE_12M, 0),
-	RATETAB_ENT(WLC_RATE_18M, 0),
-	RATETAB_ENT(WLC_RATE_24M, 0),
-	RATETAB_ENT(WLC_RATE_36M, 0),
-	RATETAB_ENT(WLC_RATE_48M, 0),
-	RATETAB_ENT(WLC_RATE_54M, 0)
+	RATETAB_ENT(DOT11_RATE_1M, 0),
+	RATETAB_ENT(DOT11_RATE_2M, IEEE80211_RATE_SHORT_PREAMBLE),
+	RATETAB_ENT(DOT11_RATE_5M5, IEEE80211_RATE_SHORT_PREAMBLE),
+	RATETAB_ENT(DOT11_RATE_11M, IEEE80211_RATE_SHORT_PREAMBLE),
+	RATETAB_ENT(DOT11_RATE_6M, 0),
+	RATETAB_ENT(DOT11_RATE_9M, 0),
+	RATETAB_ENT(DOT11_RATE_12M, 0),
+	RATETAB_ENT(DOT11_RATE_18M, 0),
+	RATETAB_ENT(DOT11_RATE_24M, 0),
+	RATETAB_ENT(DOT11_RATE_36M, 0),
+	RATETAB_ENT(DOT11_RATE_48M, 0),
+	RATETAB_ENT(DOT11_RATE_54M, 0)
 };
 
 #define wl_a_rates		(__wl_rates + 4)
@@ -565,12 +699,30 @@ static const u32 __wl_cipher_suites[] = {
 	WLAN_CIPHER_SUITE_CCMP,
 	WLAN_CIPHER_SUITE_AES_CMAC,
 #ifdef BCMWAPI_WPI
-	WLAN_CIPHER_SUITE_SMS4
+	WLAN_CIPHER_SUITE_SMS4,
+#endif
+#if defined(WLFBT) && defined(WLAN_CIPHER_SUITE_PMK)
+	WLAN_CIPHER_SUITE_PMK,
 #endif
 };
 
+
 /* IOCtl version read from targeted driver */
 static int ioctl_version;
+#ifdef DEBUGFS_CFG80211
+#define S_SUBLOGLEVEL 20
+static const struct {
+	u32 log_level;
+	char *sublogname;
+} sublogname_map[] = {
+	{WL_DBG_ERR, "ERR"},
+	{WL_DBG_INFO, "INFO"},
+	{WL_DBG_DBG, "DBG"},
+	{WL_DBG_SCAN, "SCAN"},
+	{WL_DBG_TRACE, "TRACE"},
+	{WL_DBG_P2P_ACTION, "P2PACTION"}
+};
+#endif
 
 /* Return a new chanspec given a legacy chanspec
  * Returns INVCHANSPEC on error
@@ -787,22 +939,31 @@ static void swap_key_to_BE(struct wl_wsec_key *key)
 	key->iv_initialized = dtoh32(key->iv_initialized);
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)
 /* For debug: Dump the contents of the encoded wps ie buffe */
 static void
-wl_validate_wps_ie(char *wps_ie, bool *pbc)
+wl_validate_wps_ie(char *wps_ie, s32 wps_ie_len, bool *pbc)
 {
 	#define WPS_IE_FIXED_LEN 6
-	u16 len = (u16) wps_ie[TLV_LEN_OFF];
-	u8 *subel = wps_ie+  WPS_IE_FIXED_LEN;
+	u16 len;
+	u8 *subel = NULL;
 	u16 subelt_id;
 	u16 subelt_len;
 	u16 val;
 	u8 *valptr = (uint8*) &val;
+	if (wps_ie == NULL || wps_ie_len < WPS_IE_FIXED_LEN) {
+		WL_ERR(("invalid argument : NULL\n"));
+		return;
+	}
+	len = (u16)wps_ie[TLV_LEN_OFF];
 
+	if (len > wps_ie_len) {
+		WL_ERR(("invalid length len %d, wps ie len %d\n", len, wps_ie_len));
+		return;
+	}
 	WL_DBG(("wps_ie len=%d\n", len));
-
 	len -= 4;	/* for the WPS IE's OUI, oui_type fields */
-
+	subel = wps_ie + WPS_IE_FIXED_LEN;
 	while (len >= 4) {		/* must have attr id, attr len fields */
 		valptr[0] = *subel++;
 		valptr[1] = *subel++;
@@ -862,52 +1023,54 @@ wl_validate_wps_ie(char *wps_ie, bool *pbc)
 		subel += subelt_len;
 	}
 }
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0) */
 
 static chanspec_t wl_cfg80211_get_shared_freq(struct wiphy *wiphy)
 {
-	if (vsdb_supported) {
+	chanspec_t chspec;
+	int err = 0;
+	struct wl_priv *wl = wiphy_priv(wiphy);
+	struct net_device *dev = wl_to_prmry_ndev(wl);
+	struct ether_addr bssid;
+	struct wl_bss_info *bss = NULL;
+
+	if ((err = wldev_ioctl(dev, WLC_GET_BSSID, &bssid, sizeof(bssid), false))) {
+		/* STA interface is not associated. So start the new interface on a temp
+		 * channel . Later proper channel will be applied by the above framework
+		 * via set_channel (cfg80211 API).
+		 */
+		WL_DBG(("Not associated. Return a temp channel. \n"));
 		return wl_ch_host_to_driver(WL_P2P_TEMP_CHAN);
 	}
-	else {
-		chanspec_t chspec;
-		int err = 0;
-		struct wl_priv *wl = wiphy_priv(wiphy);
-		struct net_device *dev = wl_to_prmry_ndev(wl);
-		struct ether_addr bssid;
-		struct wl_bss_info *bss = NULL;
-
-		if ((err = wldev_ioctl(dev, WLC_GET_BSSID, &bssid, sizeof(bssid), false))) {
-			/* STA interface is not associated. So start the new interface on a temp
-			 * channel . Later proper channel will be applied by the above framework
-			 * via set_channel (cfg80211 API).
-			 */
-			WL_DBG(("Not associated. Return a temp channel. \n"));
-			return wl_ch_host_to_driver(WL_P2P_TEMP_CHAN);
-		}
 
 
-		*(u32 *) wl->extra_buf = htod32(WL_EXTRA_BUF_MAX);
-		if ((err = wldev_ioctl(dev, WLC_GET_BSS_INFO, wl->extra_buf,
-			sizeof(WL_EXTRA_BUF_MAX), false))) {
-				WL_ERR(("Failed to get associated bss info, use temp channel \n"));
-				chspec = wl_ch_host_to_driver(WL_P2P_TEMP_CHAN);
-		}
-		else {
-				bss = (struct wl_bss_info *) (wl->extra_buf + 4);
-				chspec =  bss->chanspec;
-				WL_DBG(("Valid BSS Found. chanspec:%d \n", bss->chanspec));
-		}
-		return chspec;
+	*(u32 *) wl->extra_buf = htod32(WL_EXTRA_BUF_MAX);
+	if ((err = wldev_ioctl(dev, WLC_GET_BSS_INFO, wl->extra_buf,
+		WL_EXTRA_BUF_MAX, false))) {
+			WL_ERR(("Failed to get associated bss info, use temp channel \n"));
+			chspec = wl_ch_host_to_driver(WL_P2P_TEMP_CHAN);
+	}
+	else {
+			bss = (struct wl_bss_info *) (wl->extra_buf + 4);
+			chspec =  bss->chanspec;
+
+			WL_DBG(("Valid BSS Found. chanspec:%d \n", chspec));
 	}
+	return chspec;
 }
 
 static struct net_device* wl_cfg80211_add_monitor_if(char *name)
 {
+#if defined(WLP2P) && defined(WL_ENABLE_P2P_IF)
+	WL_INFO(("wl_cfg80211_add_monitor_if: No more support monitor interface\n"));
+	return ERR_PTR(-EOPNOTSUPP);
+#else
 	struct net_device* ndev = NULL;
 
 	dhd_add_monitor(name, &ndev);
 	WL_INFO(("wl_cfg80211_add_monitor_if net device returned: 0x%p\n", ndev));
 	return ndev;
+#endif /* defined(WLP2P) && defined(WL_ENABLE_P2P_IF) */
 }
 
 static struct net_device *
@@ -919,15 +1082,28 @@ wl_cfg80211_add_virtual_iface(struct wiphy *wiphy, char *name,
 	s32 timeout = -1;
 	s32 wlif_type = -1;
 	s32 mode = 0;
-#if defined(WL_ENABLE_P2P_IF)
+	s32 val = 0;
 	s32 dhd_mode = 0;
-#endif /* (WL_ENABLE_P2P_IF) */
 	chanspec_t chspec;
 	struct wl_priv *wl = wiphy_priv(wiphy);
 	struct net_device *_ndev;
 	struct ether_addr primary_mac;
 	int (*net_attach)(void *dhdp, int ifidx);
 	bool rollback_lock = false;
+#ifdef PROP_TXSTATUS_VSDB
+	s32 up = 1;
+	dhd_pub_t *dhd;
+#endif /* PROP_TXSTATUS_VSDB */
+
+	struct net_info *iter, *next;	
+
+	if (!wl)
+		return ERR_PTR(-EINVAL);
+
+#ifdef PROP_TXSTATUS_VSDB
+	dhd = (dhd_pub_t *)(wl->pub);
+#endif /* PROP_TXSTATUS_VSDB */
+
 
 	/* Use primary I/F for sending cmds down to firmware */
 	_ndev = wl_to_prmry_ndev(wl);
@@ -963,9 +1139,8 @@ wl_cfg80211_add_virtual_iface(struct wiphy *wiphy, char *name,
 		WL_ERR(("name is NULL\n"));
 		return NULL;
 	}
-	if (wl->iface_cnt == IFACE_MAX_CNT)
-		return ERR_PTR(-ENOMEM);
 	if (wl->p2p_supported && (wlif_type != -1)) {
+		ASSERT(wl->p2p); /* ensure expectation of p2p initialization */
 		if (wl_get_p2p_status(wl, IF_DELETING)) {
 			/* wait till IF_DEL is complete
 			 * release the lock for the unregister to proceed
@@ -974,8 +1149,7 @@ wl_cfg80211_add_virtual_iface(struct wiphy *wiphy, char *name,
 				rtnl_unlock();
 				rollback_lock = true;
 			}
-			WL_INFO(("%s: Released the lock and wait till IF_DEL is complete\n",
-				__func__));
+			WL_INFO(("Released the lock and wait till IF_DEL is complete\n"));
 			timeout = wait_event_interruptible_timeout(wl->netif_change_event,
 				(wl_get_p2p_status(wl, IF_DELETING) == false),
 				msecs_to_jiffies(MAX_WAIT_TIME));
@@ -992,7 +1166,20 @@ wl_cfg80211_add_virtual_iface(struct wiphy *wiphy, char *name,
 				WL_ERR(("timeount < 0, return -EAGAIN\n"));
 				return ERR_PTR(-EAGAIN);
 			}
+			/* It should be now be safe to put this check here since we are sure
+			 * by now netdev_notifier (unregister) would have been called
+			 */
+			if (wl->iface_cnt == IFACE_MAX_CNT)
+				return ERR_PTR(-ENOMEM);
 		}
+
+#ifdef PROP_TXSTATUS_VSDB
+		if (!dhd)
+			return ERR_PTR(-ENODEV);
+#endif /* PROP_TXSTATUS_VSDB */
+		if (!wl->p2p)
+			return ERR_PTR(-ENODEV);
+
 		if (wl->p2p && !wl->p2p->on && strstr(name, WL_P2P_INTERFACE_PREFIX)) {
 			p2p_on(wl) = true;
 			wl_cfgp2p_set_firm_p2p(wl);
@@ -1005,8 +1192,32 @@ wl_cfg80211_add_virtual_iface(struct wiphy *wiphy, char *name,
 		memset(wl->p2p->vir_ifname, 0, IFNAMSIZ);
 		strncpy(wl->p2p->vir_ifname, name, IFNAMSIZ - 1);
 
-		wldev_iovar_setint(_ndev, "mpc", 0);
-		wl_notify_escan_complete(wl, _ndev, true, true);
+#if 0
+                wl_notify_escan_complete(wl, _ndev, true, true);
+#else
+                wl_cfg80211_scan_abort(wl);
+#endif
+		for_each_ndev(wl, iter, next) {
+			/* Save the current roam setting */
+			if ((err = wldev_iovar_setint(iter->ndev, "roam_off", 1)) != BCME_OK) {
+				WL_ERR((" %s:failed to set roam_off : %d\n", iter->ndev->name, err));
+			} else
+				WL_ERR((" %s:success to set roam_off : %d\n", iter->ndev->name, err));
+		}
+
+		if ((err = wldev_iovar_setint(_ndev, "bus:credall", 1)) != BCME_OK) {
+			WL_ERR(("failed to set credall\n"));
+		}
+#ifdef PROP_TXSTATUS_VSDB
+		if (!wl->wlfc_on && !disable_proptx) {
+			dhd->wlfc_enabled = true;
+			dhd_wlfc_init(dhd);
+			err = wldev_ioctl(_ndev, WLC_UP, &up, sizeof(s32), true);
+			if (err < 0)
+				WL_ERR(("WLC_UP return err:%d\n", err));
+			wl->wlfc_on = true;
+		}
+#endif /* PROP_TXSTATUS_VSDB */
 
 		/* In concurrency case, STA may be already associated in a particular channel.
 		 * so retrieve the current channel of primary interface and then start the virtual
@@ -1018,6 +1229,8 @@ wl_cfg80211_add_virtual_iface(struct wiphy *wiphy, char *name,
 		 * bss: "wl p2p_ifadd"
 		 */
 		wl_set_p2p_status(wl, IF_ADD);
+		if (wlif_type == WL_P2P_IF_GO)
+			wldev_iovar_setint(_ndev, "mpc", 0);
 		err = wl_cfgp2p_ifadd(wl, &wl->p2p->int_addr, htod32(wlif_type), chspec);
 
 		if (unlikely(err)) {
@@ -1053,16 +1266,25 @@ wl_cfg80211_add_virtual_iface(struct wiphy *wiphy, char *name,
 				rollback_lock = true;
 			}
 			if (net_attach && !net_attach(wl->pub, _ndev->ifindex)) {
-				wl_alloc_netinfo(wl, _ndev, vwdev, mode);
+				wl_alloc_netinfo(wl, _ndev, vwdev, mode, PM_BLOCK);
+				val = 1;
+				/* Disable firmware roaming for P2P interface  */
+				wldev_iovar_setint(_ndev, "roam_off", val);
+
+				if (mode != WL_MODE_AP)
+					wldev_iovar_setint(_ndev, "buf_key_b4_m4", 1);
+
 				WL_ERR((" virtual interface(%s) is "
 					"created net attach done\n", wl->p2p->vir_ifname));
-#if defined(WL_ENABLE_P2P_IF)
+				if (mode == WL_MODE_AP)
+					wl_set_drv_status(wl, CONNECTED, _ndev);
 				if (type == NL80211_IFTYPE_P2P_CLIENT)
-					dhd_mode = P2P_GC_ENABLED;
+					dhd_mode = DHD_FLAG_P2P_GC_MODE;
 				else if (type == NL80211_IFTYPE_P2P_GO)
-					dhd_mode = P2P_GO_ENABLED;
+					dhd_mode = DHD_FLAG_P2P_GO_MODE;
 				DNGL_FUNC(dhd_cfg80211_set_p2p_info, (wl, dhd_mode));
-#endif /* (WL_ENABLE_P2P_IF) */
+				/* reinitialize completion to clear previous count */
+				INIT_COMPLETION(wl->iface_disable);
 			} else {
 				/* put back the rtnl_lock again */
 				if (rollback_lock)
@@ -1079,9 +1301,18 @@ wl_cfg80211_add_virtual_iface(struct wiphy *wiphy, char *name,
 			WL_ERR((" virtual interface(%s) is not created \n", wl->p2p->vir_ifname));
 			memset(wl->p2p->vir_ifname, '\0', IFNAMSIZ);
 			wl->p2p->vif_created = false;
+#ifdef PROP_TXSTATUS_VSDB
+		if (dhd->wlfc_enabled && wl->wlfc_on) {
+			dhd->wlfc_enabled = false;
+			dhd_wlfc_deinit(dhd);
+			wl->wlfc_on = false;
+		}
+#endif /* PROP_TXSTATUS_VSDB */
 		}
 	}
 fail:
+	if (wlif_type == WL_P2P_IF_GO)
+		wldev_iovar_setint(_ndev, "mpc", 1);
 	return ERR_PTR(-ENODEV);
 }
 
@@ -1092,23 +1323,65 @@ wl_cfg80211_del_virtual_iface(struct wiphy *wiphy, struct net_device *dev)
 	struct wl_priv *wl = wiphy_priv(wiphy);
 	s32 timeout = -1;
 	s32 ret = 0;
-	WL_DBG(("Enter\n"));
-
+	s32 index = -1;
+	dhd_pub_t *dhd =  (dhd_pub_t *)(wl->pub);
+	s32 err;
+	struct net_info *iter, *next;
+	
+	WL_ERR(("Enter\n"));
 	if (wl->p2p_net == dev) {
 		/* Since there is no ifidx corresponding to p2p0, cmds to
 		 * firmware should be routed through primary I/F
 		 */
 		dev = wl_to_prmry_ndev(wl);
 	}
-
+	if (wl_cfgp2p_find_idx(wl, dev, &index) != BCME_OK) {
+		WL_ERR(("Find p2p index from ndev(%p) failed\n", dev));
+		return BCME_ERROR;
+	}
 	if (wl->p2p_supported) {
 		memcpy(p2p_mac.octet, wl->p2p->int_addr.octet, ETHER_ADDR_LEN);
+
+		/* Clear GO_NEG_PHASE bit to take care of GO-NEG-FAIL cases
+		 */
+		WL_DBG(("P2P: GO_NEG_PHASE status cleared "));
+		wl_clr_p2p_status(wl, GO_NEG_PHASE);
 		if (wl->p2p->vif_created) {
 			if (wl_get_drv_status(wl, SCANNING, dev)) {
 				wl_notify_escan_complete(wl, dev, true, true);
 			}
 			wldev_iovar_setint(dev, "mpc", 1);
+
+			/* for GC */
+			if (wl_get_drv_status(wl, DISCONNECTING, dev) &&
+				(wl_get_mode_by_netdev(wl, dev) != WL_MODE_AP)) {
+				WL_ERR(("Wait for Link Down event for GC !\n"));
+				wait_for_completion_timeout
+					(&wl->iface_disable, msecs_to_jiffies(500));
+			}
 			wl_set_p2p_status(wl, IF_DELETING);
+			DNGL_FUNC(dhd_cfg80211_clean_p2p_info, (wl));
+
+			/* for GO */
+			if (wl_get_mode_by_netdev(wl, dev) == WL_MODE_AP) {
+				wl_add_remove_eventmsg(dev, WLC_E_PROBREQ_MSG, false);
+				/* disable interface before bsscfg free */
+				ret = wl_cfgp2p_ifdisable(wl, &p2p_mac);
+				/* if fw doesn't support "ifdis",
+				   do not wait for link down of ap mode
+				 */
+				if (ret == 0) {
+					WL_ERR(("Wait for Link Down event for GO !!!\n"));
+					wait_for_completion_timeout(&wl->iface_disable,
+						msecs_to_jiffies(500));
+				}
+			}
+			wl_cfgp2p_clear_management_ie(wl, index);
+
+			if (wl_get_mode_by_netdev(wl, dev) != WL_MODE_AP)
+				wldev_iovar_setint(dev, "buf_key_b4_m4", 0);
+
+			/* delete interface after link down */
 			ret = wl_cfgp2p_ifdel(wl, &p2p_mac);
 			/* Firmware could not delete the interface so we will not get WLC_E_IF
 			* event for cleaning the dhd virtual nw interace
@@ -1117,24 +1390,33 @@ wl_cfg80211_del_virtual_iface(struct wiphy *wiphy, struct net_device *dev)
 			* however we should cleanup the linux network virtual interfaces
 			*/
 			/* Request framework to RESET and clean up */
-			if (ret) {
+			if (ret && !dhd->hang_was_sent) {
 				struct net_device *ndev = wl_to_prmry_ndev(wl);
 				WL_ERR(("Firmware returned an error (%d) from p2p_ifdel"
 					"HANG Notification sent to %s\n", ret, ndev->name));
-				wl_cfg80211_hang(ndev, WLAN_REASON_UNSPECIFIED);
+				net_os_send_hang_message(ndev);
+			}
+	        	for_each_ndev(wl, iter, next) {
+					if ((err = wldev_iovar_setint(iter->ndev, "roam_off", 0)) == BCME_OK)
+						WL_ERR((" %s:success to set roam_off : %d\n", iter->ndev->name, err));
+					else 
+						WL_ERR((" %s:failed to set roam_off : %d\n", iter->ndev->name, err));
 			}
 
-			/* Wait for any pending scan req to get aborted from the sysioc context */
-			timeout = wait_event_interruptible_timeout(wl->netif_change_event,
-				(wl_get_p2p_status(wl, IF_DELETING) == false),
-				msecs_to_jiffies(MAX_WAIT_TIME));
-			if (timeout > 0 && !wl_get_p2p_status(wl, IF_DELETING)) {
-				WL_DBG(("IFDEL operation done\n"));
-#if  defined(WL_ENABLE_P2P_IF)
-				DNGL_FUNC(dhd_cfg80211_clean_p2p_info, (wl));
-#endif /*  (WL_ENABLE_P2P_IF)) */
+			if ((err = wldev_iovar_setint(dev, "bus:credall", 0)) != BCME_OK)
+				WL_ERR(("failed to set credall\n"));
+			if (dhd->hang_was_sent) {
+				wl_cfg80211_ifdel_ops(dev);
 			} else {
-				WL_ERR(("IFDEL didn't complete properly\n"));
+			/* Wait for IF_DEL operation to be finished in firmware */
+				timeout = wait_event_interruptible_timeout(wl->netif_change_event,
+					(wl->p2p->vif_created == false),
+					msecs_to_jiffies(MAX_WAIT_TIME));
+				if (timeout > 0 && (wl->p2p->vif_created == false)) {
+					WL_DBG(("IFDEL operation done\n"));
+				} else {
+					WL_ERR(("IFDEL didn't complete properly\n"));
+				}
 			}
 			ret = dhd_del_monitor(dev);
 		}
@@ -1153,8 +1435,8 @@ wl_cfg80211_change_virtual_iface(struct wiphy *wiphy, struct net_device *ndev,
 	s32 mode = 0;
 	chanspec_t chspec;
 	struct wl_priv *wl = wiphy_priv(wiphy);
-
-	WL_DBG(("Enter \n"));
+	dhd_pub_t *dhd = (dhd_pub_t *)(wl->pub);
+	WL_ERR(("Enter type %d\n", type));
 	switch (type) {
 	case NL80211_IFTYPE_MONITOR:
 	case NL80211_IFTYPE_WDS:
@@ -1180,7 +1462,8 @@ wl_cfg80211_change_virtual_iface(struct wiphy *wiphy, struct net_device *ndev,
 	default:
 		return -EINVAL;
 	}
-
+	if (!dhd)
+		return -EINVAL;
 	if (ap) {
 		wl_set_mode_by_netdev(wl, ndev, mode);
 		if (wl->p2p_supported && wl->p2p->vif_created) {
@@ -1195,7 +1478,7 @@ wl_cfg80211_change_virtual_iface(struct wiphy *wiphy, struct net_device *ndev,
 			 */
 			chspec = wl_cfg80211_get_shared_freq(wiphy);
 
-			wlif_type = ap ? WL_P2P_IF_GO : WL_P2P_IF_CLIENT;
+			wlif_type = WL_P2P_IF_GO;
 			WL_ERR(("%s : ap (%d), infra (%d), iftype: (%d)\n",
 				ndev->name, ap, infra, type));
 			wl_set_p2p_status(wl, IF_CHANGING);
@@ -1205,8 +1488,12 @@ wl_cfg80211_change_virtual_iface(struct wiphy *wiphy, struct net_device *ndev,
 				(wl_get_p2p_status(wl, IF_CHANGED) == true),
 				msecs_to_jiffies(MAX_WAIT_TIME));
 			wl_set_mode_by_netdev(wl, ndev, mode);
+			dhd->op_mode &= ~DHD_FLAG_P2P_GC_MODE;
+			dhd->op_mode |= DHD_FLAG_P2P_GO_MODE;
 			wl_clr_p2p_status(wl, IF_CHANGING);
 			wl_clr_p2p_status(wl, IF_CHANGED);
+			if (mode == WL_MODE_AP)
+				wl_set_drv_status(wl, CONNECTED, ndev);
 		} else if (ndev == wl_to_prmry_ndev(wl) &&
 			!wl_get_drv_status(wl, AP_CREATED, ndev)) {
 			wl_set_drv_status(wl, AP_CREATING, ndev);
@@ -1219,6 +1506,8 @@ wl_cfg80211_change_virtual_iface(struct wiphy *wiphy, struct net_device *ndev,
 			WL_ERR(("Cannot change the interface for GO or SOFTAP\n"));
 			return -EINVAL;
 		}
+	} else {
+		WL_DBG(("Change_virtual_iface for transition from GO/AP to client/STA"));
 	}
 
 	ndev->ieee80211_ptr->iftype = type;
@@ -1255,12 +1544,28 @@ wl_cfg80211_notify_ifadd(struct net_device *ndev, s32 idx, s32 bssidx,
 }
 
 s32
-wl_cfg80211_notify_ifdel(struct net_device *ndev)
+wl_cfg80211_notify_ifdel(void)
+{
+	struct wl_priv *wl = wlcfg_drv_priv;
+
+	WL_DBG(("Enter \n"));
+	wl_clr_p2p_status(wl, IF_DELETING);
+	wake_up_interruptible(&wl->netif_change_event);
+	return 0;
+}
+
+s32
+wl_cfg80211_ifdel_ops(struct net_device *ndev)
 {
 	struct wl_priv *wl = wlcfg_drv_priv;
 	bool rollback_lock = false;
-	s32 index = 0;
-	if (!ndev || !ndev->name) {
+	s32 type = -1;
+	s32 bssidx = -1;
+
+#ifdef PROP_TXSTATUS_VSDB
+	dhd_pub_t *dhd =  (dhd_pub_t *)(wl->pub);
+#endif /* PROP_TXSTATUS_VSDB */
+	if (!ndev || (strlen(ndev->name) == 0)) {
 		WL_ERR(("net is NULL\n"));
 		return 0;
 	}
@@ -1280,19 +1585,31 @@ wl_cfg80211_notify_ifdel(struct net_device *ndev)
 			if (rollback_lock)
 				rtnl_unlock();
 		}
-		WL_ERR(("IF_DEL event called from dongle, net %x, vif name: %s\n",
-			(unsigned int)ndev, wl->p2p->vir_ifname));
+		WL_ERR(("IF_DEL event called from dongle, net %p, vif name: %s\n",
+			ndev, wl->p2p->vir_ifname));
 
 		memset(wl->p2p->vir_ifname, '\0', IFNAMSIZ);
-		index = wl_cfgp2p_find_idx(wl, ndev);
-		wl_to_p2p_bss_ndev(wl, index) = NULL;
-		wl_to_p2p_bss_bssidx(wl, index) = 0;
+		if (wl_cfgp2p_find_idx(wl, ndev, &bssidx) != BCME_OK) {
+			WL_ERR(("Find p2p bssidx from ndev(%p) failed\n", ndev));
+			return BCME_ERROR;
+		}
+		if (wl_cfgp2p_find_type(wl, bssidx, &type) != BCME_OK) {
+			WL_ERR(("Find p2p type from bssidx(%d) failed\n", bssidx));
+			return BCME_ERROR;
+		}
+		wl_to_p2p_bss_ndev(wl, type) = NULL;
+		wl_to_p2p_bss_bssidx(wl, type) = WL_INVALID;
 		wl->p2p->vif_created = false;
-		wl_cfgp2p_clear_management_ie(wl,
-			index);
-		wl_clr_p2p_status(wl, IF_DELETING);
-		WL_DBG(("index : %d\n", index));
 
+		WL_DBG(("type : %d\n", type));
+#ifdef PROP_TXSTATUS_VSDB
+		if (dhd->wlfc_enabled && wl->wlfc_on) {
+			dhd->wlfc_enabled = false;
+			dhd_wlfc_deinit(dhd);
+			wl->wlfc_on = false;
+		}
+#endif /* PROP_TXSTATUS_VSDB */
+		wl_clr_drv_status(wl, CONNECTED, ndev);
 	}
 	/* Wake up any waiting thread */
 	wake_up_interruptible(&wl->netif_change_event);
@@ -1332,15 +1649,72 @@ wl_cfg80211_notify_ifchange(void)
 	return 0;
 }
 
+/* Find listen channel */
+static s32 wl_find_listen_channel(struct wl_priv *wl,
+	const u8 *ie, u32 ie_len)
+{
+	wifi_p2p_ie_t *p2p_ie;
+	u8 *end, *pos;
+	s32 listen_channel;
+
+	pos = (u8 *)ie;
+	p2p_ie = wl_cfgp2p_find_p2pie(pos, ie_len);
+
+	if (p2p_ie == NULL)
+		return 0;
+
+	pos = p2p_ie->subelts;
+	end = p2p_ie->subelts + (p2p_ie->len - 4);
+
+	CFGP2P_DBG((" found p2p ie ! lenth %d \n",
+		p2p_ie->len));
+
+	while (pos < end) {
+		uint16 attr_len;
+		if (pos + 2 >= end) {
+			CFGP2P_DBG((" -- Invalid P2P attribute"));
+			return 0;
+		}
+		attr_len = ((uint16) (((pos + 1)[1] << 8) | (pos + 1)[0]));
+
+		if (pos + 3 + attr_len > end) {
+			CFGP2P_DBG(("P2P: Attribute underflow "
+				   "(len=%u left=%d)",
+				   attr_len, (int) (end - pos - 3)));
+			return 0;
+		}
+
+		/* if Listen Channel att id is 6 and the vailue is valid,
+		 * return the listen channel
+		 */
+		if (pos[0] == 6) {
+			/* listen channel subel length format
+			 * 1(id) + 2(len) + 3(country) + 1(op. class) + 1(chan num)
+			 */
+			listen_channel = pos[1 + 2 + 3 + 1];
+
+			if (listen_channel == SOCIAL_CHAN_1 ||
+				listen_channel == SOCIAL_CHAN_2 ||
+				listen_channel == SOCIAL_CHAN_3) {
+				CFGP2P_DBG((" Found my Listen Channel %d \n", listen_channel));
+				return listen_channel;
+			}
+		}
+		pos += 3 + attr_len;
+	}
+	return 0;
+}
+
 static void wl_scan_prep(struct wl_scan_params *params, struct cfg80211_scan_request *request)
 {
 	u32 n_ssids;
 	u32 n_channels;
 	u16 channel;
 	chanspec_t chanspec;
-	s32 i, offset;
+	s32 i = 0, j = 0, offset;
 	char *ptr;
 	wlc_ssid_t ssid;
+	struct wl_priv *wl = wlcfg_drv_priv;
 
 	memcpy(&params->bssid, &ether_bcast, ETHER_ADDR_LEN);
 	params->bss_type = DOT11_BSSTYPE_ANY;
@@ -1377,33 +1751,45 @@ static void wl_scan_prep(struct wl_scan_params *params, struct cfg80211_scan_req
 		for (i = 0; i < n_channels; i++) {
 			chanspec = 0;
 			channel = ieee80211_frequency_to_channel(request->channels[i]->center_freq);
-			if (request->channels[i]->band == IEEE80211_BAND_2GHZ)
+			/* SKIP DFS channels for Secondary interface */
+			if ((wl->escan_info.ndev != wl_to_prmry_ndev(wl)) &&
+				(request->channels[i]->flags &
+				(IEEE80211_CHAN_RADAR | IEEE80211_CHAN_PASSIVE_SCAN)))
+				continue;
+
+			if (request->channels[i]->band == IEEE80211_BAND_2GHZ) {
+#ifdef WL_HOST_BAND_MGMT
+				if (wl->curr_band == WLC_BAND_5G) {
+					WL_DBG(("In 5G only mode, omit 2G channel:%d\n", channel));
+					continue;
+				}
+#endif /* WL_HOST_BAND_MGMT */
 				chanspec |= WL_CHANSPEC_BAND_2G;
-			else
-				chanspec |= WL_CHANSPEC_BAND_5G;
-
-			if (request->channels[i]->flags & IEEE80211_CHAN_NO_HT40) {
-				chanspec |= WL_CHANSPEC_BW_20;
-				chanspec |= WL_CHANSPEC_CTL_SB_NONE;
 			} else {
-				chanspec |= WL_CHANSPEC_BW_40;
-				if (request->channels[i]->flags & IEEE80211_CHAN_NO_HT40PLUS)
-					chanspec |= WL_CHANSPEC_CTL_SB_LOWER;
-				else
-					chanspec |= WL_CHANSPEC_CTL_SB_UPPER;
+#ifdef WL_HOST_BAND_MGMT
+				if (wl->curr_band == WLC_BAND_2G) {
+					WL_DBG(("In 2G only mode, omit 5G channel:%d\n", channel));
+					continue;
+				}
+#endif /* WL_HOST_BAND_MGMT */
+				chanspec |= WL_CHANSPEC_BAND_5G;
 			}
 
-			params->channel_list[i] = channel;
-			params->channel_list[i] &= WL_CHANSPEC_CHAN_MASK;
-			params->channel_list[i] |= chanspec;
+			chanspec |= WL_CHANSPEC_BW_20;
+			chanspec |= WL_CHANSPEC_CTL_SB_NONE;
+
+			params->channel_list[j] = channel;
+			params->channel_list[j] &= WL_CHANSPEC_CHAN_MASK;
+			params->channel_list[j] |= chanspec;
 			WL_SCAN(("Chan : %d, Channel spec: %x \n",
-				channel, params->channel_list[i]));
-			params->channel_list[i] = wl_chspec_host_to_driver(params->channel_list[i]);
+				channel, params->channel_list[j]));
+			params->channel_list[j] = wl_chspec_host_to_driver(params->channel_list[j]);
+			j++;
 		}
 	} else {
 		WL_SCAN(("Scanning all channels\n"));
 	}
-
+	n_channels = j;
 	/* Copy ssid array if applicable */
 	WL_SCAN(("### List of SSIDs to scan ###\n"));
 	if (n_ssids > 0) {
@@ -1429,6 +1815,11 @@ static void wl_scan_prep(struct wl_scan_params *params, struct cfg80211_scan_req
 	params->channel_num =
 	        htod32((n_ssids << WL_SCAN_PARAMS_NSSID_SHIFT) |
 	               (n_channels & WL_SCAN_PARAMS_COUNT_MASK));
+
+	if (n_channels == 1) {
+		params->active_time = htod32(WL_SCAN_CONNECT_DWELL_TIME_MS);
+		params->nprobes = htod32(params->active_time / WL_SCAN_JOIN_PROBE_INTERVAL_MS);
+	}
 }
 
 static s32
@@ -1438,7 +1829,7 @@ wl_run_iscan(struct wl_iscan_ctrl *iscan, struct cfg80211_scan_request *request,
 	u32 n_ssids;
 	s32 params_size =
 	    (WL_SCAN_PARAMS_FIXED_SIZE + offsetof(wl_iscan_params_t, params));
-	struct wl_iscan_params *params;
+	struct wl_iscan_params *params = NULL;
 	s32 err = 0;
 
 	if (request != NULL) {
@@ -1459,9 +1850,7 @@ wl_run_iscan(struct wl_iscan_ctrl *iscan, struct cfg80211_scan_request *request,
 		err = -ENOMEM;
 		goto done;
 	}
-
-	if (request != NULL)
-		wl_scan_prep(&params->params, request);
+	wl_scan_prep(&params->params, request);
 
 	params->version = htod32(ISCAN_REQ_VERSION);
 	params->action = htod16(action);
@@ -1481,8 +1870,10 @@ wl_run_iscan(struct wl_iscan_ctrl *iscan, struct cfg80211_scan_request *request,
 			WL_ERR(("error (%d)\n", err));
 		}
 	}
-	kfree(params);
+
 done:
+	if (params)
+		kfree(params);
 	return err;
 }
 
@@ -1497,14 +1888,14 @@ static s32 wl_do_iscan(struct wl_priv *wl, struct cfg80211_scan_request *request
 
 	passive_scan = wl->active_scan ? 0 : 1;
 	err = wldev_ioctl(ndev, WLC_SET_PASSIVE_SCAN,
-		&passive_scan, sizeof(passive_scan), false);
+		&passive_scan, sizeof(passive_scan), true);
 	if (unlikely(err)) {
 		WL_DBG(("error (%d)\n", err));
 		return err;
 	}
 	wl->iscan_kickstart = true;
 	wl_run_iscan(iscan, request, WL_SCAN_ACTION_START);
-	mod_timer(&iscan->timer, jiffies + iscan->timer_ms * HZ / 1000);
+	mod_timer(&iscan->timer, jiffies + msecs_to_jiffies(iscan->timer_ms));
 	iscan->timer_on = 1;
 
 	return err;
@@ -1527,6 +1918,12 @@ wl_get_valid_channels(struct net_device *ndev, u8 *valid_chan_list, s32 size)
 
 	return err;
 }
+
+//for reduce First scan time
+#define FIRST_SCAN_ACTIVE_DWELL_TIME_MS 40
+#define FIRST_SCAN_PASSIVE_DWELL_TIME_MS 50
+static bool first_broadcast_scan = TRUE;
+
 static s32
 wl_run_escan(struct wl_priv *wl, struct net_device *ndev,
 	struct cfg80211_scan_request *request, uint16 action)
@@ -1536,7 +1933,6 @@ wl_run_escan(struct wl_priv *wl, struct net_device *ndev,
 	u32 n_ssids;
 	s32 params_size = (WL_SCAN_PARAMS_FIXED_SIZE + OFFSETOF(wl_escan_params_t, params));
 	wl_escan_params_t *params = NULL;
-	struct cfg80211_scan_request *scan_request = wl->scan_request;
 	u8 chan_buf[sizeof(u32)*(WL_NUMCHANNELS + 1)];
 	u32 num_chans = 0;
 	s32 channel;
@@ -1546,14 +1942,20 @@ wl_run_escan(struct wl_priv *wl, struct net_device *ndev,
 	u16 *default_chan_list = NULL;
 	wl_uint32_list_t *list;
 	struct net_device *dev = NULL;
-	WL_DBG(("Enter \n"));
 
+	WL_DBG(("Enter \n"));
 
-	if (!wl->p2p_supported || ((ndev == wl_to_prmry_ndev(wl)) &&
-		!p2p_scan(wl))) {
+	/* scan request can come with empty request : perform all default scan */
+	if (!wl) {
+		err = -EINVAL;
+		goto exit;
+	}
+	if (!wl->p2p_supported || !p2p_scan(wl)) {
 		/* LEGACY SCAN TRIGGER */
 		WL_SCAN((" LEGACY E-SCAN START\n"));
 
+
+		/* if scan request is not empty parse scan request paramters */
 		if (request != NULL) {
 			n_channels = request->n_channels;
 			n_ssids = request->n_ssids;
@@ -1572,12 +1974,20 @@ wl_run_escan(struct wl_priv *wl, struct net_device *ndev,
 			err = -ENOMEM;
 			goto exit;
 		}
+		wl_scan_prep(&params->params, request);
+
+//for reduce First scan time
+		/* Override active_time to reduce scan time if it's first bradcast scan. */
+		if (first_broadcast_scan) {
+			WL_DBG(("This is first SCAN! \n"));
+			first_broadcast_scan = FALSE;
+			params->params.active_time = FIRST_SCAN_ACTIVE_DWELL_TIME_MS;
+			params->params.passive_time = FIRST_SCAN_PASSIVE_DWELL_TIME_MS;
+		}
 
-		if (request != NULL)
-			wl_scan_prep(&params->params, request);
 		params->version = htod32(ESCAN_REQ_VERSION);
 		params->action =  htod16(action);
-		params->sync_id = htod16(0x1234);
+		wl_escan_set_sync_id(params->sync_id, wl);
 		if (params_size + sizeof("escan") >= WLC_IOCTL_MEDLEN) {
 			WL_ERR(("ioctl buffer length not sufficient\n"));
 			kfree(params);
@@ -1586,16 +1996,21 @@ wl_run_escan(struct wl_priv *wl, struct net_device *ndev,
 		}
 		err = wldev_iovar_setbuf(ndev, "escan", params, params_size,
 			wl->escan_ioctl_buf, WLC_IOCTL_MEDLEN, NULL);
-		if (unlikely(err))
-			WL_ERR((" Escan set error (%d)\n", err));
+		if (unlikely(err)) {
+			if (err == BCME_EPERM)
+				/* Scan Not permitted at this point of time */
+				WL_DBG((" Escan not permitted at this time (%d)\n", err));
+			else
+				WL_ERR((" Escan set error (%d)\n", err));
+		}
 		kfree(params);
 	}
 	else if (p2p_is_on(wl) && p2p_scan(wl)) {
 		/* P2P SCAN TRIGGER */
 		s32 _freq = 0;
 		n_nodfs = 0;
-		if (scan_request && scan_request->n_channels) {
-			num_chans = scan_request->n_channels;
+		if (request && request->n_channels) {
+			num_chans = request->n_channels;
 			WL_SCAN((" chann number : %d\n", num_chans));
 			default_chan_list = kzalloc(num_chans * sizeof(*default_chan_list),
 				GFP_KERNEL);
@@ -1609,18 +2024,33 @@ wl_run_escan(struct wl_priv *wl, struct net_device *ndev,
 				n_valid_chan = dtoh32(list->count);
 				for (i = 0; i < num_chans; i++)
 				{
-					_freq = scan_request->channels[i]->center_freq;
+#ifdef WL_HOST_BAND_MGMT
+					int channel_band = 0;
+#endif /* WL_HOST_BAND_MGMT */
+					_freq = request->channels[i]->center_freq;
 					channel = ieee80211_frequency_to_channel(_freq);
-					/* remove DFS channels */
-					if (channel < 52 || channel > 140) {
-						for (j = 0; j < n_valid_chan; j++) {
-							/* allows only supported channel on
-							*  current reguatory
-							*/
-							if (channel == (dtoh32(list->element[j])))
-								default_chan_list[n_nodfs++] =
-									channel;
-						}
+#ifdef WL_HOST_BAND_MGMT
+					channel_band = (channel > CH_MAX_2G_CHANNEL) ?
+						WLC_BAND_5G : WLC_BAND_2G;
+					if ((wl->curr_band != WLC_BAND_AUTO) &&
+						(wl->curr_band != channel_band) &&
+						!IS_P2P_SOCIAL_CHANNEL(channel))
+							continue;
+#endif /* WL_HOST_BAND_MGMT */
+
+					/* ignore DFS channels */
+					if (request->channels[i]->flags &
+						(IEEE80211_CHAN_RADAR
+						| IEEE80211_CHAN_PASSIVE_SCAN))
+						continue;
+
+					for (j = 0; j < n_valid_chan; j++) {
+						/* allows only supported channel on
+						*  current reguatory
+						*/
+						if (channel == (dtoh32(list->element[j])))
+							default_chan_list[n_nodfs++] =
+								channel;
 					}
 
 				}
@@ -1647,12 +2077,18 @@ wl_run_escan(struct wl_priv *wl, struct net_device *ndev,
 		}
 		err = wl_cfgp2p_escan(wl, ndev, wl->active_scan, num_chans, default_chan_list,
 			search_state, action,
-			wl_to_p2p_bss_bssidx(wl, P2PAPI_BSSCFG_DEVICE));
+			wl_to_p2p_bss_bssidx(wl, P2PAPI_BSSCFG_DEVICE), NULL);
+		if(!err)
+			wl->p2p->search_state = search_state;
 		kfree(default_chan_list);
 	}
 exit:
 	if (unlikely(err)) {
-		WL_ERR(("error (%d)\n", err));
+		/* Don't print Error incase of Scan suppress */
+		if ((err == BCME_EPERM) && wl->scan_suppressed)
+			WL_DBG(("Escan failed: Scan Suppressed \n"));
+		else
+			WL_ERR(("error (%d)\n", err));
 	}
 	return err;
 }
@@ -1666,22 +2102,27 @@ wl_do_escan(struct wl_priv *wl, struct wiphy *wiphy, struct net_device *ndev,
 	s32 passive_scan;
 	wl_scan_results_t *results;
 	WL_SCAN(("Enter \n"));
+	mutex_lock(&wl->usr_sync);
+
+	results = wl_escan_get_buf(wl, FALSE);
+	results->version = 0;
+	results->count = 0;
+	results->buflen = WL_SCAN_RESULTS_FIXED_SIZE;
+
 	wl->escan_info.ndev = ndev;
 	wl->escan_info.wiphy = wiphy;
 	wl->escan_info.escan_state = WL_ESCAN_STATE_SCANING;
 	passive_scan = wl->active_scan ? 0 : 1;
 	err = wldev_ioctl(ndev, WLC_SET_PASSIVE_SCAN,
-		&passive_scan, sizeof(passive_scan), false);
+		&passive_scan, sizeof(passive_scan), true);
 	if (unlikely(err)) {
 		WL_ERR(("error (%d)\n", err));
-		return err;
+		goto exit;
 	}
-	results = (wl_scan_results_t *) wl->escan_info.escan_buf;
-	results->version = 0;
-	results->count = 0;
-	results->buflen = WL_SCAN_RESULTS_FIXED_SIZE;
 
 	err = wl_run_escan(wl, ndev, request, WL_SCAN_ACTION_START);
+exit:
+	mutex_unlock(&wl->usr_sync);
 	return err;
 }
 
@@ -1694,15 +2135,29 @@ __wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 	struct cfg80211_ssid *ssids;
 	struct wl_scan_req *sr = wl_to_sr(wl);
 	struct ether_addr primary_mac;
-	wpa_ie_fixed_t *wps_ie;
 	s32 passive_scan;
 	bool iscan_req;
 	bool escan_req = false;
 	bool p2p_ssid;
+#ifdef WL11U
+	bcm_tlv_t *interworking_ie;
+#endif
 	s32 err = 0;
+	s32 bssidx = -1;
 	s32 i;
-	u32 wpsie_len = 0;
-	u8 wpsie[IE_MAX_LEN];
+
+	unsigned long flags;
+	static s32 busy_count = 0;
+
+	static s32 disconnect_flag = 0;
+
+	dhd_pub_t *dhd;
+
+	dhd = (dhd_pub_t *)(wl->pub);
+	if (dhd->op_mode & DHD_FLAG_HOSTAP_MODE) {
+		WL_ERR(("Invalid Scan Command at SoftAP mode\n"));
+		return -EINVAL;
+	}
 
 	/* If scan req comes for p2p0, send it over primary I/F
 	 * Scan results will be delivered corresponding to cfg80211_scan_request
@@ -1711,10 +2166,20 @@ __wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 		ndev = wl_to_prmry_ndev(wl);
 	}
 
+	if (WL_DRV_STATUS_SENDING_AF_FRM_EXT(wl)) {
+		WL_ERR(("Sending Action Frames. Try it again.\n"));
+		return -EAGAIN;
+	}
+
 	WL_DBG(("Enter wiphy (%p)\n", wiphy));
 	if (wl_get_drv_status_all(wl, SCANNING)) {
-		WL_ERR(("Scanning already\n"));
-		return -EAGAIN;
+		if (wl->scan_request == NULL) {
+			wl_clr_drv_status_all(wl, SCANNING);
+			WL_DBG(("<<<<<<<<<<<Force Clear Scanning Status>>>>>>>>>>>\n"));
+		} else {
+			WL_ERR(("Scanning already\n"));
+			return -EAGAIN;
+		}
 	}
 	if (wl_get_drv_status(wl, SCAN_ABORTING, ndev)) {
 		WL_ERR(("Scanning being aborted\n"));
@@ -1724,9 +2189,16 @@ __wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 		WL_ERR(("request null or n_ssids > WL_SCAN_PARAMS_SSID_MAX\n"));
 		return -EOPNOTSUPP;
 	}
+#ifdef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
+	if (wl_get_drv_status_all(wl, REMAINING_ON_CHANNEL)) {
+		WL_DBG(("Remain_on_channel bit is set, somehow it didn't get cleared\n"));
+		wl_notify_escan_complete(wl, ndev, true, true);
+	}
+#endif /* WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
+
 
 	/* Arm scan timeout timer */
-	mod_timer(&wl->scan_timeout, jiffies + WL_SCAN_TIMER_INTERVAL_MS * HZ / 1000);
+	mod_timer(&wl->scan_timeout, jiffies + msecs_to_jiffies(WL_SCAN_TIMER_INTERVAL_MS));
 	iscan_req = false;
 	if (request) {		/* scan bss */
 		ssids = request->ssids;
@@ -1736,7 +2208,8 @@ __wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 			escan_req = true;
 			p2p_ssid = false;
 			for (i = 0; i < request->n_ssids; i++) {
-				if (ssids[i].ssid_len && IS_P2P_SSID(ssids[i].ssid)) {
+				if (ssids[i].ssid_len &&
+					IS_P2P_SSID(ssids[i].ssid, ssids[i].ssid_len)) {
 					p2p_ssid = true;
 					break;
 				}
@@ -1744,6 +2217,8 @@ __wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 			if (p2p_ssid) {
 				if (wl->p2p_supported) {
 					/* p2p scan trigger */
+					wldev_iovar_setint(ndev, "mpc", 0);
+
 					if (p2p_on(wl) == false) {
 						/* p2p on at the first time */
 						p2p_on(wl) = true;
@@ -1752,6 +2227,8 @@ __wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 						wl_cfgp2p_generate_bss_mac(&primary_mac,
 							&wl->p2p->dev_addr, &wl->p2p->int_addr);
 					}
+					wl_clr_p2p_status(wl, GO_NEG_PHASE);
+					WL_DBG(("P2P: GO_NEG_PHASE status cleared \n"));
 					p2p_scan(wl) = true;
 				}
 			} else {
@@ -1763,8 +2240,6 @@ __wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 					/* If Netdevice is not equals to primary and p2p is on
 					*  , we will do p2p scan using P2PAPI_BSSCFG_DEVICE.
 					*/
-					if (p2p_on(wl) && (ndev != wl_to_prmry_ndev(wl)))
-						p2p_scan(wl) = true;
 
 					if (p2p_scan(wl) == false) {
 						if (wl_get_p2p_status(wl, DISCOVERY_ON)) {
@@ -1778,24 +2253,44 @@ __wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 					}
 				}
 				if (!wl->p2p_supported || !p2p_scan(wl)) {
-					if (ndev == wl_to_prmry_ndev(wl)) {
-						/* find the WPSIE */
-						memset(wpsie, 0, sizeof(wpsie));
-						if ((wps_ie = wl_cfgp2p_find_wpsie(
-							(u8 *)request->ie,
-							request->ie_len)) != NULL) {
-							wpsie_len =
-							wps_ie->length + WPA_RSN_IE_TAG_FIXED_LEN;
-							memcpy(wpsie, wps_ie, wpsie_len);
-						} else {
-							wpsie_len = 0;
-						}
-						err = wl_cfgp2p_set_management_ie(wl, ndev, -1,
-							VNDR_IE_PRBREQ_FLAG, wpsie, wpsie_len);
+
+					if (wl_cfgp2p_find_idx(wl, ndev, &bssidx) != BCME_OK) {
+						WL_ERR(("Find p2p index from ndev(%p) failed\n",
+							ndev));
+						err = BCME_ERROR;
+						goto scan_out;
+					}
+#ifdef WL11U
+					if ((interworking_ie = wl_cfg80211_find_interworking_ie(
+						(u8 *)request->ie, request->ie_len)) != NULL) {
+						err = wl_cfg80211_add_iw_ie(wl, ndev, bssidx,
+						       VNDR_IE_CUSTOM_FLAG, interworking_ie->id,
+						       interworking_ie->data, interworking_ie->len);
+
 						if (unlikely(err)) {
 							goto scan_out;
 						}
+					} else if (wl->iw_ie_len != 0) {
+					/* we have to clear IW IE and disable gratuitous APR */
+						wl_cfg80211_add_iw_ie(wl, ndev, bssidx,
+							VNDR_IE_CUSTOM_FLAG,
+							DOT11_MNG_INTERWORKING_ID,
+							0, 0);
+
+						wldev_iovar_setint_bsscfg(ndev, "grat_arp", 0,
+							bssidx);
+						wl->wl11u = FALSE;
+						/* we don't care about error */
+					}
+#endif /* WL11U */
+					err = wl_cfgp2p_set_management_ie(wl, ndev, bssidx,
+						VNDR_IE_PRBREQ_FLAG, (u8 *)request->ie,
+						request->ie_len);
+
+					if (unlikely(err)) {
+						goto scan_out;
 					}
+
 				}
 			}
 		}
@@ -1803,18 +2298,24 @@ __wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 		/* we don't do iscan in ibss */
 		ssids = this_ssid;
 	}
+	if (request && !p2p_scan(wl))
+		WL_TRACE_HW4(("START SCAN\n"));
 	wl->scan_request = request;
 	wl_set_drv_status(wl, SCANNING, ndev);
 	if (iscan_req) {
 		err = wl_do_iscan(wl, request);
 		if (likely(!err))
-			return err;
+			goto scan_success;
 		else
 			goto scan_out;
 	} else if (escan_req) {
 		if (wl->p2p_supported) {
 			if (p2p_on(wl) && p2p_scan(wl)) {
 
+				/* find my listen channel */
+				wl->afx_hdl->my_listen_chan =
+					wl_find_listen_channel(wl, request->ie,
+					request->ie_len);
 				err = wl_cfgp2p_enable_discovery(wl, ndev,
 				request->ie, request->ie_len);
 
@@ -1825,7 +2326,7 @@ __wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 		}
 		err = wl_do_escan(wl, wiphy, ndev, request);
 		if (likely(!err))
-			return err;
+			goto scan_success;
 		else
 			goto scan_out;
 
@@ -1845,7 +2346,7 @@ __wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 		WL_SCAN(("sr->ssid.SSID_len (%d)\n", sr->ssid.SSID_len));
 		passive_scan = wl->active_scan ? 0 : 1;
 		err = wldev_ioctl(ndev, WLC_SET_PASSIVE_SCAN,
-			&passive_scan, sizeof(passive_scan), false);
+			&passive_scan, sizeof(passive_scan), true);
 		if (unlikely(err)) {
 			WL_SCAN(("WLC_SET_PASSIVE_SCAN error (%d)\n", err));
 			goto scan_out;
@@ -1863,27 +2364,108 @@ __wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 		}
 	}
 
+scan_success:
+	busy_count = 0;
+
+	disconnect_flag = 0;
+
 	return 0;
 
 scan_out:
-	wl_clr_drv_status(wl, SCANNING, ndev);
-	wl->scan_request = NULL;
-	return err;
-}
-
-static s32
-wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
-	struct cfg80211_scan_request *request)
-{
-	s32 err = 0;
-	struct wl_priv *wl = wiphy_priv(wiphy);
+	if (err == BCME_BUSY || err == BCME_NOTREADY) {
+		WL_ERR(("Scan err = (%d), busy?%d", err, -EBUSY));
+		err = -EBUSY;
+	}
+
+#define SCAN_EBUSY_RETRY_LIMIT 10
+	if (err == -EBUSY) {
+		if (busy_count++ > SCAN_EBUSY_RETRY_LIMIT) {
+			struct ether_addr bssid;
+			s32 ret = 0;
+			busy_count = 0;
+			WL_ERR(("Unusual continuous EBUSY error, %d %d %d %d %d %d %d %d %d\n",
+				wl_get_drv_status(wl, SCANNING, ndev),
+				wl_get_drv_status(wl, SCAN_ABORTING, ndev),
+				wl_get_drv_status(wl, CONNECTING, ndev),
+				wl_get_drv_status(wl, CONNECTED, ndev),
+				wl_get_drv_status(wl, DISCONNECTING, ndev),
+				wl_get_drv_status(wl, AP_CREATING, ndev),
+				wl_get_drv_status(wl, AP_CREATED, ndev),
+				wl_get_drv_status(wl, SENDING_ACT_FRM, ndev),
+				wl_get_drv_status(wl, SENDING_ACT_FRM, ndev)));
+
+			bzero(&bssid, sizeof(bssid));
+			if ((ret = wldev_ioctl(ndev, WLC_GET_BSSID,
+				&bssid, ETHER_ADDR_LEN, false)) == 0)
+				WL_ERR(("FW is connected with " MACDBG "/n",
+					MAC2STRDBG(bssid.octet)));
+			else
+				WL_ERR(("GET BSSID failed with %d\n", ret));
 
-	WL_DBG(("Enter \n"));
-	CHECK_SYS_UP(wl);
+			wl_notify_escan_complete(wl, ndev, true, true);
 
-	err = __wl_cfg80211_scan(wiphy, ndev, request, NULL);
-	if (unlikely(err)) {
-		WL_ERR(("scan error (%d)\n", err));
+#if 0
+			wl_cfg80211_disconnect(wiphy, ndev, DOT11_RC_DISASSOC_LEAVING);
+#else
+			if (!disconnect_flag) {
+				if (wl_get_drv_status(wl, CONNECTING, ndev)) {
+					int val = 0;
+					int err;
+
+					/* stop to do association */
+					printf("%s: abort the connecting procedure.\n", __func__);
+					err = wldev_ioctl(ndev, WLC_DISASSOC, &val, sizeof(val), true);
+					if (unlikely(err)) {
+						WL_ERR(("call WLC_DISASSOC failed. (%d)\n", err));
+					}
+				/* notify wpa_supplicant the association abort */
+				wl_bss_connect_done(wl, ndev, NULL, NULL, false);
+				} else {
+#if 0
+					wl_cfg80211_disconnect(wiphy, ndev, DOT11_RC_DISASSOC_LEAVING);
+#else
+					wl_notify_escan_complete(wl, ndev, true, true);
+#endif
+				}
+				disconnect_flag = 1;
+			} else {
+				net_os_send_hang_message(ndev);
+				disconnect_flag = 0;
+			}
+#endif
+		}
+	} else {
+		busy_count = 0;
+		disconnect_flag = 0;
+
+	}
+
+	wl_clr_drv_status(wl, SCANNING, ndev);
+	if (timer_pending(&wl->scan_timeout))
+		del_timer_sync(&wl->scan_timeout);
+	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
+	wl->scan_request = NULL;
+	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
+
+	return err;
+}
+
+static s32
+wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
+	struct cfg80211_scan_request *request)
+{
+	s32 err = 0;
+	struct wl_priv *wl = wiphy_priv(wiphy);
+
+	WL_DBG(("Enter \n"));
+	RETURN_EIO_IF_NOT_UP(wl);
+
+	err = __wl_cfg80211_scan(wiphy, ndev, request, NULL);
+	if (unlikely(err)) {
+		if ((err == BCME_EPERM) && wl->scan_suppressed)
+			WL_DBG(("scan not permitted at this time (%d)\n", err));
+		else
+			WL_ERR(("scan error (%d)\n", err));
 		return err;
 	}
 
@@ -1920,7 +2502,7 @@ static s32 wl_set_retry(struct net_device *dev, u32 retry, bool l)
 	u32 cmd = (l ? WLC_SET_LRL : WLC_SET_SRL);
 
 	retry = htod32(retry);
-	err = wldev_ioctl(dev, cmd, &retry, sizeof(retry), false);
+	err = wldev_ioctl(dev, cmd, &retry, sizeof(retry), true);
 	if (unlikely(err)) {
 		WL_ERR(("cmd (%d) , error (%d)\n", cmd, err));
 		return err;
@@ -1934,7 +2516,7 @@ static s32 wl_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)
 	struct net_device *ndev = wl_to_prmry_ndev(wl);
 	s32 err = 0;
 
-	CHECK_SYS_UP(wl);
+	RETURN_EIO_IF_NOT_UP(wl);
 	WL_DBG(("Enter\n"));
 	if (changed & WIPHY_PARAM_RTS_THRESHOLD &&
 		(wl->conf->rts_threshold != wiphy->rts_threshold)) {
@@ -1983,7 +2565,7 @@ wl_cfg80211_join_ibss(struct wiphy *wiphy, struct net_device *dev,
 	bool rollback_lock = false;
 
 	WL_TRACE(("In\n"));
-	CHECK_SYS_UP(wl);
+	RETURN_EIO_IF_NOT_UP(wl);
 	if (params->bssid) {
 		WL_ERR(("Invalid bssid\n"));
 		return -EOPNOTSUPP;
@@ -2008,7 +2590,7 @@ wl_cfg80211_join_ibss(struct wiphy *wiphy, struct net_device *dev,
 		}
 
 		/* wait 4 secons till scan done.... */
-		schedule_timeout_interruptible(4 * HZ);
+		schedule_timeout_interruptible(msecs_to_jiffies(4000));
 		if (rollback_lock)
 			rtnl_lock();
 		bss = cfg80211_get_ibss(wiphy, NULL,
@@ -2038,7 +2620,7 @@ wl_cfg80211_join_ibss(struct wiphy *wiphy, struct net_device *dev,
 		memset(&join_params.params.bssid, 0, ETHER_ADDR_LEN);
 
 	err = wldev_ioctl(dev, WLC_SET_SSID, &join_params,
-		sizeof(join_params), false);
+		sizeof(join_params), true);
 	if (unlikely(err)) {
 		WL_ERR(("Error (%d)\n", err));
 		return err;
@@ -2051,12 +2633,50 @@ static s32 wl_cfg80211_leave_ibss(struct wiphy *wiphy, struct net_device *dev)
 	struct wl_priv *wl = wiphy_priv(wiphy);
 	s32 err = 0;
 
-	CHECK_SYS_UP(wl);
+	RETURN_EIO_IF_NOT_UP(wl);
 	wl_link_down(wl);
 
 	return err;
 }
 
+#ifdef MFP
+static int wl_cfg80211_get_rsn_capa(bcm_tlv_t *wpa2ie, u8* capa)
+{
+	u16 suite_count;
+	wpa_suite_mcast_t *mcast;
+	wpa_suite_ucast_t *ucast;
+	u16 len;
+	wpa_suite_auth_key_mgmt_t *mgmt;
+
+	if (!wpa2ie)
+		return -1;
+
+	len = wpa2ie->len;
+	mcast = (wpa_suite_mcast_t *)&wpa2ie->data[WPA2_VERSION_LEN];
+	if ((len -= WPA_SUITE_LEN) <= 0)
+		return BCME_BADLEN;
+	ucast = (wpa_suite_ucast_t *)&mcast[1];
+	suite_count = ltoh16_ua(&ucast->count);
+	if ((suite_count > NL80211_MAX_NR_CIPHER_SUITES) ||
+		(len -= (WPA_IE_SUITE_COUNT_LEN +
+		(WPA_SUITE_LEN * suite_count))) <= 0)
+		return BCME_BADLEN;
+
+	mgmt = (wpa_suite_auth_key_mgmt_t *)&ucast->list[suite_count];
+	suite_count = ltoh16_ua(&mgmt->count);
+
+	if ((suite_count > NL80211_MAX_NR_CIPHER_SUITES) ||
+		(len -= (WPA_IE_SUITE_COUNT_LEN +
+		(WPA_SUITE_LEN * suite_count))) >= RSN_CAP_LEN) {
+		capa[0] = *(u8 *)&mgmt->list[suite_count];
+		capa[1] = *((u8 *)&mgmt->list[suite_count] + 1);
+	} else
+		return BCME_BADLEN;
+
+	return 0;
+}
+#endif /* MFP */
+
 static s32
 wl_set_wpa_version(struct net_device *dev, struct cfg80211_connect_params *sme)
 {
@@ -2064,12 +2684,24 @@ wl_set_wpa_version(struct net_device *dev, struct cfg80211_connect_params *sme)
 	struct wl_security *sec;
 	s32 val = 0;
 	s32 err = 0;
-	s32 bssidx = wl_cfgp2p_find_idx(wl, dev);
+	s32 bssidx;
+	if (wl_cfgp2p_find_idx(wl, dev, &bssidx) != BCME_OK) {
+		WL_ERR(("Find p2p index from dev(%p) failed\n", dev));
+		return BCME_ERROR;
+	}
 
 	if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_1)
-		val = WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED;
+		val = WPA_AUTH_PSK |
+#ifdef BCMCCX
+			WPA_AUTH_CCKM |
+#endif
+			WPA_AUTH_UNSPECIFIED;
 	else if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2)
-		val = WPA2_AUTH_PSK| WPA2_AUTH_UNSPECIFIED;
+		val = WPA2_AUTH_PSK|
+#ifdef BCMCCX
+			WPA2_AUTH_CCKM |
+#endif
+			WPA2_AUTH_UNSPECIFIED;
 	else
 		val = WPA_AUTH_DISABLED;
 
@@ -2100,7 +2732,11 @@ wl_set_set_wapi_ie(struct net_device *dev, struct cfg80211_connect_params *sme)
 {
 	struct wl_priv *wl = wlcfg_drv_priv;
 	s32 err = 0;
-	s32 bssidx = wl_cfgp2p_find_idx(wl, dev);
+	s32 bssidx;
+	if (wl_cfgp2p_find_idx(wl, dev, &bssidx) != BCME_OK) {
+		WL_ERR(("Find p2p index from dev(%p) failed\n", dev));
+		return BCME_ERROR;
+	}
 
 	WL_DBG((" %s \n", __FUNCTION__));
 
@@ -2125,22 +2761,31 @@ wl_set_auth_type(struct net_device *dev, struct cfg80211_connect_params *sme)
 	struct wl_security *sec;
 	s32 val = 0;
 	s32 err = 0;
-	s32 bssidx = wl_cfgp2p_find_idx(wl, dev);
+	s32 bssidx;
+	if (wl_cfgp2p_find_idx(wl, dev, &bssidx) != BCME_OK) {
+		WL_ERR(("Find p2p index from dev(%p) failed\n", dev));
+		return BCME_ERROR;
+	}
+
 	switch (sme->auth_type) {
 	case NL80211_AUTHTYPE_OPEN_SYSTEM:
-		val = 0;
+		val = WL_AUTH_OPEN_SYSTEM;
 		WL_DBG(("open system\n"));
 		break;
 	case NL80211_AUTHTYPE_SHARED_KEY:
-		val = 1;
+		val = WL_AUTH_SHARED_KEY;
 		WL_DBG(("shared key\n"));
 		break;
 	case NL80211_AUTHTYPE_AUTOMATIC:
-		val = 2;
+		val = WL_AUTH_OPEN_SHARED;
 		WL_DBG(("automatic\n"));
 		break;
+#ifdef BCMCCX
 	case NL80211_AUTHTYPE_NETWORK_EAP:
 		WL_DBG(("network eap\n"));
+		val = DOT11_LEAP_AUTH;
+		break;
+#endif
 	default:
 		val = 2;
 		WL_ERR(("invalid auth type (%d)\n", sme->auth_type));
@@ -2165,10 +2810,21 @@ wl_set_set_cipher(struct net_device *dev, struct cfg80211_connect_params *sme)
 	s32 pval = 0;
 	s32 gval = 0;
 	s32 err = 0;
+	s32 wsec_val = 0;
+#ifdef MFP
+	s32 mfp = 0;
+	bcm_tlv_t *wpa2_ie;
+	u8 rsn_cap[2];
+#endif /* MFP */
+
 #ifdef BCMWAPI_WPI
 	s32 val = 0;
 #endif
-	s32 bssidx = wl_cfgp2p_find_idx(wl, dev);
+	s32 bssidx;
+	if (wl_cfgp2p_find_idx(wl, dev, &bssidx) != BCME_OK) {
+		WL_ERR(("Find p2p index from dev(%p) failed\n", dev));
+		return BCME_ERROR;
+	}
 
 	if (sme->crypto.n_ciphers_pairwise) {
 		switch (sme->crypto.ciphers_pairwise[0]) {
@@ -2180,8 +2836,6 @@ wl_set_set_cipher(struct net_device *dev, struct cfg80211_connect_params *sme)
 			pval = TKIP_ENABLED;
 			break;
 		case WLAN_CIPHER_SUITE_CCMP:
-			pval = AES_ENABLED;
-			break;
 		case WLAN_CIPHER_SUITE_AES_CMAC:
 			pval = AES_ENABLED;
 			break;
@@ -2197,6 +2851,24 @@ wl_set_set_cipher(struct net_device *dev, struct cfg80211_connect_params *sme)
 			return -EINVAL;
 		}
 	}
+#if defined(BCMSUP_4WAY_HANDSHAKE) && defined(WLAN_AKM_SUITE_FT_8021X)
+	/* Ensure in-dongle supplicant is turned on when FBT wants to do the 4-way
+	 * handshake.
+	 * Note that the FW feature flag only exists on kernels that support the
+	 * FT-EAP AKM suite.
+	 */
+	if (wl->wdev->wiphy->features & NL80211_FEATURE_FW_4WAY_HANDSHAKE) {
+		if (pval == AES_ENABLED)
+			err = wldev_iovar_setint_bsscfg(dev, "sup_wpa", 1, bssidx);
+		else
+			err = wldev_iovar_setint_bsscfg(dev, "sup_wpa", 0, bssidx);
+
+		if (err) {
+			WL_ERR(("FBT: Error setting sup_wpa (%d)\n", err));
+			return err;
+		}
+	}
+#endif /* BCMSUP_4WAY_HANDSHAKE && WLAN_AKM_SUITE_FT_8021X */
 	if (sme->crypto.cipher_group) {
 		switch (sme->crypto.cipher_group) {
 		case WLAN_CIPHER_SUITE_WEP40:
@@ -2228,7 +2900,11 @@ wl_set_set_cipher(struct net_device *dev, struct cfg80211_connect_params *sme)
 	WL_DBG(("pval (%d) gval (%d)\n", pval, gval));
 
 	if (is_wps_conn(sme)) {
-		err = wldev_iovar_setint_bsscfg(dev, "wsec", 4, bssidx);
+		if (sme->privacy)
+			err = wldev_iovar_setint_bsscfg(dev, "wsec", 4, bssidx);
+		else
+			/* WPS-2.0 allows no security */
+			err = wldev_iovar_setint_bsscfg(dev, "wsec", 0, bssidx);
 	} else {
 #ifdef BCMWAPI_WPI
 		if (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_SMS4) {
@@ -2237,8 +2913,46 @@ wl_set_set_cipher(struct net_device *dev, struct cfg80211_connect_params *sme)
 		} else {
 #endif
 			WL_DBG((" NO, is_wps_conn, Set pval | gval to WSEC"));
+			wsec_val = pval | gval;
+
+#ifdef MFP
+			if (pval == AES_ENABLED) {
+				if (((wpa2_ie = bcm_parse_tlvs((u8 *)sme->ie, sme->ie_len,
+					DOT11_MNG_RSN_ID)) != NULL) &&
+					(wl_cfg80211_get_rsn_capa(wpa2_ie, rsn_cap) == 0)) {
+
+					if (rsn_cap[0] & RSN_CAP_MFPC) {
+						/* MFP Capability advertised by supplicant. Check
+						 * whether MFP is supported in the firmware
+						 */
+						if ((err = wldev_iovar_getint_bsscfg(dev,
+								"mfp", &mfp, bssidx)) < 0) {
+							WL_ERR(("Get MFP failed! "
+								"Check MFP support in FW \n"));
+							return -1;
+						}
+
+						if ((sme->crypto.n_akm_suites == 1) &&
+							((sme->crypto.akm_suites[0] ==
+							WL_AKM_SUITE_MFP_PSK) ||
+							(sme->crypto.akm_suites[0] ==
+							WL_AKM_SUITE_MFP_1X))) {
+							wsec_val |= MFP_SHA256;
+						} else if (sme->crypto.n_akm_suites > 1) {
+							WL_ERR(("Multiple AKM Specified \n"));
+							return -EINVAL;
+						}
+
+						wsec_val |= MFP_CAPABLE;
+						if (rsn_cap[0] & RSN_CAP_MFPR)
+							wsec_val |= MFP_REQUIRED;
+					}
+				}
+			}
+#endif /* MFP */
+			WL_DBG((" Set WSEC to fW 0x%x \n", wsec_val));
 			err = wldev_iovar_setint_bsscfg(dev, "wsec",
-				pval | gval, bssidx);
+				wsec_val, bssidx);
 #ifdef BCMWAPI_WPI
 		}
 #endif
@@ -2262,7 +2976,11 @@ wl_set_key_mgmt(struct net_device *dev, struct cfg80211_connect_params *sme)
 	struct wl_security *sec;
 	s32 val = 0;
 	s32 err = 0;
-	s32 bssidx = wl_cfgp2p_find_idx(wl, dev);
+	s32 bssidx;
+	if (wl_cfgp2p_find_idx(wl, dev, &bssidx) != BCME_OK) {
+		WL_ERR(("Find p2p index from dev(%p) failed\n", dev));
+		return BCME_ERROR;
+	}
 
 	if (sme->crypto.n_akm_suites) {
 		err = wldev_iovar_getint(dev, "wpa_auth", &val);
@@ -2270,7 +2988,11 @@ wl_set_key_mgmt(struct net_device *dev, struct cfg80211_connect_params *sme)
 			WL_ERR(("could not get wpa_auth (%d)\n", err));
 			return err;
 		}
-		if (val & (WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED)) {
+		if (val & (WPA_AUTH_PSK |
+#ifdef BCMCCX
+			WPA_AUTH_CCKM |
+#endif
+			WPA_AUTH_UNSPECIFIED)) {
 			switch (sme->crypto.akm_suites[0]) {
 			case WLAN_AKM_SUITE_8021X:
 				val = WPA_AUTH_UNSPECIFIED;
@@ -2278,19 +3000,51 @@ wl_set_key_mgmt(struct net_device *dev, struct cfg80211_connect_params *sme)
 			case WLAN_AKM_SUITE_PSK:
 				val = WPA_AUTH_PSK;
 				break;
+#ifdef BCMCCX
+			case WLAN_AKM_SUITE_CCKM:
+				val = WPA_AUTH_CCKM;
+				break;
+#endif
 			default:
 				WL_ERR(("invalid cipher group (%d)\n",
 					sme->crypto.cipher_group));
 				return -EINVAL;
 			}
-		} else if (val & (WPA2_AUTH_PSK | WPA2_AUTH_UNSPECIFIED)) {
+		} else if (val & (WPA2_AUTH_PSK |
+#ifdef BCMCCX
+			WPA2_AUTH_CCKM |
+#endif
+			WPA2_AUTH_UNSPECIFIED)) {
 			switch (sme->crypto.akm_suites[0]) {
 			case WLAN_AKM_SUITE_8021X:
 				val = WPA2_AUTH_UNSPECIFIED;
 				break;
+#ifdef MFP
+			case WL_AKM_SUITE_MFP_1X:
+				val = WPA2_AUTH_UNSPECIFIED;
+				break;
+			case WL_AKM_SUITE_MFP_PSK:
+				val = WPA2_AUTH_PSK;
+				break;
+#endif
 			case WLAN_AKM_SUITE_PSK:
 				val = WPA2_AUTH_PSK;
 				break;
+#if defined(WLFBT) && defined(WLAN_AKM_SUITE_FT_8021X)
+			case WLAN_AKM_SUITE_FT_8021X:
+				val = WPA2_AUTH_UNSPECIFIED | WPA2_AUTH_FT;
+				break;
+#endif
+#if defined(WLFBT) && defined(WLAN_AKM_SUITE_FT_PSK)
+			case WLAN_AKM_SUITE_FT_PSK:
+				val = WPA2_AUTH_PSK | WPA2_AUTH_FT;
+				break;
+#endif
+#ifdef BCMCCX
+			case WLAN_AKM_SUITE_CCKM:
+				val = WPA2_AUTH_CCKM;
+				break;
+#endif
 			default:
 				WL_ERR(("invalid cipher group (%d)\n",
 					sme->crypto.cipher_group));
@@ -2315,6 +3069,25 @@ wl_set_key_mgmt(struct net_device *dev, struct cfg80211_connect_params *sme)
 #endif
 		WL_DBG(("setting wpa_auth to %d\n", val));
 
+#ifdef BCMCCX
+		if (val & (WPA_AUTH_CCKM|WPA2_AUTH_CCKM)) {
+			WL_DBG(("SET CCX enable\n"));
+			wldev_iovar_setint_bsscfg(dev, "okc_enable", 0, bssidx);
+			err = wldev_iovar_setint_bsscfg(dev, "ccx_enable", 1, bssidx);
+
+			if (unlikely(err)) {
+				WL_ERR(("could not set ccx_enable (%d)\n", err));
+				return err;
+			}
+		} else {
+			err = wldev_iovar_setint_bsscfg(dev, "ccx_enable", 0, bssidx);
+
+			if (unlikely(err)) {
+				WL_ERR(("could not set ccx_disable (%d)\n", err));
+			}
+		}
+#endif /* BCMCCX */
+
 		err = wldev_iovar_setint_bsscfg(dev, "wpa_auth", val, bssidx);
 		if (unlikely(err)) {
 			WL_ERR(("could not set wpa_auth (%d)\n", err));
@@ -2336,7 +3109,11 @@ wl_set_set_sharedkey(struct net_device *dev,
 	struct wl_wsec_key key;
 	s32 val;
 	s32 err = 0;
-	s32 bssidx = wl_cfgp2p_find_idx(wl, dev);
+	s32 bssidx;
+	if (wl_cfgp2p_find_idx(wl, dev, &bssidx) != BCME_OK) {
+		WL_ERR(("Find p2p index from dev(%p) failed\n", dev));
+		return BCME_ERROR;
+	}
 
 	WL_DBG(("key len (%d)\n", sme->key_len));
 	if (sme->key_len) {
@@ -2393,9 +3170,9 @@ wl_set_set_sharedkey(struct net_device *dev,
 				WL_ERR(("WLC_SET_KEY error (%d)\n", err));
 				return err;
 			}
-			if (sec->auth_type == NL80211_AUTHTYPE_OPEN_SYSTEM) {
+			if (sec->auth_type == NL80211_AUTHTYPE_SHARED_KEY) {
 				WL_DBG(("set auth_type to shared key\n"));
-				val = 1;	/* shared key */
+				val = WL_AUTH_SHARED_KEY;	/* shared key */
 				err = wldev_iovar_setint_bsscfg(dev, "auth", val, bssidx);
 				if (unlikely(err)) {
 					WL_ERR(("set auth failed (%d)\n", err));
@@ -2407,6 +3184,13 @@ wl_set_set_sharedkey(struct net_device *dev,
 	return err;
 }
 
+#if defined(ESCAN_RESULT_PATCH)
+static u8 connect_req_bssid[6];
+static u8 broad_bssid[6];
+#endif /* ESCAN_RESULT_PATCH */
+
+
+
 static s32
 wl_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 	struct cfg80211_connect_params *sme)
@@ -2418,99 +3202,134 @@ wl_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 	size_t join_params_size;
 	s32 err = 0;
 	wpa_ie_fixed_t *wpa_ie;
-	wpa_ie_fixed_t *wps_ie;
 	bcm_tlv_t *wpa2_ie;
 	u8* wpaie  = 0;
 	u32 wpaie_len = 0;
-	u32 wpsie_len = 0;
 	u32 chan_cnt = 0;
-	u8 wpsie[IE_MAX_LEN];
 	struct ether_addr bssid;
+	s32 bssidx;
+	int ret;
+	int wait_cnt;
+
 	WL_DBG(("In\n"));
-	CHECK_SYS_UP(wl);
+
+	if (unlikely(!sme->ssid)) {
+		WL_ERR(("Invalid ssid\n"));
+		return -EOPNOTSUPP;
+	}
+
+	if (unlikely(sme->ssid_len > DOT11_MAX_SSID_LEN)) {
+		WL_ERR(("Invalid SSID info: SSID=%s, length=%d\n",
+			sme->ssid, sme->ssid_len));
+		return -EINVAL;
+	}
+
+	RETURN_EIO_IF_NOT_UP(wl);
 
 	/*
 	 * Cancel ongoing scan to sync up with sme state machine of cfg80211.
 	 */
+#if !defined(ESCAN_RESULT_PATCH)
 	if (wl->scan_request) {
 		wl_notify_escan_complete(wl, dev, true, true);
 	}
+#endif
+#if defined(ESCAN_RESULT_PATCH)
+	if (sme->bssid)
+		memcpy(connect_req_bssid, sme->bssid, ETHER_ADDR_LEN);
+	else
+		bzero(connect_req_bssid, ETHER_ADDR_LEN);
+	bzero(broad_bssid, ETHER_ADDR_LEN);
+#endif
+
+	bzero(&bssid, sizeof(bssid));
+	if (!wl_get_drv_status(wl, CONNECTED, dev)&&
+		(ret = wldev_ioctl(dev, WLC_GET_BSSID, &bssid, ETHER_ADDR_LEN, false)) == 0) {
+		if (!ETHER_ISNULLADDR(&bssid)) {
+			scb_val_t scbval;
+			wl_set_drv_status(wl, DISCONNECTING, dev);
+			scbval.val = DOT11_RC_DISASSOC_LEAVING;
+			memcpy(&scbval.ea, &bssid, ETHER_ADDR_LEN);
+			scbval.val = htod32(scbval.val);
+
+			WL_DBG(("drv status CONNECTED is not set, but connected in FW!" MACDBG "/n",
+				MAC2STRDBG(bssid.octet)));
+			err = wldev_ioctl(dev, WLC_DISASSOC, &scbval,
+				sizeof(scb_val_t), true);
+			if (unlikely(err)) {
+				wl_clr_drv_status(wl, DISCONNECTING, dev);
+				WL_ERR(("error (%d)\n", err));
+				return err;
+			}
+			wait_cnt = 500/10;
+			while (wl_get_drv_status(wl, DISCONNECTING, dev) && wait_cnt) {
+				WL_DBG(("Waiting for disconnection terminated, wait_cnt: %d\n",
+					wait_cnt));
+				wait_cnt--;
+				msleep(10);
+			}
+		} else
+			WL_DBG(("Currently not associated!\n"));
+	} else {
+		/* if status is DISCONNECTING, wait for disconnection terminated max 500 ms */
+		wait_cnt = 500/10;
+		while (wl_get_drv_status(wl, DISCONNECTING, dev) && wait_cnt) {
+			WL_DBG(("Waiting for disconnection terminated, wait_cnt: %d\n", wait_cnt));
+			wait_cnt--;
+			msleep(10);
+		}
+	}
+
 	/* Clean BSSID */
 	bzero(&bssid, sizeof(bssid));
-	wl_update_prof(wl, dev, NULL, (void *)&bssid, WL_PROF_BSSID);
+	if (!wl_get_drv_status(wl, DISCONNECTING, dev))
+		wl_update_prof(wl, dev, NULL, (void *)&bssid, WL_PROF_BSSID);
 
-	if (IS_P2P_SSID(sme->ssid) && (dev != wl_to_prmry_ndev(wl))) {
+	if (p2p_is_on(wl) && (dev != wl_to_prmry_ndev(wl))) {
 		/* we only allow to connect using virtual interface in case of P2P */
-		if (p2p_is_on(wl) && is_wps_conn(sme)) {
-			WL_DBG(("ASSOC1 p2p index : %d sme->ie_len %d\n",
-				wl_cfgp2p_find_idx(wl, dev), sme->ie_len));
-			/* Have to apply WPS IE + P2P IE in assoc req frame */
-			wl_cfgp2p_set_management_ie(wl, dev,
-				wl_cfgp2p_find_idx(wl, dev), VNDR_IE_PRBREQ_FLAG,
-				wl_to_p2p_bss_saved_ie(wl, P2PAPI_BSSCFG_DEVICE).p2p_probe_req_ie,
-				wl_to_p2p_bss_saved_ie(wl,
-				P2PAPI_BSSCFG_DEVICE).p2p_probe_req_ie_len);
-			wl_cfgp2p_set_management_ie(wl, dev, wl_cfgp2p_find_idx(wl, dev),
-				VNDR_IE_ASSOCREQ_FLAG, sme->ie, sme->ie_len);
-		} else if (p2p_is_on(wl) && (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2)) {
-			/* This is the connect req after WPS is done [credentials exchanged]
-			 * currently identified with WPA_VERSION_2 .
-			 * Update the previously set IEs with
-			 * the newly received IEs from Supplicant. This will remove the WPS IE from
-			 * the Assoc Req.
-			 */
-			WL_DBG(("ASSOC2 p2p index : %d sme->ie_len %d\n",
-				wl_cfgp2p_find_idx(wl, dev), sme->ie_len));
-			wl_cfgp2p_set_management_ie(wl, dev, wl_cfgp2p_find_idx(wl, dev),
+			if (wl_cfgp2p_find_idx(wl, dev, &bssidx) != BCME_OK) {
+				WL_ERR(("Find p2p index from dev(%p) failed\n", dev));
+				return BCME_ERROR;
+			}
+			wl_cfgp2p_set_management_ie(wl, dev, bssidx,
 				VNDR_IE_ASSOCREQ_FLAG, sme->ie, sme->ie_len);
-		}
-
 	} else if (dev == wl_to_prmry_ndev(wl)) {
-			/* find the RSN_IE */
-			if ((wpa2_ie = bcm_parse_tlvs((u8 *)sme->ie, sme->ie_len,
-				DOT11_MNG_RSN_ID)) != NULL) {
-				WL_DBG((" WPA2 IE is found\n"));
-			}
-			/* find the WPA_IE */
-			if ((wpa_ie = wl_cfgp2p_find_wpaie((u8 *)sme->ie,
-				sme->ie_len)) != NULL) {
-				WL_DBG((" WPA IE is found\n"));
-			}
-			if (wpa_ie != NULL || wpa2_ie != NULL) {
-				wpaie = (wpa_ie != NULL) ? (u8 *)wpa_ie : (u8 *)wpa2_ie;
-				wpaie_len = (wpa_ie != NULL) ? wpa_ie->length : wpa2_ie->len;
-				wpaie_len += WPA_RSN_IE_TAG_FIXED_LEN;
-				wldev_iovar_setbuf(dev, "wpaie", wpaie, wpaie_len,
-					wl->ioctl_buf, WLC_IOCTL_MAXLEN, &wl->ioctl_buf_sync);
-			} else {
-				wldev_iovar_setbuf(dev, "wpaie", NULL, 0,
-					wl->ioctl_buf, WLC_IOCTL_MAXLEN, &wl->ioctl_buf_sync);
-			}
+		/* find the RSN_IE */
+		if ((wpa2_ie = bcm_parse_tlvs((u8 *)sme->ie, sme->ie_len,
+			DOT11_MNG_RSN_ID)) != NULL) {
+			WL_DBG((" WPA2 IE is found\n"));
+		}
+		/* find the WPA_IE */
+		if ((wpa_ie = wl_cfgp2p_find_wpaie((u8 *)sme->ie,
+			sme->ie_len)) != NULL) {
+			WL_DBG((" WPA IE is found\n"));
+		}
+		if (wpa_ie != NULL || wpa2_ie != NULL) {
+			wpaie = (wpa_ie != NULL) ? (u8 *)wpa_ie : (u8 *)wpa2_ie;
+			wpaie_len = (wpa_ie != NULL) ? wpa_ie->length : wpa2_ie->len;
+			wpaie_len += WPA_RSN_IE_TAG_FIXED_LEN;
+			wldev_iovar_setbuf(dev, "wpaie", wpaie, wpaie_len,
+				wl->ioctl_buf, WLC_IOCTL_MAXLEN, &wl->ioctl_buf_sync);
+		} else {
+			wldev_iovar_setbuf(dev, "wpaie", NULL, 0,
+				wl->ioctl_buf, WLC_IOCTL_MAXLEN, &wl->ioctl_buf_sync);
+		}
 
-			/* find the WPSIE */
-			memset(wpsie, 0, sizeof(wpsie));
-			if ((wps_ie = wl_cfgp2p_find_wpsie((u8 *)sme->ie,
-				sme->ie_len)) != NULL) {
-				wpsie_len = wps_ie->length +WPA_RSN_IE_TAG_FIXED_LEN;
-				memcpy(wpsie, wps_ie, wpsie_len);
-			} else {
-				wpsie_len = 0;
-			}
-			err = wl_cfgp2p_set_management_ie(wl, dev, -1,
-				VNDR_IE_ASSOCREQ_FLAG, wpsie, wpsie_len);
-			if (unlikely(err)) {
-				return err;
-			}
-	}
-	if (unlikely(!sme->ssid)) {
-		WL_ERR(("Invalid ssid\n"));
-		return -EOPNOTSUPP;
+		if (wl_cfgp2p_find_idx(wl, dev, &bssidx) != BCME_OK) {
+			WL_ERR(("Find p2p index from dev(%p) failed\n", dev));
+			return BCME_ERROR;
+		}
+		err = wl_cfgp2p_set_management_ie(wl, dev, bssidx,
+			VNDR_IE_ASSOCREQ_FLAG, (u8 *)sme->ie, sme->ie_len);
+		if (unlikely(err)) {
+			return err;
+		}
 	}
 	if (chan) {
 		wl->channel = ieee80211_frequency_to_channel(chan->center_freq);
 		chan_cnt = 1;
-		WL_DBG(("channel (%d), center_req (%d)\n", wl->channel,
-			chan->center_freq));
+		WL_DBG(("channel (%d), center_req (%d), %d channels\n", wl->channel,
+			chan->center_freq, chan_cnt));
 	} else
 		wl->channel = 0;
 #ifdef BCMWAPI_WPI
@@ -2577,15 +3396,27 @@ wl_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 	}
 	ext_join_params->ssid.SSID_len = min(sizeof(ext_join_params->ssid.SSID), sme->ssid_len);
 	memcpy(&ext_join_params->ssid.SSID, sme->ssid, ext_join_params->ssid.SSID_len);
+	wl_update_prof(wl, dev, NULL, &ext_join_params->ssid, WL_PROF_SSID);
 	ext_join_params->ssid.SSID_len = htod32(ext_join_params->ssid.SSID_len);
-	/* Set up join scan parameters */
-	ext_join_params->scan.scan_type = -1;
-	ext_join_params->scan.nprobes = 2;
 	/* increate dwell time to receive probe response or detect Beacon
-	* from target AP at a noisy air only during connect command
+	* from target AP at a noisy air only when channel info is provided in connect command
 	*/
-	ext_join_params->scan.active_time = WL_SCAN_ACTIVE_TIME*3;
-	ext_join_params->scan.passive_time = WL_SCAN_PASSIVE_TIME*3;
+#if 0
+	ext_join_params->scan.active_time = WL_SCAN_JOIN_ACTIVE_DWELL_TIME_MS;
+	ext_join_params->scan.passive_time = WL_SCAN_JOIN_PASSIVE_DWELL_TIME_MS;
+#else
+	ext_join_params->scan.active_time = chan_cnt ? WL_SCAN_JOIN_ACTIVE_DWELL_TIME_MS : -1;
+	ext_join_params->scan.passive_time = chan_cnt ? WL_SCAN_JOIN_PASSIVE_DWELL_TIME_MS : -1;
+#endif
+	/* Set up join scan parameters */
+	ext_join_params->scan.scan_type = -1;
+#if 0
+	ext_join_params->scan.nprobes
+		= (ext_join_params->scan.active_time/WL_SCAN_JOIN_PROBE_INTERVAL_MS);
+#else
+	ext_join_params->scan.nprobes = chan_cnt ?
+		(ext_join_params->scan.active_time/WL_SCAN_JOIN_PROBE_INTERVAL_MS) : -1;
+#endif
 	ext_join_params->scan.home_time = -1;
 
 	if (sme->bssid)
@@ -2613,8 +3444,13 @@ wl_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 			ext_join_params->ssid.SSID_len));
 	}
 	wl_set_drv_status(wl, CONNECTING, dev);
+
+	if (wl_cfgp2p_find_idx(wl, dev, &bssidx) != BCME_OK) {
+		WL_ERR(("Find p2p index from dev(%p) failed\n", dev));
+		return BCME_ERROR;
+	}
 	err = wldev_iovar_setbuf_bsscfg(dev, "join", ext_join_params, join_params_size,
-		wl->ioctl_buf, WLC_IOCTL_MAXLEN, wl_cfgp2p_find_idx(wl, dev), &wl->ioctl_buf_sync);
+		wl->ioctl_buf, WLC_IOCTL_MAXLEN, bssidx, &wl->ioctl_buf_sync);
 	kfree(ext_join_params);
 	if (err) {
 		wl_clr_drv_status(wl, CONNECTING, dev);
@@ -2640,7 +3476,7 @@ set_ssid:
 		memcpy(&join_params.params.bssid, &ether_bcast, ETH_ALEN);
 
 	wl_ch_to_chanspec(wl->channel, &join_params, &join_params_size);
-	WL_DBG(("join_param_size %d\n", join_params_size));
+	WL_DBG(("join_param_size %zu\n", join_params_size));
 
 	if (join_params.ssid.SSID_len < IEEE80211_MAX_SSID_LEN) {
 		WL_INFO(("ssid \"%s\", len (%d)\n", join_params.ssid.SSID,
@@ -2665,17 +3501,28 @@ wl_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
 	bool act = false;
 	s32 err = 0;
 	u8 *curbssid;
+	dhd_pub_t *dhd =  (dhd_pub_t *)(wl->pub);
 	WL_ERR(("Reason %d\n", reason_code));
-	CHECK_SYS_UP(wl);
+	RETURN_EIO_IF_NOT_UP(wl);
 	act = *(bool *) wl_read_prof(wl, dev, WL_PROF_ACT);
 	curbssid = wl_read_prof(wl, dev, WL_PROF_BSSID);
+
+	if (dhd->hang_was_sent && act) {
+		wl_clr_drv_status(wl, CONNECTED, dev);
+		act = 0;
+		wl_update_prof(wl, dev, NULL, &act, WL_PROF_ACT);
+		return 0;
+	}
 	if (act) {
 		/*
 		* Cancel ongoing scan to sync up with sme state machine of cfg80211.
 		*/
+#if !defined(ESCAN_RESULT_PATCH)
+		/* Let scan aborted by F/W */
 		if (wl->scan_request) {
 			wl_notify_escan_complete(wl, dev, true, true);
 		}
+#endif /* ESCAN_RESULT_PATCH */
 		wl_set_drv_status(wl, DISCONNECTING, dev);
 		scbval.val = reason_code;
 		memcpy(&scbval.ea, curbssid, ETHER_ADDR_LEN);
@@ -2703,7 +3550,7 @@ wl_cfg80211_set_tx_power(struct wiphy *wiphy,
 	s32 err = 0;
 	s32 disable = 0;
 
-	CHECK_SYS_UP(wl);
+	RETURN_EIO_IF_NOT_UP(wl);
 	switch (type) {
 	case NL80211_TX_POWER_AUTOMATIC:
 		break;
@@ -2752,7 +3599,7 @@ static s32 wl_cfg80211_get_tx_power(struct wiphy *wiphy, s32 *dbm)
 	u8 result;
 	s32 err = 0;
 
-	CHECK_SYS_UP(wl);
+	RETURN_EIO_IF_NOT_UP(wl);
 	err = wldev_iovar_getint(ndev, "qtxpower", &txpwrdbm);
 	if (unlikely(err)) {
 		WL_ERR(("error (%d)\n", err));
@@ -2772,16 +3619,21 @@ wl_cfg80211_config_default_key(struct wiphy *wiphy, struct net_device *dev,
 	u32 index;
 	s32 wsec;
 	s32 err = 0;
-	s32 bssidx = wl_cfgp2p_find_idx(wl, dev);
+	s32 bssidx;
+	if (wl_cfgp2p_find_idx(wl, dev, &bssidx) != BCME_OK) {
+		WL_ERR(("Find p2p index from dev(%p) failed\n", dev));
+		return BCME_ERROR;
+	}
 
 	WL_DBG(("key index (%d)\n", key_idx));
-	CHECK_SYS_UP(wl);
+	RETURN_EIO_IF_NOT_UP(wl);
 	err = wldev_iovar_getint_bsscfg(dev, "wsec", &wsec, bssidx);
 	if (unlikely(err)) {
 		WL_ERR(("WLC_GET_WSEC error (%d)\n", err));
 		return err;
 	}
-	if (wsec & WEP_ENABLED) {
+	/* fix IOT issue with Apple Airport */
+	if (wsec == WEP_ENABLED) {
 		/* Just select a new current key */
 		index = (u32) key_idx;
 		index = htod32(index);
@@ -2801,8 +3653,12 @@ wl_add_keyext(struct wiphy *wiphy, struct net_device *dev,
 	struct wl_priv *wl = wiphy_priv(wiphy);
 	struct wl_wsec_key key;
 	s32 err = 0;
-	s32 bssidx = wl_cfgp2p_find_idx(wl, dev);
+	s32 bssidx;
 	s32 mode = wl_get_mode_by_netdev(wl, dev);
+	if (wl_cfgp2p_find_idx(wl, dev, &bssidx) != BCME_OK) {
+		WL_ERR(("Find p2p index from dev(%p) failed\n", dev));
+		return BCME_ERROR;
+	}
 	memset(&key, 0, sizeof(key));
 	key.index = (u32) key_idx;
 
@@ -2814,7 +3670,7 @@ wl_add_keyext(struct wiphy *wiphy, struct net_device *dev,
 	if (key.len == 0) {
 		/* key delete */
 		swap_key_from_BE(&key);
-		wldev_iovar_setbuf_bsscfg(dev, "wsec_key", &key, sizeof(key),
+		err = wldev_iovar_setbuf_bsscfg(dev, "wsec_key", &key, sizeof(key),
 			wl->ioctl_buf, WLC_IOCTL_MAXLEN, bssidx, &wl->ioctl_buf_sync);
 		if (unlikely(err)) {
 			WL_ERR(("key delete error (%d)\n", err));
@@ -2879,10 +3735,9 @@ wl_add_keyext(struct wiphy *wiphy, struct net_device *dev,
 			return -EINVAL;
 		}
 		swap_key_from_BE(&key);
-#if defined(CONFIG_WIRELESS_EXT)
+		/* need to guarantee EAPOL 4/4 send out before set key */
 		dhd_wait_pend8021x(dev);
-#endif
-		wldev_iovar_setbuf_bsscfg(dev, "wsec_key", &key, sizeof(key),
+		err = wldev_iovar_setbuf_bsscfg(dev, "wsec_key", &key, sizeof(key),
 			wl->ioctl_buf, WLC_IOCTL_MAXLEN, bssidx, &wl->ioctl_buf_sync);
 		if (unlikely(err)) {
 			WL_ERR(("WLC_SET_KEY error (%d)\n", err));
@@ -2906,13 +3761,18 @@ wl_cfg80211_add_key(struct wiphy *wiphy, struct net_device *dev,
 	struct wl_priv *wl = wiphy_priv(wiphy);
 	s32 mode = wl_get_mode_by_netdev(wl, dev);
 	WL_DBG(("key index (%d)\n", key_idx));
-	CHECK_SYS_UP(wl);
+	RETURN_EIO_IF_NOT_UP(wl);
 
-	bssidx = wl_cfgp2p_find_idx(wl, dev);
+	if (wl_cfgp2p_find_idx(wl, dev, &bssidx) != BCME_OK) {
+		WL_ERR(("Find p2p index from dev(%p) failed\n", dev));
+		return BCME_ERROR;
+	}
 
-	if (mac_addr) {
-		wl_add_keyext(wiphy, dev, key_idx, mac_addr, params);
-		goto exit;
+	if (mac_addr &&
+		((params->cipher != WLAN_CIPHER_SUITE_WEP40) &&
+		(params->cipher != WLAN_CIPHER_SUITE_WEP104))) {
+			wl_add_keyext(wiphy, dev, key_idx, mac_addr, params);
+			goto exit;
 	}
 	memset(&key, 0, sizeof(key));
 
@@ -2965,6 +3825,29 @@ wl_cfg80211_add_key(struct wiphy *wiphy, struct net_device *dev,
 		val = SMS4_ENABLED;
 		break;
 #endif /* BCMWAPI_WPI */
+#if defined(WLFBT) && defined(WLAN_CIPHER_SUITE_PMK)
+	case WLAN_CIPHER_SUITE_PMK: {
+		int j;
+		wsec_pmk_t pmk;
+		char keystring[WSEC_MAX_PSK_LEN + 1];
+		char* charptr = keystring;
+		uint len;
+
+		/* copy the raw hex key to the appropriate format */
+		for (j = 0; j < (WSEC_MAX_PSK_LEN / 2); j++) {
+			sprintf(charptr, "%02x", params->key[j]);
+			charptr += 2;
+		}
+		len = strlen(keystring);
+		pmk.key_len = htod16(len);
+		bcopy(keystring, pmk.key, len);
+		pmk.flags = htod16(WSEC_PASSPHRASE);
+
+		err = wldev_ioctl(dev, WLC_SET_WSEC_PMK, &pmk, sizeof(pmk), true);
+		if (err)
+			return err;
+	} break;
+#endif /* WLFBT && WLAN_CIPHER_SUITE_PMK */
 	default:
 		WL_ERR(("Invalid cipher (0x%x)\n", params->cipher));
 		return -EINVAL;
@@ -3003,10 +3886,19 @@ wl_cfg80211_del_key(struct wiphy *wiphy, struct net_device *dev,
 	struct wl_wsec_key key;
 	struct wl_priv *wl = wiphy_priv(wiphy);
 	s32 err = 0;
-	s32 bssidx = wl_cfgp2p_find_idx(wl, dev);
-
+	s32 bssidx;
+	if (wl_cfgp2p_find_idx(wl, dev, &bssidx) != BCME_OK) {
+		WL_ERR(("Find p2p index from dev(%p) failed\n", dev));
+		return BCME_ERROR;
+	}
 	WL_DBG(("Enter\n"));
-	CHECK_SYS_UP(wl);
+
+#ifndef IEEE80211W
+	if ((key_idx >= DOT11_MAX_DEFAULT_KEYS) && (key_idx < DOT11_MAX_DEFAULT_KEYS+2))
+		return -EINVAL;
+#endif
+
+	RETURN_EIO_IF_NOT_UP(wl);
 	memset(&key, 0, sizeof(key));
 
 	key.flags = WL_PRIMARY_KEY;
@@ -3016,7 +3908,7 @@ wl_cfg80211_del_key(struct wiphy *wiphy, struct net_device *dev,
 	WL_DBG(("key index (%d)\n", key_idx));
 	/* Set the new key/index */
 	swap_key_from_BE(&key);
-	wldev_iovar_setbuf_bsscfg(dev, "wsec_key", &key, sizeof(key), wl->ioctl_buf,
+	err = wldev_iovar_setbuf_bsscfg(dev, "wsec_key", &key, sizeof(key), wl->ioctl_buf,
 		WLC_IOCTL_MAXLEN, bssidx, &wl->ioctl_buf_sync);
 	if (unlikely(err)) {
 		if (err == -EINVAL) {
@@ -3043,10 +3935,13 @@ wl_cfg80211_get_key(struct wiphy *wiphy, struct net_device *dev,
 	struct wl_security *sec;
 	s32 wsec;
 	s32 err = 0;
-	s32 bssidx = wl_cfgp2p_find_idx(wl, dev);
-
+	s32 bssidx;
+	if (wl_cfgp2p_find_idx(wl, dev, &bssidx) != BCME_OK) {
+		WL_ERR(("Find p2p index from dev(%p) failed\n", dev));
+		return BCME_ERROR;
+	}
 	WL_DBG(("key index (%d)\n", key_idx));
-	CHECK_SYS_UP(wl);
+	RETURN_EIO_IF_NOT_UP(wl);
 	memset(&key, 0, sizeof(key));
 	key.index = key_idx;
 	swap_key_to_BE(&key);
@@ -3054,7 +3949,7 @@ wl_cfg80211_get_key(struct wiphy *wiphy, struct net_device *dev,
 	params.key_len = (u8) min_t(u8, DOT11_MAX_KEY_SIZE, key.len);
 	memcpy(params.key, key.data, params.key_len);
 
-	wldev_iovar_getint_bsscfg(dev, "wsec", &wsec, bssidx);
+	err = wldev_iovar_getint_bsscfg(dev, "wsec", &wsec, bssidx);
 	if (unlikely(err)) {
 		WL_ERR(("WLC_GET_WSEC error (%d)\n", err));
 		return err;
@@ -3115,10 +4010,10 @@ wl_cfg80211_get_station(struct wiphy *wiphy, struct net_device *dev,
 	s8 eabuf[ETHER_ADDR_STR_LEN];
 #endif
 	dhd_pub_t *dhd =  (dhd_pub_t *)(wl->pub);
-	CHECK_SYS_UP(wl);
+	RETURN_EIO_IF_NOT_UP(wl);
 	if (wl_get_mode_by_netdev(wl, dev) == WL_MODE_AP) {
 		err = wldev_iovar_getbuf(dev, "sta_info", (struct ether_addr *)mac,
-			ETHER_ADDR_LEN, wl->ioctl_buf, WLC_IOCTL_MAXLEN, &wl->ioctl_buf_sync);
+			ETHER_ADDR_LEN, wl->ioctl_buf, WLC_IOCTL_SMLEN, &wl->ioctl_buf_sync);
 		if (err < 0) {
 			WL_ERR(("GET STA INFO failed, %d\n", err));
 			return err;
@@ -3141,16 +4036,19 @@ wl_cfg80211_get_station(struct wiphy *wiphy, struct net_device *dev,
 			sta->idle * 1000));
 #endif
 	} else if (wl_get_mode_by_netdev(wl, dev) == WL_MODE_BSS) {
+		get_pktcnt_t pktcnt;
 		u8 *curmacp = wl_read_prof(wl, dev, WL_PROF_BSSID);
 		if (!wl_get_drv_status(wl, CONNECTED, dev) ||
-			(dhd_is_associated(dhd, NULL) == FALSE)) {
+			(dhd_is_associated(dhd, NULL, &err) == FALSE)) {
 			WL_ERR(("NOT assoc\n"));
+			if (err == -ERESTARTSYS)
+				return err;
 			err = -ENODEV;
-			goto get_station_err;
+			return err;
 		}
 		if (memcmp(mac, curmacp, ETHER_ADDR_LEN)) {
-			WL_ERR(("Wrong Mac address: "MACSTR" != "MACSTR"\n",
-				MAC2STR(mac), MAC2STR(curmacp)));
+			WL_ERR(("Wrong Mac address: "MACDBG" != "MACDBG"\n",
+				MAC2STRDBG(mac), MAC2STRDBG(curmacp)));
 		}
 
 		/* Report the current tx rate */
@@ -3172,15 +4070,26 @@ wl_cfg80211_get_station(struct wiphy *wiphy, struct net_device *dev,
 			WL_ERR(("Could not get rssi (%d)\n", err));
 			goto get_station_err;
 		}
-		rssi = dtoh32(scb_val.val);
+		rssi = dtoh32(scb_val.val) + RSSI_OFFSET;
 		sinfo->filled |= STATION_INFO_SIGNAL;
 		sinfo->signal = rssi;
 		WL_DBG(("RSSI %d dBm\n", rssi));
-
+		err = wldev_ioctl(dev, WLC_GET_PKTCNTS, &pktcnt,
+			sizeof(pktcnt), false);
+		if (!err) {
+			sinfo->filled |= (STATION_INFO_RX_PACKETS |
+				STATION_INFO_RX_DROP_MISC |
+				STATION_INFO_TX_PACKETS |
+				STATION_INFO_TX_FAILED);
+			sinfo->rx_packets = pktcnt.rx_good_pkt;
+			sinfo->rx_dropped_misc = pktcnt.rx_bad_pkt;
+			sinfo->tx_packets = pktcnt.tx_good_pkt;
+			sinfo->tx_failed  = pktcnt.tx_bad_pkt;
+		}
 get_station_err:
-		if (err) {
+		if (err && (err != -ERESTARTSYS)) {
 			/* Disconnect due to zero BSSID or error to get RSSI */
-			WL_ERR(("force cfg80211_disconnected\n"));
+			WL_ERR(("force cfg80211_disconnected: %d\n", err));
 			wl_clr_drv_status(wl, CONNECTED, dev);
 			cfg80211_disconnected(dev, 0, NULL, 0, GFP_KERNEL);
 			wl_link_down(wl);
@@ -3190,6 +4099,24 @@ get_station_err:
 	return err;
 }
 
+/* Function to update sta power save mode for Kernel wifi stack */
+int wl_cfg80211_update_power_mode(struct net_device *dev)
+{
+	int pm = -1;
+	int err;
+
+	err = wldev_ioctl(dev, WLC_GET_PM, &pm, sizeof(pm), false);
+	if (err || (pm == -1)) {
+		WL_ERR(("error (%d)\n", err));
+	} else {
+		pm = (pm == PM_OFF) ? false : true;
+		WL_DBG(("%s: %d\n", __func__, pm));
+		if (dev->ieee80211_ptr)
+			dev->ieee80211_ptr->ps = pm;
+	}
+	return err;
+}
+
 static s32
 wl_cfg80211_set_power_mgmt(struct wiphy *wiphy, struct net_device *dev,
 	bool enabled, s32 timeout)
@@ -3197,21 +4124,31 @@ wl_cfg80211_set_power_mgmt(struct wiphy *wiphy, struct net_device *dev,
 	s32 pm;
 	s32 err = 0;
 	struct wl_priv *wl = wiphy_priv(wiphy);
+	struct net_info *_net_info = wl_get_netinfo_by_netdev(wl, dev);
+#if !defined(SUPPORT_PM2_ONLY)
+	dhd_pub_t *dhd = (dhd_pub_t *)(wl->pub);
+#endif /* (OEM_ANDROID) */
+	RETURN_EIO_IF_NOT_UP(wl);
 
-	CHECK_SYS_UP(wl);
-
-	if (wl->p2p_net == dev) {
+	if (wl->p2p_net == dev || _net_info == NULL || wl->vsdb_mode) {
 		return err;
 	}
+	WL_DBG(("%s: Enter power save enabled %d\n", dev->name, enabled));
 
-	pm = PM_OFF; /* enabled ? PM_FAST : PM_OFF; */
-	/* Do not enable the power save after assoc if it is p2p interface */
-	if (wl->p2p && wl->p2p->vif_created) {
-		WL_DBG(("Do not enable the power save for p2p interfaces even after assoc\n"));
+#if !defined(SUPPORT_PM2_ONLY)
+	/* android has special hooks to change pm when kernel suspended */
+	pm = enabled ? ((dhd->in_suspend) ? PM_MAX : PM_FAST) : PM_OFF;
+#else
+	pm = enabled ? PM_FAST : PM_OFF;
+#endif /* SUPPORT_PM2_ONLY */
+	if (_net_info->pm_block) {
+		/* Do not enable the power save if it is p2p interface or vsdb mode is set */
+		WL_DBG(("%s:Do not enable the power save for pm_block %d or vsdb_mode %d\n",
+			dev->name, _net_info->pm_block, wl->vsdb_mode));
 		pm = PM_OFF;
 	}
 	pm = htod32(pm);
-	WL_DBG(("power save %s\n", (pm ? "enabled" : "disabled")));
+	WL_DBG(("%s:power save %s\n", dev->name, (pm ? "enabled" : "disabled")));
 	err = wldev_ioctl(dev, WLC_SET_PM, &pm, sizeof(pm), true);
 	if (unlikely(err)) {
 		if (err == -ENODEV)
@@ -3349,7 +4286,7 @@ wl_cfg80211_set_pmksa(struct wiphy *wiphy, struct net_device *dev,
 	s32 err = 0;
 	int i;
 
-	CHECK_SYS_UP(wl);
+	RETURN_EIO_IF_NOT_UP(wl);
 	for (i = 0; i < wl->pmk_list->pmkids.npmkid; i++)
 		if (!memcmp(pmksa->bssid, &wl->pmk_list->pmkids.pmkid[i].BSSID,
 			ETHER_ADDR_LEN))
@@ -3382,13 +4319,13 @@ wl_cfg80211_del_pmksa(struct wiphy *wiphy, struct net_device *dev,
 	struct cfg80211_pmksa *pmksa)
 {
 	struct wl_priv *wl = wiphy_priv(wiphy);
-	struct _pmkid_list pmkid;
+	struct _pmkid_list pmkid = {0};
 	s32 err = 0;
 	int i;
 
-	CHECK_SYS_UP(wl);
+	RETURN_EIO_IF_NOT_UP(wl);
 	memcpy(&pmkid.pmkid[0].BSSID, pmksa->bssid, ETHER_ADDR_LEN);
-	memcpy(&pmkid.pmkid[0].PMKID, pmksa->pmkid, WPA2_PMKID_LEN);
+	memcpy(pmkid.pmkid[0].PMKID, pmksa->pmkid, WPA2_PMKID_LEN);
 
 	WL_DBG(("del_pmksa,IW_PMKSA_REMOVE - PMKID: %pM =\n",
 		&pmkid.pmkid[0].BSSID));
@@ -3429,7 +4366,7 @@ wl_cfg80211_flush_pmksa(struct wiphy *wiphy, struct net_device *dev)
 {
 	struct wl_priv *wl = wiphy_priv(wiphy);
 	s32 err = 0;
-	CHECK_SYS_UP(wl);
+	RETURN_EIO_IF_NOT_UP(wl);
 	memset(wl->pmk_list, 0, sizeof(*wl->pmk_list));
 	err = wl_update_pmklist(dev, wl->pmk_list, err);
 	return err;
@@ -3449,7 +4386,7 @@ wl_cfg80211_scan_alloc_params(int channel, int nprobes, int *out_params_size)
 	params_size = WL_SCAN_PARAMS_FIXED_SIZE + 1 * sizeof(uint16);
 	params = (wl_scan_params_t*) kzalloc(params_size, GFP_KERNEL);
 	if (params == NULL) {
-		WL_ERR(("%s: mem alloc failed (%d bytes)\n", __func__, params_size));
+		WL_ERR(("mem alloc failed (%d bytes)\n", params_size));
 		return params;
 	}
 	memset(params, 0, params_size);
@@ -3490,7 +4427,10 @@ wl_cfg80211_remain_on_channel(struct wiphy *wiphy, struct net_device *dev,
 
 	s32 err = BCME_OK;
 	struct wl_priv *wl = wiphy_priv(wiphy);
-	WL_DBG(("Enter, netdev_ifidx: %d \n", dev->ifindex));
+
+	WL_DBG(("Enter, ifindex: %d, channel: %d, duration ms (%d) SCANNING ?? %s \n",
+		dev->ifindex, ieee80211_frequency_to_channel(channel->center_freq),
+		duration, (wl_get_drv_status(wl, SCANNING, ndev)) ? "YES":"NO"));
 
 	if (wl->p2p_net == dev) {
 		ndev = wl_to_prmry_ndev(wl);
@@ -3498,9 +4438,23 @@ wl_cfg80211_remain_on_channel(struct wiphy *wiphy, struct net_device *dev,
 		ndev = dev;
 	}
 
+	if (!wl->p2p) {
+		WL_ERR(("wl->p2p is not initialized\n"));
+		err = BCME_ERROR;
+		goto exit;
+	}
+
+#ifndef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
+#if 0
 	if (wl_get_drv_status(wl, SCANNING, ndev)) {
 		wl_notify_escan_complete(wl, ndev, true, true);
 	}
+#else
+	if (wl_get_drv_status_all(wl, SCANNING)) {
+		wl_notify_escan_complete(wl, wl->escan_info.ndev, true, true);
+	}
+#endif
+#endif /* not WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
 
 	target_channel = ieee80211_frequency_to_channel(channel->center_freq);
 	memcpy(&wl->remain_on_chan, channel, sizeof(struct ieee80211_channel));
@@ -3509,28 +4463,85 @@ wl_cfg80211_remain_on_channel(struct wiphy *wiphy, struct net_device *dev,
 	if (id == 0)
 		id = ++wl->last_roc_id;
 	*cookie = id;
-	cfg80211_ready_on_channel(dev, *cookie, channel,
-		channel_type, duration, GFP_KERNEL);
-	if (wl->p2p && !wl->p2p->on) {
-		get_primary_mac(wl, &primary_mac);
-		wl_cfgp2p_generate_bss_mac(&primary_mac, &wl->p2p->dev_addr, &wl->p2p->int_addr);
 
-		/* In case of p2p_listen command, supplicant send remain_on_channel
-		 * without turning on P2P
-		 */
+#ifdef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
+	if (wl_get_drv_status(wl, SCANNING, ndev)) {
+		struct timer_list *_timer;
+		WL_DBG(("scan is running. go to fake listen state\n"));
 
-		p2p_on(wl) = true;
-		err = wl_cfgp2p_enable_discovery(wl, ndev, NULL, 0);
+		wl_set_drv_status(wl, FAKE_REMAINING_ON_CHANNEL, ndev);
 
-		if (unlikely(err)) {
-			goto exit;
+		if (timer_pending(&wl->p2p->listen_timer)) {
+			WL_DBG(("cancel current listen timer \n"));
+			del_timer_sync(&wl->p2p->listen_timer);
 		}
-	}
-	if (p2p_is_on(wl))
-		wl_cfgp2p_discover_listen(wl, target_channel, duration);
 
+		_timer = &wl->p2p->listen_timer;
+		wl_clr_p2p_status(wl, LISTEN_EXPIRED);
 
-exit:
+		INIT_TIMER(_timer, wl_cfgp2p_listen_expired, duration, 0);
+
+		err = BCME_OK;
+		goto exit;
+	}
+#endif /* WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
+
+#ifdef WL_CFG80211_SYNC_GON
+	if (wl_get_drv_status_all(wl, WAITING_NEXT_ACT_FRM_LISTEN)) {
+		/* do not enter listen mode again if we are in listen mode already for next af.
+		 * remain on channel completion will be returned by waiting next af completion.
+		 */
+#ifdef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
+		wl_set_drv_status(wl, FAKE_REMAINING_ON_CHANNEL, ndev);
+#else
+		wl_set_drv_status(wl, REMAINING_ON_CHANNEL, ndev);
+#endif /* WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
+		goto exit;
+	}
+#endif /* WL_CFG80211_SYNC_GON */
+	if (wl->p2p && !wl->p2p->on) {
+		/* In case of p2p_listen command, supplicant send remain_on_channel
+		 * without turning on P2P
+		 */
+		get_primary_mac(wl, &primary_mac);
+		wl_cfgp2p_generate_bss_mac(&primary_mac, &wl->p2p->dev_addr, &wl->p2p->int_addr);
+		p2p_on(wl) = true;
+	}
+
+	if (p2p_is_on(wl)) {
+		err = wl_cfgp2p_enable_discovery(wl, ndev, NULL, 0);
+		if (unlikely(err)) {
+			goto exit;
+		}
+#ifndef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
+		wl_set_drv_status(wl, REMAINING_ON_CHANNEL, ndev);
+#endif /* not WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
+		err = wl_cfgp2p_discover_listen(wl, target_channel, duration);
+
+#ifdef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
+		if (err == BCME_OK) {
+			wl_set_drv_status(wl, REMAINING_ON_CHANNEL, ndev);
+		} else {
+			/* if failed, firmware may be internal scanning state.
+			 * so other scan request shall not abort it
+			 */
+			wl_set_drv_status(wl, FAKE_REMAINING_ON_CHANNEL, ndev);
+		}
+#endif /* WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
+		/* WAR: set err = ok to prevent cookie mismatch in wpa_supplicant
+		 * and expire timer will send a completion to the upper layer
+		 */
+		err = BCME_OK;
+	}
+
+exit:
+	if (err == BCME_OK) {
+		WL_INFO(("Success\n"));
+		cfg80211_ready_on_channel(dev, *cookie, channel,
+			channel_type, duration, GFP_KERNEL);
+	} else {
+		WL_ERR(("Fail to Set (err=%d cookie:%llu)\n", err, *cookie));
+	}
 	return err;
 }
 
@@ -3542,92 +4553,453 @@ wl_cfg80211_cancel_remain_on_channel(struct wiphy *wiphy, struct net_device *dev
 	WL_DBG((" enter ) netdev_ifidx: %d \n", dev->ifindex));
 	return err;
 }
-static s32
-wl_cfg80211_send_pending_tx_act_frm(struct wl_priv *wl)
-{
-	wl_af_params_t *tx_act_frm;
-	struct net_device *dev = wl->afx_hdl->dev;
-	if (!p2p_is_on(wl))
-		return -1;
-
-	if (dev == wl->p2p_net) {
-		dev = wl_to_prmry_ndev(wl);
-	}
 
-	tx_act_frm = wl->afx_hdl->pending_tx_act_frm;
-	WL_DBG(("Sending the action frame\n"));
-	wl->afx_hdl->pending_tx_act_frm = NULL;
-	if (tx_act_frm != NULL) {
-		/* Suspend P2P discovery's search-listen to prevent it from
-		 * starting a scan or changing the channel.
-		 */
-		wl_clr_drv_status(wl, SENDING_ACT_FRM, wl->afx_hdl->dev);
-		wl_clr_drv_status(wl, SCANNING, wl->afx_hdl->dev);
-		wl_notify_escan_complete(wl, dev, true, true);
-		wl_cfgp2p_discover_enable_search(wl, false);
-		tx_act_frm->channel = wl->afx_hdl->peer_chan;
-		wl->afx_hdl->ack_recv = (wl_cfgp2p_tx_action_frame(wl, dev,
-			tx_act_frm, wl->afx_hdl->bssidx)) ? false : true;
-	}
-	return 0;
-}
 static void
 wl_cfg80211_afx_handler(struct work_struct *work)
 {
 	struct afx_hdl *afx_instance;
 	struct wl_priv *wl = wlcfg_drv_priv;
+	s32 ret = BCME_OK;
+
 	afx_instance = container_of(work, struct afx_hdl, work);
-	if (afx_instance != NULL) {
-		wl_cfgp2p_act_frm_search(wl, wl->afx_hdl->dev,
-			wl->afx_hdl->bssidx, 0);
+	if (afx_instance != NULL && wl->afx_hdl->is_active) {
+		if (wl->afx_hdl->is_listen && wl->afx_hdl->my_listen_chan) {
+			ret = wl_cfgp2p_discover_listen(wl, wl->afx_hdl->my_listen_chan,
+				(100 * (1 + (random32() % 3)))); /* 100ms ~ 300ms */
+		} else {
+			ret = wl_cfgp2p_act_frm_search(wl, wl->afx_hdl->dev,
+				wl->afx_hdl->bssidx, wl->afx_hdl->peer_listen_chan,
+				NULL);
+		}
+		if (unlikely(ret != BCME_OK)) {
+			WL_ERR(("ERROR occurred! returned value is (%d)\n", ret));
+			if (wl_get_drv_status_all(wl, FINDING_COMMON_CHANNEL))
+				complete(&wl->act_frm_scan);
+		}
 	}
 }
 
-static bool
-wl_cfg80211_send_at_common_channel(struct wl_priv *wl,
-	struct net_device *dev,
-	wl_af_params_t *af_params)
+static s32
+wl_cfg80211_af_searching_channel(struct wl_priv *wl, struct net_device *dev)
 {
+	u32 max_retry = WL_CHANNEL_SYNC_RETRY;
+
+	if (dev == NULL)
+		return -1;
+
 	WL_DBG((" enter ) \n"));
-	/* initialize afx_hdl */
-	wl->afx_hdl->pending_tx_act_frm = af_params;
-	wl->afx_hdl->bssidx = wl_cfgp2p_find_idx(wl, dev);
-	wl->afx_hdl->dev = dev;
-	wl->afx_hdl->retry = 0;
-	wl->afx_hdl->peer_chan = WL_INVALID;
-	wl->afx_hdl->ack_recv = false;
-	memcpy(wl->afx_hdl->pending_tx_dst_addr.octet,
-		af_params->action_frame.da.octet,
-		sizeof(wl->afx_hdl->pending_tx_dst_addr.octet));
-	/* Loop to wait until we have sent the pending tx action frame or the
+
+	wl_set_drv_status(wl, FINDING_COMMON_CHANNEL, dev);
+	wl->afx_hdl->is_active = TRUE;
+
+	/* Loop to wait until we find a peer's channel or the
 	 * pending action frame tx is cancelled.
 	 */
-	while ((wl->afx_hdl->retry < WL_CHANNEL_SYNC_RETRY) &&
+	while ((wl->afx_hdl->retry < max_retry) &&
 		(wl->afx_hdl->peer_chan == WL_INVALID)) {
-		wl_set_drv_status(wl, SENDING_ACT_FRM, dev);
+		wl->afx_hdl->is_listen = FALSE;
 		wl_set_drv_status(wl, SCANNING, dev);
 		WL_DBG(("Scheduling the action frame for sending.. retry %d\n",
 			wl->afx_hdl->retry));
-		/* Do find_peer_for_action */
+		/* search peer on peer's listen channel */
 		schedule_work(&wl->afx_hdl->work);
-		wait_for_completion(&wl->act_frm_scan);
+		wait_for_completion_timeout(&wl->act_frm_scan,
+			msecs_to_jiffies(WL_AF_SEARCH_TIME_MAX));
+
+		if ((wl->afx_hdl->peer_chan != WL_INVALID) ||
+			!(wl_get_drv_status(wl, FINDING_COMMON_CHANNEL, dev)))
+			break;
+
+		if (wl->afx_hdl->my_listen_chan) {
+			WL_DBG(("Scheduling Listen peer in my listen channel = %d\n",
+				wl->afx_hdl->my_listen_chan));
+			/* listen on my listen channel */
+			wl->afx_hdl->is_listen = TRUE;
+			schedule_work(&wl->afx_hdl->work);
+			wait_for_completion_timeout(&wl->act_frm_scan,
+				msecs_to_jiffies(WL_AF_SEARCH_TIME_MAX));
+		}
+		if ((wl->afx_hdl->peer_chan != WL_INVALID) ||
+			!(wl_get_drv_status(wl, FINDING_COMMON_CHANNEL, dev)))
+			break;
+
 		wl->afx_hdl->retry++;
+
+		WL_AF_TX_KEEP_PRI_CONNECTION_VSDB(wl);
 	}
-	if (wl->afx_hdl->peer_chan != WL_INVALID)
-		wl_cfg80211_send_pending_tx_act_frm(wl);
-	else {
-		WL_ERR(("Couldn't find the peer after %d retries\n",
-			wl->afx_hdl->retry));
+
+	wl->afx_hdl->is_active = FALSE;
+
+	wl_clr_drv_status(wl, SCANNING, dev);
+	wl_clr_drv_status(wl, FINDING_COMMON_CHANNEL, dev);
+
+	return (wl->afx_hdl->peer_chan);
+}
+
+struct p2p_config_af_params {
+	s32 max_tx_retry;	/* max tx retry count if tx no ack */
+	/* To make sure to send successfully action frame, we have to turn off mpc
+	 * 0: off, 1: on,  (-1): do nothing
+	 */
+	s32 mpc_onoff;
+#ifdef WL_CFG80211_SYNC_GON
+	bool extra_listen;
+#endif
+	bool search_channel;	/* 1: search peer's channel to send af */
+};
+
+static s32
+wl_cfg80211_config_p2p_pub_af_tx(struct wiphy *wiphy,
+	wl_action_frame_t *action_frame, wl_af_params_t *af_params,
+	struct p2p_config_af_params *config_af_params)
+{
+	s32 err = BCME_OK;
+	struct wl_priv *wl = wiphy_priv(wiphy);
+	wifi_p2p_pub_act_frame_t *act_frm =
+		(wifi_p2p_pub_act_frame_t *) (action_frame->data);
+
+	/* initialize default value */
+#ifdef WL_CFG80211_SYNC_GON
+	config_af_params->extra_listen = true;
+#endif
+	config_af_params->search_channel = false;
+	config_af_params->max_tx_retry = WL_AF_TX_MAX_RETRY;
+	config_af_params->mpc_onoff = -1;
+	wl->next_af_subtype = P2P_PAF_SUBTYPE_INVALID;
+
+	switch (act_frm->subtype) {
+	case P2P_PAF_GON_REQ: {
+		WL_DBG(("P2P: GO_NEG_PHASE status set \n"));
+		wl_set_p2p_status(wl, GO_NEG_PHASE);
+
+		config_af_params->mpc_onoff = 0;
+		config_af_params->search_channel = true;
+		wl->next_af_subtype = act_frm->subtype + 1;
+
+		/* increase dwell time to wait for RESP frame */
+		af_params->dwell_time = WL_MED_DWELL_TIME;
+
+		break;
+	}
+	case P2P_PAF_GON_RSP: {
+		wl->next_af_subtype = act_frm->subtype + 1;
+		/* increase dwell time to wait for CONF frame */
+		af_params->dwell_time = WL_MED_DWELL_TIME + 100;
+		break;
+	}
+	case P2P_PAF_GON_CONF: {
+		/* If we reached till GO Neg confirmation reset the filter */
+		WL_DBG(("P2P: GO_NEG_PHASE status cleared \n"));
+		wl_clr_p2p_status(wl, GO_NEG_PHASE);
+
+		/* turn on mpc again if go nego is done */
+		config_af_params->mpc_onoff = 1;
+
+		/* minimize dwell time */
+		af_params->dwell_time = WL_MIN_DWELL_TIME;
+
+#ifdef WL_CFG80211_SYNC_GON
+		config_af_params->extra_listen = false;
+#endif /* WL_CFG80211_SYNC_GON */
+		break;
+	}
+	case P2P_PAF_INVITE_REQ: {
+		config_af_params->search_channel = true;
+		wl->next_af_subtype = act_frm->subtype + 1;
+
+		/* increase dwell time */
+		af_params->dwell_time = WL_MED_DWELL_TIME;
+		break;
+	}
+	case P2P_PAF_INVITE_RSP:
+		/* minimize dwell time */
+		af_params->dwell_time = WL_MIN_DWELL_TIME;
+#ifdef WL_CFG80211_SYNC_GON
+		config_af_params->extra_listen = false;
+#endif /* WL_CFG80211_SYNC_GON */
+		break;
+	case P2P_PAF_DEVDIS_REQ: {
+		if (IS_ACTPUB_WITHOUT_GROUP_ID(&act_frm->elts[0],
+			action_frame->len)) {
+			config_af_params->search_channel = true;
+		}
+
+		wl->next_af_subtype = act_frm->subtype + 1;
+		/* maximize dwell time to wait for RESP frame */
+		af_params->dwell_time = WL_LONG_DWELL_TIME;
+		break;
+	}
+	case P2P_PAF_DEVDIS_RSP:
+		/* minimize dwell time */
+		af_params->dwell_time = WL_MIN_DWELL_TIME;
+#ifdef WL_CFG80211_SYNC_GON
+		config_af_params->extra_listen = false;
+#endif /* WL_CFG80211_SYNC_GON */
+		break;
+	case P2P_PAF_PROVDIS_REQ: {
+		if (IS_ACTPUB_WITHOUT_GROUP_ID(&act_frm->elts[0],
+			action_frame->len)) {
+			config_af_params->search_channel = true;
+		}
+
+		config_af_params->mpc_onoff = 0;
+		wl->next_af_subtype = act_frm->subtype + 1;
+		/* increase dwell time to wait for RESP frame */
+		af_params->dwell_time = WL_MED_DWELL_TIME;
+		break;
+	}
+	case P2P_PAF_PROVDIS_RSP: {
+		wl->next_af_subtype = P2P_PAF_GON_REQ;
+#if 0
+		/* increase dwell time to MED level */
+		af_params->dwell_time = WL_MED_DWELL_TIME;
+#else
+		af_params->dwell_time = WL_MIN_DWELL_TIME;
+#endif
+#ifdef WL_CFG80211_SYNC_GON
+		config_af_params->extra_listen = false;
+#endif /* WL_CFG80211_SYNC_GON */
+		break;
+	}
+	default:
+		WL_DBG(("Unknown p2p pub act frame subtype: %d\n",
+			act_frm->subtype));
+		err = BCME_BADARG;
+	}
+	return err;
+}
+
+
+static bool
+wl_cfg80211_send_action_frame(struct wiphy *wiphy, struct net_device *dev,
+	struct net_device *ndev, wl_af_params_t *af_params,
+	wl_action_frame_t *action_frame, u16 action_frame_len, s32 bssidx)
+{
+	struct wl_priv *wl = wiphy_priv(wiphy);
+	bool ack = false;
+	u8 category, action;
+	s32 tx_retry;
+	struct p2p_config_af_params config_af_params;
+#ifdef VSDB
+	ulong off_chan_started_jiffies = 0;
+#endif
+	dhd_pub_t *dhd = (dhd_pub_t *)(wl->pub);
+
+
+	category = action_frame->data[DOT11_ACTION_CAT_OFF];
+	action = action_frame->data[DOT11_ACTION_ACT_OFF];
+
+	/* initialize variables */
+	tx_retry = 0;
+	wl->next_af_subtype = P2P_PAF_SUBTYPE_INVALID;
+	config_af_params.max_tx_retry = WL_AF_TX_MAX_RETRY;
+	config_af_params.mpc_onoff = -1;
+	config_af_params.search_channel = false;
+#ifdef WL_CFG80211_SYNC_GON
+	config_af_params.extra_listen = false;
+#endif
+
+	/* config parameters */
+	/* Public Action Frame Process - DOT11_ACTION_CAT_PUBLIC */
+	if (category == DOT11_ACTION_CAT_PUBLIC) {
+		if ((action == P2P_PUB_AF_ACTION) &&
+			(action_frame_len >= sizeof(wifi_p2p_pub_act_frame_t))) {
+			/* p2p public action frame process */
+			if (BCME_OK != wl_cfg80211_config_p2p_pub_af_tx(wiphy,
+				action_frame, af_params, &config_af_params)) {
+				WL_DBG(("Unknown subtype.\n"));
+			}
+
+		} else if (action_frame_len >= sizeof(wifi_p2psd_gas_pub_act_frame_t)) {
+			/* service discovery process */
+			if (action == P2PSD_ACTION_ID_GAS_IREQ ||
+				action == P2PSD_ACTION_ID_GAS_CREQ) {
+				/* configure service discovery query frame */
+
+				config_af_params.search_channel = true;
+
+				/* save next af suptype to cancel remained dwell time */
+				wl->next_af_subtype = action + 1;
+
+				af_params->dwell_time = WL_MED_DWELL_TIME;
+			} else if (action == P2PSD_ACTION_ID_GAS_IRESP ||
+				action == P2PSD_ACTION_ID_GAS_CRESP) {
+				/* configure service discovery response frame */
+				af_params->dwell_time = WL_MIN_DWELL_TIME;
+			} else {
+				WL_DBG(("Unknown action type: %d\n", action));
+			}
+		} else {
+			WL_DBG(("Unknown Frame: category 0x%x, action 0x%x, length %d\n",
+				category, action, action_frame_len));
+	}
+	} else if (category == P2P_AF_CATEGORY) {
+		/* do not configure anything. it will be sent with a default configuration */
+	} else {
+		WL_DBG(("Unknown Frame: category 0x%x, action 0x%x\n",
+			category, action));
+		if (dhd->op_mode & DHD_FLAG_HOSTAP_MODE) {
+			wl_clr_drv_status(wl, SENDING_ACT_FRM, dev);
+			return false;
+		}
+	}
+
+	/* To make sure to send successfully action frame, we have to turn off mpc */
+	if (config_af_params.mpc_onoff == 0) {
+		wldev_iovar_setint(dev, "mpc", 0);
+	}
+
+	/* validate channel and p2p ies */
+	if (config_af_params.search_channel && IS_P2P_SOCIAL(af_params->channel) &&
+		wl_to_p2p_bss_saved_ie(wl, P2PAPI_BSSCFG_DEVICE).p2p_probe_req_ie_len) {
+		config_af_params.search_channel = true;
+	} else {
+		config_af_params.search_channel = false;
+	}
+#ifdef WL11U
+	if (ndev == wl_to_prmry_ndev(wl))
+		config_af_params.search_channel = false;
+#endif /* WL11U */
+
+#ifdef VSDB
+	/* if connecting on primary iface, sleep for a while before sending af tx for VSDB */
+	if (wl_get_drv_status(wl, CONNECTING, wl_to_prmry_ndev(wl))) {
+		msleep(50);
+	}
+#endif
+
+	/* if scan is ongoing, abort current scan. */
+	if (wl_get_drv_status_all(wl, SCANNING)) {
+#if 0
+		wl_notify_escan_complete(wl, ndev, true, true);
+#else
+		wl_notify_escan_complete(wl, wl->escan_info.ndev, true, true);		
+#endif
+	}
+
+	/* set status and destination address before sending af */
+	if (wl->next_af_subtype != P2P_PAF_SUBTYPE_INVALID) {
+		/* set this status to cancel the remained dwell time in rx process */
+		wl_set_drv_status(wl, WAITING_NEXT_ACT_FRM, dev);
+	}
+	wl_set_drv_status(wl, SENDING_ACT_FRM, dev);
+	memcpy(wl->afx_hdl->tx_dst_addr.octet,
+		af_params->action_frame.da.octet,
+		sizeof(wl->afx_hdl->tx_dst_addr.octet));
+
+	/* save af_params for rx process */
+	wl->afx_hdl->pending_tx_act_frm = af_params;
+
+	/* search peer's channel */
+	if (config_af_params.search_channel) {
+		/* initialize afx_hdl */
+		if (wl_cfgp2p_find_idx(wl, dev, &wl->afx_hdl->bssidx) != BCME_OK) {
+			WL_ERR(("Find p2p index from dev(%p) failed\n", dev));
+			goto exit;
+		}
+		wl->afx_hdl->dev = dev;
+		wl->afx_hdl->retry = 0;
+		wl->afx_hdl->peer_chan = WL_INVALID;
+
+		if (wl_cfg80211_af_searching_channel(wl, dev) == WL_INVALID) {
+			WL_ERR(("couldn't find peer's channel.\n"));
+			wl_cfgp2p_print_actframe(true, action_frame->data, action_frame->len,
+				af_params->channel);
+			goto exit;
+		}
+
+		wl_clr_drv_status(wl, SCANNING, wl->afx_hdl->dev);
+		/*
+		 * Abort scan even for VSDB scenarios. Scan gets aborted in firmware
+		 * but after the check of piggyback algorithm.
+		 * To take care of current piggback algo, lets abort the scan here itself.
+		 */
+		wl_notify_escan_complete(wl, dev, true, true);
+		/* Suspend P2P discovery's search-listen to prevent it from
+		 * starting a scan or changing the channel.
+		 */
+		wl_cfgp2p_discover_enable_search(wl, false);
+
+		/* update channel */
+		af_params->channel = wl->afx_hdl->peer_chan;
+	}
+
+#ifdef VSDB
+	off_chan_started_jiffies = jiffies;
+#endif /* VSDB */
+
+	wl_cfgp2p_print_actframe(true, action_frame->data, action_frame->len, af_params->channel);
+
+	/* Now send a tx action frame */
+	ack = wl_cfgp2p_tx_action_frame(wl, dev, af_params, bssidx) ? false : true;
+
+	/* if failed, retry it. tx_retry_max value is configure by .... */
+	while ((ack == false) && (tx_retry++ < config_af_params.max_tx_retry)) {
+#ifdef VSDB
+		if (af_params->channel) {
+			if (jiffies_to_msecs(jiffies - off_chan_started_jiffies) >
+				OFF_CHAN_TIME_THRESHOLD_MS) {
+				WL_AF_TX_KEEP_PRI_CONNECTION_VSDB(wl);
+				off_chan_started_jiffies = jiffies;
+			} else
+				msleep(AF_RETRY_DELAY_TIME);
+		}
+#endif /* VSDB */
+		ack = wl_cfgp2p_tx_action_frame(wl, dev, af_params, bssidx) ?
+			false : true;
 	}
-	wl->afx_hdl->dev = NULL;
-	wl->afx_hdl->bssidx = WL_INVALID;
+	if (ack == false) {
+		WL_ERR(("Failed to send Action Frame(retry %d)\n", tx_retry));
+	}
+exit:
+	/* Clear SENDING_ACT_FRM after all sending af is done */
 	wl_clr_drv_status(wl, SENDING_ACT_FRM, dev);
-	if (wl->afx_hdl->ack_recv)
-		return true; /* ACK */
-	else
-		return false; /* NO ACK */
+
+#ifdef WL_CFG80211_SYNC_GON
+	/* WAR: sometimes dongle does not keep the dwell time of 'actframe'.
+	 * if we coundn't get the next action response frame and dongle does not keep
+	 * the dwell time, go to listen state again to get next action response frame.
+	 */
+	if (ack && config_af_params.extra_listen &&
+		wl_get_drv_status_all(wl, WAITING_NEXT_ACT_FRM) &&
+		wl->af_sent_channel == wl->afx_hdl->my_listen_chan) {
+		s32 extar_listen_time;
+
+		extar_listen_time = af_params->dwell_time -
+			jiffies_to_msecs(jiffies - wl->af_tx_sent_jiffies);
+
+		if (extar_listen_time > 50) {
+			wl_set_drv_status(wl, WAITING_NEXT_ACT_FRM_LISTEN, dev);
+			WL_DBG(("Wait more time! actual af time:%d,"
+				"calculated extar listen:%d\n",
+				af_params->dwell_time, extar_listen_time));
+			if (wl_cfgp2p_discover_listen(wl, wl->af_sent_channel,
+				extar_listen_time + 100) == BCME_OK) {
+				wait_for_completion_timeout(&wl->wait_next_af,
+					msecs_to_jiffies(extar_listen_time + 100 + 300));
+			}
+			wl_clr_drv_status(wl, WAITING_NEXT_ACT_FRM_LISTEN, dev);
+		}
+	}
+#endif /* WL_CFG80211_SYNC_GON */
+	wl_clr_drv_status(wl, WAITING_NEXT_ACT_FRM, dev);
+
+	if (wl->afx_hdl->pending_tx_act_frm)
+		wl->afx_hdl->pending_tx_act_frm = NULL;
+
+	WL_INFO(("-- sending Action Frame is %s, listen chan: %d\n",
+		(ack) ? "Succeeded!!":"Failed!!", wl->afx_hdl->my_listen_chan));
+
+
+	/* if all done, turn mpc on again */
+	if (config_af_params.mpc_onoff == 1) {
+		wldev_iovar_setint(dev, "mpc", 1);
+	}
+
+	return ack;
 }
 
+#define MAX_NUM_OF_ASSOCIATED_DEV       64
 static s32
 wl_cfg80211_mgmt_tx(struct wiphy *wiphy, struct net_device *ndev,
 	struct ieee80211_channel *channel, bool offchan,
@@ -3644,24 +5016,14 @@ wl_cfg80211_mgmt_tx(struct wiphy *wiphy, struct net_device *ndev,
 {
 	wl_action_frame_t *action_frame;
 	wl_af_params_t *af_params;
-	wifi_p2p_ie_t *p2p_ie;
-	wpa_ie_fixed_t *wps_ie;
 	scb_val_t scb_val;
-	wifi_wfd_ie_t *wfd_ie;
 	const struct ieee80211_mgmt *mgmt;
 	struct wl_priv *wl = wiphy_priv(wiphy);
 	struct net_device *dev = NULL;
 	s32 err = BCME_OK;
 	s32 bssidx = 0;
-	u32 p2pie_len = 0;
-	u32 wpsie_len = 0;
-	u32 wfdie_len = 0;
 	u32 id;
-	u32 retry = 0;
 	bool ack = false;
-	wifi_p2p_pub_act_frame_t *act_frm = NULL;
-	wifi_p2p_action_frame_t *p2p_act_frm = NULL;
-	wifi_p2psd_gas_pub_act_frame_t *sd_act_frm = NULL;
 	s8 eabuf[ETHER_ADDR_STR_LEN];
 
 	WL_DBG(("Enter \n"));
@@ -3674,11 +5036,9 @@ wl_cfg80211_mgmt_tx(struct wiphy *wiphy, struct net_device *ndev,
 	}
 
 	/* find bssidx based on ndev */
-	bssidx = wl_cfgp2p_find_idx(wl, dev);
-	if (bssidx == -1) {
-
-		WL_ERR(("Can not find the bssidx for dev( %p )\n", dev));
-		return -ENODEV;
+	if (wl_cfgp2p_find_idx(wl, dev, &bssidx) != BCME_OK) {
+		WL_ERR(("Find p2p index from ndev(%p) failed\n", dev));
+		return BCME_ERROR;
 	}
 	if (p2p_is_on(wl)) {
 		/* Suspend P2P discovery search-listen to prevent it from changing the
@@ -3699,39 +5059,40 @@ wl_cfg80211_mgmt_tx(struct wiphy *wiphy, struct net_device *ndev,
 		if (ieee80211_is_probe_resp(mgmt->frame_control)) {
 			s32 ie_offset =  DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;
 			s32 ie_len = len - ie_offset;
-			if ((p2p_ie = wl_cfgp2p_find_p2pie((u8 *)(buf + ie_offset), ie_len))
-				!= NULL) {
-				/* Total length of P2P Information Element */
-				p2pie_len = p2p_ie->len + sizeof(p2p_ie->len) + sizeof(p2p_ie->id);
-			}
-			if ((wfd_ie = wl_cfgp2p_find_wfdie((u8 *)(buf + ie_offset), ie_len))
-				!= NULL) {
-				/* Total length of WFD Information Element */
-				wfdie_len = wfd_ie->len + sizeof(wfd_ie->len) + sizeof(wfd_ie->id);
-			}
-			if ((wps_ie = wl_cfgp2p_find_wpsie((u8 *)(buf + ie_offset), ie_len))
-				!= NULL) {
-				/* Order of Vendor IE is 1) WPS IE +
-				 * 2) P2P IE created by supplicant
-				 *  So, it is ok to find start address of WPS IE
-				 *  to save IEs
-				 */
-				wpsie_len = wps_ie->length + sizeof(wps_ie->length) +
-					sizeof(wps_ie->tag);
+			if (dev == wl_to_prmry_ndev(wl))
+				bssidx = wl_to_p2p_bss_bssidx(wl, P2PAPI_BSSCFG_DEVICE);
 				wl_cfgp2p_set_management_ie(wl, dev, bssidx,
-					VNDR_IE_PRBRSP_FLAG,
-					(u8 *)wps_ie, wpsie_len + p2pie_len + wfdie_len);
-			}
+				VNDR_IE_PRBRSP_FLAG, (u8 *)(buf + ie_offset), ie_len);
 			cfg80211_mgmt_tx_status(ndev, *cookie, buf, len, true, GFP_KERNEL);
 			goto exit;
 		} else if (ieee80211_is_disassoc(mgmt->frame_control) ||
 			ieee80211_is_deauth(mgmt->frame_control)) {
+			char mac_buf[MAX_NUM_OF_ASSOCIATED_DEV *
+				sizeof(struct ether_addr) + sizeof(uint)] = {0};
+			int num_associated = 0;
+			struct maclist *assoc_maclist = (struct maclist *)mac_buf;
+			if (!bcmp((const uint8 *)BSSID_BROADCAST,
+				(const struct ether_addr *)mgmt->da, ETHER_ADDR_LEN)) {
+				assoc_maclist->count = MAX_NUM_OF_ASSOCIATED_DEV;
+				err = wldev_ioctl(ndev, WLC_GET_ASSOCLIST,
+					assoc_maclist, sizeof(mac_buf), false);
+				if (err < 0)
+					WL_ERR(("WLC_GET_ASSOCLIST error %d\n", err));
+				else
+					num_associated = assoc_maclist->count;
+			}
 			memcpy(scb_val.ea.octet, mgmt->da, ETH_ALEN);
 			scb_val.val = mgmt->u.disassoc.reason_code;
-			wldev_ioctl(dev, WLC_SCB_DEAUTHENTICATE_FOR_REASON, &scb_val,
+			err = wldev_ioctl(dev, WLC_SCB_DEAUTHENTICATE_FOR_REASON, &scb_val,
 				sizeof(scb_val_t), true);
-			WL_DBG(("Disconnect STA : %s\n",
-				bcm_ether_ntoa((const struct ether_addr *)mgmt->da, eabuf)));
+			if (err < 0)
+				WL_ERR(("WLC_SCB_DEAUTHENTICATE_FOR_REASON error %d\n", err));
+			WL_ERR(("Disconnect STA : %s scb_val.val %d\n",
+				bcm_ether_ntoa((const struct ether_addr *)mgmt->da, eabuf),
+				scb_val.val));
+			if (num_associated) {
+				wl_delay(400);
+			}
 			cfg80211_mgmt_tx_status(ndev, *cookie, buf, len, true, GFP_KERNEL);
 			goto exit;
 
@@ -3743,8 +5104,12 @@ wl_cfg80211_mgmt_tx(struct wiphy *wiphy, struct net_device *ndev,
 			* tx is still in progress (including the dwell time),
 			* then this new action frame will not be sent out.
 			*/
+/* Do not abort scan for VSDB. Scan will be aborted in firmware if necessary.
+ * And previous off-channel action frame must be ended before new af tx.
+ */
+#ifndef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
 			wl_notify_escan_complete(wl, dev, true, true);
-
+#endif /* not WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
 		}
 
 	} else {
@@ -3777,98 +5142,23 @@ wl_cfg80211_mgmt_tx(struct wiphy *wiphy, struct net_device *ndev,
 	af_params->channel =
 		ieee80211_frequency_to_channel(channel->center_freq);
 
-	if (channel->band == IEEE80211_BAND_5GHZ) {
-		WL_DBG(("5GHz channel %d", af_params->channel));
-		err = wldev_ioctl(dev, WLC_SET_CHANNEL,
-			&af_params->channel, sizeof(af_params->channel), true);
-		if (err < 0) {
-			WL_ERR(("WLC_SET_CHANNEL error %d\n", err));
-		}
-	}
+	/* Save listen_chan for searching common channel */
+	wl->afx_hdl->peer_listen_chan = af_params->channel;
+	WL_DBG(("channel from upper layer %d\n", wl->afx_hdl->peer_listen_chan));
 
-	/* Add the dwell time
+	/* Add the default dwell time
 	 * Dwell time to stay off-channel to wait for a response action frame
 	 * after transmitting an GO Negotiation action frame
 	 */
 	af_params->dwell_time = WL_DWELL_TIME;
 
 	memcpy(action_frame->data, &buf[DOT11_MGMT_HDR_LEN], action_frame->len);
-	if (wl_cfgp2p_is_pub_action(action_frame->data, action_frame->len)) {
-		act_frm = (wifi_p2p_pub_act_frame_t *) (action_frame->data);
-		WL_DBG(("P2P PUB action_frame->len: %d chan %d category %d subtype %d\n",
-			action_frame->len, af_params->channel,
-			act_frm->category, act_frm->subtype));
-	} else if (wl_cfgp2p_is_p2p_action(action_frame->data, action_frame->len)) {
-		p2p_act_frm = (wifi_p2p_action_frame_t *) (action_frame->data);
-		WL_DBG(("P2P action_frame->len: %d chan %d category %d subtype %d\n",
-			action_frame->len, af_params->channel,
-			p2p_act_frm->category, p2p_act_frm->subtype));
-	} else if (wl_cfgp2p_is_gas_action(action_frame->data, action_frame->len)) {
-		sd_act_frm = (wifi_p2psd_gas_pub_act_frame_t *) (action_frame->data);
-		WL_DBG(("Service Discovery action_frame->len: %d chan %d category %d action %d\n",
-			action_frame->len, af_params->channel,
-			sd_act_frm->category, sd_act_frm->action));
-
-	}
-	wl_cfgp2p_print_actframe(true, action_frame->data, action_frame->len);
-		/*
-		 * To make sure to send successfully action frame, we have to turn off mpc
-		 */
-
-	if (act_frm && ((act_frm->subtype == P2P_PAF_GON_REQ) ||
-	  (act_frm->subtype == P2P_PAF_GON_RSP) ||
-	  (act_frm->subtype == P2P_PAF_GON_CONF) ||
-	  (act_frm->subtype == P2P_PAF_PROVDIS_REQ))) {
-		wldev_iovar_setint(dev, "mpc", 0);
-	}
-
-	if (act_frm && act_frm->subtype == P2P_PAF_DEVDIS_REQ) {
-		af_params->dwell_time = WL_LONG_DWELL_TIME;
-	} else if (act_frm &&
-		(act_frm->subtype == P2P_PAF_PROVDIS_REQ ||
-		act_frm->subtype == P2P_PAF_PROVDIS_RSP ||
-		act_frm->subtype == P2P_PAF_GON_RSP)) {
-		af_params->dwell_time = WL_MED_DWELL_TIME;
-	}
-
-	if (IS_P2P_SOCIAL(af_params->channel) &&
-		(IS_P2P_PUB_ACT_REQ(act_frm, action_frame->len) ||
-		IS_GAS_REQ(sd_act_frm, action_frame->len)) &&
-		wl_to_p2p_bss_saved_ie(wl, P2PAPI_BSSCFG_DEVICE).p2p_probe_req_ie_len) {
-		/* channel offload require P2P IE for Probe request
-		 * otherwise, we will use wl_cfgp2p_tx_action_frame directly.
-		 * channel offload for action request frame
-		 */
 
-		/* channel offload for action request frame */
-		ack = wl_cfg80211_send_at_common_channel(wl, dev, af_params);
-	} else {
-		ack = (wl_cfgp2p_tx_action_frame(wl, dev, af_params, bssidx)) ? false : true;
-		if (!ack) {
-			if (wl_to_p2p_bss_saved_ie(wl, P2PAPI_BSSCFG_DEVICE).p2p_probe_req_ie_len) {
-				/* if the NO ACK occurs, the peer device will be on
-				* listen channel of the peer
-				* So, we have to find the peer and send action frame on
-				* that channel.
-				*/
-				ack = wl_cfg80211_send_at_common_channel(wl, dev, af_params);
-			} else {
-				for (retry = 0; retry < WL_CHANNEL_SYNC_RETRY; retry++) {
-					ack = (wl_cfgp2p_tx_action_frame(wl, dev,
-						af_params, bssidx)) ? false : true;
-					if (ack)
-						break;
-				}
-
-			}
-
-		}
+	ack = wl_cfg80211_send_action_frame(wiphy, dev, ndev, af_params,
+		action_frame, action_frame->len, bssidx);
 
-	}
 	cfg80211_mgmt_tx_status(ndev, *cookie, buf, len, ack, GFP_KERNEL);
-	if (act_frm && act_frm->subtype == P2P_PAF_GON_CONF) {
-		wldev_iovar_setint(dev, "mpc", 1);
-	}
+
 	kfree(af_params);
 exit:
 	return err;
@@ -3880,7 +5170,7 @@ wl_cfg80211_mgmt_frame_register(struct wiphy *wiphy, struct net_device *dev,
 	u16 frame_type, bool reg)
 {
 
-	WL_DBG(("%s: frame_type: %x, reg: %d\n", __func__, frame_type, reg));
+	WL_DBG(("frame_type: %x, reg: %d\n", frame_type, reg));
 
 	if (frame_type != (IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_PROBE_REQ))
 		return;
@@ -3920,20 +5210,90 @@ wl_cfg80211_set_channel(struct wiphy *wiphy, struct net_device *dev,
 	struct ieee80211_channel *chan,
 	enum nl80211_channel_type channel_type)
 {
-	s32 channel;
+	s32 _chan;
+	chanspec_t chspec = 0;
+	chanspec_t fw_chspec = 0;
+	u32 bw = WL_CHANSPEC_BW_20;
+
 	s32 err = BCME_OK;
+	s32 bw_cap = 0;
+	struct {
+		u32 band;
+		u32 bw_cap;
+	} param = {0, 0};
 	struct wl_priv *wl = wiphy_priv(wiphy);
 
 	if (wl->p2p_net == dev) {
 		dev = wl_to_prmry_ndev(wl);
 	}
-	channel = ieee80211_frequency_to_channel(chan->center_freq);
-	WL_DBG(("netdev_ifidx(%d), chan_type(%d) target channel(%d) \n",
-		dev->ifindex, channel_type, channel));
-	err = wldev_ioctl(dev, WLC_SET_CHANNEL, &channel, sizeof(channel), true);
-	if (err < 0) {
-		WL_ERR(("WLC_SET_CHANNEL error %d chip may not be supporting this channel\n", err));
-	}
+	_chan = ieee80211_frequency_to_channel(chan->center_freq);
+	WL_ERR(("netdev_ifidx(%d), chan_type(%d) target channel(%d) \n",
+		dev->ifindex, channel_type, _chan));
+
+
+	if (chan->band == IEEE80211_BAND_5GHZ) {
+		param.band = WLC_BAND_5G;
+		err = wldev_iovar_getbuf(dev, "bw_cap", &param, sizeof(param),
+			wl->ioctl_buf, WLC_IOCTL_SMLEN, &wl->ioctl_buf_sync);
+		if (err) {
+			if (err != BCME_UNSUPPORTED) {
+				WL_ERR(("bw_cap failed, %d\n", err));
+				return err;
+			} else {
+				err = wldev_iovar_getint(dev, "mimo_bw_cap", &bw_cap);
+				if (err) {
+					WL_ERR(("error get mimo_bw_cap (%d)\n", err));
+				}
+				if (bw_cap != WLC_N_BW_20ALL)
+					bw = WL_CHANSPEC_BW_40;
+			}
+		} else {
+			if (WL_BW_CAP_80MHZ(wl->ioctl_buf[0]))
+				bw = WL_CHANSPEC_BW_80;
+			else if (WL_BW_CAP_40MHZ(wl->ioctl_buf[0]))
+				bw = WL_CHANSPEC_BW_40;
+			else
+				bw = WL_CHANSPEC_BW_20;
+
+		}
+
+	} else if (chan->band == IEEE80211_BAND_2GHZ)
+		bw = WL_CHANSPEC_BW_20;
+set_channel:
+	chspec = wf_channel2chspec(_chan, bw);
+	if (wf_chspec_valid(chspec)) {
+		fw_chspec = wl_chspec_host_to_driver(chspec);
+		if (fw_chspec != INVCHANSPEC) {
+			if ((err = wldev_iovar_setint(dev, "chanspec",
+				fw_chspec)) == BCME_BADCHAN) {
+				if (bw == WL_CHANSPEC_BW_80)
+					goto change_bw;
+				err = wldev_ioctl(dev, WLC_SET_CHANNEL,
+					&_chan, sizeof(_chan), true);
+				if (err < 0) {
+					WL_ERR(("WLC_SET_CHANNEL error %d"
+					"chip may not be supporting this channel\n", err));
+				}
+			} else if (err) {
+				WL_ERR(("failed to set chanspec error %d\n", err));
+			}
+		} else {
+			WL_ERR(("failed to convert host chanspec to fw chanspec\n"));
+			err = BCME_ERROR;
+		}
+	} else {
+change_bw:
+		if (bw == WL_CHANSPEC_BW_80)
+			bw = WL_CHANSPEC_BW_40;
+		else if (bw == WL_CHANSPEC_BW_40)
+			bw = WL_CHANSPEC_BW_20;
+		else
+			bw = 0;
+		if (bw)
+			goto set_channel;
+		WL_ERR(("Invalid chanspec 0x%x\n", chspec));
+		err = BCME_ERROR;
+	}
 	return err;
 }
 
@@ -3974,10 +5334,14 @@ wl_validate_wpa2ie(struct net_device *dev, bcm_tlv_t *wpa2ie, s32 bssidx)
 	u32 pval = 0;
 	u32 gval = 0;
 	u32 wpa_auth = 0;
-	u8* tmp;
 	wpa_suite_mcast_t *mcast;
 	wpa_suite_ucast_t *ucast;
 	wpa_suite_auth_key_mgmt_t *mgmt;
+
+	u16 suite_count;
+	u8 rsn_cap[2];
+	u32 wme_bss_disable;
+
 	if (wpa2ie == NULL)
 		goto exit;
 
@@ -3985,8 +5349,7 @@ wl_validate_wpa2ie(struct net_device *dev, bcm_tlv_t *wpa2ie, s32 bssidx)
 	len =  wpa2ie->len;
 	/* check the mcast cipher */
 	mcast = (wpa_suite_mcast_t *)&wpa2ie->data[WPA2_VERSION_LEN];
-	tmp = mcast->oui;
-	switch (tmp[DOT11_OUI_LEN]) {
+	switch (mcast->type) {
 		case WPA_CIPHER_NONE:
 			gval = 0;
 			break;
@@ -4009,12 +5372,13 @@ wl_validate_wpa2ie(struct net_device *dev, bcm_tlv_t *wpa2ie, s32 bssidx)
 			WL_ERR(("No Security Info\n"));
 			break;
 	}
-	len -= WPA_SUITE_LEN;
+	if ((len -= WPA_SUITE_LEN) <= 0)
+		return BCME_BADLEN;
+
 	/* check the unicast cipher */
 	ucast = (wpa_suite_ucast_t *)&mcast[1];
-	ltoh16_ua(&ucast->count);
-	tmp = ucast->list[0].oui;
-	switch (tmp[DOT11_OUI_LEN]) {
+	suite_count = ltoh16_ua(&ucast->count);
+	switch (ucast->list[0].type) {
 		case WPA_CIPHER_NONE:
 			pval = 0;
 			break;
@@ -4036,13 +5400,15 @@ wl_validate_wpa2ie(struct net_device *dev, bcm_tlv_t *wpa2ie, s32 bssidx)
 		default:
 			WL_ERR(("No Security Info\n"));
 	}
+	if ((len -= (WPA_IE_SUITE_COUNT_LEN + (WPA_SUITE_LEN * suite_count))) <= 0)
+		return BCME_BADLEN;
+
 	/* FOR WPS , set SEC_OW_ENABLED */
 	wsec = (pval | gval | SES_OW_ENABLED);
 	/* check the AKM */
-	mgmt = (wpa_suite_auth_key_mgmt_t *)&ucast->list[1];
-	ltoh16_ua(&mgmt->count);
-	tmp = (u8 *)&mgmt->list[0];
-	switch (tmp[DOT11_OUI_LEN]) {
+	mgmt = (wpa_suite_auth_key_mgmt_t *)&ucast->list[suite_count];
+	suite_count = ltoh16_ua(&mgmt->count);
+	switch (mgmt->list[0].type) {
 		case RSN_AKM_NONE:
 			wpa_auth = WPA_AUTH_NONE;
 			break;
@@ -4055,6 +5421,27 @@ wl_validate_wpa2ie(struct net_device *dev, bcm_tlv_t *wpa2ie, s32 bssidx)
 		default:
 			WL_ERR(("No Key Mgmt Info\n"));
 	}
+
+	if ((len -= (WPA_IE_SUITE_COUNT_LEN + (WPA_SUITE_LEN * suite_count))) >= RSN_CAP_LEN) {
+		rsn_cap[0] = *(u8 *)&mgmt->list[suite_count];
+		rsn_cap[1] = *((u8 *)&mgmt->list[suite_count] + 1);
+
+		if (rsn_cap[0] & (RSN_CAP_16_REPLAY_CNTRS << RSN_CAP_PTK_REPLAY_CNTR_SHIFT)) {
+			wme_bss_disable = 0;
+		} else {
+			wme_bss_disable = 1;
+		}
+
+		/* set wme_bss_disable to sync RSN Capabilities */
+		err = wldev_iovar_setint_bsscfg(dev, "wme_bss_disable", wme_bss_disable, bssidx);
+		if (err < 0) {
+			WL_ERR(("wme_bss_disable error %d\n", err));
+			return BCME_ERROR;
+		}
+	} else {
+		WL_DBG(("There is no RSN Capabilities. remained len %d\n", len));
+	}
+
 	/* set auth */
 	err = wldev_iovar_setint_bsscfg(dev, "auth", auth, bssidx);
 	if (err < 0) {
@@ -4223,122 +5610,210 @@ exit:
 	return 0;
 }
 
-#if 0
 static s32
-wl_cfg80211_add_set_beacon(struct wiphy *wiphy, struct net_device *dev,
-	struct beacon_parameters *info)
+wl_cfg80211_bcn_validate_sec(
+	struct net_device *dev,
+	struct parsed_ies *ies,
+	u32 dev_role,
+	s32 bssidx)
 {
-	s32 err = BCME_OK;
-	bcm_tlv_t *ssid_ie;
-	wlc_ssid_t ssid;
-	struct wl_priv *wl = wiphy_priv(wiphy);
-	struct wl_join_params join_params;
-	wpa_ie_fixed_t *wps_ie;
-	wpa_ie_fixed_t *wpa_ie;
-	bcm_tlv_t *wpa2_ie;
-	wifi_p2p_ie_t *p2p_ie;
-	wifi_wfd_ie_t *wfd_ie;
-	bool is_bssup = false;
-	bool update_bss = false;
-	bool pbc = false;
-	u16 wpsie_len = 0;
-	u16 p2pie_len = 0;
-	u32 wfdie_len = 0;
-	u8 beacon_ie[IE_MAX_LEN];
-	s32 ie_offset = 0;
-	s32 bssidx = 0;
-	s32 infra = 1;
-	s32 join_params_size = 0;
-	s32 ap = 0;
-	WL_DBG(("interval (%d) dtim_period (%d) head_len (%d) tail_len (%d)\n",
-		info->interval, info->dtim_period, info->head_len, info->tail_len));
+	struct wl_priv *wl = wlcfg_drv_priv;
 
-	if (wl->p2p_net == dev) {
-		dev = wl_to_prmry_ndev(wl);
-	}
+	if (dev_role == NL80211_IFTYPE_P2P_GO && (ies->wpa2_ie)) {
+		/* For P2P GO, the sec type is WPA2-PSK */
+		WL_DBG(("P2P GO: validating wpa2_ie"));
+		if (wl_validate_wpa2ie(dev, ies->wpa2_ie, bssidx)  < 0)
+			return BCME_ERROR;
+
+	} else if (dev_role == NL80211_IFTYPE_AP) {
+
+		WL_DBG(("SoftAP: validating security"));
+		/* If wpa2_ie or wpa_ie is present validate it */
+		if ((ies->wpa2_ie || ies->wpa_ie) &&
+			((wl_validate_wpa2ie(dev, ies->wpa2_ie, bssidx)  < 0 ||
+			wl_validate_wpaie(dev, ies->wpa_ie, bssidx) < 0))) {
+			wl->ap_info->security_mode = false;
+			return BCME_ERROR;
+		}
 
-	bssidx = wl_cfgp2p_find_idx(wl, dev);
-	if (p2p_is_on(wl) &&
-		(bssidx == wl_to_p2p_bss_bssidx(wl,
-		P2PAPI_BSSCFG_CONNECTION))) {
-		memset(beacon_ie, 0, sizeof(beacon_ie));
-		/* We don't need to set beacon for P2P_GO,
-		 * but need to parse ssid from beacon_parameters
-		 * because there is no way to set ssid
-		 */
-		ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;
-		/* find the SSID */
-		if ((ssid_ie = bcm_parse_tlvs((u8 *)&info->head[ie_offset],
-			info->head_len - ie_offset,
-			DOT11_MNG_SSID_ID)) != NULL) {
-			memcpy(wl->p2p->ssid.SSID, ssid_ie->data, ssid_ie->len);
-			wl->p2p->ssid.SSID_len = ssid_ie->len;
-			WL_DBG(("SSID (%s) in Head \n", ssid_ie->data));
+		wl->ap_info->security_mode = true;
+		if (wl->ap_info->rsn_ie) {
+			kfree(wl->ap_info->rsn_ie);
+			wl->ap_info->rsn_ie = NULL;
+		}
+		if (wl->ap_info->wpa_ie) {
+			kfree(wl->ap_info->wpa_ie);
+			wl->ap_info->wpa_ie = NULL;
+		}
+		if (wl->ap_info->wps_ie) {
+			kfree(wl->ap_info->wps_ie);
+			wl->ap_info->wps_ie = NULL;
+		}
+		if (ies->wpa_ie != NULL) {
+			/* WPAIE */
+			wl->ap_info->rsn_ie = NULL;
+			wl->ap_info->wpa_ie = kmemdup(ies->wpa_ie,
+				ies->wpa_ie->length + WPA_RSN_IE_TAG_FIXED_LEN,
+				GFP_KERNEL);
+		} else if (ies->wpa2_ie != NULL) {
+			/* RSNIE */
+			wl->ap_info->wpa_ie = NULL;
+			wl->ap_info->rsn_ie = kmemdup(ies->wpa2_ie,
+				ies->wpa2_ie->len + WPA_RSN_IE_TAG_FIXED_LEN,
+				GFP_KERNEL);
+		}
 
-		} else {
-			WL_ERR(("No SSID in beacon \n"));
+		if (!ies->wpa2_ie && !ies->wpa_ie) {
+			wl_validate_opensecurity(dev, bssidx);
+			wl->ap_info->security_mode = false;
 		}
 
-		/* find the WPSIE */
-		if ((wps_ie = wl_cfgp2p_find_wpsie((u8 *)info->tail, info->tail_len)) != NULL) {
-			wpsie_len = wps_ie->length + WPA_RSN_IE_TAG_FIXED_LEN;
-			/*
-			 * Should be compared with saved ie before saving it
-			 */
-			wl_validate_wps_ie((char *) wps_ie, &pbc);
-			memcpy(beacon_ie, wps_ie, wpsie_len);
-		} else {
-			WL_ERR(("No WPSIE in beacon \n"));
+		if (ies->wps_ie) {
+			wl->ap_info->wps_ie = kmemdup(ies->wps_ie, ies->wps_ie_len, GFP_KERNEL);
 		}
+	}
 
+	return 0;
 
-		/* find the P2PIE */
-		if ((p2p_ie = wl_cfgp2p_find_p2pie((u8 *)info->tail, info->tail_len)) != NULL) {
-			/* Total length of P2P Information Element */
-			p2pie_len = p2p_ie->len + sizeof(p2p_ie->len) + sizeof(p2p_ie->id);
-			memcpy(&beacon_ie[wpsie_len], p2p_ie, p2pie_len);
+}
 
-		} else {
-			WL_ERR(("No P2PIE in beacon \n"));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+static s32 wl_cfg80211_bcn_set_params(
+	struct cfg80211_ap_settings *info,
+	struct net_device *dev,
+	u32 dev_role, s32 bssidx)
+{
+	struct wl_priv *wl = wlcfg_drv_priv;
+	s32 err = BCME_OK;
+
+	WL_DBG(("interval (%d) \ndtim_period (%d) \n",
+		info->beacon_interval, info->dtim_period));
+
+	if (info->beacon_interval) {
+		if ((err = wldev_ioctl(dev, WLC_SET_BCNPRD,
+			&info->beacon_interval, sizeof(s32), true)) < 0) {
+			WL_ERR(("Beacon Interval Set Error, %d\n", err));
+			return err;
 		}
+	}
 
-		/* find the WFD IEs */
-		if ((wfd_ie = wl_cfgp2p_find_wfdie((u8 *)info->tail, info->tail_len)) != NULL) {
-			/* Total length of P2P Information Element */
-			wfdie_len = wfd_ie->len + sizeof(wfd_ie->len) + sizeof(wfd_ie->id);
-			if ((wpsie_len + p2pie_len + wfdie_len) < IE_MAX_LEN) {
-				memcpy(&beacon_ie[wpsie_len + p2pie_len], wfd_ie, wfdie_len);
-			} else {
-				WL_ERR(("Found WFD IE but there is no space, (%d)(%d)(%d)\n",
-					wpsie_len, p2pie_len, wfdie_len));
-				wfdie_len = 0;
-			}
-		} else {
-			WL_ERR(("No WFDIE in beacon \n"));
+	if (info->dtim_period) {
+		if ((err = wldev_ioctl(dev, WLC_SET_DTIMPRD,
+			&info->dtim_period, sizeof(s32), true)) < 0) {
+			WL_ERR(("DTIM Interval Set Error, %d\n", err));
+			return err;
 		}
-		/* add WLC_E_PROBREQ_MSG event to respose probe_request from STA */
-		wl_add_remove_eventmsg(dev, WLC_E_PROBREQ_MSG, pbc);
-		wl_cfgp2p_set_management_ie(wl, dev, bssidx, VNDR_IE_BEACON_FLAG,
-			beacon_ie, wpsie_len + p2pie_len + wfdie_len);
+	}
 
-		/* find the RSN_IE */
-		if ((wpa2_ie = bcm_parse_tlvs((u8 *)info->tail, info->tail_len,
-			DOT11_MNG_RSN_ID)) != NULL) {
-			WL_DBG((" WPA2 IE is found\n"));
+	if ((info->ssid) && (info->ssid_len > 0) &&
+		(info->ssid_len <= 32)) {
+		WL_DBG(("SSID (%s) len:%d \n", info->ssid, info->ssid_len));
+		if (dev_role == NL80211_IFTYPE_AP) {
+			/* Store the hostapd SSID */
+			memset(wl->hostapd_ssid.SSID, 0x00, 32);
+			memcpy(wl->hostapd_ssid.SSID, info->ssid, info->ssid_len);
+			wl->hostapd_ssid.SSID_len = info->ssid_len;
+		} else {
+				/* P2P GO */
+			memset(wl->p2p->ssid.SSID, 0x00, 32);
+			memcpy(wl->p2p->ssid.SSID, info->ssid, info->ssid_len);
+			wl->p2p->ssid.SSID_len = info->ssid_len;
 		}
+	}
+
+	if (info->hidden_ssid) {
+		if ((err = wldev_iovar_setint(dev, "closednet", 1)) < 0)
+			WL_ERR(("failed to set hidden : %d\n", err));
+		WL_DBG(("hidden_ssid_enum_val: %d \n", info->hidden_ssid));
+	}
+
+	return err;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0) */
+
+static s32
+wl_cfg80211_parse_ies(u8 *ptr, u32 len, struct parsed_ies *ies)
+{
+	s32 err = BCME_OK;
+
+	memset(ies, 0, sizeof(struct parsed_ies));
+
+	/* find the WPSIE */
+	if ((ies->wps_ie = wl_cfgp2p_find_wpsie(ptr, len)) != NULL) {
+		WL_DBG(("WPSIE in beacon \n"));
+		ies->wps_ie_len = ies->wps_ie->length + WPA_RSN_IE_TAG_FIXED_LEN;
+	} else {
+		WL_ERR(("No WPSIE in beacon \n"));
+	}
+
+	/* find the RSN_IE */
+	if ((ies->wpa2_ie = bcm_parse_tlvs(ptr, len,
+		DOT11_MNG_RSN_ID)) != NULL) {
+		WL_DBG((" WPA2 IE found\n"));
+		ies->wpa2_ie_len = ies->wpa2_ie->len;
+	}
+
+	/* find the WPA_IE */
+	if ((ies->wpa_ie = wl_cfgp2p_find_wpaie(ptr, len)) != NULL) {
+		WL_DBG((" WPA found\n"));
+		ies->wpa_ie_len = ies->wpa_ie->length;
+	}
+
+	return err;
+
+}
+
+static void wl_cfg80211_scan_abort(struct wl_priv *wl)
+{
+       wl_scan_params_t *params = NULL;
+       s32 params_size = 0;
+       s32 err = BCME_OK;
+       struct net_device *dev = wl_to_prmry_ndev(wl);
+       if (!in_atomic()) {
+               /* Our scan params only need space for 1 channel and 0 ssids */
+               params = wl_cfg80211_scan_alloc_params(-1, 0, &params_size);
+               if (params == NULL) {
+                       WL_ERR(("scan params allocation failed \n"));
+                       err = -ENOMEM;
+               } else {
+                       /* Do a scan abort to stop the driver's scan engine */
+                       err = wldev_ioctl(dev, WLC_SCAN, params, params_size, true);
+                       if (err < 0) {
+                               WL_ERR(("scan abort  failed \n"));
+                       }
+                       kfree(params);
+               }
+       }
+}
+static s32
+wl_cfg80211_bcn_bringup_ap(
+	struct net_device *dev,
+	struct parsed_ies *ies,
+	u32 dev_role, s32 bssidx)
+{
+	struct wl_priv *wl = wlcfg_drv_priv;
+	struct wl_join_params join_params;
+	bool is_bssup = false;
+	s32 infra = 1;
+	s32 join_params_size = 0;
+	s32 ap = 1;
+	s32 err = BCME_OK;
+
+	WL_DBG(("Enter dev_role: %d\n", dev_role));
+
+	/* Common code for SoftAP and P2P GO */
+	wldev_iovar_setint(dev, "mpc", 0);
+
+	if (dev_role == NL80211_IFTYPE_P2P_GO) {
 		is_bssup = wl_cfgp2p_bss_isup(dev, bssidx);
+		if (!is_bssup && (ies->wpa2_ie != NULL)) {
 
-		if (!is_bssup && (wpa2_ie != NULL)) {
-			wldev_iovar_setint(dev, "mpc", 0);
-			if ((err = wl_validate_wpa2ie(dev, wpa2_ie, bssidx)) < 0) {
-				WL_ERR(("WPA2 IE parsing error"));
-				goto exit;
-			}
 			err = wldev_ioctl(dev, WLC_SET_INFRA, &infra, sizeof(s32), true);
 			if (err < 0) {
 				WL_ERR(("SET INFRA error %d\n", err));
 				goto exit;
 			}
+
 			err = wldev_iovar_setbuf_bsscfg(dev, "ssid", &wl->p2p->ssid,
 				sizeof(wl->p2p->ssid), wl->ioctl_buf, WLC_IOCTL_MAXLEN,
 				bssidx, &wl->ioctl_buf_sync);
@@ -4346,1177 +5821,1297 @@ wl_cfg80211_add_set_beacon(struct wiphy *wiphy, struct net_device *dev,
 				WL_ERR(("GO SSID setting error %d\n", err));
 				goto exit;
 			}
+
+			/* Do abort scan before creating GO */
+#if 0
+			if (wl_get_drv_status_all(wl, SCANNING) && wl->escan_info.ndev)
+				wl_notify_escan_complete(wl, wl->escan_info.ndev, true, true);
+#else
+                        wl_cfg80211_scan_abort(wl);
+#endif
+
 			if ((err = wl_cfgp2p_bss(wl, dev, bssidx, 1)) < 0) {
 				WL_ERR(("GO Bring up error %d\n", err));
 				goto exit;
 			}
+		} else
+			WL_DBG(("Bss is already up\n"));
+	} else if ((dev_role == NL80211_IFTYPE_AP) &&
+		(wl_get_drv_status(wl, AP_CREATING, dev))) {
+		/* Device role SoftAP */
+		err = wldev_ioctl(dev, WLC_DOWN, &ap, sizeof(s32), true);
+		if (err < 0) {
+			WL_ERR(("WLC_DOWN error %d\n", err));
+			goto exit;
 		}
-	} else if (wl_get_drv_status(wl, AP_CREATING, dev)) {
-		ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;
-		ap = 1;
-		/* find the SSID */
-		if ((ssid_ie = bcm_parse_tlvs((u8 *)&info->head[ie_offset],
-			info->head_len - ie_offset,
-			DOT11_MNG_SSID_ID)) != NULL) {
-			memset(&ssid, 0, sizeof(wlc_ssid_t));
-			memcpy(ssid.SSID, ssid_ie->data, ssid_ie->len);
-			WL_DBG(("SSID is (%s) in Head \n", ssid.SSID));
-			ssid.SSID_len = ssid_ie->len;
-			wldev_iovar_setint(dev, "mpc", 0);
-			wldev_ioctl(dev, WLC_DOWN, &ap, sizeof(s32), true);
-			wldev_ioctl(dev, WLC_SET_INFRA, &infra, sizeof(s32), true);
-			if ((err = wldev_ioctl(dev, WLC_SET_AP, &ap, sizeof(s32), true)) < 0) {
-				WL_ERR(("setting AP mode failed %d \n", err));
-				return err;
-			}
-			/* find the RSN_IE */
-			if ((wpa2_ie = bcm_parse_tlvs((u8 *)info->tail, info->tail_len,
-				DOT11_MNG_RSN_ID)) != NULL) {
-				WL_DBG((" WPA2 IE is found\n"));
-			}
-			/* find the WPA_IE */
-			if ((wpa_ie = wl_cfgp2p_find_wpaie((u8 *)info->tail,
-			info->tail_len)) != NULL) {
-				WL_DBG((" WPA IE is found\n"));
-			}
-			if ((wpa_ie != NULL || wpa2_ie != NULL)) {
-				if (wl_validate_wpa2ie(dev, wpa2_ie, bssidx)  < 0 ||
-					wl_validate_wpaie(dev, wpa_ie, bssidx) < 0) {
-					wl->ap_info->security_mode = false;
-					return BCME_ERROR;
-				}
-				wl->ap_info->security_mode = true;
-				if (wl->ap_info->rsn_ie) {
-					kfree(wl->ap_info->rsn_ie);
-					wl->ap_info->rsn_ie = NULL;
-				}
-				if (wl->ap_info->wpa_ie) {
-					kfree(wl->ap_info->wpa_ie);
-					wl->ap_info->wpa_ie = NULL;
-				}
-				if (wl->ap_info->wps_ie) {
-					kfree(wl->ap_info->wps_ie);
-					wl->ap_info->wps_ie = NULL;
-				}
-				if (wpa_ie != NULL) {
-					/* WPAIE */
-					wl->ap_info->rsn_ie = NULL;
-					wl->ap_info->wpa_ie = kmemdup(wpa_ie,
-						wpa_ie->length + WPA_RSN_IE_TAG_FIXED_LEN,
-						GFP_KERNEL);
-				} else {
-					/* RSNIE */
-					wl->ap_info->wpa_ie = NULL;
-					wl->ap_info->rsn_ie = kmemdup(wpa2_ie,
-						wpa2_ie->len + WPA_RSN_IE_TAG_FIXED_LEN,
-						GFP_KERNEL);
-				}
-			} else {
-				wl_validate_opensecurity(dev, bssidx);
-				wl->ap_info->security_mode = false;
-			}
-			/* find the WPSIE */
-			if ((wps_ie = wl_cfgp2p_find_wpsie((u8 *)info->tail,
-				info->tail_len)) != NULL) {
-				wpsie_len = wps_ie->length +WPA_RSN_IE_TAG_FIXED_LEN;
-				/*
-				* Should be compared with saved ie before saving it
-				*/
-				wl_validate_wps_ie((char *) wps_ie, &pbc);
-				memcpy(beacon_ie, wps_ie, wpsie_len);
-				wl_cfgp2p_set_management_ie(wl, dev, bssidx, VNDR_IE_BEACON_FLAG,
-				beacon_ie, wpsie_len);
-				wl->ap_info->wps_ie = kmemdup(wps_ie, wpsie_len, GFP_KERNEL);
-				/* add WLC_E_PROBREQ_MSG event to respose probe_request from STA */
-				wl_add_remove_eventmsg(dev, WLC_E_PROBREQ_MSG, pbc);
-			} else {
-				WL_DBG(("No WPSIE in beacon \n"));
-			}
-			if (info->interval) {
-				if ((err = wldev_ioctl(dev, WLC_SET_BCNPRD,
-					&info->interval, sizeof(s32), true)) < 0) {
-					WL_ERR(("Beacon Interval Set Error, %d\n", err));
-					return err;
-				}
-			}
-			if (info->dtim_period) {
-				if ((err = wldev_ioctl(dev, WLC_SET_DTIMPRD,
-					&info->dtim_period, sizeof(s32), true)) < 0) {
-					WL_ERR(("DTIM Interval Set Error, %d\n", err));
-					return err;
-				}
-			}
-			err = wldev_ioctl(dev, WLC_UP, &ap, sizeof(s32), true);
-			if (unlikely(err)) {
-				WL_ERR(("WLC_UP error (%d)\n", err));
-				return err;
-			}
-			memset(&join_params, 0, sizeof(join_params));
-			/* join parameters starts with ssid */
-			join_params_size = sizeof(join_params.ssid);
-			memcpy(join_params.ssid.SSID, ssid.SSID, ssid.SSID_len);
-			join_params.ssid.SSID_len = htod32(ssid.SSID_len);
-			/* create softap */
-			if ((err = wldev_ioctl(dev, WLC_SET_SSID, &join_params,
-				join_params_size, true)) == 0) {
-				wl_clr_drv_status(wl, AP_CREATING, dev);
-				wl_set_drv_status(wl, AP_CREATED, dev);
-			}
+		err = wldev_ioctl(dev, WLC_SET_INFRA, &infra, sizeof(s32), true);
+		if (err < 0) {
+			WL_ERR(("SET INFRA error %d\n", err));
+			goto exit;
 		}
-	} else if (wl_get_drv_status(wl, AP_CREATED, dev)) {
-		ap = 1;
-		/* find the WPSIE */
-		if ((wps_ie = wl_cfgp2p_find_wpsie((u8 *)info->tail, info->tail_len)) != NULL) {
-			wpsie_len = wps_ie->length + WPA_RSN_IE_TAG_FIXED_LEN;
-			/*
-			 * Should be compared with saved ie before saving it
-			 */
-			wl_validate_wps_ie((char *) wps_ie, &pbc);
-			memcpy(beacon_ie, wps_ie, wpsie_len);
-			wl_cfgp2p_set_management_ie(wl, dev, bssidx, VNDR_IE_BEACON_FLAG,
-			beacon_ie, wpsie_len);
-			if (wl->ap_info->wps_ie &&
-				memcmp(wl->ap_info->wps_ie, wps_ie, wpsie_len)) {
-				WL_DBG((" WPS IE is changed\n"));
-				kfree(wl->ap_info->wps_ie);
-				wl->ap_info->wps_ie = kmemdup(wps_ie, wpsie_len, GFP_KERNEL);
-				/* add WLC_E_PROBREQ_MSG event to respose probe_request from STA */
-				wl_add_remove_eventmsg(dev, WLC_E_PROBREQ_MSG, pbc);
-			} else if (wl->ap_info->wps_ie == NULL) {
-				WL_DBG((" WPS IE is added\n"));
-				wl->ap_info->wps_ie = kmemdup(wps_ie, wpsie_len, GFP_KERNEL);
-				/* add WLC_E_PROBREQ_MSG event to respose probe_request from STA */
-				wl_add_remove_eventmsg(dev, WLC_E_PROBREQ_MSG, pbc);
-			}
-			/* find the RSN_IE */
-			if ((wpa2_ie = bcm_parse_tlvs((u8 *)info->tail, info->tail_len,
-				DOT11_MNG_RSN_ID)) != NULL) {
-				WL_DBG((" WPA2 IE is found\n"));
-			}
-			/* find the WPA_IE */
-			if ((wpa_ie = wl_cfgp2p_find_wpaie((u8 *)info->tail,
-				info->tail_len)) != NULL) {
-				WL_DBG((" WPA IE is found\n"));
-			}
-			if ((wpa_ie != NULL || wpa2_ie != NULL)) {
-				if (!wl->ap_info->security_mode) {
-					/* change from open mode to security mode */
-					update_bss = true;
-					if (wpa_ie != NULL) {
-						wl->ap_info->wpa_ie = kmemdup(wpa_ie,
-						wpa_ie->length + WPA_RSN_IE_TAG_FIXED_LEN,
-						GFP_KERNEL);
-					} else {
-						wl->ap_info->rsn_ie = kmemdup(wpa2_ie,
-						wpa2_ie->len + WPA_RSN_IE_TAG_FIXED_LEN,
-						GFP_KERNEL);
-					}
-				} else if (wl->ap_info->wpa_ie) {
-					/* change from WPA mode to WPA2 mode */
-					if (wpa2_ie != NULL) {
-						update_bss = true;
-						kfree(wl->ap_info->wpa_ie);
-						wl->ap_info->rsn_ie = kmemdup(wpa2_ie,
-						wpa2_ie->len + WPA_RSN_IE_TAG_FIXED_LEN,
-						GFP_KERNEL);
-						wl->ap_info->wpa_ie = NULL;
-					}
-					else if (memcmp(wl->ap_info->wpa_ie,
-						wpa_ie, wpa_ie->length +
-						WPA_RSN_IE_TAG_FIXED_LEN)) {
-						kfree(wl->ap_info->wpa_ie);
-						update_bss = true;
-						wl->ap_info->wpa_ie = kmemdup(wpa_ie,
-						wpa_ie->length + WPA_RSN_IE_TAG_FIXED_LEN,
-						GFP_KERNEL);
-						wl->ap_info->rsn_ie = NULL;
-					}
-				} else {
-					/* change from WPA2 mode to WPA mode */
-					if (wpa_ie != NULL) {
-						update_bss = true;
-						kfree(wl->ap_info->rsn_ie);
-						wl->ap_info->rsn_ie = NULL;
-						wl->ap_info->wpa_ie = kmemdup(wpa_ie,
-						wpa_ie->length + WPA_RSN_IE_TAG_FIXED_LEN,
-						GFP_KERNEL);
-					} else if (memcmp(wl->ap_info->rsn_ie,
-						wpa2_ie, wpa2_ie->len + WPA_RSN_IE_TAG_FIXED_LEN)) {
-						update_bss = true;
-						kfree(wl->ap_info->rsn_ie);
-						wl->ap_info->rsn_ie = kmemdup(wpa2_ie,
-						wpa2_ie->len + WPA_RSN_IE_TAG_FIXED_LEN,
-						GFP_KERNEL);
-						wl->ap_info->wpa_ie = NULL;
-					}
-				}
-				if (update_bss) {
-					wl->ap_info->security_mode = true;
-					wl_cfgp2p_bss(wl, dev, bssidx, 0);
-					if (wl_validate_wpa2ie(dev, wpa2_ie, bssidx)  < 0 ||
-						wl_validate_wpaie(dev, wpa_ie, bssidx) < 0) {
-						return BCME_ERROR;
-					}
-					wl_cfgp2p_bss(wl, dev, bssidx, 1);
-				}
-			}
-		} else {
-			WL_ERR(("No WPSIE in beacon \n"));
+		if ((err = wldev_ioctl(dev, WLC_SET_AP, &ap, sizeof(s32), true)) < 0) {
+			WL_ERR(("setting AP mode failed %d \n", err));
+			goto exit;
+		}
+
+		err = wldev_ioctl(dev, WLC_UP, &ap, sizeof(s32), true);
+		if (unlikely(err)) {
+			WL_ERR(("WLC_UP error (%d)\n", err));
+			goto exit;
+		}
+
+		memset(&join_params, 0, sizeof(join_params));
+		/* join parameters starts with ssid */
+		join_params_size = sizeof(join_params.ssid);
+		memcpy(join_params.ssid.SSID, wl->hostapd_ssid.SSID,
+			wl->hostapd_ssid.SSID_len);
+		join_params.ssid.SSID_len = htod32(wl->hostapd_ssid.SSID_len);
+
+		/* create softap */
+		if ((err = wldev_ioctl(dev, WLC_SET_SSID, &join_params,
+			join_params_size, true)) == 0) {
+			WL_DBG(("SoftAP set SSID (%s) success\n", join_params.ssid.SSID));
+			wl_clr_drv_status(wl, AP_CREATING, dev);
+			wl_set_drv_status(wl, AP_CREATED, dev);
 		}
 	}
+
+
 exit:
-	if (err)
-		wldev_iovar_setint(dev, "mpc", 1);
 	return err;
 }
-#endif
-
-static struct cfg80211_ops wl_cfg80211_ops = {
-	.add_virtual_intf = wl_cfg80211_add_virtual_iface,
-	.del_virtual_intf = wl_cfg80211_del_virtual_iface,
-	.change_virtual_intf = wl_cfg80211_change_virtual_iface,
-	.scan = wl_cfg80211_scan,
-	.set_wiphy_params = wl_cfg80211_set_wiphy_params,
-	.join_ibss = wl_cfg80211_join_ibss,
-	.leave_ibss = wl_cfg80211_leave_ibss,
-	.get_station = wl_cfg80211_get_station,
-	.set_tx_power = wl_cfg80211_set_tx_power,
-	.get_tx_power = wl_cfg80211_get_tx_power,
-	.add_key = wl_cfg80211_add_key,
-	.del_key = wl_cfg80211_del_key,
-	.get_key = wl_cfg80211_get_key,
-	.set_default_key = wl_cfg80211_config_default_key,
-	.set_default_mgmt_key = wl_cfg80211_config_default_mgmt_key,
-	.set_power_mgmt = wl_cfg80211_set_power_mgmt,
-	.connect = wl_cfg80211_connect,
-	.disconnect = wl_cfg80211_disconnect,
-	.suspend = wl_cfg80211_suspend,
-	.resume = wl_cfg80211_resume,
-	.set_pmksa = wl_cfg80211_set_pmksa,
-	.del_pmksa = wl_cfg80211_del_pmksa,
-	.flush_pmksa = wl_cfg80211_flush_pmksa,
-	.remain_on_channel = wl_cfg80211_remain_on_channel,
-	.cancel_remain_on_channel = wl_cfg80211_cancel_remain_on_channel,
-	.mgmt_tx = wl_cfg80211_mgmt_tx,
-	.mgmt_frame_register = wl_cfg80211_mgmt_frame_register,
-	.change_bss = wl_cfg80211_change_bss,
-	.set_channel = wl_cfg80211_set_channel,
-#if 0
-	.set_beacon = wl_cfg80211_add_set_beacon,
-	.add_beacon = wl_cfg80211_add_set_beacon,
-#endif
-};
 
-s32 wl_mode_to_nl80211_iftype(s32 mode)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+s32
+wl_cfg80211_parse_ap_ies(
+	struct net_device *dev,
+	struct cfg80211_beacon_data *info,
+	struct parsed_ies *ies)
 {
-	s32 err = 0;
+	struct parsed_ies prb_ies;
+	struct wl_priv *wl = wlcfg_drv_priv;
+	dhd_pub_t *dhd = (dhd_pub_t *)(wl->pub);
+	u8 *vndr = NULL;
+	u32 vndr_ie_len = 0;
+	s32 err = BCME_OK;
 
-	switch (mode) {
-	case WL_MODE_BSS:
-		return NL80211_IFTYPE_STATION;
-	case WL_MODE_IBSS:
-		return NL80211_IFTYPE_ADHOC;
-	case WL_MODE_AP:
-		return NL80211_IFTYPE_AP;
-	default:
-		return NL80211_IFTYPE_UNSPECIFIED;
+	/* Parse Beacon IEs */
+	if (wl_cfg80211_parse_ies((u8 *)info->tail,
+		info->tail_len, ies) < 0) {
+		WL_ERR(("Beacon get IEs failed \n"));
+		err = -EINVAL;
+		goto fail;
 	}
 
-	return err;
-}
+	if (dhd->op_mode & DHD_FLAG_HOSTAP_MODE) {
+		/* SoftAP mode */
+		struct ieee80211_mgmt *mgmt;
+		mgmt = (struct ieee80211_mgmt *)info->probe_resp;
+		if (mgmt != NULL) {
+			vndr = (u8 *)&mgmt->u.probe_resp.variable;
+			vndr_ie_len = info->probe_resp_len -
+				offsetof(struct ieee80211_mgmt, u.probe_resp.variable);
+		}
+	} else {
+		/* Other mode */
+		vndr = (u8 *)info->proberesp_ies;
+		vndr_ie_len = info->proberesp_ies_len;
+	}
 
-static s32 wl_setup_wiphy(struct wireless_dev *wdev, struct device *sdiofunc_dev)
-{
-	s32 err = 0;
-	wdev->wiphy =
-	    wiphy_new(&wl_cfg80211_ops, sizeof(struct wl_priv));
-	if (unlikely(!wdev->wiphy)) {
-		WL_ERR(("Couldn not allocate wiphy device\n"));
-		err = -ENOMEM;
-		return err;
+	/* Parse Probe Response IEs */
+	if (wl_cfg80211_parse_ies(vndr, vndr_ie_len, &prb_ies) < 0) {
+		WL_ERR(("PROBE RESP get IEs failed \n"));
+		err = -EINVAL;
 	}
-	set_wiphy_dev(wdev->wiphy, sdiofunc_dev);
-	wdev->wiphy->max_scan_ie_len = WL_SCAN_IE_LEN_MAX;
-	/* Report  how many SSIDs Driver can support per Scan request */
-	wdev->wiphy->max_scan_ssids = WL_SCAN_PARAMS_SSID_MAX;
-	wdev->wiphy->max_num_pmkids = WL_NUM_PMKIDS_MAX;
-	wdev->wiphy->interface_modes =
-		BIT(NL80211_IFTYPE_STATION)
-		| BIT(NL80211_IFTYPE_AP) | BIT(NL80211_IFTYPE_MONITOR);
 
-	wdev->wiphy->bands[IEEE80211_BAND_2GHZ] = &__wl_band_2ghz;
+fail:
 
-	wdev->wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
-	wdev->wiphy->cipher_suites = __wl_cipher_suites;
-	wdev->wiphy->n_cipher_suites = ARRAY_SIZE(__wl_cipher_suites);
-	wdev->wiphy->max_remain_on_channel_duration = 5000;
-	wdev->wiphy->mgmt_stypes = wl_cfg80211_default_mgmt_stypes;
-#ifndef WL_POWERSAVE_DISABLED
-	wdev->wiphy->flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;
-#else
-	wdev->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
-#endif				/* !WL_POWERSAVE_DISABLED */
-	wdev->wiphy->flags |= WIPHY_FLAG_NETNS_OK |
-		WIPHY_FLAG_4ADDR_AP |
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 39)
-		WIPHY_FLAG_SUPPORTS_SEPARATE_DEFAULT_KEYS |
-#endif
-		WIPHY_FLAG_4ADDR_STATION;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
-	wdev->wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM;
-#endif
-	WL_DBG(("Registering custom regulatory)\n"));
-	wdev->wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;
-	wiphy_apply_custom_regulatory(wdev->wiphy, &brcm_regdom);
-	/* Now we can register wiphy with cfg80211 module */
-	err = wiphy_register(wdev->wiphy);
-	if (unlikely(err < 0)) {
-		WL_ERR(("Couldn not register wiphy device (%d)\n", err));
-		wiphy_free(wdev->wiphy);
-	}
 	return err;
 }
 
-static void wl_free_wdev(struct wl_priv *wl)
+s32
+wl_cfg80211_set_ies(
+	struct net_device *dev,
+	struct cfg80211_beacon_data *info,
+	s32 bssidx)
 {
-	struct wireless_dev *wdev = wl->wdev;
-	struct wiphy *wiphy;
-	if (!wdev) {
-		WL_ERR(("wdev is invalid\n"));
-		return;
+	struct wl_priv *wl = wlcfg_drv_priv;
+	dhd_pub_t *dhd = (dhd_pub_t *)(wl->pub);
+	u8 *vndr = NULL;
+	u32 vndr_ie_len = 0;
+	s32 err = BCME_OK;
+
+	/* Set Beacon IEs to FW */
+	if ((err = wl_cfgp2p_set_management_ie(wl, dev, bssidx,
+		VNDR_IE_BEACON_FLAG, (u8 *)info->tail,
+		info->tail_len)) < 0) {
+		WL_ERR(("Set Beacon IE Failed \n"));
+	} else {
+		WL_DBG(("Applied Vndr IEs for Beacon \n"));
 	}
-	wiphy = wdev->wiphy;
-	wiphy_unregister(wdev->wiphy);
-	wdev->wiphy->dev.parent = NULL;
 
-	wl_delete_all_netinfo(wl);
-	wiphy_free(wiphy);
-	/* PLEASE do NOT call any function after wiphy_free, the driver's private structure "wl",
-	 * which is the private part of wiphy, has been freed in wiphy_free !!!!!!!!!!!
-	 */
+	if (dhd->op_mode & DHD_FLAG_HOSTAP_MODE) {
+		/* SoftAP mode */
+		struct ieee80211_mgmt *mgmt;
+		mgmt = (struct ieee80211_mgmt *)info->probe_resp;
+		if (mgmt != NULL) {
+			vndr = (u8 *)&mgmt->u.probe_resp.variable;
+			vndr_ie_len = info->probe_resp_len -
+				offsetof(struct ieee80211_mgmt, u.probe_resp.variable);
+		}
+	} else {
+		/* Other mode */
+		vndr = (u8 *)info->proberesp_ies;
+		vndr_ie_len = info->proberesp_ies_len;
+	}
+
+	/* Set Probe Response IEs to FW */
+	if ((err = wl_cfgp2p_set_management_ie(wl, dev, bssidx,
+		VNDR_IE_PRBRSP_FLAG, vndr, vndr_ie_len)) < 0) {
+		WL_ERR(("Set Probe Resp IE Failed \n"));
+	} else {
+		WL_DBG(("Applied Vndr IEs for Probe Resp \n"));
+	}
+
+	return err;
 }
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0) */
 
-static s32 wl_inform_bss(struct wl_priv *wl)
+static s32 wl_cfg80211_hostapd_sec(
+	struct net_device *dev,
+	struct parsed_ies *ies,
+	s32 bssidx)
 {
-	struct wl_scan_results *bss_list;
-	struct wl_bss_info *bi = NULL;	/* must be initialized */
-	s32 err = 0;
-	s32 i;
+	bool update_bss = 0;
+	struct wl_priv *wl = wlcfg_drv_priv;
 
-	bss_list = wl->bss_list;
-	WL_DBG(("scanned AP count (%d)\n", bss_list->count));
-	bi = next_bss(bss_list, bi);
-	for_each_bss(bss_list, bi, i) {
-		err = wl_inform_single_bss(wl, bi);
-		if (unlikely(err))
-			break;
+
+	if (ies->wps_ie) {
+		if (wl->ap_info->wps_ie &&
+			memcmp(wl->ap_info->wps_ie, ies->wps_ie, ies->wps_ie_len)) {
+			WL_DBG((" WPS IE is changed\n"));
+			kfree(wl->ap_info->wps_ie);
+			wl->ap_info->wps_ie = kmemdup(ies->wps_ie, ies->wps_ie_len, GFP_KERNEL);
+		} else if (wl->ap_info->wps_ie == NULL) {
+			WL_DBG((" WPS IE is added\n"));
+			wl->ap_info->wps_ie = kmemdup(ies->wps_ie, ies->wps_ie_len, GFP_KERNEL);
+		}
+		if ((ies->wpa_ie != NULL || ies->wpa2_ie != NULL)) {
+			if (!wl->ap_info->security_mode) {
+				/* change from open mode to security mode */
+				update_bss = true;
+				if (ies->wpa_ie != NULL) {
+					wl->ap_info->wpa_ie = kmemdup(ies->wpa_ie,
+					ies->wpa_ie->length + WPA_RSN_IE_TAG_FIXED_LEN,
+					GFP_KERNEL);
+				} else {
+					wl->ap_info->rsn_ie = kmemdup(ies->wpa2_ie,
+					ies->wpa2_ie->len + WPA_RSN_IE_TAG_FIXED_LEN,
+					GFP_KERNEL);
+				}
+			} else if (wl->ap_info->wpa_ie) {
+				/* change from WPA2 mode to WPA mode */
+				if (ies->wpa_ie != NULL) {
+					update_bss = true;
+					kfree(wl->ap_info->rsn_ie);
+					wl->ap_info->rsn_ie = NULL;
+					wl->ap_info->wpa_ie = kmemdup(ies->wpa_ie,
+					ies->wpa_ie->length + WPA_RSN_IE_TAG_FIXED_LEN,
+					GFP_KERNEL);
+				} else if (memcmp(wl->ap_info->rsn_ie,
+					ies->wpa2_ie, ies->wpa2_ie->len
+					+ WPA_RSN_IE_TAG_FIXED_LEN)) {
+					update_bss = true;
+					kfree(wl->ap_info->rsn_ie);
+					wl->ap_info->rsn_ie = kmemdup(ies->wpa2_ie,
+					ies->wpa2_ie->len + WPA_RSN_IE_TAG_FIXED_LEN,
+					GFP_KERNEL);
+					wl->ap_info->wpa_ie = NULL;
+				}
+			}
+			if (update_bss) {
+				wl->ap_info->security_mode = true;
+				wl_cfgp2p_bss(wl, dev, bssidx, 0);
+				if (wl_validate_wpa2ie(dev, ies->wpa2_ie, bssidx)  < 0 ||
+					wl_validate_wpaie(dev, ies->wpa_ie, bssidx) < 0) {
+					return BCME_ERROR;
+				}
+				wl_cfgp2p_bss(wl, dev, bssidx, 1);
+			}
+		}
+	} else {
+		WL_ERR(("No WPSIE in beacon \n"));
 	}
-	return err;
+	return 0;
 }
 
-static s32 wl_inform_single_bss(struct wl_priv *wl, struct wl_bss_info *bi)
+#if defined(WL_SUPPORT_BACKPORTED_KPATCHES) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3, \
+	2, 0))
+static s32
+wl_cfg80211_del_station(
+	struct wiphy *wiphy,
+	struct net_device *ndev,
+	u8* mac_addr)
 {
-	struct wiphy *wiphy = wiphy_from_scan(wl);
-	struct ieee80211_mgmt *mgmt;
-	struct ieee80211_channel *channel;
-	struct ieee80211_supported_band *band;
-	struct wl_cfg80211_bss_info *notif_bss_info;
-	struct wl_scan_req *sr = wl_to_sr(wl);
-	struct beacon_proberesp *beacon_proberesp;
-	struct cfg80211_bss *cbss = NULL;
-	s32 mgmt_type;
-	s32 signal;
-	u32 freq;
-	s32 err = 0;
+	struct net_device *dev;
+	struct wl_priv *wl = wiphy_priv(wiphy);
+	scb_val_t scb_val;
+	s8 eabuf[ETHER_ADDR_STR_LEN];
+	int err;
+	char mac_buf[MAX_NUM_OF_ASSOCIATED_DEV *
+		sizeof(struct ether_addr) + sizeof(uint)] = {0};
+	struct maclist *assoc_maclist = (struct maclist *)mac_buf;
+	int num_associated = 0;
+
+	WL_DBG(("Entry\n"));
+	if (mac_addr == NULL) {
+		WL_DBG(("mac_addr is NULL ignore it\n"));
+		return 0;
+	}
 
-	if (unlikely(dtoh32(bi->length) > WL_BSS_INFO_MAX)) {
-		WL_DBG(("Beacon is larger than buffer. Discarding\n"));
-		return err;
+	if (ndev == wl->p2p_net) {
+		dev = wl_to_prmry_ndev(wl);
+	} else {
+		dev = ndev;
 	}
-	notif_bss_info = kzalloc(sizeof(*notif_bss_info) + sizeof(*mgmt)
-		- sizeof(u8) + WL_BSS_INFO_MAX, GFP_KERNEL);
-	if (unlikely(!notif_bss_info)) {
-		WL_ERR(("notif_bss_info alloc failed\n"));
-		return -ENOMEM;
+
+	if (p2p_is_on(wl)) {
+		/* Suspend P2P discovery search-listen to prevent it from changing the
+		 * channel.
+		 */
+		if ((wl_cfgp2p_discover_enable_search(wl, false)) < 0) {
+			WL_ERR(("Can not disable discovery mode\n"));
+			return -EFAULT;
+		}
 	}
-	mgmt = (struct ieee80211_mgmt *)notif_bss_info->frame_buf;
-	notif_bss_info->channel =
-		bi->ctl_ch ? bi->ctl_ch : CHSPEC_CHANNEL(wl_chspec_driver_to_host(bi->chanspec));
 
-	if (notif_bss_info->channel <= CH_MAX_2G_CHANNEL)
-		band = wiphy->bands[IEEE80211_BAND_2GHZ];
+	assoc_maclist->count = MAX_NUM_OF_ASSOCIATED_DEV;
+	err = wldev_ioctl(ndev, WLC_GET_ASSOCLIST,
+		assoc_maclist, sizeof(mac_buf), false);
+	if (err < 0)
+		WL_ERR(("WLC_GET_ASSOCLIST error %d\n", err));
 	else
-		band = wiphy->bands[IEEE80211_BAND_5GHZ];
-	if (!band) {
-		WL_ERR(("No valid band"));
-		kfree(notif_bss_info);
-		return -EINVAL;
+		num_associated = assoc_maclist->count;
+
+	memcpy(scb_val.ea.octet, mac_addr, ETHER_ADDR_LEN);
+	scb_val.val = DOT11_RC_DEAUTH_LEAVING;
+	err = wldev_ioctl(dev, WLC_SCB_DEAUTHENTICATE_FOR_REASON, &scb_val,
+		sizeof(scb_val_t), true);
+	if (err < 0)
+		WL_ERR(("WLC_SCB_DEAUTHENTICATE_FOR_REASON err %d\n", err));
+	WL_ERR(("Disconnect STA : %s scb_val.val %d\n",
+		bcm_ether_ntoa((const struct ether_addr *)mac_addr, eabuf),
+		scb_val.val));
+	if (num_associated)
+		wl_delay(400);
+	return 0;
+}
+#endif /* WL_SUPPORT_BACKPORTED_KPATCHES || KERNEL_VER >= KERNEL_VERSION(3, 2, 0)) */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+static s32
+wl_cfg80211_start_ap(
+	struct wiphy *wiphy,
+	struct net_device *dev,
+	struct cfg80211_ap_settings *info)
+{
+	struct wl_priv *wl = wiphy_priv(wiphy);
+	s32 err = BCME_OK;
+	struct parsed_ies ies;
+	s32 bssidx = 0;
+	u32 dev_role = 0;
+
+	WL_DBG(("Enter \n"));
+	if (dev == wl_to_prmry_ndev(wl)) {
+		WL_DBG(("Start AP req on primary iface: Softap\n"));
+		dev_role = NL80211_IFTYPE_AP;
+	} else if (dev == wl->p2p_net) {
+		/* Group Add request on p2p0 */
+		WL_DBG(("Start AP req on P2P iface: GO\n"));
+		dev = wl_to_prmry_ndev(wl);
+		dev_role = NL80211_IFTYPE_P2P_GO;
 	}
-	notif_bss_info->rssi = dtoh16(bi->RSSI);
-	memcpy(mgmt->bssid, &bi->BSSID, ETHER_ADDR_LEN);
-	mgmt_type = wl->active_scan ?
-		IEEE80211_STYPE_PROBE_RESP : IEEE80211_STYPE_BEACON;
-	if (!memcmp(bi->SSID, sr->ssid.SSID, bi->SSID_len)) {
-	    mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT | mgmt_type);
+	if (wl_cfgp2p_find_idx(wl, dev, &bssidx) != BCME_OK) {
+		WL_ERR(("Find p2p index from dev(%p) failed\n", dev));
+		return BCME_ERROR;
+	}
+	if (p2p_is_on(wl) &&
+		(bssidx == wl_to_p2p_bss_bssidx(wl,
+		P2PAPI_BSSCFG_CONNECTION))) {
+		dev_role = NL80211_IFTYPE_P2P_GO;
+		WL_DBG(("Start AP req on P2P connection iface\n"));
 	}
-	beacon_proberesp = wl->active_scan ?
-		(struct beacon_proberesp *)&mgmt->u.probe_resp :
-		(struct beacon_proberesp *)&mgmt->u.beacon;
-	beacon_proberesp->timestamp = 0;
-	beacon_proberesp->beacon_int = cpu_to_le16(bi->beacon_period);
-	beacon_proberesp->capab_info = cpu_to_le16(bi->capability);
-	wl_rst_ie(wl);
 
-	wl_mrg_ie(wl, ((u8 *) bi) + bi->ie_offset, bi->ie_length);
-	wl_cp_ie(wl, beacon_proberesp->variable, WL_BSS_INFO_MAX -
-		offsetof(struct wl_cfg80211_bss_info, frame_buf));
-	notif_bss_info->frame_len = offsetof(struct ieee80211_mgmt,
-		u.beacon.variable) + wl_get_ielen(wl);
-#if LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 38) && !defined(WL_COMPAT_WIRELESS)
-	freq = ieee80211_channel_to_frequency(notif_bss_info->channel);
-	(void)band->band;
-#else
-	freq = ieee80211_channel_to_frequency(notif_bss_info->channel, band->band);
-#endif
-	channel = ieee80211_get_channel(wiphy, freq);
+	if ((err = wl_cfg80211_bcn_set_params(info, dev,
+		dev_role, bssidx)) < 0) {
+		WL_ERR(("Beacon params set failed \n"));
+		goto fail;
+	}
 
-	WL_DBG(("SSID : \"%s\", rssi %d, channel %d, capability : 0x04%x, bssid %pM"
-			"mgmt_type %d frame_len %d\n", bi->SSID,
-			notif_bss_info->rssi, notif_bss_info->channel,
-			mgmt->u.beacon.capab_info, &bi->BSSID, mgmt_type,
-			notif_bss_info->frame_len));
+	/* Parse IEs */
+	if ((err = wl_cfg80211_parse_ap_ies(dev, &info->beacon, &ies) < 0)) {
+		WL_ERR(("Set IEs failed \n"));
+		goto fail;
+	}
 
-	signal = notif_bss_info->rssi * 100;
+	/* Set IEs to FW */
+	if ((err = wl_cfg80211_set_ies(dev, &info->beacon, bssidx) < 0))
+		WL_ERR(("Set IEs failed \n"));
 
-#if defined(WLP2P) && defined(WL_ENABLE_P2P_IF)
-	if (wl->p2p_net && wl->scan_request &&
-		((wl->scan_request->dev == wl->p2p_net) ||
-		(wl->scan_request->dev == wl_to_p2p_bss_ndev(wl, P2PAPI_BSSCFG_CONNECTION)))) {
-#else
-	if (p2p_is_on(wl) && (p2p_scan(wl) ||
-		(wl->scan_request->dev == wl_to_p2p_bss_ndev(wl, P2PAPI_BSSCFG_CONNECTION)))) {
-#endif
-		/* find the P2PIE, if we do not find it, we will discard this frame */
-		wifi_p2p_ie_t * p2p_ie;
-		if ((p2p_ie = wl_cfgp2p_find_p2pie((u8 *)beacon_proberesp->variable,
-			wl_get_ielen(wl))) == NULL) {
-			WL_ERR(("Couldn't find P2PIE in probe response/beacon\n"));
-			kfree(notif_bss_info);
-			return err;
-		}
+	if ((wl_cfg80211_bcn_validate_sec(dev, &ies,
+		dev_role, bssidx)) < 0)
+	{
+		WL_ERR(("Beacon set security failed \n"));
+		goto fail;
 	}
 
-	cbss = cfg80211_inform_bss_frame(wiphy, channel, mgmt,
-		le16_to_cpu(notif_bss_info->frame_len), signal, GFP_KERNEL);
-	if (unlikely(!cbss)) {
-		WL_ERR(("cfg80211_inform_bss_frame error\n"));
-		kfree(notif_bss_info);
-		return -EINVAL;
+	if ((err = wl_cfg80211_bcn_bringup_ap(dev, &ies,
+		dev_role, bssidx)) < 0) {
+		WL_ERR(("Beacon bring up AP/GO failed \n"));
+		goto fail;
 	}
 
-	cfg80211_put_bss(cbss);
-	kfree(notif_bss_info);
+	WL_DBG(("** AP/GO Created **\n"));
+
+#if 0
+	/* Set IEs to FW */
+	if ((err = wl_cfg80211_set_ies(dev, &info->beacon, bssidx) < 0))
+		WL_ERR(("Set IEs failed \n"));
+#endif
+fail:
+	if (err) {
+		WL_ERR(("ADD/SET beacon failed\n"));
+		wldev_iovar_setint(dev, "mpc", 1);
+	}
 
 	return err;
 }
 
-static bool wl_is_linkup(struct wl_priv *wl, const wl_event_msg_t *e, struct net_device *ndev)
+static s32
+wl_cfg80211_stop_ap(
+	struct wiphy *wiphy,
+	struct net_device *dev)
 {
-	u32 event = ntoh32(e->event_type);
-	u32 status =  ntoh32(e->status);
-	u16 flags = ntoh16(e->flags);
+	int err = 0;
+	u32 dev_role = 0;
+	int infra = 0;
+	int ap = 0;
+	s32 bssidx = 0;
+	struct wl_priv *wl = wiphy_priv(wiphy);
 
-	WL_DBG(("event %d, status %d flags %x\n", event, status, flags));
-	if (event == WLC_E_SET_SSID) {
-		if (status == WLC_E_STATUS_SUCCESS) {
-			if (!wl_is_ibssmode(wl, ndev))
-				return true;
-		}
-	} else if (event == WLC_E_LINK) {
-		if (flags & WLC_EVENT_MSG_LINK)
-			return true;
-	}
+	WL_DBG(("Enter \n"));
+	if (dev == wl_to_prmry_ndev(wl)) {
+		dev_role = NL80211_IFTYPE_AP;
+	} else if (dev == wl->p2p_net) {
+		/* Group Add request on p2p0 */
+		dev = wl_to_prmry_ndev(wl);
+		dev_role = NL80211_IFTYPE_P2P_GO;
+	}
+	if (wl_cfgp2p_find_idx(wl, dev, &bssidx) != BCME_OK) {
+		WL_ERR(("Find p2p index from dev(%p) failed\n", dev));
+		return BCME_ERROR;
+	}
+	if (p2p_is_on(wl) &&
+		(bssidx == wl_to_p2p_bss_bssidx(wl,
+		P2PAPI_BSSCFG_CONNECTION))) {
+		dev_role = NL80211_IFTYPE_P2P_GO;
+	}
 
-	WL_DBG(("wl_is_linkup false\n"));
-	return false;
-}
+	if (dev_role == NL80211_IFTYPE_AP) {
+		/* SoftAp on primary Interface.
+		 * Shut down AP and turn on MPC
+		 */
+		if ((err = wldev_ioctl(dev, WLC_SET_AP, &ap, sizeof(s32), true)) < 0) {
+			WL_ERR(("setting AP mode failed %d \n", err));
+			err = -ENOTSUPP;
+			goto exit;
+		}
+		err = wldev_ioctl(dev, WLC_SET_INFRA, &infra, sizeof(s32), true);
+		if (err < 0) {
+			WL_ERR(("SET INFRA error %d\n", err));
+			err = -ENOTSUPP;
+			goto exit;
+		}
 
-static bool wl_is_linkdown(struct wl_priv *wl, const wl_event_msg_t *e)
-{
-	u32 event = ntoh32(e->event_type);
-	u16 flags = ntoh16(e->flags);
+		err = wldev_ioctl(dev, WLC_UP, &ap, sizeof(s32), true);
+		if (unlikely(err)) {
+			WL_ERR(("WLC_UP error (%d)\n", err));
+			err = -EINVAL;
+			goto exit;
+		}
 
-	if (event == WLC_E_DEAUTH_IND ||
-	event == WLC_E_DISASSOC_IND ||
-	event == WLC_E_DISASSOC ||
-	event == WLC_E_DEAUTH) {
-		return true;
-	} else if (event == WLC_E_LINK) {
-		if (!(flags & WLC_EVENT_MSG_LINK))
-			return true;
+		wl_clr_drv_status(wl, AP_CREATED, dev);
+		/* Turn on the MPC */
+		wldev_iovar_setint(dev, "mpc", 1);
+	} else {
+		WL_DBG(("Stopping P2P GO \n"));
 	}
 
-	return false;
+exit:
+	return err;
 }
 
-static bool wl_is_nonetwork(struct wl_priv *wl, const wl_event_msg_t *e)
+static s32
+wl_cfg80211_change_beacon(
+	struct wiphy *wiphy,
+	struct net_device *dev,
+	struct cfg80211_beacon_data *info)
 {
-	u32 event = ntoh32(e->event_type);
-	u32 status = ntoh32(e->status);
+	s32 err = BCME_OK;
+	struct wl_priv *wl = wiphy_priv(wiphy);
+	struct parsed_ies ies;
+	u32 dev_role = 0;
+	s32 bssidx = 0;
 
-	if (event == WLC_E_LINK && status == WLC_E_STATUS_NO_NETWORKS)
-		return true;
-	if (event == WLC_E_SET_SSID && status != WLC_E_STATUS_SUCCESS)
-		return true;
+	WL_DBG(("Enter \n"));
 
-	return false;
-}
+	if (dev == wl_to_prmry_ndev(wl)) {
+		dev_role = NL80211_IFTYPE_AP;
+	} else if (dev == wl->p2p_net) {
+		/* Group Add request on p2p0 */
+		dev = wl_to_prmry_ndev(wl);
+		dev_role = NL80211_IFTYPE_P2P_GO;
+	}
+	if (wl_cfgp2p_find_idx(wl, dev, &bssidx) != BCME_OK) {
+		WL_ERR(("Find p2p index from dev(%p) failed\n", dev));
+		return BCME_ERROR;
+	}
+	if (p2p_is_on(wl) &&
+		(bssidx == wl_to_p2p_bss_bssidx(wl,
+		P2PAPI_BSSCFG_CONNECTION))) {
+		dev_role = NL80211_IFTYPE_P2P_GO;
+	}
 
-/* The mainline kernel >= 3.2.0 has support for indicating new/del station
- * to AP/P2P GO via events. If this change is backported to kernel for which
- * this driver is being built, then define WL_CFG80211_STA_EVENT. You
- * should use this new/del sta event mechanism for BRCM supplicant >= 22.
- */
+	/* Parse IEs */
+	if ((err = wl_cfg80211_parse_ap_ies(dev, info, &ies) < 0)) {
+		WL_ERR(("Parse IEs failed \n"));
+		goto fail;
+	}
+
+	/* Set IEs to FW */
+	if ((err = wl_cfg80211_set_ies(dev, info, bssidx) < 0)) {
+		WL_ERR(("Set IEs failed \n"));
+		goto fail;
+	}
+
+	if (dev_role == NL80211_IFTYPE_AP) {
+		if (wl_cfg80211_hostapd_sec(dev, &ies, bssidx) < 0) {
+			WL_ERR(("Hostapd update sec failed \n"));
+			err = -EINVAL;
+			goto fail;
+		}
+	}
+
+fail:
+	return err;
+}
+#else /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0) */
 static s32
-wl_notify_connect_status_ap(struct wl_priv *wl, struct net_device *ndev,
-	const wl_event_msg_t *e, void *data)
+wl_cfg80211_add_set_beacon(struct wiphy *wiphy, struct net_device *dev,
+	struct beacon_parameters *info)
 {
-	s32 err = 0;
-	u32 event = ntoh32(e->event_type);
-	u32 reason = ntoh32(e->reason);
-	u32 len = ntoh32(e->datalen);
+	s32 err = BCME_OK;
+	struct wl_priv *wl = wiphy_priv(wiphy);
+	s32 ie_offset = 0;
+	s32 bssidx = 0;
+	u32 dev_role = NL80211_IFTYPE_AP;
+	struct parsed_ies ies;
+	bcm_tlv_t *ssid_ie;
+	bool pbc = 0;
+	WL_DBG(("interval (%d) dtim_period (%d) head_len (%d) tail_len (%d)\n",
+		info->interval, info->dtim_period, info->head_len, info->tail_len));
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0)) && !defined(WL_CFG80211_STA_EVENT)
-	bool isfree = false;
-	u8 *mgmt_frame;
-	u8 bsscfgidx = e->bsscfgidx;
-	s32 freq;
-	s32 channel;
-	u8 body[WL_FRAME_LEN];
-	u16 fc = 0;
+	if (dev == wl_to_prmry_ndev(wl)) {
+		dev_role = NL80211_IFTYPE_AP;
+	} else if (dev == wl->p2p_net) {
+		/* Group Add request on p2p0 */
+		dev = wl_to_prmry_ndev(wl);
+		dev_role = NL80211_IFTYPE_P2P_GO;
+	}
+	if (wl_cfgp2p_find_idx(wl, dev, &bssidx) != BCME_OK) {
+		WL_ERR(("Find p2p index from dev(%p) failed\n", dev));
+		return BCME_ERROR;
+	}
+	if (p2p_is_on(wl) &&
+		(bssidx == wl_to_p2p_bss_bssidx(wl,
+		P2PAPI_BSSCFG_CONNECTION))) {
+		dev_role = NL80211_IFTYPE_P2P_GO;
+	}
+
+	ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;
+	/* find the SSID */
+	if ((ssid_ie = bcm_parse_tlvs((u8 *)&info->head[ie_offset],
+		info->head_len - ie_offset,
+		DOT11_MNG_SSID_ID)) != NULL) {
+		if (dev_role == NL80211_IFTYPE_AP) {
+			/* Store the hostapd SSID */
+			memset(&wl->hostapd_ssid.SSID[0], 0x00, 32);
+			memcpy(&wl->hostapd_ssid.SSID[0], ssid_ie->data, ssid_ie->len);
+			wl->hostapd_ssid.SSID_len = ssid_ie->len;
+		} else {
+				/* P2P GO */
+			memset(&wl->p2p->ssid.SSID[0], 0x00, 32);
+			memcpy(wl->p2p->ssid.SSID, ssid_ie->data, ssid_ie->len);
+			wl->p2p->ssid.SSID_len = ssid_ie->len;
+		}
+	}
 
-	struct ieee80211_supported_band *band;
-	struct ether_addr da;
-	struct ether_addr bssid;
-	struct wiphy *wiphy = wl_to_wiphy(wl);
-	channel_info_t ci;
-#else
-	struct station_info sinfo;
-#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0)) && !WL_CFG80211_STA_EVENT */
+	if (wl_cfg80211_parse_ies((u8 *)info->tail,
+		info->tail_len, &ies) < 0) {
+		WL_ERR(("Beacon get IEs failed \n"));
+		err = -EINVAL;
+		goto fail;
+	}
 
+	if (wl_cfgp2p_set_management_ie(wl, dev, bssidx,
+		VNDR_IE_BEACON_FLAG, (u8 *)info->tail,
+		info->tail_len) < 0) {
+		WL_ERR(("Beacon set IEs failed \n"));
+		goto fail;
+	} else {
+		WL_DBG(("Applied Vndr IEs for Beacon \n"));
+	}
+	if (!wl_cfgp2p_bss_isup(dev, bssidx) &&
+		(wl_cfg80211_bcn_validate_sec(dev, &ies, dev_role, bssidx) < 0))
+	{
+		WL_ERR(("Beacon set security failed \n"));
+		goto fail;
+	}
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0)) && !defined(WL_CFG80211_STA_EVENT)
-	memset(body, 0, sizeof(body));
-	memset(&bssid, 0, ETHER_ADDR_LEN);
-	WL_DBG(("Enter event %d ndev %p\n", event, ndev));
-	if (wl_get_mode_by_netdev(wl, ndev) == WL_INVALID)
-		return WL_INVALID;
+	/* Set BI and DTIM period */
+	if (info->interval) {
+		if ((err = wldev_ioctl(dev, WLC_SET_BCNPRD,
+			&info->interval, sizeof(s32), true)) < 0) {
+			WL_ERR(("Beacon Interval Set Error, %d\n", err));
+			return err;
+		}
+	}
+	if (info->dtim_period) {
+		if ((err = wldev_ioctl(dev, WLC_SET_DTIMPRD,
+			&info->dtim_period, sizeof(s32), true)) < 0) {
+			WL_ERR(("DTIM Interval Set Error, %d\n", err));
+			return err;
+		}
+	}
 
-	if (len > WL_FRAME_LEN) {
-		WL_ERR(("Received frame length %d from dongle is greater than"
-			" allocated body buffer len %d", len, WL_FRAME_LEN));
-		goto exit;
+	if (wl_cfg80211_bcn_bringup_ap(dev, &ies, dev_role, bssidx) < 0) {
+		WL_ERR(("Beacon bring up AP/GO failed \n"));
+		goto fail;
 	}
-	memcpy(body, data, len);
-	wldev_iovar_getbuf_bsscfg(ndev, "cur_etheraddr",
-		NULL, 0, wl->ioctl_buf, WLC_IOCTL_MAXLEN, bsscfgidx, &wl->ioctl_buf_sync);
-	memcpy(da.octet, wl->ioctl_buf, ETHER_ADDR_LEN);
-	err = wldev_ioctl(ndev, WLC_GET_BSSID, &bssid, ETHER_ADDR_LEN, false);
-	switch (event) {
-		case WLC_E_ASSOC_IND:
-			fc = FC_ASSOC_REQ;
-			break;
-		case WLC_E_REASSOC_IND:
-			fc = FC_REASSOC_REQ;
-			break;
-		case WLC_E_DISASSOC_IND:
-			fc = FC_DISASSOC;
-			break;
-		case WLC_E_DEAUTH_IND:
-			fc = FC_DISASSOC;
-			break;
-		case WLC_E_DEAUTH:
-			fc = FC_DISASSOC;
-			break;
-		default:
-			fc = 0;
-			goto exit;
+
+	if (wl_get_drv_status(wl, AP_CREATED, dev)) {
+		/* Soft AP already running. Update changed params */
+		if (wl_cfg80211_hostapd_sec(dev, &ies, bssidx) < 0) {
+			WL_ERR(("Hostapd update sec failed \n"));
+			err = -EINVAL;
+			goto fail;
+		}
 	}
-	if ((err = wldev_ioctl(ndev, WLC_GET_CHANNEL, &ci, sizeof(ci), false)))
-		return err;
 
-	channel = dtoh32(ci.hw_channel);
-	if (channel <= CH_MAX_2G_CHANNEL)
-		band = wiphy->bands[IEEE80211_BAND_2GHZ];
-	else
-		band = wiphy->bands[IEEE80211_BAND_5GHZ];
-	if (!band) {
-		WL_ERR(("No valid band"));
+	/* Enable Probe Req filter */
+	if (((dev_role == NL80211_IFTYPE_P2P_GO) ||
+		(dev_role == NL80211_IFTYPE_AP)) && (ies.wps_ie != NULL)) {
+		wl_validate_wps_ie((char *) ies.wps_ie, ies.wps_ie_len, &pbc);
+		if (pbc)
+			wl_add_remove_eventmsg(dev, WLC_E_PROBREQ_MSG, true);
+	}
+
+	WL_DBG(("** ADD/SET beacon done **\n"));
+
+fail:
+	if (err) {
+		WL_ERR(("ADD/SET beacon failed\n"));
+		wldev_iovar_setint(dev, "mpc", 1);
+	}
+	return err;
+
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0) */
+
+#ifdef WL_SCHED_SCAN
+#define PNO_TIME		30
+#define PNO_REPEAT		4
+#define PNO_FREQ_EXPO_MAX	2
+int wl_cfg80211_sched_scan_start(struct wiphy *wiphy,
+                             struct net_device *dev,
+                             struct cfg80211_sched_scan_request *request)
+{
+	ushort pno_time = PNO_TIME;
+	int pno_repeat = PNO_REPEAT;
+	int pno_freq_expo_max = PNO_FREQ_EXPO_MAX;
+	wlc_ssid_t ssids_local[MAX_PFN_LIST_COUNT];
+	struct wl_priv *wl = wiphy_priv(wiphy);
+	struct cfg80211_ssid *ssid = NULL;
+	int ssid_count = 0;
+	int i;
+	int ret = 0;
+
+	WL_DBG(("Enter \n"));
+	WL_PNO((">>> SCHED SCAN START\n"));
+	WL_PNO(("Enter n_match_sets:%d   n_ssids:%d \n",
+		request->n_match_sets, request->n_ssids));
+	WL_PNO(("ssids:%d pno_time:%d pno_repeat:%d pno_freq:%d \n",
+		request->n_ssids, pno_time, pno_repeat, pno_freq_expo_max));
+
+
+	if (!request || !request->n_ssids || !request->n_match_sets) {
+		WL_ERR(("Invalid sched scan req!! n_ssids:%d \n", request->n_ssids));
 		return -EINVAL;
 	}
-#if LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 38) && !defined(WL_COMPAT_WIRELESS)
-	freq = ieee80211_channel_to_frequency(channel);
-	(void)band->band;
-#else
-	freq = ieee80211_channel_to_frequency(channel, band->band);
-#endif
 
-	err = wl_frame_get_mgmt(fc, &da, &e->addr, &bssid,
-		&mgmt_frame, &len, body);
-	if (err < 0)
-		goto exit;
-	isfree = true;
+	memset(&ssids_local, 0, sizeof(ssids_local));
 
-	if (event == WLC_E_ASSOC_IND && reason == DOT11_SC_SUCCESS) {
-		cfg80211_rx_mgmt(ndev, freq, 0, mgmt_frame, len, GFP_ATOMIC);
-	} else if (event == WLC_E_DISASSOC_IND) {
-		cfg80211_rx_mgmt(ndev, freq, 0, mgmt_frame, len, GFP_ATOMIC);
-	} else if ((event == WLC_E_DEAUTH_IND) || (event == WLC_E_DEAUTH)) {
-		cfg80211_rx_mgmt(ndev, freq, 0, mgmt_frame, len, GFP_ATOMIC);
+	if (request->n_match_sets > 0) {
+		for (i = 0; i < request->n_match_sets; i++) {
+			ssid = &request->match_sets[i].ssid;
+			memcpy(ssids_local[i].SSID, ssid->ssid, ssid->ssid_len);
+			ssids_local[i].SSID_len = ssid->ssid_len;
+			WL_PNO((">>> PNO filter set for ssid (%s) \n", ssid->ssid));
+			ssid_count++;
+		}
 	}
 
-exit:
-	if (isfree)
-		kfree(mgmt_frame);
-	return err;
-#else /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0) && !WL_CFG80211_STA_EVENT */
-	sinfo.filled = 0;
-	if (((event == WLC_E_ASSOC_IND) || (event == WLC_E_REASSOC_IND)) &&
-		reason == DOT11_SC_SUCCESS) {
-		sinfo.filled = STATION_INFO_ASSOC_REQ_IES;
-		if (!data) {
-			WL_ERR(("No IEs present in ASSOC/REASSOC_IND"));
+	if (request->n_ssids > 0) {
+		for (i = 0; i < request->n_ssids; i++) {
+			/* Active scan req for ssids */
+			WL_PNO((">>> Active scan req for ssid (%s) \n", request->ssids[i].ssid));
+
+			/* match_set ssids is a supert set of n_ssid list, so we need
+			 * not add these set seperately
+			 */
+		}
+	}
+
+	if (ssid_count) {
+		if ((ret = dhd_dev_pno_set(dev, ssids_local, request->n_match_sets,
+			pno_time, pno_repeat, pno_freq_expo_max)) < 0) {
+			WL_ERR(("PNO setup failed!! ret=%d \n", ret));
 			return -EINVAL;
 		}
-		sinfo.assoc_req_ies = data;
-		sinfo.assoc_req_ies_len = len;
-		cfg80211_new_sta(ndev, e->addr.octet, &sinfo, GFP_ATOMIC);
-	} else if (event == WLC_E_DISASSOC_IND) {
-		cfg80211_del_sta(ndev, e->addr.octet, GFP_ATOMIC);
-	} else if ((event == WLC_E_DEAUTH_IND) || (event == WLC_E_DEAUTH)) {
-		cfg80211_del_sta(ndev, e->addr.octet, GFP_ATOMIC);
+
+		/* Enable the PNO */
+		if (dhd_dev_pno_enable(dev, 1) < 0) {
+			WL_ERR(("PNO enable failed!! ret=%d \n", ret));
+			return -EINVAL;
+		}
+		wl->sched_scan_req = request;
+	} else {
+		return -EINVAL;
 	}
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0) && !WL_CFG80211_STA_EVENT */
-	return err;
+
+	return 0;
 }
 
-static s32
-wl_notify_connect_status(struct wl_priv *wl, struct net_device *ndev,
-	const wl_event_msg_t *e, void *data)
+int wl_cfg80211_sched_scan_stop(struct wiphy *wiphy, struct net_device *dev)
 {
-	bool act;
-	s32 err = 0;
-	u32 event = ntoh32(e->event_type);
+	struct wl_priv *wl = wiphy_priv(wiphy);
 
-	if (wl_get_mode_by_netdev(wl, ndev) == WL_MODE_AP) {
-		wl_notify_connect_status_ap(wl, ndev, e, data);
-	} else {
-		WL_DBG(("wl_notify_connect_status : event %d status : %d ndev %p\n",
-			ntoh32(e->event_type), ntoh32(e->status), ndev));
-		if (wl_is_linkup(wl, e, ndev)) {
-			wl_link_up(wl);
-			act = true;
-			wl_update_prof(wl, ndev, e, &act, WL_PROF_ACT);
-			wl_update_prof(wl, ndev, NULL, (void *)&e->addr, WL_PROF_BSSID);
-			if (wl_is_ibssmode(wl, ndev)) {
-				printk("cfg80211_ibss_joined\n");
-				cfg80211_ibss_joined(ndev, (s8 *)&e->addr,
-					GFP_KERNEL);
-				WL_DBG(("joined in IBSS network\n"));
-			} else {
-				if (!wl_get_drv_status(wl, DISCONNECTING, ndev)) {
-					printk("wl_bss_connect_done succeeded\n");
-					wl_bss_connect_done(wl, ndev, e, data, true);
-					WL_DBG(("joined in BSS network \"%s\"\n",
-					((struct wlc_ssid *)
-					 wl_read_prof(wl, ndev, WL_PROF_SSID))->SSID));
-				}
-			}
+	WL_DBG(("Enter \n"));
+	WL_PNO((">>> SCHED SCAN STOP\n"));
 
-		} else if (wl_is_linkdown(wl, e)) {
-			if (wl->scan_request) {
-				if (wl->escan_on) {
-					wl_notify_escan_complete(wl, ndev, true, true);
-				} else {
-					del_timer_sync(&wl->scan_timeout);
-					wl_iscan_aborted(wl);
-				}
-			}
-			if (wl_get_drv_status(wl, CONNECTED, ndev)) {
-				scb_val_t scbval;
-				u8 *curbssid = wl_read_prof(wl, ndev, WL_PROF_BSSID);
-				printk("link down, call cfg80211_disconnected\n");
-				wl_clr_drv_status(wl, CONNECTED, ndev);
-				if (! wl_get_drv_status(wl, DISCONNECTING, ndev)) {
-					/* To make sure disconnect, explictly send dissassoc
-					*  for BSSID 00:00:00:00:00:00 issue
-					*/
-					scbval.val = WLAN_REASON_DEAUTH_LEAVING;
+	if (dhd_dev_pno_enable(dev, 0) < 0)
+		WL_ERR(("PNO disable failed"));
 
-					memcpy(&scbval.ea, curbssid, ETHER_ADDR_LEN);
-					scbval.val = htod32(scbval.val);
-					wldev_ioctl(ndev, WLC_DISASSOC, &scbval,
-						sizeof(scb_val_t), true);
-					cfg80211_disconnected(ndev, 0, NULL, 0, GFP_KERNEL);
-					wl_link_down(wl);
-					wl_init_prof(wl, ndev);
-				}
-			}
-			else if (wl_get_drv_status(wl, CONNECTING, ndev)) {
-				printk("link down, during connecting\n");
-				wl_bss_connect_done(wl, ndev, e, data, false);
-			}
-			wl_clr_drv_status(wl, DISCONNECTING, ndev);
+	if (dhd_dev_pno_reset(dev) < 0)
+		WL_ERR(("PNO reset failed"));
 
-		} else if (wl_is_nonetwork(wl, e)) {
-			printk("connect failed event=%d e->status 0x%x\n",
-				event, (int)ntoh32(e->status));
-			/* Clean up any pending scan request */
-			if (wl->scan_request) {
-				if (wl->escan_on) {
-					wl_notify_escan_complete(wl, ndev, true, true);
-				} else {
-					del_timer_sync(&wl->scan_timeout);
-					wl_iscan_aborted(wl);
-				}
-			}
-			if (wl_get_drv_status(wl, CONNECTING, ndev))
-				wl_bss_connect_done(wl, ndev, e, data, false);
-		} else {
-			printk("%s nothing\n", __FUNCTION__);
-		}
+	if (wl->scan_request && wl->sched_scan_running) {
+		WL_PNO((">>> Sched scan running. Aborting it..\n"));
+		wl_notify_escan_complete(wl, dev, true, true);
 	}
-	return err;
-}
 
-static s32
-wl_notify_roaming_status(struct wl_priv *wl, struct net_device *ndev,
-	const wl_event_msg_t *e, void *data)
-{
-	bool act;
-	s32 err = 0;
-	u32 event = be32_to_cpu(e->event_type);
-	u32 status = be32_to_cpu(e->status);
-	WL_DBG(("Enter \n"));
-	if (event == WLC_E_ROAM && status == WLC_E_STATUS_SUCCESS) {
-		if (wl_get_drv_status(wl, CONNECTED, ndev))
-			wl_bss_roaming_done(wl, ndev, e, data);
-		else
-			wl_bss_connect_done(wl, ndev, e, data, true);
-		act = true;
-		wl_update_prof(wl, ndev, e, &act, WL_PROF_ACT);
-		wl_update_prof(wl, ndev, NULL, (void *)&e->addr, WL_PROF_BSSID);
-	}
-	return err;
+	 wl->sched_scan_req = NULL;
+	 wl->sched_scan_running = FALSE;
+
+	return 0;
 }
+#endif /* WL_SCHED_SCAN */
 
-static s32 wl_get_assoc_ies(struct wl_priv *wl, struct net_device *ndev)
+static struct cfg80211_ops wl_cfg80211_ops = {
+	.add_virtual_intf = wl_cfg80211_add_virtual_iface,
+	.del_virtual_intf = wl_cfg80211_del_virtual_iface,
+	.change_virtual_intf = wl_cfg80211_change_virtual_iface,
+	.scan = wl_cfg80211_scan,
+	.set_wiphy_params = wl_cfg80211_set_wiphy_params,
+	.join_ibss = wl_cfg80211_join_ibss,
+	.leave_ibss = wl_cfg80211_leave_ibss,
+	.get_station = wl_cfg80211_get_station,
+	.set_tx_power = wl_cfg80211_set_tx_power,
+	.get_tx_power = wl_cfg80211_get_tx_power,
+	.add_key = wl_cfg80211_add_key,
+	.del_key = wl_cfg80211_del_key,
+	.get_key = wl_cfg80211_get_key,
+	.set_default_key = wl_cfg80211_config_default_key,
+	.set_default_mgmt_key = wl_cfg80211_config_default_mgmt_key,
+	.set_power_mgmt = wl_cfg80211_set_power_mgmt,
+	.connect = wl_cfg80211_connect,
+	.disconnect = wl_cfg80211_disconnect,
+	.suspend = wl_cfg80211_suspend,
+	.resume = wl_cfg80211_resume,
+	.set_pmksa = wl_cfg80211_set_pmksa,
+	.del_pmksa = wl_cfg80211_del_pmksa,
+	.flush_pmksa = wl_cfg80211_flush_pmksa,
+	.remain_on_channel = wl_cfg80211_remain_on_channel,
+	.cancel_remain_on_channel = wl_cfg80211_cancel_remain_on_channel,
+	.mgmt_tx = wl_cfg80211_mgmt_tx,
+	.mgmt_frame_register = wl_cfg80211_mgmt_frame_register,
+	.change_bss = wl_cfg80211_change_bss,
+	.set_channel = wl_cfg80211_set_channel,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)
+	.set_beacon = wl_cfg80211_add_set_beacon,
+	.add_beacon = wl_cfg80211_add_set_beacon,
+#else
+	.change_beacon = wl_cfg80211_change_beacon,
+	.start_ap = wl_cfg80211_start_ap,
+	.stop_ap = wl_cfg80211_stop_ap,
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0) */
+#ifdef WL_SCHED_SCAN
+	.sched_scan_start = wl_cfg80211_sched_scan_start,
+	.sched_scan_stop = wl_cfg80211_sched_scan_stop,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0) */
+#if defined(WL_SUPPORT_BACKPORTED_KPATCHES) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3, \
+	2, 0))
+	.del_station = wl_cfg80211_del_station,
+	.mgmt_tx_cancel_wait = wl_cfg80211_mgmt_tx_cancel_wait,
+#endif /* WL_SUPPORT_BACKPORTED_KPATCHES || KERNEL_VERSION >= (3,2,0) */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 2, 0)
+	.tdls_oper = wl_cfg80211_tdls_oper
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(3, 2, 0) */
+};
+
+s32 wl_mode_to_nl80211_iftype(s32 mode)
 {
-	wl_assoc_info_t assoc_info;
-	struct wl_connect_info *conn_info = wl_to_conn(wl);
 	s32 err = 0;
 
-	WL_DBG(("Enter \n"));
-	err = wldev_iovar_getbuf(ndev, "assoc_info", NULL, 0, wl->extra_buf,
-		WL_ASSOC_INFO_MAX, NULL);
-	if (unlikely(err)) {
-		WL_ERR(("could not get assoc info (%d)\n", err));
-		return err;
-	}
-	memcpy(&assoc_info, wl->extra_buf, sizeof(wl_assoc_info_t));
-	assoc_info.req_len = htod32(assoc_info.req_len);
-	assoc_info.resp_len = htod32(assoc_info.resp_len);
-	assoc_info.flags = htod32(assoc_info.flags);
-	if (conn_info->req_ie_len) {
-		conn_info->req_ie_len = 0;
-		bzero(conn_info->req_ie, sizeof(conn_info->req_ie));
-	}
-	if (conn_info->resp_ie_len) {
-		conn_info->resp_ie_len = 0;
-		bzero(conn_info->resp_ie, sizeof(conn_info->resp_ie));
-	}
-	if (assoc_info.req_len) {
-		err = wldev_iovar_getbuf(ndev, "assoc_req_ies", NULL, 0, wl->extra_buf,
-			WL_ASSOC_INFO_MAX, NULL);
-		if (unlikely(err)) {
-			WL_ERR(("could not get assoc req (%d)\n", err));
-			return err;
-		}
-		conn_info->req_ie_len = assoc_info.req_len - sizeof(struct dot11_assoc_req);
-		if (assoc_info.flags & WLC_ASSOC_REQ_IS_REASSOC) {
-			conn_info->req_ie_len -= ETHER_ADDR_LEN;
-		}
-		if (conn_info->req_ie_len <= MAX_REQ_LINE)
-			memcpy(conn_info->req_ie, wl->extra_buf, conn_info->req_ie_len);
-		else {
-			WL_ERR(("%s IE size %d above max %d size \n",
-				__FUNCTION__, conn_info->req_ie_len, MAX_REQ_LINE));
-			return err;
-		}
-	} else {
-		conn_info->req_ie_len = 0;
-	}
-	if (assoc_info.resp_len) {
-		err = wldev_iovar_getbuf(ndev, "assoc_resp_ies", NULL, 0, wl->extra_buf,
-			WL_ASSOC_INFO_MAX, NULL);
-		if (unlikely(err)) {
-			WL_ERR(("could not get assoc resp (%d)\n", err));
-			return err;
-		}
-		conn_info->resp_ie_len = assoc_info.resp_len -sizeof(struct dot11_assoc_resp);
-		if (conn_info->resp_ie_len <= MAX_REQ_LINE)
-			memcpy(conn_info->resp_ie, wl->extra_buf, conn_info->resp_ie_len);
-		else {
-			WL_ERR(("%s IE size %d above max %d size \n",
-				__FUNCTION__, conn_info->resp_ie_len, MAX_REQ_LINE));
-			return err;
-		}
-	} else {
-		conn_info->resp_ie_len = 0;
+	switch (mode) {
+	case WL_MODE_BSS:
+		return NL80211_IFTYPE_STATION;
+	case WL_MODE_IBSS:
+		return NL80211_IFTYPE_ADHOC;
+	case WL_MODE_AP:
+		return NL80211_IFTYPE_AP;
+	default:
+		return NL80211_IFTYPE_UNSPECIFIED;
 	}
-	WL_DBG(("req len (%d) resp len (%d)\n", conn_info->req_ie_len,
-		conn_info->resp_ie_len));
 
 	return err;
 }
 
-static void wl_ch_to_chanspec(int ch, struct wl_join_params *join_params,
-        size_t *join_params_size)
+/*  	Kernel Network Support->Wireless->Regulatory rules database
+	options should be enabled and regulatory  CRDA regdb table populated in Kernel
+	for proper country reg notification
+*/
+#ifdef CONFIG_CFG80211_INTERNAL_REGDB
+static int
+wl_cfg80211_reg_notifier(
+	struct wiphy *wiphy,
+	struct regulatory_request *request)
 {
-	chanspec_t chanspec = 0;
-
-	if (ch != 0) {
-		join_params->params.chanspec_num = 1;
-		join_params->params.chanspec_list[0] = ch;
-
-		if (join_params->params.chanspec_list[0] <= CH_MAX_2G_CHANNEL)
-			chanspec |= WL_CHANSPEC_BAND_2G;
-		else
-			chanspec |= WL_CHANSPEC_BAND_5G;
-
-		chanspec |= WL_CHANSPEC_BW_20;
-		chanspec |= WL_CHANSPEC_CTL_SB_NONE;
+	struct wl_priv *wl = (struct wl_priv *)wiphy_priv(wiphy);
+	int ret = 0;
 
-		*join_params_size += WL_ASSOC_PARAMS_FIXED_SIZE +
-			join_params->params.chanspec_num * sizeof(chanspec_t);
+	if (!request || !wl) {
+		WL_ERR(("Invalid arg\n"));
+		return -EINVAL;
+	}
 
-		join_params->params.chanspec_list[0]  &= WL_CHANSPEC_CHAN_MASK;
-		join_params->params.chanspec_list[0] |= chanspec;
-		join_params->params.chanspec_list[0] =
-			wl_chspec_host_to_driver(join_params->params.chanspec_list[0]);
+	WL_DBG(("ccode: %c%c Initiator: %d\n",
+		request->alpha2[0], request->alpha2[1], request->initiator));
 
-		join_params->params.chanspec_num =
-			htod32(join_params->params.chanspec_num);
+	/* We support only REGDOM_SET_BY_USER as of now */
+	if ((request->initiator != NL80211_REGDOM_SET_BY_USER) &&
+		(request->initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE)) {
+		WL_ERR(("reg_notifier for intiator:%d not supported : set default\n",
+			request->initiator));
+		/* in case of no supported country by regdb
+		     lets driver setup platform default Locale
+		*/
+	}
 
-		WL_DBG(("%s  join_params->params.chanspec_list[0]= %X\n",
-			__FUNCTION__, join_params->params.chanspec_list[0]));
+	WL_ERR(("Set country code %c%c from %s\n",
+		request->alpha2[0], request->alpha2[1],
+		((request->initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE) ? " 11d AP" : "User")));
+	/*
+	* fact : connect to phicomm 300M/302M that will set country to KR, wifi will auto disconnect.
+	* reason : when set country as KR, wifi only scan 5G but no 2.4G.Brcom will chang KR 
+	* to XY 3 in dhd_custom_gpio.c for some case, but now do not run it. See get_customized_country_code.
+	* So now if it's KR, keep last country code as new. 
+	*/
+	if((request->alpha2[0]== 'K')  && (request->alpha2[1] == 'R')) {
+		printk("sh skip set KP country code\n");
+		return 0;
+	}
 
+	if ((ret = wldev_set_country(wl_to_prmry_ndev(wl), request->alpha2,
+		false, (request->initiator == NL80211_REGDOM_SET_BY_USER ? true : false))) < 0) {
+		WL_ERR(("set country Failed :%d\n", ret));
 	}
+
+	return ret;
 }
+#endif /* CONFIG_CFG80211_INTERNAL_REGDB */
 
-static s32 wl_update_bss_info(struct wl_priv *wl, struct net_device *ndev)
+static s32 wl_setup_wiphy(struct wireless_dev *wdev, struct device *sdiofunc_dev, void *data)
 {
-	struct cfg80211_bss *bss;
-	struct wl_bss_info *bi;
-	struct wlc_ssid *ssid;
-	struct bcm_tlv *tim;
-	s32 beacon_interval;
-	s32 dtim_period;
-	size_t ie_len;
-	u8 *ie;
-	u8 *curbssid;
 	s32 err = 0;
-	struct wiphy *wiphy;
-
-	wiphy = wl_to_wiphy(wl);
-
-	if (wl_is_ibssmode(wl, ndev))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)) && \
+	(defined(WL_IFACE_COMB_NUM_CHANNELS) || defined(WL_CFG80211_P2P_DEV_IF))
+	dhd_pub_t *dhd = (dhd_pub_t *)data;
+#endif /* LINUX_VER >= 3.0 && (WL_IFACE_COMB_NUM_CHANNELS || WL_CFG80211_P2P_DEV_IF) */
+	wdev->wiphy =
+	    wiphy_new(&wl_cfg80211_ops, sizeof(struct wl_priv));
+	if (unlikely(!wdev->wiphy)) {
+		WL_ERR(("Couldn not allocate wiphy device\n"));
+		err = -ENOMEM;
 		return err;
+	}
+	set_wiphy_dev(wdev->wiphy, sdiofunc_dev);
+	wdev->wiphy->max_scan_ie_len = WL_SCAN_IE_LEN_MAX;
+	/* Report  how many SSIDs Driver can support per Scan request */
+	wdev->wiphy->max_scan_ssids = WL_SCAN_PARAMS_SSID_MAX;
+	wdev->wiphy->max_num_pmkids = WL_NUM_PMKIDS_MAX;
+#ifdef WL_SCHED_SCAN
+	wdev->wiphy->max_sched_scan_ssids = MAX_PFN_LIST_COUNT;
+	wdev->wiphy->max_match_sets = MAX_PFN_LIST_COUNT;
+	wdev->wiphy->max_sched_scan_ie_len = WL_SCAN_IE_LEN_MAX;
+	wdev->wiphy->flags |= WIPHY_FLAG_SUPPORTS_SCHED_SCAN;
+#endif /* WL_SCHED_SCAN */
+	wdev->wiphy->interface_modes =
+		BIT(NL80211_IFTYPE_STATION)
+		| BIT(NL80211_IFTYPE_ADHOC)
+#if !defined(WL_ENABLE_P2P_IF)
+		| BIT(NL80211_IFTYPE_MONITOR)
+#endif
 
-	ssid = (struct wlc_ssid *)wl_read_prof(wl, ndev, WL_PROF_SSID);
-	curbssid = wl_read_prof(wl, ndev, WL_PROF_BSSID);
-	bss = cfg80211_get_bss(wiphy, NULL, curbssid,
-		ssid->SSID, ssid->SSID_len, WLAN_CAPABILITY_ESS,
-		WLAN_CAPABILITY_ESS);
+#if defined(WL_IFACE_COMB_NUM_CHANNELS) || defined(WL_CFG80211_P2P_DEV_IF)
+		| BIT(NL80211_IFTYPE_P2P_CLIENT)
+		| BIT(NL80211_IFTYPE_P2P_GO)
+#endif /* WL_IFACE_COMB_NUM_CHANNELS || WL_CFG80211_P2P_DEV_IF */
+#if defined(WL_CFG80211_P2P_DEV_IF)
+		| BIT(NL80211_IFTYPE_P2P_DEVICE)
+#endif
+		| BIT(NL80211_IFTYPE_AP);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)) && \
+	(defined(WL_IFACE_COMB_NUM_CHANNELS) || defined(WL_CFG80211_P2P_DEV_IF))
+	if (dhd && dhd->op_mode == DHD_FLAG_HOSTAP_MODE) {
+		WL_DBG(("Setting interface combinations for SoftAP mode\n"));
+		wdev->wiphy->iface_combinations = softap_iface_combinations;
+		wdev->wiphy->n_iface_combinations =
+			ARRAY_SIZE(softap_iface_combinations);
+	} else {
+		WL_DBG(("Setting interface combinations for STA+P2P mode\n"));
+		wdev->wiphy->iface_combinations = sta_p2p_iface_combinations;
+		wdev->wiphy->n_iface_combinations =
+			ARRAY_SIZE(sta_p2p_iface_combinations);
+	}
+#endif /* LINUX_VER >= 3.0 && (WL_IFACE_COMB_NUM_CHANNELS || WL_CFG80211_P2P_DEV_IF) */
 
-	mutex_lock(&wl->usr_sync);
-	if (!bss) {
-		WL_DBG(("Could not find the AP\n"));
-		*(u32 *) wl->extra_buf = htod32(WL_EXTRA_BUF_MAX);
-		err = wldev_ioctl(ndev, WLC_GET_BSS_INFO,
-			wl->extra_buf, WL_EXTRA_BUF_MAX, false);
-		if (unlikely(err)) {
-			WL_ERR(("Could not get bss info %d\n", err));
-			goto update_bss_info_out;
-		}
-		bi = (struct wl_bss_info *)(wl->extra_buf + 4);
-		if (memcmp(bi->BSSID.octet, curbssid, ETHER_ADDR_LEN)) {
-			err = -EIO;
-			goto update_bss_info_out;
-		}
-		err = wl_inform_single_bss(wl, bi);
-		if (unlikely(err))
-			goto update_bss_info_out;
-
-		ie = ((u8 *)bi) + bi->ie_offset;
-		ie_len = bi->ie_length;
-		beacon_interval = cpu_to_le16(bi->beacon_period);
-	} else {
-		WL_DBG(("Found the AP in the list - BSSID %pM\n", bss->bssid));
-		ie = bss->information_elements;
-		ie_len = bss->len_information_elements;
-		beacon_interval = bss->beacon_interval;
-		cfg80211_put_bss(bss);
-	}
+	wdev->wiphy->bands[IEEE80211_BAND_2GHZ] = &__wl_band_2ghz;
 
-	tim = bcm_parse_tlvs(ie, ie_len, WLAN_EID_TIM);
-	if (tim) {
-		dtim_period = tim->data[1];
-	} else {
-		/*
-		* active scan was done so we could not get dtim
-		* information out of probe response.
-		* so we speficially query dtim information.
-		*/
-		err = wldev_ioctl(ndev, WLC_GET_DTIMPRD,
-			&dtim_period, sizeof(dtim_period), false);
-		if (unlikely(err)) {
-			WL_ERR(("WLC_GET_DTIMPRD error (%d)\n", err));
-			goto update_bss_info_out;
-		}
-	}
+	wdev->wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
+	wdev->wiphy->cipher_suites = __wl_cipher_suites;
+	wdev->wiphy->n_cipher_suites = ARRAY_SIZE(__wl_cipher_suites);
+	wdev->wiphy->max_remain_on_channel_duration = 5000;
+	wdev->wiphy->mgmt_stypes = wl_cfg80211_default_mgmt_stypes;
+#ifndef WL_POWERSAVE_DISABLED
+	wdev->wiphy->flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;
+#else
+	wdev->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
+#endif				/* !WL_POWERSAVE_DISABLED */
+	wdev->wiphy->flags |= WIPHY_FLAG_NETNS_OK |
+		WIPHY_FLAG_4ADDR_AP |
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 39)
+		WIPHY_FLAG_SUPPORTS_SEPARATE_DEFAULT_KEYS |
+#endif
+		WIPHY_FLAG_4ADDR_STATION;
+	/*  If driver advertises FW_ROAM, the supplicant wouldn't
+	 * send the BSSID & Freq in the connect command allowing the
+	 * the driver to choose the AP to connect to. But unless we
+	 * support ROAM_CACHE in firware this will delay the ASSOC as
+	 * as the FW need to do a full scan before attempting to connect
+	 * So that feature will just increase assoc. The better approach
+	 * to let Supplicant to provide channel info and FW letter may roam
+	 * if needed so DON'T advertise that featur eto Supplicant.
+	 */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+/*	wdev->wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM; */
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)
+	wdev->wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL |
+		WIPHY_FLAG_OFFCHAN_TX;
+#endif
+#if defined(WL_SUPPORT_BACKPORTED_KPATCHES) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3, \
+	4, 0))
+	/* From 3.4 kernel ownards AP_SME flag can be advertised
+	 * to remove the patch from supplicant
+	 */
+	wdev->wiphy->flags |= WIPHY_FLAG_HAVE_AP_SME;
+#endif /* WL_SUPPORT_BACKPORTED_KPATCHES) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)) */
 
-	wl_update_prof(wl, ndev, NULL, &beacon_interval, WL_PROF_BEACONINT);
-	wl_update_prof(wl, ndev, NULL, &dtim_period, WL_PROF_DTIMPERIOD);
+#ifdef CONFIG_CFG80211_INTERNAL_REGDB
+	wdev->wiphy->reg_notifier = wl_cfg80211_reg_notifier;
+#endif /* CONFIG_CFG80211_INTERNAL_REGDB */
 
-update_bss_info_out:
-	mutex_unlock(&wl->usr_sync);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 2, 0)
+	wdev->wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS;
+#endif
+	WL_DBG(("Registering custom regulatory)\n"));
+	wdev->wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;
+	wiphy_apply_custom_regulatory(wdev->wiphy, &brcm_regdom);
+	/* Now we can register wiphy with cfg80211 module */
+	err = wiphy_register(wdev->wiphy);
+	if (unlikely(err < 0)) {
+		WL_ERR(("Couldn not register wiphy device (%d)\n", err));
+		wiphy_free(wdev->wiphy);
+	}
+#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)) && (LINUX_VERSION_CODE <= \
+	KERNEL_VERSION(3, 3, 0))) && defined(WL_IFACE_COMB_NUM_CHANNELS)
+	wdev->wiphy->flags &= ~WIPHY_FLAG_ENFORCE_COMBINATIONS;
+#endif /* ((LINUX_VER >= 3.0) && (LINUX_VER <= 3.3)) && WL_IFACE_COMB_NUM_CHANNELS */
 	return err;
 }
 
-static s32
-wl_bss_roaming_done(struct wl_priv *wl, struct net_device *ndev,
-	const wl_event_msg_t *e, void *data)
+static void wl_free_wdev(struct wl_priv *wl)
 {
-	struct wl_connect_info *conn_info = wl_to_conn(wl);
-	s32 err = 0;
-	u8 *curbssid;
-
-	wl_get_assoc_ies(wl, ndev);
-	wl_update_prof(wl, ndev, NULL, (void *)(e->addr.octet), WL_PROF_BSSID);
-	curbssid = wl_read_prof(wl, ndev, WL_PROF_BSSID);
-	wl_update_bss_info(wl, ndev);
-	wl_update_pmklist(ndev, wl->pmk_list, err);
-	cfg80211_roamed(ndev,
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39)
-		NULL,
-#endif
-		curbssid,
-		conn_info->req_ie, conn_info->req_ie_len,
-		conn_info->resp_ie, conn_info->resp_ie_len, GFP_KERNEL);
-	WL_DBG(("Report roaming result\n"));
-
-	wl_set_drv_status(wl, CONNECTED, ndev);
+	struct wireless_dev *wdev = wl->wdev;
+	struct wiphy *wiphy;
+	if (!wdev) {
+		WL_ERR(("wdev is invalid\n"));
+		return;
+	}
+	wiphy = wdev->wiphy;
+	wiphy_unregister(wdev->wiphy);
+	wdev->wiphy->dev.parent = NULL;
 
-	return err;
+	wl_delete_all_netinfo(wl);
+	wiphy_free(wiphy);
+	/* PLEASE do NOT call any function after wiphy_free, the driver's private structure "wl",
+	 * which is the private part of wiphy, has been freed in wiphy_free !!!!!!!!!!!
+	 */
 }
 
-static s32
-wl_bss_connect_done(struct wl_priv *wl, struct net_device *ndev,
-	const wl_event_msg_t *e, void *data, bool completed)
+static s32 wl_inform_bss(struct wl_priv *wl)
 {
-	struct wl_connect_info *conn_info = wl_to_conn(wl);
+	struct wl_scan_results *bss_list;
+	struct wl_bss_info *bi = NULL;	/* must be initialized */
 	s32 err = 0;
-	u8 *curbssid = wl_read_prof(wl, ndev, WL_PROF_BSSID);
+	s32 i;
 
-	WL_DBG((" enter\n"));
-	if (wl->scan_request) {
-		wl_notify_escan_complete(wl, ndev, true, true);
-	}
-	if (wl_get_drv_status(wl, CONNECTING, ndev)) {
-		wl_clr_drv_status(wl, CONNECTING, ndev);
-		if (completed) {
-			wl_get_assoc_ies(wl, ndev);
-			wl_update_prof(wl, ndev, NULL, (void *)(e->addr.octet), WL_PROF_BSSID);
-			curbssid = wl_read_prof(wl, ndev, WL_PROF_BSSID);
-			wl_update_bss_info(wl, ndev);
-			wl_update_pmklist(ndev, wl->pmk_list, err);
-			wl_set_drv_status(wl, CONNECTED, ndev);
-		}
-		cfg80211_connect_result(ndev,
-			curbssid,
-			conn_info->req_ie,
-			conn_info->req_ie_len,
-			conn_info->resp_ie,
-			conn_info->resp_ie_len,
-			completed ? WLAN_STATUS_SUCCESS : WLAN_STATUS_AUTH_TIMEOUT,
-			GFP_KERNEL);
-		if (completed)
-			WL_INFO(("Report connect result - connection succeeded\n"));
-		else
-			WL_ERR(("Report connect result - connection failed\n"));
+	bss_list = wl->bss_list;
+	WL_DBG(("scanned AP count (%d)\n", bss_list->count));
+	bi = next_bss(bss_list, bi);
+	for_each_bss(bss_list, bi, i) {
+		err = wl_inform_single_bss(wl, bi, 0);
+		if (unlikely(err))
+			break;
 	}
 	return err;
 }
 
-static s32
-wl_notify_mic_status(struct wl_priv *wl, struct net_device *ndev,
-	const wl_event_msg_t *e, void *data)
-{
-	u16 flags = ntoh16(e->flags);
-	enum nl80211_key_type key_type;
-
-	mutex_lock(&wl->usr_sync);
-	if (flags & WLC_EVENT_MSG_GROUP)
-		key_type = NL80211_KEYTYPE_GROUP;
-	else
-		key_type = NL80211_KEYTYPE_PAIRWISE;
-
-	cfg80211_michael_mic_failure(ndev, (u8 *)&e->addr, key_type, -1,
-		NULL, GFP_KERNEL);
-	mutex_unlock(&wl->usr_sync);
-
-	return 0;
-}
-
-static s32
-wl_notify_scan_status(struct wl_priv *wl, struct net_device *ndev,
-	const wl_event_msg_t *e, void *data)
+static s32 wl_inform_single_bss(struct wl_priv *wl, struct wl_bss_info *bi, u8 is_roam_done)
 {
-	struct channel_info channel_inform;
-	struct wl_scan_results *bss_list;
-	u32 len = WL_SCAN_BUF_MAX;
+	struct wiphy *wiphy = wl_to_wiphy(wl);
+	struct ieee80211_mgmt *mgmt;
+	struct ieee80211_channel *channel;
+	struct ieee80211_supported_band *band;
+	struct wl_cfg80211_bss_info *notif_bss_info;
+	struct wl_scan_req *sr = wl_to_sr(wl);
+	struct beacon_proberesp *beacon_proberesp;
+	struct cfg80211_bss *cbss = NULL;
+	s32 mgmt_type;
+	s32 signal;
+	u32 freq;
 	s32 err = 0;
-	unsigned long flags;
+	gfp_t aflags;
+	u8 *ie_offset = NULL;
 
-	WL_DBG(("Enter \n"));
-	if (!wl_get_drv_status(wl, SCANNING, ndev)) {
-		WL_ERR(("scan is not ready \n"));
+	if (unlikely(dtoh32(bi->length) > WL_BSS_INFO_MAX)) {
+		WL_DBG(("Beacon is larger than buffer. Discarding\n"));
 		return err;
 	}
-	if (wl->iscan_on && wl->iscan_kickstart)
-		return wl_wakeup_iscan(wl_to_iscan(wl));
-
-	mutex_lock(&wl->usr_sync);
-	wl_clr_drv_status(wl, SCANNING, ndev);
-	err = wldev_ioctl(ndev, WLC_GET_CHANNEL, &channel_inform,
-		sizeof(channel_inform), false);
-	if (unlikely(err)) {
-		WL_ERR(("scan busy (%d)\n", err));
-		goto scan_done_out;
+	aflags = (in_atomic()) ? GFP_ATOMIC : GFP_KERNEL;
+	notif_bss_info = kzalloc(sizeof(*notif_bss_info) + sizeof(*mgmt)
+		- sizeof(u8) + WL_BSS_INFO_MAX, aflags);
+	if (unlikely(!notif_bss_info)) {
+		WL_ERR(("notif_bss_info alloc failed\n"));
+		return -ENOMEM;
 	}
-	channel_inform.scan_channel = dtoh32(channel_inform.scan_channel);
-	if (unlikely(channel_inform.scan_channel)) {
+	mgmt = (struct ieee80211_mgmt *)notif_bss_info->frame_buf;
+	notif_bss_info->channel =
+		bi->ctl_ch ? bi->ctl_ch : CHSPEC_CHANNEL(wl_chspec_driver_to_host(bi->chanspec));
 
-		WL_DBG(("channel_inform.scan_channel (%d)\n",
-			channel_inform.scan_channel));
+	if (notif_bss_info->channel <= CH_MAX_2G_CHANNEL)
+		band = wiphy->bands[IEEE80211_BAND_2GHZ];
+	else
+		band = wiphy->bands[IEEE80211_BAND_5GHZ];
+	if (!band) {
+		WL_ERR(("No valid band"));
+		kfree(notif_bss_info);
+		return -EINVAL;
 	}
-	wl->bss_list = wl->scan_results;
-	bss_list = wl->bss_list;
-	memset(bss_list, 0, len);
-	bss_list->buflen = htod32(len);
-	err = wldev_ioctl(ndev, WLC_SCAN_RESULTS, bss_list, len, false);
-	if (unlikely(err)) {
-		WL_ERR(("%s Scan_results error (%d)\n", ndev->name, err));
-		err = -EINVAL;
-		goto scan_done_out;
+	notif_bss_info->rssi = dtoh16(bi->RSSI) + RSSI_OFFSET;
+	memcpy(mgmt->bssid, &bi->BSSID, ETHER_ADDR_LEN);
+	mgmt_type = wl->active_scan ?
+		IEEE80211_STYPE_PROBE_RESP : IEEE80211_STYPE_BEACON;
+	if (!memcmp(bi->SSID, sr->ssid.SSID, bi->SSID_len)) {
+	    mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT | mgmt_type);
 	}
-	bss_list->buflen = dtoh32(bss_list->buflen);
-	bss_list->version = dtoh32(bss_list->version);
-	bss_list->count = dtoh32(bss_list->count);
-
-	err = wl_inform_bss(wl);
+	beacon_proberesp = wl->active_scan ?
+		(struct beacon_proberesp *)&mgmt->u.probe_resp :
+		(struct beacon_proberesp *)&mgmt->u.beacon;
+	beacon_proberesp->timestamp = 0;
+	beacon_proberesp->beacon_int = cpu_to_le16(bi->beacon_period);
+	beacon_proberesp->capab_info = cpu_to_le16(bi->capability);
+	wl_rst_ie(wl);
 
-scan_done_out:
-	del_timer_sync(&wl->scan_timeout);
-	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
-	if (wl->scan_request) {
-		WL_DBG(("cfg80211_scan_done\n"));
-		cfg80211_scan_done(wl->scan_request, false);
-		wl->scan_request = NULL;
+	ie_offset = ((u8 *) bi) + bi->ie_offset;
+
+	if (is_roam_done && ((int)(*(ie_offset)) == WLAN_EID_SSID &&
+		((int)(*(ie_offset+1)) == 0 || (int)(*(ie_offset+2)) == 0))) {
+		u8 *ie_new_offset = NULL;
+		uint8 ie_new_length;
+
+		WL_ERR(("WAR trace: Changing the SSID Info, from beacon %d\n",
+			bi->flags & WL_BSS_FLAGS_FROM_BEACON));
+
+		ie_new_offset = (u8 *)kzalloc(WL_BSS_INFO_MAX, GFP_KERNEL);
+		if (ie_new_offset) {
+			*(ie_new_offset) = WLAN_EID_SSID;
+			*(ie_new_offset+1) = bi->SSID_len;
+			memcpy(ie_new_offset+2, bi->SSID, bi->SSID_len);
+			ie_new_length = bi->ie_length - *(ie_offset+1) + bi->SSID_len;
+
+			/* Copy the remaining IE apart from SSID IE from bi */
+			memcpy(ie_new_offset+2 + bi->SSID_len,
+				ie_offset+2 + *(ie_offset+1),
+				bi->ie_length - 2 - *(ie_offset+1));
+			wl_mrg_ie(wl, ie_new_offset, ie_new_length);
+			kfree(ie_new_offset);
+		} else {
+			wl_mrg_ie(wl, ((u8 *) bi) + bi->ie_offset, bi->ie_length);
+		}
+	} else {
+		wl_mrg_ie(wl, ((u8 *) bi) + bi->ie_offset, bi->ie_length);
 	}
-	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
-	mutex_unlock(&wl->usr_sync);
+
+	wl_cp_ie(wl, beacon_proberesp->variable, WL_BSS_INFO_MAX -
+		offsetof(struct wl_cfg80211_bss_info, frame_buf));
+	notif_bss_info->frame_len = offsetof(struct ieee80211_mgmt,
+		u.beacon.variable) + wl_get_ielen(wl);
+#if LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 38) && !defined(WL_COMPAT_WIRELESS)
+	freq = ieee80211_channel_to_frequency(notif_bss_info->channel);
+	(void)band->band;
+#else
+	freq = ieee80211_channel_to_frequency(notif_bss_info->channel, band->band);
+#endif
+	if (freq == 0) {
+		WL_ERR(("Invalid channel, fail to chcnage channel to freq\n"));
+		kfree(notif_bss_info);
+		return -EINVAL;
+	}
+	channel = ieee80211_get_channel(wiphy, freq);
+	if (unlikely(!channel)) {
+		WL_ERR(("ieee80211_get_channel error\n"));
+		kfree(notif_bss_info);
+		return -EINVAL;
+	}
+	WL_DBG(("SSID : \"%s\", rssi %d, channel %d, capability : 0x04%x, bssid %pM"
+			"mgmt_type %d frame_len %d\n", bi->SSID,
+			notif_bss_info->rssi, notif_bss_info->channel,
+			mgmt->u.beacon.capab_info, &bi->BSSID, mgmt_type,
+			notif_bss_info->frame_len));
+
+	signal = notif_bss_info->rssi * 100;
+	if (!mgmt->u.probe_resp.timestamp) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
+		struct timespec ts;
+		get_monotonic_boottime(&ts);
+		mgmt->u.probe_resp.timestamp = ((u64)ts.tv_sec*1000000)
+				+ ts.tv_nsec / 1000;
+#else
+		struct timeval tv;
+		do_gettimeofday(&tv);
+		mgmt->u.probe_resp.timestamp = ((u64)tv.tv_sec*1000000)
+				+ tv.tv_usec;
+#endif
+	}
+
+
+	cbss = cfg80211_inform_bss_frame(wiphy, channel, mgmt,
+		le16_to_cpu(notif_bss_info->frame_len), signal, aflags);
+	if (unlikely(!cbss)) {
+		WL_ERR(("cfg80211_inform_bss_frame error\n"));
+		kfree(notif_bss_info);
+		return -EINVAL;
+	}
+
+	cfg80211_put_bss(cbss);
+	kfree(notif_bss_info);
 	return err;
 }
-static s32
-wl_frame_get_mgmt(u16 fc, const struct ether_addr *da,
-	const struct ether_addr *sa, const struct ether_addr *bssid,
-	u8 **pheader, u32 *body_len, u8 *pbody)
+
+static bool wl_is_linkup(struct wl_priv *wl, const wl_event_msg_t *e, struct net_device *ndev)
 {
-	struct dot11_management_header *hdr;
-	u32 totlen = 0;
-	s32 err = 0;
-	u8 *offset;
-	u32 prebody_len = *body_len;
-	switch (fc) {
-		case FC_ASSOC_REQ:
-			/* capability , listen interval */
-			totlen = DOT11_ASSOC_REQ_FIXED_LEN;
-			*body_len += DOT11_ASSOC_REQ_FIXED_LEN;
-			break;
+	u32 event = ntoh32(e->event_type);
+	u32 status =  ntoh32(e->status);
+	u16 flags = ntoh16(e->flags);
 
-		case FC_REASSOC_REQ:
-			/* capability, listen inteval, ap address */
-			totlen = DOT11_REASSOC_REQ_FIXED_LEN;
-			*body_len += DOT11_REASSOC_REQ_FIXED_LEN;
-			break;
+	WL_DBG(("event %d, status %d flags %x\n", event, status, flags));
+	if (event == WLC_E_SET_SSID) {
+		if (status == WLC_E_STATUS_SUCCESS) {
+			if (!wl_is_ibssmode(wl, ndev))
+				return true;
+		}
+	} else if (event == WLC_E_LINK) {
+		if (flags & WLC_EVENT_MSG_LINK)
+			return true;
 	}
-	totlen += DOT11_MGMT_HDR_LEN + prebody_len;
-	*pheader = kzalloc(totlen, GFP_KERNEL);
-	if (*pheader == NULL) {
-		WL_ERR(("memory alloc failed \n"));
-		return -ENOMEM;
+
+	WL_DBG(("wl_is_linkup false\n"));
+	return false;
+}
+
+static bool wl_is_linkdown(struct wl_priv *wl, const wl_event_msg_t *e)
+{
+	u32 event = ntoh32(e->event_type);
+	u16 flags = ntoh16(e->flags);
+
+	if (event == WLC_E_DEAUTH_IND ||
+	event == WLC_E_DISASSOC_IND ||
+	event == WLC_E_DISASSOC ||
+	event == WLC_E_DEAUTH) {
+#if (WL_DBG_LEVEL > 0)
+	WL_ERR(("Link down Reason : WLC_E_%s\n", wl_dbg_estr[event]));
+#endif /* (WL_DBG_LEVEL > 0) */
+		return true;
+	} else if (event == WLC_E_LINK) {
+		if (!(flags & WLC_EVENT_MSG_LINK)) {
+#if (WL_DBG_LEVEL > 0)
+	WL_ERR(("Link down Reason : WLC_E_%s\n", wl_dbg_estr[event]));
+#endif /* (WL_DBG_LEVEL > 0) */
+			return true;
+		}
 	}
-	hdr = (struct dot11_management_header *) (*pheader);
-	hdr->fc = htol16(fc);
-	hdr->durid = 0;
-	hdr->seq = 0;
-	offset = (u8*)(hdr + 1) + (totlen - DOT11_MGMT_HDR_LEN - prebody_len);
-	bcopy((const char*)da, (u8*)&hdr->da, ETHER_ADDR_LEN);
-	bcopy((const char*)sa, (u8*)&hdr->sa, ETHER_ADDR_LEN);
-	bcopy((const char*)bssid, (u8*)&hdr->bssid, ETHER_ADDR_LEN);
-	bcopy((const char*)pbody, offset, prebody_len);
-	*body_len = totlen;
-	return err;
+
+	return false;
+}
+
+static bool wl_is_nonetwork(struct wl_priv *wl, const wl_event_msg_t *e)
+{
+	u32 event = ntoh32(e->event_type);
+	u32 status = ntoh32(e->status);
+
+	if (event == WLC_E_LINK && status == WLC_E_STATUS_NO_NETWORKS)
+		return true;
+	if (event == WLC_E_SET_SSID && status != WLC_E_STATUS_SUCCESS)
+		return true;
+
+	return false;
 }
+
+/* The mainline kernel >= 3.2.0 has support for indicating new/del station
+ * to AP/P2P GO via events. If this change is backported to kernel for which
+ * this driver is being built, then define WL_CFG80211_STA_EVENT. You
+ * should use this new/del sta event mechanism for BRCM supplicant >= 22.
+ */
 static s32
-wl_notify_rx_mgmt_frame(struct wl_priv *wl, struct net_device *ndev,
+wl_notify_connect_status_ap(struct wl_priv *wl, struct net_device *ndev,
 	const wl_event_msg_t *e, void *data)
 {
-	struct ieee80211_supported_band *band;
-	struct wiphy *wiphy = wl_to_wiphy(wl);
-	struct ether_addr da;
-	struct ether_addr bssid;
-	bool isfree = false;
 	s32 err = 0;
-	s32 freq;
-	struct net_device *dev = NULL;
-	wifi_p2p_pub_act_frame_t *act_frm = NULL;
-	wifi_p2p_action_frame_t *p2p_act_frm = NULL;
-	wifi_p2psd_gas_pub_act_frame_t *sd_act_frm = NULL;
-	wl_event_rx_frame_data_t *rxframe =
-		(wl_event_rx_frame_data_t*)data;
 	u32 event = ntoh32(e->event_type);
+	u32 reason = ntoh32(e->reason);
+	u32 len = ntoh32(e->datalen);
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0)) && !defined(WL_CFG80211_STA_EVENT)
+	bool isfree = false;
 	u8 *mgmt_frame;
 	u8 bsscfgidx = e->bsscfgidx;
-	u32 mgmt_frame_len = ntoh32(e->datalen) - sizeof(wl_event_rx_frame_data_t);
-	u16 channel = ((ntoh16(rxframe->channel) & WL_CHANSPEC_CHAN_MASK));
+	s32 freq;
+	s32 channel;
+	u8 *body = NULL;
+	u16 fc = 0;
+
+	struct ieee80211_supported_band *band;
+	struct ether_addr da;
+	struct ether_addr bssid;
+	struct wiphy *wiphy = wl_to_wiphy(wl);
+	channel_info_t ci;
+#else
+	struct station_info sinfo;
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0)) && !WL_CFG80211_STA_EVENT */
+
+	WL_DBG(("event %d status %d reason %d\n", event, ntoh32(e->status), reason));
+	/* if link down, bsscfg is disabled. */
+	if (event == WLC_E_LINK && reason == WLC_E_LINK_BSSCFG_DIS &&
+		wl_get_p2p_status(wl, IF_DELETING) && (ndev != wl_to_prmry_ndev(wl))) {
+		wl_add_remove_eventmsg(ndev, WLC_E_PROBREQ_MSG, false);
+		WL_INFO(("AP mode link down !! \n"));
+		complete(&wl->iface_disable);
+		return 0;
+	}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0)) && !defined(WL_CFG80211_STA_EVENT)
+	WL_DBG(("Enter \n"));
+	if (!len && (event == WLC_E_DEAUTH)) {
+		len = 2; /* reason code field */
+		data = &reason;
+	}
+	if (len) {
+		body = kzalloc(len, GFP_KERNEL);
 
+		if (body == NULL) {
+			WL_ERR(("wl_notify_connect_status: Failed to allocate body\n"));
+			return WL_INVALID;
+		}
+	}
 	memset(&bssid, 0, ETHER_ADDR_LEN);
+	WL_DBG(("Enter event %d ndev %p\n", event, ndev));
+	if (wl_get_mode_by_netdev(wl, ndev) == WL_INVALID) {
+		kfree(body);
+		return WL_INVALID;
+	}
+	if (len)
+		memcpy(body, data, len);
 
-	if (wl->p2p_net == ndev) {
-		dev = wl_to_prmry_ndev(wl);
-	} else {
-		dev = ndev;
+	wldev_iovar_getbuf_bsscfg(ndev, "cur_etheraddr",
+		NULL, 0, wl->ioctl_buf, WLC_IOCTL_SMLEN, bsscfgidx, &wl->ioctl_buf_sync);
+	memcpy(da.octet, wl->ioctl_buf, ETHER_ADDR_LEN);
+	err = wldev_ioctl(ndev, WLC_GET_BSSID, &bssid, ETHER_ADDR_LEN, false);
+	switch (event) {
+		case WLC_E_ASSOC_IND:
+			fc = FC_ASSOC_REQ;
+			break;
+		case WLC_E_REASSOC_IND:
+			fc = FC_REASSOC_REQ;
+			break;
+		case WLC_E_DISASSOC_IND:
+			fc = FC_DISASSOC;
+			break;
+		case WLC_E_DEAUTH_IND:
+			fc = FC_DISASSOC;
+			break;
+		case WLC_E_DEAUTH:
+			fc = FC_DISASSOC;
+			break;
+		default:
+			fc = 0;
+			goto exit;
+	}
+	if ((err = wldev_ioctl(ndev, WLC_GET_CHANNEL, &ci, sizeof(ci), false))) {
+		kfree(body);
+		return err;
 	}
 
+	channel = dtoh32(ci.hw_channel);
 	if (channel <= CH_MAX_2G_CHANNEL)
 		band = wiphy->bands[IEEE80211_BAND_2GHZ];
 	else
 		band = wiphy->bands[IEEE80211_BAND_5GHZ];
 	if (!band) {
 		WL_ERR(("No valid band"));
+		if (body)
+			kfree(body);
 		return -EINVAL;
 	}
 #if LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 38) && !defined(WL_COMPAT_WIRELESS)
@@ -5525,1717 +7120,3855 @@ wl_notify_rx_mgmt_frame(struct wl_priv *wl, struct net_device *ndev,
 #else
 	freq = ieee80211_channel_to_frequency(channel, band->band);
 #endif
-	if (event == WLC_E_ACTION_FRAME_RX) {
-		wldev_iovar_getbuf_bsscfg(dev, "cur_etheraddr",
-			NULL, 0, wl->ioctl_buf, WLC_IOCTL_MAXLEN, bsscfgidx, &wl->ioctl_buf_sync);
 
-		wldev_ioctl(dev, WLC_GET_BSSID, &bssid, ETHER_ADDR_LEN, false);
-		memcpy(da.octet, wl->ioctl_buf, ETHER_ADDR_LEN);
-		err = wl_frame_get_mgmt(FC_ACTION, &da, &e->addr, &bssid,
-			&mgmt_frame, &mgmt_frame_len,
-			(u8 *)((wl_event_rx_frame_data_t *)rxframe + 1));
-		if (err < 0) {
-			WL_ERR(("%s: Error in receiving action frame len %d channel %d freq %d\n",
-				__func__, mgmt_frame_len, channel, freq));
-			goto exit;
-		}
-		isfree = true;
-		if (wl_cfgp2p_is_pub_action(&mgmt_frame[DOT11_MGMT_HDR_LEN],
-			mgmt_frame_len - DOT11_MGMT_HDR_LEN)) {
-			act_frm = (wifi_p2p_pub_act_frame_t *)
-					(&mgmt_frame[DOT11_MGMT_HDR_LEN]);
-		} else if (wl_cfgp2p_is_p2p_action(&mgmt_frame[DOT11_MGMT_HDR_LEN],
-			mgmt_frame_len - DOT11_MGMT_HDR_LEN)) {
-			p2p_act_frm = (wifi_p2p_action_frame_t *)
-					(&mgmt_frame[DOT11_MGMT_HDR_LEN]);
-			(void) p2p_act_frm;
-		} else if (wl_cfgp2p_is_gas_action(&mgmt_frame[DOT11_MGMT_HDR_LEN],
-			mgmt_frame_len - DOT11_MGMT_HDR_LEN)) {
-			sd_act_frm = (wifi_p2psd_gas_pub_act_frame_t *)
-					(&mgmt_frame[DOT11_MGMT_HDR_LEN]);
-			(void) sd_act_frm;
-		}
-		wl_cfgp2p_print_actframe(false, &mgmt_frame[DOT11_MGMT_HDR_LEN],
-			mgmt_frame_len - DOT11_MGMT_HDR_LEN);
-		/*
-		 * After complete GO Negotiation, roll back to mpc mode
-		 */
-		if (act_frm && ((act_frm->subtype == P2P_PAF_GON_CONF) ||
-			(act_frm->subtype == P2P_PAF_PROVDIS_RSP))) {
-			wldev_iovar_setint(dev, "mpc", 1);
-		}
-	} else {
-		mgmt_frame = (u8 *)((wl_event_rx_frame_data_t *)rxframe + 1);
-	}
+	err = wl_frame_get_mgmt(fc, &da, &e->addr, &bssid,
+		&mgmt_frame, &len, body);
+	if (err < 0)
+		goto exit;
+	isfree = true;
 
-	cfg80211_rx_mgmt(ndev, freq, 0, mgmt_frame, mgmt_frame_len, GFP_ATOMIC);
-
-	WL_DBG(("%s: mgmt_frame_len (%d) , e->datalen (%d), channel (%d), freq (%d)\n", __func__,
-		mgmt_frame_len, ntoh32(e->datalen), channel, freq));
+	if (event == WLC_E_ASSOC_IND && reason == DOT11_SC_SUCCESS) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+		cfg80211_rx_mgmt(ndev, freq, 0, mgmt_frame, len, GFP_ATOMIC);
+#else
+		cfg80211_rx_mgmt(ndev, freq, mgmt_frame, len, GFP_ATOMIC);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0) */
+	} else if (event == WLC_E_DISASSOC_IND) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+		cfg80211_rx_mgmt(ndev, freq, 0, mgmt_frame, len, GFP_ATOMIC);
+#else
+		cfg80211_rx_mgmt(ndev, freq, mgmt_frame, len, GFP_ATOMIC);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0) */
+	} else if ((event == WLC_E_DEAUTH_IND) || (event == WLC_E_DEAUTH)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+		cfg80211_rx_mgmt(ndev, freq, 0, mgmt_frame, len, GFP_ATOMIC);
+#else
+		cfg80211_rx_mgmt(ndev, freq, mgmt_frame, len, GFP_ATOMIC);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0) */
+	}
 
+exit:
 	if (isfree)
 		kfree(mgmt_frame);
-exit:
-	return 0;
+	if (body)
+		kfree(body);
+	return err;
+#else /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0) && !WL_CFG80211_STA_EVENT */
+	sinfo.filled = 0;
+	if (((event == WLC_E_ASSOC_IND) || (event == WLC_E_REASSOC_IND)) &&
+		reason == DOT11_SC_SUCCESS) {
+		sinfo.filled = STATION_INFO_ASSOC_REQ_IES;
+		if (!data) {
+			WL_ERR(("No IEs present in ASSOC/REASSOC_IND"));
+			return -EINVAL;
+		}
+		sinfo.assoc_req_ies = data;
+		sinfo.assoc_req_ies_len = len;
+		cfg80211_new_sta(ndev, e->addr.octet, &sinfo, GFP_ATOMIC);
+	} else if (event == WLC_E_DISASSOC_IND) {
+		cfg80211_del_sta(ndev, e->addr.octet, GFP_ATOMIC);
+	} else if ((event == WLC_E_DEAUTH_IND) || (event == WLC_E_DEAUTH)) {
+		cfg80211_del_sta(ndev, e->addr.octet, GFP_ATOMIC);
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0) && !WL_CFG80211_STA_EVENT */
+	return err;
 }
 
-static void wl_init_conf(struct wl_conf *conf)
+static s32
+wl_get_auth_assoc_status(struct wl_priv *wl, struct net_device *ndev,
+	const wl_event_msg_t *e)
 {
-	WL_DBG(("Enter \n"));
-	conf->frag_threshold = (u32)-1;
-	conf->rts_threshold = (u32)-1;
-	conf->retry_short = (u32)-1;
-	conf->retry_long = (u32)-1;
-	conf->tx_power = -1;
+	u32 reason = ntoh32(e->reason);
+	u32 event = ntoh32(e->event_type);
+	struct wl_security *sec = wl_read_prof(wl, ndev, WL_PROF_SEC);
+	WL_DBG(("event type : %d, reason : %d\n", event, reason));
+	if (sec) {
+		switch (event) {
+		case WLC_E_ASSOC:
+		case WLC_E_AUTH:
+				sec->auth_assoc_res_status = reason;
+		default:
+			break;
+		}
+	} else
+		WL_ERR(("sec is NULL\n"));
+	return 0;
 }
 
-static void wl_init_prof(struct wl_priv *wl, struct net_device *ndev)
+static s32
+wl_notify_connect_status(struct wl_priv *wl, struct net_device *ndev,
+	const wl_event_msg_t *e, void *data)
 {
-	unsigned long flags;
-	struct wl_profile *profile = wl_get_profile_by_netdev(wl, ndev);
+	bool act;
+	s32 err = 0;
+	u32 event = ntoh32(e->event_type);
 
-	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
-	memset(profile, 0, sizeof(struct wl_profile));
-	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
-}
+	if (wl_get_mode_by_netdev(wl, ndev) == WL_MODE_AP) {
+		wl_notify_connect_status_ap(wl, ndev, e, data);
+	} else {
+		WL_DBG(("wl_notify_connect_status : event %d status : %d ndev %p\n",
+			ntoh32(e->event_type), ntoh32(e->status), ndev));
+		if (event == WLC_E_ASSOC || event == WLC_E_AUTH) {
+			wl_get_auth_assoc_status(wl, ndev, e);
+			return 0;
+		}
+		if (wl_is_linkup(wl, e, ndev)) {
+			wl_link_up(wl);
+			act = true;
+			if (wl_is_ibssmode(wl, ndev)) {
+				printk("cfg80211_ibss_joined\n");
+				cfg80211_ibss_joined(ndev, (s8 *)&e->addr,
+					GFP_KERNEL);
+				WL_DBG(("joined in IBSS network\n"));
+			} else {
+				if (!wl_get_drv_status(wl, DISCONNECTING, ndev)) {
+					printk("wl_bss_connect_done succeeded with " MACDBG "\n",
+						MAC2STRDBG((u8*)(&e->addr)));
+					wl_bss_connect_done(wl, ndev, e, data, true);
+					WL_DBG(("joined in BSS network \"%s\"\n",
+					((struct wlc_ssid *)
+					 wl_read_prof(wl, ndev, WL_PROF_SSID))->SSID));
+				}
+			}
+			wl_update_prof(wl, ndev, e, &act, WL_PROF_ACT);
+			wl_update_prof(wl, ndev, NULL, (void *)&e->addr, WL_PROF_BSSID);
 
-static void wl_init_event_handler(struct wl_priv *wl)
-{
-	memset(wl->evt_handler, 0, sizeof(wl->evt_handler));
+		} else if (wl_is_linkdown(wl, e)) {
+			if (wl->scan_request) {
+				if (wl->escan_on) {
+					wl_notify_escan_complete(wl, ndev, true, true);
+				} else {
+					del_timer_sync(&wl->scan_timeout);
+					wl_iscan_aborted(wl);
+				}
+			}
+			if (wl_get_drv_status(wl, CONNECTED, ndev)) {
+				scb_val_t scbval;
+				u8 *curbssid = wl_read_prof(wl, ndev, WL_PROF_BSSID);
+				s32 reason = 0;
+				if (event == WLC_E_DEAUTH_IND || event == WLC_E_DISASSOC_IND)
+					reason = ntoh32(e->reason);
+				/* WLAN_REASON_UNSPECIFIED is used for hang up event in Android */
+				reason = (reason == WLAN_REASON_UNSPECIFIED)? 0 : reason;
+
+				printk("link down if %s may call cfg80211_disconnected. "
+					"event : %d, reason=%d from " MACDBG "\n",
+					ndev->name, event, ntoh32(e->reason),
+					MAC2STRDBG((u8*)(&e->addr)));
+				if (memcmp(curbssid, &e->addr, ETHER_ADDR_LEN) != 0) {
+					WL_ERR(("BSSID of event is not the connected BSSID"
+						"(ignore it) cur: " MACDBG " event: " MACDBG"\n",
+						MAC2STRDBG(curbssid), MAC2STRDBG((u8*)(&e->addr))));
+					return 0;
+				}
+				wl_clr_drv_status(wl, CONNECTED, ndev);
+				if (! wl_get_drv_status(wl, DISCONNECTING, ndev)) {
+					/* To make sure disconnect, explictly send dissassoc
+					*  for BSSID 00:00:00:00:00:00 issue
+					*/
+					scbval.val = WLAN_REASON_DEAUTH_LEAVING;
 
-	wl->evt_handler[WLC_E_SCAN_COMPLETE] = wl_notify_scan_status;
-	wl->evt_handler[WLC_E_LINK] = wl_notify_connect_status;
-	wl->evt_handler[WLC_E_DEAUTH_IND] = wl_notify_connect_status;
-	wl->evt_handler[WLC_E_DEAUTH] = wl_notify_connect_status;
-	wl->evt_handler[WLC_E_DISASSOC_IND] = wl_notify_connect_status;
-	wl->evt_handler[WLC_E_ASSOC_IND] = wl_notify_connect_status;
-	wl->evt_handler[WLC_E_REASSOC_IND] = wl_notify_connect_status;
-	wl->evt_handler[WLC_E_ROAM] = wl_notify_roaming_status;
-	wl->evt_handler[WLC_E_MIC_ERROR] = wl_notify_mic_status;
-	wl->evt_handler[WLC_E_SET_SSID] = wl_notify_connect_status;
-	wl->evt_handler[WLC_E_ACTION_FRAME_RX] = wl_notify_rx_mgmt_frame;
-	wl->evt_handler[WLC_E_PROBREQ_MSG] = wl_notify_rx_mgmt_frame;
-	wl->evt_handler[WLC_E_P2P_PROBREQ_MSG] = wl_notify_rx_mgmt_frame;
-	wl->evt_handler[WLC_E_P2P_DISC_LISTEN_COMPLETE] = wl_cfgp2p_listen_complete;
-	wl->evt_handler[WLC_E_ACTION_FRAME_COMPLETE] = wl_cfgp2p_action_tx_complete;
-	wl->evt_handler[WLC_E_ACTION_FRAME_OFF_CHAN_COMPLETE] = wl_cfgp2p_action_tx_complete;
+					memcpy(&scbval.ea, curbssid, ETHER_ADDR_LEN);
+					scbval.val = htod32(scbval.val);
+					err = wldev_ioctl(ndev, WLC_DISASSOC, &scbval,
+						sizeof(scb_val_t), true);
+					if (err < 0) {
+						WL_ERR(("WLC_DISASSOC error %d\n", err));
+						err = 0;
+					}
+					cfg80211_disconnected(ndev, reason, NULL, 0, GFP_KERNEL);
+					wl_link_down(wl);
+					wl_init_prof(wl, ndev);
+				}
+			}
+			else if (wl_get_drv_status(wl, CONNECTING, ndev)) {
+				printk("link down, during connecting\n");
+#ifdef ESCAN_RESULT_PATCH
+				if ((memcmp(connect_req_bssid, broad_bssid, ETHER_ADDR_LEN) == 0) ||
+					(memcmp(&e->addr, broad_bssid, ETHER_ADDR_LEN) == 0) ||
+					(memcmp(&e->addr, connect_req_bssid, ETHER_ADDR_LEN) == 0))
+					/* In case this event comes while associating another AP */
+#endif /* ESCAN_RESULT_PATCH */
+					wl_bss_connect_done(wl, ndev, e, data, false);
+			}
+			wl_clr_drv_status(wl, DISCONNECTING, ndev);
 
+			/* if link down, bsscfg is diabled */
+			if (ndev != wl_to_prmry_ndev(wl))
+				complete(&wl->iface_disable);
+
+		} else if (wl_is_nonetwork(wl, e)) {
+			printk("connect failed event=%d e->status %d e->reason %d \n",
+				event, (int)ntoh32(e->status), (int)ntoh32(e->reason));
+			/* Clean up any pending scan request */
+			if (wl->scan_request) {
+				if (wl->escan_on) {
+					wl_notify_escan_complete(wl, ndev, true, true);
+				} else {
+					del_timer_sync(&wl->scan_timeout);
+					wl_iscan_aborted(wl);
+				}
+			}
+			if (wl_get_drv_status(wl, CONNECTING, ndev))
+				wl_bss_connect_done(wl, ndev, e, data, false);
+		} else {
+			printk("%s nothing\n", __FUNCTION__);
+		}
+	}
+	return err;
 }
 
-static s32 wl_init_priv_mem(struct wl_priv *wl)
+static s32
+wl_notify_roaming_status(struct wl_priv *wl, struct net_device *ndev,
+	const wl_event_msg_t *e, void *data)
 {
+	bool act;
+	s32 err = 0;
+	u32 event = be32_to_cpu(e->event_type);
+	u32 status = be32_to_cpu(e->status);
 	WL_DBG(("Enter \n"));
-	wl->scan_results = (void *)kzalloc(WL_SCAN_BUF_MAX, GFP_KERNEL);
-	if (unlikely(!wl->scan_results)) {
-		WL_ERR(("Scan results alloc failed\n"));
-		goto init_priv_mem_out;
+	if (event == WLC_E_ROAM && status == WLC_E_STATUS_SUCCESS) {
+		if (wl_get_drv_status(wl, CONNECTED, ndev))
+			wl_bss_roaming_done(wl, ndev, e, data);
+		else
+			wl_bss_connect_done(wl, ndev, e, data, true);
+		act = true;
+		wl_update_prof(wl, ndev, e, &act, WL_PROF_ACT);
+		wl_update_prof(wl, ndev, NULL, (void *)&e->addr, WL_PROF_BSSID);
 	}
-	wl->conf = (void *)kzalloc(sizeof(*wl->conf), GFP_KERNEL);
-	if (unlikely(!wl->conf)) {
-		WL_ERR(("wl_conf alloc failed\n"));
-		goto init_priv_mem_out;
+	return err;
+}
+
+static s32 wl_get_assoc_ies(struct wl_priv *wl, struct net_device *ndev)
+{
+	wl_assoc_info_t assoc_info;
+	struct wl_connect_info *conn_info = wl_to_conn(wl);
+	s32 err = 0;
+
+	WL_DBG(("Enter \n"));
+	err = wldev_iovar_getbuf(ndev, "assoc_info", NULL, 0, wl->extra_buf,
+		WL_ASSOC_INFO_MAX, NULL);
+	if (unlikely(err)) {
+		WL_ERR(("could not get assoc info (%d)\n", err));
+		return err;
 	}
-	wl->scan_req_int =
-	    (void *)kzalloc(sizeof(*wl->scan_req_int), GFP_KERNEL);
-	if (unlikely(!wl->scan_req_int)) {
-		WL_ERR(("Scan req alloc failed\n"));
-		goto init_priv_mem_out;
+	memcpy(&assoc_info, wl->extra_buf, sizeof(wl_assoc_info_t));
+	assoc_info.req_len = htod32(assoc_info.req_len);
+	assoc_info.resp_len = htod32(assoc_info.resp_len);
+	assoc_info.flags = htod32(assoc_info.flags);
+	if (conn_info->req_ie_len) {
+		conn_info->req_ie_len = 0;
+		bzero(conn_info->req_ie, sizeof(conn_info->req_ie));
 	}
-	wl->ioctl_buf = (void *)kzalloc(WLC_IOCTL_MAXLEN, GFP_KERNEL);
-	if (unlikely(!wl->ioctl_buf)) {
-		WL_ERR(("Ioctl buf alloc failed\n"));
-		goto init_priv_mem_out;
+	if (conn_info->resp_ie_len) {
+		conn_info->resp_ie_len = 0;
+		bzero(conn_info->resp_ie, sizeof(conn_info->resp_ie));
 	}
-	wl->escan_ioctl_buf = (void *)kzalloc(WLC_IOCTL_MAXLEN, GFP_KERNEL);
-	if (unlikely(!wl->escan_ioctl_buf)) {
-		WL_ERR(("Ioctl buf alloc failed\n"));
-		goto init_priv_mem_out;
+	if (assoc_info.req_len) {
+		err = wldev_iovar_getbuf(ndev, "assoc_req_ies", NULL, 0, wl->extra_buf,
+			WL_ASSOC_INFO_MAX, NULL);
+		if (unlikely(err)) {
+			WL_ERR(("could not get assoc req (%d)\n", err));
+			return err;
+		}
+		conn_info->req_ie_len = assoc_info.req_len - sizeof(struct dot11_assoc_req);
+		if (assoc_info.flags & WLC_ASSOC_REQ_IS_REASSOC) {
+			conn_info->req_ie_len -= ETHER_ADDR_LEN;
+		}
+		if (conn_info->req_ie_len <= MAX_REQ_LINE)
+			memcpy(conn_info->req_ie, wl->extra_buf, conn_info->req_ie_len);
+		else {
+			WL_ERR(("IE size %d above max %d size \n",
+				conn_info->req_ie_len, MAX_REQ_LINE));
+			return err;
+		}
+	} else {
+		conn_info->req_ie_len = 0;
 	}
-	wl->extra_buf = (void *)kzalloc(WL_EXTRA_BUF_MAX, GFP_KERNEL);
-	if (unlikely(!wl->extra_buf)) {
-		WL_ERR(("Extra buf alloc failed\n"));
-		goto init_priv_mem_out;
+	if (assoc_info.resp_len) {
+		err = wldev_iovar_getbuf(ndev, "assoc_resp_ies", NULL, 0, wl->extra_buf,
+			WL_ASSOC_INFO_MAX, NULL);
+		if (unlikely(err)) {
+			WL_ERR(("could not get assoc resp (%d)\n", err));
+			return err;
+		}
+		conn_info->resp_ie_len = assoc_info.resp_len -sizeof(struct dot11_assoc_resp);
+		if (conn_info->resp_ie_len <= MAX_REQ_LINE)
+			memcpy(conn_info->resp_ie, wl->extra_buf, conn_info->resp_ie_len);
+		else {
+			WL_ERR(("IE size %d above max %d size \n",
+				conn_info->resp_ie_len, MAX_REQ_LINE));
+			return err;
+		}
+	} else {
+		conn_info->resp_ie_len = 0;
 	}
-	wl->iscan = (void *)kzalloc(sizeof(*wl->iscan), GFP_KERNEL);
-	if (unlikely(!wl->iscan)) {
-		WL_ERR(("Iscan buf alloc failed\n"));
-		goto init_priv_mem_out;
-	}
-	wl->pmk_list = (void *)kzalloc(sizeof(*wl->pmk_list), GFP_KERNEL);
-	if (unlikely(!wl->pmk_list)) {
-		WL_ERR(("pmk list alloc failed\n"));
-		goto init_priv_mem_out;
+	WL_DBG(("req len (%d) resp len (%d)\n", conn_info->req_ie_len,
+		conn_info->resp_ie_len));
+
+	return err;
+}
+
+static void wl_ch_to_chanspec(int ch, struct wl_join_params *join_params,
+        size_t *join_params_size)
+{
+	chanspec_t chanspec = 0;
+	if (ch != 0) {
+		join_params->params.chanspec_num = 1;
+		join_params->params.chanspec_list[0] = ch;
+
+		if (join_params->params.chanspec_list[0] <= CH_MAX_2G_CHANNEL)
+			chanspec |= WL_CHANSPEC_BAND_2G;
+		else
+			chanspec |= WL_CHANSPEC_BAND_5G;
+
+		chanspec |= WL_CHANSPEC_BW_20;
+		chanspec |= WL_CHANSPEC_CTL_SB_NONE;
+
+		*join_params_size += WL_ASSOC_PARAMS_FIXED_SIZE +
+			join_params->params.chanspec_num * sizeof(chanspec_t);
+
+		join_params->params.chanspec_list[0]  &= WL_CHANSPEC_CHAN_MASK;
+		join_params->params.chanspec_list[0] |= chanspec;
+		join_params->params.chanspec_list[0] =
+			wl_chspec_host_to_driver(join_params->params.chanspec_list[0]);
+
+		join_params->params.chanspec_num =
+			htod32(join_params->params.chanspec_num);
+		WL_DBG(("join_params->params.chanspec_list[0]= %X, %d channels\n",
+			join_params->params.chanspec_list[0],
+			join_params->params.chanspec_num));
 	}
-	wl->sta_info = (void *)kzalloc(sizeof(*wl->sta_info), GFP_KERNEL);
-	if (unlikely(!wl->sta_info)) {
-		WL_ERR(("sta info  alloc failed\n"));
-		goto init_priv_mem_out;
+}
+
+static s32 wl_update_bss_info(struct wl_priv *wl, struct net_device *ndev, u8 is_roam_done)
+{
+	struct cfg80211_bss *bss;
+	struct wl_bss_info *bi;
+	struct wlc_ssid *ssid;
+	struct bcm_tlv *tim;
+	s32 beacon_interval;
+	s32 dtim_period;
+	size_t ie_len;
+	u8 *ie;
+	u8 *ssidie;
+	u8 *curbssid;
+	s32 err = 0;
+	struct wiphy *wiphy;
+
+	wiphy = wl_to_wiphy(wl);
+
+	if (wl_is_ibssmode(wl, ndev))
+		return err;
+
+	ssid = (struct wlc_ssid *)wl_read_prof(wl, ndev, WL_PROF_SSID);
+	curbssid = wl_read_prof(wl, ndev, WL_PROF_BSSID);
+	bss = cfg80211_get_bss(wiphy, NULL, curbssid,
+		ssid->SSID, ssid->SSID_len, WLAN_CAPABILITY_ESS,
+		WLAN_CAPABILITY_ESS);
+
+	mutex_lock(&wl->usr_sync);
+	if (!bss) {
+		WL_DBG(("Could not find the AP\n"));
+		*(u32 *) wl->extra_buf = htod32(WL_EXTRA_BUF_MAX);
+		err = wldev_ioctl(ndev, WLC_GET_BSS_INFO,
+			wl->extra_buf, WL_EXTRA_BUF_MAX, false);
+		if (unlikely(err)) {
+			WL_ERR(("Could not get bss info %d\n", err));
+			goto update_bss_info_out;
+		}
+		bi = (struct wl_bss_info *)(wl->extra_buf + 4);
+		if (memcmp(bi->BSSID.octet, curbssid, ETHER_ADDR_LEN)) {
+			err = -EIO;
+			goto update_bss_info_out;
+		}
+
+		ie = ((u8 *)bi) + bi->ie_offset;
+		ie_len = bi->ie_length;
+		ssidie = (u8 *)cfg80211_find_ie(WLAN_EID_SSID, ie, ie_len);
+		if (ssidie && ssidie[1] == bi->SSID_len && !ssidie[2] && bi->SSID[0])
+			memcpy(ssidie + 2, bi->SSID, bi->SSID_len);
+
+		err = wl_inform_single_bss(wl, bi, is_roam_done);
+		if (unlikely(err))
+			goto update_bss_info_out;
+
+		ie = ((u8 *)bi) + bi->ie_offset;
+		ie_len = bi->ie_length;
+		beacon_interval = cpu_to_le16(bi->beacon_period);
+	} else {
+		WL_DBG(("Found the AP in the list - BSSID %pM\n", bss->bssid));
+		ie = bss->information_elements;
+		ie_len = bss->len_information_elements;
+		beacon_interval = bss->beacon_interval;
+		cfg80211_put_bss(bss);
 	}
-	wl->afx_hdl = (void *)kzalloc(sizeof(*wl->afx_hdl), GFP_KERNEL);
-	if (unlikely(!wl->afx_hdl)) {
-		WL_ERR(("afx hdl  alloc failed\n"));
-		goto init_priv_mem_out;
+
+	tim = bcm_parse_tlvs(ie, ie_len, WLAN_EID_TIM);
+	if (tim) {
+		dtim_period = tim->data[1];
 	} else {
-		init_completion(&wl->act_frm_scan);
-		INIT_WORK(&wl->afx_hdl->work, wl_cfg80211_afx_handler);
+		/*
+		* active scan was done so we could not get dtim
+		* information out of probe response.
+		* so we speficially query dtim information.
+		*/
+		err = wldev_ioctl(ndev, WLC_GET_DTIMPRD,
+			&dtim_period, sizeof(dtim_period), false);
+		if (unlikely(err)) {
+			WL_ERR(("WLC_GET_DTIMPRD error (%d)\n", err));
+			goto update_bss_info_out;
+		}
+	}
+
+	wl_update_prof(wl, ndev, NULL, &beacon_interval, WL_PROF_BEACONINT);
+	wl_update_prof(wl, ndev, NULL, &dtim_period, WL_PROF_DTIMPERIOD);
+
+update_bss_info_out:
+	mutex_unlock(&wl->usr_sync);
+	return err;
+}
+
+static s32
+wl_bss_roaming_done(struct wl_priv *wl, struct net_device *ndev,
+	const wl_event_msg_t *e, void *data)
+{
+	struct wl_connect_info *conn_info = wl_to_conn(wl);
+	s32 err = 0;
+	u8 *curbssid;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39)
+	struct wl_bss_info *bss_info;
+	struct wiphy *wiphy = wl_to_wiphy(wl);
+	struct ieee80211_supported_band *band;
+	struct ieee80211_channel *notify_channel = NULL;
+	u8 *buf;
+	u16 channel;
+	u32 freq;
+#endif /* LINUX_VERSION > 2.6.39 */
+
+	wl_get_assoc_ies(wl, ndev);
+	wl_update_prof(wl, ndev, NULL, (void *)(e->addr.octet), WL_PROF_BSSID);
+	curbssid = wl_read_prof(wl, ndev, WL_PROF_BSSID);
+	wl_update_bss_info(wl, ndev, 1);
+	wl_update_pmklist(ndev, wl->pmk_list, err);
+
+	if (ap_resp_ie_len) {
+		/* hacked ap_resp_ie to conn_info->resp_ie */
+		memcpy(conn_info->resp_ie, ap_resp_ie, ap_resp_ie_len);
+		conn_info->resp_ie_len = ap_resp_ie_len;
+	}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39)
+	/* channel info for cfg80211_roamed introduced in 2.6.39-rc1 */
+	buf = kzalloc(WL_EXTRA_BUF_MAX, GFP_KERNEL);
+	if (!buf)
+		goto done;
+
+	*(__le32 *)buf = htod32(WL_EXTRA_BUF_MAX);
+	err = wldev_ioctl(ndev, WLC_GET_BSS_INFO, buf, WL_EXTRA_BUF_MAX, false);
+	if (err)
+		goto done;
+
+	bss_info = (struct wl_bss_info *)(buf + 4);
+	channel = bss_info->ctl_ch ? bss_info->ctl_ch :
+		CHSPEC_CHANNEL(wl_chspec_driver_to_host(bss_info->chanspec));
+	if (channel <= CH_MAX_2G_CHANNEL)
+		band = wiphy->bands[IEEE80211_BAND_2GHZ];
+	else
+		band = wiphy->bands[IEEE80211_BAND_5GHZ];
+	freq = ieee80211_channel_to_frequency(channel, band->band);
+	notify_channel = ieee80211_get_channel(wiphy, freq);
+done:
+	kfree(buf);
+#endif /* LINUX_VERSION > 2.6.39 */
+
+	printk("wl_bss_roaming_done succeeded to " MACDBG "\n",
+		MAC2STRDBG((u8*)(&e->addr)));
+
+	cfg80211_roamed(ndev,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39)
+		notify_channel,
+#endif
+		curbssid,
+		conn_info->req_ie, conn_info->req_ie_len,
+		conn_info->resp_ie, conn_info->resp_ie_len, GFP_KERNEL);
+	WL_DBG(("Report roaming result\n"));
+
+	wl_set_drv_status(wl, CONNECTED, ndev);
+
+	return err;
+}
+
+static s32
+wl_bss_connect_done(struct wl_priv *wl, struct net_device *ndev,
+	const wl_event_msg_t *e, void *data, bool completed)
+{
+	struct wl_connect_info *conn_info = wl_to_conn(wl);
+	struct wl_security *sec = wl_read_prof(wl, ndev, WL_PROF_SEC);
+	s32 err = 0;
+	u8 *curbssid = wl_read_prof(wl, ndev, WL_PROF_BSSID);
+	if (!sec) {
+		WL_ERR(("sec is NULL\n"));
+		return -ENODEV;
+	}
+	WL_DBG((" enter\n"));
+#ifdef ESCAN_RESULT_PATCH
+	if (wl_get_drv_status(wl, CONNECTED, ndev)) {
+		if (memcmp(curbssid, connect_req_bssid, ETHER_ADDR_LEN) == 0) {
+			WL_DBG((" Connected event of connected device e=%d s=%d, ignore it\n",
+				ntoh32(e->event_type), ntoh32(e->status)));
+			return err;
+		}
+	}
+	if (memcmp(curbssid, broad_bssid, ETHER_ADDR_LEN) == 0 &&
+		memcmp(broad_bssid, connect_req_bssid, ETHER_ADDR_LEN) != 0) {
+		WL_DBG(("copy bssid\n"));
+		memcpy(curbssid, connect_req_bssid, ETHER_ADDR_LEN);
 	}
+
+#else
+	if (wl->scan_request) {
+		wl_notify_escan_complete(wl, ndev, true, true);
+	}
+#endif /* ESCAN_RESULT_PATCH */
+	if (wl_get_drv_status(wl, CONNECTING, ndev)) {
+	    /*20130704 : continous fail to scan after authentication fail*/
+	    wl_cfg80211_scan_abort(wl);
+		wl_clr_drv_status(wl, CONNECTING, ndev);
+		if (completed) {
+			wl_get_assoc_ies(wl, ndev);
+			wl_update_prof(wl, ndev, NULL, (void *)(e->addr.octet), WL_PROF_BSSID);
+			curbssid = wl_read_prof(wl, ndev, WL_PROF_BSSID);
+			wl_update_bss_info(wl, ndev, 0);
+			wl_update_pmklist(ndev, wl->pmk_list, err);
+			wl_set_drv_status(wl, CONNECTED, ndev);
+			if (ndev != wl_to_prmry_ndev(wl)) {
+				/* reinitialize completion to clear previous count */
+				INIT_COMPLETION(wl->iface_disable);
+			}
+		}
+		cfg80211_connect_result(ndev,
+			curbssid,
+			conn_info->req_ie,
+			conn_info->req_ie_len,
+			conn_info->resp_ie,
+			conn_info->resp_ie_len,
+			completed ? WLAN_STATUS_SUCCESS :
+			(sec->auth_assoc_res_status) ?
+			sec->auth_assoc_res_status :
+			WLAN_STATUS_UNSPECIFIED_FAILURE,
+			GFP_KERNEL);
+		if (completed)
+			WL_INFO(("Report connect result - connection succeeded\n"));
+		else
+			WL_ERR(("Report connect result - connection failed\n"));
+	}
+	return err;
+}
+
+static s32
+wl_notify_mic_status(struct wl_priv *wl, struct net_device *ndev,
+	const wl_event_msg_t *e, void *data)
+{
+	u16 flags = ntoh16(e->flags);
+	enum nl80211_key_type key_type;
+
+	mutex_lock(&wl->usr_sync);
+	if (flags & WLC_EVENT_MSG_GROUP)
+		key_type = NL80211_KEYTYPE_GROUP;
+	else
+		key_type = NL80211_KEYTYPE_PAIRWISE;
+
+	cfg80211_michael_mic_failure(ndev, (u8 *)&e->addr, key_type, -1,
+		NULL, GFP_KERNEL);
+	mutex_unlock(&wl->usr_sync);
+
+	return 0;
+}
+
+#ifdef PNO_SUPPORT
+static s32
+wl_notify_pfn_status(struct wl_priv *wl, struct net_device *ndev,
+	const wl_event_msg_t *e, void *data)
+{
+	WL_ERR((">>> PNO Event\n"));
+
+#ifndef WL_SCHED_SCAN
+	mutex_lock(&wl->usr_sync);
+	/* TODO: Use cfg80211_sched_scan_results(wiphy); */
+	cfg80211_disconnected(ndev, 0, NULL, 0, GFP_KERNEL);
+	mutex_unlock(&wl->usr_sync);
+#else
+	/* If cfg80211 scheduled scan is supported, report the pno results via sched
+	 * scan results
+	 */
+	wl_notify_sched_scan_results(wl, ndev, e, data);
+#endif /* WL_SCHED_SCAN */
 	return 0;
+}
+#endif /* PNO_SUPPORT */
 
-init_priv_mem_out:
-	wl_deinit_priv_mem(wl);
+static s32
+wl_notify_scan_status(struct wl_priv *wl, struct net_device *ndev,
+	const wl_event_msg_t *e, void *data)
+{
+	struct channel_info channel_inform;
+	struct wl_scan_results *bss_list;
+	u32 len = WL_SCAN_BUF_MAX;
+	s32 err = 0;
+	unsigned long flags;
+
+	WL_DBG(("Enter \n"));
+	if (!wl_get_drv_status(wl, SCANNING, ndev)) {
+		WL_ERR(("scan is not ready \n"));
+		return err;
+	}
+	if (wl->iscan_on && wl->iscan_kickstart)
+		return wl_wakeup_iscan(wl_to_iscan(wl));
+
+	mutex_lock(&wl->usr_sync);
+	wl_clr_drv_status(wl, SCANNING, ndev);
+	err = wldev_ioctl(ndev, WLC_GET_CHANNEL, &channel_inform,
+		sizeof(channel_inform), false);
+	if (unlikely(err)) {
+		WL_ERR(("scan busy (%d)\n", err));
+		goto scan_done_out;
+	}
+	channel_inform.scan_channel = dtoh32(channel_inform.scan_channel);
+	if (unlikely(channel_inform.scan_channel)) {
+
+		WL_DBG(("channel_inform.scan_channel (%d)\n",
+			channel_inform.scan_channel));
+	}
+	wl->bss_list = wl->scan_results;
+	bss_list = wl->bss_list;
+	memset(bss_list, 0, len);
+	bss_list->buflen = htod32(len);
+	err = wldev_ioctl(ndev, WLC_SCAN_RESULTS, bss_list, len, false);
+	if (unlikely(err) && unlikely(!wl->scan_suppressed)) {
+		WL_ERR(("%s Scan_results error (%d)\n", ndev->name, err));
+		err = -EINVAL;
+		goto scan_done_out;
+	}
+	bss_list->buflen = dtoh32(bss_list->buflen);
+	bss_list->version = dtoh32(bss_list->version);
+	bss_list->count = dtoh32(bss_list->count);
+
+	err = wl_inform_bss(wl);
+
+scan_done_out:
+	del_timer_sync(&wl->scan_timeout);
+	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
+	if (wl->scan_request) {
+		cfg80211_scan_done(wl->scan_request, false);
+		wl->scan_request = NULL;
+	}
+	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
+	WL_DBG(("cfg80211_scan_done\n"));
+	mutex_unlock(&wl->usr_sync);
+	return err;
+}
+static s32
+wl_frame_get_mgmt(u16 fc, const struct ether_addr *da,
+	const struct ether_addr *sa, const struct ether_addr *bssid,
+	u8 **pheader, u32 *body_len, u8 *pbody)
+{
+	struct dot11_management_header *hdr;
+	u32 totlen = 0;
+	s32 err = 0;
+	u8 *offset;
+	u32 prebody_len = *body_len;
+	switch (fc) {
+		case FC_ASSOC_REQ:
+			/* capability , listen interval */
+			totlen = DOT11_ASSOC_REQ_FIXED_LEN;
+			*body_len += DOT11_ASSOC_REQ_FIXED_LEN;
+			break;
+
+		case FC_REASSOC_REQ:
+			/* capability, listen inteval, ap address */
+			totlen = DOT11_REASSOC_REQ_FIXED_LEN;
+			*body_len += DOT11_REASSOC_REQ_FIXED_LEN;
+			break;
+	}
+	totlen += DOT11_MGMT_HDR_LEN + prebody_len;
+	*pheader = kzalloc(totlen, GFP_KERNEL);
+	if (*pheader == NULL) {
+		WL_ERR(("memory alloc failed \n"));
+		return -ENOMEM;
+	}
+	hdr = (struct dot11_management_header *) (*pheader);
+	hdr->fc = htol16(fc);
+	hdr->durid = 0;
+	hdr->seq = 0;
+	offset = (u8*)(hdr + 1) + (totlen - DOT11_MGMT_HDR_LEN - prebody_len);
+	bcopy((const char*)da, (u8*)&hdr->da, ETHER_ADDR_LEN);
+	bcopy((const char*)sa, (u8*)&hdr->sa, ETHER_ADDR_LEN);
+	bcopy((const char*)bssid, (u8*)&hdr->bssid, ETHER_ADDR_LEN);
+	if ((pbody != NULL) && prebody_len)
+		bcopy((const char*)pbody, offset, prebody_len);
+	*body_len = totlen;
+	return err;
+}
+
+
+void
+wl_stop_wait_next_action_frame(struct wl_priv *wl)
+{
+	if (wl_get_drv_status_all(wl, SENDING_ACT_FRM)) {
+		if (!(wl_get_p2p_status(wl, ACTION_TX_COMPLETED) ||
+			wl_get_p2p_status(wl, ACTION_TX_NOACK)))
+			wl_set_p2p_status(wl, ACTION_TX_COMPLETED);
+
+		WL_DBG(("*** Wake UP ** abort actframe iovar\n"));
+		/* if channel is not zero, "actfame" uses off channel scan.
+		 * So abort scan for off channel completion.
+		 */
+		if (wl->af_sent_channel)
+			wl_cfg80211_scan_abort(wl);
+	}
+#ifdef WL_CFG80211_SYNC_GON
+	else if (wl_get_drv_status_all(wl, WAITING_NEXT_ACT_FRM_LISTEN)) {
+		WL_DBG(("*** Wake UP ** abort listen for next af frame\n"));
+		/* So abort scan to cancel listen */
+		wl_cfg80211_scan_abort(wl);
+	}
+#endif /* WL_CFG80211_SYNC_GON */
+}
+
+
+static s32
+wl_notify_rx_mgmt_frame(struct wl_priv *wl, struct net_device *ndev,
+	const wl_event_msg_t *e, void *data)
+{
+	struct ieee80211_supported_band *band;
+	struct wiphy *wiphy = wl_to_wiphy(wl);
+	struct ether_addr da;
+	struct ether_addr bssid;
+	bool isfree = false;
+	s32 err = 0;
+	s32 freq;
+	struct net_device *dev = NULL;
+	wifi_p2p_pub_act_frame_t *act_frm = NULL;
+	wifi_p2p_action_frame_t *p2p_act_frm = NULL;
+	wifi_p2psd_gas_pub_act_frame_t *sd_act_frm = NULL;
+	wl_event_rx_frame_data_t *rxframe =
+		(wl_event_rx_frame_data_t*)data;
+	u32 event = ntoh32(e->event_type);
+	u8 *mgmt_frame;
+	u8 bsscfgidx = e->bsscfgidx;
+	u32 mgmt_frame_len = ntoh32(e->datalen) - sizeof(wl_event_rx_frame_data_t);
+	u16 channel = ((ntoh16(rxframe->channel) & WL_CHANSPEC_CHAN_MASK));
+
+	memset(&bssid, 0, ETHER_ADDR_LEN);
+
+	if (wl->p2p_net == ndev) {
+		dev = wl_to_prmry_ndev(wl);
+	} else {
+		dev = ndev;
+	}
+
+	if (channel <= CH_MAX_2G_CHANNEL)
+		band = wiphy->bands[IEEE80211_BAND_2GHZ];
+	else
+		band = wiphy->bands[IEEE80211_BAND_5GHZ];
+	if (!band) {
+		WL_ERR(("No valid band"));
+		return -EINVAL;
+	}
+#if LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 38) && !defined(WL_COMPAT_WIRELESS)
+	freq = ieee80211_channel_to_frequency(channel);
+	(void)band->band;
+#else
+	freq = ieee80211_channel_to_frequency(channel, band->band);
+#endif
+	if (event == WLC_E_ACTION_FRAME_RX) {
+		wldev_iovar_getbuf_bsscfg(dev, "cur_etheraddr",
+			NULL, 0, wl->ioctl_buf, WLC_IOCTL_SMLEN, bsscfgidx, &wl->ioctl_buf_sync);
+
+		err = wldev_ioctl(dev, WLC_GET_BSSID, &bssid, ETHER_ADDR_LEN, false);
+		if (err < 0)
+			 WL_ERR(("WLC_GET_BSSID error %d\n", err));
+		memcpy(da.octet, wl->ioctl_buf, ETHER_ADDR_LEN);
+		err = wl_frame_get_mgmt(FC_ACTION, &da, &e->addr, &bssid,
+			&mgmt_frame, &mgmt_frame_len,
+			(u8 *)((wl_event_rx_frame_data_t *)rxframe + 1));
+		if (err < 0) {
+			WL_ERR(("Error in receiving action frame len %d channel %d freq %d\n",
+				mgmt_frame_len, channel, freq));
+			goto exit;
+		}
+		isfree = true;
+		if (wl_cfgp2p_is_pub_action(&mgmt_frame[DOT11_MGMT_HDR_LEN],
+			mgmt_frame_len - DOT11_MGMT_HDR_LEN)) {
+			act_frm = (wifi_p2p_pub_act_frame_t *)
+					(&mgmt_frame[DOT11_MGMT_HDR_LEN]);
+		} else if (wl_cfgp2p_is_p2p_action(&mgmt_frame[DOT11_MGMT_HDR_LEN],
+			mgmt_frame_len - DOT11_MGMT_HDR_LEN)) {
+			p2p_act_frm = (wifi_p2p_action_frame_t *)
+					(&mgmt_frame[DOT11_MGMT_HDR_LEN]);
+			(void) p2p_act_frm;
+		} else if (wl_cfgp2p_is_gas_action(&mgmt_frame[DOT11_MGMT_HDR_LEN],
+			mgmt_frame_len - DOT11_MGMT_HDR_LEN)) {
+
+			sd_act_frm = (wifi_p2psd_gas_pub_act_frame_t *)
+					(&mgmt_frame[DOT11_MGMT_HDR_LEN]);
+			if (sd_act_frm && wl_get_drv_status_all(wl, WAITING_NEXT_ACT_FRM)) {
+				if (wl->next_af_subtype == sd_act_frm->action) {
+					WL_DBG(("We got a right next frame of SD!(%d)\n",
+						sd_act_frm->action));
+					wl_clr_drv_status(wl, WAITING_NEXT_ACT_FRM, ndev);
+
+					/* Stop waiting for next AF. */
+					wl_stop_wait_next_action_frame(wl);
+				}
+			}
+			(void) sd_act_frm;
+		} else {
+			/*
+			 *  if we got normal action frame and ndev is p2p0,
+			 *  we have to change ndev from p2p0 to wlan0
+			 */
+			if (wl->p2p_net == ndev)
+				ndev = wl_to_prmry_ndev(wl);
+		}
+
+		if (act_frm) {
+
+			if (wl_get_drv_status_all(wl, WAITING_NEXT_ACT_FRM)) {
+				if (wl->next_af_subtype == act_frm->subtype) {
+					WL_DBG(("We got a right next frame!(%d)\n",
+						act_frm->subtype));
+					wl_clr_drv_status(wl, WAITING_NEXT_ACT_FRM, ndev);
+
+					/* Stop waiting for next AF. */
+						wl_stop_wait_next_action_frame(wl);
+				}
+			}
+		}
+
+		wl_cfgp2p_print_actframe(false, &mgmt_frame[DOT11_MGMT_HDR_LEN],
+			mgmt_frame_len - DOT11_MGMT_HDR_LEN, channel);
+		/*
+		 * After complete GO Negotiation, roll back to mpc mode
+		 */
+		if (act_frm && ((act_frm->subtype == P2P_PAF_GON_CONF) ||
+			(act_frm->subtype == P2P_PAF_PROVDIS_RSP))) {
+			wldev_iovar_setint(dev, "mpc", 1);
+		}
+		if (act_frm && (act_frm->subtype == P2P_PAF_GON_CONF)) {
+			WL_DBG(("P2P: GO_NEG_PHASE status cleared \n"));
+			wl_clr_p2p_status(wl, GO_NEG_PHASE);
+		}
+	} else {
+		mgmt_frame = (u8 *)((wl_event_rx_frame_data_t *)rxframe + 1);
+
+		/* wpa supplicant use probe request event for restarting another GON Req.
+		 * but it makes GON Req repetition.
+		 * so if src addr of prb req is same as my target device,
+		 * do not send probe request event during sending action frame.
+		 */
+		if (event == WLC_E_P2P_PROBREQ_MSG) {
+			WL_DBG((" Event %s\n", (event == WLC_E_P2P_PROBREQ_MSG) ?
+				"WLC_E_P2P_PROBREQ_MSG":"WLC_E_PROBREQ_MSG"));
+
+
+			/* Filter any P2P probe reqs arriving during the
+			 * GO-NEG Phase
+			 */
+			if (wl->p2p &&
+				wl_get_p2p_status(wl, GO_NEG_PHASE)) {
+				WL_DBG(("Filtering P2P probe_req while "
+					"being in GO-Neg state\n"));
+				return 0;
+			}
+		}
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+	cfg80211_rx_mgmt(ndev, freq, 0, mgmt_frame, mgmt_frame_len, GFP_ATOMIC);
+#else
+	cfg80211_rx_mgmt(ndev, freq, mgmt_frame, mgmt_frame_len, GFP_ATOMIC);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0) */
+
+	WL_DBG(("mgmt_frame_len (%d) , e->datalen (%d), channel (%d), freq (%d)\n",
+		mgmt_frame_len, ntoh32(e->datalen), channel, freq));
+exit:
+	if (isfree)
+		kfree(mgmt_frame);
+	return 0;
+}
+
+#ifdef WL_SCHED_SCAN
+/* If target scan is not reliable, set the below define to "1" to do a
+ * full escan
+ */
+#define FULL_ESCAN_ON_PFN_NET_FOUND		0
+static s32
+wl_notify_sched_scan_results(struct wl_priv *wl, struct net_device *ndev,
+	const wl_event_msg_t *e, void *data)
+{
+	wl_pfn_net_info_t *netinfo, *pnetinfo;
+	struct cfg80211_scan_request request;
+	struct wiphy *wiphy	= wl_to_wiphy(wl);
+	int err = 0;
+	struct cfg80211_ssid ssid[MAX_PFN_LIST_COUNT];
+	struct ieee80211_channel *channel = NULL;
+	int channel_req = 0;
+	int band = 0;
+	struct wl_pfn_scanresults *pfn_result = (struct wl_pfn_scanresults *)data;
+
+	WL_DBG(("Enter\n"));
+
+	if (e->event_type == WLC_E_PFN_NET_LOST) {
+		WL_PNO(("PFN NET LOST event. Do Nothing \n"));
+		return 0;
+	}
+	WL_PNO((">>> PFN NET FOUND event. count:%d \n", pfn_result->count));
+	if (pfn_result->count > 0) {
+		int i;
+
+		memset(&request, 0x00, sizeof(struct cfg80211_scan_request));
+		memset(&ssid, 0x00, sizeof(ssid));
+		request.wiphy = wiphy;
+
+		pnetinfo = (wl_pfn_net_info_t *)(data + sizeof(wl_pfn_scanresults_t)
+				- sizeof(wl_pfn_net_info_t));
+		channel = (struct ieee80211_channel *)kzalloc(
+			(sizeof(struct ieee80211_channel) * MAX_PFN_LIST_COUNT),
+			GFP_KERNEL);
+		if (!channel) {
+			WL_ERR(("No memory"));
+			err = -ENOMEM;
+			goto out_err;
+		}
+
+		for (i = 0; i < pfn_result->count; i++) {
+			netinfo = &pnetinfo[i];
+			if (!netinfo) {
+				WL_ERR(("Invalid netinfo ptr. index:%d", i));
+				err = -EINVAL;
+				goto out_err;
+			}
+			WL_PNO((">>> SSID:%s Channel:%d \n",
+				netinfo->pfnsubnet.SSID, netinfo->pfnsubnet.channel));
+			/* PFN result doesn't have all the info which are required by the supplicant
+			 * (For e.g IEs) Do a target Escan so that sched scan results are reported
+			 * via wl_inform_single_bss in the required format. Escan does require the
+			 * scan request in the form of cfg80211_scan_request. For timebeing, create
+			 * cfg80211_scan_request one out of the received PNO event.
+			 */
+			memcpy(ssid[i].ssid, netinfo->pfnsubnet.SSID,
+				netinfo->pfnsubnet.SSID_len);
+			ssid[i].ssid_len = netinfo->pfnsubnet.SSID_len;
+			request.n_ssids++;
+
+			channel_req = netinfo->pfnsubnet.channel;
+			band = (channel_req <= CH_MAX_2G_CHANNEL) ? NL80211_BAND_2GHZ
+				: NL80211_BAND_5GHZ;
+			channel[i].center_freq = ieee80211_channel_to_frequency(channel_req, band);
+			channel[i].band = band;
+			channel[i].flags |= IEEE80211_CHAN_NO_HT40;
+			request.channels[i] = &channel[i];
+			request.n_channels++;
+		}
+
+		/* assign parsed ssid array */
+		if (request.n_ssids)
+			request.ssids = &ssid[0];
+
+		if (wl_get_drv_status_all(wl, SCANNING)) {
+			/* Abort any on-going scan */
+			wl_notify_escan_complete(wl, ndev, true, true);
+		}
+
+		if (wl_get_p2p_status(wl, DISCOVERY_ON)) {
+			WL_PNO((">>> P2P discovery was ON. Disabling it\n"));
+			err = wl_cfgp2p_discover_enable_search(wl, false);
+			if (unlikely(err)) {
+				wl_clr_drv_status(wl, SCANNING, ndev);
+				goto out_err;
+			}
+		}
+
+		wl_set_drv_status(wl, SCANNING, ndev);
+#if FULL_ESCAN_ON_PFN_NET_FOUND
+		WL_PNO((">>> Doing Full ESCAN on PNO event\n"));
+		err = wl_do_escan(wl, wiphy, ndev, NULL);
+#else
+		WL_PNO((">>> Doing targeted ESCAN on PNO event\n"));
+		err = wl_do_escan(wl, wiphy, ndev, &request);
+#endif
+		if (err) {
+			wl_clr_drv_status(wl, SCANNING, ndev);
+			goto out_err;
+		}
+		wl->sched_scan_running = TRUE;
+	}
+	else {
+		WL_ERR(("FALSE PNO Event. (pfn_count == 0) \n"));
+	}
+out_err:
+	if (channel)
+		kfree(channel);
+	return err;
+}
+#endif /* WL_SCHED_SCAN */
+
+static void wl_init_conf(struct wl_conf *conf)
+{
+	WL_DBG(("Enter \n"));
+	conf->frag_threshold = (u32)-1;
+	conf->rts_threshold = (u32)-1;
+	conf->retry_short = (u32)-1;
+	conf->retry_long = (u32)-1;
+	conf->tx_power = -1;
+}
+
+static void wl_init_prof(struct wl_priv *wl, struct net_device *ndev)
+{
+	unsigned long flags;
+	struct wl_profile *profile = wl_get_profile_by_netdev(wl, ndev);
+
+	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
+	memset(profile, 0, sizeof(struct wl_profile));
+	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
+}
+
+static void wl_init_event_handler(struct wl_priv *wl)
+{
+	memset(wl->evt_handler, 0, sizeof(wl->evt_handler));
+
+	wl->evt_handler[WLC_E_SCAN_COMPLETE] = wl_notify_scan_status;
+	wl->evt_handler[WLC_E_AUTH] = wl_notify_connect_status;
+	wl->evt_handler[WLC_E_ASSOC] = wl_notify_connect_status;
+	wl->evt_handler[WLC_E_LINK] = wl_notify_connect_status;
+	wl->evt_handler[WLC_E_DEAUTH_IND] = wl_notify_connect_status;
+	wl->evt_handler[WLC_E_DEAUTH] = wl_notify_connect_status;
+	wl->evt_handler[WLC_E_DISASSOC_IND] = wl_notify_connect_status;
+	wl->evt_handler[WLC_E_ASSOC_IND] = wl_notify_connect_status;
+	wl->evt_handler[WLC_E_REASSOC_IND] = wl_notify_connect_status;
+	wl->evt_handler[WLC_E_ROAM] = wl_notify_roaming_status;
+	wl->evt_handler[WLC_E_MIC_ERROR] = wl_notify_mic_status;
+	wl->evt_handler[WLC_E_SET_SSID] = wl_notify_connect_status;
+	wl->evt_handler[WLC_E_ACTION_FRAME_RX] = wl_notify_rx_mgmt_frame;
+	wl->evt_handler[WLC_E_PROBREQ_MSG] = wl_notify_rx_mgmt_frame;
+	wl->evt_handler[WLC_E_P2P_PROBREQ_MSG] = wl_notify_rx_mgmt_frame;
+	wl->evt_handler[WLC_E_P2P_DISC_LISTEN_COMPLETE] = wl_cfgp2p_listen_complete;
+	wl->evt_handler[WLC_E_ACTION_FRAME_COMPLETE] = wl_cfgp2p_action_tx_complete;
+	wl->evt_handler[WLC_E_ACTION_FRAME_OFF_CHAN_COMPLETE] = wl_cfgp2p_action_tx_complete;
+#ifdef PNO_SUPPORT
+	wl->evt_handler[WLC_E_PFN_NET_FOUND] = wl_notify_pfn_status;
+#endif /* PNO_SUPPORT */
+#ifdef WLTDLS
+	wl->evt_handler[WLC_E_TDLS_PEER_EVENT] = wl_tdls_event_handler;
+#endif /* WLTDLS */
+}
+
+#if defined(STATIC_WL_PRIV_STRUCT)
+static void
+wl_init_escan_result_buf(struct wl_priv *wl)
+{
+	wl->escan_info.escan_buf = dhd_os_prealloc(NULL, DHD_PREALLOC_WIPHY_ESCAN0, 0);
+	bzero(wl->escan_info.escan_buf, ESCAN_BUF_SIZE);
+}
+
+static void
+wl_deinit_escan_result_buf(struct wl_priv *wl)
+{
+	wl->escan_info.escan_buf = NULL;
+
+}
+#endif /* STATIC_WL_PRIV_STRUCT */
+
+static s32 wl_init_priv_mem(struct wl_priv *wl)
+{
+	WL_DBG(("Enter \n"));
+	wl->scan_results = (void *)kzalloc(WL_SCAN_BUF_MAX, GFP_KERNEL);
+	if (unlikely(!wl->scan_results)) {
+		WL_ERR(("Scan results alloc failed\n"));
+		goto init_priv_mem_out;
+	}
+	wl->conf = (void *)kzalloc(sizeof(*wl->conf), GFP_KERNEL);
+	if (unlikely(!wl->conf)) {
+		WL_ERR(("wl_conf alloc failed\n"));
+		goto init_priv_mem_out;
+	}
+	wl->scan_req_int =
+	    (void *)kzalloc(sizeof(*wl->scan_req_int), GFP_KERNEL);
+	if (unlikely(!wl->scan_req_int)) {
+		WL_ERR(("Scan req alloc failed\n"));
+		goto init_priv_mem_out;
+	}
+	wl->ioctl_buf = (void *)kzalloc(WLC_IOCTL_MAXLEN, GFP_KERNEL);
+	if (unlikely(!wl->ioctl_buf)) {
+		WL_ERR(("Ioctl buf alloc failed\n"));
+		goto init_priv_mem_out;
+	}
+	wl->escan_ioctl_buf = (void *)kzalloc(WLC_IOCTL_MAXLEN, GFP_KERNEL);
+	if (unlikely(!wl->escan_ioctl_buf)) {
+		WL_ERR(("Ioctl buf alloc failed\n"));
+		goto init_priv_mem_out;
+	}
+	wl->extra_buf = (void *)kzalloc(WL_EXTRA_BUF_MAX, GFP_KERNEL);
+	if (unlikely(!wl->extra_buf)) {
+		WL_ERR(("Extra buf alloc failed\n"));
+		goto init_priv_mem_out;
+	}
+	wl->iscan = (void *)kzalloc(sizeof(*wl->iscan), GFP_KERNEL);
+	if (unlikely(!wl->iscan)) {
+		WL_ERR(("Iscan buf alloc failed\n"));
+		goto init_priv_mem_out;
+	}
+	wl->pmk_list = (void *)kzalloc(sizeof(*wl->pmk_list), GFP_KERNEL);
+	if (unlikely(!wl->pmk_list)) {
+		WL_ERR(("pmk list alloc failed\n"));
+		goto init_priv_mem_out;
+	}
+	wl->sta_info = (void *)kzalloc(sizeof(*wl->sta_info), GFP_KERNEL);
+	if (unlikely(!wl->sta_info)) {
+		WL_ERR(("sta info  alloc failed\n"));
+		goto init_priv_mem_out;
+	}
+
+#if defined(STATIC_WL_PRIV_STRUCT)
+	wl->conn_info = (void *)kzalloc(sizeof(*wl->conn_info), GFP_KERNEL);
+	if (unlikely(!wl->conn_info)) {
+		WL_ERR(("wl->conn_info  alloc failed\n"));
+		goto init_priv_mem_out;
+	}
+	wl->ie = (void *)kzalloc(sizeof(*wl->ie), GFP_KERNEL);
+	if (unlikely(!wl->ie)) {
+		WL_ERR(("wl->ie  alloc failed\n"));
+		goto init_priv_mem_out;
+	}
+	wl_init_escan_result_buf(wl);
+#endif /* STATIC_WL_PRIV_STRUCT */
+	wl->afx_hdl = (void *)kzalloc(sizeof(*wl->afx_hdl), GFP_KERNEL);
+	if (unlikely(!wl->afx_hdl)) {
+		WL_ERR(("afx hdl  alloc failed\n"));
+		goto init_priv_mem_out;
+	} else {
+		init_completion(&wl->act_frm_scan);
+		init_completion(&wl->wait_next_af);
+
+		INIT_WORK(&wl->afx_hdl->work, wl_cfg80211_afx_handler);
+	}
+	return 0;
+
+init_priv_mem_out:
+	wl_deinit_priv_mem(wl);
+
+	return -ENOMEM;
+}
+
+static void wl_deinit_priv_mem(struct wl_priv *wl)
+{
+	kfree(wl->scan_results);
+	wl->scan_results = NULL;
+	kfree(wl->conf);
+	wl->conf = NULL;
+	kfree(wl->scan_req_int);
+	wl->scan_req_int = NULL;
+	kfree(wl->ioctl_buf);
+	wl->ioctl_buf = NULL;
+	kfree(wl->escan_ioctl_buf);
+	wl->escan_ioctl_buf = NULL;
+	kfree(wl->extra_buf);
+	wl->extra_buf = NULL;
+	kfree(wl->iscan);
+	wl->iscan = NULL;
+	kfree(wl->pmk_list);
+	wl->pmk_list = NULL;
+	kfree(wl->sta_info);
+	wl->sta_info = NULL;
+#if defined(STATIC_WL_PRIV_STRUCT)
+	kfree(wl->conn_info);
+	wl->conn_info = NULL;
+	kfree(wl->ie);
+	wl->ie = NULL;
+	wl_deinit_escan_result_buf(wl);
+#endif /* STATIC_WL_PRIV_STRUCT */
+	if (wl->afx_hdl) {
+		cancel_work_sync(&wl->afx_hdl->work);
+		kfree(wl->afx_hdl);
+		wl->afx_hdl = NULL;
+	}
+
+	if (wl->ap_info) {
+		kfree(wl->ap_info->wpa_ie);
+		kfree(wl->ap_info->rsn_ie);
+		kfree(wl->ap_info->wps_ie);
+		kfree(wl->ap_info);
+		wl->ap_info = NULL;
+	}
+}
+
+static s32 wl_create_event_handler(struct wl_priv *wl)
+{
+	int ret = 0;
+	WL_DBG(("Enter \n"));
+
+	/* Do not use DHD in cfg driver */
+	wl->event_tsk.thr_pid = -1;
+
+	PROC_START(wl_event_handler, wl, &wl->event_tsk, 0, "wl_event_handler");
+	if (wl->event_tsk.thr_pid < 0)
+		ret = -ENOMEM;
+	return ret;
+}
+
+static void wl_destroy_event_handler(struct wl_priv *wl)
+{
+	if (wl->event_tsk.thr_pid >= 0)
+		PROC_STOP(&wl->event_tsk);
+}
+
+static void wl_term_iscan(struct wl_priv *wl)
+{
+	struct wl_iscan_ctrl *iscan = wl_to_iscan(wl);
+	WL_TRACE(("In\n"));
+	if (wl->iscan_on && iscan->tsk) {
+		iscan->state = WL_ISCAN_STATE_IDLE;
+		WL_INFO(("SIGTERM\n"));
+		send_sig(SIGTERM, iscan->tsk, 1);
+		WL_DBG(("kthread_stop\n"));
+		kthread_stop(iscan->tsk);
+		iscan->tsk = NULL;
+	}
+}
+
+static void wl_notify_iscan_complete(struct wl_iscan_ctrl *iscan, bool aborted)
+{
+	struct wl_priv *wl = iscan_to_wl(iscan);
+	struct net_device *ndev = wl_to_prmry_ndev(wl);
+	unsigned long flags;
+
+	WL_DBG(("Enter \n"));
+	if (!wl_get_drv_status(wl, SCANNING, ndev)) {
+		wl_clr_drv_status(wl, SCANNING, ndev);
+		WL_ERR(("Scan complete while device not scanning\n"));
+		return;
+	}
+	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
+	wl_clr_drv_status(wl, SCANNING, ndev);
+	if (likely(wl->scan_request)) {
+		cfg80211_scan_done(wl->scan_request, aborted);
+		wl->scan_request = NULL;
+	}
+	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
+	wl->iscan_kickstart = false;
+}
+
+static s32 wl_wakeup_iscan(struct wl_iscan_ctrl *iscan)
+{
+	if (likely(iscan->state != WL_ISCAN_STATE_IDLE)) {
+		WL_DBG(("wake up iscan\n"));
+		up(&iscan->sync);
+		return 0;
+	}
+
+	return -EIO;
+}
+
+static s32
+wl_get_iscan_results(struct wl_iscan_ctrl *iscan, u32 *status,
+	struct wl_scan_results **bss_list)
+{
+	struct wl_iscan_results list;
+	struct wl_scan_results *results;
+	struct wl_iscan_results *list_buf;
+	s32 err = 0;
+
+	WL_DBG(("Enter \n"));
+	memset(iscan->scan_buf, 0, WL_ISCAN_BUF_MAX);
+	list_buf = (struct wl_iscan_results *)iscan->scan_buf;
+	results = &list_buf->results;
+	results->buflen = WL_ISCAN_RESULTS_FIXED_SIZE;
+	results->version = 0;
+	results->count = 0;
+
+	memset(&list, 0, sizeof(list));
+	list.results.buflen = htod32(WL_ISCAN_BUF_MAX);
+	err = wldev_iovar_getbuf(iscan->dev, "iscanresults", &list,
+		WL_ISCAN_RESULTS_FIXED_SIZE, iscan->scan_buf,
+		WL_ISCAN_BUF_MAX, NULL);
+	if (unlikely(err)) {
+		WL_ERR(("error (%d)\n", err));
+		return err;
+	}
+	results->buflen = dtoh32(results->buflen);
+	results->version = dtoh32(results->version);
+	results->count = dtoh32(results->count);
+	WL_DBG(("results->count = %d\n", results->count));
+	WL_DBG(("results->buflen = %d\n", results->buflen));
+	*status = dtoh32(list_buf->status);
+	*bss_list = results;
+
+	return err;
+}
+
+static s32 wl_iscan_done(struct wl_priv *wl)
+{
+	struct wl_iscan_ctrl *iscan = wl->iscan;
+	s32 err = 0;
+
+	iscan->state = WL_ISCAN_STATE_IDLE;
+	mutex_lock(&wl->usr_sync);
+	wl_inform_bss(wl);
+	wl_notify_iscan_complete(iscan, false);
+	mutex_unlock(&wl->usr_sync);
+
+	return err;
+}
+
+static s32 wl_iscan_pending(struct wl_priv *wl)
+{
+	struct wl_iscan_ctrl *iscan = wl->iscan;
+	s32 err = 0;
+
+	/* Reschedule the timer */
+	mod_timer(&iscan->timer, jiffies + msecs_to_jiffies(iscan->timer_ms));
+	iscan->timer_on = 1;
+
+	return err;
+}
+
+static s32 wl_iscan_inprogress(struct wl_priv *wl)
+{
+	struct wl_iscan_ctrl *iscan = wl->iscan;
+	s32 err = 0;
+
+	mutex_lock(&wl->usr_sync);
+	wl_inform_bss(wl);
+	wl_run_iscan(iscan, NULL, WL_SCAN_ACTION_CONTINUE);
+	mutex_unlock(&wl->usr_sync);
+	/* Reschedule the timer */
+	mod_timer(&iscan->timer, jiffies +  msecs_to_jiffies(iscan->timer_ms));
+	iscan->timer_on = 1;
+
+	return err;
+}
+
+static s32 wl_iscan_aborted(struct wl_priv *wl)
+{
+	struct wl_iscan_ctrl *iscan = wl->iscan;
+	s32 err = 0;
+
+	iscan->state = WL_ISCAN_STATE_IDLE;
+	mutex_lock(&wl->usr_sync);
+	wl_notify_iscan_complete(iscan, true);
+	mutex_unlock(&wl->usr_sync);
+
+	return err;
+}
+
+static s32 wl_iscan_thread(void *data)
+{
+	struct wl_iscan_ctrl *iscan = (struct wl_iscan_ctrl *)data;
+	struct wl_priv *wl = iscan_to_wl(iscan);
+	u32 status;
+	int err = 0;
+
+	allow_signal(SIGTERM);
+	status = WL_SCAN_RESULTS_PARTIAL;
+	while (likely(!down_interruptible(&iscan->sync))) {
+		if (kthread_should_stop())
+			break;
+		if (iscan->timer_on) {
+			del_timer_sync(&iscan->timer);
+			iscan->timer_on = 0;
+		}
+		mutex_lock(&wl->usr_sync);
+		err = wl_get_iscan_results(iscan, &status, &wl->bss_list);
+		if (unlikely(err)) {
+			status = WL_SCAN_RESULTS_ABORTED;
+			WL_ERR(("Abort iscan\n"));
+		}
+		mutex_unlock(&wl->usr_sync);
+		iscan->iscan_handler[status] (wl);
+	}
+	if (iscan->timer_on) {
+		del_timer_sync(&iscan->timer);
+		iscan->timer_on = 0;
+	}
+	WL_DBG(("was terminated\n"));
+
+	return 0;
+}
+
+static void wl_scan_timeout(unsigned long data)
+{
+	wl_event_msg_t msg;
+	struct wl_priv *wl = (struct wl_priv *)data;
+
+	if (!(wl->scan_request)) {
+		WL_ERR(("timer expired but no scan request\n"));
+		return;
+	}
+	bzero(&msg, sizeof(wl_event_msg_t));
+	WL_ERR(("timer expired\n"));
+	if (wl->escan_on) {
+		msg.event_type = hton32(WLC_E_ESCAN_RESULT);
+		msg.status = hton32(WLC_E_STATUS_TIMEOUT);
+		msg.reason = 0xFFFFFFFF;
+		wl_cfg80211_event(wl_to_prmry_ndev(wl), &msg, NULL);
+	} else {
+		/* Need to check it try to access SDIO */
+		WL_ERR(("SCAN Timeout(ISCAN)\n"));
+		wl_notify_iscan_complete(wl_to_iscan(wl), true);
+	}
+}
+
+static void wl_iscan_timer(unsigned long data)
+{
+	struct wl_iscan_ctrl *iscan = (struct wl_iscan_ctrl *)data;
+
+	if (iscan) {
+		iscan->timer_on = 0;
+		WL_DBG(("timer expired\n"));
+		wl_wakeup_iscan(iscan);
+	}
+}
+
+static s32 wl_invoke_iscan(struct wl_priv *wl)
+{
+	struct wl_iscan_ctrl *iscan = wl_to_iscan(wl);
+	int err = 0;
+
+	if (wl->iscan_on && !iscan->tsk) {
+		iscan->state = WL_ISCAN_STATE_IDLE;
+		sema_init(&iscan->sync, 0);
+		iscan->tsk = kthread_run(wl_iscan_thread, iscan, "wl_iscan");
+		if (IS_ERR(iscan->tsk)) {
+			WL_ERR(("Could not create iscan thread\n"));
+			iscan->tsk = NULL;
+			return -ENOMEM;
+		}
+	}
+
+	return err;
+}
+
+static void wl_init_iscan_handler(struct wl_iscan_ctrl *iscan)
+{
+	memset(iscan->iscan_handler, 0, sizeof(iscan->iscan_handler));
+	iscan->iscan_handler[WL_SCAN_RESULTS_SUCCESS] = wl_iscan_done;
+	iscan->iscan_handler[WL_SCAN_RESULTS_PARTIAL] = wl_iscan_inprogress;
+	iscan->iscan_handler[WL_SCAN_RESULTS_PENDING] = wl_iscan_pending;
+	iscan->iscan_handler[WL_SCAN_RESULTS_ABORTED] = wl_iscan_aborted;
+	iscan->iscan_handler[WL_SCAN_RESULTS_NO_MEM] = wl_iscan_aborted;
+}
+
+static s32
+wl_cfg80211_netdev_notifier_call(struct notifier_block * nb,
+	unsigned long state,
+	void *ndev)
+{
+	struct net_device *dev = ndev;
+	struct wireless_dev *wdev = dev->ieee80211_ptr;
+	struct wl_priv *wl = wlcfg_drv_priv;
+	int refcnt = 0;
+
+	WL_DBG(("Enter \n"));
+	if (!wdev || !wl || dev == wl_to_prmry_ndev(wl))
+		return NOTIFY_DONE;
+	switch (state) {
+		case NETDEV_DOWN:
+			while (work_pending(&wdev->cleanup_work) && refcnt < 100) {
+				if (refcnt%5 == 0)
+					WL_ERR(("[NETDEV_DOWN] work_pending (%d th)\n", refcnt));
+				set_current_state(TASK_INTERRUPTIBLE);
+				schedule_timeout(100);
+				set_current_state(TASK_RUNNING);
+				refcnt++;
+			}
+			break;
+
+		case NETDEV_UNREGISTER:
+			/* after calling list_del_rcu(&wdev->list) */
+			wl_dealloc_netinfo(wl, ndev);
+			break;
+		case NETDEV_GOING_DOWN:
+			/* At NETDEV_DOWN state, wdev_cleanup_work work will be called.
+			*  In front of door, the function checks
+			*  whether current scan is working or not.
+			*  If the scanning is still working, wdev_cleanup_work call WARN_ON and
+			*  make the scan done forcibly.
+			*/
+			if (wl_get_drv_status(wl, SCANNING, dev)) {
+				if (wl->escan_on) {
+					wl_notify_escan_complete(wl, dev, true, true);
+				}
+			}
+			break;
+	}
+	return NOTIFY_DONE;
+}
+static struct notifier_block wl_cfg80211_netdev_notifier = {
+	.notifier_call = wl_cfg80211_netdev_notifier_call,
+};
+
+static s32 wl_notify_escan_complete(struct wl_priv *wl,
+	struct net_device *ndev,
+	bool aborted, bool fw_abort)
+{
+	wl_scan_params_t *params = NULL;
+	s32 params_size = 0;
+	s32 err = BCME_OK;
+	unsigned long flags;
+	struct net_device *dev;
+
+	WL_DBG(("Enter \n"));
+	if (!ndev) {
+		WL_ERR(("ndev is null\n"));
+		return err;
+	}
+
+	if (wl->escan_info.ndev != ndev) {
+		WL_ERR(("ndev is different %p %p\n", wl->escan_info.ndev, ndev));
+		return err;
+	}
+
+	if (wl->scan_request) {
+		if (wl->scan_request->dev == wl->p2p_net)
+			dev = wl_to_prmry_ndev(wl);
+		else
+			dev = wl->scan_request->dev;
+	}
+	else {
+		WL_DBG(("wl->scan_request is NULL may be internal scan."
+			"doing scan_abort for ndev %p primary %p p2p_net %p",
+				ndev, wl_to_prmry_ndev(wl), wl->p2p_net));
+		dev = ndev;
+	}
+	if (fw_abort && !in_atomic()) {
+		/* Our scan params only need space for 1 channel and 0 ssids */
+		params = wl_cfg80211_scan_alloc_params(-1, 0, &params_size);
+		if (params == NULL) {
+			WL_ERR(("scan params allocation failed \n"));
+			err = -ENOMEM;
+		} else {
+			/* Do a scan abort to stop the driver's scan engine */
+			err = wldev_ioctl(dev, WLC_SCAN, params, params_size, true);
+			if (err < 0) {
+				WL_ERR(("scan abort  failed \n"));
+			}
+		}
+	}
+	if (timer_pending(&wl->scan_timeout))
+		del_timer_sync(&wl->scan_timeout);
+#if defined(ESCAN_RESULT_PATCH)
+	if (likely(wl->scan_request)) {
+		wl->bss_list = wl_escan_get_buf(wl, aborted);
+		wl_inform_bss(wl);
+	}
+#endif /* ESCAN_RESULT_PATCH */
+	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
+#ifdef WL_SCHED_SCAN
+	if (wl->sched_scan_req && !wl->scan_request) {
+		WL_PNO((">>> REPORTING SCHED SCAN RESULTS \n"));
+		if (aborted)
+			cfg80211_sched_scan_stopped(wl->sched_scan_req->wiphy);
+		else
+			cfg80211_sched_scan_results(wl->sched_scan_req->wiphy);
+		wl->sched_scan_running = FALSE;
+		wl->sched_scan_req = NULL;
+	}
+#endif /* WL_SCHED_SCAN */
+	if (likely(wl->scan_request)) {
+		cfg80211_scan_done(wl->scan_request, aborted);
+		wl->scan_request = NULL;
+	}
+	if (p2p_is_on(wl))
+		wl_clr_p2p_status(wl, SCANNING);
+	wl_clr_drv_status(wl, SCANNING, dev);
+	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
+	if (params)
+		kfree(params);
+	return err;
+}
+
+static s32 wl_escan_handler(struct wl_priv *wl,
+	struct net_device *ndev,
+	const wl_event_msg_t *e, void *data)
+{
+	s32 err = BCME_OK;
+	s32 status = ntoh32(e->status);
+	wl_bss_info_t *bi;
+	wl_escan_result_t *escan_result;
+	wl_bss_info_t *bss = NULL;
+	wl_scan_results_t *list;
+	wifi_p2p_ie_t * p2p_ie;
+	u32 bi_length;
+	u32 i;
+	u8 *p2p_dev_addr = NULL;
+
+	WL_DBG((" enter event type : %d, status : %d \n",
+		ntoh32(e->event_type), ntoh32(e->status)));
+
+	mutex_lock(&wl->usr_sync);
+	/* P2P SCAN is coming from primary interface */
+	if (wl_get_p2p_status(wl, SCANNING)) {
+		if (wl_get_drv_status_all(wl, SENDING_ACT_FRM))
+			ndev = wl->afx_hdl->dev;
+		else
+			ndev = wl->escan_info.ndev;
+
+	}
+	if (!ndev || !wl->escan_on ||
+		(!wl_get_drv_status(wl, SCANNING, ndev) &&
+		!wl->sched_scan_running)) {
+		WL_ERR(("escan is not ready ndev %p wl->escan_on %d"
+			" drv_status 0x%x e_type %d e_states %d\n",
+			ndev, wl->escan_on, wl_get_drv_status(wl, SCANNING, ndev),
+			ntoh32(e->event_type), ntoh32(e->status)));
+		goto exit;
+	}
+	escan_result = (wl_escan_result_t *)data;
+
+	if (status == WLC_E_STATUS_PARTIAL) {
+		WL_INFO(("WLC_E_STATUS_PARTIAL \n"));
+		if (!escan_result) {
+			WL_ERR(("Invalid escan result (NULL pointer)\n"));
+			goto exit;
+		}
+		if (dtoh16(escan_result->bss_count) != 1) {
+			WL_ERR(("Invalid bss_count %d: ignoring\n", escan_result->bss_count));
+			goto exit;
+		}
+		bi = escan_result->bss_info;
+		if (!bi) {
+			WL_ERR(("Invalid escan bss info (NULL pointer)\n"));
+			goto exit;
+		}
+		bi_length = dtoh32(bi->length);
+		if (bi_length != (dtoh32(escan_result->buflen) - WL_ESCAN_RESULTS_FIXED_SIZE)) {
+			WL_ERR(("Invalid bss_info length %d: ignoring\n", bi_length));
+			goto exit;
+		}
+		if (wl_escan_check_sync_id(status, escan_result->sync_id,
+			wl->escan_info.cur_sync_id) < 0)
+			goto exit;
+
+		if (!(wl_to_wiphy(wl)->interface_modes & BIT(NL80211_IFTYPE_ADHOC))) {
+			if (dtoh16(bi->capability) & DOT11_CAP_IBSS) {
+				WL_DBG(("Ignoring IBSS result\n"));
+				goto exit;
+			}
+		}
+
+		if (wl_get_drv_status_all(wl, FINDING_COMMON_CHANNEL)) {
+			p2p_dev_addr = wl_cfgp2p_retreive_p2p_dev_addr(bi, bi_length);
+//			if (p2p_dev_addr && !memcmp(p2p_dev_addr,
+			if (p2p_dev_addr && wl->afx_hdl &&!memcmp(p2p_dev_addr,
+				wl->afx_hdl->tx_dst_addr.octet, ETHER_ADDR_LEN)) {
+				s32 channel = wf_chspec_ctlchan(
+					wl_chspec_driver_to_host(bi->chanspec));
+
+				if ((channel > MAXCHANNEL) || (channel <= 0))
+					channel = WL_INVALID;
+				else
+					WL_ERR(("ACTION FRAME SCAN : Peer " MACDBG " found,"
+						" channel : %d\n",
+						MAC2STRDBG(wl->afx_hdl->tx_dst_addr.octet),
+						channel));
+
+				wl_clr_p2p_status(wl, SCANNING);
+				wl->afx_hdl->peer_chan = channel;
+				complete(&wl->act_frm_scan);
+				goto exit;
+			}
+
+		} else {
+			int cur_len = WL_SCAN_RESULTS_FIXED_SIZE;
+			list = wl_escan_get_buf(wl, FALSE);
+#if defined(WLP2P) && defined(WL_ENABLE_P2P_IF)
+			if (wl->p2p_net && wl->scan_request &&
+				wl->scan_request->dev == wl->p2p_net) {
+#else
+			if (p2p_is_on(wl) && p2p_scan(wl)) {
+#endif
+#ifdef WL_HOST_BAND_MGMT
+				s32 channel = 0;
+				s32 channel_band = 0;
+#endif /* WL_HOST_BAND_MGMT */
+				/* p2p scan && allow only probe response */
+#if 0
+				if (bi->flags & WL_BSS_FLAGS_FROM_BEACON)
+#else
+				if((wl->p2p->search_state != WL_P2P_DISC_ST_SCAN) && (bi->flags & WL_BSS_FLAGS_FROM_BEACON))
+#endif
+					goto exit;
+				if ((p2p_ie = wl_cfgp2p_find_p2pie(((u8 *) bi) + bi->ie_offset,
+					bi->ie_length)) == NULL) {
+						WL_ERR(("Couldn't find P2PIE in probe"
+							" response/beacon\n"));
+						goto exit;
+				}
+#ifdef WL_HOST_BAND_MGMT
+				channel = CHSPEC_CHANNEL(wl_chspec_driver_to_host(bi->chanspec));
+				channel_band = (channel > CH_MAX_2G_CHANNEL) ?
+				WLC_BAND_5G : WLC_BAND_2G;
+
+
+				if ((wl->curr_band == WLC_BAND_5G) &&
+					(channel_band == WLC_BAND_2G)) {
+					/* Avoid sending the GO results in band conflict */
+					if (wl_cfgp2p_retreive_p2pattrib(p2p_ie,
+						P2P_SEID_GROUP_ID) != NULL)
+						goto exit;
+				}
+#endif /* WL_HOST_BAND_MGMT */
+			}
+			for (i = 0; i < list->count; i++) {
+				bss = bss ? (wl_bss_info_t *)((uintptr)bss + dtoh32(bss->length))
+					: list->bss_info;
+
+				if (!bcmp(&bi->BSSID, &bss->BSSID, ETHER_ADDR_LEN) &&
+					(CHSPEC_BAND(wl_chspec_driver_to_host(bi->chanspec))
+					== CHSPEC_BAND(wl_chspec_driver_to_host(bss->chanspec))) &&
+					bi->SSID_len == bss->SSID_len &&
+					!bcmp(bi->SSID, bss->SSID, bi->SSID_len)) {
+
+					/* do not allow beacon data to update
+					*the data recd from a probe response
+					*/
+					if (!(bss->flags & WL_BSS_FLAGS_FROM_BEACON) &&
+						(bi->flags & WL_BSS_FLAGS_FROM_BEACON))
+						goto exit;
+
+					WL_DBG(("%s("MACDBG"), i=%d prev: RSSI %d"
+						" flags 0x%x, new: RSSI %d flags 0x%x\n",
+						bss->SSID, MAC2STRDBG(bi->BSSID.octet), i,
+						bss->RSSI, bss->flags, bi->RSSI, bi->flags));
+
+					if ((bss->flags & WL_BSS_FLAGS_RSSI_ONCHANNEL) ==
+						(bi->flags & WL_BSS_FLAGS_RSSI_ONCHANNEL)) {
+						/* preserve max RSSI if the measurements are
+						* both on-channel or both off-channel
+						*/
+						WL_SCAN(("%s("MACDBG"), same onchan"
+						", RSSI: prev %d new %d\n",
+						bss->SSID, MAC2STRDBG(bi->BSSID.octet),
+						bss->RSSI, bi->RSSI));
+						bi->RSSI = MAX(bss->RSSI, bi->RSSI);
+					} else if ((bss->flags & WL_BSS_FLAGS_RSSI_ONCHANNEL) &&
+						(bi->flags & WL_BSS_FLAGS_RSSI_ONCHANNEL) == 0) {
+						/* preserve the on-channel rssi measurement
+						* if the new measurement is off channel
+						*/
+						WL_SCAN(("%s("MACDBG"), prev onchan"
+						", RSSI: prev %d new %d\n",
+						bss->SSID, MAC2STRDBG(bi->BSSID.octet),
+						bss->RSSI, bi->RSSI));
+						bi->RSSI = bss->RSSI;
+						bi->flags |= WL_BSS_FLAGS_RSSI_ONCHANNEL;
+					}
+					if (dtoh32(bss->length) != bi_length) {
+						u32 prev_len = dtoh32(bss->length);
+
+						WL_SCAN(("bss info replacement"
+							" is occured(bcast:%d->probresp%d)\n",
+							bss->ie_length, bi->ie_length));
+						WL_DBG(("%s("MACDBG"), replacement!(%d -> %d)\n",
+						bss->SSID, MAC2STRDBG(bi->BSSID.octet),
+						prev_len, bi_length));
+
+						if (list->buflen - prev_len + bi_length
+							> ESCAN_BUF_SIZE) {
+							WL_ERR(("Buffer is too small: keep the"
+								" previous result of this AP\n"));
+							/* Only update RSSI */
+							bss->RSSI = bi->RSSI;
+							bss->flags |= (bi->flags
+								& WL_BSS_FLAGS_RSSI_ONCHANNEL);
+							goto exit;
+						}
+
+						if (i < list->count - 1) {
+							/* memory copy required by this case only */
+							memmove((u8 *)bss + bi_length,
+								(u8 *)bss + prev_len,
+								list->buflen - cur_len - prev_len);
+						}
+						list->buflen -= prev_len;
+						list->buflen += bi_length;
+					}
+					list->version = dtoh32(bi->version);
+					memcpy((u8 *)bss, (u8 *)bi, bi_length);
+					goto exit;
+				}
+				cur_len += dtoh32(bss->length);
+			}
+			if (bi_length > ESCAN_BUF_SIZE - list->buflen) {
+				WL_ERR(("Buffer is too small: ignoring\n"));
+				goto exit;
+			}
+
+			memcpy(&(((char *)list)[list->buflen]), bi, bi_length);
+			list->version = dtoh32(bi->version);
+			list->buflen += bi_length;
+			list->count++;
 
-	return -ENOMEM;
-}
+		}
 
-static void wl_deinit_priv_mem(struct wl_priv *wl)
-{
-	kfree(wl->scan_results);
-	wl->scan_results = NULL;
-	kfree(wl->conf);
-	wl->conf = NULL;
-	kfree(wl->scan_req_int);
-	wl->scan_req_int = NULL;
-	kfree(wl->ioctl_buf);
-	wl->ioctl_buf = NULL;
-	kfree(wl->escan_ioctl_buf);
-	wl->escan_ioctl_buf = NULL;
-	kfree(wl->extra_buf);
-	wl->extra_buf = NULL;
-	kfree(wl->iscan);
-	wl->iscan = NULL;
-	kfree(wl->pmk_list);
-	wl->pmk_list = NULL;
-	kfree(wl->sta_info);
-	wl->sta_info = NULL;
-	if (wl->afx_hdl) {
-		cancel_work_sync(&wl->afx_hdl->work);
-		kfree(wl->afx_hdl);
-		wl->afx_hdl = NULL;
 	}
+	else if (status == WLC_E_STATUS_SUCCESS) {
+		wl->escan_info.escan_state = WL_ESCAN_STATE_IDLE;
+		wl_escan_print_sync_id(status, wl->escan_info.cur_sync_id,
+			escan_result->sync_id);
 
-	if (wl->ap_info) {
-		kfree(wl->ap_info->wpa_ie);
-		kfree(wl->ap_info->rsn_ie);
-		kfree(wl->ap_info->wps_ie);
-		kfree(wl->ap_info);
-		wl->ap_info = NULL;
+		if (wl_get_drv_status_all(wl, FINDING_COMMON_CHANNEL)) {
+			WL_INFO(("ACTION FRAME SCAN DONE\n"));
+			wl_clr_p2p_status(wl, SCANNING);
+			wl_clr_drv_status(wl, SCANNING, wl->afx_hdl->dev);
+			if (wl->afx_hdl->peer_chan == WL_INVALID)
+				complete(&wl->act_frm_scan);
+		} else if ((likely(wl->scan_request)) || (wl->sched_scan_running)) {
+			WL_INFO(("ESCAN COMPLETED\n"));
+			wl->bss_list = wl_escan_get_buf(wl, FALSE);
+			if (wl->scan_request && wl->scan_request->dev != wl->p2p_net) {
+				WL_TRACE_HW4(("SCAN COMPLETED: scanned AP count=%d\n",
+					wl->bss_list->count));
+			}
+			wl_inform_bss(wl);
+			wl_notify_escan_complete(wl, ndev, false, false);
+		}
+		wl_escan_increment_sync_id(wl, SCAN_BUF_NEXT);
+	}
+	else if (status == WLC_E_STATUS_ABORT) {
+		wl->escan_info.escan_state = WL_ESCAN_STATE_IDLE;
+		wl_escan_print_sync_id(status, escan_result->sync_id,
+			wl->escan_info.cur_sync_id);
+		if (wl_get_drv_status_all(wl, FINDING_COMMON_CHANNEL)) {
+			WL_INFO(("ACTION FRAME SCAN DONE\n"));
+			wl_clr_drv_status(wl, SCANNING, wl->afx_hdl->dev);
+			wl_clr_p2p_status(wl, SCANNING);
+			if (wl->afx_hdl->peer_chan == WL_INVALID)
+				complete(&wl->act_frm_scan);
+		} else if ((likely(wl->scan_request)) || (wl->sched_scan_running)) {
+			WL_INFO(("ESCAN ABORTED\n"));
+			wl->bss_list = wl_escan_get_buf(wl, TRUE);
+			if (wl->scan_request && wl->scan_request->dev != wl->p2p_net) {
+				WL_TRACE_HW4(("SCAN ABORTED: scanned AP count=%d\n",
+					wl->bss_list->count));
+			}
+			wl_inform_bss(wl);
+			wl_notify_escan_complete(wl, ndev, true, false);
+		}
+		wl_escan_increment_sync_id(wl, SCAN_BUF_CNT);
+	} else if (status == WLC_E_STATUS_NEWSCAN) {
+		WL_ERR(("WLC_E_STATUS_NEWSCAN : scan_request[%p]\n", wl->scan_request));
+		WL_ERR(("sync_id[%d], bss_count[%d]\n", escan_result->sync_id,
+			escan_result->bss_count));
+	} else if (status == WLC_E_STATUS_TIMEOUT) {
+		WL_ERR(("WLC_E_STATUS_TIMEOUT : scan_request[%p]\n", wl->scan_request));
+		WL_ERR(("escan_on[%d], reason[0x%x]\n", wl->escan_on, e->reason));
+		if (e->reason == 0xFFFFFFFF) {
+			wl_notify_escan_complete(wl, wl->escan_info.ndev, true, true);
+		}
+	} else {
+		WL_ERR(("unexpected Escan Event %d : abort\n", status));
+		wl->escan_info.escan_state = WL_ESCAN_STATE_IDLE;
+		wl_escan_print_sync_id(status, escan_result->sync_id,
+			wl->escan_info.cur_sync_id);
+		if (wl_get_drv_status_all(wl, FINDING_COMMON_CHANNEL)) {
+			WL_INFO(("ACTION FRAME SCAN DONE\n"));
+			wl_clr_p2p_status(wl, SCANNING);
+			wl_clr_drv_status(wl, SCANNING, wl->afx_hdl->dev);
+			if (wl->afx_hdl->peer_chan == WL_INVALID)
+				complete(&wl->act_frm_scan);
+		} else if ((likely(wl->scan_request)) || (wl->sched_scan_running)) {
+			wl->bss_list = wl_escan_get_buf(wl, TRUE);
+			if (wl->scan_request && wl->scan_request->dev != wl->p2p_net) {
+				WL_TRACE_HW4(("SCAN ABORTED(UNEXPECTED): "
+					"scanned AP count=%d\n",
+					wl->bss_list->count));
+			}
+			wl_inform_bss(wl);
+			wl_notify_escan_complete(wl, ndev, true, false);
+		}
+		wl_escan_increment_sync_id(wl, 2);
 	}
+exit:
+	mutex_unlock(&wl->usr_sync);
+	return err;
 }
 
-static s32 wl_create_event_handler(struct wl_priv *wl)
+static void wl_cfg80211_concurrent_roam(struct wl_priv *wl, int enable)
 {
-	int ret = 0;
-	WL_DBG(("Enter \n"));
+	u32 connected_cnt  = wl_get_drv_status_all(wl, CONNECTED);
+	struct net_info *iter, *next;
+	int err;
 
-	/* Do not use DHD in cfg driver */
-	wl->event_tsk.thr_pid = -1;
-	PROC_START(wl_event_handler, wl, &wl->event_tsk, 0);
-	if (wl->event_tsk.thr_pid < 0)
-		ret = -ENOMEM;
-	return ret;
+	if (!wl->roamoff_on_concurrent)
+		return;
+	if (enable && connected_cnt > 1) {
+		for_each_ndev(wl, iter, next) {
+			/* Save the current roam setting */
+			if ((err = wldev_iovar_getint(iter->ndev, "roam_off",
+				(s32 *)&iter->roam_off)) != BCME_OK) {
+				WL_ERR(("%s:Failed to get current roam setting err %d\n",
+					iter->ndev->name, err));
+				continue;
+			}
+			if ((err = wldev_iovar_setint(iter->ndev, "roam_off", 1)) != BCME_OK) {
+				WL_ERR((" %s:failed to set roam_off : %d\n",
+					iter->ndev->name, err));
+			}
+		}
+	}
+	else if (!enable) {
+		for_each_ndev(wl, iter, next) {
+			if (iter->roam_off != WL_INVALID) {
+				if ((err = wldev_iovar_setint(iter->ndev, "roam_off",
+					iter->roam_off)) == BCME_OK)
+					iter->roam_off = WL_INVALID;
+				else {
+					WL_ERR((" %s:failed to set roam_off : %d\n",
+						iter->ndev->name, err));
+				}
+			}
+		}
+	}
+	return;
 }
 
-static void wl_destroy_event_handler(struct wl_priv *wl)
+static void wl_cfg80211_determine_vsdb_mode(struct wl_priv *wl)
 {
-	if (wl->event_tsk.thr_pid >= 0)
-		PROC_STOP(&wl->event_tsk);
-}
+	struct net_info *iter, *next;
+	u32 chan = 0;
+	u32 chanspec = 0;
+	u32 prev_chan = 0;
+	u32 connected_cnt  = wl_get_drv_status_all(wl, CONNECTED);
+	wl->vsdb_mode = false;
 
-static void wl_term_iscan(struct wl_priv *wl)
-{
-	struct wl_iscan_ctrl *iscan = wl_to_iscan(wl);
-	WL_TRACE(("In\n"));
-	if (wl->iscan_on && iscan->tsk) {
-		iscan->state = WL_ISCAN_STATE_IDLE;
-		WL_INFO(("SIGTERM\n"));
-		send_sig(SIGTERM, iscan->tsk, 1);
-		WL_DBG(("kthread_stop\n"));
-		kthread_stop(iscan->tsk);
-		iscan->tsk = NULL;
+	if (connected_cnt <= 1)  {
+		return;
+	}
+	for_each_ndev(wl, iter, next) {
+		chanspec = 0;
+		chan = 0;
+		if (wl_get_drv_status(wl, CONNECTED, iter->ndev)) {
+			if (wldev_iovar_getint(iter->ndev, "chanspec",
+				(s32 *)&chanspec) == BCME_OK) {
+				chan = CHSPEC_CHANNEL(chanspec);
+				if (CHSPEC_IS40(chanspec)) {
+					if (CHSPEC_SB_UPPER(chanspec))
+						chan += CH_10MHZ_APART;
+					else
+						chan -= CH_10MHZ_APART;
+				}
+				wl_update_prof(wl, iter->ndev, NULL,
+					&chan, WL_PROF_CHAN);
+			}
+			if (!prev_chan && chan)
+				prev_chan = chan;
+			else if (prev_chan && (prev_chan != chan))
+				wl->vsdb_mode = true;
+		}
 	}
+	return;
 }
-
-static void wl_notify_iscan_complete(struct wl_iscan_ctrl *iscan, bool aborted)
+static s32 wl_notifier_change_state(struct wl_priv *wl, struct net_info *_net_info,
+	enum wl_status state, bool set)
 {
-	struct wl_priv *wl = iscan_to_wl(iscan);
-	struct net_device *ndev = wl_to_prmry_ndev(wl);
-	unsigned long flags;
+	s32 pm = PM_FAST;
+	s32 err = BCME_OK;
+	u32 chan = 0;
+	struct net_info *iter, *next;
+	struct net_device *primary_dev = wl_to_prmry_ndev(wl);
+	WL_DBG(("Enter state %d set %d _net_info->pm_restore %d iface %s\n",
+		state, set, _net_info->pm_restore, _net_info->ndev->name));
 
-	WL_DBG(("Enter \n"));
-	if (!wl_get_drv_status(wl, SCANNING, ndev)) {
-		wl_clr_drv_status(wl, SCANNING, ndev);
-		WL_ERR(("Scan complete while device not scanning\n"));
-		return;
+	if (state != WL_STATUS_CONNECTED)
+		return 0;
+
+	if (set) {
+		wl_cfg80211_concurrent_roam(wl, 1);
+
+		if (wl_get_mode_by_netdev(wl, _net_info->ndev) == WL_MODE_AP) {
+
+			if (wl_add_remove_eventmsg(primary_dev, WLC_E_P2P_PROBREQ_MSG, false))
+				WL_ERR((" failed to unset WLC_E_P2P_PROPREQ_MSG\n"));
+		}
+		wl_cfg80211_determine_vsdb_mode(wl);
+		if (wl->vsdb_mode || _net_info->pm_block) {
+			pm = PM_OFF;
+			for_each_ndev(wl, iter, next) {
+				if (iter->pm_restore)
+					continue;
+				/* Save the current power mode */
+				err = wldev_ioctl(iter->ndev, WLC_GET_PM, &iter->pm,
+					sizeof(iter->pm), false);
+				WL_DBG(("%s:power save %s\n", iter->ndev->name,
+					iter->pm ? "enabled" : "disabled"));
+				if (!err && iter->pm) {
+					iter->pm_restore = true;
+				}
+
+			}
+			for_each_ndev(wl, iter, next) {
+				if ((err = wldev_ioctl(iter->ndev, WLC_SET_PM, &pm,
+					sizeof(pm), true)) != 0) {
+					if (err == -ENODEV)
+						WL_DBG(("%s:netdev not ready\n", iter->ndev->name));
+					else
+						WL_ERR(("%s:error (%d)\n", iter->ndev->name, err));
+					iter->ndev->ieee80211_ptr->ps = false;
+				}
+			}
+		}
 	}
-	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
-	wl_clr_drv_status(wl, SCANNING, ndev);
-	if (likely(wl->scan_request)) {
-		cfg80211_scan_done(wl->scan_request, aborted);
-		wl->scan_request = NULL;
+	 else { /* clear */
+		chan = 0;
+		/* clear chan information when the net device is disconnected */
+		wl_update_prof(wl, _net_info->ndev, NULL, &chan, WL_PROF_CHAN);
+		wl_cfg80211_determine_vsdb_mode(wl);
+		for_each_ndev(wl, iter, next) {
+			if (iter->pm_restore && iter->pm) {
+				WL_DBG(("%s:restoring power save %s\n",
+					iter->ndev->name, (iter->pm ? "enabled" : "disabled")));
+				err = wldev_ioctl(iter->ndev,
+					WLC_SET_PM, &iter->pm, sizeof(iter->pm), true);
+				if (unlikely(err)) {
+					if (err == -ENODEV)
+						WL_DBG(("%s:netdev not ready\n", iter->ndev->name));
+					else
+						WL_ERR(("%s:error(%d)\n", iter->ndev->name, err));
+					break;
+				}
+				iter->pm_restore = 0;
+				iter->ndev->ieee80211_ptr->ps = true;
+			}
+		}
+		wl_cfg80211_concurrent_roam(wl, 0);
 	}
-	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
-	wl->iscan_kickstart = false;
+	return err;
 }
-
-static s32 wl_wakeup_iscan(struct wl_iscan_ctrl *iscan)
+static s32 wl_init_scan(struct wl_priv *wl)
 {
-	if (likely(iscan->state != WL_ISCAN_STATE_IDLE)) {
-		WL_DBG(("wake up iscan\n"));
-		up(&iscan->sync);
-		return 0;
+	struct wl_iscan_ctrl *iscan = wl_to_iscan(wl);
+	int err = 0;
+
+	if (wl->iscan_on) {
+		iscan->dev = wl_to_prmry_ndev(wl);
+		iscan->state = WL_ISCAN_STATE_IDLE;
+		wl_init_iscan_handler(iscan);
+		iscan->timer_ms = WL_ISCAN_TIMER_INTERVAL_MS;
+		init_timer(&iscan->timer);
+		iscan->timer.data = (unsigned long) iscan;
+		iscan->timer.function = wl_iscan_timer;
+		sema_init(&iscan->sync, 0);
+		iscan->tsk = kthread_run(wl_iscan_thread, iscan, "wl_iscan");
+		if (IS_ERR(iscan->tsk)) {
+			WL_ERR(("Could not create iscan thread\n"));
+			iscan->tsk = NULL;
+			return -ENOMEM;
+		}
+		iscan->data = wl;
+	} else if (wl->escan_on) {
+		wl->evt_handler[WLC_E_ESCAN_RESULT] = wl_escan_handler;
+		wl->escan_info.escan_state = WL_ESCAN_STATE_IDLE;
+		wl_escan_init_sync_id(wl);
 	}
+	/* Init scan_timeout timer */
+	init_timer(&wl->scan_timeout);
+	wl->scan_timeout.data = (unsigned long) wl;
+	wl->scan_timeout.function = wl_scan_timeout;
 
-	return -EIO;
+	return err;
 }
 
-static s32
-wl_get_iscan_results(struct wl_iscan_ctrl *iscan, u32 *status,
-	struct wl_scan_results **bss_list)
+static s32 wl_init_priv(struct wl_priv *wl)
 {
-	struct wl_iscan_results list;
-	struct wl_scan_results *results;
-	struct wl_iscan_results *list_buf;
+	struct wiphy *wiphy = wl_to_wiphy(wl);
+	struct net_device *ndev = wl_to_prmry_ndev(wl);
 	s32 err = 0;
 
-	WL_DBG(("Enter \n"));
-	memset(iscan->scan_buf, 0, WL_ISCAN_BUF_MAX);
-	list_buf = (struct wl_iscan_results *)iscan->scan_buf;
-	results = &list_buf->results;
-	results->buflen = WL_ISCAN_RESULTS_FIXED_SIZE;
-	results->version = 0;
-	results->count = 0;
-
-	memset(&list, 0, sizeof(list));
-	list.results.buflen = htod32(WL_ISCAN_BUF_MAX);
-	err = wldev_iovar_getbuf(iscan->dev, "iscanresults", &list,
-		WL_ISCAN_RESULTS_FIXED_SIZE, iscan->scan_buf,
-		WL_ISCAN_BUF_MAX, NULL);
-	if (unlikely(err)) {
-		WL_ERR(("error (%d)\n", err));
+	wl->scan_request = NULL;
+	wl->pwr_save = !!(wiphy->flags & WIPHY_FLAG_PS_ON_BY_DEFAULT);
+	wl->iscan_on = false;
+	wl->escan_on = true;
+	wl->roam_on = true;
+	wl->iscan_kickstart = false;
+	wl->active_scan = true;
+	wl->rf_blocked = false;
+	wl->vsdb_mode = false;
+	wl->wlfc_on = false;
+	wl->roamoff_on_concurrent = true;
+	/* register interested state */
+	set_bit(WL_STATUS_CONNECTED, &wl->interrested_state);
+	spin_lock_init(&wl->cfgdrv_lock);
+	mutex_init(&wl->ioctl_buf_sync);
+	init_waitqueue_head(&wl->netif_change_event);
+	init_completion(&wl->send_af_done);
+	init_completion(&wl->iface_disable);
+	wl_init_eq(wl);
+	err = wl_init_priv_mem(wl);
+	if (err)
 		return err;
-	}
-	results->buflen = dtoh32(results->buflen);
-	results->version = dtoh32(results->version);
-	results->count = dtoh32(results->count);
-	WL_DBG(("results->count = %d\n", results->count));
-	WL_DBG(("results->buflen = %d\n", results->buflen));
-	*status = dtoh32(list_buf->status);
-	*bss_list = results;
+	if (wl_create_event_handler(wl))
+		return -ENOMEM;
+	wl_init_event_handler(wl);
+	mutex_init(&wl->usr_sync);
+	mutex_init(&wl->event_sync);
+	err = wl_init_scan(wl);
+	if (err)
+		return err;
+	wl_init_conf(wl->conf);
+	wl_init_prof(wl, ndev);
+	wl_link_down(wl);
+	DNGL_FUNC(dhd_cfg80211_init, (wl));
 
 	return err;
 }
 
-static s32 wl_iscan_done(struct wl_priv *wl)
+static void wl_deinit_priv(struct wl_priv *wl)
+{
+	DNGL_FUNC(dhd_cfg80211_deinit, (wl));
+	wl_destroy_event_handler(wl);
+	wl_flush_eq(wl);
+	wl_link_down(wl);
+	del_timer_sync(&wl->scan_timeout);
+	wl_term_iscan(wl);
+	wl_deinit_priv_mem(wl);
+	unregister_netdevice_notifier(&wl_cfg80211_netdev_notifier);
+}
+
+#if defined(WLP2P) && defined(WL_ENABLE_P2P_IF)
+static s32 wl_cfg80211_attach_p2p(void)
 {
-	struct wl_iscan_ctrl *iscan = wl->iscan;
-	s32 err = 0;
+	struct wl_priv *wl = wlcfg_drv_priv;
 
-	iscan->state = WL_ISCAN_STATE_IDLE;
-	mutex_lock(&wl->usr_sync);
-	wl_inform_bss(wl);
-	wl_notify_iscan_complete(iscan, false);
-	mutex_unlock(&wl->usr_sync);
+	WL_TRACE(("Enter \n"));
 
-	return err;
+	if (wl_cfgp2p_register_ndev(wl) < 0) {
+		WL_ERR(("P2P attach failed. \n"));
+		return -ENODEV;
+	}
+
+	return 0;
 }
 
-static s32 wl_iscan_pending(struct wl_priv *wl)
+static s32  wl_cfg80211_detach_p2p(void)
 {
-	struct wl_iscan_ctrl *iscan = wl->iscan;
-	s32 err = 0;
+	struct wl_priv *wl = wlcfg_drv_priv;
+	struct wireless_dev *wdev;
 
-	/* Reschedule the timer */
-	mod_timer(&iscan->timer, jiffies + iscan->timer_ms * HZ / 1000);
-	iscan->timer_on = 1;
+	WL_DBG(("Enter \n"));
+	if (!wl) {
+		WL_ERR(("Invalid Ptr\n"));
+		return -EINVAL;
+	} else
+		wdev = wl->p2p_wdev;
 
-	return err;
-}
+	if (!wdev) {
+		WL_ERR(("Invalid Ptr\n"));
+		return -EINVAL;
+	}
 
-static s32 wl_iscan_inprogress(struct wl_priv *wl)
-{
-	struct wl_iscan_ctrl *iscan = wl->iscan;
-	s32 err = 0;
+	wl_cfgp2p_unregister_ndev(wl);
 
-	mutex_lock(&wl->usr_sync);
-	wl_inform_bss(wl);
-	wl_run_iscan(iscan, NULL, WL_SCAN_ACTION_CONTINUE);
-	mutex_unlock(&wl->usr_sync);
-	/* Reschedule the timer */
-	mod_timer(&iscan->timer, jiffies + iscan->timer_ms * HZ / 1000);
-	iscan->timer_on = 1;
+	wl->p2p_wdev = NULL;
+	wl->p2p_net = NULL;
+	WL_DBG(("Freeing 0x%08x \n", (unsigned int)wdev));
+	kfree(wdev);
 
-	return err;
+	return 0;
 }
+#endif /* defined(WLP2P) && defined(WL_ENABLE_P2P_IF) */
 
-static s32 wl_iscan_aborted(struct wl_priv *wl)
+s32 wl_cfg80211_attach_post(struct net_device *ndev)
 {
-	struct wl_iscan_ctrl *iscan = wl->iscan;
+	struct wl_priv * wl = NULL;
 	s32 err = 0;
+	WL_TRACE(("In\n"));
+	if (unlikely(!ndev)) {
+		WL_ERR(("ndev is invaild\n"));
+		return -ENODEV;
+	}
+	wl = wlcfg_drv_priv;
+	if (unlikely(!wl)) {
+		WL_ERR(("wl is invaild\n"));
+		return -EINVAL;
+	}
+	if (!wl_get_drv_status(wl, READY, ndev)) {
+			if (wl->wdev &&
+				wl_cfgp2p_supported(wl, ndev)) {
+#if !defined(WL_ENABLE_P2P_IF)
+				wl->wdev->wiphy->interface_modes |=
+					(BIT(NL80211_IFTYPE_P2P_CLIENT)|
+					BIT(NL80211_IFTYPE_P2P_GO));
+#endif
+				if ((err = wl_cfgp2p_init_priv(wl)) != 0)
+					goto fail;
 
-	iscan->state = WL_ISCAN_STATE_IDLE;
-	mutex_lock(&wl->usr_sync);
-	wl_notify_iscan_complete(iscan, true);
-	mutex_unlock(&wl->usr_sync);
+#if defined(WLP2P) && defined(WL_ENABLE_P2P_IF)
+				if (wl->p2p_net) {
+					/* Update MAC addr for p2p0 interface here. */
+					memcpy(wl->p2p_net->dev_addr, ndev->dev_addr, ETH_ALEN);
+					wl->p2p_net->dev_addr[0] |= 0x02;
+					WL_ERR(("%s: p2p_dev_addr="MACDBG "\n",
+						wl->p2p_net->name,
+						MAC2STRDBG(wl->p2p_net->dev_addr)));
+				} else {
+					WL_ERR(("p2p_net not yet populated."
+					" Couldn't update the MAC Address for p2p0 \n"));
+					return -ENODEV;
+				}
+#endif /* defined(WLP2P) && (WL_ENABLE_P2P_IF) */
 
+				wl->p2p_supported = true;
+			}
+	}
+	wl_set_drv_status(wl, READY, ndev);
+fail:
 	return err;
 }
 
-static s32 wl_iscan_thread(void *data)
+s32 wl_cfg80211_attach(struct net_device *ndev, void *data)
 {
-	struct wl_iscan_ctrl *iscan = (struct wl_iscan_ctrl *)data;
-	struct wl_priv *wl = iscan_to_wl(iscan);
-	u32 status;
-	int err = 0;
+	struct wireless_dev *wdev;
+	struct wl_priv *wl;
+	s32 err = 0;
+	struct device *dev;
 
-	allow_signal(SIGTERM);
-	status = WL_SCAN_RESULTS_PARTIAL;
-	while (likely(!down_interruptible(&iscan->sync))) {
-		if (kthread_should_stop())
-			break;
-		if (iscan->timer_on) {
-			del_timer_sync(&iscan->timer);
-			iscan->timer_on = 0;
-		}
-		mutex_lock(&wl->usr_sync);
-		err = wl_get_iscan_results(iscan, &status, &wl->bss_list);
-		if (unlikely(err)) {
-			status = WL_SCAN_RESULTS_ABORTED;
-			WL_ERR(("Abort iscan\n"));
-		}
-		mutex_unlock(&wl->usr_sync);
-		iscan->iscan_handler[status] (wl);
+	WL_TRACE(("In\n"));
+	if (!ndev) {
+		WL_ERR(("ndev is invaild\n"));
+		return -ENODEV;
 	}
-	if (iscan->timer_on) {
-		del_timer_sync(&iscan->timer);
-		iscan->timer_on = 0;
+	WL_DBG(("func %p\n", wl_cfg80211_get_parent_dev()));
+	dev = wl_cfg80211_get_parent_dev();
+
+	wdev = kzalloc(sizeof(*wdev), GFP_KERNEL);
+	if (unlikely(!wdev)) {
+		WL_ERR(("Could not allocate wireless device\n"));
+		return -ENOMEM;
+	}
+	err = wl_setup_wiphy(wdev, dev, data);
+	if (unlikely(err)) {
+		kfree(wdev);
+		return -ENOMEM;
+	}
+	wdev->iftype = wl_mode_to_nl80211_iftype(WL_MODE_BSS);
+	wl = (struct wl_priv *)wiphy_priv(wdev->wiphy);
+	wl->wdev = wdev;
+	wl->pub = data;
+	INIT_LIST_HEAD(&wl->net_list);
+	ndev->ieee80211_ptr = wdev;
+	SET_NETDEV_DEV(ndev, wiphy_dev(wdev->wiphy));
+	wdev->netdev = ndev;
+	wl->state_notifier = wl_notifier_change_state;
+	err = wl_alloc_netinfo(wl, ndev, wdev, WL_MODE_BSS, PM_ENABLE);
+	if (err) {
+		WL_ERR(("Failed to alloc net_info (%d)\n", err));
+		goto cfg80211_attach_out;
+	}
+	err = wl_init_priv(wl);
+	if (err) {
+		WL_ERR(("Failed to init iwm_priv (%d)\n", err));
+		goto cfg80211_attach_out;
 	}
-	WL_DBG(("%s was terminated\n", __func__));
 
-	return 0;
+	err = wl_setup_rfkill(wl, TRUE);
+	if (err) {
+		WL_ERR(("Failed to setup rfkill %d\n", err));
+		goto cfg80211_attach_out;
+	}
+#ifdef DEBUGFS_CFG80211
+	err = wl_setup_debugfs(wl);
+	if (err) {
+		WL_ERR(("Failed to setup debugfs %d\n", err));
+		goto cfg80211_attach_out;
+	}
+#endif
+	err = register_netdevice_notifier(&wl_cfg80211_netdev_notifier);
+	if (err) {
+		WL_ERR(("Failed to register notifierl %d\n", err));
+		goto cfg80211_attach_out;
+	}
+#if defined(COEX_DHCP)
+	err = wl_cfg80211_btcoex_init(wl);
+	if (err)
+		goto cfg80211_attach_out;
+#endif 
+
+	wlcfg_drv_priv = wl;
+
+#if defined(WLP2P) && defined(WL_ENABLE_P2P_IF)
+	err = wl_cfg80211_attach_p2p();
+	if (err)
+		goto cfg80211_attach_out;
+#endif
+
+	return err;
+
+cfg80211_attach_out:
+	wl_setup_rfkill(wl, FALSE);
+	wl_free_wdev(wl);
+	return err;
 }
 
-static void wl_scan_timeout(unsigned long data)
+void wl_cfg80211_detach(void *para)
 {
-	struct wl_priv *wl = (struct wl_priv *)data;
+	struct wl_priv *wl;
 
-	if (wl->scan_request) {
-		WL_ERR(("timer expired\n"));
-		if (wl->escan_on)
-			wl_notify_escan_complete(wl, wl->escan_info.ndev, true, true);
-		else
-			wl_notify_iscan_complete(wl_to_iscan(wl), true);
+	(void)para;
+	wl = wlcfg_drv_priv;
+
+	WL_TRACE(("In\n"));
+
+#if defined(COEX_DHCP)
+	wl_cfg80211_btcoex_deinit(wl);
+#endif 
+
+	wl_setup_rfkill(wl, FALSE);
+#ifdef DEBUGFS_CFG80211
+	wl_free_debugfs(wl);
+#endif
+	if (wl->p2p_supported) {
+		if (timer_pending(&wl->p2p->listen_timer))
+			del_timer_sync(&wl->p2p->listen_timer);
+		wl_cfgp2p_deinit_priv(wl);
 	}
+
+#if defined(WLP2P) && defined(WL_ENABLE_P2P_IF)
+	wl_cfg80211_detach_p2p();
+#endif
+	wl_deinit_priv(wl);
+	wlcfg_drv_priv = NULL;
+	wl_cfg80211_clear_parent_dev();
+	wl_free_wdev(wl);
+	 /* PLEASE do NOT call any function after wl_free_wdev, the driver's private structure "wl",
+	  * which is the private part of wiphy, has been freed in wl_free_wdev !!!!!!!!!!!
+	  */
 }
-static void wl_iscan_timer(unsigned long data)
-{
-	struct wl_iscan_ctrl *iscan = (struct wl_iscan_ctrl *)data;
 
-	if (iscan) {
-		iscan->timer_on = 0;
-		WL_DBG(("timer expired\n"));
-		wl_wakeup_iscan(iscan);
+static void wl_wakeup_event(struct wl_priv *wl)
+{
+	if (wl->event_tsk.thr_pid >= 0) {
+		DHD_OS_WAKE_LOCK(wl->pub);
+		up(&wl->event_tsk.sema);
 	}
 }
 
-static s32 wl_invoke_iscan(struct wl_priv *wl)
+static int wl_is_p2p_event(struct wl_event_q *e)
 {
-	struct wl_iscan_ctrl *iscan = wl_to_iscan(wl);
-	int err = 0;
-
-	if (wl->iscan_on && !iscan->tsk) {
-		iscan->state = WL_ISCAN_STATE_IDLE;
-		sema_init(&iscan->sync, 0);
-		iscan->tsk = kthread_run(wl_iscan_thread, iscan, "wl_iscan");
-		if (IS_ERR(iscan->tsk)) {
-			WL_ERR(("Could not create iscan thread\n"));
-			iscan->tsk = NULL;
-			return -ENOMEM;
+	switch (e->etype) {
+	/* We have to seperate out the P2P events received
+	 * on primary interface so that it can be send up
+	 * via p2p0 interface.
+	*/
+	case WLC_E_P2P_PROBREQ_MSG:
+	case WLC_E_P2P_DISC_LISTEN_COMPLETE:
+	case WLC_E_ACTION_FRAME_RX:
+	case WLC_E_ACTION_FRAME_OFF_CHAN_COMPLETE:
+	case WLC_E_ACTION_FRAME_COMPLETE:
+
+		if (e->emsg.ifidx != 0) {
+			WL_TRACE(("P2P Event on Virtual I/F (ifidx:%d) \n",
+			e->emsg.ifidx));
+			/* We are only bothered about the P2P events received
+			 * on primary interface. For rest of them return false
+			 * so that it is sent over the interface corresponding
+			 * to the ifidx.
+			 */
+			return FALSE;
+		} else {
+			WL_TRACE(("P2P Event on Primary I/F (ifidx:%d)."
+				" Sent it to p2p0 \n", e->emsg.ifidx));
+			return TRUE;
 		}
-	}
+		break;
 
-	return err;
+	default:
+		WL_TRACE(("NON-P2P Event %d on ifidx (ifidx:%d) \n",
+			e->etype, e->emsg.ifidx));
+		return FALSE;
+	}
 }
 
-static void wl_init_iscan_handler(struct wl_iscan_ctrl *iscan)
+static s32 wl_event_handler(void *data)
 {
-	memset(iscan->iscan_handler, 0, sizeof(iscan->iscan_handler));
-	iscan->iscan_handler[WL_SCAN_RESULTS_SUCCESS] = wl_iscan_done;
-	iscan->iscan_handler[WL_SCAN_RESULTS_PARTIAL] = wl_iscan_inprogress;
-	iscan->iscan_handler[WL_SCAN_RESULTS_PENDING] = wl_iscan_pending;
-	iscan->iscan_handler[WL_SCAN_RESULTS_ABORTED] = wl_iscan_aborted;
-	iscan->iscan_handler[WL_SCAN_RESULTS_NO_MEM] = wl_iscan_aborted;
-}
+	struct net_device *netdev;
+	struct wl_priv *wl = NULL;
+	struct wl_event_q *e;
+	tsk_ctl_t *tsk = (tsk_ctl_t *)data;
 
-static s32
-wl_cfg80211_netdev_notifier_call(struct notifier_block * nb,
-	unsigned long state,
-	void *ndev)
-{
-	struct net_device *dev = ndev;
-	struct wireless_dev *wdev = dev->ieee80211_ptr;
-	struct wl_priv *wl = wlcfg_drv_priv;
+	wl = (struct wl_priv *)tsk->parent;
 
-	WL_DBG(("Enter \n"));
-	if (!wdev || !wl || dev == wl_to_prmry_ndev(wl))
-		return NOTIFY_DONE;
-	switch (state) {
-		case NETDEV_UNREGISTER:
-			/* after calling list_del_rcu(&wdev->list) */
-			wl_dealloc_netinfo(wl, ndev);
+#ifndef USE_KTHREAD_API
+	DAEMONIZE("dhd_cfg80211_event");
+	complete(&tsk->completed);
+#else
+	WL_ERR(("tsk Enter, tsk = 0x%08x\n", (unsigned int)tsk));
+#endif
+
+	while (down_interruptible (&tsk->sema) == 0) {
+		SMP_RD_BARRIER_DEPENDS();
+		if (tsk->terminated)
 			break;
-		case NETDEV_GOING_DOWN:
-			/* At NETDEV_DOWN state, wdev_cleanup_work work will be called.
-			*  In front of door, the function checks
-			*  whether current scan is working or not.
-			*  If the scanning is still working, wdev_cleanup_work call WARN_ON and
-			*  make the scan done forcibly.
-			*/
-			if (wl_get_drv_status(wl, SCANNING, dev)) {
-				if (wl->escan_on) {
-					wl_notify_escan_complete(wl, dev, true, true);
-				}
+		while ((e = wl_deq_event(wl))) {
+			WL_DBG(("event type (%d), if idx: %d\n", e->etype, e->emsg.ifidx));
+			/* All P2P device address related events comes on primary interface since
+			 * there is no corresponding bsscfg for P2P interface. Map it to p2p0
+			 * interface.
+			 */
+			if ((wl_is_p2p_event(e) == TRUE) && (wl->p2p_net)) {
+				netdev = wl->p2p_net;
+			} else {
+				netdev = dhd_idx2net((struct dhd_pub *)(wl->pub), e->emsg.ifidx);
 			}
-			break;
+			if (!netdev)
+				netdev = wl_to_prmry_ndev(wl);
+			if (e->etype < WLC_E_LAST && wl->evt_handler[e->etype]) {
+				wl->evt_handler[e->etype] (wl, netdev, &e->emsg, e->edata);
+			} else {
+				WL_DBG(("Unknown Event (%d): ignoring\n", e->etype));
+			}
+			wl_put_event(e);
+		}
+		DHD_OS_WAKE_UNLOCK(wl->pub);
 	}
-	return NOTIFY_DONE;
+	WL_ERR(("was terminated\n"));
+	complete_and_exit(&tsk->completed, 0);
+	return 0;
 }
-static struct notifier_block wl_cfg80211_netdev_notifier = {
-	.notifier_call = wl_cfg80211_netdev_notifier_call,
-};
 
-static s32 wl_notify_escan_complete(struct wl_priv *wl,
-	struct net_device *ndev,
-	bool aborted, bool fw_abort)
+void
+wl_cfg80211_event(struct net_device *ndev, const wl_event_msg_t * e, void *data)
 {
-	wl_scan_params_t *params = NULL;
-	s32 params_size = 0;
-	s32 err = BCME_OK;
-	unsigned long flags;
-	struct net_device *dev;
+	u32 event_type = ntoh32(e->event_type);
+	u32 status = ntoh32(e->status);
+	u32 len = ntoh32(e->datalen);
+	struct wl_priv *wl = wlcfg_drv_priv;
 
-	WL_DBG(("Enter \n"));
+#if (WL_DBG_LEVEL > 0)
+	s8 *estr = (event_type <= sizeof(wl_dbg_estr) / WL_DBG_ESTR_MAX - 1) ?
+	    wl_dbg_estr[event_type] : (s8 *) "Unknown";
+	WL_DBG(("event_type (%d):" "WLC_E_" "%s\n", event_type, estr));
+#endif /* (WL_DBG_LEVEL > 0) */
 
-	if (wl->scan_request) {
-		if (wl->scan_request->dev == wl->p2p_net)
-			dev = wl_to_prmry_ndev(wl);
-		else
-			dev = wl->scan_request->dev;
+	if (event_type == WLC_E_PFN_NET_FOUND) {
+		WL_DBG((" PNOEVENT: PNO_NET_FOUND\n"));
 	}
-	else {
-		WL_ERR(("wl->scan_request is NULL may be internal scan."
-			"doing scan_abort for ndev %p primary %p p2p_net %p",
-				ndev, wl_to_prmry_ndev(wl), wl->p2p_net));
-		dev = ndev;
+	else if (event_type == WLC_E_PFN_NET_LOST) {
+		WL_DBG((" PNOEVENT: PNO_NET_LOST\n"));
 	}
-	if (fw_abort) {
-		/* Our scan params only need space for 1 channel and 0 ssids */
-		params = wl_cfg80211_scan_alloc_params(-1, 0, &params_size);
-		if (params == NULL) {
-			WL_ERR(("scan params allocation failed \n"));
-			err = -ENOMEM;
-		} else if (!in_atomic()) {
-			/* Do a scan abort to stop the driver's scan engine */
-			err = wldev_ioctl(dev, WLC_SCAN, params, params_size, true);
-			if (err < 0) {
-				WL_ERR(("scan abort  failed \n"));
+
+	switch (event_type) {
+		case WLC_E_ASSOC_REQ_IE:
+			WL_ERR(("WLC_E_ASSOC_REQ_IE\n"));
+			if (!ap_resp_ie_len)
+				memset(ap_resp_ie, 0, 256);
+			if (status == 1) {
+				WL_DBG(("set ap_resp_ie, len = %d\n", len));
+				memcpy(ap_resp_ie, data, len);
+				ap_resp_ie_len = len;
 			}
-		}
-	}
-	if (timer_pending(&wl->scan_timeout))
-		del_timer_sync(&wl->scan_timeout);
-	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
-	if (likely(wl->scan_request)) {
-		cfg80211_scan_done(wl->scan_request, aborted);
-		wl->scan_request = NULL;
+			break;
+		default:
+			break;
 	}
-	if (p2p_is_on(wl))
-		wl_clr_p2p_status(wl, SCANNING);
-	wl_clr_drv_status(wl, SCANNING, dev);
-	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
-	if (params)
-		kfree(params);
 
-	return err;
+	if (likely(!wl_enq_event(wl, ndev, event_type, e, data)))
+		wl_wakeup_event(wl);
 }
 
-static s32 wl_escan_handler(struct wl_priv *wl,
-	struct net_device *ndev,
-	const wl_event_msg_t *e, void *data)
+static void wl_init_eq(struct wl_priv *wl)
 {
-	s32 err = BCME_OK;
-	s32 status = ntoh32(e->status);
-	wl_bss_info_t *bi;
-	wl_escan_result_t *escan_result;
-	wl_bss_info_t *bss = NULL;
-	wl_scan_results_t *list;
-	u32 bi_length;
-	u32 i;
-	u8 *p2p_dev_addr = NULL;
+	wl_init_eq_lock(wl);
+	INIT_LIST_HEAD(&wl->eq_list);
+}
 
-	WL_DBG((" enter event type : %d, status : %d \n",
-		ntoh32(e->event_type), ntoh32(e->status)));
-	/* P2P SCAN is coming from primary interface */
-	if (wl_get_p2p_status(wl, SCANNING)) {
-		if (wl_get_drv_status_all(wl, SENDING_ACT_FRM))
-			ndev = wl->afx_hdl->dev;
-		else
-			ndev = wl->escan_info.ndev;
+static void wl_flush_eq(struct wl_priv *wl)
+{
+	struct wl_event_q *e;
+	unsigned long flags;
 
+	flags = wl_lock_eq(wl);
+	while (!list_empty(&wl->eq_list)) {
+		e = list_first_entry(&wl->eq_list, struct wl_event_q, eq_list);
+		list_del(&e->eq_list);
+		kfree(e);
 	}
-	if (!ndev || !wl->escan_on ||
-		!wl_get_drv_status(wl, SCANNING, ndev)) {
-		WL_ERR(("escan is not ready ndev %p wl->escan_on %d drv_status 0x%x\n",
-			ndev, wl->escan_on, wl_get_drv_status(wl, SCANNING, ndev)));
-		return err;
-	}
-
-	if (status == WLC_E_STATUS_PARTIAL) {
-		WL_INFO(("WLC_E_STATUS_PARTIAL \n"));
-		escan_result = (wl_escan_result_t *) data;
-		if (!escan_result) {
-			WL_ERR(("Invalid escan result (NULL pointer)\n"));
-			goto exit;
-		}
-		if (dtoh16(escan_result->bss_count) != 1) {
-			WL_ERR(("Invalid bss_count %d: ignoring\n", escan_result->bss_count));
-			goto exit;
-		}
-		bi = escan_result->bss_info;
-		if (!bi) {
-			WL_ERR(("Invalid escan bss info (NULL pointer)\n"));
-			goto exit;
-		}
-		bi_length = dtoh32(bi->length);
-		if (bi_length != (dtoh32(escan_result->buflen) - WL_ESCAN_RESULTS_FIXED_SIZE)) {
-			WL_ERR(("Invalid bss_info length %d: ignoring\n", bi_length));
-			goto exit;
-		}
-
-		if (!(wl_to_wiphy(wl)->interface_modes & BIT(NL80211_IFTYPE_ADHOC))) {
-			if (dtoh16(bi->capability) & DOT11_CAP_IBSS) {
-				WL_ERR(("Ignoring IBSS result\n"));
-				goto exit;
-			}
-		}
-
-		if (wl_get_drv_status_all(wl, SENDING_ACT_FRM)) {
-			p2p_dev_addr = wl_cfgp2p_retreive_p2p_dev_addr(bi, bi_length);
-			if (p2p_dev_addr && !memcmp(p2p_dev_addr,
-				wl->afx_hdl->pending_tx_dst_addr.octet, ETHER_ADDR_LEN)) {
-				s32 channel = CHSPEC_CHANNEL(
-					wl_chspec_driver_to_host(bi->chanspec));
-				WL_DBG(("ACTION FRAME SCAN : Peer found, channel : %d\n", channel));
-				wl_clr_p2p_status(wl, SCANNING);
-				wl->afx_hdl->peer_chan = channel;
-				complete(&wl->act_frm_scan);
-				goto exit;
-			}
-
-		} else {
-			list = (wl_scan_results_t *)wl->escan_info.escan_buf;
-			if (bi_length > ESCAN_BUF_SIZE - list->buflen) {
-				WL_ERR(("Buffer is too small: ignoring\n"));
-				goto exit;
-			}
-#define WLC_BSS_RSSI_ON_CHANNEL 0x0002
-			for (i = 0; i < list->count; i++) {
-				bss = bss ? (wl_bss_info_t *)((uintptr)bss + dtoh32(bss->length))
-					: list->bss_info;
-
-				if (!bcmp(&bi->BSSID, &bss->BSSID, ETHER_ADDR_LEN) &&
-					(CHSPEC_BAND(wl_chspec_driver_to_host(bi->chanspec))
-					== CHSPEC_BAND(wl_chspec_driver_to_host(bss->chanspec))) &&
-					bi->SSID_len == bss->SSID_len &&
-					!bcmp(bi->SSID, bss->SSID, bi->SSID_len)) {
-					if ((bss->flags & WLC_BSS_RSSI_ON_CHANNEL) ==
-						(bi->flags & WLC_BSS_RSSI_ON_CHANNEL)) {
-						/* preserve max RSSI if the measurements are
-						* both on-channel or both off-channel
-						*/
-						bss->RSSI = MAX(bss->RSSI, bi->RSSI);
-					} else if ((bss->flags & WLC_BSS_RSSI_ON_CHANNEL) &&
-						(bi->flags & WLC_BSS_RSSI_ON_CHANNEL) == 0) {
-						/* preserve the on-channel rssi measurement
-						* if the new measurement is off channel
-						*/
-						bss->RSSI = bi->RSSI;
-						bss->flags |= WLC_BSS_RSSI_ON_CHANNEL;
-					}
+	wl_unlock_eq(wl, flags);
+}
 
-					goto exit;
-				}
-			}
-			memcpy(&(wl->escan_info.escan_buf[list->buflen]), bi, bi_length);
-			list->version = dtoh32(bi->version);
-			list->buflen += bi_length;
-			list->count++;
+/*
+* retrieve first queued event from head
+*/
 
-		}
+static struct wl_event_q *wl_deq_event(struct wl_priv *wl)
+{
+	struct wl_event_q *e = NULL;
+	unsigned long flags;
 
+	flags = wl_lock_eq(wl);
+	if (likely(!list_empty(&wl->eq_list))) {
+		e = list_first_entry(&wl->eq_list, struct wl_event_q, eq_list);
+		list_del(&e->eq_list);
 	}
-	else if (status == WLC_E_STATUS_SUCCESS) {
-		wl->escan_info.escan_state = WL_ESCAN_STATE_IDLE;
-		if (wl_get_drv_status_all(wl, SENDING_ACT_FRM)) {
-			WL_INFO(("ACTION FRAME SCAN DONE\n"));
-			wl_clr_p2p_status(wl, SCANNING);
-			wl_clr_drv_status(wl, SCANNING, wl->afx_hdl->dev);
-			if (wl->afx_hdl->peer_chan == WL_INVALID)
-				complete(&wl->act_frm_scan);
-		} else if (likely(wl->scan_request)) {
-			mutex_lock(&wl->usr_sync);
-			WL_INFO(("ESCAN COMPLETED\n"));
-			wl->bss_list = (wl_scan_results_t *)wl->escan_info.escan_buf;
-			wl_inform_bss(wl);
-			wl_notify_escan_complete(wl, ndev, false, false);
-			mutex_unlock(&wl->usr_sync);
-		}
-	}
-	else if (status == WLC_E_STATUS_ABORT) {
-		wl->escan_info.escan_state = WL_ESCAN_STATE_IDLE;
-		if (wl_get_drv_status_all(wl, SENDING_ACT_FRM)) {
-			WL_INFO(("ACTION FRAME SCAN DONE\n"));
-			wl_clr_drv_status(wl, SCANNING, wl->afx_hdl->dev);
-			wl_clr_p2p_status(wl, SCANNING);
-			if (wl->afx_hdl->peer_chan == WL_INVALID)
-				complete(&wl->act_frm_scan);
-		} else if (likely(wl->scan_request)) {
-			mutex_lock(&wl->usr_sync);
-			WL_INFO(("ESCAN ABORTED\n"));
-			wl->bss_list = (wl_scan_results_t *)wl->escan_info.escan_buf;
-			wl_inform_bss(wl);
-			wl_notify_escan_complete(wl, ndev, true, false);
-			mutex_unlock(&wl->usr_sync);
-		}
-	}
-	else {
-		WL_ERR(("unexpected Escan Event %d : abort\n", status));
-		wl->escan_info.escan_state = WL_ESCAN_STATE_IDLE;
-		if (wl_get_drv_status_all(wl, SENDING_ACT_FRM)) {
-			WL_INFO(("ACTION FRAME SCAN DONE\n"));
-			wl_clr_p2p_status(wl, SCANNING);
-			wl_clr_drv_status(wl, SCANNING, wl->afx_hdl->dev);
-			if (wl->afx_hdl->peer_chan == WL_INVALID)
-				complete(&wl->act_frm_scan);
-		} else if (likely(wl->scan_request)) {
-			mutex_lock(&wl->usr_sync);
-			wl->bss_list = (wl_scan_results_t *)wl->escan_info.escan_buf;
-			wl_inform_bss(wl);
-			wl_notify_escan_complete(wl, ndev, true, false);
-			mutex_unlock(&wl->usr_sync);
-		}
-	}
-exit:
-	return err;
+	wl_unlock_eq(wl, flags);
+
+	return e;
 }
 
-static s32 wl_init_scan(struct wl_priv *wl)
+/*
+ * push event to tail of the queue
+ */
+
+static s32
+wl_enq_event(struct wl_priv *wl, struct net_device *ndev, u32 event, const wl_event_msg_t *msg,
+	void *data)
 {
-	struct wl_iscan_ctrl *iscan = wl_to_iscan(wl);
-	int err = 0;
+	struct wl_event_q *e;
+	s32 err = 0;
+	uint32 evtq_size;
+	uint32 data_len;
+	unsigned long flags;
+	gfp_t aflags;
 
-	if (wl->iscan_on) {
-		iscan->dev = wl_to_prmry_ndev(wl);
-		iscan->state = WL_ISCAN_STATE_IDLE;
-		wl_init_iscan_handler(iscan);
-		iscan->timer_ms = WL_ISCAN_TIMER_INTERVAL_MS;
-		init_timer(&iscan->timer);
-		iscan->timer.data = (unsigned long) iscan;
-		iscan->timer.function = wl_iscan_timer;
-		sema_init(&iscan->sync, 0);
-		iscan->tsk = kthread_run(wl_iscan_thread, iscan, "wl_iscan");
-		if (IS_ERR(iscan->tsk)) {
-			WL_ERR(("Could not create iscan thread\n"));
-			iscan->tsk = NULL;
-			return -ENOMEM;
-		}
-		iscan->data = wl;
-	} else if (wl->escan_on) {
-		wl->evt_handler[WLC_E_ESCAN_RESULT] = wl_escan_handler;
-		wl->escan_info.escan_state = WL_ESCAN_STATE_IDLE;
+	data_len = 0;
+	if (data)
+		data_len = ntoh32(msg->datalen);
+	evtq_size = sizeof(struct wl_event_q) + data_len;
+	aflags = (in_atomic()) ? GFP_ATOMIC : GFP_KERNEL;
+	e = kzalloc(evtq_size, aflags);
+	if (unlikely(!e)) {
+		WL_ERR(("event alloc failed\n"));
+		return -ENOMEM;
 	}
-	/* Init scan_timeout timer */
-	init_timer(&wl->scan_timeout);
-	wl->scan_timeout.data = (unsigned long) wl;
-	wl->scan_timeout.function = wl_scan_timeout;
+	e->etype = event;
+	memcpy(&e->emsg, msg, sizeof(wl_event_msg_t));
+	if (data)
+		memcpy(e->edata, data, data_len);
+	flags = wl_lock_eq(wl);
+	list_add_tail(&e->eq_list, &wl->eq_list);
+	wl_unlock_eq(wl, flags);
 
 	return err;
 }
 
-static s32 wl_init_priv(struct wl_priv *wl)
+static void wl_put_event(struct wl_event_q *e)
 {
-	struct wiphy *wiphy = wl_to_wiphy(wl);
-	struct net_device *ndev = wl_to_prmry_ndev(wl);
-	s32 err = 0;
+	kfree(e);
+}
 
-	wl->scan_request = NULL;
-	wl->pwr_save = !!(wiphy->flags & WIPHY_FLAG_PS_ON_BY_DEFAULT);
-	wl->iscan_on = false;
-	wl->escan_on = true;
-	wl->roam_on = false;
-	wl->iscan_kickstart = false;
-	wl->active_scan = true;
-	wl->rf_blocked = false;
-	spin_lock_init(&wl->cfgdrv_lock);
-	mutex_init(&wl->ioctl_buf_sync);
-	init_waitqueue_head(&wl->netif_change_event);
-	wl_init_eq(wl);
-	err = wl_init_priv_mem(wl);
-	if (err)
+static s32 wl_config_ifmode(struct wl_priv *wl, struct net_device *ndev, s32 iftype)
+{
+	s32 infra = 0;
+	s32 err = 0;
+	s32 mode = 0;
+	switch (iftype) {
+	case NL80211_IFTYPE_MONITOR:
+	case NL80211_IFTYPE_WDS:
+		WL_ERR(("type (%d) : currently we do not support this mode\n",
+			iftype));
+		err = -EINVAL;
 		return err;
-	if (wl_create_event_handler(wl))
-		return -ENOMEM;
-	wl_init_event_handler(wl);
-	mutex_init(&wl->usr_sync);
-	err = wl_init_scan(wl);
-	if (err)
+	case NL80211_IFTYPE_ADHOC:
+		mode = WL_MODE_IBSS;
+		break;
+	case NL80211_IFTYPE_STATION:
+	case NL80211_IFTYPE_P2P_CLIENT:
+		mode = WL_MODE_BSS;
+		infra = 1;
+		break;
+	case NL80211_IFTYPE_AP:
+	case NL80211_IFTYPE_P2P_GO:
+		mode = WL_MODE_AP;
+		infra = 1;
+		break;
+	default:
+		err = -EINVAL;
+		WL_ERR(("invalid type (%d)\n", iftype));
 		return err;
-	wl_init_conf(wl->conf);
-	wl_init_prof(wl, ndev);
-	wl_link_down(wl);
-	DNGL_FUNC(dhd_cfg80211_init, (wl));
+	}
+	infra = htod32(infra);
+	err = wldev_ioctl(ndev, WLC_SET_INFRA, &infra, sizeof(infra), true);
+	if (unlikely(err)) {
+		WL_ERR(("WLC_SET_INFRA error (%d)\n", err));
+		return err;
+	}
 
-	return err;
+	wl_set_mode_by_netdev(wl, ndev, mode);
+
+	return 0;
 }
 
-static void wl_deinit_priv(struct wl_priv *wl)
+void wl_cfg80211_add_to_eventbuffer(struct wl_eventmsg_buf *ev, u16 event, bool set)
 {
-	DNGL_FUNC(dhd_cfg80211_deinit, (wl));
-	wl_destroy_event_handler(wl);
-	wl_flush_eq(wl);
-	wl_link_down(wl);
-	del_timer_sync(&wl->scan_timeout);
-	wl_term_iscan(wl);
-	wl_deinit_priv_mem(wl);
-	unregister_netdevice_notifier(&wl_cfg80211_netdev_notifier);
+	if (!ev || (event > WLC_E_LAST))
+		return;
+
+	if (ev->num < MAX_EVENT_BUF_NUM) {
+		ev->event[ev->num].type = event;
+		ev->event[ev->num].set = set;
+		ev->num++;
+	} else {
+		WL_ERR(("evenbuffer doesn't support > %u events. Update"
+			" the define MAX_EVENT_BUF_NUM \n", MAX_EVENT_BUF_NUM));
+		ASSERT(0);
+	}
 }
 
-#if defined(WLP2P) && defined(WL_ENABLE_P2P_IF)
-static s32 wl_cfg80211_attach_p2p(void)
+s32 wl_cfg80211_apply_eventbuffer(
+	struct net_device *ndev,
+	struct wl_priv *wl,
+	wl_eventmsg_buf_t *ev)
 {
-	struct wl_priv *wl = wlcfg_drv_priv;
+	char eventmask[WL_EVENTING_MASK_LEN];
+	int i, ret = 0;
+	s8 iovbuf[WL_EVENTING_MASK_LEN + 12];
 
-	WL_TRACE(("Enter \n"));
+	if (!ev || (!ev->num))
+		return -EINVAL;
 
-	if (wl_cfgp2p_register_ndev(wl) < 0) {
-		WL_ERR(("%s: P2P attach failed. \n", __func__));
+	mutex_lock(&wl->event_sync);
+
+	/* Read event_msgs mask */
+	bcm_mkiovar("event_msgs", NULL, 0, iovbuf,
+		sizeof(iovbuf));
+	ret = wldev_ioctl(ndev, WLC_GET_VAR, iovbuf, sizeof(iovbuf), false);
+	if (unlikely(ret)) {
+		WL_ERR(("Get event_msgs error (%d)\n", ret));
+		goto exit;
+	}
+	memcpy(eventmask, iovbuf, WL_EVENTING_MASK_LEN);
+
+	/* apply the set bits */
+	for (i = 0; i < ev->num; i++) {
+		if (ev->event[i].set)
+			setbit(eventmask, ev->event[i].type);
+		else
+			clrbit(eventmask, ev->event[i].type);
+	}
+
+	/* Write updated Event mask */
+	bcm_mkiovar("event_msgs", eventmask, WL_EVENTING_MASK_LEN, iovbuf,
+		sizeof(iovbuf));
+	ret = wldev_ioctl(ndev, WLC_SET_VAR, iovbuf, sizeof(iovbuf), true);
+	if (unlikely(ret)) {
+		WL_ERR(("Set event_msgs error (%d)\n", ret));
+	}
+
+exit:
+	mutex_unlock(&wl->event_sync);
+	return ret;
+}
+
+s32 wl_add_remove_eventmsg(struct net_device *ndev, u16 event, bool add)
+{
+	s8 iovbuf[WL_EVENTING_MASK_LEN + 12];
+	s8 eventmask[WL_EVENTING_MASK_LEN];
+	s32 err = 0;
+	struct wl_priv *wl = wlcfg_drv_priv;
+
+	if (!ndev || !wl)
 		return -ENODEV;
+
+	mutex_lock(&wl->event_sync);
+
+	/* Setup event_msgs */
+	bcm_mkiovar("event_msgs", NULL, 0, iovbuf,
+		sizeof(iovbuf));
+	err = wldev_ioctl(ndev, WLC_GET_VAR, iovbuf, sizeof(iovbuf), false);
+	if (unlikely(err)) {
+		WL_ERR(("Get event_msgs error (%d)\n", err));
+		goto eventmsg_out;
+	}
+	memcpy(eventmask, iovbuf, WL_EVENTING_MASK_LEN);
+	if (add) {
+		setbit(eventmask, event);
+	} else {
+		clrbit(eventmask, event);
+	}
+	bcm_mkiovar("event_msgs", eventmask, WL_EVENTING_MASK_LEN, iovbuf,
+		sizeof(iovbuf));
+	err = wldev_ioctl(ndev, WLC_SET_VAR, iovbuf, sizeof(iovbuf), true);
+	if (unlikely(err)) {
+		WL_ERR(("Set event_msgs error (%d)\n", err));
+		goto eventmsg_out;
 	}
 
-	return 0;
+eventmsg_out:
+	mutex_unlock(&wl->event_sync);
+	return err;
 }
 
-static s32  wl_cfg80211_detach_p2p(void)
+static int wl_construct_reginfo(struct wl_priv *wl, s32 bw_cap)
 {
-	struct wl_priv *wl = wlcfg_drv_priv;
-	struct wireless_dev *wdev = wl->p2p_wdev;
-
-	WL_DBG(("Enter \n"));
-	if (!wdev || !wl) {
-		WL_ERR(("Invalid Ptr\n"));
-		return -EINVAL;
-	}
+	struct net_device *dev = wl_to_prmry_ndev(wl);
+	struct ieee80211_channel *band_chan_arr = NULL;
+	wl_uint32_list_t *list;
+	u32 i, j, index, n_2g, n_5g, band, channel, array_size;
+	u32 *n_cnt = NULL;
+	chanspec_t c = 0;
+	s32 err = BCME_OK;
+	bool update;
+	bool ht40_allowed;
+	u8 *pbuf = NULL;
+	bool dfs_radar_disabled = FALSE;
 
-	wl_cfgp2p_unregister_ndev(wl);
+#define LOCAL_BUF_LEN 1024
+	pbuf = kzalloc(LOCAL_BUF_LEN, GFP_KERNEL);
 
-	wl->p2p_wdev = NULL;
-	wl->p2p_net = NULL;
-	WL_DBG(("Freeing 0x%08x \n", (unsigned int)wdev));
-	kfree(wdev);
+	if (pbuf == NULL) {
+		WL_ERR(("failed to allocate local buf\n"));
+		return -ENOMEM;
+	}
+	list = (wl_uint32_list_t *)(void *)pbuf;
+	list->count = htod32(WL_NUMCHANSPECS);
 
-	return 0;
-}
-#endif /* defined(WLP2P) && defined(WL_ENABLE_P2P_IF) */
 
-s32 wl_cfg80211_attach_post(struct net_device *ndev)
-{
-	struct wl_priv * wl = NULL;
-	s32 err = 0;
-	WL_TRACE(("In\n"));
-	if (unlikely(!ndev)) {
-		WL_ERR(("ndev is invaild\n"));
-		return -ENODEV;
+	err = wldev_iovar_getbuf_bsscfg(dev, "chanspecs", NULL,
+		0, pbuf, LOCAL_BUF_LEN, 0, &wl->ioctl_buf_sync);
+	if (err != 0) {
+		WL_ERR(("get chanspecs failed with %d\n", err));
+		kfree(pbuf);
+		return err;
 	}
-	wl = wlcfg_drv_priv;
-	if (wl && !wl_get_drv_status(wl, READY, ndev)) {
-			if (wl->wdev &&
-				wl_cfgp2p_supported(wl, ndev)) {
-#if !defined(WL_ENABLE_P2P_IF)
-				wl->wdev->wiphy->interface_modes |=
-					(BIT(NL80211_IFTYPE_P2P_CLIENT)|
-					BIT(NL80211_IFTYPE_P2P_GO));
+#undef LOCAL_BUF_LEN
+
+	list = (wl_uint32_list_t *)(void *)pbuf;
+	band = array_size = n_2g = n_5g = 0;
+	for (i = 0; i < dtoh32(list->count); i++) {
+		index = 0;
+		update = false;
+		ht40_allowed = false;
+		c = (chanspec_t)dtoh32(list->element[i]);
+		c = wl_chspec_driver_to_host(c);
+		channel = CHSPEC_CHANNEL(c);
+		if (CHSPEC_IS40(c)) {
+			if (CHSPEC_SB_UPPER(c))
+				channel += CH_10MHZ_APART;
+			else
+				channel -= CH_10MHZ_APART;
+		} else if (CHSPEC_IS80(c)) {
+			WL_DBG(("HT80 center channel : %d\n", channel));
+			continue;
+		}
+		if (CHSPEC_IS2G(c) && (channel >= CH_MIN_2G_CHANNEL) &&
+			(channel <= CH_MAX_2G_CHANNEL)) {
+			band_chan_arr = __wl_2ghz_channels;
+			array_size = ARRAYSIZE(__wl_2ghz_channels);
+			n_cnt = &n_2g;
+			band = IEEE80211_BAND_2GHZ;
+			ht40_allowed = (bw_cap  == WLC_N_BW_40ALL)? true : false;
+		} else if (CHSPEC_IS5G(c) && channel >= CH_MIN_5G_CHANNEL) {
+			band_chan_arr = __wl_5ghz_a_channels;
+			array_size = ARRAYSIZE(__wl_5ghz_a_channels);
+			n_cnt = &n_5g;
+			band = IEEE80211_BAND_5GHZ;
+			ht40_allowed = (bw_cap  == WLC_N_BW_20ALL)? false : true;
+		} else {
+			WL_ERR(("Invalid channel Sepc. 0x%x.\n", c));
+			continue;
+		}
+		if (!ht40_allowed && CHSPEC_IS40(c))
+			continue;
+		for (j = 0; (j < *n_cnt && (*n_cnt < array_size)); j++) {
+			if (band_chan_arr[j].hw_value == channel) {
+				update = true;
+				break;
+			}
+		}
+		if (update)
+			index = j;
+		else
+			index = *n_cnt;
+		if (index <  array_size) {
+#if LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 38) && !defined(WL_COMPAT_WIRELESS)
+			band_chan_arr[index].center_freq =
+				ieee80211_channel_to_frequency(channel);
+#else
+			band_chan_arr[index].center_freq =
+				ieee80211_channel_to_frequency(channel, band);
 #endif
-				if ((err = wl_cfgp2p_init_priv(wl)) != 0)
-					goto fail;
+			band_chan_arr[index].hw_value = channel;
 
-#if defined(WLP2P) && defined(WL_ENABLE_P2P_IF)
-				if (wl->p2p_net) {
-					/* Update MAC addr for p2p0 interface here. */
-					memcpy(wl->p2p_net->dev_addr, ndev->dev_addr, ETH_ALEN);
-					wl->p2p_net->dev_addr[0] |= 0x02;
-					printk("%s: p2p_dev_addr="MACSTR "\n",
-						wl->p2p_net->name, MAC2STR(wl->p2p_net->dev_addr));
+			if (CHSPEC_IS40(c) && ht40_allowed) {
+				/* assuming the order is HT20, HT40 Upper,
+				 *  HT40 lower from chanspecs
+				 */
+				u32 ht40_flag = band_chan_arr[index].flags & IEEE80211_CHAN_NO_HT40;
+				if (CHSPEC_SB_UPPER(c)) {
+					if (ht40_flag == IEEE80211_CHAN_NO_HT40)
+						band_chan_arr[index].flags &=
+							~IEEE80211_CHAN_NO_HT40;
+					band_chan_arr[index].flags |= IEEE80211_CHAN_NO_HT40PLUS;
 				} else {
-					WL_ERR(("p2p_net not yet populated."
-					" Couldn't update the MAC Address for p2p0 \n"));
-					return -ENODEV;
+					/* It should be one of
+					 * IEEE80211_CHAN_NO_HT40 or IEEE80211_CHAN_NO_HT40PLUS
+					 */
+					band_chan_arr[index].flags &= ~IEEE80211_CHAN_NO_HT40;
+					if (ht40_flag == IEEE80211_CHAN_NO_HT40)
+						band_chan_arr[index].flags |=
+							IEEE80211_CHAN_NO_HT40MINUS;
+				}
+			} else {
+				band_chan_arr[index].flags = IEEE80211_CHAN_NO_HT40;
+				if (!dfs_radar_disabled) {
+					if (band == IEEE80211_BAND_2GHZ)
+						channel |= WL_CHANSPEC_BAND_2G;
+					else
+						channel |= WL_CHANSPEC_BAND_5G;
+					channel |= WL_CHANSPEC_BW_20;
+					channel = wl_chspec_host_to_driver(channel);
+					err = wldev_iovar_getint(dev, "per_chan_info", &channel);
+					if (!err) {
+						if (channel & WL_CHAN_RADAR)
+							band_chan_arr[index].flags |=
+								(IEEE80211_CHAN_RADAR |
+								IEEE80211_CHAN_NO_IBSS);
+						if (channel & WL_CHAN_PASSIVE)
+							band_chan_arr[index].flags |=
+								IEEE80211_CHAN_PASSIVE_SCAN;
+					} else if (err == BCME_UNSUPPORTED) {
+						dfs_radar_disabled = TRUE;
+						WL_ERR(("does not support per_chan_info\n"));
+					}
 				}
-#endif /* defined(WLP2P) && (WL_ENABLE_P2P_IF) */
-
-				wl->p2p_supported = true;
 			}
-	} else
-		return -ENODEV;
-	wl_set_drv_status(wl, READY, ndev);
-fail:
+			if (!update)
+				(*n_cnt)++;
+		}
+
+	}
+	__wl_band_2ghz.n_channels = n_2g;
+	__wl_band_5ghz_a.n_channels = n_5g;
+	kfree(pbuf);
 	return err;
 }
 
-s32 wl_cfg80211_attach(struct net_device *ndev, void *data)
+s32 wl_update_wiphybands(struct wl_priv *wl, bool notify)
 {
-	struct wireless_dev *wdev;
-	struct wl_priv *wl;
+	struct wiphy *wiphy;
+	struct net_device *dev;
+	u32 bandlist[3];
+	u32 nband = 0;
+	u32 i = 0;
 	s32 err = 0;
-	struct device *dev;
+	s32 index = 0;
+	s32 nmode = 0;
+	bool rollback_lock = false;
+	s32 bw_cap = 0;
+	s32 cur_band = -1;
+	struct ieee80211_supported_band *bands[IEEE80211_NUM_BANDS] = {NULL, };
 
-	WL_TRACE(("In\n"));
-	if (!ndev) {
-		WL_ERR(("ndev is invaild\n"));
-		return -ENODEV;
+	if (wl == NULL) {
+		wl = wlcfg_drv_priv;
+		mutex_lock(&wl->usr_sync);
+		rollback_lock = true;
 	}
-	WL_DBG(("func %p\n", wl_cfg80211_get_parent_dev()));
-	dev = wl_cfg80211_get_parent_dev();
+	dev = wl_to_prmry_ndev(wl);
 
-	wdev = kzalloc(sizeof(*wdev), GFP_KERNEL);
-	if (unlikely(!wdev)) {
-		WL_ERR(("Could not allocate wireless device\n"));
-		return -ENOMEM;
-	}
-	err = wl_setup_wiphy(wdev, dev);
+	memset(bandlist, 0, sizeof(bandlist));
+	err = wldev_ioctl(dev, WLC_GET_BANDLIST, bandlist,
+		sizeof(bandlist), false);
 	if (unlikely(err)) {
-		kfree(wdev);
-		return -ENOMEM;
-	}
-	wdev->iftype = wl_mode_to_nl80211_iftype(WL_MODE_BSS);
-	wl = (struct wl_priv *)wiphy_priv(wdev->wiphy);
-	wl->wdev = wdev;
-	wl->pub = data;
-	INIT_LIST_HEAD(&wl->net_list);
-	ndev->ieee80211_ptr = wdev;
-	SET_NETDEV_DEV(ndev, wiphy_dev(wdev->wiphy));
-	wdev->netdev = ndev;
-	err = wl_alloc_netinfo(wl, ndev, wdev, WL_MODE_BSS);
-	if (err) {
-		WL_ERR(("Failed to alloc net_info (%d)\n", err));
-		goto cfg80211_attach_out;
+		WL_ERR(("error  read bandlist  (%d)\n", err));
+		goto end_bands;
 	}
-	err = wl_init_priv(wl);
-	if (err) {
-		WL_ERR(("Failed to init iwm_priv (%d)\n", err));
-		goto cfg80211_attach_out;
+	err = wldev_ioctl(dev, WLC_GET_BAND, &cur_band,
+		sizeof(s32), false);
+	if (unlikely(err)) {
+		WL_ERR(("error (%d)\n", err));
+		goto end_bands;
 	}
 
-	err = wl_setup_rfkill(wl, TRUE);
-	if (err) {
-		WL_ERR(("Failed to setup rfkill %d\n", err));
-		goto cfg80211_attach_out;
+	err = wldev_iovar_getint(dev, "nmode", &nmode);
+	if (unlikely(err)) {
+		WL_ERR(("error reading nmode (%d)\n", err));
+	} else {
+		/* For nmodeonly  check bw cap */
+		err = wldev_iovar_getint(dev, "mimo_bw_cap", &bw_cap);
+		if (unlikely(err)) {
+			WL_ERR(("error get mimo_bw_cap (%d)\n", err));
+		}
 	}
-	err = register_netdevice_notifier(&wl_cfg80211_netdev_notifier);
+
+	err = wl_construct_reginfo(wl, bw_cap);
 	if (err) {
-		WL_ERR(("Failed to register notifierl %d\n", err));
-		goto cfg80211_attach_out;
+		WL_ERR(("wl_construct_reginfo() fails err=%d\n", err));
+		if (err != BCME_UNSUPPORTED)
+			goto end_bands;
+		err = 0;
 	}
-#if defined(COEX_DHCP)
-	if (wl_cfg80211_btcoex_init(wl))
-		goto cfg80211_attach_out;
-#endif 
-
-	wlcfg_drv_priv = wl;
-
-#if defined(WLP2P) && defined(WL_ENABLE_P2P_IF)
-	err = wl_cfg80211_attach_p2p();
-	if (err)
-		goto cfg80211_attach_out;
-#endif
+	wiphy = wl_to_wiphy(wl);
+	nband = bandlist[0];
 
-	return err;
+	for (i = 1; i <= nband && i < ARRAYSIZE(bandlist); i++) {
+		index = -1;
+		if (bandlist[i] == WLC_BAND_5G && __wl_band_5ghz_a.n_channels > 0) {
+			bands[IEEE80211_BAND_5GHZ] =
+				&__wl_band_5ghz_a;
+			index = IEEE80211_BAND_5GHZ;
+			if (bw_cap == WLC_N_BW_40ALL || bw_cap == WLC_N_BW_20IN2G_40IN5G)
+				bands[index]->ht_cap.cap |= IEEE80211_HT_CAP_SGI_40;
+		}
+		else if (bandlist[i] == WLC_BAND_2G && __wl_band_2ghz.n_channels > 0) {
+			bands[IEEE80211_BAND_2GHZ] =
+				&__wl_band_2ghz;
+			index = IEEE80211_BAND_2GHZ;
+			if (bw_cap == WLC_N_BW_40ALL)
+				bands[index]->ht_cap.cap |= IEEE80211_HT_CAP_SGI_40;
+		}
 
-cfg80211_attach_out:
-	err = wl_setup_rfkill(wl, FALSE);
-	wl_free_wdev(wl);
-	return err;
-}
+		if ((index >= 0) && nmode) {
+			bands[index]->ht_cap.cap |=
+				(IEEE80211_HT_CAP_SGI_20 | IEEE80211_HT_CAP_DSSSCCK40);
+			bands[index]->ht_cap.ht_supported = TRUE;
+			bands[index]->ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;
+			bands[index]->ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_16;
+			/* An HT shall support all EQM rates for one spatial stream */
+			bands[index]->ht_cap.mcs.rx_mask[0] = 0xff;
+		}
 
-void wl_cfg80211_detach(void *para)
-{
-	struct wl_priv *wl;
+	}
 
-	(void)para;
-	wl = wlcfg_drv_priv;
+	wiphy->bands[IEEE80211_BAND_2GHZ] = bands[IEEE80211_BAND_2GHZ];
+	wiphy->bands[IEEE80211_BAND_5GHZ] = bands[IEEE80211_BAND_5GHZ];
 
-	WL_TRACE(("In\n"));
+	/* check if any bands populated otherwise makes 2Ghz as default */
+	if (wiphy->bands[IEEE80211_BAND_2GHZ] == NULL &&
+		wiphy->bands[IEEE80211_BAND_5GHZ] == NULL) {
+		/* Setup 2Ghz band as default */
+		wiphy->bands[IEEE80211_BAND_2GHZ] = &__wl_band_2ghz;
+	}
 
-#if defined(COEX_DHCP)
-	wl_cfg80211_btcoex_deinit(wl);
-#endif 
+	if (notify)
+		wiphy_apply_custom_regulatory(wiphy, &brcm_regdom);
 
-#if defined(WLP2P) && defined(WL_ENABLE_P2P_IF)
-	wl_cfg80211_detach_p2p();
-#endif
-	wl_setup_rfkill(wl, FALSE);
-	if (wl->p2p_supported)
-		wl_cfgp2p_deinit_priv(wl);
-	wl_deinit_priv(wl);
-	wlcfg_drv_priv = NULL;
-	wl_cfg80211_clear_parent_dev();
-	wl_free_wdev(wl);
-	 /* PLEASE do NOT call any function after wl_free_wdev, the driver's private structure "wl",
-	  * which is the private part of wiphy, has been freed in wl_free_wdev !!!!!!!!!!!
-	  */
+	end_bands:
+		if (rollback_lock)
+			mutex_unlock(&wl->usr_sync);
+	return err;
 }
 
-static void wl_wakeup_event(struct wl_priv *wl)
+static s32 __wl_cfg80211_up(struct wl_priv *wl)
 {
-	if (wl->event_tsk.thr_pid >= 0) {
-		DHD_OS_WAKE_LOCK(wl->pub);
-		up(&wl->event_tsk.sema);
-	}
-}
+	s32 err = 0;
+#ifdef WL_HOST_BAND_MGMT
+	s32 ret = 0;
+#endif /* WL_HOST_BAND_MGMT */
+	struct net_device *ndev = wl_to_prmry_ndev(wl);
+	struct wireless_dev *wdev = ndev->ieee80211_ptr;
 
-static int wl_is_p2p_event(struct wl_event_q *e)
-{
-	switch (e->etype) {
-	/* We have to seperate out the P2P events received
-	 * on primary interface so that it can be send up
-	 * via p2p0 interface.
-	*/
-	case WLC_E_P2P_PROBREQ_MSG:
-	case WLC_E_P2P_DISC_LISTEN_COMPLETE:
-	case WLC_E_ACTION_FRAME_RX:
-	case WLC_E_ACTION_FRAME_OFF_CHAN_COMPLETE:
-	case WLC_E_ACTION_FRAME_COMPLETE:
+	WL_DBG(("In\n"));
 
-		if (e->emsg.ifidx != 0) {
-			WL_TRACE(("P2P Event on Virtual I/F (ifidx:%d) \n",
-			e->emsg.ifidx));
-			/* We are only bothered about the P2P events received
-			 * on primary interface. For rest of them return false
-			 * so that it is sent over the interface corresponding
-			 * to the ifidx.
-			 */
-			return FALSE;
-		} else {
-			WL_TRACE(("P2P Event on Primary I/F (ifidx:%d)."
-				" Sent it to p2p0 \n", e->emsg.ifidx));
-			return TRUE;
-		}
-		break;
+	err = dhd_config_dongle(wl, false);
+	if (unlikely(err))
+		return err;
 
-	default:
-		WL_TRACE(("NON-P2P Event %d on ifidx (ifidx:%d) \n",
-			e->etype, e->emsg.ifidx));
-		return FALSE;
+	err = wl_config_ifmode(wl, ndev, wdev->iftype);
+	if (unlikely(err && err != -EINPROGRESS)) {
+		WL_ERR(("wl_config_ifmode failed\n"));
 	}
-}
-
-static s32 wl_event_handler(void *data)
-{
-	struct net_device *netdev;
-	struct wl_priv *wl = NULL;
-	struct wl_event_q *e;
-	tsk_ctl_t *tsk = (tsk_ctl_t *)data;
-
-	wl = (struct wl_priv *)tsk->parent;
-	DAEMONIZE("dhd_cfg80211_event");
-	complete(&tsk->completed);
-
-	while (down_interruptible (&tsk->sema) == 0) {
-		SMP_RD_BARRIER_DEPENDS();
-		if (tsk->terminated)
-			break;
-		while ((e = wl_deq_event(wl))) {
-			WL_DBG(("event type (%d), if idx: %d\n", e->etype, e->emsg.ifidx));
-			/* All P2P device address related events comes on primary interface since
-			 * there is no corresponding bsscfg for P2P interface. Map it to p2p0
-			 * interface.
+	err = wl_update_wiphybands(wl, true);
+	if (unlikely(err)) {
+		WL_ERR(("wl_update_wiphybands failed\n"));
+	}
+
+	err = dhd_monitor_init(wl->pub);
+	err = wl_invoke_iscan(wl);
+
+#ifdef WL_HOST_BAND_MGMT
+	/* By default the curr_band is initialized to BAND_AUTO */
+	if ((ret = wl_cfg80211_set_band(ndev, WLC_BAND_AUTO)) < 0) {
+		if (ret == BCME_UNSUPPORTED) {
+			/* Don't fail the initialization, lets just
+			 * fall back to the original method
 			 */
-			if ((wl_is_p2p_event(e) == TRUE) && (wl->p2p_net)) {
-				netdev = wl->p2p_net;
-			} else {
-				netdev = dhd_idx2net((struct dhd_pub *)(wl->pub), e->emsg.ifidx);
-			}
-			if (!netdev)
-				netdev = wl_to_prmry_ndev(wl);
-			if (e->etype < WLC_E_LAST && wl->evt_handler[e->etype]) {
-				wl->evt_handler[e->etype] (wl, netdev, &e->emsg, e->edata);
-			} else {
-				WL_DBG(("Unknown Event (%d): ignoring\n", e->etype));
-			}
-			wl_put_event(e);
+			WL_ERR(("WL_HOST_BAND_MGMT defined, "
+				"but roam_band iovar not supported \n"));
+		} else {
+			WL_ERR(("roam_band failed. ret=%d", ret));
+			err = -1;
 		}
-		DHD_OS_WAKE_UNLOCK(wl->pub);
 	}
-	WL_ERR(("%s was terminated\n", __func__));
-	complete_and_exit(&tsk->completed, 0);
-	return 0;
+#endif /* WL_HOST_BAND_MGMT */
+
+#if defined(DHCP_SCAN_SUPPRESS)
+	/* wlan scan_supp timer and work thread info */
+	init_timer(&wl->scan_supp_timer);
+	wl->scan_supp_timer.data = (ulong)wl;
+	wl->scan_supp_timer.function = wl_cfg80211_scan_supp_timerfunc;
+	INIT_WORK(&wl->wlan_work, wl_cfg80211_work_handler);
+#endif /* DHCP_SCAN_SUPPRESS */
+
+	wl_set_drv_status(wl, READY, ndev);
+	return err;
 }
 
-void
-wl_cfg80211_event(struct net_device *ndev, const wl_event_msg_t * e, void *data)
+static s32 __wl_cfg80211_down(struct wl_priv *wl)
 {
-	u32 event_type = ntoh32(e->event_type);
-	struct wl_priv *wl = wlcfg_drv_priv;
+	s32 err = 0;
+	unsigned long flags;
+	struct net_info *iter, *next;
+	struct net_device *ndev = wl_to_prmry_ndev(wl);
+	u32 bssidx = 0;
+	WL_DBG(("In\n"));
 
-#if (WL_DBG_LEVEL > 0)
-	s8 *estr = (event_type <= sizeof(wl_dbg_estr) / WL_DBG_ESTR_MAX - 1) ?
-	    wl_dbg_estr[event_type] : (s8 *) "Unknown";
-	WL_DBG(("event_type (%d):" "WLC_E_" "%s\n", event_type, estr));
-#endif /* (WL_DBG_LEVEL > 0) */
+#if defined(DHCP_SCAN_SUPPRESS)
+	/* Force clear of scan_suppress */
+	if (wl->scan_suppressed)
+		wl_cfg80211_scan_suppress(ndev, 0);
+	if (timer_pending(&wl->scan_supp_timer))
+		del_timer_sync(&wl->scan_supp_timer);
+	cancel_work_sync(&wl->wlan_work);
+#endif /* DHCP_SCAN_SUPPRESS */
 
-	if (event_type == WLC_E_PFN_NET_FOUND) {
-		WL_DBG((" PNOEVENT: PNO_NET_FOUND\n"));
+	/* If primary BSS is operational (for e.g SoftAP), bring it down */
+	if (!(wl_cfgp2p_find_idx(wl, ndev, &bssidx)) &&
+		wl_cfgp2p_bss_isup(ndev, bssidx)) {
+		if (wl_cfgp2p_bss(wl, ndev, bssidx, 0) < 0)
+			WL_ERR(("BSS down failed \n"));
 	}
-	else if (event_type == WLC_E_PFN_NET_LOST) {
-		WL_DBG((" PNOEVENT: PNO_NET_LOST\n"));
+
+	/* Check if cfg80211 interface is already down */
+	if (!wl_get_drv_status(wl, READY, ndev))
+		return err;	/* it is even not ready */
+	for_each_ndev(wl, iter, next)
+		wl_set_drv_status(wl, SCAN_ABORTING, iter->ndev);
+
+
+	wl_term_iscan(wl);
+	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
+	if (wl->scan_request) {
+		cfg80211_scan_done(wl->scan_request, true);
+		wl->scan_request = NULL;
 	}
+	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
 
-	if (likely(!wl_enq_event(wl, ndev, event_type, e, data)))
-		wl_wakeup_event(wl);
-}
+	for_each_ndev(wl, iter, next) {
+		wl_clr_drv_status(wl, READY, iter->ndev);
+		wl_clr_drv_status(wl, SCANNING, iter->ndev);
+		wl_clr_drv_status(wl, SCAN_ABORTING, iter->ndev);
+		wl_clr_drv_status(wl, CONNECTING, iter->ndev);
+		wl_clr_drv_status(wl, CONNECTED, iter->ndev);
+		wl_clr_drv_status(wl, DISCONNECTING, iter->ndev);
+		wl_clr_drv_status(wl, AP_CREATED, iter->ndev);
+		wl_clr_drv_status(wl, AP_CREATING, iter->ndev);
+	}
+	wl_to_prmry_ndev(wl)->ieee80211_ptr->iftype =
+		NL80211_IFTYPE_STATION;
+	DNGL_FUNC(dhd_cfg80211_down, (wl));
+	wl_flush_eq(wl);
+	wl_link_down(wl);
+	if (wl->p2p_supported)
+		wl_cfgp2p_down(wl);
+	dhd_monitor_uninit();
 
-static void wl_init_eq(struct wl_priv *wl)
-{
-	wl_init_eq_lock(wl);
-	INIT_LIST_HEAD(&wl->eq_list);
+	return err;
 }
 
-static void wl_flush_eq(struct wl_priv *wl)
+s32 wl_cfg80211_up(void *para)
 {
-	struct wl_event_q *e;
-	unsigned long flags;
+	struct wl_priv *wl;
+	s32 err = 0;
+	int val = 1;
+	dhd_pub_t *dhd;
 
-	flags = wl_lock_eq(wl);
-	while (!list_empty(&wl->eq_list)) {
-		e = list_first_entry(&wl->eq_list, struct wl_event_q, eq_list);
-		list_del(&e->eq_list);
-		kfree(e);
+	(void)para;
+	WL_DBG(("In\n"));
+	wl = wlcfg_drv_priv;
+
+	if ((err = wldev_ioctl(wl_to_prmry_ndev(wl), WLC_GET_VERSION, &val,
+		sizeof(int), false) < 0)) {
+		WL_ERR(("WLC_GET_VERSION failed, err=%d\n", err));
+		return err;
 	}
-	wl_unlock_eq(wl, flags);
-}
+	val = dtoh32(val);
+	if (val != WLC_IOCTL_VERSION && val != 1) {
+		WL_ERR(("Version mismatch, please upgrade. Got %d, expected %d or 1\n",
+			val, WLC_IOCTL_VERSION));
+		return BCME_VERSION;
+	}
+	ioctl_version = val;
+	WL_TRACE(("WLC_GET_VERSION=%d\n", ioctl_version));
 
-/*
-* retrieve first queued event from head
-*/
+	mutex_lock(&wl->usr_sync);
+	dhd = (dhd_pub_t *)(wl->pub);
+	if (!(dhd->op_mode & DHD_FLAG_HOSTAP_MODE)) {
+		err = wl_cfg80211_attach_post(wl_to_prmry_ndev(wl));
+		if (unlikely(err))
+			return err;
+	}
+#if defined(BCMSUP_4WAY_HANDSHAKE) && defined(WLAN_AKM_SUITE_FT_8021X)
+	if (dhd->fw_4way_handshake)
+		wl->wdev->wiphy->features |= NL80211_FEATURE_FW_4WAY_HANDSHAKE;
+#endif
+	err = __wl_cfg80211_up(wl);
+	if (unlikely(err))
+		WL_ERR(("__wl_cfg80211_up failed\n"));
+// for reduce First scan time
+	first_broadcast_scan = TRUE;
+	mutex_unlock(&wl->usr_sync);
+	return err;
+}
 
-static struct wl_event_q *wl_deq_event(struct wl_priv *wl)
+/* Private Event to Supplicant with indication that chip hangs */
+int wl_cfg80211_hang(struct net_device *dev, u16 reason)
 {
-	struct wl_event_q *e = NULL;
-	unsigned long flags;
+	struct wl_priv *wl;
+	wl = wlcfg_drv_priv;
 
-	flags = wl_lock_eq(wl);
-	if (likely(!list_empty(&wl->eq_list))) {
-		e = list_first_entry(&wl->eq_list, struct wl_event_q, eq_list);
-		list_del(&e->eq_list);
+	WL_ERR(("In : chip crash eventing\n"));
+	cfg80211_disconnected(dev, reason, NULL, 0, GFP_KERNEL);
+	if (wl != NULL) {
+		wl_link_down(wl);
 	}
-	wl_unlock_eq(wl, flags);
-
-	return e;
+	return 0;
 }
 
-/*
- * push event to tail of the queue
- */
-
-static s32
-wl_enq_event(struct wl_priv *wl, struct net_device *ndev, u32 event, const wl_event_msg_t *msg,
-	void *data)
+s32 wl_cfg80211_down(void *para)
 {
-	struct wl_event_q *e;
+	struct wl_priv *wl;
 	s32 err = 0;
-	uint32 evtq_size;
-	uint32 data_len;
-	unsigned long flags;
-	gfp_t aflags;
+#ifdef PROP_TXSTATUS_VSDB
+	dhd_pub_t *dhd = NULL;
+#endif /* PROP_TXSTATUS_VSDB */
 
-	data_len = 0;
-	if (data)
-		data_len = ntoh32(msg->datalen);
-	evtq_size = sizeof(struct wl_event_q) + data_len;
-	aflags = (in_atomic()) ? GFP_ATOMIC : GFP_KERNEL;
-	e = kzalloc(evtq_size, aflags);
-	if (unlikely(!e)) {
-		WL_ERR(("event alloc failed\n"));
-		return -ENOMEM;
-	}
-	e->etype = event;
-	memcpy(&e->emsg, msg, sizeof(wl_event_msg_t));
-	if (data)
-		memcpy(e->edata, data, data_len);
-	flags = wl_lock_eq(wl);
-	list_add_tail(&e->eq_list, &wl->eq_list);
-	wl_unlock_eq(wl, flags);
+	(void)para;
+	WL_DBG(("In\n"));
+	wl = wlcfg_drv_priv;
+	mutex_lock(&wl->usr_sync);
+	err = __wl_cfg80211_down(wl);
+	mutex_unlock(&wl->usr_sync);
+#ifdef PROP_TXSTATUS_VSDB
+	dhd =  (dhd_pub_t *)(wl->pub);
+	/* disable wlfc */
+	if (dhd->wlfc_state) {
+		dhd->wlfc_enabled = false;
+		dhd_wlfc_deinit(dhd);
+		wl->wlfc_on = false;
+	}	
+#endif
 
 	return err;
 }
 
-static void wl_put_event(struct wl_event_q *e)
+static void *wl_read_prof(struct wl_priv *wl, struct net_device *ndev, s32 item)
 {
-	kfree(e);
+	unsigned long flags;
+	void *rptr = NULL;
+	struct wl_profile *profile = wl_get_profile_by_netdev(wl, ndev);
+
+	if (!profile)
+		return NULL;
+	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
+	switch (item) {
+	case WL_PROF_SEC:
+		rptr = &profile->sec;
+		break;
+	case WL_PROF_ACT:
+		rptr = &profile->active;
+		break;
+	case WL_PROF_BSSID:
+		rptr = profile->bssid;
+		break;
+	case WL_PROF_SSID:
+		rptr = &profile->ssid;
+		break;
+	case WL_PROF_CHAN:
+		rptr = &profile->channel;
+		break;
+	}
+	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
+	if (!rptr)
+		WL_ERR(("invalid item (%d)\n", item));
+	return rptr;
 }
 
-static s32 wl_config_ifmode(struct wl_priv *wl, struct net_device *ndev, s32 iftype)
+static s32
+wl_update_prof(struct wl_priv *wl, struct net_device *ndev,
+	const wl_event_msg_t *e, void *data, s32 item)
 {
-	s32 infra = 0;
 	s32 err = 0;
-	s32 mode = 0;
-	switch (iftype) {
-	case NL80211_IFTYPE_MONITOR:
-	case NL80211_IFTYPE_WDS:
-		WL_ERR(("type (%d) : currently we do not support this mode\n",
-			iftype));
-		err = -EINVAL;
-		return err;
-	case NL80211_IFTYPE_ADHOC:
-		mode = WL_MODE_IBSS;
+	struct wlc_ssid *ssid;
+	unsigned long flags;
+	struct wl_profile *profile = wl_get_profile_by_netdev(wl, ndev);
+
+	if (!profile)
+		return WL_INVALID;
+	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
+	switch (item) {
+	case WL_PROF_SSID:
+		ssid = (wlc_ssid_t *) data;
+		memset(profile->ssid.SSID, 0,
+			sizeof(profile->ssid.SSID));
+		memcpy(profile->ssid.SSID, ssid->SSID, ssid->SSID_len);
+		profile->ssid.SSID_len = ssid->SSID_len;
+		break;
+	case WL_PROF_BSSID:
+		if (data)
+			memcpy(profile->bssid, data, ETHER_ADDR_LEN);
+		else
+			memset(profile->bssid, 0, ETHER_ADDR_LEN);
+		break;
+	case WL_PROF_SEC:
+		memcpy(&profile->sec, data, sizeof(profile->sec));
+		break;
+	case WL_PROF_ACT:
+		profile->active = *(bool *)data;
+		break;
+	case WL_PROF_BEACONINT:
+		profile->beacon_interval = *(u16 *)data;
 		break;
-	case NL80211_IFTYPE_STATION:
-	case NL80211_IFTYPE_P2P_CLIENT:
-		mode = WL_MODE_BSS;
-		infra = 1;
+	case WL_PROF_DTIMPERIOD:
+		profile->dtim_period = *(u8 *)data;
 		break;
-	case NL80211_IFTYPE_AP:
-	case NL80211_IFTYPE_P2P_GO:
-		mode = WL_MODE_AP;
-		infra = 1;
+	case WL_PROF_CHAN:
+		profile->channel = *(u32*)data;
 		break;
 	default:
-		err = -EINVAL;
-		WL_ERR(("invalid type (%d)\n", iftype));
-		return err;
-	}
-	infra = htod32(infra);
-	err = wldev_ioctl(ndev, WLC_SET_INFRA, &infra, sizeof(infra), true);
-	if (unlikely(err)) {
-		WL_ERR(("WLC_SET_INFRA error (%d)\n", err));
-		return err;
+		err = -EOPNOTSUPP;
+		break;
 	}
+	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
 
-	wl_set_mode_by_netdev(wl, ndev, mode);
+	if (err == -EOPNOTSUPP)
+		WL_ERR(("unsupported item (%d)\n", item));
 
-	return 0;
+	return err;
 }
 
-static s32 wl_add_remove_eventmsg(struct net_device *ndev, u16 event, bool add)
+void wl_cfg80211_dbg_level(u32 level)
 {
-	s8 iovbuf[WL_EVENTING_MASK_LEN + 12];
+	/*
+	* prohibit to change debug level
+	* by insmod parameter.
+	* eventually debug level will be configured
+	* in compile time by using CONFIG_XXX
+	*/
+	/* wl_dbg_level = level; */
+}
 
-	s8 eventmask[WL_EVENTING_MASK_LEN];
-	s32 err = 0;
+static bool wl_is_ibssmode(struct wl_priv *wl, struct net_device *ndev)
+{
+	return wl_get_mode_by_netdev(wl, ndev) == WL_MODE_IBSS;
+}
 
-	/* Setup event_msgs */
-	bcm_mkiovar("event_msgs", NULL, 0, iovbuf,
-		sizeof(iovbuf));
-	err = wldev_ioctl(ndev, WLC_GET_VAR, iovbuf, sizeof(iovbuf), false);
-	if (unlikely(err)) {
-		WL_ERR(("Get event_msgs error (%d)\n", err));
-		goto eventmsg_out;
-	}
-	memcpy(eventmask, iovbuf, WL_EVENTING_MASK_LEN);
-	if (add) {
-		setbit(eventmask, event);
-	} else {
-		clrbit(eventmask, event);
-	}
-	bcm_mkiovar("event_msgs", eventmask, WL_EVENTING_MASK_LEN, iovbuf,
-		sizeof(iovbuf));
-	err = wldev_ioctl(ndev, WLC_SET_VAR, iovbuf, sizeof(iovbuf), true);
-	if (unlikely(err)) {
-		WL_ERR(("Set event_msgs error (%d)\n", err));
-		goto eventmsg_out;
-	}
+static __used bool wl_is_ibssstarter(struct wl_priv *wl)
+{
+	return wl->ibss_starter;
+}
 
-eventmsg_out:
-	return err;
+static void wl_rst_ie(struct wl_priv *wl)
+{
+	struct wl_ie *ie = wl_to_ie(wl);
 
+	ie->offset = 0;
 }
 
-s32 wl_update_wiphybands(struct wl_priv *wl)
+static __used s32 wl_add_ie(struct wl_priv *wl, u8 t, u8 l, u8 *v)
 {
-	struct wiphy *wiphy;
-	u32 bandlist[3];
-	u32 nband = 0;
-	u32 i = 0;
+	struct wl_ie *ie = wl_to_ie(wl);
 	s32 err = 0;
-	int nmode = 0;
-	int bw_40 = 0;
-	int index = 0;
 
-	WL_DBG(("Entry"));
-	memset(bandlist, 0, sizeof(bandlist));
-	err = wldev_ioctl(wl_to_prmry_ndev(wl), WLC_GET_BANDLIST, bandlist,
-		sizeof(bandlist), false);
-	if (unlikely(err)) {
-		WL_ERR(("error (%d)\n", err));
-		return err;
-	}
-	wiphy = wl_to_wiphy(wl);
-	nband = bandlist[0];
-	wiphy->bands[IEEE80211_BAND_2GHZ] = &__wl_band_2ghz;
-	wiphy->bands[IEEE80211_BAND_5GHZ] = NULL;
-
-	err = wldev_iovar_getint(wl_to_prmry_ndev(wl), "nmode", &nmode);
-	if (unlikely(err)) {
-		WL_ERR(("error reading nmode (%d)\n", err));
-	}
-	else {
-		/* For nmodeonly  check bw cap */
-		err = wldev_iovar_getint(wl_to_prmry_ndev(wl), "mimo_bw_cap", &bw_40);
-		if (unlikely(err)) {
-			WL_ERR(("error get mimo_bw_cap (%d)\n", err));
-		}
+	if (unlikely(ie->offset + l + 2 > WL_TLV_INFO_MAX)) {
+		WL_ERR(("ei crosses buffer boundary\n"));
+		return -ENOSPC;
 	}
+	ie->buf[ie->offset] = t;
+	ie->buf[ie->offset + 1] = l;
+	memcpy(&ie->buf[ie->offset + 2], v, l);
+	ie->offset += l + 2;
 
-	for (i = 1; i <= nband && i < sizeof(bandlist)/sizeof(u32); i++) {
-		index = -1;
-		if (bandlist[i] == WLC_BAND_5G) {
-			wiphy->bands[IEEE80211_BAND_5GHZ] =
-				&__wl_band_5ghz_a;
-				index = IEEE80211_BAND_5GHZ;
-		} else if (bandlist[i] == WLC_BAND_2G) {
-			wiphy->bands[IEEE80211_BAND_2GHZ] =
-				&__wl_band_2ghz;
-				index = IEEE80211_BAND_2GHZ;
-		}
+	return err;
+}
 
-		if ((index >= 0) && nmode) {
-			wiphy->bands[index]->ht_cap.cap =
-			IEEE80211_HT_CAP_SGI_20 | IEEE80211_HT_CAP_DSSSCCK40
-			| IEEE80211_HT_CAP_MAX_AMSDU;
-			wiphy->bands[index]->ht_cap.ht_supported = TRUE;
-			wiphy->bands[index]->ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;
-			wiphy->bands[index]->ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_16;
-		}
+static s32 wl_mrg_ie(struct wl_priv *wl, u8 *ie_stream, u16 ie_size)
+{
+	struct wl_ie *ie = wl_to_ie(wl);
+	s32 err = 0;
 
-		if ((index >= 0) && bw_40) {
-			wiphy->bands[index]->ht_cap.cap |= IEEE80211_HT_CAP_SGI_40;
-		}
+	if (unlikely(ie->offset + ie_size > WL_TLV_INFO_MAX)) {
+		WL_ERR(("ei_stream crosses buffer boundary\n"));
+		return -ENOSPC;
 	}
+	memcpy(&ie->buf[ie->offset], ie_stream, ie_size);
+	ie->offset += ie_size;
 
-	wiphy_apply_custom_regulatory(wiphy, &brcm_regdom);
 	return err;
 }
 
-static s32 __wl_cfg80211_up(struct wl_priv *wl)
+static s32 wl_cp_ie(struct wl_priv *wl, u8 *dst, u16 dst_size)
 {
+	struct wl_ie *ie = wl_to_ie(wl);
 	s32 err = 0;
-	struct net_device *ndev = wl_to_prmry_ndev(wl);
-	struct wireless_dev *wdev = ndev->ieee80211_ptr;
-
-	WL_DBG(("In\n"));
-
-	err = dhd_config_dongle(wl, false);
-	if (unlikely(err))
-		return err;
 
-	err = wl_config_ifmode(wl, ndev, wdev->iftype);
-	if (unlikely(err && err != -EINPROGRESS)) {
-		WL_ERR(("wl_config_ifmode failed\n"));
-	}
-	err = wl_update_wiphybands(wl);
-	if (unlikely(err)) {
-		WL_ERR(("wl_update_wiphybands failed\n"));
+	if (unlikely(ie->offset > dst_size)) {
+		WL_ERR(("dst_size is not enough\n"));
+		return -ENOSPC;
 	}
+	memcpy(dst, &ie->buf[0], ie->offset);
 
-	err = dhd_monitor_init(wl->pub);
-	err = wl_invoke_iscan(wl);
-	wl_set_drv_status(wl, READY, ndev);
 	return err;
 }
 
-static s32 __wl_cfg80211_down(struct wl_priv *wl)
+static u32 wl_get_ielen(struct wl_priv *wl)
 {
-	s32 err = 0;
-	unsigned long flags;
-	struct net_info *iter, *next;
-	struct net_device *ndev = wl_to_prmry_ndev(wl);
+	struct wl_ie *ie = wl_to_ie(wl);
 
-	WL_DBG(("In\n"));
-	/* Check if cfg80211 interface is already down */
-	if (!wl_get_drv_status(wl, READY, ndev))
-		return err;	/* it is even not ready */
-	for_each_ndev(wl, iter, next)
-		wl_set_drv_status(wl, SCAN_ABORTING, iter->ndev);
+	return ie->offset;
+}
 
-	wl_term_iscan(wl);
-	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
-	if (wl->scan_request) {
-		cfg80211_scan_done(wl->scan_request, true);
-		wl->scan_request = NULL;
-	}
-	for_each_ndev(wl, iter, next) {
-		wl_clr_drv_status(wl, READY, iter->ndev);
-		wl_clr_drv_status(wl, SCANNING, iter->ndev);
-		wl_clr_drv_status(wl, SCAN_ABORTING, iter->ndev);
-		wl_clr_drv_status(wl, CONNECTING, iter->ndev);
-		wl_clr_drv_status(wl, CONNECTED, iter->ndev);
-		wl_clr_drv_status(wl, DISCONNECTING, iter->ndev);
-		wl_clr_drv_status(wl, AP_CREATED, iter->ndev);
-		wl_clr_drv_status(wl, AP_CREATING, iter->ndev);
-	}
-	wl_to_prmry_ndev(wl)->ieee80211_ptr->iftype =
-		NL80211_IFTYPE_STATION;
-	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
+static void wl_link_up(struct wl_priv *wl)
+{
+	wl->link_up = true;
+}
 
-	DNGL_FUNC(dhd_cfg80211_down, (wl));
-	wl_flush_eq(wl);
-	wl_link_down(wl);
-	if (wl->p2p_supported)
-		wl_cfgp2p_down(wl);
-	dhd_monitor_uninit();
+static void wl_link_down(struct wl_priv *wl)
+{
+	struct wl_connect_info *conn_info = wl_to_conn(wl);
 
-	return err;
+	WL_DBG(("In\n"));
+	wl->link_up = false;
+	conn_info->req_ie_len = 0;
+	conn_info->resp_ie_len = 0;
 }
 
-s32 wl_cfg80211_up(void *para)
+static unsigned long wl_lock_eq(struct wl_priv *wl)
 {
-	struct wl_priv *wl;
-	s32 err = 0;
-	int val = 1;
+	unsigned long flags;
 
-	(void)para;
-	WL_DBG(("In\n"));
-	wl = wlcfg_drv_priv;
+	spin_lock_irqsave(&wl->eq_lock, flags);
+	return flags;
+}
 
-	if ((err = wldev_ioctl(wl_to_prmry_ndev(wl), WLC_GET_VERSION, &val,
-		sizeof(int), false) < 0)) {
-		WL_ERR(("WLC_GET_VERSION failed, err=%d\n", err));
-		return err;
+static void wl_unlock_eq(struct wl_priv *wl, unsigned long flags)
+{
+	spin_unlock_irqrestore(&wl->eq_lock, flags);
+}
+
+static void wl_init_eq_lock(struct wl_priv *wl)
+{
+	spin_lock_init(&wl->eq_lock);
+}
+
+static void wl_delay(u32 ms)
+{
+	if (in_atomic() || (ms < jiffies_to_msecs(1))) {
+		mdelay(ms);
+	} else {
+		msleep(ms);
 	}
-	val = dtoh32(val);
-	if (val != WLC_IOCTL_VERSION && val != 1) {
-		WL_ERR(("Version mismatch, please upgrade. Got %d, expected %d or 1\n",
-			val, WLC_IOCTL_VERSION));
-		return BCME_VERSION;
+}
+
+s32 wl_cfg80211_get_p2p_dev_addr(struct net_device *net, struct ether_addr *p2pdev_addr)
+{
+	struct wl_priv *wl = wlcfg_drv_priv;
+	struct ether_addr p2pif_addr;
+	struct ether_addr primary_mac;
+	if (!wl->p2p)
+		return -1;
+	if (!p2p_is_on(wl)) {
+		get_primary_mac(wl, &primary_mac);
+		wl_cfgp2p_generate_bss_mac(&primary_mac, p2pdev_addr, &p2pif_addr);
+	} else {
+		memcpy(p2pdev_addr->octet,
+			wl->p2p->dev_addr.octet, ETHER_ADDR_LEN);
 	}
-	ioctl_version = val;
-	WL_ERR(("WLC_GET_VERSION=%d\n", ioctl_version));
 
-	mutex_lock(&wl->usr_sync);
-	wl_cfg80211_attach_post(wl_to_prmry_ndev(wl));
-	err = __wl_cfg80211_up(wl);
-	if (err)
-		WL_ERR(("__wl_cfg80211_up failed\n"));
-	mutex_unlock(&wl->usr_sync);
 
-	return err;
+	return 0;
+}
+s32 wl_cfg80211_set_p2p_noa(struct net_device *net, char* buf, int len)
+{
+	struct wl_priv *wl;
+
+	wl = wlcfg_drv_priv;
+
+	return wl_cfgp2p_set_p2p_noa(wl, net, buf, len);
 }
 
-/* Private Event to Supplicant with indication that chip hangs */
-int wl_cfg80211_hang(struct net_device *dev, u16 reason)
+s32 wl_cfg80211_get_p2p_noa(struct net_device *net, char* buf, int len)
 {
 	struct wl_priv *wl;
 	wl = wlcfg_drv_priv;
 
-	WL_ERR(("In : chip crash eventing\n"));
-	cfg80211_disconnected(dev, reason, NULL, 0, GFP_KERNEL);
-	if (wl != NULL) {
-		wl_link_down(wl);
-	}
-	return 0;
+	return wl_cfgp2p_get_p2p_noa(wl, net, buf, len);
 }
 
-s32 wl_cfg80211_down(void *para)
+s32 wl_cfg80211_set_p2p_ps(struct net_device *net, char* buf, int len)
 {
 	struct wl_priv *wl;
-	s32 err = 0;
-
-	(void)para;
-	WL_DBG(("In\n"));
 	wl = wlcfg_drv_priv;
-	mutex_lock(&wl->usr_sync);
-	err = __wl_cfg80211_down(wl);
-	mutex_unlock(&wl->usr_sync);
 
-	return err;
+	return wl_cfgp2p_set_p2p_ps(wl, net, buf, len);
 }
 
-static void *wl_read_prof(struct wl_priv *wl, struct net_device *ndev, s32 item)
+s32 wl_cfg80211_channel_to_freq(u32 channel)
 {
-	unsigned long flags;
-	void *rptr = NULL;
-	struct wl_profile *profile = wl_get_profile_by_netdev(wl, ndev);
+	int freq = 0;
 
-	if (!profile)
-		return NULL;
-	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
-	switch (item) {
-	case WL_PROF_SEC:
-		rptr = &profile->sec;
-		break;
-	case WL_PROF_ACT:
-		rptr = &profile->active;
-		break;
-	case WL_PROF_BSSID:
-		rptr = profile->bssid;
-		break;
-	case WL_PROF_SSID:
-		rptr = &profile->ssid;
-		break;
+#if LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 38) && !defined(WL_COMPAT_WIRELESS)
+	freq = ieee80211_channel_to_frequency(channel);
+#else
+	{
+		u16 band = 0;
+		if (channel <= CH_MAX_2G_CHANNEL)
+			band = IEEE80211_BAND_2GHZ;
+		else
+			band = IEEE80211_BAND_5GHZ;
+		freq = ieee80211_channel_to_frequency(channel, band);
 	}
-	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
-	if (!rptr)
-		WL_ERR(("invalid item (%d)\n", item));
-	return rptr;
+#endif
+	return freq;
 }
 
+
+#ifdef WLTDLS
 static s32
-wl_update_prof(struct wl_priv *wl, struct net_device *ndev,
-	const wl_event_msg_t *e, void *data, s32 item)
-{
-	s32 err = 0;
-	struct wlc_ssid *ssid;
-	unsigned long flags;
-	struct wl_profile *profile = wl_get_profile_by_netdev(wl, ndev);
+wl_tdls_event_handler(struct wl_priv *wl, struct net_device *ndev,
+	const wl_event_msg_t *e, void *data) {
 
-	if (!profile)
-		return WL_INVALID;
-	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
-	switch (item) {
-	case WL_PROF_SSID:
-		ssid = (wlc_ssid_t *) data;
-		memset(profile->ssid.SSID, 0,
-			sizeof(profile->ssid.SSID));
-		memcpy(profile->ssid.SSID, ssid->SSID, ssid->SSID_len);
-		profile->ssid.SSID_len = ssid->SSID_len;
+	u32 reason = ntoh32(e->reason);
+	s8 *msg = NULL;
+	switch (reason) {
+	case WLC_E_TDLS_PEER_DISCOVERED :
+		msg = " TDLS PEER DISCOVERD ";
 		break;
-	case WL_PROF_BSSID:
-		if (data)
-			memcpy(profile->bssid, data, ETHER_ADDR_LEN);
-		else
-			memset(profile->bssid, 0, ETHER_ADDR_LEN);
+	case WLC_E_TDLS_PEER_CONNECTED :
+		msg = " TDLS PEER CONNECTED ";
 		break;
-	case WL_PROF_SEC:
-		memcpy(&profile->sec, data, sizeof(profile->sec));
+	case WLC_E_TDLS_PEER_DISCONNECTED :
+		msg = "TDLS PEER DISCONNECTED ";
 		break;
-	case WL_PROF_ACT:
-		profile->active = *(bool *)data;
+	}
+	if (msg) {
+		WL_ERR(("%s: " MACDBG " on %s ndev\n", msg, MAC2STRDBG((u8*)(&e->addr)),
+			(wl_to_prmry_ndev(wl) == ndev) ? "primary" : "secondary"));
+	}
+	return 0;
+
+}
+#endif  /* WLTDLS */
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 2, 0)
+static s32
+wl_cfg80211_tdls_oper(struct wiphy *wiphy, struct net_device *dev,
+	u8 *peer, enum nl80211_tdls_operation oper)
+{
+	s32 ret = 0;
+#ifdef WLTDLS
+	struct wl_priv *wl;
+	tdls_iovar_t info;
+	wl = wlcfg_drv_priv;
+	memset(&info, 0, sizeof(tdls_iovar_t));
+	if (peer)
+		memcpy(&info.ea, peer, ETHER_ADDR_LEN);
+	switch (oper) {
+	case NL80211_TDLS_DISCOVERY_REQ:
+		info.mode = TDLS_MANUAL_EP_DISCOVERY;
 		break;
-	case WL_PROF_BEACONINT:
-		profile->beacon_interval = *(u16 *)data;
+	case NL80211_TDLS_SETUP:
+		info.mode = TDLS_MANUAL_EP_CREATE;
 		break;
-	case WL_PROF_DTIMPERIOD:
-		profile->dtim_period = *(u8 *)data;
+	case NL80211_TDLS_TEARDOWN:
+		info.mode = TDLS_MANUAL_EP_DELETE;
 		break;
 	default:
-		WL_ERR(("unsupported item (%d)\n", item));
-		err = -EOPNOTSUPP;
-		break;
+		WL_ERR(("Unsupported operation : %d\n", oper));
+		goto out;
 	}
-	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
-	return err;
+	ret = wldev_iovar_setbuf(dev, "tdls_endpoint", &info, sizeof(info),
+		wl->ioctl_buf, WLC_IOCTL_MAXLEN, &wl->ioctl_buf_sync);
+	if (ret) {
+		WL_ERR(("tdls_endpoint error %d\n", ret));
+	}
+out:
+#endif /* WLTDLS */
+	return ret;
 }
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(3, 2, 0) */
 
-void wl_cfg80211_dbg_level(u32 level)
+s32 wl_cfg80211_set_wps_p2p_ie(struct net_device *net, char *buf, int len,
+	enum wl_management_type type)
 {
-	/*
-	* prohibit to change debug level
-	* by insmod parameter.
-	* eventually debug level will be configured
-	* in compile time by using CONFIG_XXX
-	*/
-	/* wl_dbg_level = level; */
-}
+	struct wl_priv *wl;
+	struct net_device *ndev = NULL;
+	struct ether_addr primary_mac;
+	s32 ret = 0;
+	s32 bssidx = 0;
+	s32 pktflag = 0;
+	wl = wlcfg_drv_priv;
 
-static bool wl_is_ibssmode(struct wl_priv *wl, struct net_device *ndev)
-{
-	return wl_get_mode_by_netdev(wl, ndev) == WL_MODE_IBSS;
+	if (wl_get_drv_status(wl, AP_CREATING, net) ||
+		wl_get_drv_status(wl, AP_CREATED, net)) {
+		ndev = net;
+		bssidx = 0;
+	} else if (wl->p2p) {
+		if (net == wl->p2p_net) {
+			net = wl_to_prmry_ndev(wl);
+		}
+		if (!wl->p2p->on) {
+			get_primary_mac(wl, &primary_mac);
+			wl_cfgp2p_generate_bss_mac(&primary_mac, &wl->p2p->dev_addr,
+				&wl->p2p->int_addr);
+			/* In case of p2p_listen command, supplicant send remain_on_channel
+			* without turning on P2P
+			*/
+
+			p2p_on(wl) = true;
+			ret = wl_cfgp2p_enable_discovery(wl, net, NULL, 0);
+
+			if (unlikely(ret)) {
+				goto exit;
+			}
+		}
+		if (net  != wl_to_prmry_ndev(wl)) {
+			if (wl_get_mode_by_netdev(wl, net) == WL_MODE_AP) {
+				ndev = wl_to_p2p_bss_ndev(wl, P2PAPI_BSSCFG_CONNECTION);
+				bssidx = wl_to_p2p_bss_bssidx(wl, P2PAPI_BSSCFG_CONNECTION);
+			}
+		} else {
+				ndev = wl_to_p2p_bss_ndev(wl, P2PAPI_BSSCFG_PRIMARY);
+				bssidx = wl_to_p2p_bss_bssidx(wl, P2PAPI_BSSCFG_DEVICE);
+		}
+	}
+	if (ndev != NULL) {
+		switch (type) {
+			case WL_BEACON:
+				pktflag = VNDR_IE_BEACON_FLAG;
+				break;
+			case WL_PROBE_RESP:
+				pktflag = VNDR_IE_PRBRSP_FLAG;
+				break;
+			case WL_ASSOC_RESP:
+				pktflag = VNDR_IE_ASSOCRSP_FLAG;
+				break;
+		}
+		if (pktflag)
+			ret = wl_cfgp2p_set_management_ie(wl, ndev, bssidx, pktflag, buf, len);
+	}
+exit:
+	return ret;
 }
 
-static __used bool wl_is_ibssstarter(struct wl_priv *wl)
+#ifdef WL_SUPPORT_AUTO_CHANNEL
+static s32
+wl_cfg80211_set_auto_channel_scan_state(struct net_device *ndev)
 {
-	return wl->ibss_starter;
+	u32 val = 0;
+	s32 ret = BCME_ERROR;
+	struct wl_priv *wl = wlcfg_drv_priv;
+
+	/* Disable mpc, to avoid automatic interface down. */
+	val = 0;
+
+	ret = wldev_iovar_setbuf_bsscfg(ndev, "mpc", (void *)&val,
+		sizeof(val), wl->ioctl_buf, WLC_IOCTL_SMLEN, 0,
+		&wl->ioctl_buf_sync);
+	if (ret < 0) {
+		WL_ERR(("set 'mpc' failed, error = %d\n", ret));
+		goto done;
+	}
+
+	/* Set interface up, explicitly. */
+	val = 1;
+
+	ret = wldev_ioctl(ndev, WLC_UP, (void *)&val, sizeof(val), true);
+	if (ret < 0) {
+		WL_ERR(("set interface up failed, error = %d\n", ret));
+		goto done;
+	}
+
+	/* Stop all scan explicitly, till auto channel selection complete. */
+	wl_set_drv_status(wl, SCANNING, ndev);
+	ret = wl_notify_escan_complete(wl, ndev, true, true);
+	if (ret < 0) {
+		WL_ERR(("set scan abort failed, error = %d\n", ret));
+		goto done;
+	}
+
+done:
+	return ret;
 }
 
-static void wl_rst_ie(struct wl_priv *wl)
+static bool
+wl_cfg80211_valid_chanspec_p2p(chanspec_t chanspec)
 {
-	struct wl_ie *ie = wl_to_ie(wl);
+	bool valid = false;
 
-	ie->offset = 0;
+	/* channel 1 to 14 */
+	if ((chanspec >= 0x2b01) && (chanspec <= 0x2b0e)) {
+		valid = true;
+	}
+	/* channel 36 to 48 */
+	else if ((chanspec >= 0x1b24) && (chanspec <= 0x1b30)) {
+		valid = true;
+	}
+	/* channel 149 to 161 */
+	else if ((chanspec >= 0x1b95) && (chanspec <= 0x1ba1)) {
+		valid = true;
+	}
+	else {
+		valid = false;
+		WL_INFO(("invalid P2P chanspec, channel = %d, chanspec = %04x\n",
+			CHSPEC_CHANNEL(chanspec), chanspec));
+	}
+
+	return valid;
 }
 
-static __used s32 wl_add_ie(struct wl_priv *wl, u8 t, u8 l, u8 *v)
+static s32
+wl_cfg80211_get_chanspecs_2g(struct net_device *ndev, void *buf, s32 buflen)
 {
-	struct wl_ie *ie = wl_to_ie(wl);
-	s32 err = 0;
+	s32 ret = BCME_ERROR;
+	struct wl_priv *wl = NULL;
+	wl_uint32_list_t *list = NULL;
+	chanspec_t chanspec = 0;
 
-	if (unlikely(ie->offset + l + 2 > WL_TLV_INFO_MAX)) {
-		WL_ERR(("ei crosses buffer boundary\n"));
-		return -ENOSPC;
+	memset(buf, 0, buflen);
+
+	wl = wlcfg_drv_priv;
+	list = (wl_uint32_list_t *)buf;
+	list->count = htod32(WL_NUMCHANSPECS);
+
+	/* Restrict channels to 2.4GHz, 20MHz BW, no SB. */
+	chanspec |= (WL_CHANSPEC_BAND_2G | WL_CHANSPEC_BW_20 |
+		WL_CHANSPEC_CTL_SB_NONE);
+	chanspec = wl_chspec_host_to_driver(chanspec);
+
+	ret = wldev_iovar_getbuf_bsscfg(ndev, "chanspecs", (void *)&chanspec,
+		sizeof(chanspec), buf, buflen, 0, &wl->ioctl_buf_sync);
+	if (ret < 0) {
+		WL_ERR(("get 'chanspecs' failed, error = %d\n", ret));
 	}
-	ie->buf[ie->offset] = t;
-	ie->buf[ie->offset + 1] = l;
-	memcpy(&ie->buf[ie->offset + 2], v, l);
-	ie->offset += l + 2;
 
-	return err;
+	return ret;
 }
 
-static s32 wl_mrg_ie(struct wl_priv *wl, u8 *ie_stream, u16 ie_size)
+static s32
+wl_cfg80211_get_chanspecs_5g(struct net_device *ndev, void *buf, s32 buflen)
 {
-	struct wl_ie *ie = wl_to_ie(wl);
-	s32 err = 0;
+	u32 channel = 0;
+	s32 ret = BCME_ERROR;
+	s32 i = 0;
+	s32 j = 0;
+	struct wl_priv *wl = NULL;
+	wl_uint32_list_t *list = NULL;
+	chanspec_t chanspec = 0;
 
-	if (unlikely(ie->offset + ie_size > WL_TLV_INFO_MAX)) {
-		WL_ERR(("ei_stream crosses buffer boundary\n"));
-		return -ENOSPC;
+	memset(buf, 0, buflen);
+
+	wl = wlcfg_drv_priv;
+	list = (wl_uint32_list_t *)buf;
+	list->count = htod32(WL_NUMCHANSPECS);
+
+	/* Restrict channels to 5GHz, 20MHz BW, no SB. */
+	chanspec |= (WL_CHANSPEC_BAND_5G | WL_CHANSPEC_BW_20 |
+		WL_CHANSPEC_CTL_SB_NONE);
+	chanspec = wl_chspec_host_to_driver(chanspec);
+
+	ret = wldev_iovar_getbuf_bsscfg(ndev, "chanspecs", (void *)&chanspec,
+		sizeof(chanspec), buf, buflen, 0, &wl->ioctl_buf_sync);
+	if (ret < 0) {
+		WL_ERR(("get 'chanspecs' failed, error = %d\n", ret));
+		goto done;
 	}
-	memcpy(&ie->buf[ie->offset], ie_stream, ie_size);
-	ie->offset += ie_size;
 
-	return err;
+	/* Skip DFS and inavlid P2P channel. */
+	for (i = 0, j = 0; i < dtoh32(list->count); i++) {
+		chanspec = (chanspec_t) dtoh32(list->element[i]);
+		channel = CHSPEC_CHANNEL(chanspec);
+
+		ret = wldev_iovar_getint(ndev, "per_chan_info", &channel);
+		if (ret < 0) {
+			WL_ERR(("get 'per_chan_info' failed, error = %d\n", ret));
+			goto done;
+		}
+
+		if (CHANNEL_IS_RADAR(channel) ||
+			!(wl_cfg80211_valid_chanspec_p2p(chanspec))) {
+			continue;
+		} else {
+			list->element[j] = list->element[i];
+		}
+
+		j++;
+	}
+
+	list->count = j;
+
+done:
+	return ret;
 }
 
-static s32 wl_cp_ie(struct wl_priv *wl, u8 *dst, u16 dst_size)
-{
-	struct wl_ie *ie = wl_to_ie(wl);
-	s32 err = 0;
+static s32
+wl_cfg80211_get_best_channel(struct net_device *ndev, void *buf, int buflen,
+	int *channel)
+{
+	s32 ret = BCME_ERROR;
+	int chosen = 0;
+	int retry = 0;
+
+	/* Start auto channel selection scan. */
+	ret = wldev_ioctl(ndev, WLC_START_CHANNEL_SEL, buf, buflen, true);
+	if (ret < 0) {
+		WL_ERR(("can't start auto channel scan, error = %d\n", ret));
+		*channel = 0;
+		goto done;
+	}
 
-	if (unlikely(ie->offset > dst_size)) {
-		WL_ERR(("dst_size is not enough\n"));
-		return -ENOSPC;
+	/* Wait for auto channel selection, worst case possible delay is 5250ms. */
+	retry = CHAN_SEL_RETRY_COUNT;
+
+	while (retry--) {
+		bcm_mdelay(CHAN_SEL_IOCTL_DELAY);
+
+		ret = wldev_ioctl(ndev, WLC_GET_CHANNEL_SEL, &chosen, sizeof(chosen),
+			false);
+		if ((ret == 0) && (dtoh32(chosen) != 0)) {
+			*channel = (u16)(chosen & 0x00FF);
+			WL_INFO(("selected channel = %d\n", *channel));
+			break;
+		}
+		WL_INFO(("attempt = %d, ret = %d, chosen = %d\n",
+			(CHAN_SEL_RETRY_COUNT - retry), ret, dtoh32(chosen)));
 	}
-	memcpy(dst, &ie->buf[0], ie->offset);
 
-	return err;
+	if (retry <= 0)	{
+		WL_ERR(("failure, auto channel selection timed out\n"));
+		*channel = 0;
+		ret = BCME_ERROR;
+	}
+
+done:
+	return ret;
 }
 
-static u32 wl_get_ielen(struct wl_priv *wl)
+static s32
+wl_cfg80211_restore_auto_channel_scan_state(struct net_device *ndev)
 {
-	struct wl_ie *ie = wl_to_ie(wl);
+	u32 val = 0;
+	s32 ret = BCME_ERROR;
+	struct wl_priv *wl = wlcfg_drv_priv;
 
-	return ie->offset;
-}
+	/* Clear scan stop driver status. */
+	wl_clr_drv_status(wl, SCANNING, ndev);
 
-static void wl_link_up(struct wl_priv *wl)
-{
-	wl->link_up = true;
-}
+	/* Enable mpc back to 1, irrespective of initial state. */
+	val = 1;
 
-static void wl_link_down(struct wl_priv *wl)
-{
-	struct wl_connect_info *conn_info = wl_to_conn(wl);
+	ret = wldev_iovar_setbuf_bsscfg(ndev, "mpc", (void *)&val,
+		sizeof(val), wl->ioctl_buf, WLC_IOCTL_SMLEN, 0,
+		&wl->ioctl_buf_sync);
+	if (ret < 0) {
+		WL_ERR(("set 'mpc' failed, error = %d\n", ret));
+	}
 
-	WL_DBG(("In\n"));
-	wl->link_up = false;
-	conn_info->req_ie_len = 0;
-	conn_info->resp_ie_len = 0;
+	return ret;
 }
 
-static unsigned long wl_lock_eq(struct wl_priv *wl)
+s32
+wl_cfg80211_get_best_channels(struct net_device *dev, char* cmd, int total_len)
 {
-	unsigned long flags;
+	int channel = 0;
+	s32 ret = BCME_ERROR;
+	u8 *buf = NULL;
+	char *pos = cmd;
+	struct wl_priv *wl = NULL;
+	struct net_device *ndev = NULL;
 
-	spin_lock_irqsave(&wl->eq_lock, flags);
-	return flags;
-}
+	memset(cmd, 0, total_len);
 
-static void wl_unlock_eq(struct wl_priv *wl, unsigned long flags)
-{
-	spin_unlock_irqrestore(&wl->eq_lock, flags);
-}
+	buf = kmalloc(CHANSPEC_BUF_SIZE, GFP_KERNEL);
+	if (buf == NULL) {
+		WL_ERR(("failed to allocate chanspec buffer\n"));
+		return -ENOMEM;
+	}
 
-static void wl_init_eq_lock(struct wl_priv *wl)
-{
-	spin_lock_init(&wl->eq_lock);
-}
+	/*
+	 * Always use primary interface, irrespective of interface on which
+	 * command came.
+	 */
+	wl = wlcfg_drv_priv;
+	ndev = wl_to_prmry_ndev(wl);
 
-static void wl_delay(u32 ms)
-{
-	if (ms < 1000 / HZ) {
-		cond_resched();
-		mdelay(ms);
-	} else {
-		msleep(ms);
+	/*
+	 * Make sure that FW and driver are in right state to do auto channel
+	 * selection scan.
+	 */
+	ret = wl_cfg80211_set_auto_channel_scan_state(ndev);
+	if (ret < 0) {
+		WL_ERR(("can't set auto channel scan state, error = %d\n", ret));
+		goto done;
 	}
-}
 
-s32 wl_cfg80211_get_p2p_dev_addr(struct net_device *net, struct ether_addr *p2pdev_addr)
-{
-	struct wl_priv *wl = wlcfg_drv_priv;
-	struct ether_addr p2pif_addr;
-	struct ether_addr primary_mac;
-	if (!wl->p2p)
-		return -1;
-	if (!p2p_is_on(wl)) {
-		get_primary_mac(wl, &primary_mac);
-		wl_cfgp2p_generate_bss_mac(&primary_mac, p2pdev_addr, &p2pif_addr);
-	} else {
-		memcpy(p2pdev_addr->octet,
-			wl->p2p->dev_addr.octet, ETHER_ADDR_LEN);
+	/* Best channel selection in 2.4GHz band. */
+	ret = wl_cfg80211_get_chanspecs_2g(ndev, (void *)buf, CHANSPEC_BUF_SIZE);
+	if (ret < 0) {
+		WL_ERR(("can't get chanspecs in 2.4GHz, error = %d\n", ret));
+		goto done;
 	}
 
+	ret = wl_cfg80211_get_best_channel(ndev, (void *)buf, CHANSPEC_BUF_SIZE,
+		&channel);
+	if (ret < 0) {
+		WL_ERR(("can't select best channel scan in 2.4GHz, error = %d\n", ret));
+		goto done;
+	}
 
-	return 0;
-}
-s32 wl_cfg80211_set_p2p_noa(struct net_device *net, char* buf, int len)
-{
-	struct wl_priv *wl;
+	if (CHANNEL_IS_2G(channel)) {
+		channel = ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
+	} else {
+		WL_ERR(("invalid 2.4GHz channel, channel = %d\n", channel));
+		channel = 0;
+	}
 
-	wl = wlcfg_drv_priv;
+	sprintf(pos, "%04d ", channel);
+	pos += 5;
 
-	return wl_cfgp2p_set_p2p_noa(wl, net, buf, len);
-}
+	/* Best channel selection in 5GHz band. */
+	ret = wl_cfg80211_get_chanspecs_5g(ndev, (void *)buf, CHANSPEC_BUF_SIZE);
+	if (ret < 0) {
+		WL_ERR(("can't get chanspecs in 5GHz, error = %d\n", ret));
+		goto done;
+	}
 
-s32 wl_cfg80211_get_p2p_noa(struct net_device *net, char* buf, int len)
-{
-	struct wl_priv *wl;
-	wl = wlcfg_drv_priv;
+	ret = wl_cfg80211_get_best_channel(ndev, (void *)buf, CHANSPEC_BUF_SIZE,
+		&channel);
+	if (ret < 0) {
+		WL_ERR(("can't select best channel scan in 5GHz, error = %d\n", ret));
+		goto done;
+	}
 
-	return wl_cfgp2p_get_p2p_noa(wl, net, buf, len);
-}
+	if (CHANNEL_IS_5G(channel)) {
+		channel = ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
+	} else {
+		WL_ERR(("invalid 5GHz channel, channel = %d\n", channel));
+		channel = 0;
+	}
 
-s32 wl_cfg80211_set_p2p_ps(struct net_device *net, char* buf, int len)
-{
-	struct wl_priv *wl;
-	wl = wlcfg_drv_priv;
+	sprintf(pos, "%04d ", channel);
+	pos += 5;
 
-	return wl_cfgp2p_set_p2p_ps(wl, net, buf, len);
-}
+	/* Set overall best channel same as 5GHz best channel. */
+	sprintf(pos, "%04d ", channel);
+	pos += 5;
 
-s32 wl_cfg80211_set_wps_p2p_ie(struct net_device *net, char *buf, int len,
-	enum wl_management_type type)
-{
-	struct wl_priv *wl;
-	struct net_device *ndev = NULL;
-	s32 ret = 0;
-	s32 bssidx = 0;
-	s32 pktflag = 0;
-	wl = wlcfg_drv_priv;
-	if (wl->p2p && wl->p2p->vif_created) {
-		ndev = wl_to_p2p_bss_ndev(wl, P2PAPI_BSSCFG_CONNECTION);
-		bssidx = wl_to_p2p_bss_bssidx(wl, P2PAPI_BSSCFG_CONNECTION);
-	} else if (wl_get_drv_status(wl, AP_CREATING, net) ||
-		wl_get_drv_status(wl, AP_CREATED, net)) {
-		ndev = net;
-		bssidx = 0;
+done:
+	if (NULL != buf) {
+		kfree(buf);
 	}
-	if (ndev != NULL) {
-		switch (type) {
-			case WL_BEACON:
-				pktflag = VNDR_IE_BEACON_FLAG;
-				break;
-			case WL_PROBE_RESP:
-				pktflag = VNDR_IE_PRBRSP_FLAG;
-				break;
-			case WL_ASSOC_RESP:
-				pktflag = VNDR_IE_ASSOCRSP_FLAG;
-				break;
-		}
-		if (pktflag)
-			ret = wl_cfgp2p_set_management_ie(wl, ndev, bssidx, pktflag, buf, len);
+
+	/* Restore FW and driver back to normal state. */
+	ret = wl_cfg80211_restore_auto_channel_scan_state(ndev);
+	if (ret < 0) {
+		WL_ERR(("can't restore auto channel scan state, error = %d\n", ret));
 	}
 
-	return ret;
+	return (pos - cmd);
 }
+#endif /* WL_SUPPORT_AUTO_CHANNEL */
 
 static const struct rfkill_ops wl_rfkill_ops = {
 	.set_block = wl_rfkill_set
@@ -7291,6 +11024,128 @@ err_out:
 	return err;
 }
 
+#ifdef DEBUGFS_CFG80211
+/**
+* Format : echo "SCAN:1 DBG:1" > /sys/kernel/debug/dhd/debug_level
+* to turn on SCAN and DBG log.
+* To turn off SCAN partially, echo "SCAN:0" > /sys/kernel/debug/dhd/debug_level
+* To see current setting of debug level,
+* cat /sys/kernel/debug/dhd/debug_level
+*/
+static ssize_t
+wl_debuglevel_write(struct file *file, const char __user *userbuf,
+	size_t count, loff_t *ppos)
+{
+	char tbuf[S_SUBLOGLEVEL * ARRAYSIZE(sublogname_map)], sublog[S_SUBLOGLEVEL];
+	char *params, *token, *colon;
+	uint i, tokens, log_on = 0;
+	memset(tbuf, 0, sizeof(tbuf));
+	memset(sublog, 0, sizeof(sublog));
+	if (copy_from_user(&tbuf, userbuf, min_t(size_t, sizeof(tbuf), count)))
+		return -EFAULT;
+
+	params = &tbuf[0];
+	colon = strchr(params, '\n');
+	if (colon != NULL)
+		*colon = '\0';
+	while ((token = strsep(&params, " ")) != NULL) {
+		memset(sublog, 0, sizeof(sublog));
+		if (token == NULL || !*token)
+			break;
+		if (*token == '\0')
+			continue;
+		colon = strchr(token, ':');
+		if (colon != NULL) {
+			*colon = ' ';
+		}
+		tokens = sscanf(token, "%s %u", sublog, &log_on);
+		if (colon != NULL)
+			*colon = ':';
+
+		if (tokens == 2) {
+				for (i = 0; i < ARRAYSIZE(sublogname_map); i++) {
+					if (!strncmp(sublog, sublogname_map[i].sublogname,
+						strlen(sublogname_map[i].sublogname))) {
+						if (log_on)
+							wl_dbg_level |=
+							(sublogname_map[i].log_level);
+						else
+							wl_dbg_level &=
+							~(sublogname_map[i].log_level);
+					}
+				}
+		} else
+			WL_ERR(("%s: can't parse '%s' as a "
+			       "SUBMODULE:LEVEL (%d tokens)\n",
+			       tbuf, token, tokens));
+
+
+	}
+	return count;
+}
+
+static ssize_t
+wl_debuglevel_read(struct file *file, char __user *user_buf,
+	size_t count, loff_t *ppos)
+{
+	char *param;
+	char tbuf[S_SUBLOGLEVEL * ARRAYSIZE(sublogname_map)];
+	uint i;
+	memset(tbuf, 0, sizeof(tbuf));
+	param = &tbuf[0];
+	for (i = 0; i < ARRAYSIZE(sublogname_map); i++) {
+		param += snprintf(param, sizeof(tbuf) - 1, "%s:%d ",
+			sublogname_map[i].sublogname,
+			(wl_dbg_level & sublogname_map[i].log_level) ? 1 : 0);
+	}
+	*param = '\n';
+	return simple_read_from_buffer(user_buf, count, ppos, tbuf, strlen(&tbuf[0]));
+
+}
+static const struct file_operations fops_debuglevel = {
+	.open = NULL,
+	.write = wl_debuglevel_write,
+	.read = wl_debuglevel_read,
+	.owner = THIS_MODULE,
+	.llseek = NULL,
+};
+
+static s32 wl_setup_debugfs(struct wl_priv *wl)
+{
+	s32 err = 0;
+	struct dentry *_dentry;
+	if (!wl)
+		return -EINVAL;
+	wl->debugfs = debugfs_create_dir(KBUILD_MODNAME, NULL);
+	if (!wl->debugfs || IS_ERR(wl->debugfs)) {
+		if (wl->debugfs == ERR_PTR(-ENODEV))
+			WL_ERR(("Debugfs is not enabled on this kernel\n"));
+		else
+			WL_ERR(("Can not create debugfs directory\n"));
+		wl->debugfs = NULL;
+		goto exit;
+
+	}
+	_dentry = debugfs_create_file("debug_level", S_IRUSR | S_IWUSR,
+		wl->debugfs, wl, &fops_debuglevel);
+	if (!_dentry || IS_ERR(_dentry)) {
+		WL_ERR(("failed to create debug_level debug file\n"));
+		wl_free_debugfs(wl);
+	}
+exit:
+	return err;
+}
+static s32 wl_free_debugfs(struct wl_priv *wl)
+{
+	if (!wl)
+		return -EINVAL;
+	if (wl->debugfs)
+		debugfs_remove_recursive(wl->debugfs);
+	wl->debugfs = NULL;
+	return 0;
+}
+#endif /* DEBUGFS_CFG80211 */
+
 struct device *wl_cfg80211_get_parent_dev(void)
 {
 	return cfg80211_parent_dev;
@@ -7309,7 +11164,7 @@ static void wl_cfg80211_clear_parent_dev(void)
 static void get_primary_mac(struct wl_priv *wl, struct ether_addr *mac)
 {
 	wldev_iovar_getbuf_bsscfg(wl_to_prmry_ndev(wl), "cur_etheraddr", NULL,
-		0, wl->ioctl_buf, WLC_IOCTL_MAXLEN, 0, &wl->ioctl_buf_sync);
+		0, wl->ioctl_buf, WLC_IOCTL_SMLEN, 0, &wl->ioctl_buf_sync);
 	memcpy(mac->octet, wl->ioctl_buf, ETHER_ADDR_LEN);
 }
 
@@ -7326,7 +11181,215 @@ int wl_cfg80211_do_driver_init(struct net_device *net)
 	return 0;
 }
 
-void wl_cfg80211_enable_trace(int level)
+void wl_cfg80211_enable_trace(bool set, u32 level)
+{
+	if (set)
+		wl_dbg_level = level & WL_DBG_LEVEL;
+	else
+		wl_dbg_level |= (WL_DBG_LEVEL & level);
+}
+#if defined(WL_SUPPORT_BACKPORTED_KPATCHES) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3, \
+	2, 0))
+static s32
+wl_cfg80211_mgmt_tx_cancel_wait(struct wiphy *wiphy,
+	struct net_device *dev, u64 cookie)
+{
+	/* CFG80211 checks for tx_cancel_wait callback when ATTR_DURATION
+	 * is passed with CMD_FRAME. This callback is supposed to cancel
+	 * the OFFCHANNEL Wait. Since we are already taking care of that
+	 *  with the tx_mgmt logic, do nothing here.
+	 */
+
+	return 0;
+}
+#endif /* WL_SUPPORT_BACKPORTED_PATCHES || KERNEL >= 3.2.0 */
+
+#ifdef WL11U
+bcm_tlv_t *
+wl_cfg80211_find_interworking_ie(u8 *parse, u32 len)
+{
+	bcm_tlv_t *ie;
+
+	while ((ie = bcm_parse_tlvs(parse, (u32)len, DOT11_MNG_INTERWORKING_ID))) {
+			return (bcm_tlv_t *)ie;
+	}
+	return NULL;
+}
+
+
+static s32
+wl_cfg80211_add_iw_ie(struct wl_priv *wl, struct net_device *ndev, s32 bssidx, s32 pktflag,
+            uint8 ie_id, uint8 *data, uint8 data_len)
+{
+	s32 err = BCME_OK;
+	s32 buf_len;
+	s32 iecount;
+	ie_setbuf_t *ie_setbuf;
+
+	if (ie_id != DOT11_MNG_INTERWORKING_ID)
+		return BCME_UNSUPPORTED;
+
+	/* Validate the pktflag parameter */
+	if ((pktflag & ~(VNDR_IE_BEACON_FLAG | VNDR_IE_PRBRSP_FLAG |
+	            VNDR_IE_ASSOCRSP_FLAG | VNDR_IE_AUTHRSP_FLAG |
+	            VNDR_IE_PRBREQ_FLAG | VNDR_IE_ASSOCREQ_FLAG|
+	            VNDR_IE_CUSTOM_FLAG))) {
+		WL_ERR(("cfg80211 Add IE: Invalid packet flag 0x%x\n", pktflag));
+		return -1;
+	}
+
+	/* use VNDR_IE_CUSTOM_FLAG flags for none vendor IE . currently fixed value */
+	pktflag = htod32(pktflag);
+
+	buf_len = sizeof(ie_setbuf_t) + data_len - 1;
+	ie_setbuf = (ie_setbuf_t *) kzalloc(buf_len, GFP_KERNEL);
+
+	if (!ie_setbuf) {
+		WL_ERR(("Error allocating buffer for IE\n"));
+		return -ENOMEM;
+	}
+
+	if (wl->iw_ie_len == data_len && !memcmp(wl->iw_ie, data, data_len)) {
+		WL_ERR(("Previous IW IE is equals to current IE\n"));
+		err = BCME_OK;
+		goto exit;
+	}
+
+	strncpy(ie_setbuf->cmd, "add", VNDR_IE_CMD_LEN - 1);
+	ie_setbuf->cmd[VNDR_IE_CMD_LEN - 1] = '\0';
+
+	/* Buffer contains only 1 IE */
+	iecount = htod32(1);
+	memcpy((void *)&ie_setbuf->ie_buffer.iecount, &iecount, sizeof(int));
+	memcpy((void *)&ie_setbuf->ie_buffer.ie_list[0].pktflag, &pktflag, sizeof(uint32));
+
+	/* Now, add the IE to the buffer */
+	ie_setbuf->ie_buffer.ie_list[0].ie_data.id = ie_id;
+
+	/* if already set with previous values, delete it first */
+	if (wl->iw_ie_len != 0) {
+		WL_DBG(("Different IW_IE was already set. clear first\n"));
+
+		ie_setbuf->ie_buffer.ie_list[0].ie_data.len = 0;
+
+		err = wldev_iovar_setbuf_bsscfg(ndev, "ie", ie_setbuf, buf_len,
+			wl->ioctl_buf, WLC_IOCTL_MAXLEN, bssidx, &wl->ioctl_buf_sync);
+
+		if (err != BCME_OK)
+			goto exit;
+	}
+
+	ie_setbuf->ie_buffer.ie_list[0].ie_data.len = data_len;
+	memcpy((uchar *)&ie_setbuf->ie_buffer.ie_list[0].ie_data.data[0], data, data_len);
+
+	err = wldev_iovar_setbuf_bsscfg(ndev, "ie", ie_setbuf, buf_len,
+		wl->ioctl_buf, WLC_IOCTL_MAXLEN, bssidx, &wl->ioctl_buf_sync);
+
+	if (err == BCME_OK) {
+		memcpy(wl->iw_ie, data, data_len);
+		wl->iw_ie_len = data_len;
+		wl->wl11u = TRUE;
+
+		err = wldev_iovar_setint_bsscfg(ndev, "grat_arp", 1, bssidx);
+	}
+
+exit:
+	if (ie_setbuf)
+		kfree(ie_setbuf);
+	return err;
+}
+#endif /* WL11U */
+
+#ifdef WL_HOST_BAND_MGMT
+s32
+wl_cfg80211_set_band(struct net_device *ndev, int band)
+{
+	struct wl_priv *wl = wlcfg_drv_priv;
+	int ret = 0;
+	char ioctl_buf[50];
+
+	if ((band < WLC_BAND_AUTO) || (band > WLC_BAND_2G)) {
+		WL_ERR(("Invalid band\n"));
+		return -EINVAL;
+	}
+
+	if ((ret = wldev_iovar_setbuf(ndev, "roam_band", &band,
+		sizeof(int), ioctl_buf, sizeof(ioctl_buf), NULL)) < 0) {
+		WL_ERR(("seting roam_band failed code=%d\n", ret));
+		return ret;
+	}
+
+	WL_DBG(("Setting band to %d\n", band));
+	wl->curr_band = band;
+
+	return 0;
+}
+#endif /* WL_HOST_BAND_MGMT */
+
+#if defined(DHCP_SCAN_SUPPRESS)
+static void wl_cfg80211_scan_supp_timerfunc(ulong data)
+{
+	struct wl_priv *wl = (struct wl_priv *)data;
+
+	WL_DBG(("Enter \n"));
+	schedule_work(&wl->wlan_work);
+}
+
+static void wl_cfg80211_work_handler(struct work_struct *work)
+{
+	struct wl_priv *wl = wlcfg_drv_priv;
+
+	wl = container_of(work, struct wl_priv, wlan_work);
+
+	if (!wl) {
+		WL_ERR(("wl_priv ptr NULL\n"));
+		return;
+	}
+
+	if (wl->scan_suppressed) {
+		/* There is pending scan_suppress. Clean it */
+		WL_ERR(("Clean up from timer after %d msec\n", WL_SCAN_SUPPRESS_TIMEOUT));
+		wl_cfg80211_scan_suppress(wl_to_prmry_ndev(wl), 0);
+	}
+}
+
+int wl_cfg80211_scan_suppress(struct net_device *dev, int suppress)
 {
-	wl_dbg_level |= WL_DBG_DBG;
+	struct wl_priv *wl = wlcfg_drv_priv;
+	int ret = 0;
+
+	if (!dev || !wl || ((suppress != 0) && (suppress != 1)))
+		return -EINVAL;
+
+	if (suppress == wl->scan_suppressed) {
+		WL_DBG(("No change in scan_suppress state. Ignoring cmd..\n"));
+		return 0;
+	}
+
+	if (timer_pending(&wl->scan_supp_timer))
+		del_timer_sync(&wl->scan_supp_timer);
+
+	if ((ret = wldev_ioctl(dev, WLC_SET_SCANSUPPRESS,
+		&suppress, sizeof(int), true)) < 0) {
+		WL_ERR(("Scan suppress setting failed ret:%d \n", ret));
+	} else {
+		WL_DBG(("Scan suppress %s \n", suppress ? "Enabled" : "Disabled"));
+		wl->scan_suppressed = suppress;
+	}
+
+	/* If scan_suppress is set, Start a timer to monitor it (just incase) */
+	if (wl->scan_suppressed) {
+		if (ret) {
+			WL_ERR(("Retry scan_suppress reset at a later time \n"));
+			mod_timer(&wl->scan_supp_timer,
+				jiffies + msecs_to_jiffies(WL_SCAN_SUPPRESS_RETRY));
+		} else {
+			WL_DBG(("Start wlan_timer to clear of scan_suppress \n"));
+			mod_timer(&wl->scan_supp_timer,
+				jiffies + msecs_to_jiffies(WL_SCAN_SUPPRESS_TIMEOUT));
+		}
+	}
+
+	return ret;
 }
+#endif /* DHCP_SCAN_SUPPRESS */
diff --git a/drivers/net/wireless/bcmdhd/wl_cfg80211.h b/drivers/net/wireless/bcmdhd/wl_cfg80211.h
old mode 100644
new mode 100755
index edf8a30..686863b
--- a/drivers/net/wireless/bcmdhd/wl_cfg80211.h
+++ b/drivers/net/wireless/bcmdhd/wl_cfg80211.h
@@ -1,27 +1,9 @@
 /*
  * Linux cfg80211 driver
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: wl_cfg80211.h 316895 2012-02-24 00:05:41Z $
+ * $Id: wl_cfg80211.h 389705 2013-03-07 20:04:22Z $
  */
 
 #ifndef _wl_cfg80211_h_
@@ -52,6 +34,7 @@ struct wl_ibss;
 #define dtohchanspec(i) i
 
 #define WL_DBG_NONE	0
+#define WL_DBG_P2P_ACTION (1 << 5)
 #define WL_DBG_TRACE	(1 << 4)
 #define WL_DBG_SCAN 	(1 << 3)
 #define WL_DBG_DBG 	(1 << 2)
@@ -61,20 +44,33 @@ struct wl_ibss;
 /* 0 invalidates all debug messages.  default is 1 */
 #define WL_DBG_LEVEL 0xFF
 
+#define CFG80211_ERROR_TEXT		"CFG80211-ERROR) "
+
+#if defined(DHD_DEBUG)
 #define	WL_ERR(args)									\
 do {										\
 	if (wl_dbg_level & WL_DBG_ERR) {				\
-			printk(KERN_ERR "CFG80211-ERROR) %s : ", __func__);	\
+			printk(KERN_INFO CFG80211_ERROR_TEXT "%s : ", __func__);	\
 			printk args;						\
-		} 								\
+		}								\
 } while (0)
+#else /* defined(DHD_DEBUG) */
+#define	WL_ERR(args)									\
+do {										\
+	if ((wl_dbg_level & WL_DBG_ERR) && net_ratelimit()) {				\
+			printk(KERN_INFO CFG80211_ERROR_TEXT "%s : ", __func__);	\
+			printk args;						\
+		}								\
+} while (0)
+#endif /* defined(DHD_DEBUG) */
+
 #ifdef WL_INFO
 #undef WL_INFO
 #endif
 #define	WL_INFO(args)									\
 do {										\
 	if (wl_dbg_level & WL_DBG_INFO) {				\
-			printk(KERN_ERR "CFG80211-INFO) %s : ", __func__);	\
+			printk(KERN_INFO "CFG80211-INFO) %s : ", __func__);	\
 			printk args;						\
 		}								\
 } while (0)
@@ -84,7 +80,7 @@ do {										\
 #define	WL_SCAN(args)								\
 do {									\
 	if (wl_dbg_level & WL_DBG_SCAN) {			\
-		printk(KERN_ERR "CFG80211-SCAN) %s :", __func__);	\
+		printk(KERN_INFO "CFG80211-SCAN) %s :", __func__);	\
 		printk args;							\
 	}									\
 } while (0)
@@ -94,31 +90,37 @@ do {									\
 #define	WL_TRACE(args)								\
 do {									\
 	if (wl_dbg_level & WL_DBG_TRACE) {			\
-		printk(KERN_ERR "CFG80211-TRACE) %s :", __func__);	\
+		printk(KERN_INFO "CFG80211-TRACE) %s :", __func__);	\
 		printk args;							\
 	}									\
 } while (0)
+#ifdef WL_TRACE_HW4
+#undef WL_TRACE_HW4
+#endif
+#define	WL_TRACE_HW4			WL_TRACE
 #if (WL_DBG_LEVEL > 0)
 #define	WL_DBG(args)								\
 do {									\
 	if (wl_dbg_level & WL_DBG_DBG) {			\
-		printk(KERN_ERR "CFG80211-DEBUG) %s :", __func__);	\
+		printk(KERN_DEBUG "CFG80211-DEBUG) %s :", __func__);	\
 		printk args;							\
 	}									\
 } while (0)
 #else				/* !(WL_DBG_LEVEL > 0) */
 #define	WL_DBG(args)
 #endif				/* (WL_DBG_LEVEL > 0) */
+#define WL_PNO(x)
+#define WL_SD(x)
 
 
 #define WL_SCAN_RETRY_MAX	3
 #define WL_NUM_PMKIDS_MAX	MAXPMKID
 #define WL_SCAN_BUF_MAX 	(1024 * 8)
-#define WL_TLV_INFO_MAX 	1024
+#define WL_TLV_INFO_MAX 	1500
 #define WL_SCAN_IE_LEN_MAX      2048
 #define WL_BSS_INFO_MAX		2048
 #define WL_ASSOC_INFO_MAX	512
-#define WL_IOCTL_LEN_MAX	1024
+#define WL_IOCTL_LEN_MAX	2048
 #define WL_EXTRA_BUF_MAX	2048
 #define WL_ISCAN_BUF_MAX	2048
 #define WL_ISCAN_TIMER_INTERVAL_MS	3000
@@ -127,13 +129,32 @@ do {									\
 #define WL_FILE_NAME_MAX	256
 #define WL_DWELL_TIME 		200
 #define WL_MED_DWELL_TIME       400
+#define WL_MIN_DWELL_TIME	100
 #define WL_LONG_DWELL_TIME 	1000
 #define IFACE_MAX_CNT 		2
+#define WL_SCAN_CONNECT_DWELL_TIME_MS 		200
+#define WL_SCAN_JOIN_PROBE_INTERVAL_MS 		20
+#define WL_SCAN_JOIN_ACTIVE_DWELL_TIME_MS 	320
+#define WL_SCAN_JOIN_PASSIVE_DWELL_TIME_MS 	400
+#define WL_AF_TX_MAX_RETRY 	5
+
+#define WL_AF_SEARCH_TIME_MAX           450
+
+#define WL_AF_TX_EXTRA_TIME_MAX         200
 
 #define WL_SCAN_TIMER_INTERVAL_MS	8000 /* Scan timeout */
 #define WL_CHANNEL_SYNC_RETRY 	5
 #define WL_INVALID 		-1
 
+/* Bring down SCB Timeout to 20secs from 60secs default */
+#ifndef WL_SCB_TIMEOUT
+#define WL_SCB_TIMEOUT 20
+#endif
+
+/* SCAN_SUPPRESS timer values in ms */
+#define WL_SCAN_SUPPRESS_TIMEOUT 31000 /* default Framwork DHCP timeout is 30 sec */
+#define WL_SCAN_SUPPRESS_RETRY 3000
+
 /* driver status */
 enum wl_status {
 	WL_STATUS_READY = 0,
@@ -144,7 +165,33 @@ enum wl_status {
 	WL_STATUS_DISCONNECTING,
 	WL_STATUS_AP_CREATING,
 	WL_STATUS_AP_CREATED,
-	WL_STATUS_SENDING_ACT_FRM
+	/* whole sending action frame procedure:
+	 * includes a) 'finding common channel' for public action request frame
+	 * and b) 'sending af via 'actframe' iovar'
+	 */
+	WL_STATUS_SENDING_ACT_FRM,
+	/* find a peer to go to a common channel before sending public action req frame */
+	WL_STATUS_FINDING_COMMON_CHANNEL,
+	/* waiting for next af to sync time of supplicant.
+	 * it includes SENDING_ACT_FRM and WAITING_NEXT_ACT_FRM_LISTEN
+	 */
+	WL_STATUS_WAITING_NEXT_ACT_FRM,
+#ifdef WL_CFG80211_SYNC_GON
+	/* go to listen state to wait for next af after SENDING_ACT_FRM */
+	WL_STATUS_WAITING_NEXT_ACT_FRM_LISTEN,
+#endif /* WL_CFG80211_SYNC_GON */
+	/* it will be set when upper layer requests listen and succeed in setting listen mode.
+	 * if set, other scan request can abort current listen state
+	 */
+	WL_STATUS_REMAINING_ON_CHANNEL,
+#ifdef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
+	/* it's fake listen state to keep current scan state.
+	 * it will be set when upper layer requests listen but scan is running. then just run
+	 * a expire timer without actual listen state.
+	 * if set, other scan request does not need to abort scan.
+	 */
+	WL_STATUS_FAKE_REMAINING_ON_CHANNEL
+#endif /* WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
 };
 
 /* wi-fi mode */
@@ -161,6 +208,7 @@ enum wl_prof_list {
 	WL_PROF_SEC,
 	WL_PROF_IBSS,
 	WL_PROF_BAND,
+	WL_PROF_CHAN,
 	WL_PROF_BSSID,
 	WL_PROF_ACT,
 	WL_PROF_BEACONINT,
@@ -245,6 +293,7 @@ struct wl_security {
 	u32 cipher_pairwise;
 	u32 cipher_group;
 	u32 wpa_auth;
+	u32 auth_assoc_res_status;
 };
 
 /* ibss information for currently joined ibss network */
@@ -260,6 +309,7 @@ struct wl_ibss {
 struct wl_profile {
 	u32 mode;
 	s32 band;
+	u32 channel;
 	struct wlc_ssid ssid;
 	struct wl_security sec;
 	struct wl_ibss ibss;
@@ -274,7 +324,11 @@ struct net_info {
 	struct wireless_dev *wdev;
 	struct wl_profile profile;
 	s32 mode;
+	s32 roam_off;
 	unsigned long sme_state;
+	bool pm_restore;
+	bool pm_block;
+	s32 pm;
 	struct list_head list; /* list of all net_info structure */
 };
 typedef s32(*ISCAN_HANDLER) (struct wl_priv *wl);
@@ -329,15 +383,22 @@ struct wl_pmk_list {
 
 struct escan_info {
 	u32 escan_state;
+#if defined(STATIC_WL_PRIV_STRUCT)
+#ifndef CONFIG_DHD_USE_STATIC_BUF
+#error STATIC_WL_PRIV_STRUCT should be used with CONFIG_DHD_USE_STATIC_BUF
+#endif /* CONFIG_DHD_USE_STATIC_BUF */
+	u8 *escan_buf;
+#else
 	u8 escan_buf[ESCAN_BUF_SIZE];
+#endif /* STATIC_WL_PRIV_STRUCT */
 	struct wiphy *wiphy;
 	struct net_device *ndev;
 };
 
 struct ap_info {
 /* Structure to hold WPS, WPA IEs for a AP */
-	u8   probe_res_ie[IE_MAX_LEN];
-	u8   beacon_ie[IE_MAX_LEN];
+	u8   probe_res_ie[VNDR_IES_MAX_BUF_LEN];
+	u8   beacon_ie[VNDR_IES_MAX_BUF_LEN];
 	u32 probe_res_ie_len;
 	u32 beacon_ie_len;
 	u8 *wpa_ie;
@@ -361,23 +422,51 @@ struct btcoex_info {
 
 struct sta_info {
 	/* Structure to hold WPS IE for a STA */
-	u8  probe_req_ie[IE_MAX_LEN];
-	u8  assoc_req_ie[IE_MAX_LEN];
+	u8  probe_req_ie[VNDR_IES_BUF_LEN];
+	u8  assoc_req_ie[VNDR_IES_BUF_LEN];
 	u32 probe_req_ie_len;
 	u32 assoc_req_ie_len;
 };
 
 struct afx_hdl {
 	wl_af_params_t *pending_tx_act_frm;
-	struct ether_addr	pending_tx_dst_addr;
+	struct ether_addr	tx_dst_addr;
 	struct net_device *dev;
 	struct work_struct work;
 	u32 bssidx;
 	u32 retry;
 	s32 peer_chan;
+	s32 peer_listen_chan; /* search channel: configured by upper layer */
+	s32 my_listen_chan;	/* listen chanel: extract it from prb req or gon req */
+	bool is_listen;
 	bool ack_recv;
+	bool is_active;
 };
 
+struct parsed_ies {
+	wpa_ie_fixed_t *wps_ie;
+	u32 wps_ie_len;
+	wpa_ie_fixed_t *wpa_ie;
+	u32 wpa_ie_len;
+	bcm_tlv_t *wpa2_ie;
+	u32 wpa2_ie_len;
+};
+
+
+#ifdef WL11U
+/* Max length of Interworking element */
+#define IW_IES_MAX_BUF_LEN 		9
+#endif
+
+#define MAX_EVENT_BUF_NUM 16
+typedef struct wl_eventmsg_buf {
+    u16 num;
+    struct {
+		u16 type;
+		bool set;
+	} event [MAX_EVENT_BUF_NUM];
+} wl_eventmsg_buf_t;
+
 /* private data of cfg80211 interface */
 struct wl_priv {
 	struct wireless_dev *wdev;	/* representing wl cfg80211 device */
@@ -393,6 +482,8 @@ struct wl_priv {
 	spinlock_t eq_lock;	/* for event queue synchronization */
 	spinlock_t cfgdrv_lock;	/* to protect scan status (and others if needed) */
 	struct completion act_frm_scan;
+	struct completion iface_disable;
+	struct completion wait_next_af;
 	struct mutex usr_sync;	/* maily for up/down synchronization */
 	struct wl_scan_results *bss_list;
 	struct wl_scan_results *scan_results;
@@ -400,17 +491,33 @@ struct wl_priv {
 	/* scan request object for internal purpose */
 	struct wl_scan_req *scan_req_int;
 	/* information element object for internal purpose */
+#if defined(STATIC_WL_PRIV_STRUCT)
+	struct wl_ie *ie;
+#else
 	struct wl_ie ie;
+#endif
 	struct wl_iscan_ctrl *iscan;	/* iscan controller */
 
 	/* association information container */
+#if defined(STATIC_WL_PRIV_STRUCT)
+	struct wl_connect_info *conn_info;
+#else
 	struct wl_connect_info conn_info;
-
+#endif
+#ifdef DEBUGFS_CFG80211
+	struct dentry		*debugfs;
+#endif /* DEBUGFS_CFG80211 */
 	struct wl_pmk_list *pmk_list;	/* wpa2 pmk list */
 	tsk_ctl_t event_tsk;  		/* task of main event handler thread */
 	void *pub;
 	u32 iface_cnt;
 	u32 channel;		/* current channel */
+	u32 af_sent_channel;	/* channel action frame is sent */
+	/* next af subtype to cancel the remained dwell time in rx process */
+	u8 next_af_subtype;
+#ifdef WL_CFG80211_SYNC_GON
+	ulong af_tx_sent_jiffies;
+#endif /* WL_CFG80211_SYNC_GON */
 	bool iscan_on;		/* iscan on/off switch */
 	bool iscan_kickstart;	/* indicate iscan already started */
 	bool escan_on;      /* escan on/off switch */
@@ -423,6 +530,9 @@ struct wl_priv {
 	bool pwr_save;
 	bool roam_on;		/* on/off switch for self-roaming */
 	bool scan_tried;	/* indicates if first scan attempted */
+	bool wlfc_on;
+	bool vsdb_mode;
+	bool roamoff_on_concurrent;
 	u8 *ioctl_buf;		/* ioctl buffer */
 	struct mutex ioctl_buf_sync;
 	u8 *escan_ioctl_buf;
@@ -435,6 +545,7 @@ struct wl_priv {
 	u64 send_action_id;
 	u64 last_roc_id;
 	wait_queue_head_t netif_change_event;
+	struct completion send_af_done;
 	struct afx_hdl *afx_hdl;
 	struct ap_info *ap_info;
 	struct sta_info *sta_info;
@@ -442,6 +553,26 @@ struct wl_priv {
 	bool p2p_supported;
 	struct btcoex_info *btcoex_info;
 	struct timer_list scan_timeout;   /* Timer for catch scan event timeout */
+	s32(*state_notifier) (struct wl_priv *wl,
+		struct net_info *_net_info, enum wl_status state, bool set);
+	unsigned long interrested_state;
+	wlc_ssid_t hostapd_ssid;
+#ifdef WL11U
+	bool wl11u;
+	u8 iw_ie[IW_IES_MAX_BUF_LEN];
+	u32 iw_ie_len;
+#endif /* WL11U */
+	bool sched_scan_running;	/* scheduled scan req status */
+#ifdef WL_SCHED_SCAN
+	struct cfg80211_sched_scan_request *sched_scan_req;	/* scheduled scan req */
+#endif /* WL_SCHED_SCAN */
+#ifdef WL_HOST_BAND_MGMT
+	u8 curr_band;
+#endif /* WL_HOST_BAND_MGMT */
+	bool scan_suppressed;
+	struct timer_list scan_supp_timer;
+	struct work_struct wlan_work;
+	struct mutex event_sync;	/* maily for up/down synchronization */
 };
 
 
@@ -452,7 +583,7 @@ static inline struct wl_bss_info *next_bss(struct wl_scan_results *list, struct
 }
 static inline s32
 wl_alloc_netinfo(struct wl_priv *wl, struct net_device *ndev,
-	struct wireless_dev * wdev, s32 mode)
+	struct wireless_dev * wdev, s32 mode, bool pm_block)
 {
 	struct net_info *_net_info;
 	s32 err = 0;
@@ -465,6 +596,10 @@ wl_alloc_netinfo(struct wl_priv *wl, struct net_device *ndev,
 		_net_info->mode = mode;
 		_net_info->ndev = ndev;
 		_net_info->wdev = wdev;
+		_net_info->pm_restore = 0;
+		_net_info->pm = 0;
+		_net_info->pm_block = pm_block;
+		_net_info->roam_off = WL_INVALID;
 		wl->iface_cnt++;
 		list_add(&_net_info->list, &wl->net_list);
 	}
@@ -501,7 +636,7 @@ wl_delete_all_netinfo(struct wl_priv *wl)
 	}
 	wl->iface_cnt = 0;
 }
-static inline bool
+static inline u32
 wl_get_status_all(struct wl_priv *wl, s32 status)
 
 {
@@ -512,7 +647,28 @@ wl_get_status_all(struct wl_priv *wl, s32 status)
 			test_bit(status, &_net_info->sme_state))
 			cnt++;
 	}
-	return cnt? true: false;
+	return cnt;
+}
+static inline void
+wl_set_status_all(struct wl_priv *wl, s32 status, u32 op)
+{
+	struct net_info *_net_info, *next;
+	list_for_each_entry_safe(_net_info, next, &wl->net_list, list) {
+		switch (op) {
+			case 1:
+				return; /* set all status is not allowed */
+			case 2:
+				clear_bit(status, &_net_info->sme_state);
+				if (wl->state_notifier &&
+					test_bit(status, &(wl->interrested_state)))
+					wl->state_notifier(wl, _net_info, status, false);
+				break;
+			case 4:
+				return; /* change all status is not allowed */
+			default:
+				return; /* unknown operation */
+		}
+	}
 }
 static inline void
 wl_set_status_by_netdev(struct wl_priv *wl, s32 status,
@@ -526,9 +682,15 @@ wl_set_status_by_netdev(struct wl_priv *wl, s32 status,
 			switch (op) {
 				case 1:
 					set_bit(status, &_net_info->sme_state);
+					if (wl->state_notifier &&
+						test_bit(status, &(wl->interrested_state)))
+						wl->state_notifier(wl, _net_info, status, true);
 					break;
 				case 2:
 					clear_bit(status, &_net_info->sme_state);
+					if (wl->state_notifier &&
+						test_bit(status, &(wl->interrested_state)))
+						wl->state_notifier(wl, _net_info, status, false);
 					break;
 				case 4:
 					change_bit(status, &_net_info->sme_state);
@@ -588,14 +750,30 @@ wl_get_profile_by_netdev(struct wl_priv *wl, struct net_device *ndev)
 	}
 	return NULL;
 }
+static inline struct net_info *
+wl_get_netinfo_by_netdev(struct wl_priv *wl, struct net_device *ndev)
+{
+	struct net_info *_net_info, *next;
+
+	list_for_each_entry_safe(_net_info, next, &wl->net_list, list) {
+				if (ndev && (_net_info->ndev == ndev))
+					return _net_info;
+	}
+	return NULL;
+}
 #define wl_to_wiphy(w) (w->wdev->wiphy)
 #define wl_to_prmry_ndev(w) (w->wdev->netdev)
 #define ndev_to_wl(n) (wdev_to_wl(n->ieee80211_ptr))
 #define wl_to_sr(w) (w->scan_req_int)
+#if defined(STATIC_WL_PRIV_STRUCT)
+#define wl_to_ie(w) (w->ie)
+#define wl_to_conn(w) (w->conn_info)
+#else
 #define wl_to_ie(w) (&w->ie)
+#define wl_to_conn(w) (&w->conn_info)
+#endif
 #define iscan_to_wl(i) ((struct wl_priv *)(i->data))
 #define wl_to_iscan(w) (w->iscan)
-#define wl_to_conn(w) (&w->conn_info)
 #define wiphy_from_scan(w) (w->escan_info.wiphy)
 #define wl_get_drv_status_all(wl, stat) \
 	(wl_get_status_all(wl, WL_STATUS_ ## stat))
@@ -605,6 +783,8 @@ wl_get_profile_by_netdev(struct wl_priv *wl, struct net_device *ndev)
 	(wl_set_status_by_netdev(wl, WL_STATUS_ ## stat, ndev, 1))
 #define wl_clr_drv_status(wl, stat, ndev)  \
 	(wl_set_status_by_netdev(wl, WL_STATUS_ ## stat, ndev, 2))
+#define wl_clr_drv_status_all(wl, stat)  \
+	(wl_set_status_all(wl, WL_STATUS_ ## stat, 2))
 #define wl_chg_drv_status(wl, stat, ndev)  \
 	(wl_set_status_by_netdev(wl, WL_STATUS_ ## stat, ndev, 4))
 
@@ -636,7 +816,7 @@ extern s32 wl_cfg80211_down(void *para);
 extern s32 wl_cfg80211_notify_ifadd(struct net_device *ndev, s32 idx, s32 bssidx,
 	void* _net_attach);
 extern s32 wl_cfg80211_ifdel_ops(struct net_device *net);
-extern s32 wl_cfg80211_notify_ifdel(struct net_device *ndev);
+extern s32 wl_cfg80211_notify_ifdel(void);
 extern s32 wl_cfg80211_is_progress_ifadd(void);
 extern s32 wl_cfg80211_is_progress_ifchange(void);
 extern s32 wl_cfg80211_is_progress_ifadd(void);
@@ -648,11 +828,44 @@ extern s32 wl_cfg80211_get_p2p_noa(struct net_device *net, char* buf, int len);
 extern s32 wl_cfg80211_set_wps_p2p_ie(struct net_device *net, char *buf, int len,
 	enum wl_management_type type);
 extern s32 wl_cfg80211_set_p2p_ps(struct net_device *net, char* buf, int len);
+#ifdef WL_SUPPORT_AUTO_CHANNEL
+#define CHANSPEC_BUF_SIZE	1024
+#define CHAN_SEL_IOCTL_DELAY	300
+#define CHAN_SEL_RETRY_COUNT	15
+#define CHANNEL_IS_RADAR(channel)	(((channel & WL_CHAN_RADAR) || \
+	(channel & WL_CHAN_PASSIVE)) ? true : false)
+#define CHANNEL_IS_2G(channel)	(((channel >= 1) && (channel <= 14)) ? \
+	true : false)
+#define CHANNEL_IS_5G(channel)	(((channel >= 36) && (channel <= 165)) ? \
+	true : false)
+extern s32 wl_cfg80211_get_best_channels(struct net_device *dev, char* command,
+	int total_len);
+#endif /* WL_SUPPORT_AUTO_CHANNEL */
 extern int wl_cfg80211_hang(struct net_device *dev, u16 reason);
 extern s32 wl_mode_to_nl80211_iftype(s32 mode);
 int wl_cfg80211_do_driver_init(struct net_device *net);
-void wl_cfg80211_enable_trace(int level);
+void wl_cfg80211_enable_trace(bool set, u32 level);
+extern s32 wl_update_wiphybands(struct wl_priv *wl, bool notify);
 extern s32 wl_cfg80211_if_is_group_owner(void);
 extern chanspec_t wl_ch_host_to_driver(u16 channel);
-
+extern s32 wl_add_remove_eventmsg(struct net_device *ndev, u16 event, bool add);
+extern void wl_stop_wait_next_action_frame(struct wl_priv *wl);
+extern int wl_cfg80211_update_power_mode(struct net_device *dev);
+#ifdef WL_HOST_BAND_MGMT
+extern s32 wl_cfg80211_set_band(struct net_device *ndev, int band);
+#endif /* WL_HOST_BAND_MGMT */
+#if defined(DHCP_SCAN_SUPPRESS)
+extern int wl_cfg80211_scan_suppress(struct net_device *dev, int suppress);
+#endif /* OEM_ANDROID */
+extern void wl_cfg80211_add_to_eventbuffer(wl_eventmsg_buf_t *ev, u16 event, bool set);
+extern s32 wl_cfg80211_apply_eventbuffer(struct net_device *ndev,
+	struct wl_priv *wl, wl_eventmsg_buf_t *ev);
+#define SCAN_BUF_CNT	2
+#define SCAN_BUF_NEXT	1
+#define wl_escan_set_sync_id(a, b) ((a) = htod16(0x1234))
+#define wl_escan_get_buf(a, b) ((wl_scan_results_t *) (a)->escan_info.escan_buf)
+#define wl_escan_check_sync_id(a, b, c) 0
+#define wl_escan_print_sync_id(a, b, c)
+#define wl_escan_increment_sync_id(a, b)
+#define wl_escan_init_sync_id(a)
 #endif				/* _wl_cfg80211_h_ */
diff --git a/drivers/net/wireless/bcmdhd/wl_cfgp2p.c b/drivers/net/wireless/bcmdhd/wl_cfgp2p.c
old mode 100644
new mode 100755
index eb76fd0..2a58309
--- a/drivers/net/wireless/bcmdhd/wl_cfgp2p.c
+++ b/drivers/net/wireless/bcmdhd/wl_cfgp2p.c
@@ -1,27 +1,9 @@
 /*
  * Linux cfgp2p driver
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: wl_cfgp2p.c 321498 2012-03-15 12:54:13Z $
+ * $Id: wl_cfgp2p.c 394172 2013-04-01 09:44:27Z $
  *
  */
 #include <typedefs.h>
@@ -40,6 +22,7 @@
 #include <bcmutils.h>
 #include <bcmendian.h>
 #include <proto/ethernet.h>
+#include <proto/802.11.h>
 
 #include <wl_cfg80211.h>
 #include <wl_cfgp2p.h>
@@ -47,18 +30,20 @@
 #include <wl_android.h>
 
 static s8 scanparambuf[WLC_IOCTL_SMLEN];
-
+static s8 g_mgmt_ie_buf[2048];
 static bool
 wl_cfgp2p_has_ie(u8 *ie, u8 **tlvs, u32 *tlvs_len, const u8 *oui, u32 oui_len, u8 type);
 
-static s32
-wl_cfgp2p_vndr_ie(struct wl_priv *wl, struct net_device *ndev, s32 bssidx, s32 pktflag,
-            s8 *oui, s32 ie_id, s8 *data, s32 data_len, s32 delete);
+static u32
+wl_cfgp2p_vndr_ie(struct wl_priv *wl, u8 *iebuf, s32 pktflag,
+            s8 *oui, s32 ie_id, s8 *data, s32 datalen, const s8* add_del_cmd);
 
 static int wl_cfgp2p_start_xmit(struct sk_buff *skb, struct net_device *ndev);
 static int wl_cfgp2p_do_ioctl(struct net_device *net, struct ifreq *ifr, int cmd);
 static int wl_cfgp2p_if_open(struct net_device *net);
 static int wl_cfgp2p_if_stop(struct net_device *net);
+static s32 wl_cfgp2p_cancel_listen(struct wl_priv *wl, struct net_device *ndev,
+	bool notify);
 
 static const struct net_device_ops wl_cfgp2p_if_ops = {
 	.ndo_open		= wl_cfgp2p_if_open,
@@ -105,6 +90,41 @@ bool wl_cfgp2p_is_p2p_action(void *frame, u32 frame_len)
 
 	return false;
 }
+
+#ifdef WL11U
+#define GAS_RESP_LEN		2
+#define DOUBLE_TLV_BODY_OFF	4
+#define GAS_RESP_OFFSET		4
+#define GAS_CRESP_OFFSET	5
+
+bool wl_cfgp2p_find_gas_subtype(u8 subtype, u8* data, u32 len)
+{
+	bcm_tlv_t *ie = (bcm_tlv_t *)data;
+	u8 *frame = NULL;
+	u16 id, flen;
+
+	/* Skipped first ANQP Element, if frame has anqp elemnt */
+	ie = bcm_parse_tlvs(ie, (int)len, DOT11_MNG_ADVERTISEMENT_ID);
+
+	if (ie == NULL)
+		return false;
+
+	frame = (uint8 *)ie + ie->len + TLV_HDR_LEN + GAS_RESP_LEN;
+	id = ((u16) (((frame)[1] << 8) | (frame)[0]));
+	flen = ((u16) (((frame)[3] << 8) | (frame)[2]));
+
+	/* If the contents match the OUI and the type */
+	if (flen >= WFA_OUI_LEN + 1 &&
+		id ==  P2PSD_GAS_NQP_INFOID &&
+		!bcmp(&frame[DOUBLE_TLV_BODY_OFF], (const uint8*)WFA_OUI, WFA_OUI_LEN) &&
+		subtype == frame[DOUBLE_TLV_BODY_OFF+WFA_OUI_LEN]) {
+		return true;
+	}
+
+	return false;
+}
+#endif /* WL11U */
+
 bool wl_cfgp2p_is_gas_action(void *frame, u32 frame_len)
 {
 
@@ -119,6 +139,22 @@ bool wl_cfgp2p_is_gas_action(void *frame, u32 frame_len)
 	if (sd_act_frm->category != P2PSD_ACTION_CATEGORY)
 		return false;
 
+#ifdef WL11U
+	if (sd_act_frm->action == P2PSD_ACTION_ID_GAS_IRESP)
+		return wl_cfgp2p_find_gas_subtype(P2PSD_GAS_OUI_SUBTYPE,
+			(u8 *)sd_act_frm->query_data + GAS_RESP_OFFSET,
+			frame_len);
+
+	else if (sd_act_frm->action == P2PSD_ACTION_ID_GAS_CRESP)
+		return wl_cfgp2p_find_gas_subtype(P2PSD_GAS_OUI_SUBTYPE,
+			(u8 *)sd_act_frm->query_data + GAS_CRESP_OFFSET,
+			frame_len);
+	else if (sd_act_frm->action == P2PSD_ACTION_ID_GAS_IREQ ||
+		sd_act_frm->action == P2PSD_ACTION_ID_GAS_CREQ)
+		return true;
+	else
+		return false;
+#else
 	if (sd_act_frm->action == P2PSD_ACTION_ID_GAS_IREQ ||
 		sd_act_frm->action == P2PSD_ACTION_ID_GAS_IRESP ||
 		sd_act_frm->action == P2PSD_ACTION_ID_GAS_CREQ ||
@@ -126,9 +162,9 @@ bool wl_cfgp2p_is_gas_action(void *frame, u32 frame_len)
 		return true;
 	else
 		return false;
-
+#endif /* WL11U */
 }
-void wl_cfgp2p_print_actframe(bool tx, void *frame, u32 frame_len)
+void wl_cfgp2p_print_actframe(bool tx, void *frame, u32 frame_len, u32 channel)
 {
 	wifi_p2p_pub_act_frame_t *pact_frm;
 	wifi_p2p_action_frame_t *act_frm;
@@ -140,44 +176,44 @@ void wl_cfgp2p_print_actframe(bool tx, void *frame, u32 frame_len)
 		pact_frm = (wifi_p2p_pub_act_frame_t *)frame;
 		switch (pact_frm->subtype) {
 			case P2P_PAF_GON_REQ:
-				CFGP2P_DBG(("%s P2P Group Owner Negotiation Req Frame\n",
-					(tx)? "TX": "RX"));
+				CFGP2P_ACTION(("%s P2P Group Owner Negotiation Req Frame,"
+					" channel=%d\n", (tx)? "TX": "RX", channel));
 				break;
 			case P2P_PAF_GON_RSP:
-				CFGP2P_DBG(("%s P2P Group Owner Negotiation Rsp Frame\n",
-					(tx)? "TX": "RX"));
+				CFGP2P_ACTION(("%s P2P Group Owner Negotiation Rsp Frame,"
+					" channel=%d\n", (tx)? "TX": "RX", channel));
 				break;
 			case P2P_PAF_GON_CONF:
-				CFGP2P_DBG(("%s P2P Group Owner Negotiation Confirm Frame\n",
-					(tx)? "TX": "RX"));
+				CFGP2P_ACTION(("%s P2P Group Owner Negotiation Confirm Frame,"
+					" channel=%d\n", (tx)? "TX": "RX", channel));
 				break;
 			case P2P_PAF_INVITE_REQ:
-				CFGP2P_DBG(("%s P2P Invitation Request  Frame\n",
-					(tx)? "TX": "RX"));
+				CFGP2P_ACTION(("%s P2P Invitation Request  Frame,"
+					" channel=%d\n", (tx)? "TX": "RX", channel));
 				break;
 			case P2P_PAF_INVITE_RSP:
-				CFGP2P_DBG(("%s P2P Invitation Response Frame\n",
-					(tx)? "TX": "RX"));
+				CFGP2P_ACTION(("%s P2P Invitation Response Frame,"
+					" channel=%d\n", (tx)? "TX": "RX", channel));
 				break;
 			case P2P_PAF_DEVDIS_REQ:
-				CFGP2P_DBG(("%s P2P Device Discoverability Request Frame\n",
-					(tx)? "TX": "RX"));
+				CFGP2P_ACTION(("%s P2P Device Discoverability Request Frame,"
+					" channel=%d\n", (tx)? "TX": "RX", channel));
 				break;
 			case P2P_PAF_DEVDIS_RSP:
-				CFGP2P_DBG(("%s P2P Device Discoverability Response Frame\n",
-					(tx)? "TX": "RX"));
+				CFGP2P_ACTION(("%s P2P Device Discoverability Response Frame,"
+					" channel=%d\n", (tx)? "TX": "RX", channel));
 				break;
 			case P2P_PAF_PROVDIS_REQ:
-				CFGP2P_DBG(("%s P2P Provision Discovery Request Frame\n",
-					(tx)? "TX": "RX"));
+				CFGP2P_ACTION(("%s P2P Provision Discovery Request Frame,"
+					" channel=%d\n", (tx)? "TX": "RX", channel));
 				break;
 			case P2P_PAF_PROVDIS_RSP:
-				CFGP2P_DBG(("%s P2P Provision Discovery Response Frame\n",
-					(tx)? "TX": "RX"));
+				CFGP2P_ACTION(("%s P2P Provision Discovery Response Frame,"
+					" channel=%d\n", (tx)? "TX": "RX", channel));
 				break;
 			default:
-				CFGP2P_DBG(("%s Unknown P2P Public Action Frame\n",
-					(tx)? "TX": "RX"));
+				CFGP2P_ACTION(("%s Unknown P2P Public Action Frame,"
+					" channel=%d\n", (tx)? "TX": "RX", channel));
 
 		}
 
@@ -185,53 +221,52 @@ void wl_cfgp2p_print_actframe(bool tx, void *frame, u32 frame_len)
 		act_frm = (wifi_p2p_action_frame_t *)frame;
 		switch (act_frm->subtype) {
 			case P2P_AF_NOTICE_OF_ABSENCE:
-				CFGP2P_DBG(("%s P2P Notice of Absence Frame\n",
-					(tx)? "TX": "RX"));
+				CFGP2P_ACTION(("%s P2P Notice of Absence Frame,"
+					" channel=%d\n", (tx)? "TX": "RX", channel));
 				break;
 			case P2P_AF_PRESENCE_REQ:
-				CFGP2P_DBG(("%s P2P Presence Request Frame\n",
-					(tx)? "TX": "RX"));
+				CFGP2P_ACTION(("%s P2P Presence Request Frame,"
+					" channel=%d\n", (tx)? "TX": "RX", channel));
 				break;
 			case P2P_AF_PRESENCE_RSP:
-				CFGP2P_DBG(("%s P2P Presence Response Frame\n",
-					(tx)? "TX": "RX"));
+				CFGP2P_ACTION(("%s P2P Presence Response Frame,"
+					" channel=%d\n", (tx)? "TX": "RX", channel));
 				break;
 			case P2P_AF_GO_DISC_REQ:
-				CFGP2P_DBG(("%s P2P Discoverability Request Frame\n",
-					(tx)? "TX": "RX"));
+				CFGP2P_ACTION(("%s P2P Discoverability Request Frame,"
+					" channel=%d\n", (tx)? "TX": "RX", channel));
 				break;
 			default:
-				CFGP2P_DBG(("%s Unknown P2P Action Frame\n",
-					(tx)? "TX": "RX"));
+				CFGP2P_ACTION(("%s Unknown P2P Action Frame,"
+					" channel=%d\n", (tx)? "TX": "RX", channel));
 		}
 
 	} else if (wl_cfgp2p_is_gas_action(frame, frame_len)) {
 		sd_act_frm = (wifi_p2psd_gas_pub_act_frame_t *)frame;
 		switch (sd_act_frm->action) {
 			case P2PSD_ACTION_ID_GAS_IREQ:
-				CFGP2P_DBG(("%s P2P GAS Initial Request\n",
-					(tx)? "TX" : "RX"));
+				CFGP2P_ACTION(("%s P2P GAS Initial Request,"
+					" channel=%d\n", (tx)? "TX" : "RX", channel));
 				break;
 			case P2PSD_ACTION_ID_GAS_IRESP:
-				CFGP2P_DBG(("%s P2P GAS Initial Response\n",
-					(tx)? "TX" : "RX"));
+				CFGP2P_ACTION(("%s P2P GAS Initial Response,"
+					" channel=%d\n", (tx)? "TX" : "RX", channel));
 				break;
 			case P2PSD_ACTION_ID_GAS_CREQ:
-				CFGP2P_DBG(("%s P2P GAS Comback Request\n",
-					(tx)? "TX" : "RX"));
+				CFGP2P_ACTION(("%s P2P GAS Comback Request,"
+					" channel=%d\n", (tx)? "TX" : "RX", channel));
 				break;
 			case P2PSD_ACTION_ID_GAS_CRESP:
-				CFGP2P_DBG(("%s P2P GAS Comback Response\n",
-					(tx)? "TX" : "RX"));
+				CFGP2P_ACTION(("%s P2P GAS Comback Response,"
+					" channel=%d\n", (tx)? "TX" : "RX", channel));
 				break;
 			default:
-				CFGP2P_DBG(("%s Unknown P2P GAS Frame\n",
-					(tx)? "TX" : "RX"));
+				CFGP2P_ACTION(("%s Unknown P2P GAS Frame,"
+					" channel=%d\n", (tx)? "TX" : "RX", channel));
 		}
 
 
 	}
-
 }
 
 /*
@@ -274,7 +309,6 @@ wl_cfgp2p_init_priv(struct wl_priv *wl)
 	wl_to_p2p_bss_bssidx(wl, P2PAPI_BSSCFG_DEVICE) = 0;
 	wl_to_p2p_bss_ndev(wl, P2PAPI_BSSCFG_CONNECTION) = NULL;
 	wl_to_p2p_bss_bssidx(wl, P2PAPI_BSSCFG_CONNECTION) = 0;
-	spin_lock_init(&wl->p2p->timer_lock);
 	return BCME_OK;
 
 }
@@ -303,16 +337,26 @@ wl_cfgp2p_set_firm_p2p(struct wl_priv *wl)
 	s32 ret = BCME_OK;
 	s32 val = 0;
 	/* Do we have to check whether APSTA is enabled or not ? */
-	wldev_iovar_getint(ndev, "apsta", &val);
+	ret = wldev_iovar_getint(ndev, "apsta", &val);
+	if (ret < 0) {
+		CFGP2P_ERR(("get apsta error %d\n", ret));
+		return ret;
+	}
 	if (val == 0) {
 		val = 1;
-		wldev_ioctl(ndev, WLC_DOWN, &val, sizeof(s32), true);
+		ret = wldev_ioctl(ndev, WLC_DOWN, &val, sizeof(s32), true);
+		if (ret < 0) {
+			CFGP2P_ERR(("WLC_DOWN error %d\n", ret));
+			return ret;
+		}
 		wldev_iovar_setint(ndev, "apsta", val);
-		wldev_ioctl(ndev, WLC_UP, &val, sizeof(s32), true);
+		ret = wldev_ioctl(ndev, WLC_UP, &val, sizeof(s32), true);
+		if (ret < 0) {
+			CFGP2P_ERR(("WLC_UP error %d\n", ret));
+			return ret;
+		}
 	}
-	val = 1;
-	/* Disable firmware roaming for P2P  */
-	wldev_iovar_setint(ndev, "roam_off", val);
+
 	/* In case of COB type, firmware has default mac address
 	 * After Initializing firmware, we have to set current mac address to
 	 * firmware for P2P device address
@@ -338,23 +382,52 @@ wl_cfgp2p_ifadd(struct wl_priv *wl, struct ether_addr *mac, u8 if_type,
 {
 	wl_p2p_if_t ifreq;
 	s32 err;
+	u32 scb_timeout = WL_SCB_TIMEOUT;
 	struct net_device *ndev = wl_to_prmry_ndev(wl);
 
 	ifreq.type = if_type;
 	ifreq.chspec = chspec;
 	memcpy(ifreq.addr.octet, mac->octet, sizeof(ifreq.addr.octet));
 
-	CFGP2P_DBG(("---wl p2p_ifadd %02x:%02x:%02x:%02x:%02x:%02x %s %u\n",
-	    ifreq.addr.octet[0], ifreq.addr.octet[1], ifreq.addr.octet[2],
-		ifreq.addr.octet[3], ifreq.addr.octet[4], ifreq.addr.octet[5],
+	CFGP2P_DBG(("---wl p2p_ifadd "MACDBG" %s %u\n",
+		MAC2STRDBG(ifreq.addr.octet),
 		(if_type == WL_P2P_IF_GO) ? "go" : "client",
 	        (chspec & WL_CHANSPEC_CHAN_MASK) >> WL_CHANSPEC_CHAN_SHIFT));
 
 	err = wldev_iovar_setbuf(ndev, "p2p_ifadd", &ifreq, sizeof(ifreq),
 		wl->ioctl_buf, WLC_IOCTL_MAXLEN, &wl->ioctl_buf_sync);
+
+	if (unlikely(err < 0))
+		printk("'wl p2p_ifadd' error %d\n", err);
+	else if (if_type == WL_P2P_IF_GO) {
+		err = wldev_ioctl(ndev, WLC_SET_SCB_TIMEOUT, &scb_timeout, sizeof(u32), true);
+		if (unlikely(err < 0))
+			printk("'wl scb_timeout' error %d\n", err);
+	}
 	return err;
 }
 
+/* Disable a P2P BSS.
+ * Parameters:
+ * @mac      : MAC address of the BSS to create
+ * Returns 0 if success.
+ */
+s32
+wl_cfgp2p_ifdisable(struct wl_priv *wl, struct ether_addr *mac)
+{
+	s32 ret;
+	struct net_device *netdev = wl_to_prmry_ndev(wl);
+
+	CFGP2P_INFO(("------primary idx %d : wl p2p_ifdis "MACDBG"\n",
+		netdev->ifindex, MAC2STRDBG(mac->octet)));
+	ret = wldev_iovar_setbuf(netdev, "p2p_ifdis", mac, sizeof(*mac),
+		wl->ioctl_buf, WLC_IOCTL_MAXLEN, &wl->ioctl_buf_sync);
+	if (unlikely(ret < 0)) {
+		printk("'wl p2p_ifdis' error %d\n", ret);
+	}
+	return ret;
+}
+
 /* Delete a P2P BSS.
  * Parameters:
  * @mac      : MAC address of the BSS to create
@@ -366,9 +439,8 @@ wl_cfgp2p_ifdel(struct wl_priv *wl, struct ether_addr *mac)
 	s32 ret;
 	struct net_device *netdev = wl_to_prmry_ndev(wl);
 
-	CFGP2P_INFO(("------primary idx %d : wl p2p_ifdel %02x:%02x:%02x:%02x:%02x:%02x\n",
-	    netdev->ifindex, mac->octet[0], mac->octet[1], mac->octet[2],
-	    mac->octet[3], mac->octet[4], mac->octet[5]));
+	CFGP2P_INFO(("------primary idx %d : wl p2p_ifdel "MACDBG"\n",
+	    netdev->ifindex, MAC2STRDBG(mac->octet)));
 	ret = wldev_iovar_setbuf(netdev, "p2p_ifdel", mac, sizeof(*mac),
 		wl->ioctl_buf, WLC_IOCTL_MAXLEN, &wl->ioctl_buf_sync);
 	if (unlikely(ret < 0)) {
@@ -388,23 +460,29 @@ wl_cfgp2p_ifchange(struct wl_priv *wl, struct ether_addr *mac, u8 if_type,
 {
 	wl_p2p_if_t ifreq;
 	s32 err;
+	u32 scb_timeout = WL_SCB_TIMEOUT;
+
 	struct net_device *netdev =  wl_to_p2p_bss_ndev(wl, P2PAPI_BSSCFG_CONNECTION);
 
 	ifreq.type = if_type;
 	ifreq.chspec = chspec;
 	memcpy(ifreq.addr.octet, mac->octet, sizeof(ifreq.addr.octet));
 
-	CFGP2P_INFO(("---wl p2p_ifchange %02x:%02x:%02x:%02x:%02x:%02x %s %u\n",
-	    ifreq.addr.octet[0], ifreq.addr.octet[1], ifreq.addr.octet[2],
-	    ifreq.addr.octet[3], ifreq.addr.octet[4], ifreq.addr.octet[5],
-	    (if_type == WL_P2P_IF_GO) ? "go" : "client",
-		(chspec & WL_CHANSPEC_CHAN_MASK) >> WL_CHANSPEC_CHAN_SHIFT));
+	CFGP2P_INFO(("---wl p2p_ifchange "MACDBG" %s %u"
+		" chanspec 0x%04x\n", MAC2STRDBG(ifreq.addr.octet),
+		(if_type == WL_P2P_IF_GO) ? "go" : "client",
+		(chspec & WL_CHANSPEC_CHAN_MASK) >> WL_CHANSPEC_CHAN_SHIFT,
+		ifreq.chspec));
 
 	err = wldev_iovar_setbuf(netdev, "p2p_ifupd", &ifreq, sizeof(ifreq),
 		wl->ioctl_buf, WLC_IOCTL_MAXLEN, &wl->ioctl_buf_sync);
 
 	if (unlikely(err < 0)) {
 		printk("'wl p2p_ifupd' error %d\n", err);
+	} else if (if_type == WL_P2P_IF_GO) {
+		err = wldev_ioctl(netdev, WLC_SET_SCB_TIMEOUT, &scb_timeout, sizeof(u32), true);
+		if (unlikely(err < 0))
+			printk("'wl scb_timeout' error %d\n", err);
 	}
 	return err;
 }
@@ -423,15 +501,13 @@ wl_cfgp2p_ifidx(struct wl_priv *wl, struct ether_addr *mac, s32 *index)
 	u8 getbuf[64];
 	struct net_device *dev = wl_to_prmry_ndev(wl);
 
-	CFGP2P_INFO(("---wl p2p_if %02x:%02x:%02x:%02x:%02x:%02x\n",
-	    mac->octet[0], mac->octet[1], mac->octet[2],
-	    mac->octet[3], mac->octet[4], mac->octet[5]));
+	CFGP2P_INFO(("---wl p2p_if "MACDBG"\n", MAC2STRDBG(mac->octet)));
 
 	ret = wldev_iovar_getbuf_bsscfg(dev, "p2p_if", mac, sizeof(*mac), getbuf,
 		sizeof(getbuf), wl_to_p2p_bss_bssidx(wl, P2PAPI_BSSCFG_PRIMARY), NULL);
 
 	if (ret == 0) {
-		memcpy(index, getbuf, sizeof(index));
+		memcpy(index, getbuf, sizeof(s32));
 		CFGP2P_INFO(("---wl p2p_if   ==> %d\n", *index));
 	}
 
@@ -471,12 +547,12 @@ wl_cfgp2p_set_p2p_mode(struct wl_priv *wl, u8 mode, u32 channel, u16 listen_ms,
 	struct net_device *dev;
 	CFGP2P_DBG(("enter\n"));
 
-	if (unlikely(bssidx >= P2PAPI_BSSCFG_MAX)) {
+	if (unlikely(bssidx == WL_INVALID)) {
 		CFGP2P_ERR((" %d index out of range\n", bssidx));
 		return -1;
 	}
 
-	dev = wl_to_p2p_bss_ndev(wl, bssidx);
+	dev = wl_cfgp2p_find_ndev(wl, bssidx);
 	if (unlikely(dev == NULL)) {
 		CFGP2P_ERR(("bssidx %d is not assigned\n", bssidx));
 		return BCME_NOTFOUND;
@@ -582,7 +658,7 @@ wl_cfgp2p_deinit_discovery(struct wl_priv *wl)
 	/* Clear the saved bsscfg index of the discovery BSSCFG to indicate we
 	 * have no discovery BSS.
 	 */
-	wl_to_p2p_bss_bssidx(wl, P2PAPI_BSSCFG_DEVICE) = 0;
+	wl_to_p2p_bss_bssidx(wl, P2PAPI_BSSCFG_DEVICE) = WL_INVALID;
 	wl_to_p2p_bss_ndev(wl, P2PAPI_BSSCFG_DEVICE) = NULL;
 
 	return ret;
@@ -600,6 +676,14 @@ wl_cfgp2p_enable_discovery(struct wl_priv *wl, struct net_device *dev,
 	const u8 *ie, u32 ie_len)
 {
 	s32 ret = BCME_OK;
+	s32 bssidx;
+
+	if (wl_to_prmry_ndev(wl) == dev) {
+		bssidx = wl_to_p2p_bss_bssidx(wl, P2PAPI_BSSCFG_DEVICE);
+	} else if (wl_cfgp2p_find_idx(wl, dev, &bssidx) != BCME_OK) {
+		WL_ERR(("Find p2p index from dev(%p) failed\n", dev));
+		return BCME_ERROR;
+	}
 	if (wl_get_p2p_status(wl, DISCOVERY_ON)) {
 		CFGP2P_INFO((" DISCOVERY is already initialized, we have nothing to do\n"));
 		goto set_ie;
@@ -624,13 +708,15 @@ wl_cfgp2p_enable_discovery(struct wl_priv *wl, struct net_device *dev,
 		CFGP2P_ERR((" wsec error %d\n", ret));
 	}
 set_ie:
-	ret = wl_cfgp2p_set_management_ie(wl, dev,
-	            wl_to_p2p_bss_bssidx(wl, P2PAPI_BSSCFG_DEVICE),
-	            VNDR_IE_PRBREQ_FLAG, ie, ie_len);
-
-	if (unlikely(ret < 0)) {
-		CFGP2P_ERR(("set probreq ie occurs error %d\n", ret));
-		goto exit;
+	if (ie_len) {
+		ret = wl_cfgp2p_set_management_ie(wl, dev,
+			bssidx,
+			VNDR_IE_PRBREQ_FLAG, ie, ie_len);
+
+		if (unlikely(ret < 0)) {
+			CFGP2P_ERR(("set probreq ie occurs error %d\n", ret));
+			goto exit;
+		}
 	}
 exit:
 	return ret;
@@ -663,11 +749,6 @@ wl_cfgp2p_disable_discovery(struct wl_priv *wl)
 	/* Do a scan abort to stop the driver's scan engine in case it is still
 	 * waiting out an action frame tx dwell time.
 	 */
-#ifdef NOT_YET
-	if (wl_get_p2p_status(wl, SCANNING)) {
-		p2pwlu_scan_abort(hdl, FALSE);
-	}
-#endif
 	wl_clr_p2p_status(wl, DISCOVERY_ON);
 	ret = wl_cfgp2p_deinit_discovery(wl);
 
@@ -678,7 +759,7 @@ exit:
 s32
 wl_cfgp2p_escan(struct wl_priv *wl, struct net_device *dev, u16 active,
 	u32 num_chans, u16 *channels,
-	s32 search_state, u16 action, u32 bssidx)
+	s32 search_state, u16 action, u32 bssidx, struct ether_addr *tx_dst_addr)
 {
 	s32 ret = BCME_OK;
 	s32 memsize;
@@ -690,11 +771,13 @@ wl_cfgp2p_escan(struct wl_priv *wl, struct net_device *dev, u16 active,
 	wlc_ssid_t ssid;
 	/* Scan parameters */
 #define P2PAPI_SCAN_NPROBES 1
-#define P2PAPI_SCAN_DWELL_TIME_MS 50
+#define P2PAPI_SCAN_DWELL_TIME_MS 80
 #define P2PAPI_SCAN_SOCIAL_DWELL_TIME_MS 40
 #define P2PAPI_SCAN_HOME_TIME_MS 60
+#define P2PAPI_SCAN_NPROBS_TIME_MS 30
+#define P2PAPI_SCAN_AF_SEARCH_DWELL_TIME_MS 100
+
 	struct net_device *pri_dev = wl_to_p2p_bss_ndev(wl, P2PAPI_BSSCFG_PRIMARY);
-	wl_set_p2p_status(wl, SCANNING);
 	/* Allocate scan params which need space for 3 channels and 0 ssids */
 	eparams_size = (WL_SCAN_PARAMS_FIXED_SIZE +
 	    OFFSETOF(wl_escan_params_t, params)) +
@@ -703,7 +786,7 @@ wl_cfgp2p_escan(struct wl_priv *wl, struct net_device *dev, u16 active,
 	memsize = sizeof(wl_p2p_scan_t) + eparams_size;
 	memblk = scanparambuf;
 	if (memsize > sizeof(scanparambuf)) {
-		CFGP2P_ERR((" scanpar buf too small (%u > %u)\n",
+		CFGP2P_ERR((" scanpar buf too small (%u > %zu)\n",
 		    memsize, sizeof(scanparambuf)));
 		return -1;
 	}
@@ -715,8 +798,9 @@ wl_cfgp2p_escan(struct wl_priv *wl, struct net_device *dev, u16 active,
 		 * because dongle use P2P WILDCARD internally by default
 		 */
 		wl_cfgp2p_set_p2p_mode(wl, WL_P2P_DISC_ST_SEARCH, 0, 0, bssidx);
-		ssid.SSID_len = htod32(0);
-
+		/* use null ssid */
+		ssid.SSID_len = 0;
+		memset(&ssid.SSID, 0, sizeof(ssid.SSID));
 	} else if (search_state == WL_P2P_DISC_ST_SCAN) {
 		/* SCAN STATE 802.11 SCAN
 		 * WFD Supplicant has p2p_find command with (type=progressive, type= full)
@@ -724,9 +808,14 @@ wl_cfgp2p_escan(struct wl_priv *wl, struct net_device *dev, u16 active,
 		 * we have to set ssid to P2P WILDCARD because
 		 * we just do broadcast scan unless setting SSID
 		 */
-		strcpy(ssid.SSID, WL_P2P_WILDCARD_SSID);
-		ssid.SSID_len = htod32(WL_P2P_WILDCARD_SSID_LEN);
 		wl_cfgp2p_set_p2p_mode(wl, WL_P2P_DISC_ST_SCAN, 0, 0, bssidx);
+		/* use wild card ssid */
+		ssid.SSID_len = WL_P2P_WILDCARD_SSID_LEN;
+		memset(&ssid.SSID, 0, sizeof(ssid.SSID));
+		memcpy(&ssid.SSID, WL_P2P_WILDCARD_SSID, WL_P2P_WILDCARD_SSID_LEN);
+	} else {
+		CFGP2P_ERR((" invalid search state %d\n", search_state));
+		return -1;
 	}
 
 
@@ -741,18 +830,41 @@ wl_cfgp2p_escan(struct wl_priv *wl, struct net_device *dev, u16 active,
 	else
 		eparams->params.scan_type = DOT11_SCANTYPE_PASSIVE;
 
-	memcpy(&eparams->params.bssid, &ether_bcast, ETHER_ADDR_LEN);
+	if (tx_dst_addr == NULL)
+		memcpy(&eparams->params.bssid, &ether_bcast, ETHER_ADDR_LEN);
+	else
+		memcpy(&eparams->params.bssid, tx_dst_addr, ETHER_ADDR_LEN);
+
 	if (ssid.SSID_len)
 		memcpy(&eparams->params.ssid, &ssid, sizeof(wlc_ssid_t));
 
-	eparams->params.nprobes = htod32(P2PAPI_SCAN_NPROBES);
 	eparams->params.home_time = htod32(P2PAPI_SCAN_HOME_TIME_MS);
-	if (wl_get_drv_status_all(wl, CONNECTED))
-		eparams->params.active_time = htod32(-1);
-	else if (num_chans == 3)
+
+	/* SOCIAL_CHAN_CNT + 1 takes care of the Progressive scan supported by
+	 * the supplicant
+	 */
+	if ((num_chans == SOCIAL_CHAN_CNT) || (num_chans == SOCIAL_CHAN_CNT + 1))
 		eparams->params.active_time = htod32(P2PAPI_SCAN_SOCIAL_DWELL_TIME_MS);
+	else if (num_chans == AF_PEER_SEARCH_CNT)
+		eparams->params.active_time = htod32(P2PAPI_SCAN_AF_SEARCH_DWELL_TIME_MS);
+	else if (wl_get_drv_status_all(wl, CONNECTED))
+		eparams->params.active_time = -1;
 	else
 		eparams->params.active_time = htod32(P2PAPI_SCAN_DWELL_TIME_MS);
+	eparams->params.nprobes = htod32((eparams->params.active_time /
+		P2PAPI_SCAN_NPROBS_TIME_MS));
+
+	/* Override scan params to find a peer for a connection */
+	if (num_chans == 1) {
+		eparams->params.active_time = htod32(WL_SCAN_CONNECT_DWELL_TIME_MS);
+		eparams->params.nprobes = htod32(eparams->params.active_time /
+			WL_SCAN_JOIN_PROBE_INTERVAL_MS);
+	}
+
+	if (eparams->params.nprobes <= 0)
+		eparams->params.nprobes = 1;
+	CFGP2P_DBG(("nprobes # %d, active_time %d\n",
+		eparams->params.nprobes, eparams->params.active_time));
 	eparams->params.passive_time = htod32(-1);
 	eparams->params.channel_num = htod32((0 << WL_SCAN_PARAMS_NSSID_SHIFT) |
 	    (num_chans & WL_SCAN_PARAMS_COUNT_MASK));
@@ -762,7 +874,7 @@ wl_cfgp2p_escan(struct wl_priv *wl, struct net_device *dev, u16 active,
 	}
 	eparams->version = htod32(ESCAN_REQ_VERSION);
 	eparams->action =  htod16(action);
-	eparams->sync_id = htod16(0x1234);
+	wl_escan_set_sync_id(eparams->sync_id, wl);
 	CFGP2P_INFO(("SCAN CHANNELS : "));
 
 	for (i = 0; i < num_chans; i++) {
@@ -774,6 +886,8 @@ wl_cfgp2p_escan(struct wl_priv *wl, struct net_device *dev, u16 active,
 
 	ret = wldev_iovar_setbuf_bsscfg(pri_dev, "p2p_scan",
 		memblk, memsize, wl->ioctl_buf, WLC_IOCTL_MAXLEN, bssidx, &wl->ioctl_buf_sync);
+	if (ret == BCME_OK)
+		wl_set_p2p_status(wl, SCANNING);
 	return ret;
 }
 
@@ -786,18 +900,18 @@ wl_cfgp2p_escan(struct wl_priv *wl, struct net_device *dev, u16 active,
  */
 s32
 wl_cfgp2p_act_frm_search(struct wl_priv *wl, struct net_device *ndev,
-	s32 bssidx, s32 channel)
+	s32 bssidx, s32 channel, struct ether_addr *tx_dst_addr)
 {
 	s32 ret = 0;
 	u32 chan_cnt = 0;
 	u16 *default_chan_list = NULL;
-	if (!p2p_is_on(wl))
+	if (!p2p_is_on(wl) || ndev == NULL || bssidx == WL_INVALID)
 		return -BCME_ERROR;
 	CFGP2P_ERR((" Enter\n"));
-	if (bssidx == P2PAPI_BSSCFG_PRIMARY)
-		bssidx =  wl_to_p2p_bss_bssidx(wl, P2PAPI_BSSCFG_DEVICE);
+	if (bssidx == wl_to_p2p_bss_bssidx(wl, P2PAPI_BSSCFG_PRIMARY))
+		bssidx = wl_to_p2p_bss_bssidx(wl, P2PAPI_BSSCFG_DEVICE);
 	if (channel)
-		chan_cnt = 1;
+		chan_cnt = AF_PEER_SEARCH_CNT;
 	else
 		chan_cnt = SOCIAL_CHAN_CNT;
 	default_chan_list = kzalloc(chan_cnt * sizeof(*default_chan_list), GFP_KERNEL);
@@ -807,15 +921,19 @@ wl_cfgp2p_act_frm_search(struct wl_priv *wl, struct net_device *ndev,
 		goto exit;
 	}
 	if (channel) {
-		default_chan_list[0] = channel;
+		u32 i;
+		/* insert same channel to the chan_list */
+		for (i = 0; i < chan_cnt; i++) {
+			default_chan_list[i] = channel;
+		}
 	} else {
 		default_chan_list[0] = SOCIAL_CHAN_1;
 		default_chan_list[1] = SOCIAL_CHAN_2;
 		default_chan_list[2] = SOCIAL_CHAN_3;
 	}
-	ret = wl_cfgp2p_escan(wl, ndev, true, SOCIAL_CHAN_CNT,
+	ret = wl_cfgp2p_escan(wl, ndev, true, chan_cnt,
 		default_chan_list, WL_P2P_DISC_ST_SEARCH,
-		WL_SCAN_ACTION_START, bssidx);
+		WL_SCAN_ACTION_START, bssidx, tx_dst_addr);
 	kfree(default_chan_list);
 exit:
 	return ret;
@@ -831,9 +949,69 @@ exit:
 #define wl_cfgp2p_is_p2p_ie(ie, tlvs, len)	wl_cfgp2p_has_ie(ie, tlvs, len, \
 		(const uint8 *)WFA_OUI, WFA_OUI_LEN, WFA_OUI_TYPE_P2P)
 /* Check whether the given IE looks like WFA WFDisplay IE. */
+#ifndef WFA_OUI_TYPE_WFD
 #define WFA_OUI_TYPE_WFD	0x0a			/* WiFi Display OUI TYPE */
+#endif
 #define wl_cfgp2p_is_wfd_ie(ie, tlvs, len)	wl_cfgp2p_has_ie(ie, tlvs, len, \
 		(const uint8 *)WFA_OUI, WFA_OUI_LEN, WFA_OUI_TYPE_WFD)
+
+static s32
+wl_cfgp2p_parse_vndr_ies(u8 *parse, u32 len,
+	struct parsed_vndr_ies *vndr_ies)
+{
+	s32 err = BCME_OK;
+	vndr_ie_t *vndrie;
+	bcm_tlv_t *ie;
+	struct parsed_vndr_ie_info *parsed_info;
+	u32	count = 0;
+	s32 remained_len;
+
+	remained_len = (s32)len;
+	memset(vndr_ies, 0, sizeof(*vndr_ies));
+
+	WL_INFO(("---> len %d\n", len));
+	ie = (bcm_tlv_t *) parse;
+	if (!bcm_valid_tlv(ie, remained_len))
+		ie = NULL;
+	while (ie) {
+		if (count >= MAX_VNDR_IE_NUMBER)
+			break;
+		if (ie->id == DOT11_MNG_VS_ID) {
+			vndrie = (vndr_ie_t *) ie;
+			/* len should be bigger than OUI length + one data length at least */
+			if (vndrie->len < (VNDR_IE_MIN_LEN + 1)) {
+				CFGP2P_ERR(("%s: invalid vndr ie. length is too small %d\n",
+					__FUNCTION__, vndrie->len));
+				goto end;
+			}
+			/* if wpa or wme ie, do not add ie */
+			if (!bcmp(vndrie->oui, (u8*)WPA_OUI, WPA_OUI_LEN) &&
+				((vndrie->data[0] == WPA_OUI_TYPE) ||
+				(vndrie->data[0] == WME_OUI_TYPE))) {
+				CFGP2P_DBG(("Found WPA/WME oui. Do not add it\n"));
+				goto end;
+			}
+
+			parsed_info = &vndr_ies->ie_info[count++];
+
+			/* save vndr ie information */
+			parsed_info->ie_ptr = (char *)vndrie;
+			parsed_info->ie_len = (vndrie->len + TLV_HDR_LEN);
+			memcpy(&parsed_info->vndrie, vndrie, sizeof(vndr_ie_t));
+
+			vndr_ies->count = count;
+
+			CFGP2P_DBG(("\t ** OUI %02x %02x %02x, type 0x%02x \n",
+				parsed_info->vndrie.oui[0], parsed_info->vndrie.oui[1],
+				parsed_info->vndrie.oui[2], parsed_info->vndrie.data[0]));
+		}
+end:
+		ie = bcm_next_tlv(ie, &remained_len);
+	}
+	return err;
+}
+
+
 /* Delete and Set a management vndr ie to firmware
  * Parameters:
  * @wl       : wl_private data
@@ -850,52 +1028,62 @@ s32
 wl_cfgp2p_set_management_ie(struct wl_priv *wl, struct net_device *ndev, s32 bssidx,
     s32 pktflag, const u8 *vndr_ie, u32 vndr_ie_len)
 {
-	/* Vendor-specific Information Element ID */
-#define VNDR_SPEC_ELEMENT_ID 0xdd
 	s32 ret = BCME_OK;
-	u32 pos;
-	u8  *ie_buf;
+	u8  *curr_ie_buf = NULL;
 	u8  *mgmt_ie_buf = NULL;
 	u32 mgmt_ie_buf_len = 0;
 	u32 *mgmt_ie_len = 0;
-	u8 ie_id, ie_len;
-	u8 delete = 0;
+	u32 del_add_ie_buf_len = 0;
+	u32 total_ie_buf_len = 0;
+	u32 parsed_ie_buf_len = 0;
+	struct parsed_vndr_ies old_vndr_ies;
+	struct parsed_vndr_ies new_vndr_ies;
+	s32 i;
+	u8 *ptr;
+	s32 type = -1;
+	s32 remained_buf_len;
 #define IE_TYPE(type, bsstype) (wl_to_p2p_bss_saved_ie(wl, bsstype).p2p_ ## type ## _ie)
 #define IE_TYPE_LEN(type, bsstype) (wl_to_p2p_bss_saved_ie(wl, bsstype).p2p_ ## type ## _ie_len)
-	if (p2p_is_on(wl) && bssidx != -1) {
-		if (bssidx == P2PAPI_BSSCFG_PRIMARY)
-			bssidx =  wl_to_p2p_bss_bssidx(wl, P2PAPI_BSSCFG_DEVICE);
+	memset(g_mgmt_ie_buf, 0, sizeof(g_mgmt_ie_buf));
+	curr_ie_buf = g_mgmt_ie_buf;
+	CFGP2P_DBG((" bssidx %d, pktflag : 0x%02X\n", bssidx, pktflag));
+	if (wl->p2p != NULL) {
+		if (wl_cfgp2p_find_type(wl, bssidx, &type)) {
+			CFGP2P_ERR(("cannot find type from bssidx : %d\n", bssidx));
+			return BCME_ERROR;
+		}
+
 		switch (pktflag) {
 			case VNDR_IE_PRBREQ_FLAG :
-				mgmt_ie_buf = IE_TYPE(probe_req, bssidx);
-				mgmt_ie_len = &IE_TYPE_LEN(probe_req, bssidx);
-				mgmt_ie_buf_len = sizeof(IE_TYPE(probe_req, bssidx));
+				mgmt_ie_buf = IE_TYPE(probe_req, type);
+				mgmt_ie_len = &IE_TYPE_LEN(probe_req, type);
+				mgmt_ie_buf_len = sizeof(IE_TYPE(probe_req, type));
 				break;
 			case VNDR_IE_PRBRSP_FLAG :
-				mgmt_ie_buf = IE_TYPE(probe_res, bssidx);
-				mgmt_ie_len = &IE_TYPE_LEN(probe_res, bssidx);
-				mgmt_ie_buf_len = sizeof(IE_TYPE(probe_res, bssidx));
+				mgmt_ie_buf = IE_TYPE(probe_res, type);
+				mgmt_ie_len = &IE_TYPE_LEN(probe_res, type);
+				mgmt_ie_buf_len = sizeof(IE_TYPE(probe_res, type));
 				break;
 			case VNDR_IE_ASSOCREQ_FLAG :
-				mgmt_ie_buf = IE_TYPE(assoc_req, bssidx);
-				mgmt_ie_len = &IE_TYPE_LEN(assoc_req, bssidx);
-				mgmt_ie_buf_len = sizeof(IE_TYPE(assoc_req, bssidx));
+				mgmt_ie_buf = IE_TYPE(assoc_req, type);
+				mgmt_ie_len = &IE_TYPE_LEN(assoc_req, type);
+				mgmt_ie_buf_len = sizeof(IE_TYPE(assoc_req, type));
 				break;
 			case VNDR_IE_ASSOCRSP_FLAG :
-				mgmt_ie_buf = IE_TYPE(assoc_res, bssidx);
-				mgmt_ie_len = &IE_TYPE_LEN(assoc_res, bssidx);
-				mgmt_ie_buf_len = sizeof(IE_TYPE(assoc_res, bssidx));
+				mgmt_ie_buf = IE_TYPE(assoc_res, type);
+				mgmt_ie_len = &IE_TYPE_LEN(assoc_res, type);
+				mgmt_ie_buf_len = sizeof(IE_TYPE(assoc_res, type));
 				break;
 			case VNDR_IE_BEACON_FLAG :
-				mgmt_ie_buf = IE_TYPE(beacon, bssidx);
-				mgmt_ie_len = &IE_TYPE_LEN(beacon, bssidx);
-				mgmt_ie_buf_len = sizeof(IE_TYPE(beacon, bssidx));
+				mgmt_ie_buf = IE_TYPE(beacon, type);
+				mgmt_ie_len = &IE_TYPE_LEN(beacon, type);
+				mgmt_ie_buf_len = sizeof(IE_TYPE(beacon, type));
 				break;
 			default:
 				mgmt_ie_buf = NULL;
 				mgmt_ie_len = NULL;
 				CFGP2P_ERR(("not suitable type\n"));
-				return -1;
+				return BCME_ERROR;
 		}
 	} else if (wl_get_mode_by_netdev(wl, ndev) == WL_MODE_AP) {
 		switch (pktflag) {
@@ -913,10 +1101,10 @@ wl_cfgp2p_set_management_ie(struct wl_priv *wl, struct net_device *ndev, s32 bss
 				mgmt_ie_buf = NULL;
 				mgmt_ie_len = NULL;
 				CFGP2P_ERR(("not suitable type\n"));
-				return -1;
+				return BCME_ERROR;
 		}
 		bssidx = 0;
-	} else if (bssidx == -1 && wl_get_mode_by_netdev(wl, ndev) == WL_MODE_BSS) {
+	} else if (wl_get_mode_by_netdev(wl, ndev) == WL_MODE_BSS) {
 		switch (pktflag) {
 			case VNDR_IE_PRBREQ_FLAG :
 				mgmt_ie_buf = wl->sta_info->probe_req_ie;
@@ -932,71 +1120,121 @@ wl_cfgp2p_set_management_ie(struct wl_priv *wl, struct net_device *ndev, s32 bss
 				mgmt_ie_buf = NULL;
 				mgmt_ie_len = NULL;
 				CFGP2P_ERR(("not suitable type\n"));
-				return -1;
+				return BCME_ERROR;
 		}
 		bssidx = 0;
 	} else {
 		CFGP2P_ERR(("not suitable type\n"));
-		return -1;
+		return BCME_ERROR;
 	}
 
 	if (vndr_ie_len > mgmt_ie_buf_len) {
 		CFGP2P_ERR(("extra IE size too big\n"));
 		ret = -ENOMEM;
 	} else {
+		/* parse and save new vndr_ie in curr_ie_buff before comparing it */
+		if (vndr_ie && vndr_ie_len && curr_ie_buf) {
+			ptr = curr_ie_buf;
+
+			wl_cfgp2p_parse_vndr_ies((u8*)vndr_ie,
+				vndr_ie_len, &new_vndr_ies);
+
+			for (i = 0; i < new_vndr_ies.count; i++) {
+				struct parsed_vndr_ie_info *vndrie_info =
+					&new_vndr_ies.ie_info[i];
+
+				memcpy(ptr + parsed_ie_buf_len, vndrie_info->ie_ptr,
+					vndrie_info->ie_len);
+				parsed_ie_buf_len += vndrie_info->ie_len;
+			}
+		}
+
 		if (mgmt_ie_buf != NULL) {
-			if (vndr_ie_len && (vndr_ie_len == *mgmt_ie_len) &&
-			     (memcmp(mgmt_ie_buf, vndr_ie, vndr_ie_len) == 0)) {
+			if (parsed_ie_buf_len && (parsed_ie_buf_len == *mgmt_ie_len) &&
+			     (memcmp(mgmt_ie_buf, curr_ie_buf, parsed_ie_buf_len) == 0)) {
 				CFGP2P_INFO(("Previous mgmt IE is equals to current IE"));
 				goto exit;
 			}
-			pos = 0;
-			delete = 1;
-			ie_buf = (u8 *) mgmt_ie_buf;
-			while (pos < *mgmt_ie_len) {
-				ie_id = ie_buf[pos++];
-				ie_len = ie_buf[pos++];
-				if ((ie_id == DOT11_MNG_VS_ID) &&
-				   (wl_cfgp2p_is_wps_ie(&ie_buf[pos-2], NULL, 0) ||
-					wl_cfgp2p_is_p2p_ie(&ie_buf[pos-2], NULL, 0) ||
-					wl_cfgp2p_is_wfd_ie(&ie_buf[pos-2], NULL, 0))) {
-					CFGP2P_INFO(("DELELED ID : %d, Len : %d , OUI :"
-						"%02x:%02x:%02x\n", ie_id, ie_len, ie_buf[pos],
-						ie_buf[pos+1], ie_buf[pos+2]));
-					ret = wl_cfgp2p_vndr_ie(wl, ndev, bssidx, pktflag,
-						ie_buf+pos, VNDR_SPEC_ELEMENT_ID, ie_buf+pos+3,
-						ie_len-3, delete);
-				}
-				pos += ie_len;
-			}
 
+			/* parse old vndr_ie */
+			wl_cfgp2p_parse_vndr_ies(mgmt_ie_buf, *mgmt_ie_len,
+				&old_vndr_ies);
+
+			/* make a command to delete old ie */
+			for (i = 0; i < old_vndr_ies.count; i++) {
+				struct parsed_vndr_ie_info *vndrie_info =
+					&old_vndr_ies.ie_info[i];
+
+				CFGP2P_INFO(("DELETED ID : %d, Len: %d , OUI:%02x:%02x:%02x\n",
+					vndrie_info->vndrie.id, vndrie_info->vndrie.len,
+					vndrie_info->vndrie.oui[0], vndrie_info->vndrie.oui[1],
+					vndrie_info->vndrie.oui[2]));
+
+				del_add_ie_buf_len = wl_cfgp2p_vndr_ie(wl, curr_ie_buf,
+					pktflag, vndrie_info->vndrie.oui,
+					vndrie_info->vndrie.id,
+					vndrie_info->ie_ptr + VNDR_IE_FIXED_LEN,
+					vndrie_info->ie_len - VNDR_IE_FIXED_LEN,
+					"del");
+
+				curr_ie_buf += del_add_ie_buf_len;
+				total_ie_buf_len += del_add_ie_buf_len;
+			}
 		}
+
 		*mgmt_ie_len = 0;
 		/* Add if there is any extra IE */
-		if (vndr_ie && vndr_ie_len) {
-			/* save the current IE in wl struct */
-			memcpy(mgmt_ie_buf, vndr_ie, vndr_ie_len);
-			*mgmt_ie_len = vndr_ie_len;
-			pos = 0;
-			ie_buf = (u8 *) vndr_ie;
-			delete = 0;
-			while (pos < vndr_ie_len) {
-				ie_id = ie_buf[pos++];
-				ie_len = ie_buf[pos++];
-				if ((ie_id == DOT11_MNG_VS_ID) &&
-				   (wl_cfgp2p_is_wps_ie(&ie_buf[pos-2], NULL, 0) ||
-					wl_cfgp2p_is_p2p_ie(&ie_buf[pos-2], NULL, 0) ||
-					wl_cfgp2p_is_wfd_ie(&ie_buf[pos-2], NULL, 0))) {
-					CFGP2P_INFO(("ADDED ID : %d, Len : %d , OUI :"
-						"%02x:%02x:%02x\n", ie_id, ie_len, ie_buf[pos],
-						ie_buf[pos+1], ie_buf[pos+2]));
-					ret = wl_cfgp2p_vndr_ie(wl, ndev, bssidx, pktflag,
-						ie_buf+pos, VNDR_SPEC_ELEMENT_ID, ie_buf+pos+3,
-						ie_len-3, delete);
+		if (mgmt_ie_buf && parsed_ie_buf_len) {
+			ptr = mgmt_ie_buf;
+
+			remained_buf_len = mgmt_ie_buf_len;
+
+			/* make a command to add new ie */
+			for (i = 0; i < new_vndr_ies.count; i++) {
+				struct parsed_vndr_ie_info *vndrie_info =
+					&new_vndr_ies.ie_info[i];
+
+				CFGP2P_INFO(("ADDED ID : %d, Len: %d(%d), OUI:%02x:%02x:%02x\n",
+					vndrie_info->vndrie.id, vndrie_info->vndrie.len,
+					vndrie_info->ie_len - 2,
+					vndrie_info->vndrie.oui[0], vndrie_info->vndrie.oui[1],
+					vndrie_info->vndrie.oui[2]));
+
+				del_add_ie_buf_len = wl_cfgp2p_vndr_ie(wl, curr_ie_buf,
+					pktflag, vndrie_info->vndrie.oui,
+					vndrie_info->vndrie.id,
+					vndrie_info->ie_ptr + VNDR_IE_FIXED_LEN,
+					vndrie_info->ie_len - VNDR_IE_FIXED_LEN,
+					"add");
+
+				/* verify remained buf size before copy data */
+				if (remained_buf_len >= vndrie_info->ie_len) {
+					remained_buf_len -= vndrie_info->ie_len;
+				} else {
+					CFGP2P_ERR(("no space in mgmt_ie_buf: pktflag = %d, "
+						"found vndr ies # = %d(cur %d), remained len %d, "
+						"cur mgmt_ie_len %d, new ie len = %d\n",
+						pktflag, new_vndr_ies.count, i, remained_buf_len,
+						*mgmt_ie_len, vndrie_info->ie_len));
+					break;
 				}
-				pos += ie_len;
+
+				/* save the parsed IE in wl struct */
+				memcpy(ptr + (*mgmt_ie_len), vndrie_info->ie_ptr,
+					vndrie_info->ie_len);
+				*mgmt_ie_len += vndrie_info->ie_len;
+
+				curr_ie_buf += del_add_ie_buf_len;
+				total_ie_buf_len += del_add_ie_buf_len;
 			}
 		}
+		if (total_ie_buf_len) {
+			ret  = wldev_iovar_setbuf_bsscfg(ndev, "vndr_ie", g_mgmt_ie_buf,
+				total_ie_buf_len, wl->ioctl_buf, WLC_IOCTL_MAXLEN,
+				bssidx, &wl->ioctl_buf_sync);
+			if (ret)
+				CFGP2P_ERR(("vndr ie set error : %d\n", ret));
+		}
 	}
 #undef IE_TYPE
 #undef IE_TYPE_LEN
@@ -1014,21 +1252,37 @@ exit:
 s32
 wl_cfgp2p_clear_management_ie(struct wl_priv *wl, s32 bssidx)
 {
+
+	s32 vndrie_flag[] = {VNDR_IE_BEACON_FLAG, VNDR_IE_PRBRSP_FLAG, VNDR_IE_ASSOCRSP_FLAG,
+		VNDR_IE_PRBREQ_FLAG, VNDR_IE_ASSOCREQ_FLAG};
+	s32 index = -1;
+	s32 type = -1;
+	struct net_device *ndev = wl_cfgp2p_find_ndev(wl, bssidx);
 #define INIT_IE(IE_TYPE, BSS_TYPE)		\
 	do {							\
 		memset(wl_to_p2p_bss_saved_ie(wl, BSS_TYPE).p2p_ ## IE_TYPE ## _ie, 0, \
 		   sizeof(wl_to_p2p_bss_saved_ie(wl, BSS_TYPE).p2p_ ## IE_TYPE ## _ie)); \
 		wl_to_p2p_bss_saved_ie(wl, BSS_TYPE).p2p_ ## IE_TYPE ## _ie_len = 0; \
 	} while (0);
-	if (bssidx < 0) {
-		CFGP2P_ERR(("invalid bssidx\n"));
+
+	if (bssidx < 0 || ndev == NULL) {
+		CFGP2P_ERR(("invalid %s\n", (bssidx < 0) ? "bssidx" : "ndev"));
 		return BCME_BADARG;
 	}
-	INIT_IE(probe_req, bssidx);
-	INIT_IE(probe_res, bssidx);
-	INIT_IE(assoc_req, bssidx);
-	INIT_IE(assoc_res, bssidx);
-	INIT_IE(beacon, bssidx);
+
+	if (wl_cfgp2p_find_type(wl, bssidx, &type)) {
+		CFGP2P_ERR(("invalid argument\n"));
+		return BCME_BADARG;
+	}
+	for (index = 0; index < ARRAYSIZE(vndrie_flag); index++) {
+		/* clean up vndr ies in dongle */
+		wl_cfgp2p_set_management_ie(wl, ndev, bssidx, vndrie_flag[index], NULL, 0);
+	}
+	INIT_IE(probe_req, type);
+	INIT_IE(probe_res, type);
+	INIT_IE(assoc_req, type);
+	INIT_IE(assoc_res, type);
+	INIT_IE(beacon, type);
 	return BCME_OK;
 }
 
@@ -1041,8 +1295,8 @@ wl_cfgp2p_has_ie(u8 *ie, u8 **tlvs, u32 *tlvs_len, const u8 *oui, u32 oui_len, u
 {
 	/* If the contents match the OUI and the type */
 	if (ie[TLV_LEN_OFF] >= oui_len + 1 &&
-	        !bcmp(&ie[TLV_BODY_OFF], oui, oui_len) &&
-	        type == ie[TLV_BODY_OFF + oui_len]) {
+		!bcmp(&ie[TLV_BODY_OFF], oui, oui_len) &&
+		type == ie[TLV_BODY_OFF + oui_len]) {
 		return TRUE;
 	}
 
@@ -1109,15 +1363,13 @@ wl_cfgp2p_find_wfdie(u8 *parse, u32 len)
 	}
 	return NULL;
 }
-static s32
-wl_cfgp2p_vndr_ie(struct wl_priv *wl, struct net_device *ndev, s32 bssidx, s32 pktflag,
-            s8 *oui, s32 ie_id, s8 *data, s32 data_len, s32 delete)
+static u32
+wl_cfgp2p_vndr_ie(struct wl_priv *wl, u8 *iebuf, s32 pktflag,
+            s8 *oui, s32 ie_id, s8 *data, s32 datalen, const s8* add_del_cmd)
 {
-	s32 err = BCME_OK;
-	s32 buf_len;
+	vndr_ie_setbuf_t hdr;	/* aligned temporary vndr_ie buffer header */
 	s32 iecount;
-
-	vndr_ie_setbuf_t *ie_setbuf;
+	u32 data_offset;
 
 	/* Validate the pktflag parameter */
 	if ((pktflag & ~(VNDR_IE_BEACON_FLAG | VNDR_IE_PRBRSP_FLAG |
@@ -1127,36 +1379,41 @@ wl_cfgp2p_vndr_ie(struct wl_priv *wl, struct net_device *ndev, s32 bssidx, s32 p
 		return -1;
 	}
 
-	buf_len = sizeof(vndr_ie_setbuf_t) + data_len - 1;
-	ie_setbuf = (vndr_ie_setbuf_t *) kzalloc(buf_len, GFP_KERNEL);
+	/* Copy the vndr_ie SET command ("add"/"del") to the buffer */
+	strncpy(hdr.cmd, add_del_cmd, VNDR_IE_CMD_LEN - 1);
+	hdr.cmd[VNDR_IE_CMD_LEN - 1] = '\0';
 
-	CFGP2P_INFO((" ie_id : %02x, data length : %d\n", ie_id, data_len));
-	if (!ie_setbuf) {
-
-		CFGP2P_ERR(("Error allocating buffer for IE\n"));
-		return -ENOMEM;
-	}
-	if (delete)
-		strcpy(ie_setbuf->cmd, "del");
-	else
-		strcpy(ie_setbuf->cmd, "add");
-	/* Buffer contains only 1 IE */
+	/* Set the IE count - the buffer contains only 1 IE */
 	iecount = htod32(1);
-	memcpy((void *)&ie_setbuf->vndr_ie_buffer.iecount, &iecount, sizeof(int));
+	memcpy((void *)&hdr.vndr_ie_buffer.iecount, &iecount, sizeof(s32));
+
+	/* Copy packet flags that indicate which packets will contain this IE */
 	pktflag = htod32(pktflag);
-	memcpy((void *)&ie_setbuf->vndr_ie_buffer.vndr_ie_list[0].pktflag,
-	    &pktflag, sizeof(uint32));
-	ie_setbuf->vndr_ie_buffer.vndr_ie_list[0].vndr_ie_data.id = ie_id;
-	ie_setbuf->vndr_ie_buffer.vndr_ie_list[0].vndr_ie_data.len
-	        = (uchar)(data_len + VNDR_IE_MIN_LEN);
-	memcpy(ie_setbuf->vndr_ie_buffer.vndr_ie_list[0].vndr_ie_data.oui, oui, 3);
-	memcpy(ie_setbuf->vndr_ie_buffer.vndr_ie_list[0].vndr_ie_data.data, data, data_len);
-	err = wldev_iovar_setbuf_bsscfg(ndev, "vndr_ie", ie_setbuf, buf_len,
-		wl->ioctl_buf, WLC_IOCTL_MAXLEN, bssidx, &wl->ioctl_buf_sync);
+	memcpy((void *)&hdr.vndr_ie_buffer.vndr_ie_list[0].pktflag, &pktflag,
+		sizeof(u32));
+
+	/* Add the IE ID to the buffer */
+	hdr.vndr_ie_buffer.vndr_ie_list[0].vndr_ie_data.id = ie_id;
+
+	/* Add the IE length to the buffer */
+	hdr.vndr_ie_buffer.vndr_ie_list[0].vndr_ie_data.len =
+		(uint8) VNDR_IE_MIN_LEN + datalen;
+
+	/* Add the IE OUI to the buffer */
+	hdr.vndr_ie_buffer.vndr_ie_list[0].vndr_ie_data.oui[0] = oui[0];
+	hdr.vndr_ie_buffer.vndr_ie_list[0].vndr_ie_data.oui[1] = oui[1];
+	hdr.vndr_ie_buffer.vndr_ie_list[0].vndr_ie_data.oui[2] = oui[2];
+
+	/* Copy the aligned temporary vndr_ie buffer header to the IE buffer */
+	memcpy(iebuf, &hdr, sizeof(hdr) - 1);
+
+	/* Copy the IE data to the IE buffer */
+	data_offset =
+		(u8*)&hdr.vndr_ie_buffer.vndr_ie_list[0].vndr_ie_data.data[0] -
+		(u8*)&hdr;
+	memcpy(iebuf + data_offset, data, datalen);
+	return data_offset + datalen;
 
-	CFGP2P_INFO(("vndr_ie iovar returns %d\n", err));
-	kfree(ie_setbuf);
-	return err;
 }
 
 /*
@@ -1164,32 +1421,81 @@ wl_cfgp2p_vndr_ie(struct wl_priv *wl, struct net_device *ndev, s32 bssidx, s32 p
  * Parameters:
  * @wl       : wl_private data
  * @ndev     : net device to search bssidx
- *  Returns bssidx for ndev
+ * @bssidx  : output arg to store bssidx of the bsscfg of firmware.
+ * Returns error
  */
 s32
-wl_cfgp2p_find_idx(struct wl_priv *wl, struct net_device *ndev)
+wl_cfgp2p_find_idx(struct wl_priv *wl, struct net_device *ndev, s32 *bssidx)
 {
 	u32 i;
-	s32 index = -1;
-
-	if (ndev == NULL) {
-		CFGP2P_ERR((" ndev is NULL\n"));
-		goto exit;
+	if (ndev == NULL || bssidx == NULL) {
+		CFGP2P_ERR((" argument is invalid\n"));
+		return BCME_BADARG;
 	}
 	if (!wl->p2p_supported) {
-		return P2PAPI_BSSCFG_PRIMARY;
+		*bssidx = P2PAPI_BSSCFG_PRIMARY;
+		return BCME_OK;
 	}
+	/* we cannot find the bssidx of DISCOVERY BSS
+	 *  because the ndev is same with ndev of PRIMARY BSS.
+	 */
 	for (i = 0; i < P2PAPI_BSSCFG_MAX; i++) {
 		if (ndev == wl_to_p2p_bss_ndev(wl, i)) {
-			index = wl_to_p2p_bss_bssidx(wl, i);
+			*bssidx = wl_to_p2p_bss_bssidx(wl, i);
+			return BCME_OK;
+		}
+	}
+	return BCME_BADARG;
+}
+struct net_device *
+wl_cfgp2p_find_ndev(struct wl_priv *wl, s32 bssidx)
+{
+	u32 i;
+	struct net_device *ndev = NULL;
+	if (bssidx < 0) {
+		CFGP2P_ERR((" bsscfg idx is invalid\n"));
+		goto exit;
+	}
+
+	for (i = 0; i < P2PAPI_BSSCFG_MAX; i++) {
+		if (bssidx == wl_to_p2p_bss_bssidx(wl, i)) {
+			ndev = wl_to_p2p_bss_ndev(wl, i);
 			break;
 		}
 	}
-	if (index == -1)
-		return P2PAPI_BSSCFG_PRIMARY;
+
+exit:
+	return ndev;
+}
+/*
+ * Search the driver array idx based on bssidx argument
+ * Parameters:
+ * @wl     : wl_private data
+ * @bssidx : bssidx which indicate bsscfg->idx of firmware.
+ * @type   : output arg to store array idx of p2p->bss.
+ * Returns error
+ */
+
+s32
+wl_cfgp2p_find_type(struct wl_priv *wl, s32 bssidx, s32 *type)
+{
+	u32 i;
+	if (bssidx < 0 || type == NULL) {
+		CFGP2P_ERR((" argument is invalid\n"));
+		goto exit;
+	}
+
+	for (i = 0; i < P2PAPI_BSSCFG_MAX; i++) {
+		if (bssidx == wl_to_p2p_bss_bssidx(wl, i)) {
+			*type = i;
+			return BCME_OK;
+		}
+	}
+
 exit:
-	return index;
+	return BCME_BADARG;
 }
+
 /*
  * Callback function for WLC_E_P2P_DISC_LISTEN_COMPLETE
  */
@@ -1198,17 +1504,59 @@ wl_cfgp2p_listen_complete(struct wl_priv *wl, struct net_device *ndev,
             const wl_event_msg_t *e, void *data)
 {
 	s32 ret = BCME_OK;
-
+	struct net_device *netdev;
+	if (!wl || !wl->p2p)
+		return BCME_ERROR;
+	if (wl->p2p_net == ndev) {
+		netdev = wl_to_prmry_ndev(wl);
+	} else {
+		netdev = ndev;
+	}
 	CFGP2P_DBG((" Enter\n"));
 	if (wl_get_p2p_status(wl, LISTEN_EXPIRED) == 0) {
 		wl_set_p2p_status(wl, LISTEN_EXPIRED);
 		if (timer_pending(&wl->p2p->listen_timer)) {
-			spin_lock_bh(&wl->p2p->timer_lock);
 			del_timer_sync(&wl->p2p->listen_timer);
-			spin_unlock_bh(&wl->p2p->timer_lock);
 		}
-		cfg80211_remain_on_channel_expired(ndev, wl->last_roc_id, &wl->remain_on_chan,
-		    wl->remain_on_chan_type, GFP_KERNEL);
+
+		if (wl->afx_hdl->is_listen == TRUE &&
+			wl_get_drv_status_all(wl, FINDING_COMMON_CHANNEL)) {
+			WL_DBG(("Listen DONE for action frame\n"));
+			complete(&wl->act_frm_scan);
+		}
+#ifdef WL_CFG80211_SYNC_GON
+		else if (wl_get_drv_status_all(wl, WAITING_NEXT_ACT_FRM_LISTEN)) {
+			wl_clr_drv_status(wl, WAITING_NEXT_ACT_FRM_LISTEN, netdev);
+			WL_DBG(("Listen DONE and wake up wait_next_af !!(%d)\n",
+				jiffies_to_msecs(jiffies - wl->af_tx_sent_jiffies)));
+
+			if (wl_get_drv_status_all(wl, WAITING_NEXT_ACT_FRM))
+				wl_clr_drv_status(wl, WAITING_NEXT_ACT_FRM, netdev);
+
+			complete(&wl->wait_next_af);
+		}
+#endif /* WL_CFG80211_SYNC_GON */
+
+#ifndef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
+		if (wl_get_drv_status_all(wl, REMAINING_ON_CHANNEL)) {
+#else
+		if (wl_get_drv_status_all(wl, REMAINING_ON_CHANNEL) ||
+			wl_get_drv_status_all(wl, FAKE_REMAINING_ON_CHANNEL)) {
+#endif /* WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
+			WL_DBG(("Listen DONE for ramain on channel expired\n"));
+			wl_clr_drv_status(wl, REMAINING_ON_CHANNEL, netdev);
+#ifdef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
+			wl_clr_drv_status(wl, FAKE_REMAINING_ON_CHANNEL, netdev);
+#endif /* WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
+			if (ndev && (ndev->ieee80211_ptr != NULL)) {
+				cfg80211_remain_on_channel_expired(ndev, wl->last_roc_id,
+					&wl->remain_on_chan, wl->remain_on_chan_type, GFP_KERNEL);
+			}
+		}
+		if (wl_add_remove_eventmsg(wl_to_prmry_ndev(wl),
+			WLC_E_P2P_PROBREQ_MSG, false) != BCME_OK) {
+			CFGP2P_ERR((" failed to unset WLC_E_P2P_PROPREQ_MSG\n"));
+		}
 	} else
 		wl_clr_p2p_status(wl, LISTEN_EXPIRED);
 
@@ -1221,17 +1569,39 @@ wl_cfgp2p_listen_complete(struct wl_priv *wl, struct net_device *ndev,
  *  We can't report cfg80211_remain_on_channel_expired from Timer ISR context,
  *  so lets do it from thread context.
  */
-static void
+void
 wl_cfgp2p_listen_expired(unsigned long data)
 {
 	wl_event_msg_t msg;
 	struct wl_priv *wl = (struct wl_priv *) data;
-
 	CFGP2P_DBG((" Enter\n"));
+	bzero(&msg, sizeof(wl_event_msg_t));
 	msg.event_type =  hton32(WLC_E_P2P_DISC_LISTEN_COMPLETE);
-	wl_cfg80211_event(wl_to_p2p_bss_ndev(wl, P2PAPI_BSSCFG_DEVICE), &msg, NULL);
+	wl_cfg80211_event(wl->p2p_net ? wl->p2p_net :
+		wl_to_p2p_bss_ndev(wl, P2PAPI_BSSCFG_DEVICE), &msg, NULL);
+}
+/*
+ *  Routine for cancelling the P2P LISTEN
+ */
+static s32
+wl_cfgp2p_cancel_listen(struct wl_priv *wl, struct net_device *ndev,
+                         bool notify)
+{
+	WL_DBG(("Enter \n"));
+	/* Irrespective of whether timer is running or not, reset
+	 * the LISTEN state.
+	 */
+	if (timer_pending(&wl->p2p->listen_timer)) {
+		del_timer_sync(&wl->p2p->listen_timer);
+		if (notify)
+			if (ndev && ndev->ieee80211_ptr) {
+				cfg80211_remain_on_channel_expired(ndev, wl->last_roc_id,
+				 &wl->remain_on_chan, wl->remain_on_chan_type,
+				 GFP_KERNEL);
+			}
+	}
+	return 0;
 }
-
 /*
  * Do a P2P Listen on the given channel for the given duration.
  * A listen consists of sitting idle and responding to P2P probe requests
@@ -1246,18 +1616,13 @@ wl_cfgp2p_listen_expired(unsigned long data)
 s32
 wl_cfgp2p_discover_listen(struct wl_priv *wl, s32 channel, u32 duration_ms)
 {
-#define INIT_TIMER(timer, func, duration, extra_delay)	\
-	do {                   \
-		init_timer(timer); \
-		timer->function = func; \
-		timer->expires = jiffies + msecs_to_jiffies(duration + extra_delay); \
-		timer->data = (unsigned long) wl; \
-		add_timer(timer); \
-	} while (0);
-
+#define EXTRA_DELAY_TIME	100
 	s32 ret = BCME_OK;
 	struct timer_list *_timer;
-	CFGP2P_DBG((" Enter Channel : %d, Duration : %d\n", channel, duration_ms));
+	s32 extra_delay;
+	struct net_device *netdev = wl_to_prmry_ndev(wl);
+
+	CFGP2P_DBG((" Enter Listen Channel : %d, Duration : %d\n", channel, duration_ms));
 	if (unlikely(wl_get_p2p_status(wl, DISCOVERY_ON) == 0)) {
 
 		CFGP2P_ERR((" Discovery is not set, so we have noting to do\n"));
@@ -1269,19 +1634,36 @@ wl_cfgp2p_discover_listen(struct wl_priv *wl, s32 channel, u32 duration_ms)
 		CFGP2P_DBG(("previous LISTEN is not completed yet\n"));
 		goto exit;
 
-	} else
+	}
+#ifndef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
+	else
 		wl_clr_p2p_status(wl, LISTEN_EXPIRED);
+#endif /* not WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
+	if (wl_add_remove_eventmsg(netdev, WLC_E_P2P_PROBREQ_MSG, true) != BCME_OK) {
+			CFGP2P_ERR((" failed to set WLC_E_P2P_PROPREQ_MSG\n"));
+	}
 
-	wl_cfgp2p_set_p2p_mode(wl, WL_P2P_DISC_ST_LISTEN, channel, (u16) duration_ms,
+	ret = wl_cfgp2p_set_p2p_mode(wl, WL_P2P_DISC_ST_LISTEN, channel, (u16) duration_ms,
 	            wl_to_p2p_bss_bssidx(wl, P2PAPI_BSSCFG_DEVICE));
 	_timer = &wl->p2p->listen_timer;
 
 	/*  We will wait to receive WLC_E_P2P_DISC_LISTEN_COMPLETE from dongle ,
-	 *  otherwise we will wait up to duration_ms + 200ms
+	 *  otherwise we will wait up to duration_ms + 100ms + duration / 10
 	 */
-	INIT_TIMER(_timer, wl_cfgp2p_listen_expired, duration_ms, 200);
+	if (ret == BCME_OK) {
+		extra_delay = EXTRA_DELAY_TIME + (duration_ms / 10);
+	} else {
+		/* if failed to set listen, it doesn't need to wait whole duration. */
+		duration_ms = 100 + duration_ms / 20;
+		extra_delay = 0;
+	}
+
+	INIT_TIMER(_timer, wl_cfgp2p_listen_expired, duration_ms, extra_delay);
+#ifdef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
+	wl_clr_p2p_status(wl, LISTEN_EXPIRED);
+#endif /* WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
 
-#undef INIT_TIMER
+#undef EXTRA_DELAY_TIME
 exit:
 	return ret;
 }
@@ -1326,20 +1708,31 @@ wl_cfgp2p_action_tx_complete(struct wl_priv *wl, struct net_device *ndev,
 	u32 event_type = ntoh32(e->event_type);
 	u32 status = ntoh32(e->status);
 	CFGP2P_DBG((" Enter\n"));
-	if (event_type == WLC_E_ACTION_FRAME_COMPLETE) {
+	if (wl_get_drv_status_all(wl, SENDING_ACT_FRM)) {
+		if (event_type == WLC_E_ACTION_FRAME_COMPLETE) {
 
-		CFGP2P_INFO((" WLC_E_ACTION_FRAME_COMPLETE is received : %d\n", status));
-		if (status == WLC_E_STATUS_SUCCESS) {
-			wl_set_p2p_status(wl, ACTION_TX_COMPLETED);
-		}
-		else {
-			wl_set_p2p_status(wl, ACTION_TX_NOACK);
-			CFGP2P_ERR(("WLC_E_ACTION_FRAME_COMPLETE : NO ACK\n"));
+			CFGP2P_INFO((" WLC_E_ACTION_FRAME_COMPLETE is received : %d\n", status));
+			if (status == WLC_E_STATUS_SUCCESS) {
+				wl_set_p2p_status(wl, ACTION_TX_COMPLETED);
+				CFGP2P_DBG(("WLC_E_ACTION_FRAME_COMPLETE : ACK\n"));
+			}
+			else {
+				if (!wl_get_p2p_status(wl, ACTION_TX_COMPLETED)) {
+				wl_set_p2p_status(wl, ACTION_TX_NOACK);
+				CFGP2P_INFO(("WLC_E_ACTION_FRAME_COMPLETE : NO ACK\n"));
+				/* XXX if there is no ack, we don't need to wait for
+				 * WLC_E_ACTION_FRAME_OFFCHAN_COMPLETE event
+				 */
+				wl_stop_wait_next_action_frame(wl);
+				}
+			}
+		} else {
+			CFGP2P_INFO((" WLC_E_ACTION_FRAME_OFFCHAN_COMPLETE is received,"
+						"status : %d\n", status));
+
+			if (wl_get_drv_status_all(wl, SENDING_ACT_FRM))
+				complete(&wl->send_af_done);
 		}
-	} else {
-		CFGP2P_INFO((" WLC_E_ACTION_FRAME_OFFCHAN_COMPLETE is received,"
-					"status : %d\n", status));
-		wake_up_interruptible(&wl->netif_change_event);
 	}
 	return ret;
 }
@@ -1357,6 +1750,7 @@ wl_cfgp2p_tx_action_frame(struct wl_priv *wl, struct net_device *dev,
 {
 	s32 ret = BCME_OK;
 	s32 timeout = 0;
+	wl_eventmsg_buf_t buf;
 
 
 	CFGP2P_INFO(("\n"));
@@ -1365,32 +1759,52 @@ wl_cfgp2p_tx_action_frame(struct wl_priv *wl, struct net_device *dev,
 
 	wl_clr_p2p_status(wl, ACTION_TX_COMPLETED);
 	wl_clr_p2p_status(wl, ACTION_TX_NOACK);
-#define MAX_WAIT_TIME 2000
+
+	bzero(&buf, sizeof(wl_eventmsg_buf_t));
+	wl_cfg80211_add_to_eventbuffer(&buf, WLC_E_ACTION_FRAME_OFF_CHAN_COMPLETE, true);
+	wl_cfg80211_add_to_eventbuffer(&buf, WLC_E_ACTION_FRAME_COMPLETE, true);
+	if ((ret = wl_cfg80211_apply_eventbuffer(wl_to_prmry_ndev(wl), wl, &buf)) < 0)
+		return ret;
+
 	if (bssidx == P2PAPI_BSSCFG_PRIMARY)
 		bssidx =  wl_to_p2p_bss_bssidx(wl, P2PAPI_BSSCFG_DEVICE);
 
+	wl->af_sent_channel  = af_params->channel;
+#ifdef WL_CFG80211_SYNC_GON
+	wl->af_tx_sent_jiffies = jiffies;
+#endif /* WL_CFG80211_SYNC_GON */
+
 	ret = wldev_iovar_setbuf_bsscfg(dev, "actframe", af_params, sizeof(*af_params),
 		wl->ioctl_buf, WLC_IOCTL_MAXLEN, bssidx, &wl->ioctl_buf_sync);
 
 	if (ret < 0) {
-
 		CFGP2P_ERR((" sending action frame is failed\n"));
 		goto exit;
 	}
-	timeout = wait_event_interruptible_timeout(wl->netif_change_event,
-	(wl_get_p2p_status(wl, ACTION_TX_COMPLETED) || wl_get_p2p_status(wl, ACTION_TX_NOACK)),
-	msecs_to_jiffies(MAX_WAIT_TIME));
 
-	if (timeout > 0 && wl_get_p2p_status(wl, ACTION_TX_COMPLETED)) {
+	timeout = wait_for_completion_timeout(&wl->send_af_done,
+		msecs_to_jiffies(af_params->dwell_time + WL_AF_TX_EXTRA_TIME_MAX));
+
+	if (timeout >= 0 && wl_get_p2p_status(wl, ACTION_TX_COMPLETED)) {
 		CFGP2P_INFO(("tx action frame operation is completed\n"));
 		ret = BCME_OK;
 	} else {
 		ret = BCME_ERROR;
 		CFGP2P_INFO(("tx action frame operation is failed\n"));
 	}
+	/* clear status bit for action tx */
+	wl_clr_p2p_status(wl, ACTION_TX_COMPLETED);
+	wl_clr_p2p_status(wl, ACTION_TX_NOACK);
+
 exit:
 	CFGP2P_INFO((" via act frame iovar : status = %d\n", ret));
-#undef MAX_WAIT_TIME
+
+	bzero(&buf, sizeof(wl_eventmsg_buf_t));
+	wl_cfg80211_add_to_eventbuffer(&buf, WLC_E_ACTION_FRAME_OFF_CHAN_COMPLETE, false);
+	wl_cfg80211_add_to_eventbuffer(&buf, WLC_E_ACTION_FRAME_COMPLETE, false);
+	if ((ret = wl_cfg80211_apply_eventbuffer(wl_to_prmry_ndev(wl), wl, &buf)) < 0)
+		WL_ERR(("TX frame events revert back failed \n"));
+
 	return ret;
 }
 
@@ -1550,8 +1964,14 @@ wl_cfgp2p_supported(struct wl_priv *wl, struct net_device *ndev)
 s32
 wl_cfgp2p_down(struct wl_priv *wl)
 {
-	if (timer_pending(&wl->p2p->listen_timer))
-		del_timer_sync(&wl->p2p->listen_timer);
+	s32 i = 0, index = -1;
+	wl_cfgp2p_cancel_listen(wl,
+		wl->p2p_net ? wl->p2p_net : wl_to_prmry_ndev(wl), TRUE);
+	for (i = 0; i < P2PAPI_BSSCFG_MAX; i++) {
+			index = wl_to_p2p_bss_bssidx(wl, i);
+			if (index != WL_INVALID)
+				wl_cfgp2p_clear_management_ie(wl, index);
+	}
 	wl_cfgp2p_deinit_priv(wl);
 	return 0;
 }
@@ -1570,7 +1990,7 @@ wl_cfgp2p_set_p2p_noa(struct wl_priv *wl, struct net_device *ndev, char* buf, in
 
 		wl->p2p->noa.desc[0].start = 0;
 
-		sscanf(buf, "%d %d %d", &count, &start, &duration);
+		sscanf(buf, "%10d %10d %10d", &count, &start, &duration);
 		CFGP2P_DBG(("set_p2p_noa count %d start %d duration %d\n",
 			count, start, duration));
 		if (count != -1)
@@ -1659,7 +2079,7 @@ wl_cfgp2p_get_p2p_noa(struct wl_priv *wl, struct net_device *ndev, char* buf, in
 			}
 			/* We have to convert the buffer data into ASCII strings */
 			for (i = 0; i < len; i++) {
-				sprintf(buf, "%02x", _buf[i]);
+				snprintf(buf, 3, "%02x", _buf[i]);
 				buf += 2;
 			}
 			buf[i*2] = '\0';
@@ -1680,7 +2100,7 @@ wl_cfgp2p_set_p2p_ps(struct wl_priv *wl, struct net_device *ndev, char* buf, int
 
 	CFGP2P_DBG((" Enter\n"));
 	if (wl->p2p && wl->p2p->vif_created) {
-		sscanf(buf, "%d %d %d", &legacy_ps, &ps, &ctw);
+		sscanf(buf, "%10d %10d %10d", &legacy_ps, &ps, &ctw);
 		CFGP2P_DBG((" Enter legacy_ps %d ps %d ctw %d\n", legacy_ps, ps, ctw));
 		if (ctw != -1) {
 			wl->p2p->ops.ctw = ctw;
@@ -1697,10 +2117,17 @@ wl_cfgp2p_set_p2p_ps(struct wl_priv *wl, struct net_device *ndev, char* buf, int
 		}
 
 		if ((legacy_ps != -1) && ((legacy_ps == PM_MAX) || (legacy_ps == PM_OFF))) {
+#if defined(SUPPORT_PM2_ONLY)
+			if (legacy_ps == PM_MAX)
+				legacy_ps = PM_FAST;
+#endif /* SUPPORT_PM2_ONLY */
+
 			ret = wldev_ioctl(wl_to_p2p_bss_ndev(wl, P2PAPI_BSSCFG_CONNECTION),
 				WLC_SET_PM, &legacy_ps, sizeof(legacy_ps), true);
 			if (unlikely(ret)) {
 				CFGP2P_ERR(("error (%d)\n", ret));
+			} else {
+				wl_cfg80211_update_power_mode(ndev);
 			}
 		}
 		else
@@ -1765,20 +2192,48 @@ wl_cfgp2p_retreive_p2pattrib(void *buf, u8 element_id)
 }
 
 #define P2P_GROUP_CAPAB_GO_BIT	0x01
+
+u8*
+wl_cfgp2p_find_attrib_in_all_p2p_Ies(u8 *parse, u32 len, u32 attrib)
+{
+	bcm_tlv_t *ie;
+	u8* pAttrib;
+
+	CFGP2P_INFO(("Starting parsing parse %p attrib %d remaining len %d ", parse, attrib, len));
+	while ((ie = bcm_parse_tlvs(parse, (int)len, DOT11_MNG_VS_ID))) {
+		if (wl_cfgp2p_is_p2p_ie((uint8*)ie, &parse, &len) == TRUE) {
+			/* Have the P2p ie. Now check for attribute */
+			if ((pAttrib = wl_cfgp2p_retreive_p2pattrib(parse, attrib)) != NULL) {
+				CFGP2P_INFO(("P2P attribute %d was found at parse %p",
+					attrib, parse));
+				return pAttrib;
+			}
+			else {
+				parse += (ie->len + TLV_HDR_LEN);
+				len -= (ie->len + TLV_HDR_LEN);
+				CFGP2P_INFO(("P2P Attribute %d not found Moving parse"
+					" to %p len to %d", attrib, parse, len));
+			}
+		}
+		else {
+			/* It was not p2p IE. parse will get updated automatically to next TLV */
+			CFGP2P_INFO(("IT was NOT P2P IE parse %p len %d", parse, len));
+		}
+	}
+	CFGP2P_ERR(("P2P attribute %d was NOT found", attrib));
+	return NULL;
+}
+
 u8 *
 wl_cfgp2p_retreive_p2p_dev_addr(wl_bss_info_t *bi, u32 bi_length)
 {
-	wifi_p2p_ie_t * p2p_ie = NULL;
+	//wifi_p2p_ie_t * p2p_ie = NULL;
 	u8 *capability = NULL;
 	bool p2p_go	= 0;
 	u8 *ptr = NULL;
 
-	if (!(p2p_ie = wl_cfgp2p_find_p2pie(((u8 *) bi) + bi->ie_offset, bi->ie_length))) {
-		WL_ERR(("P2P IE not found"));
-		return NULL;
-	}
-
-	if (!(capability = wl_cfgp2p_retreive_p2pattrib(p2p_ie, P2P_SEID_P2P_INFO))) {
+	if ((capability = wl_cfgp2p_find_attrib_in_all_p2p_Ies(((u8 *) bi) + bi->ie_offset,
+	bi->ie_length, P2P_SEID_P2P_INFO)) == NULL) {
 		WL_ERR(("P2P Capability attribute not found"));
 		return NULL;
 	}
@@ -1790,11 +2245,15 @@ wl_cfgp2p_retreive_p2p_dev_addr(wl_bss_info_t *bi, u32 bi_length)
 	}
 
 	/* In probe responses, DEVICE INFO attribute will be present */
-	if (!(ptr = wl_cfgp2p_retreive_p2pattrib(p2p_ie, P2P_SEID_DEV_INFO))) {
+	//if (!(ptr = wl_cfgp2p_retreive_p2pattrib(p2p_ie, P2P_SEID_DEV_INFO))) {
+	if (!(ptr = wl_cfgp2p_find_attrib_in_all_p2p_Ies(((u8 *) bi) + bi->ie_offset,
+		bi->ie_length,  P2P_SEID_DEV_INFO))) {
 		/* If DEVICE_INFO is not found, this might be a beacon frame.
 		 * check for DEVICE_ID in the beacon frame.
 		 */
-		ptr = wl_cfgp2p_retreive_p2pattrib(p2p_ie, P2P_SEID_DEV_ID);
+		//ptr = wl_cfgp2p_retreive_p2pattrib(p2p_ie, P2P_SEID_DEV_ID);
+		ptr = wl_cfgp2p_find_attrib_in_all_p2p_Ies(((u8 *) bi) + bi->ie_offset,
+			bi->ie_length,	P2P_SEID_DEV_ID);
 	}
 
 	if (!ptr)
@@ -1803,25 +2262,50 @@ wl_cfgp2p_retreive_p2p_dev_addr(wl_bss_info_t *bi, u32 bi_length)
 	return ptr;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
+static void
+wl_cfgp2p_ethtool_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info)
+{
+	snprintf(info->driver, sizeof(info->driver), "p2p");
+	snprintf(info->version, sizeof(info->version), "%lu", (unsigned long)(0));
+}
+
+struct ethtool_ops cfgp2p_ethtool_ops = {
+	.get_drvinfo = wl_cfgp2p_ethtool_get_drvinfo
+};
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24) */
+
 s32
 wl_cfgp2p_register_ndev(struct wl_priv *wl)
 {
 	int ret = 0;
 	struct net_device* net = NULL;
-	struct wireless_dev *wdev;
+	struct wireless_dev *wdev = NULL;
 	uint8 temp_addr[ETHER_ADDR_LEN] = { 0x00, 0x90, 0x4c, 0x33, 0x22, 0x11 };
 
+	if (wl->p2p_net) {
+		CFGP2P_ERR(("p2p_net defined already.\n"));
+		return -EINVAL;
+	}
+
 	/* Allocate etherdev, including space for private structure */
-	if (!(net = alloc_etherdev(sizeof(wl)))) {
+	if (!(net = alloc_etherdev(sizeof(struct wl_priv *)))) {
 		CFGP2P_ERR(("%s: OOM - alloc_etherdev\n", __FUNCTION__));
-		goto fail;
+		return -ENODEV;
 	}
 
-	strcpy(net->name, "p2p%d");
+	wdev = kzalloc(sizeof(*wdev), GFP_KERNEL);
+	if (unlikely(!wdev)) {
+		WL_ERR(("Could not allocate wireless device\n"));
+		free_netdev(net);
+		return -ENOMEM;
+	}
+
+	strncpy(net->name, "p2p%d", sizeof(net->name) - 1);
 	net->name[IFNAMSIZ - 1] = '\0';
 
 	/* Copy the reference to wl_priv */
-	memcpy((void *)netdev_priv(net), &wl, sizeof(wl));
+	memcpy((void *)netdev_priv(net), &wl, sizeof(struct wl_priv *));
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31))
 	ASSERT(!net->open);
@@ -1837,57 +2321,38 @@ wl_cfgp2p_register_ndev(struct wl_priv *wl)
 	/* Register with a dummy MAC addr */
 	memcpy(net->dev_addr, temp_addr, ETHER_ADDR_LEN);
 
-	wdev = kzalloc(sizeof(*wdev), GFP_KERNEL);
-	if (unlikely(!wdev)) {
-		WL_ERR(("Could not allocate wireless device\n"));
-		return -ENOMEM;
-	}
-
 	wdev->wiphy = wl->wdev->wiphy;
 
 	wdev->iftype = wl_mode_to_nl80211_iftype(WL_MODE_BSS);
 
 	net->ieee80211_ptr = wdev;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
+	net->ethtool_ops = &cfgp2p_ethtool_ops;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24) */
+
 	SET_NETDEV_DEV(net, wiphy_dev(wdev->wiphy));
 
 	/* Associate p2p0 network interface with new wdev */
 	wdev->netdev = net;
 
-	/* store p2p net ptr for further reference. Note that iflist won't have this
-	 * entry as there corresponding firmware interface is a "Hidden" interface.
-	 */
-	if (wl->p2p_net) {
-		CFGP2P_ERR(("p2p_net defined already.\n"));
-		return -EINVAL;
-	} else {
-		wl->p2p_wdev = wdev;
-		wl->p2p_net = net;
-	}
-
 	ret = register_netdev(net);
 	if (ret) {
 		CFGP2P_ERR((" register_netdevice failed (%d)\n", ret));
-		goto fail;
+		free_netdev(net);
+		kfree(wdev);
+		return -ENODEV;
 	}
 
+	/* store p2p net ptr for further reference. Note that iflist won't have this
+	 * entry as there corresponding firmware interface is a "Hidden" interface.
+	 */
+	wl->p2p_wdev = wdev;
+	wl->p2p_net = net;
+
 	printk("%s: P2P Interface Registered\n", net->name);
 
 	return ret;
-fail:
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31)
-	net->open = NULL;
-#else
-	net->netdev_ops = NULL;
-#endif
-
-	if (net) {
-		unregister_netdev(net);
-		free_netdev(net);
-	}
-
-	return -ENODEV;
 }
 
 s32
@@ -1906,7 +2371,14 @@ wl_cfgp2p_unregister_ndev(struct wl_priv *wl)
 }
 static int wl_cfgp2p_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 {
-	CFGP2P_DBG(("(%s) is not used for data operations. Droping the packet. \n", ndev->name));
+
+	if (skb)
+	{
+		CFGP2P_DBG(("(%s) is not used for data operations.Droping the packet.\n",
+			ndev->name));
+		dev_kfree_skb_any(skb);
+	}
+
 	return 0;
 }
 
@@ -1934,34 +2406,60 @@ static int wl_cfgp2p_do_ioctl(struct net_device *net, struct ifreq *ifr, int cmd
 
 static int wl_cfgp2p_if_open(struct net_device *net)
 {
+	extern struct wl_priv *wlcfg_drv_priv;
 	struct wireless_dev *wdev = net->ieee80211_ptr;
-
-	if (!wdev)
+	struct wl_priv *wl = NULL;
+	wl = wlcfg_drv_priv;
+	if (!wdev || !wl || !wl->p2p)
 		return -EINVAL;
-
+	WL_TRACE(("Enter\n"));
+#if !defined(WL_IFACE_COMB_NUM_CHANNELS)
 	/* If suppose F/W download (ifconfig wlan0 up) hasn't been done by now,
 	 * do it here. This will make sure that in concurrent mode, supplicant
 	 * is not dependent on a particular order of interface initialization.
 	 * i.e you may give wpa_supp -iwlan0 -N -ip2p0 or wpa_supp -ip2p0 -N
 	 * -iwlan0.
 	 */
-	wl_cfg80211_do_driver_init(net);
-
 	wdev->wiphy->interface_modes |= (BIT(NL80211_IFTYPE_P2P_CLIENT)
 		| BIT(NL80211_IFTYPE_P2P_GO));
+#endif/*!WL_IFACE_COMB_NUM_CHANNELS*/
+	wl_cfg80211_do_driver_init(net);
 
 	return 0;
 }
 
 static int wl_cfgp2p_if_stop(struct net_device *net)
 {
+	extern struct wl_priv *wlcfg_drv_priv;
+	struct wl_priv *wl = NULL;
+	unsigned long flags;
 	struct wireless_dev *wdev = net->ieee80211_ptr;
-
+	int clear_flag = 0;
 	if (!wdev)
 		return -EINVAL;
 
+	WL_TRACE(("Enter\n"));
+	wl = wlcfg_drv_priv;
+	if (!wl)
+		return -EINVAL;
+	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
+	if (wl->scan_request && wl->scan_request->dev == net) {
+		cfg80211_scan_done(wl->scan_request, true);
+		wl->scan_request = NULL;
+		clear_flag = 1;
+	}
+	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
+	if (clear_flag)
+		wl_clr_drv_status(wl, SCANNING, net);
+#if !defined(WL_IFACE_COMB_NUM_CHANNELS)
 	wdev->wiphy->interface_modes = (wdev->wiphy->interface_modes)
 					& (~(BIT(NL80211_IFTYPE_P2P_CLIENT)|
 					BIT(NL80211_IFTYPE_P2P_GO)));
+#endif/*!WL_IFACE_COMB_NUM_CHANNELS*/
 	return 0;
 }
+
+bool wl_cfgp2p_is_ifops(const struct net_device_ops *if_ops)
+{
+	return (if_ops == &wl_cfgp2p_if_ops);
+}
diff --git a/drivers/net/wireless/bcmdhd/wl_cfgp2p.h b/drivers/net/wireless/bcmdhd/wl_cfgp2p.h
old mode 100644
new mode 100755
index 427cb4a..ddb234b
--- a/drivers/net/wireless/bcmdhd/wl_cfgp2p.h
+++ b/drivers/net/wireless/bcmdhd/wl_cfgp2p.h
@@ -1,27 +1,9 @@
 /*
  * Linux cfgp2p driver
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: wl_cfgp2p.h 316197 2012-02-21 13:16:39Z $
+ * $Id: wl_cfgp2p.h 386595 2013-02-21 07:03:27Z $
  */
 #ifndef _wl_cfgp2p_h_
 #define _wl_cfgp2p_h_
@@ -43,14 +25,18 @@ typedef enum {
 	P2PAPI_BSSCFG_MAX
 } p2p_bsscfg_type_t;
 
-#define IE_MAX_LEN 300
+/* vendor ies max buffer length for probe response or beacon */
+#define VNDR_IES_MAX_BUF_LEN	1400
+/* normal vendor ies buffer length */
+#define VNDR_IES_BUF_LEN 		512
+
 /* Structure to hold all saved P2P and WPS IEs for a BSSCFG */
 struct p2p_saved_ie {
-	u8  p2p_probe_req_ie[IE_MAX_LEN];
-	u8  p2p_probe_res_ie[IE_MAX_LEN];
-	u8  p2p_assoc_req_ie[IE_MAX_LEN];
-	u8  p2p_assoc_res_ie[IE_MAX_LEN];
-	u8  p2p_beacon_ie[IE_MAX_LEN];
+	u8  p2p_probe_req_ie[VNDR_IES_BUF_LEN];
+	u8  p2p_probe_res_ie[VNDR_IES_MAX_BUF_LEN];
+	u8  p2p_assoc_req_ie[VNDR_IES_BUF_LEN];
+	u8  p2p_assoc_res_ie[VNDR_IES_BUF_LEN];
+	u8  p2p_beacon_ie[VNDR_IES_MAX_BUF_LEN];
 	u32 p2p_probe_req_ie_len;
 	u32 p2p_probe_res_ie_len;
 	u32 p2p_assoc_req_ie_len;
@@ -68,17 +54,31 @@ struct p2p_bss {
 struct p2p_info {
 	bool on;    /* p2p on/off switch */
 	bool scan;
+	int16 search_state;
+
 	bool vif_created;
 	s8 vir_ifname[IFNAMSIZ];
 	unsigned long status;
 	struct ether_addr dev_addr;
 	struct ether_addr int_addr;
-	struct p2p_bss bss_idx[P2PAPI_BSSCFG_MAX];
+	struct p2p_bss bss[P2PAPI_BSSCFG_MAX];
 	struct timer_list listen_timer;
 	wl_p2p_sched_t noa;
 	wl_p2p_ops_t ops;
 	wlc_ssid_t ssid;
-	spinlock_t timer_lock;
+};
+
+#define MAX_VNDR_IE_NUMBER	5
+
+struct parsed_vndr_ie_info {
+	char *ie_ptr;
+	u32 ie_len;	/* total length including id & length field */
+	vndr_ie_t vndrie;
+};
+
+struct parsed_vndr_ies {
+	u32 count;
+	struct parsed_vndr_ie_info ie_info[MAX_VNDR_IE_NUMBER];
 };
 
 /* dongle status */
@@ -93,15 +93,17 @@ enum wl_cfgp2p_status {
 	WLP2P_STATUS_LISTEN_EXPIRED,
 	WLP2P_STATUS_ACTION_TX_COMPLETED,
 	WLP2P_STATUS_ACTION_TX_NOACK,
-	WLP2P_STATUS_SCANNING
+	WLP2P_STATUS_SCANNING,
+	WLP2P_STATUS_GO_NEG_PHASE,
+	WLP2P_STATUS_DISC_IN_PROGRESS
 };
 
 
-#define wl_to_p2p_bss_ndev(w, type) 	((wl)->p2p->bss_idx[type].dev)
-#define wl_to_p2p_bss_bssidx(w, type) 	((wl)->p2p->bss_idx[type].bssidx)
-#define wl_to_p2p_bss_saved_ie(w, type) 	((wl)->p2p->bss_idx[type].saved_ie)
-#define wl_to_p2p_bss_private(w, type) 	((wl)->p2p->bss_idx[type].private_data)
-#define wl_to_p2p_bss(wl, type) ((wl)->p2p->bss_idx[type])
+#define wl_to_p2p_bss_ndev(wl, type)		((wl)->p2p->bss[type].dev)
+#define wl_to_p2p_bss_bssidx(wl, type)		((wl)->p2p->bss[type].bssidx)
+#define wl_to_p2p_bss_saved_ie(wl, type)	((wl)->p2p->bss[type].saved_ie)
+#define wl_to_p2p_bss_private(wl, type)		((wl)->p2p->bss[type].private_data)
+#define wl_to_p2p_bss(wl, type)			((wl)->p2p->bss[type])
 #define wl_get_p2p_status(wl, stat) ((!(wl)->p2p_supported) ? 0 : test_bit(WLP2P_STATUS_ ## stat, \
 									&(wl)->p2p->status))
 #define wl_set_p2p_status(wl, stat) ((!(wl)->p2p_supported) ? 0 : set_bit(WLP2P_STATUS_ ## stat, \
@@ -116,31 +118,49 @@ enum wl_cfgp2p_status {
 
 /* dword align allocation */
 #define WLC_IOCTL_MAXLEN 8192
-#define MAC2STR(a) (a)[0], (a)[1], (a)[2], (a)[3], (a)[4], (a)[5]
-#define MACSTR "%02x:%02x:%02x:%02x:%02x:%02x"
+
+#define CFGP2P_ERROR_TEXT		"CFGP2P-ERROR) "
+
 
 #define CFGP2P_ERR(args)									\
 	do {										\
 		if (wl_dbg_level & WL_DBG_ERR) {				\
-			printk(KERN_ERR "CFGP2P-ERROR) %s : ", __func__);	\
+			printk(KERN_INFO CFGP2P_ERROR_TEXT "%s : ", __func__);	\
 			printk args;						\
 		}									\
 	} while (0)
 #define	CFGP2P_INFO(args)									\
 	do {										\
 		if (wl_dbg_level & WL_DBG_INFO) {				\
-			printk(KERN_ERR "CFGP2P-INFO) %s : ", __func__);	\
+			printk(KERN_INFO "CFGP2P-INFO) %s : ", __func__);	\
 			printk args;						\
 		}									\
 	} while (0)
 #define	CFGP2P_DBG(args)								\
 	do {									\
 		if (wl_dbg_level & WL_DBG_DBG) {			\
-			printk(KERN_ERR "CFGP2P-DEBUG) %s :", __func__);	\
+			printk(KERN_DEBUG "CFGP2P-DEBUG) %s :", __func__);	\
 			printk args;							\
 		}									\
 	} while (0)
 
+#define	CFGP2P_ACTION(args)								\
+	do {									\
+		if (wl_dbg_level & WL_DBG_P2P_ACTION) {			\
+			printk(KERN_DEBUG "CFGP2P-ACTION) %s :", __func__);	\
+			printk args;							\
+		}									\
+	} while (0)
+#define INIT_TIMER(timer, func, duration, extra_delay)	\
+	do {				   \
+		init_timer(timer); \
+		timer->function = func; \
+		timer->expires = jiffies + msecs_to_jiffies(duration + extra_delay); \
+		timer->data = (unsigned long) wl; \
+		add_timer(timer); \
+	} while (0);
+extern void
+wl_cfgp2p_listen_expired(unsigned long data);
 extern bool
 wl_cfgp2p_is_pub_action(void *frame, u32 frame_len);
 extern bool
@@ -148,7 +168,7 @@ wl_cfgp2p_is_p2p_action(void *frame, u32 frame_len);
 extern bool
 wl_cfgp2p_is_gas_action(void *frame, u32 frame_len);
 extern void
-wl_cfgp2p_print_actframe(bool tx, void *frame, u32 frame_len);
+wl_cfgp2p_print_actframe(bool tx, void *frame, u32 frame_len, u32 channel);
 extern s32
 wl_cfgp2p_init_priv(struct wl_priv *wl);
 extern void
@@ -162,6 +182,8 @@ extern s32
 wl_cfgp2p_ifadd(struct wl_priv *wl, struct ether_addr *mac, u8 if_type,
             chanspec_t chspec);
 extern s32
+wl_cfgp2p_ifdisable(struct wl_priv *wl, struct ether_addr *mac);
+extern s32
 wl_cfgp2p_ifdel(struct wl_priv *wl, struct ether_addr *mac);
 extern s32
 wl_cfgp2p_ifchange(struct wl_priv *wl, struct ether_addr *mac, u8 if_type, chanspec_t chspec);
@@ -178,11 +200,11 @@ wl_cfgp2p_disable_discovery(struct wl_priv *wl);
 extern s32
 wl_cfgp2p_escan(struct wl_priv *wl, struct net_device *dev, u16 active, u32 num_chans,
 	u16 *channels,
-	s32 search_state, u16 action, u32 bssidx);
+	s32 search_state, u16 action, u32 bssidx, struct ether_addr *tx_dst_addr);
 
 extern s32
 wl_cfgp2p_act_frm_search(struct wl_priv *wl, struct net_device *ndev,
-	s32 bssidx, s32 channel);
+	s32 bssidx, s32 channel, struct ether_addr *tx_dst_addr);
 
 extern wpa_ie_fixed_t *
 wl_cfgp2p_find_wpaie(u8 *parse, u32 len);
@@ -202,7 +224,11 @@ extern s32
 wl_cfgp2p_clear_management_ie(struct wl_priv *wl, s32 bssidx);
 
 extern s32
-wl_cfgp2p_find_idx(struct wl_priv *wl, struct net_device *ndev);
+wl_cfgp2p_find_idx(struct wl_priv *wl, struct net_device *ndev, s32 *index);
+extern struct net_device *
+wl_cfgp2p_find_ndev(struct wl_priv *wl, s32 bssidx);
+extern s32
+wl_cfgp2p_find_type(struct wl_priv *wl, s32 bssidx, s32 *type);
 
 
 extern s32
@@ -252,6 +278,9 @@ wl_cfgp2p_set_p2p_ps(struct wl_priv *wl, struct net_device *ndev, char* buf, int
 extern u8 *
 wl_cfgp2p_retreive_p2pattrib(void *buf, u8 element_id);
 
+extern u8*
+wl_cfgp2p_find_attrib_in_all_p2p_Ies(u8 *parse, u32 len, u32 attrib);
+
 extern u8 *
 wl_cfgp2p_retreive_p2p_dev_addr(wl_bss_info_t *bi, u32 bi_length);
 
@@ -261,24 +290,39 @@ wl_cfgp2p_register_ndev(struct wl_priv *wl);
 extern s32
 wl_cfgp2p_unregister_ndev(struct wl_priv *wl);
 
+extern bool
+wl_cfgp2p_is_ifops(const struct net_device_ops *if_ops);
+
 /* WiFi Direct */
 #define SOCIAL_CHAN_1 1
 #define SOCIAL_CHAN_2 6
 #define SOCIAL_CHAN_3 11
+#define IS_P2P_SOCIAL_CHANNEL(channel) ((channel == SOCIAL_CHAN_1) || \
+					(channel == SOCIAL_CHAN_2) || \
+					(channel == SOCIAL_CHAN_3))
 #define SOCIAL_CHAN_CNT 3
+#define AF_PEER_SEARCH_CNT 2
 #define WL_P2P_WILDCARD_SSID "DIRECT-"
 #define WL_P2P_WILDCARD_SSID_LEN 7
 #define WL_P2P_INTERFACE_PREFIX "p2p"
 #define WL_P2P_TEMP_CHAN 11
 
+/* If the provision discovery is for JOIN operations,
+ * or the device discoverablity frame is destined to GO
+ * then we need not do an internal scan to find GO.
+ */
+#define IS_ACTPUB_WITHOUT_GROUP_ID(p2p_ie, len) \
+	(wl_cfgp2p_retreive_p2pattrib(p2p_ie, P2P_SEID_GROUP_ID) == NULL)
 
 #define IS_GAS_REQ(frame, len) (wl_cfgp2p_is_gas_action(frame, len) && \
 					((frame->action == P2PSD_ACTION_ID_GAS_IREQ) || \
 					(frame->action == P2PSD_ACTION_ID_GAS_CREQ)))
-#define IS_P2P_PUB_ACT_REQ(frame, len) (wl_cfgp2p_is_pub_action(frame, len) && \
-						((frame->subtype == P2P_PAF_GON_REQ) || \
-						(frame->subtype == P2P_PAF_INVITE_REQ) || \
-						(frame->subtype == P2P_PAF_PROVDIS_REQ)))
+
+#define IS_P2P_PUB_ACT_RSP_SUBTYPE(subtype) ((subtype == P2P_PAF_GON_RSP) || \
+							((subtype == P2P_PAF_GON_CONF) || \
+							(subtype == P2P_PAF_INVITE_RSP) || \
+							(subtype == P2P_PAF_PROVDIS_RSP)))
 #define IS_P2P_SOCIAL(ch) ((ch == SOCIAL_CHAN_1) || (ch == SOCIAL_CHAN_2) || (ch == SOCIAL_CHAN_3))
-#define IS_P2P_SSID(ssid) (memcmp(ssid, WL_P2P_WILDCARD_SSID, WL_P2P_WILDCARD_SSID_LEN) == 0)
+#define IS_P2P_SSID(ssid, len) (!memcmp(ssid, WL_P2P_WILDCARD_SSID, WL_P2P_WILDCARD_SSID_LEN) && \
+					(len == WL_P2P_WILDCARD_SSID_LEN))
 #endif				/* _wl_cfgp2p_h_ */
diff --git a/drivers/net/wireless/bcmdhd/wl_dbg.h b/drivers/net/wireless/bcmdhd/wl_dbg.h
old mode 100644
new mode 100755
index b5e7080..9dace14
--- a/drivers/net/wireless/bcmdhd/wl_dbg.h
+++ b/drivers/net/wireless/bcmdhd/wl_dbg.h
@@ -2,27 +2,9 @@
  * Minimal debug/trace/assert driver definitions for
  * Broadcom 802.11 Networking Adapter.
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: wl_dbg.h 326635 2012-04-10 03:15:29Z $
+ * $Id: wl_dbg.h 376019 2012-12-21 01:00:06Z $
  */
 
 
diff --git a/drivers/net/wireless/bcmdhd/wl_iw.c b/drivers/net/wireless/bcmdhd/wl_iw.c
old mode 100644
new mode 100755
index be08025..4eca121
--- a/drivers/net/wireless/bcmdhd/wl_iw.c
+++ b/drivers/net/wireless/bcmdhd/wl_iw.c
@@ -1,27 +1,9 @@
 /*
  * Linux Wireless Extensions support
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
- * $Id: wl_iw.c 312290 2012-02-02 02:52:18Z $
+ * $Id: wl_iw.c 393481 2013-03-27 20:43:17Z $
  */
 
 #if defined(USE_IW)
@@ -38,7 +20,6 @@
 #include <linux/if_arp.h>
 #include <asm/uaccess.h>
 
-
 typedef const struct si_pub	si_t;
 #include <wlioctl.h>
 
@@ -73,6 +54,29 @@ typedef const struct si_pub	si_t;
 #endif
 #endif 
 
+
+#ifndef IW_AUTH_KEY_MGMT_FT_802_1X
+#define IW_AUTH_KEY_MGMT_FT_802_1X 0x04
+#endif
+
+#ifndef IW_AUTH_KEY_MGMT_FT_PSK
+#define IW_AUTH_KEY_MGMT_FT_PSK 0x08
+#endif
+
+#ifndef IW_ENC_CAPA_FW_ROAM_ENABLE
+#define IW_ENC_CAPA_FW_ROAM_ENABLE	0x00000020
+#endif
+
+
+
+#ifndef IW_ENCODE_ALG_PMK
+#define IW_ENCODE_ALG_PMK 4
+#endif
+#ifndef IW_ENC_CAPA_4WAY_HANDSHAKE
+#define IW_ENC_CAPA_4WAY_HANDSHAKE 0x00000010
+#endif
+
+
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
 #include <linux/rtnetlink.h>
 #endif
@@ -260,6 +264,7 @@ dev_iw_iovar_setbuf(
 
 	iolen = bcm_mkiovar(iovar, param, paramlen, bufptr, buflen);
 	ASSERT(iolen);
+	BCM_REFERENCE(iolen);
 
 	return (dev_wlc_ioctl(dev, WLC_SET_VAR, bufptr, iolen));
 }
@@ -418,6 +423,9 @@ wl_iw_set_pm(
 	error = dev_wlc_ioctl(dev, WLC_SET_PM, &pm, sizeof(pm));
 	return error;
 }
+
+#if WIRELESS_EXT > 17
+#endif 
 #endif 
 
 int
@@ -668,6 +676,7 @@ wl_iw_get_range(
 		{14, 29, 43, 58, 87, 116, 130, 144},
 		{27, 54, 81, 108, 162, 216, 243, 270},
 		{30, 60, 90, 120, 180, 240, 270, 300}};
+	int fbt_cap = 0;
 
 	WL_TRACE(("%s: SIOCGIWRANGE\n", dev->name));
 
@@ -723,15 +732,18 @@ wl_iw_get_range(
 	range->num_bitrates = rateset.count;
 	for (i = 0; i < rateset.count && i < IW_MAX_BITRATES; i++)
 		range->bitrate[i] = (rateset.rates[i] & 0x7f) * 500000; 
-	dev_wlc_intvar_get(dev, "nmode", &nmode);
+	if ((error = dev_wlc_intvar_get(dev, "nmode", &nmode)))
+		return error;
 	if ((error = dev_wlc_ioctl(dev, WLC_GET_PHYTYPE, &phytype, sizeof(phytype))))
 		return error;
-
 	if (nmode == 1 && ((phytype == WLC_PHY_TYPE_SSN) || (phytype == WLC_PHY_TYPE_LCN) ||
 		(phytype == WLC_PHY_TYPE_LCN40))) {
-		dev_wlc_intvar_get(dev, "mimo_bw_cap", &bw_cap);
-		dev_wlc_intvar_get(dev, "sgi_tx", &sgi_tx);
-		dev_wlc_ioctl(dev, WLC_GET_CHANNEL, &ci, sizeof(channel_info_t));
+		if ((error = dev_wlc_intvar_get(dev, "mimo_bw_cap", &bw_cap)))
+			return error;
+		if ((error = dev_wlc_intvar_get(dev, "sgi_tx", &sgi_tx)))
+			return error;
+		if ((error = dev_wlc_ioctl(dev, WLC_GET_CHANNEL, &ci, sizeof(channel_info_t))))
+			return error;
 		ci.hw_channel = dtoh32(ci.hw_channel);
 
 		if (bw_cap == 0 ||
@@ -749,6 +761,7 @@ wl_iw_get_range(
 				nrate_list2copy = 3;
 		}
 		range->num_bitrates += 8;
+		ASSERT(range->num_bitrates < IW_MAX_BITRATES);
 		for (k = 0; i < range->num_bitrates; k++, i++) {
 			
 			range->bitrate[i] = (nrate_list[nrate_list2copy][k]) * 500000;
@@ -816,9 +829,18 @@ wl_iw_get_range(
 	range->enc_capa |= IW_ENC_CAPA_CIPHER_TKIP;
 	range->enc_capa |= IW_ENC_CAPA_CIPHER_CCMP;
 	range->enc_capa |= IW_ENC_CAPA_WPA2;
-#if (defined(BCMSUP_PSK) && defined(WLFBT))
+
 	
-	range->enc_capa |= IW_ENC_CAPA_4WAY_HANDSHAKE;
+	if (dev_wlc_intvar_get(dev, "fbt_cap", &fbt_cap) == 0) {
+		if (fbt_cap == WLC_FBT_CAP_DRV_4WAY_AND_REASSOC) {
+			
+			range->enc_capa |= IW_ENC_CAPA_4WAY_HANDSHAKE;
+		}
+	}
+
+#ifdef BCMFW_ROAM_ENABLE_WEXT
+	
+	range->enc_capa |= IW_ENC_CAPA_FW_ROAM_ENABLE;
 #endif 
 
 	
@@ -1227,7 +1249,7 @@ wl_iw_iscan_set_scan(
 	wl_iw_set_event_mask(dev);
 	wl_iw_iscan(iscan, &ssid, WL_SCAN_ACTION_START);
 
-	iscan->timer.expires = jiffies + iscan->timer_ms*HZ/1000;
+	iscan->timer.expires = jiffies + msecs_to_jiffies(iscan->timer_ms);
 	add_timer(&iscan->timer);
 	iscan->timer_on = 1;
 
@@ -1336,14 +1358,12 @@ wl_iw_handle_scanresults_ies(char **event_p, char *end,
 		}
 		ptr = ((uint8 *)bi) + sizeof(wl_bss_info_t);
 
-#if defined(WLFBT)
 		if ((ie = bcm_parse_tlvs(ptr, ptr_len, DOT11_MNG_MDIE_ID))) {
 			iwe.cmd = IWEVGENIE;
 			iwe.u.data.length = ie->len + 2;
 			event = IWE_STREAM_ADD_POINT(info, event, end, &iwe, (char *)ie);
 		}
 		ptr = ((uint8 *)bi) + sizeof(wl_bss_info_t);
-#endif 
 
 		while ((ie = bcm_parse_tlvs(ptr, ptr_len, DOT11_MNG_WPA_ID))) {
 			
@@ -1393,6 +1413,7 @@ wl_iw_handle_scanresults_ies(char **event_p, char *end,
 			wpa_snprintf_hex(buf + 10, 2+1, &(ie->len), 1);
 			wpa_snprintf_hex(buf + 12, 2*ie->len+1, ie->data, ie->len);
 			event = IWE_STREAM_ADD_POINT(info, event, end, &iwe, buf);
+			kfree(buf);
 #endif 
 			break;
 		}
@@ -1625,7 +1646,7 @@ wl_iw_iscan_get_scan(
 		event = IWE_STREAM_ADD_POINT(info, event, end, &iwe, (char *)event);
 
 		
-		if (bi->rateset.count) {
+		if (bi->rateset.count <= sizeof(bi->rateset.rates)) {
 			if (event + IW_MAX_BITRATES*IW_EV_PARAM_LEN >= end)
 				return -E2BIG;
 
@@ -2387,7 +2408,6 @@ wl_iw_set_encodeext(
 				return error;
 		}
 	}
-#if (defined(BCMSUP_PSK) && defined(WLFBT))
 	
 	else if (iwe->alg == IW_ENCODE_ALG_PMK) {
 		int j;
@@ -2410,7 +2430,6 @@ wl_iw_set_encodeext(
 		if (error)
 			return error;
 	}
-#endif 
 
 	else {
 		if (iwe->key_len > sizeof(key.data))
@@ -2624,7 +2643,8 @@ wl_iw_set_wpaauth(
 		break;
 
 	case IW_AUTH_CIPHER_PAIRWISE:
-	case IW_AUTH_CIPHER_GROUP:
+	case IW_AUTH_CIPHER_GROUP: {
+		int fbt_cap = 0;
 
 		if (paramid == IW_AUTH_CIPHER_PAIRWISE) {
 			iw->pwsec = paramval;
@@ -2666,33 +2686,42 @@ wl_iw_set_wpaauth(
 
 		if ((error = dev_wlc_intvar_set(dev, "wsec", val)))
 			return error;
-#ifdef WLFBT
-		if ((paramid == IW_AUTH_CIPHER_PAIRWISE) && (val | AES_ENABLED)) {
-			if ((error = dev_wlc_intvar_set(dev, "sup_wpa", 1)))
-				return error;
-		}
-		else if (val == 0) {
-			if ((error = dev_wlc_intvar_set(dev, "sup_wpa", 0)))
-				return error;
+
+		
+		if (dev_wlc_intvar_get(dev, "fbt_cap", &fbt_cap) == 0) {
+			if (fbt_cap == WLC_FBT_CAP_DRV_4WAY_AND_REASSOC) {
+				if ((paramid == IW_AUTH_CIPHER_PAIRWISE) && (val & AES_ENABLED)) {
+					if ((error = dev_wlc_intvar_set(dev, "sup_wpa", 1)))
+						return error;
+				}
+				else if (val == 0) {
+					if ((error = dev_wlc_intvar_set(dev, "sup_wpa", 0)))
+						return error;
+				}
+			}
 		}
-#endif 
 		break;
+	}
 
 	case IW_AUTH_KEY_MGMT:
 		if ((error = dev_wlc_intvar_get(dev, "wpa_auth", &val)))
 			return error;
 
 		if (val & (WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED)) {
-			if (paramval & IW_AUTH_KEY_MGMT_PSK)
+			if (paramval & (IW_AUTH_KEY_MGMT_FT_PSK | IW_AUTH_KEY_MGMT_PSK))
 				val = WPA_AUTH_PSK;
 			else
 				val = WPA_AUTH_UNSPECIFIED;
+			if (paramval & (IW_AUTH_KEY_MGMT_FT_802_1X | IW_AUTH_KEY_MGMT_FT_PSK))
+				val |= WPA2_AUTH_FT;
 		}
 		else if (val & (WPA2_AUTH_PSK | WPA2_AUTH_UNSPECIFIED)) {
-			if (paramval & IW_AUTH_KEY_MGMT_PSK)
+			if (paramval & (IW_AUTH_KEY_MGMT_FT_PSK | IW_AUTH_KEY_MGMT_PSK))
 				val = WPA2_AUTH_PSK;
 			else
 				val = WPA2_AUTH_UNSPECIFIED;
+			if (paramval & (IW_AUTH_KEY_MGMT_FT_802_1X | IW_AUTH_KEY_MGMT_FT_PSK))
+				val |= WPA2_AUTH_FT;
 		}
 #ifdef BCMWAPI_WPI
 		if (paramval & (IW_AUTH_KEY_MGMT_WAPI_PSK | IW_AUTH_KEY_MGMT_WAPI_CERT))
@@ -2984,13 +3013,19 @@ static const iw_handler wl_iw_handler[] =
 enum {
 	WL_IW_SET_LEDDC = SIOCIWFIRSTPRIV,
 	WL_IW_SET_VLANMODE,
-	WL_IW_SET_PM
+	WL_IW_SET_PM,
+#if WIRELESS_EXT > 17
+#endif 
+	WL_IW_SET_LAST
 };
 
 static iw_handler wl_iw_priv_handler[] = {
 	wl_iw_set_leddc,
 	wl_iw_set_vlanmode,
-	wl_iw_set_pm
+	wl_iw_set_pm,
+#if WIRELESS_EXT > 17
+#endif 
+	NULL
 };
 
 static struct iw_priv_args wl_iw_priv_args[] = {
@@ -3011,7 +3046,10 @@ static struct iw_priv_args wl_iw_priv_args[] = {
 		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
 		0,
 		"set_pm"
-	}
+	},
+#if WIRELESS_EXT > 17
+#endif 
+	{ 0, 0, 0, { 0 } }
 };
 
 const struct iw_handler_def wl_iw_handler_def =
@@ -3610,11 +3648,11 @@ wl_iw_iscan_get(iscan_info_t *iscan)
 static void wl_iw_send_scan_complete(iscan_info_t *iscan)
 {
 	union iwreq_data wrqu;
-	char extra[IW_CUSTOM_MAX + 1];
 
 	memset(&wrqu, 0, sizeof(wrqu));
-	memset(extra, 0, sizeof(extra));
-	wireless_send_event(iscan->dev, SIOCGIWSCAN, &wrqu, extra);
+
+	
+	wireless_send_event(iscan->dev, SIOCGIWSCAN, &wrqu, NULL);
 }
 
 static int
@@ -3652,7 +3690,7 @@ _iscan_sysioc_thread(void *data)
 				rtnl_unlock();
 #endif
 				
-				iscan->timer.expires = jiffies + iscan->timer_ms*HZ/1000;
+				iscan->timer.expires = jiffies + msecs_to_jiffies(iscan->timer_ms);
 				add_timer(&iscan->timer);
 				iscan->timer_on = 1;
 				break;
@@ -3664,7 +3702,7 @@ _iscan_sysioc_thread(void *data)
 			case WL_SCAN_RESULTS_PENDING:
 				WL_TRACE(("iscanresults pending\n"));
 				
-				iscan->timer.expires = jiffies + iscan->timer_ms*HZ/1000;
+				iscan->timer.expires = jiffies + msecs_to_jiffies(iscan->timer_ms);
 				add_timer(&iscan->timer);
 				iscan->timer_on = 1;
 				break;
diff --git a/drivers/net/wireless/bcmdhd/wl_iw.h b/drivers/net/wireless/bcmdhd/wl_iw.h
old mode 100644
new mode 100755
index 2afb5a6..dd00123
--- a/drivers/net/wireless/bcmdhd/wl_iw.h
+++ b/drivers/net/wireless/bcmdhd/wl_iw.h
@@ -1,25 +1,7 @@
 /*
  * Linux Wireless Extensions support
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * $Id: wl_iw.h 291086 2011-10-21 01:17:24Z $
  */
diff --git a/drivers/net/wireless/bcmdhd/wl_linux_mon.c b/drivers/net/wireless/bcmdhd/wl_linux_mon.c
old mode 100644
new mode 100755
index af25863..f82238d
--- a/drivers/net/wireless/bcmdhd/wl_linux_mon.c
+++ b/drivers/net/wireless/bcmdhd/wl_linux_mon.c
@@ -1,25 +1,7 @@
 /*
  * Broadcom Dongle Host Driver (DHD), Linux monitor network interface
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * $Id: dhd_linux_mon.c 280623 2011-08-30 14:49:39Z $
  */
diff --git a/drivers/net/wireless/bcmdhd/wldev_common.c b/drivers/net/wireless/bcmdhd/wldev_common.c
old mode 100644
new mode 100755
index f83df79..702a139
--- a/drivers/net/wireless/bcmdhd/wldev_common.c
+++ b/drivers/net/wireless/bcmdhd/wldev_common.c
@@ -1,25 +1,7 @@
 /*
  * Common function shared by Linux WEXT, cfg80211 and p2p drivers
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * $Id: wldev_common.c,v 1.1.4.1.2.14 2011-02-09 01:40:07 $
  */
@@ -105,7 +87,11 @@ s32 wldev_iovar_setbuf(
 		mutex_lock(buf_sync);
 	}
 	iovar_len = wldev_mkiovar(iovar_name, param, paramlen, buf, buflen);
-	ret = wldev_ioctl(dev, WLC_SET_VAR, buf, iovar_len, TRUE);
+	if (iovar_len > 0)
+		ret = wldev_ioctl(dev, WLC_SET_VAR, buf, iovar_len, TRUE);
+	else
+		ret = BCME_BUFTOOSHORT;
+
 	if (buf_sync)
 		mutex_unlock(buf_sync);
 	return ret;
@@ -220,7 +206,12 @@ s32 wldev_iovar_setbuf_bsscfg(
 		mutex_lock(buf_sync);
 	}
 	iovar_len = wldev_mkiovar_bsscfg(iovar_name, param, paramlen, buf, buflen, bsscfg_idx);
-	ret = wldev_ioctl(dev, WLC_SET_VAR, buf, iovar_len, TRUE);
+	if (iovar_len > 0)
+		ret = wldev_ioctl(dev, WLC_SET_VAR, buf, iovar_len, TRUE);
+	else {
+		ret = BCME_BUFTOOSHORT;
+	}
+
 	if (buf_sync) {
 		mutex_unlock(buf_sync);
 	}
@@ -319,13 +310,15 @@ int wldev_set_band(
 	int error = -1;
 
 	if ((band == WLC_BAND_AUTO) || (band == WLC_BAND_5G) || (band == WLC_BAND_2G)) {
-		error = wldev_ioctl(dev, WLC_SET_BAND, &band, sizeof(band), 1);
+		error = wldev_ioctl(dev, WLC_SET_BAND, &band, sizeof(band), true);
+		if (!error)
+			dhd_bus_band_set(dev, band);
 	}
 	return error;
 }
 
 int wldev_set_country(
-	struct net_device *dev, char *country_code)
+	struct net_device *dev, char *country_code, bool notify, bool user_enforced)
 {
 	int error = -1;
 	wl_country_t cspec = {{0}, 0, {0}};
@@ -335,34 +328,40 @@ int wldev_set_country(
 	if (!country_code)
 		return error;
 
-	error = wldev_iovar_getbuf(dev, "country", &cspec, sizeof(cspec),
-		smbuf, sizeof(smbuf), NULL);
-	if (error < 0)
+	bzero(&scbval, sizeof(scb_val_t));
+	error = wldev_iovar_getbuf(dev, "country", NULL, 0, &cspec, sizeof(cspec), NULL);
+	if (error < 0) {
 		WLDEV_ERROR(("%s: get country failed = %d\n", __FUNCTION__, error));
+		return error;
+	}
 
 	if ((error < 0) ||
-	    (strncmp(country_code, smbuf, WLC_CNTRY_BUF_SZ) != 0)) {
-		bzero(&scbval, sizeof(scb_val_t));
-		error = wldev_ioctl(dev, WLC_DISASSOC, &scbval, sizeof(scb_val_t), 1);
+	    (strncmp(country_code, cspec.ccode, WLC_CNTRY_BUF_SZ) != 0)) {
+
+		if (user_enforced) {
+			bzero(&scbval, sizeof(scb_val_t));
+			error = wldev_ioctl(dev, WLC_DISASSOC, &scbval, sizeof(scb_val_t), true);
+			if (error < 0) {
+				WLDEV_ERROR(("%s: set country failed due to Disassoc error %d\n",
+					__FUNCTION__, error));
+				return error;
+			}
+		}
+
+		cspec.rev = -1;
+		memcpy(cspec.country_abbrev, country_code, WLC_CNTRY_BUF_SZ);
+		memcpy(cspec.ccode, country_code, WLC_CNTRY_BUF_SZ);
+		get_customized_country_code((char *)&cspec.country_abbrev, &cspec);
+		error = wldev_iovar_setbuf(dev, "country", &cspec, sizeof(cspec),
+			smbuf, sizeof(smbuf), NULL);
 		if (error < 0) {
-			WLDEV_ERROR(("%s: set country failed due to Disassoc error %d\n",
-				__FUNCTION__, error));
+			WLDEV_ERROR(("%s: set country for %s as %s rev %d failed\n",
+				__FUNCTION__, country_code, cspec.ccode, cspec.rev));
 			return error;
 		}
-	}
-	cspec.rev = -1;
-	memcpy(cspec.country_abbrev, country_code, WLC_CNTRY_BUF_SZ);
-	memcpy(cspec.ccode, country_code, WLC_CNTRY_BUF_SZ);
-	get_customized_country_code((char *)&cspec.country_abbrev, &cspec);
-	error = wldev_iovar_setbuf(dev, "country", &cspec, sizeof(cspec),
-		smbuf, sizeof(smbuf), NULL);
-	if (error < 0) {
-		WLDEV_ERROR(("%s: set country for %s as %s rev %d failed\n",
+		dhd_bus_country_set(dev, &cspec, notify);
+		WLDEV_ERROR(("%s: set country for %s as %s rev %d\n",
 			__FUNCTION__, country_code, cspec.ccode, cspec.rev));
-		return error;
 	}
-	dhd_bus_country_set(dev, &cspec);
-	WLDEV_ERROR(("%s: set country for %s as %s rev %d\n",
-		__FUNCTION__, country_code, cspec.ccode, cspec.rev));
 	return 0;
 }
diff --git a/drivers/net/wireless/bcmdhd/wldev_common.h b/drivers/net/wireless/bcmdhd/wldev_common.h
old mode 100644
new mode 100755
index 16a071f..298380f
--- a/drivers/net/wireless/bcmdhd/wldev_common.h
+++ b/drivers/net/wireless/bcmdhd/wldev_common.h
@@ -1,25 +1,7 @@
 /*
  * Common function shared by Linux WEXT, cfg80211 and p2p drivers
  *
- * Copyright (C) 1999-2012, Broadcom Corporation
- * 
- *      Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2 (the "GPL"),
- * available at http://www.broadcom.com/licenses/GPLv2.php, with the
- * following added to such license:
- * 
- *      As a special exception, the copyright holders of this software give you
- * permission to link this software with independent modules, and to copy and
- * distribute the resulting executable under terms of your choice, provided that
- * you also meet, for each linked independent module, the terms and conditions of
- * the license of that module.  An independent module is a module which is not
- * derived from this software.  The special exception does not apply to any
- * modifications of the software.
- * 
- *      Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a license
- * other than the GPL, without Broadcom's express prior written consent.
+ * $Copyright Open Broadcom Corporation$
  *
  * $Id: wldev_common.h,v 1.1.4.1.2.14 2011-02-09 01:40:07 $
  */
@@ -84,15 +66,17 @@ s32 wldev_iovar_setint_bsscfg(
 	struct net_device *dev, s8 *iovar, s32 val, s32 bssidx);
 
 extern void get_customized_country_code(char *country_iso_code, wl_country_t *cspec);
-extern void dhd_bus_country_set(struct net_device *dev, wl_country_t *cspec);
-extern int wldev_set_country(struct net_device *dev, char *country_code);
+extern void dhd_bus_country_set(struct net_device *dev, wl_country_t *cspec, bool notify);
+extern void dhd_bus_band_set(struct net_device *dev, uint band);
+extern int wldev_set_country(struct net_device *dev, char *country_code, bool notify,
+	bool user_enforced);
 extern int net_os_wake_lock(struct net_device *dev);
 extern int net_os_wake_unlock(struct net_device *dev);
 extern int net_os_wake_lock_timeout(struct net_device *dev);
 extern int net_os_wake_lock_timeout_enable(struct net_device *dev, int val);
 extern int net_os_set_dtim_skip(struct net_device *dev, int val);
 extern int net_os_set_suspend_disable(struct net_device *dev, int val);
-extern int net_os_set_suspend(struct net_device *dev, int val);
+extern int net_os_set_suspend(struct net_device *dev, int val, int force);
 extern int wl_iw_parse_ssid_list_tlv(char** list_str, wlc_ssid_t* ssid,
 	int max, int *bytes_left);
 
diff --git a/drivers/nfc/Kconfig b/drivers/nfc/Kconfig
old mode 100644
new mode 100755
index 3039b0d..88f03bc
--- a/drivers/nfc/Kconfig
+++ b/drivers/nfc/Kconfig
@@ -40,6 +40,18 @@ config NFC_WILINK
 
 endmenu
 
+config NFC_PN544
+	tristate "ZTEMT NFC PN544 driver"
+	depends on I2C
+	select CRC_CCITT
+	default n
+	---help---
+	  Say yes if you want ZTEMT PN544 Near Field Communication driver.
+	  This is for i2c connected version. If unsure, say N here.
+
+	  To compile this driver as a module, choose m here. The module will
+	  be called pn544.	  
+
 config NFC_QNCI
 	bool "Qualcomm NCI based NFC Controller Driver for qca199x"
 	depends on I2C
diff --git a/drivers/nfc/Makefile b/drivers/nfc/Makefile
old mode 100644
new mode 100755
index 35a71e8..c9c1e36
--- a/drivers/nfc/Makefile
+++ b/drivers/nfc/Makefile
@@ -3,6 +3,7 @@
 #
 
 obj-$(CONFIG_PN544_NFC)		+= pn544.o
+obj-$(CONFIG_NFC_PN544)		+= nxp_pn544.o
 obj-$(CONFIG_NFC_PN533)		+= pn533.o
 obj-$(CONFIG_NFC_WILINK)	+= nfcwilink.o
 obj-$(CONFIG_NFC_QNCI)		+= nfc-nci.o
diff --git a/drivers/nfc/nxp_pn544.c b/drivers/nfc/nxp_pn544.c
new file mode 100755
index 0000000..8705e53
--- /dev/null
+++ b/drivers/nfc/nxp_pn544.c
@@ -0,0 +1,618 @@
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/regulator/consumer.h>
+#include <linux/string.h>
+#include <linux/of_gpio.h>
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/irq.h>
+#include <linux/jiffies.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <linux/spinlock.h>
+#include <linux/pn544.h>
+#include <linux/fs.h>
+
+#define PN544_DRIVER_NAME	"pn544"
+//#denfie NFC_HOST_OFF_CE
+
+//#define NXP_PN544_DEBUG
+
+#define DRIVER_DESC	"NFC driver for PN544"
+
+#define MAX_BUFFER_SIZE		512
+#define PN544_MSG_MAX_SIZE	0x21 /* at normal HCI mode */
+
+/* Timing restrictions (ms) */
+#define PN544_RESETVEN_TIME	35 /* 7 */
+
+//struct pn544_nfc_platform_data pn544_nfc_platform_data;
+
+enum pn544_irq {
+	PN544_NONE,
+	PN544_INT,
+};
+
+struct pn544_dev	{
+	wait_queue_head_t	read_wq;
+	//struct pn544_nfc_platform_data *pdata;
+	struct mutex read_mutex;
+	struct i2c_client	*client;
+	struct miscdevice	miscdev;
+	bool irq_enabled;
+	spinlock_t irq_enabled_lock;
+	enum pn544_irq read_irq;
+	
+	int updata_gpio;
+	int ven_gpio;
+	int irq_gpio;
+	int (*request_resources) (void);
+	void (*free_resources) (void);
+	void (*enable) (int fw);
+	int (*test) (void);
+	void (*disable) (void);
+	int (*irq_status) (void);
+};
+
+static struct pn544_dev *pn544_dev;
+
+#if 1
+#define PN544_NFC_SW_UPDATE   (pn544_dev->updata_gpio) //#define PN544_NFC_SW_UPDATE 13
+#define PN544_NFC_nVEN        (pn544_dev->ven_gpio) //#define PN544_NFC_nVEN      85
+#define PN544_NFC_GPIO_INT    (pn544_dev->irq_gpio)//#define PN544_NFC_GPIO_INT  68
+
+
+static int pn544_nfc_request_resources(void)
+{
+	printk("[%s] pn544_nfc_request_resources start.\n", __func__);
+	
+	if(gpio_request(PN544_NFC_SW_UPDATE, "NFC_SW_UPDATE")) {
+		pr_err("failed request NFC_SW_UPDATE.\n");
+		return -1;
+	}
+	gpio_tlmm_config(GPIO_CFG(PN544_NFC_SW_UPDATE, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),GPIO_CFG_ENABLE);
+	gpio_set_value(PN544_NFC_SW_UPDATE,0);
+	#if 0
+	error = gpio_direction_output(PN544_NFC_SW_UPDATE, 0);
+	if (error) 
+	{
+		printk("unable to set direction for gpio [%d]\n",pn544_dev->updata_gpio);
+	}
+	#endif
+	if(gpio_request(PN544_NFC_nVEN, "NFC_VEN")) {
+		pr_err("failed request NFC_VEN.\n");
+		return -1;
+	}
+	gpio_direction_output(PN544_NFC_nVEN, 1);
+	gpio_set_value_cansleep(PN544_NFC_nVEN,1);
+	
+	if(gpio_request(PN544_NFC_GPIO_INT, "NFC_IRQ")) {
+		pr_err("failed request NFC_IRQ.\n");
+		goto err_rst_gpio_req;
+	}	
+	gpio_tlmm_config(GPIO_CFG(PN544_NFC_GPIO_INT, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),GPIO_CFG_ENABLE);
+	#if 0
+	error = gpio_direction_input(pn544_dev->irq_gpio);
+	if (error) 
+	{
+		printk("unable to set direction for gpio [%d]\n",pn544_dev->irq_gpio);
+	}
+	#endif
+	return 0;
+err_rst_gpio_req:
+	gpio_free(PN544_NFC_SW_UPDATE);
+	gpio_free(PN544_NFC_nVEN);
+	return -1;
+}
+static void pn544_nfc_free_resources(void)
+{
+	/* Release the HW resources */
+	printk("%s:goto pn544_nfc_free_resources\n",__func__);
+	//pmapp_clock_vote("NNFC", PMAPP_CLOCK_ID_A1, PMAPP_CLOCK_VOTE_OFF);
+	gpio_tlmm_config(GPIO_CFG(PN544_NFC_SW_UPDATE, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),GPIO_CFG_ENABLE);
+	gpio_tlmm_config(GPIO_CFG(PN544_NFC_GPIO_INT, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),GPIO_CFG_ENABLE);
+	gpio_free(PN544_NFC_SW_UPDATE);
+	gpio_free(PN544_NFC_nVEN);
+	gpio_free(PN544_NFC_GPIO_INT);
+}
+static void pn544_nfc_enable(int fw)
+{
+	printk("%s:goto pn544_nfc_enable\n",__func__);
+	/* Turn the device on */
+    if (HCI_MODE == fw )
+    {
+		printk("%s:enable HCI_MODE pn544\n",__func__);
+        gpio_set_value(PN544_NFC_SW_UPDATE, 0);
+        gpio_set_value_cansleep(PN544_NFC_nVEN,0);
+    }
+    else // FW_MODE
+    {
+        
+		printk("%s:enable FW_MODE pn544\n",__func__);
+		gpio_set_value_cansleep(PN544_NFC_nVEN, 0);/* 1 */
+        gpio_set_value(PN544_NFC_SW_UPDATE, 1); /* 1 */
+        msleep(10);
+        gpio_set_value_cansleep(PN544_NFC_nVEN, 1);/* 0 */
+        msleep(50);
+        gpio_set_value_cansleep(PN544_NFC_nVEN, 0);/* 1 */
+        msleep(10);
+    }
+}
+static int pn544_nfc_test(void)
+{
+	/*
+	 * Put the device into the FW update mode
+	 * and then back to the normal mode.
+	 * Check the behavior and return one on success,
+	 * zero on failure.
+	 */
+	return 0;
+}
+
+static void pn544_nfc_disable(void)
+{
+	/* turn the power off */
+ 	gpio_set_value(PN544_NFC_SW_UPDATE, 0);
+	gpio_set_value_cansleep(PN544_NFC_nVEN, 1);
+}
+
+static int pn544_pt_irq_status(void)
+{
+  return (gpio_get_value(PN544_NFC_GPIO_INT) != 0);
+}
+#endif //CONFIG_PN544_NFC
+
+static int pn544_dev_enable(struct pn544_dev *dev, int mode)
+{
+#ifdef NXP_PN544_DEBUG
+    printk("%s: mode: %d\n", __func__, mode);
+#endif
+
+	dev->read_irq = PN544_NONE;
+	if (dev->enable)
+		dev->enable(mode);
+	usleep_range(10000, 15000);
+	//usleep_range(20000, 35000);
+	return 0;
+}
+
+static void pn544_dev_disable(struct pn544_dev *dev)
+{
+	//struct i2c_client *client = dev->client;
+	
+	if (dev->disable)
+		dev->disable();
+
+	msleep(PN544_RESETVEN_TIME);
+
+	dev->read_irq = PN544_NONE;
+
+#ifdef NXP_PN544_DEBUG
+	//dev_dbg(&client->dev, "%s: Now in OFF-mode\n", __func__);//delete by chengdongsheng 
+    printk(KERN_DEBUG "%s: Now in OFF-mode\n", __func__);
+#endif
+}
+
+static int pn544_irq_status(struct pn544_dev *dev)
+{
+	if ( dev->irq_status ) {
+		return 0;
+	} else {
+		return dev->irq_status();
+	}
+}
+
+static void pn544_disable_irq(struct pn544_dev *dev)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->irq_enabled_lock, flags);
+	if (dev->irq_enabled) {
+		disable_irq_nosync(dev->client->irq);
+		dev->irq_enabled = false;
+	}
+	spin_unlock_irqrestore(&dev->irq_enabled_lock, flags);
+}
+
+
+static int pn544_dev_open(struct inode *inode, struct file *filp)
+{
+	filp->private_data = pn544_dev;
+	
+	printk("%s : (imajor) %d, (iminor) %d\n", __func__, imajor(inode), iminor(inode));
+	
+	return pn544_dev_enable(pn544_dev, HCI_MODE);
+}
+
+static ssize_t pn544_dev_read(struct file *filp, char __user *buf,
+		size_t count, loff_t *offset)
+{
+	//ztemt changed  by chengdongsheng 2012.12.20 avoid the filp->private_data was null
+	//struct pn544_dev *dev = filp->private_data;	
+	struct pn544_dev *dev = pn544_dev;
+	//ztemt end
+	struct i2c_client *client = dev->client;
+	char tmp[MAX_BUFFER_SIZE];
+	int ret;
+
+	if (count > MAX_BUFFER_SIZE)
+		count = MAX_BUFFER_SIZE;
+
+#ifdef NXP_PN544_DEBUG
+    printk(KERN_DEBUG "%s: reading %zu bytes.\n", __func__, count);
+#endif
+	mutex_lock(&dev->read_mutex);
+
+	if ( !pn544_irq_status(dev) ) {
+		if (filp->f_flags & O_NONBLOCK) {
+			ret = -EAGAIN;
+			goto fail;
+		}
+
+		dev->irq_enabled = true;
+		enable_irq(dev->client->irq);
+		ret = wait_event_interruptible(dev->read_wq, 
+			(dev->read_irq == PN544_INT));
+		pn544_disable_irq(dev);
+
+		if (ret)
+			goto fail;
+	}
+	/* Read data */
+	ret = i2c_master_recv(dev->client, tmp, count);
+	dev->read_irq = PN544_NONE;
+	mutex_unlock(&dev->read_mutex);
+
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: i2c_master_recv returned %d\n", 
+				__func__, ret);
+		return ret;
+	}
+	if (ret > count) {
+		dev_err(&client->dev, "%s: received too many bytes from i2c (%d)\n",
+				__func__, ret);
+		return -EIO;
+	}
+#ifdef NXP_PN544_DEBUG
+	print_hex_dump(KERN_DEBUG, " read: ", DUMP_PREFIX_NONE, 16, 1, tmp, ret, false);
+#endif
+	if (copy_to_user(buf, tmp, ret)) {
+		dev_err(&client->dev, "%s : failed to copy to user space\n", 
+				__func__);
+		return -EFAULT;
+	}
+	return ret;
+
+fail:
+	mutex_unlock(&dev->read_mutex);
+	return ret;
+}
+
+static ssize_t pn544_dev_write(struct file *filp, const char __user *buf,
+		size_t count, loff_t *offset)
+{
+	//ztem changed  by chengdongsheng 2012.12.20 avoid the filp->private_data was null
+	//struct pn544_dev *dev = filp->private_data;
+	struct pn544_dev *dev = pn544_dev;
+	//ztemt end
+	struct i2c_client *client = dev->client;
+	char tmp[MAX_BUFFER_SIZE];
+	int ret;
+
+	if (count > MAX_BUFFER_SIZE)
+		count = MAX_BUFFER_SIZE;
+
+	if (copy_from_user(tmp, buf, count)) {
+		dev_err(&client->dev, "%s : failed to copy from user space\n", __func__);
+		return -EFAULT;
+	}
+
+#ifdef NXP_PN544_DEBUG
+	dev_dbg(&client->dev, "%s : writing %zu bytes.\n", __func__, count);
+	print_hex_dump(KERN_DEBUG, "write: ", DUMP_PREFIX_NONE, 16, 1, tmp, count, false);
+#endif
+	/* Write data */
+	ret = i2c_master_send(client, tmp, count);
+	if (ret != count) {
+		dev_err(&client->dev, "%s : addr is 0x%x, i2c_master_send returned %d\n", __func__, client->addr, ret);
+		ret = -EIO;
+	}
+
+	return ret;
+}
+
+static long pn544_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{	
+	//ztemt changed  by chengdongsheng 2012.12.20 avoid the filp->private_data was null
+	//struct pn544_dev *dev = filp->private_data;
+	struct pn544_dev *dev = pn544_dev;	
+	//ztemt end
+	struct i2c_client *client = dev->client;
+	unsigned int val;
+	int r = 0;
+
+#ifdef NXP_PN544_DEBUG
+	dev_dbg(&client->dev, "%s: cmd: 0x%x,PN544_SET_PWR:0x%x\n", __func__, cmd, PN544_SET_PWR);
+#endif
+	switch (cmd) {
+		case PN544_SET_PWR:
+			val = arg;
+#ifdef NXP_PN544_DEBUG
+			dev_dbg(&client->dev, "%s:  PN544_SET_PWR: %d\n", __func__, val);
+#endif
+			switch (val) {
+				case 0: // power off
+					pn544_dev_disable(dev);
+#ifdef NFC_HOST_OFF_CE
+					irq_set_irq_wake(pn544_dev->client->irq,0);
+					msleep(10);
+#endif
+					break;
+				case 1: // power on
+					r = pn544_dev_enable(dev, HCI_MODE);
+					if (r < 0)
+						goto out;
+#ifdef NFC_HOST_OFF_CE
+					irq_set_irq_wake(pn544_dev->client->irq,1);
+					msleep(10);
+#endif
+					break;
+				case 2: // reset and power on with firmware download enabled
+					r = pn544_dev_enable(dev, FW_MODE);
+					if (r < 0)
+						goto out;
+#ifdef NFC_HOST_OFF_CE
+					irq_set_irq_wake(pn544_dev->client->irq,1);
+					msleep(10);
+#endif
+					break;
+				default:
+					r = -ENOIOCTLCMD;
+					goto out;
+					break;
+			}
+			break;
+		default:
+			dev_err(&client->dev, "%s bad ioctl %u\n", __func__, cmd);
+			return -EINVAL;
+	}
+out:
+	return r;
+}
+
+static irqreturn_t pn544_dev_irq_handler(int irq, void *dev_id)
+{
+	struct pn544_dev *dev = dev_id;
+
+	pn544_disable_irq(dev);
+
+	//dev_dbg(&dev->client->dev, "IRQ\n");
+
+	dev->read_irq = PN544_INT;
+	
+	/* Wake up waiting readers */
+	wake_up(&dev->read_wq);
+
+	return IRQ_HANDLED;
+}
+
+static const struct file_operations pn544_dev_fops = {
+	.owner	= THIS_MODULE,
+	.llseek	= no_llseek,
+	.open	= pn544_dev_open,
+	.read	= pn544_dev_read,
+	.write	= pn544_dev_write,
+	.unlocked_ioctl = pn544_dev_ioctl,
+};
+
+#ifdef NXP_PN544_STANDBY_MODE
+static void set_standby_mode(struct pn544_dev *pn544dev)
+{
+	char standby_commands[] = {0x09, 0x9B, 0x82, 0x3F, 0x00, 0x9E, 0xAA, 0x01, 0x9B, 0x03};
+	int ret = -1;
+
+	pn544dev = pn544_dev;
+	if(pn544dev == NULL){
+		printk(KERN_ERR "[%s]dev is NULL.\n", __func__);
+		return;
+	}
+	
+	//Reset and write standy mode commands
+	ret = pn544_dev_enable(pn544dev, HCI_MODE);
+	if (ret < 0){
+		printk(KERN_ERR "[%s]enable nfc failed.\n", __func__);
+		return;
+	}
+	
+	pn544_dev_disable(pn544dev);
+
+	ret = pn544_dev_enable(pn544dev, HCI_MODE);
+	if (ret < 0){
+		printk(KERN_ERR "[%s]enable nfc failed.\n", __func__);
+		return;
+	}
+
+	ret = i2c_master_send(pn544dev->client , standby_commands, sizeof(standby_commands));
+	if (ret != sizeof(standby_commands)) {
+		printk(KERN_ERR "[%s]i2c_master_send failed. returned %d\n", __func__, ret);
+		return;
+	}
+	pn544_dev_disable(pn544dev);
+	
+    printk(KERN_DEBUG "[%s]Reset and write standby commands successfully.write bytes:%d\n", __func__, ret);
+}
+#endif
+
+static __devinit int pn544_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	int irq_gpio = -1;
+	int updata_gpio = -1;
+	int ven_gpio = -1;
+	int irq;
+	int addr;
+	int ret;
+
+	dev_dbg(&client->dev, "IRQ: %d\n", client->irq);
+
+	if(client->dev.of_node)
+	{
+		irq_gpio = of_get_named_gpio_flags(client->dev.of_node, "nxp,irq-gpio", 0, NULL);
+		updata_gpio = of_get_named_gpio_flags(client->dev.of_node, "nxp,updata-gpio", 0, NULL);
+		ven_gpio = of_get_named_gpio_flags(client->dev.of_node, "nxp,ven-gpio", 0, NULL);
+		printk("pn544,--irq_gpio---:%d\n", irq_gpio);
+		printk("pn544,--updata_gpio---:%d\n", updata_gpio);
+		printk("pn544,--ven_gpio---:%d\n", ven_gpio);
+	}
+
+	irq = client->irq;
+	addr = client->addr;
+
+	if (pn544_dev != NULL) {
+		dev_warn(&client->dev, "only one PN544 supported.\n");
+		return -EBUSY;
+	}
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "%s : need I2C_FUNC_I2C\n", __func__);
+		return  -ENODEV;
+	}
+	
+	pn544_dev = kzalloc(sizeof(struct pn544_dev), GFP_KERNEL);
+	if (pn544_dev == NULL) {
+		dev_err(&client->dev, "failed to allocate memory for module data\n");
+		ret = -ENOMEM;
+		goto err_exit;
+	}
+	
+	pn544_dev->client = client;
+	pn544_dev->irq_gpio = irq_gpio;
+	pn544_dev->updata_gpio = updata_gpio;
+	pn544_dev->ven_gpio = ven_gpio;
+	pn544_dev->request_resources = pn544_nfc_request_resources;
+	pn544_dev->free_resources = pn544_nfc_free_resources;
+	pn544_dev->enable = pn544_nfc_enable;
+	pn544_dev->disable = pn544_nfc_disable;
+	pn544_dev->test = pn544_nfc_test;
+	pn544_dev->irq_status = pn544_pt_irq_status;
+	/* init mutex and queues */
+	pn544_dev->read_irq = PN544_NONE;
+	init_waitqueue_head(&pn544_dev->read_wq);
+	mutex_init(&pn544_dev->read_mutex);
+	spin_lock_init(&pn544_dev->irq_enabled_lock);
+	
+	i2c_set_clientdata(client, pn544_dev);
+
+	if (!pn544_dev->request_resources) {
+		dev_err(&client->dev, "request_resources() missing\n");
+		ret = -EINVAL;
+		goto err_request_resources;
+	}
+
+	ret = pn544_dev->request_resources();
+	if (ret < 0) {
+		dev_err(&client->dev, "Cannot get platform resources\n");
+		goto err_request_resources;
+	}
+	pn544_dev->irq_enabled = true;
+
+	ret = request_irq(client->irq, pn544_dev_irq_handler,
+			IRQF_TRIGGER_HIGH, client->name, pn544_dev);
+	printk("--client->irq:%d,client->name:%s\n", client->irq,client->name);
+	
+	if (ret) {
+		dev_err(&client->dev, "request_irq failed\n");
+		goto err_request_irq;
+	}
+	
+	printk("pn544_dev->client->irq:%d\n",pn544_dev->client->irq);
+	pn544_disable_irq(pn544_dev);	
+
+	pn544_dev->miscdev.minor = MISC_DYNAMIC_MINOR;
+	pn544_dev->miscdev.name = PN544_DRIVER_NAME;
+	pn544_dev->miscdev.fops = &pn544_dev_fops;
+	pn544_dev->miscdev.parent = &client->dev;
+	ret = misc_register(&pn544_dev->miscdev);
+	if (ret) {
+		dev_err(&client->dev, "%s : misc_register failed\n", __func__);
+		goto err_misc_register;
+	}
+
+	printk("%s: dev: %p, client %p\n",__func__, pn544_dev, client);
+
+#ifdef NXP_PN544_STANDBY_MODE
+	set_standby_mode(pn544_dev);
+#endif
+
+	return 0;
+
+err_misc_register:
+	free_irq(client->irq, pn544_dev);
+err_request_irq:
+	if (pn544_dev->free_resources)
+		pn544_dev->free_resources();
+err_request_resources:
+	mutex_destroy(&pn544_dev->read_mutex);
+	kfree(pn544_dev);
+err_exit:
+	return ret;
+	
+}
+
+static __devexit int pn544_remove(struct i2c_client *client)
+{
+	struct pn544_dev *dev = i2c_get_clientdata(client);
+
+	dev_dbg(&client->dev, "%s\n", __func__);
+
+	misc_deregister(&dev->miscdev);
+	if (dev->disable)
+		dev->disable();
+	dev->read_irq = PN544_NONE;
+	free_irq(client->irq, dev);
+	if (dev->free_resources)
+		dev->free_resources();
+	mutex_destroy(&dev->read_mutex);
+	kfree(dev);
+
+	pn544_dev = NULL;
+	
+	return 0;
+}
+
+static struct of_device_id nxp_match_table[] = {
+	{ .compatible = "nxp,i2c_adapter",},
+	{ },
+};
+
+static const struct i2c_device_id pn544_id[] = {
+	{ PN544_DRIVER_NAME, 0 },
+	{ }
+};
+
+static struct i2c_driver pn544_driver = {
+	.id_table	= pn544_id,
+	.probe		= pn544_probe,
+	.remove		= pn544_remove,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= PN544_DRIVER_NAME,
+		.of_match_table = nxp_match_table,
+	},
+};
+
+module_i2c_driver(pn544_driver);
+
+MODULE_DESCRIPTION("I2C_TEST_NXP");
+MODULE_LICENSE("GPL");
diff --git a/drivers/of/of_batterydata.c b/drivers/of/of_batterydata.c
old mode 100644
new mode 100755
diff --git a/drivers/platform/msm/qpnp-power-on.c b/drivers/platform/msm/qpnp-power-on.c
old mode 100644
new mode 100755
index 1d388f4..c62ce9f
--- a/drivers/platform/msm/qpnp-power-on.c
+++ b/drivers/platform/msm/qpnp-power-on.c
@@ -23,6 +23,10 @@
 #include <linux/input.h>
 #include <linux/log2.h>
 #include <linux/qpnp/power-on.h>
+#ifdef CONFIG_ZTE_POWEROFF_ALARM
+#include <linux/io.h>
+#include <mach/restart.h>
+#endif
 
 #define PMIC_VER_8941           0x01
 #define PMIC_VERSION_REG        0x0105
@@ -1102,6 +1106,54 @@ free_input_dev:
 	return rc;
 }
 
+#ifdef CONFIG_ZTE_POWEROFF_ALARM
+int  poweron_reason_index=0;
+int  zte_reboot_reason=0;
+
+static ssize_t poweron_reason_info_show(struct device *dev, 
+		struct device_attribute *attr, char *buf)
+{
+    if(buf)
+		
+	*buf = (char)poweron_reason_index;
+	return 1;
+}
+
+static ssize_t poweron_reason_info_store(struct device *dev, 
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+     return count;
+}
+
+static DEVICE_ATTR(info, 0444, poweron_reason_info_show, poweron_reason_info_store);
+
+static ssize_t reboot_reason_info_show(struct device *dev, 
+		struct device_attribute *attr, char *buf)
+{
+    if(buf)	
+	*buf = (char)zte_reboot_reason;
+    return 1;
+	//return snprintf(buf, PAGE_SIZE, "%d\n",zte_reboot_reason);
+}
+
+void qpnp_get_reboot_reason(void){
+
+ unsigned long reboot_reason=0;
+ 
+   reboot_reason=__raw_readl(restart_reason);
+      
+  if(0x77665503==reboot_reason)
+  	{
+	  zte_reboot_reason=3;
+    }
+   __raw_writel(0,restart_reason); 
+}
+
+static DEVICE_ATTR(rb_reason, 0444, reboot_reason_info_show, NULL);
+
+
+#endif
+
 static int __devinit qpnp_pon_probe(struct spmi_device *spmi)
 {
 	struct qpnp_pon *pon;
@@ -1113,6 +1165,10 @@ static int __devinit qpnp_pon_probe(struct spmi_device *spmi)
 	const char *s3_src;
 	u8 s3_src_reg;
 	u16 poff_sts = 0;
+#ifdef CONFIG_ZTE_POWEROFF_ALARM
+	static struct kobject *poweron_reason_kobject = NULL;
+	int ret;
+#endif
 
 	pon = devm_kzalloc(&spmi->dev, sizeof(struct qpnp_pon),
 							GFP_KERNEL);
@@ -1194,6 +1250,27 @@ static int __devinit qpnp_pon_probe(struct spmi_device *spmi)
 				pon->spmi->sid,
 				qpnp_poff_reason[index]);
 
+#ifdef CONFIG_ZTE_POWEROFF_ALARM
+
+        if(qpnp_pon_is_warm_reset())
+			index=0;		
+		poweron_reason_kobject = kobject_create_and_add("zte_poweron_reason", NULL);
+		if(poweron_reason_kobject == NULL) {
+			ret = -ENOMEM;
+			return ret;
+		}	
+		ret = sysfs_create_file(poweron_reason_kobject, &dev_attr_info.attr);
+		if(ret){
+			return ret;
+		}
+		poweron_reason_index=index;
+
+       qpnp_get_reboot_reason();
+       ret = sysfs_create_file(poweron_reason_kobject, &dev_attr_rb_reason.attr);
+		if(ret){
+			return ret;
+		}		
+#endif
 	rc = of_property_read_u32(pon->spmi->dev.of_node,
 				"qcom,pon-dbc-delay", &delay);
 	if (rc) {
diff --git a/drivers/platform/msm/qpnp-pwm.c b/drivers/platform/msm/qpnp-pwm.c
old mode 100644
new mode 100755
diff --git a/drivers/platform/msm/qpnp-vibrator.c b/drivers/platform/msm/qpnp-vibrator.c
old mode 100644
new mode 100755
diff --git a/drivers/power/Kconfig b/drivers/power/Kconfig
old mode 100644
new mode 100755
index e744d04..1ce17db
--- a/drivers/power/Kconfig
+++ b/drivers/power/Kconfig
@@ -13,7 +13,11 @@ config POWER_SUPPLY_DEBUG
 	help
 	  Say Y here to enable debugging messages for power supply class
 	  and drivers.
-
+config ZTEMT_POWER_DEBUG
+	bool "ZTEMT Power Debug Feature"
+	default y
+	help
+	  ZTEMT Power Debug Feature
 config PDA_POWER
 	tristate "Generic PDA/phone power driver"
 	depends on !S390
@@ -497,7 +501,32 @@ config AB8500_BATTERY_THERM_ON_BATCTRL
 	help
 	  Say Y to enable battery temperature measurements using
 	  thermistor connected on BATCTRL ADC.
+	  
+################ZTEMT charger
+menu "ZTEMT charger and battery"
+
+config ZTEMT_COMM_CHARGE
+	bool "ZTEMT comm qpnp Charge"
+	default n
+	help
+	  ZTEMT comm qpnp Charge 
 
+config ZTEMT_CHG_PARAM_CHECK
+	bool "ZTEMT  Charge parameters check"
+	default n
+	help
+	  ZTEMT  Charge parameters check
+
+################ztemt battery config
+
+config ZTEMT_NX503A_CHARGE
+	bool "ZTEMT 2300mAh battery"
+	default n
+	help
+	  ZTEMT 2300mAh battery
+endmenu
+################ZTEMT end
+	  
 config QPNP_BMS
 	tristate "QPNP Battery Monitoring System driver"
 	depends on SPMI
diff --git a/drivers/power/Makefile b/drivers/power/Makefile
old mode 100644
new mode 100755
diff --git a/drivers/power/power_supply_sysfs.c b/drivers/power/power_supply_sysfs.c
old mode 100644
new mode 100755
index 6f8f9a9..68d088c
--- a/drivers/power/power_supply_sysfs.c
+++ b/drivers/power/power_supply_sysfs.c
@@ -156,6 +156,9 @@ static struct device_attribute power_supply_attrs[] = {
 	POWER_SUPPLY_ATTR(bypass_vchg_loop_debouncer),
 	POWER_SUPPLY_ATTR(current_now),
 	POWER_SUPPLY_ATTR(current_avg),
+  #ifdef CONFIG_ZTEMT_COMM_CHARGE	
+	POWER_SUPPLY_ATTR(charger_online),
+	#endif				
 	POWER_SUPPLY_ATTR(power_now),
 	POWER_SUPPLY_ATTR(power_avg),
 	POWER_SUPPLY_ATTR(charge_full_design),
diff --git a/drivers/power/qpnp-bms.c b/drivers/power/qpnp-bms.c
old mode 100644
new mode 100755
index 6320dec..d478bc8c
--- a/drivers/power/qpnp-bms.c
+++ b/drivers/power/qpnp-bms.c
@@ -82,8 +82,11 @@
 #define IGNORE_SOC_TEMP_DECIDEG		50
 #define IAVG_STEP_SIZE_MA		10
 #define IAVG_INVALID			0xFF
+#ifdef CONFIG_ZTEMT_NX503A_CHARGE
+#define SOC_INVALID			0xFF
+#else
 #define SOC_INVALID			0x7E
-
+#endif
 #define IAVG_SAMPLES 16
 
 /* FCC learning constants */
@@ -95,6 +98,21 @@
 
 #define QPNP_BMS_DEV_NAME "qcom,qpnp-bms"
 
+#ifdef CONFIG_ZTEMT_COMM_CHARGE_X
+//
+ #undef pr_debug
+ #define pr_debug   pr_info
+
+#undef KERN_INFO
+#define KERN_INFO KERN_ERR
+#endif
+
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+static int debug_mask_bms = 1;
+module_param_named(debug_mask_bms, debug_mask_bms, int, S_IRUGO | S_IWUSR | S_IWGRP);
+#define DBG_BMS(x...) do {if (debug_mask_bms) pr_info(">>ZTEMT_BMS>>  " x); } while (0)
+#endif
+
 enum {
 	SHDW_CC,
 	CC
@@ -1169,8 +1187,11 @@ static int calculate_pc(struct qpnp_bms_chip *chip, int ocv_uv,
 
 	pc = interpolate_pc(chip->pc_temp_ocv_lut,
 			batt_temp, ocv_uv / 1000);
+#ifdef	CONFIG_ZTEMT_COMM_CHARGE
+#else
 	pr_debug("pc = %u %% for ocv = %d uv batt_temp = %d\n",
 					pc, ocv_uv, batt_temp);
+#endif
 	/* Multiply the initial FCC value by the scale factor. */
 	return pc;
 }
@@ -1438,8 +1459,11 @@ static int calculate_unusable_charge_uah(struct qpnp_bms_chip *chip,
 	uuc_iavg_ma = 0;
 	if (chip->iavg_num_samples != 0) {
 		for (i = 0; i < chip->iavg_num_samples; i++) {
+		#ifdef CONFIG_ZTEMT_COMM_CHARGE 
+		#else
 			pr_debug("iavg_samples_ma[%d] = %d\n", i,
 					chip->iavg_samples_ma[i]);
+		 #endif
 			uuc_iavg_ma += chip->iavg_samples_ma[i];
 		}
 
@@ -1756,12 +1780,22 @@ static void backup_soc_and_iavg(struct qpnp_bms_chip *chip, int batt_temp,
 	rc = qpnp_write_wrapper(chip, &temp, chip->base + IAVG_STORAGE_REG, 1);
 
 	/* store an invalid soc if temperature is below 5degC */
+#ifdef CONFIG_ZTEMT_NX503A_CHARGE
+	if (batt_temp > IGNORE_SOC_TEMP_DECIDEG)
+			temp = soc;
+	else 
+		 	temp = SOC_INVALID;
+		 	
+				rc = qpnp_write_wrapper(chip, &temp,
+																		 chip->soc_storage_addr, 1);
+#else
 	if (batt_temp > IGNORE_SOC_TEMP_DECIDEG)
 		qpnp_masked_write_base(chip, chip->soc_storage_addr,
 				SOC_STORAGE_MASK, (soc + 1) << 1);
 	else
 		qpnp_masked_write_base(chip, chip->soc_storage_addr,
 				SOC_STORAGE_MASK, SOC_STORAGE_MASK);
+#endif	
 }
 
 static int scale_soc_while_chg(struct qpnp_bms_chip *chip, int chg_time_sec,
@@ -2411,6 +2445,9 @@ static int calculate_raw_soc(struct qpnp_bms_chip *chip,
 }
 
 #define SLEEP_RECALC_INTERVAL	3
+#ifdef CONFIG_ZTEMT_COMM_CHARGE	
+#define UPDATED_BATT_TEMP_STEP   20
+#endif
 static int calculate_state_of_charge(struct qpnp_bms_chip *chip,
 					struct raw_soc_params *raw,
 					int batt_temp)
@@ -2418,6 +2455,9 @@ static int calculate_state_of_charge(struct qpnp_bms_chip *chip,
 	struct soc_params params;
 	int soc, previous_soc, shutdown_soc, new_calculated_soc;
 	int remaining_usable_charge_uah;
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+	static int  previous_batt_temp  = 0;
+#endif
 
 	calculate_soc_params(chip, raw, &params, batt_temp);
 	if (!is_battery_present(chip)) {
@@ -2517,8 +2557,17 @@ done_calculating:
 	mutex_unlock(&chip->last_soc_mutex);
 	wake_up_interruptible(&chip->bms_wait_queue);
 
-	if (new_calculated_soc != previous_soc && chip->bms_psy_registered) {
+	if (
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+		((new_calculated_soc != previous_soc)||(abs(batt_temp - previous_batt_temp)>UPDATED_BATT_TEMP_STEP))
+#else		
+		(new_calculated_soc != previous_soc)
+#endif			
+		&& chip->bms_psy_registered) {
 		power_supply_changed(&chip->bms_psy);
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+		previous_batt_temp = batt_temp;
+#endif
 		pr_debug("power supply changed\n");
 	} else {
 		/*
@@ -3417,7 +3466,13 @@ static void battery_insertion_check(struct qpnp_bms_chip *chip)
 /* Returns capacity as a SoC percentage between 0 and 100 */
 static int get_prop_bms_capacity(struct qpnp_bms_chip *chip)
 {
+ #ifdef CONFIG_ZTEMT_COMM_CHARGE
+	int soc = report_state_of_charge(chip);
+	soc = bound_soc(soc);
+	return soc;
+#else
 	return report_state_of_charge(chip);
+#endif
 }
 
 static void qpnp_bms_external_power_changed(struct power_supply *psy)
@@ -3553,10 +3608,14 @@ static int read_shutdown_soc(struct qpnp_bms_chip *chip)
 		return SOC_INVALID;
 	}
 
+#ifdef CONFIG_ZTEMT_NX503A_CHARGE
+		shutdown_soc = stored_soc ;
+#else
 	if ((stored_soc >> 1) > 0)
 		shutdown_soc = (stored_soc >> 1) - 1;
 	else
 		shutdown_soc = SOC_INVALID;
+#endif
 
 	pr_debug("stored soc = 0x%02x, shutdown_soc = %d\n",
 			stored_soc, shutdown_soc);
@@ -3680,7 +3739,11 @@ static int set_battery_data(struct qpnp_bms_chip *chip)
 	if (chip->batt_type == BATT_DESAY) {
 		batt_data = &desay_5200_data;
 	} else if (chip->batt_type == BATT_PALLADIUM) {
+#ifdef CONFIG_ZTEMT_NX503A_CHARGE
+		batt_data = &ztemt_NX503A_2300mAh_data;
+#else
 		batt_data = &palladium_1500_data;
+#endif
 	} else if (chip->batt_type == BATT_OEM) {
 		batt_data = &oem_batt_data;
 	} else if (chip->batt_type == BATT_QRD_4V35_2000MAH) {
diff --git a/drivers/power/qpnp-charger.c b/drivers/power/qpnp-charger.c
old mode 100644
new mode 100755
index af16e9d..fdf6cea
--- a/drivers/power/qpnp-charger.c
+++ b/drivers/power/qpnp-charger.c
@@ -36,6 +36,11 @@
 #include <linux/of_gpio.h>
 #include <linux/qpnp/pin.h>
 
+#ifdef CONFIG_NX503A_ZTEMT_DEVICE_INFO
+#include <linux/io.h>
+#include <linux/qpnp/qpnp-device-info.h>
+#endif
+
 /* Interrupt offsets */
 #define INT_RT_STS(base)			(base + 0x10)
 #define INT_SET_TYPE(base)			(base + 0x11)
@@ -225,6 +230,34 @@
 #define BOOST_FLASH_WA			BIT(1)
 #define POWER_STAGE_WA			BIT(2)
 
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+//
+//#undef pr_debug
+//#define pr_debug   pr_info
+
+#undef KERN_INFO
+#define KERN_INFO KERN_ERR
+#endif
+
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+static int debug_mask = 1;
+module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
+#define DBG_CHARGE(x...) do {if (debug_mask) pr_info(">>ZTEMT_CHARGE>>  " x); } while (0)
+#endif
+
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+	struct qpnp_chg_chip	*g_chip = NULL;
+
+enum  dwc3_chg_type {
+	DWC3_INVALID_CHARGER = 0,
+	DWC3_SDP_CHARGER,
+	DWC3_DCP_CHARGER,
+	DWC3_CDP_CHARGER,
+	DWC3_PROPRIETARY_CHARGER,
+	DWC3_FLOATED_CHARGER,
+};
+#endif
+
 struct qpnp_chg_irq {
 	int		irq;
 	unsigned long		disabled;
@@ -401,8 +434,86 @@ struct qpnp_chg_chip {
 	unsigned int			ext_ovp_isns_gpio;
 	unsigned int			usb_trim_default;
 	u8				chg_temp_thresh_default;
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+	enum  dwc3_chg_type   chg_type;
+	struct delayed_work battery_monitor_work;
+#endif
+
+	#ifdef CONFIG_ZTEMT_POWER_DEBUG
+	struct delayed_work power_debug_work;
+	#endif
+};
+#ifdef CONFIG_ZTEMT_POWER_DEBUG
+#include <../../arch/arm/mach-msm/clock.h>
+#define POWER_MONITOR_PERIOD_MS	10000
+#define DRV_NAME "zte_power_debug"
+static int power_debug_switch=1;
+static struct qpnp_chg_chip *chip_temp;
+extern int msm_show_resume_irq_mask; //used to print the resume irq
+extern void global_print_active_locks( void );
+//print suspend_states
+//extern int suspend_stats_debug(void);
+#endif
+
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+struct monitor_status {
+    bool  is_charger_online;
+    bool  is_temp_abnormal;
+	int  batt_temp;
+};
+
+static struct monitor_status monitor_st = {
+    .is_charger_online = 0,
+	.is_temp_abnormal = 0,
+	.batt_temp = 25,
 };
+enum batt_temp_st {
+	BATT_TEMP_GOOD = 0,
+	BATT_TEMP_ABNORMAL = 1,
+};
+
+static bool 
+is_charger_online(void)
+{
+    return monitor_st.is_charger_online;
+}
+static void
+set_charger_status(bool present)
+{
+    monitor_st.is_charger_online = present;
+}
+
+static bool
+is_chg_batt_temp_abnormal(void)
+{
+    return monitor_st.is_temp_abnormal;
+}
+
+static void 
+set_chg_batt_temp_st(enum batt_temp_st temp_status)
+{
+    monitor_st.is_temp_abnormal =(bool) temp_status;
+}
 
+static void 
+set_batt_temp(int temp)
+{
+    monitor_st.batt_temp = temp;
+}
+/*
+*  
+*  [-6 , 48] 
+*/
+#define BATT_TEMP_HIGH   530
+#define BATT_TEMP_LOW    -60
+static int is_batt_temp_abnormal(void)
+{
+    int ret = 0;
+    if(monitor_st.batt_temp<BATT_TEMP_LOW || monitor_st.batt_temp>BATT_TEMP_HIGH )
+		ret = 1;
+	return ret;
+}
+#endif
 static void
 qpnp_chg_set_appropriate_battery_current(struct qpnp_chg_chip *chip);
 
@@ -638,6 +749,33 @@ qpnp_chg_disable_irq(struct qpnp_chg_irq *irq)
 	}
 }
 
+#ifdef CONFIG_ZTEMT_COMM_CHARGE_X
+//Reset The Charger State Machine
+static int  qpnp_chg_state_machine_reset(struct qpnp_chg_chip *chip)
+{
+	u8 temp;
+	int rc;
+	
+	temp = 0x80;
+	rc = qpnp_chg_write(chip, &temp,
+			chip->chgr_base + CHGR_CHG_WDOG_PET, 1);
+	if (rc) {
+		pr_err("Failed to write wdog pet : %d\n", rc);
+		return rc;
+	}
+		
+	temp = 0x80;
+	rc = qpnp_chg_write (chip, &temp,
+			chip->chgr_base + CHGR_CHG_FAILED, 1);
+	if (rc) {
+		pr_err("Failed to write chg failed state  : %d\n", rc);
+		return rc;
+	}
+	return rc;
+
+}
+#endif
+
 static void
 qpnp_chg_irq_wake_enable(struct qpnp_chg_irq *irq)
 {
@@ -886,6 +1024,20 @@ qpnp_chg_is_dc_chg_plugged_in(struct qpnp_chg_chip *chip)
 	return (dcin_valid_rt_sts & DCIN_VALID_IRQ) ? 1 : 0;
 }
 
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+int  qpnp_chg_is_chg_plugged_in(void)
+{
+	if (!g_chip) {
+		pr_err("%s:called before init\n",__func__);
+		return 0;
+	}
+
+ 	return (g_chip->usb_present) || (g_chip->dc_present) ||  \
+ 		          qpnp_chg_is_usb_chg_plugged_in(g_chip) ||  \
+ 	            qpnp_chg_is_dc_chg_plugged_in(g_chip);
+}
+#endif
+
 static int
 qpnp_chg_is_ichg_loop_active(struct qpnp_chg_chip *chip)
 {
@@ -1022,8 +1174,11 @@ qpnp_chg_iusbmax_set(struct qpnp_chg_chip *chip, int mA)
 			chip->buck_base + CHGR_BUCK_COMPARATOR_OVRIDE_3,
 			0x0C, 0x0C, 1);
 	}
-
+	#ifdef CONFIG_ZTEMT_CHG_PARAM_CHECK 
+	pr_info("--CHG_CHECK--iusb mA=%d \n", mA);
+	#else
 	pr_debug("current=%d setting 0x%x\n", mA, usb_reg);
+	#endif
 	rc = qpnp_chg_write(chip, &usb_reg,
 		chip->usb_chgpth_base + CHGR_I_MAX_REG, 1);
 
@@ -1222,6 +1377,14 @@ qpnp_chg_charge_en(struct qpnp_chg_chip *chip, int enable)
 		pr_debug("Battery not present, skipping\n");
 		return 0;
 	}
+
+	#ifdef CONFIG_ZTEMT_COMM_CHARGE
+		if(is_chg_batt_temp_abnormal() ){
+				enable = 0 ;
+				DBG_CHARGE("charging %s\n", enable ? "enabled" : "disabled");
+		}
+	 #endif
+
 	pr_debug("charging %s\n", enable ? "enabled" : "disabled");
 	return qpnp_chg_masked_write(chip, chip->chgr_base + CHGR_CHG_CTRL,
 			CHGR_CHG_EN,
@@ -1312,8 +1475,11 @@ qpnp_chg_vbatdet_set(struct qpnp_chg_chip *chip, int vbatdet_mv)
 	}
 	temp = (vbatdet_mv - QPNP_CHG_VBATDET_MIN_MV)
 			/ QPNP_CHG_VBATDET_STEP_MV;
-
+    #ifdef CONFIG_ZTEMT_CHG_PARAM_CHECK 
+	pr_info("--CHG_CHECK--vbatdet voltage=%d \n", vbatdet_mv);
+	#else
 	pr_debug("voltage=%d setting %02x\n", vbatdet_mv, temp);
+	#endif
 	return qpnp_chg_write(chip, &temp,
 		chip->chgr_base + CHGR_VBAT_DET, 1);
 }
@@ -1553,8 +1719,13 @@ qpnp_chg_vddmax_and_trim_set(struct qpnp_chg_chip *chip,
 		pr_err("Failed to write buck trim1: %d\n", rc);
 		return rc;
 	}
+	
+	#ifdef CONFIG_ZTEMT_CHG_PARAM_CHECK 
+	pr_info("--CHG_CHECK--vddmax voltage=%d+%d \n",	voltage, trim_mv);
+	#else
 	pr_debug("voltage=%d+%d setting vddmax: %02x, trim: %02x\n",
 			voltage, trim_mv, vddmax, trim);
+    #endif
 	return 0;
 }
 
@@ -1693,17 +1864,21 @@ qpnp_chg_regulator_batfet_set(struct qpnp_chg_chip *chip, bool enable)
 		rc = qpnp_chg_masked_write(chip,
 			chip->bat_if_base + CHGR_BAT_IF_SPARE,
 			BATFET_LPM_MASK,
-			enable ? BATFET_NO_LPM : BATFET_LPM, 1);
+			BATFET_NO_LPM, 1);
 	else
 		rc = qpnp_chg_masked_write(chip,
 			chip->bat_if_base + CHGR_BAT_IF_BATFET_CTRL4,
 			BATFET_LPM_MASK,
-			enable ? BATFET_NO_LPM : BATFET_LPM, 1);
+			BATFET_NO_LPM, 1);
 
 	return rc;
 }
 
 #define USB_WALL_THRESHOLD_MA	500
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+static void  
+check_start_monitor_work(struct qpnp_chg_chip *chip);
+#endif
 #define ENUM_T_STOP_BIT		BIT(0)
 #define USB_5V_UV	5000000
 #define USB_9V_UV	9000000
@@ -1718,7 +1893,6 @@ qpnp_chg_usb_usbin_valid_irq_handler(int irq, void *_chip)
 	host_mode = qpnp_chg_is_otg_en_set(chip);
 	pr_debug("usbin-valid triggered: %d host_mode: %d\n",
 		usb_present, host_mode);
-
 	/* In host mode notifications cmoe from USB supply */
 	if (host_mode)
 		return IRQ_HANDLED;
@@ -1727,6 +1901,7 @@ qpnp_chg_usb_usbin_valid_irq_handler(int irq, void *_chip)
 		chip->aicl_settled = false;
 		chip->usb_present = usb_present;
 		if (!usb_present) {
+			//usb 
 			/* when a valid charger inserted, and increase the
 			 *  charger voltage to OVP threshold, then
 			 *  usb_in_valid falling edge interrupt triggers.
@@ -1783,6 +1958,9 @@ qpnp_chg_usb_usbin_valid_irq_handler(int irq, void *_chip)
 				msecs_to_jiffies(EOC_CHECK_PERIOD_MS));
 			schedule_work(&chip->soc_check_work);
 		}
+		#ifdef CONFIG_ZTEMT_COMM_CHARGE
+		check_start_monitor_work(chip);
+		#endif
 
 		power_supply_set_present(chip->usb_psy, chip->usb_present);
 		schedule_work(&chip->batfet_lcl_work);
@@ -2339,6 +2517,10 @@ static enum power_supply_property msm_batt_power_props[] = {
 	POWER_SUPPLY_PROP_SYSTEM_TEMP_LEVEL,
 	POWER_SUPPLY_PROP_CYCLE_COUNT,
 	POWER_SUPPLY_PROP_VOLTAGE_OCV,
+	#ifdef CONFIG_ZTEMT_COMM_CHARGE
+	POWER_SUPPLY_PROP_CHARGER_ONLINE,
+	#endif
+	
 };
 
 static char *pm_power_supplied_to[] = {
@@ -2423,6 +2605,34 @@ get_prop_battery_voltage_now(struct qpnp_chg_chip *chip)
 	}
 }
 
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+/*
+* Get The Charger Voltage
+*/
+static int
+get_prop_charger_voltage_now(struct qpnp_chg_chip *chip)
+{
+	int rc = 0;
+	struct qpnp_vadc_result results;
+
+	if (!qpnp_chg_is_usb_chg_plugged_in(chip) &&
+			!qpnp_chg_is_dc_chg_plugged_in(chip)) {
+		pr_debug("no chg connected, stopping\n");
+		goto default_voltage;
+	}
+
+		rc = qpnp_vadc_read(chip->vadc_dev, USBIN, &results);
+		if (rc) {
+			pr_err("Unable to read charger rc=%d\n", rc);
+			return 0;
+		}
+		return results.physical;
+		
+default_voltage:
+	 return 0;
+}
+#endif
+
 #define BATT_PRES_BIT BIT(7)
 static int
 get_prop_batt_present(struct qpnp_chg_chip *chip)
@@ -2447,6 +2657,14 @@ get_prop_batt_health(struct qpnp_chg_chip *chip)
 	u8 batt_health;
 	int rc;
 
+/*
+* Temperature Protection Range [-6 , 48]
+*/
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+    if( is_chg_batt_temp_abnormal() || is_batt_temp_abnormal() )
+		return POWER_SUPPLY_HEALTH_OVERHEAT;
+#endif
+
 	rc = qpnp_chg_read(chip, &batt_health,
 				chip->bat_if_base + CHGR_STATUS, 1);
 	if (rc) {
@@ -2664,6 +2882,28 @@ get_prop_batt_temp(struct qpnp_chg_chip *chip)
 	return (int)results.physical;
 }
 
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+/*
+* PMIC Temperature
+*/
+static int
+get_prop_pmic_temp(struct qpnp_chg_chip *chip)
+{
+	int rc = 0;
+	struct qpnp_vadc_result results;
+
+	rc = qpnp_vadc_read(chip->vadc_dev,DIE_TEMP, &results);
+	if (rc) {
+		pr_debug("Unable to read batt temperature rc=%d\n", rc);
+		return 0;
+	}
+	pr_debug("get_pmic_temp %d %lld\n",
+		results.adc_code, results.physical);
+
+	return (int)results.physical;
+}
+#endif
+
 static int get_prop_cycle_count(struct qpnp_chg_chip *chip)
 {
 	union power_supply_propval ret = {0,};
@@ -2713,7 +2953,9 @@ qpnp_batt_external_power_changed(struct power_supply *psy)
 	if (qpnp_chg_is_usb_chg_plugged_in(chip)) {
 		chip->usb_psy->get_property(chip->usb_psy,
 			  POWER_SUPPLY_PROP_CURRENT_MAX, &ret);
-
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+            DBG_CHARGE(" ret.intval = %d \n" , ret.intval);
+#endif   
 		if (chip->prev_usb_max_ma == ret.intval)
 			goto skip_set_iusb_max;
 
@@ -2859,7 +3101,12 @@ qpnp_batt_power_get_property(struct power_supply *psy,
 	case POWER_SUPPLY_PROP_VCHG_LOOP_DBC_BYPASS:
 		val->intval = qpnp_chg_vchg_loop_debouncer_setting_get(chip);
 		break;
-
+		#ifdef CONFIG_ZTEMT_COMM_CHARGE
+	case POWER_SUPPLY_PROP_CHARGER_ONLINE:
+	   val->intval = qpnp_chg_is_dc_chg_plugged_in(chip) ||
+			                     qpnp_chg_is_usb_chg_plugged_in(chip) ;
+		break;
+	#endif	
 	default:
 		return -EINVAL;
 	}
@@ -2916,6 +3163,10 @@ qpnp_chg_ibatsafe_set(struct qpnp_chg_chip *chip, int safe_current)
 	}
 
 	temp = safe_current / QPNP_CHG_I_STEP_MA;
+	
+	#ifdef CONFIG_ZTEMT_CHG_PARAM_CHECK 
+	pr_info("--CHG_CHECK--safe_current=%d\n", safe_current);
+	#endif
 	return qpnp_chg_masked_write(chip,
 			chip->chgr_base + CHGR_IBAT_SAFE,
 			QPNP_CHG_I_MASK, temp, 1);
@@ -2938,6 +3189,10 @@ qpnp_chg_ibatterm_set(struct qpnp_chg_chip *chip, int term_current)
 
 	temp = (term_current - QPNP_CHG_ITERM_MIN_MA)
 				/ QPNP_CHG_ITERM_STEP_MA;
+	
+	#ifdef CONFIG_ZTEMT_CHG_PARAM_CHECK 
+	pr_info("--CHG_CHECK--term_current=%d\n", term_current);
+	#endif
 	return qpnp_chg_masked_write(chip,
 			chip->chgr_base + CHGR_IBAT_TERM_CHGR,
 			QPNP_CHG_ITERM_MASK, temp, 1);
@@ -2956,6 +3211,10 @@ qpnp_chg_ibatmax_set(struct qpnp_chg_chip *chip, int chg_current)
 		return -EINVAL;
 	}
 	temp = chg_current / QPNP_CHG_I_STEP_MA;
+	
+	#ifdef CONFIG_ZTEMT_CHG_PARAM_CHECK 
+	pr_info("--CHG_CHECK--ibatt_max=%d\n", chg_current);
+	#endif
 	return qpnp_chg_masked_write(chip, chip->chgr_base + CHGR_IBAT_MAX,
 			QPNP_CHG_I_MASK, temp, 1);
 }
@@ -3049,7 +3308,11 @@ qpnp_chg_vddsafe_set(struct qpnp_chg_chip *chip, int voltage)
 		return -EINVAL;
 	}
 	temp = (voltage - QPNP_CHG_V_MIN_MV) / QPNP_CHG_V_STEP_MV;
+	#ifdef CONFIG_ZTEMT_CHG_PARAM_CHECK 
+	pr_info("--CHG_CHECK--vddsafe voltage=%d\n", voltage);
+	#else
 	pr_debug("voltage=%d setting %02x\n", voltage, temp);
+	#endif
 	return qpnp_chg_write(chip, &temp,
 		chip->chgr_base + CHGR_VDD_SAFE, 1);
 }
@@ -3769,8 +4032,13 @@ qpnp_eoc_work(struct work_struct *work)
 		return;
 	}
 
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+	DBG_CHARGE("chgr: 0x%x, bat_if: 0x%x, buck: 0x%x\n",
+		chg_sts, batt_sts, buck_sts);
+#else
 	pr_debug("chgr: 0x%x, bat_if: 0x%x, buck: 0x%x\n",
 		chg_sts, batt_sts, buck_sts);
+#endif
 
 	if (!qpnp_chg_is_usb_chg_plugged_in(chip) &&
 			!qpnp_chg_is_dc_chg_plugged_in(chip)) {
@@ -3783,8 +4051,13 @@ qpnp_eoc_work(struct work_struct *work)
 		ibat_ma = get_prop_current_now(chip) / 1000;
 		vbat_mv = get_prop_battery_voltage_now(chip) / 1000;
 
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+		DBG_CHARGE("ibat_ma = %d vbat_mv = %d term_current_ma = %d\n",
+				ibat_ma, vbat_mv, chip->term_current);
+#else
 		pr_debug("ibat_ma = %d vbat_mv = %d term_current_ma = %d\n",
 				ibat_ma, vbat_mv, chip->term_current);
+#endif
 
 		vbat_lower_than_vbatdet = !(chg_sts & VBAT_DET_LOW_IRQ);
 		if (vbat_lower_than_vbatdet && vbat_mv <
@@ -3838,14 +4111,17 @@ qpnp_eoc_work(struct work_struct *work)
 				pr_debug("psy changed batt_psy\n");
 				power_supply_changed(&chip->batt_psy);
 				qpnp_chg_enable_irq(&chip->chg_vbatdet_lo);
+				#ifdef CONFIG_ZTEMT_COMM_CHARGE_X
+				#else
 				goto stop_eoc;
+                #endif
 			} else {
 				count += 1;
 				pr_debug("EOC count = %d\n", count);
 			}
 		}
 	} else {
-		pr_debug("not charging\n");
+		pr_info("not charging\n");
 		goto stop_eoc;
 	}
 
@@ -4671,9 +4947,16 @@ qpnp_chg_load_battery_data(struct qpnp_chg_chip *chip)
 	struct qpnp_vadc_result result;
 	int rc;
 
+/*
+* CONFIG_ZTEMT_COMM_CHARGE
+ *  
+*/
 	node = of_find_node_by_name(chip->spmi->dev.of_node,
 			"qcom,battery-data");
 	if (node) {
+		#ifdef CONFIG_ZTEMT_COMM_CHARGE
+		DBG_CHARGE(" Modify The Battery Data ! \n");
+		#endif
 		memset(&batt_data, 0, sizeof(struct bms_battery_data));
 		rc = qpnp_vadc_read(chip->vadc_dev, LR_MUX2_BAT_ID, &result);
 		if (rc) {
@@ -4691,11 +4974,18 @@ qpnp_chg_load_battery_data(struct qpnp_chg_chip *chip)
 			return rc;
 		}
 
+/*
+   max_voltage_uv
+*/
 		if (batt_data.max_voltage_uv >= 0) {
 			chip->max_voltage_mv = batt_data.max_voltage_uv / 1000;
 			chip->safe_voltage_mv = chip->max_voltage_mv
 				+ MAX_DELTA_VDD_MAX_MV;
 		}
+		
+		/*
+		 term_current
+		*/
 		if (batt_data.iterm_ua >= 0)
 			chip->term_current = batt_data.iterm_ua / 1000;
 	}
@@ -4713,6 +5003,12 @@ qpnp_chg_hwinit(struct qpnp_chg_chip *chip, u8 subtype,
 	struct regulator_init_data *init_data;
 	struct regulator_desc *rdesc;
 
+	#ifdef CONFIG_ZTEMT_LIQUID_LED
+	//disable RGB_RED LED
+	spmi_ext_register_writel(chip->spmi->ctrl, 1, 0xD045, &reg,1);
+	printk("disable RGB_RED LED\n");
+	#endif
+
 	switch (subtype) {
 	case SMBB_CHGR_SUBTYPE:
 	case SMBBP_CHGR_SUBTYPE:
@@ -5218,6 +5514,357 @@ qpnp_charger_read_dt_props(struct qpnp_chg_chip *chip)
 	return rc;
 }
 
+#ifdef CONFIG_ZTEMT_POWER_DEBUG
+
+static void print_battery_information(struct qpnp_chg_chip *chip)
+{
+  printk("BMS capacity=%d current=%d vbat_uv=%d temp=%d usb_in=%d\n",
+    get_prop_capacity(chip),
+    get_prop_current_now(chip),
+    get_prop_battery_voltage_now(chip),
+    get_prop_batt_temp(chip),
+    qpnp_chg_is_usb_chg_plugged_in(chip));
+}
+
+static void power_debug_work_func(struct work_struct *work)
+{
+	struct qpnp_chg_chip *chip = container_of(work,
+	                                          struct qpnp_chg_chip,
+	                                          power_debug_work.work);
+	printk("power_debug_work_func_______start!\n");
+	//print battery related information
+	print_battery_information(chip);
+	//print wakelocks
+	global_print_active_locks();
+	//wakelock_stats_show_debug();
+	schedule_delayed_work(&chip->power_debug_work,
+			  round_jiffies_relative(msecs_to_jiffies
+						(POWER_MONITOR_PERIOD_MS)));
+	printk("power_debug_work_func_________over!\n");
+
+}
+
+static int power_debug_work_control(int on)
+{
+	int ret;
+	struct qpnp_chg_chip *chip = chip_temp; 
+	if(1==on)
+	{
+		if(1==power_debug_switch)
+		{
+			printk("%s:The power_debug_work is already on\n",__func__);
+			ret=1;
+		}
+		else
+		{
+			power_debug_switch=1;
+			msm_show_resume_irq_mask=1;
+			INIT_DELAYED_WORK(&chip->power_debug_work,  power_debug_work_func);
+			schedule_delayed_work(&chip->power_debug_work,
+			  round_jiffies_relative(msecs_to_jiffies
+						(POWER_MONITOR_PERIOD_MS)));
+
+			printk("%s:enable power_debug_work.\n",__func__);
+		}
+	}
+	else
+	{
+
+		if(0==power_debug_switch)
+		{
+			printk("%s:The power_debu_timer is already off\n",__func__);
+			ret=1;
+		}
+		else
+		{
+			power_debug_switch=0;
+			msm_show_resume_irq_mask=0;
+			cancel_delayed_work(&chip->power_debug_work);
+			printk("%s:disable power_debug_work.\n",__func__);
+		}
+
+	}
+	return ret;
+}
+
+
+static ssize_t po_info_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+
+	sprintf(buf, "%u\n", power_debug_switch);
+	return 1;
+}
+static ssize_t po_info_store(struct device *dev, 
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+
+	unsigned int val;
+
+	if (sscanf(buf, "%u", &val) == 1) {
+		if (power_debug_work_control(val))
+			return count;
+	}
+	return -EINVAL;
+}
+
+static ssize_t clock_dump_show(struct device *dev, 
+		struct device_attribute *attr, char *buf)
+{
+
+	sprintf(buf, "%u\n", power_debug_switch);
+	clock_debug_print_enabled();
+	return 1;
+}
+
+static DEVICE_ATTR(switch, 0644, po_info_show, po_info_store);
+static DEVICE_ATTR(clock_dump, 0644,  clock_dump_show, NULL);
+static struct kobject *po_kobject = NULL;
+
+static int power_debug_init(struct qpnp_chg_chip *chip)
+{
+	int ret;
+	chip_temp = chip;
+	po_kobject = kobject_create_and_add(DRV_NAME, NULL);
+	if(po_kobject == NULL) {
+		ret = -ENOMEM;
+		goto err1;
+	}
+
+	ret = sysfs_create_file(po_kobject, &dev_attr_switch.attr);
+	ret |= sysfs_create_file(po_kobject, &dev_attr_clock_dump.attr);
+	if(ret){
+		goto err;
+	}
+
+	INIT_DELAYED_WORK(&chip->power_debug_work,  power_debug_work_func);
+
+	if(power_debug_switch) {
+	  msm_show_resume_irq_mask=1; //on in default, deleted is allow.
+	  schedule_delayed_work(&chip->power_debug_work,
+			  round_jiffies_relative(msecs_to_jiffies
+						(POWER_MONITOR_PERIOD_MS)));
+	}
+	return 0;
+
+err:
+	kobject_del(po_kobject);
+err1:
+	printk(DRV_NAME": Failed to create sys file\n");
+	return ret;
+}
+#endif
+
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+/*
+* Set iusbMax Current 
+*/
+#define DWC3_IDEV_CHG_MAX 1500
+void qpnp_notify_charger_of_the_charger_type(int i_chg_type)
+{
+
+	if(!g_chip)
+		return ;
+	
+	 g_chip->chg_type = i_chg_type;
+	
+	DBG_CHARGE("chg_type =%d" , i_chg_type);
+	pr_debug("chg_type =%d" , i_chg_type);
+
+	if ( (qpnp_chg_is_usb_chg_plugged_in(g_chip) ||
+	      qpnp_chg_is_dc_chg_plugged_in(g_chip))&&
+	       ( !(g_chip->chg_done)) ) {
+	 
+		if (	qpnp_chg_usb_iusbmax_get(g_chip) < USB_WALL_THRESHOLD_MA ||
+			   (g_chip->chg_type == DWC3_SDP_CHARGER)) {
+		
+			qpnp_chg_iusbmax_set( g_chip , USB_WALL_THRESHOLD_MA);
+		}		    	
+		else if(g_chip->chg_type == DWC3_DCP_CHARGER||
+				g_chip->chg_type == DWC3_CDP_CHARGER||
+				g_chip->chg_type == DWC3_PROPRIETARY_CHARGER||
+				g_chip->chg_type == DWC3_FLOATED_CHARGER){
+		
+			 qpnp_chg_iusbmax_set( g_chip , DWC3_IDEV_CHG_MAX);
+		}
+						  
+	}
+		
+		//qpnp_chg_state_machine_reset(g_chip);
+}
+/*
+* Print The Debug Information
+*/
+static void 
+qpnp_print_debug_info(struct qpnp_chg_chip *chip ){
+	bool is_usb_in = false  ;
+	bool is_dc_in =   false ;
+	 
+	if( qpnp_chg_is_usb_chg_plugged_in(chip) ) {
+		is_usb_in = true ;
+	}
+	else if (qpnp_chg_is_dc_chg_plugged_in(chip)) {
+		is_dc_in = true ;
+	}
+	
+	pr_info("Batt:Soc=%d mV=%d mA=%d Temp=%d Chg:mV=%d Pm:T=%d\n",
+        get_prop_capacity(chip),
+        get_prop_battery_voltage_now(chip)/1000,
+	    get_prop_current_now(chip)/1000,
+		get_prop_batt_temp(chip),
+		get_prop_charger_voltage_now(chip)/1000,
+		get_prop_pmic_temp(chip)/100);	               
+}
+
+//
+
+#define CHG_PMIC_TEMP_HIGH_LIMIT    			700
+#define CHG_PMIC_TEMP_HIGH_RECOVER     		650
+#define CHG_PMIC_BATT_TEMP_DIFF_LIMIT       	300
+#define CHG_PMIC_BATT_TEMP_DIFF_RECOVER     	250
+#define LIMIT_BATT_CURRENT 					300
+
+void is_ibatt_limited_for_temp(int pmic_temperature,int batt_temperature)
+{
+       static bool limit_ibatt_flag = 0;	
+	int rc = 0;	
+
+	if(!g_chip){
+		return ;	
+	}
+		
+	if(g_chip->chg_type!=DWC3_SDP_CHARGER){
+		if((pmic_temperature > CHG_PMIC_TEMP_HIGH_LIMIT)&&
+			((pmic_temperature -batt_temperature)>CHG_PMIC_BATT_TEMP_DIFF_LIMIT)){
+		
+			if((!limit_ibatt_flag)&&(LIMIT_BATT_CURRENT < g_chip->safe_current)){
+			
+				 rc = qpnp_chg_ibatmax_set(g_chip,   LIMIT_BATT_CURRENT);
+
+				 rc |= qpnp_chg_ibatsafe_set(g_chip,   LIMIT_BATT_CURRENT);
+				 if (rc) {
+				 
+					pr_err("Error setting ibatt  property %d\n", rc);
+				 }
+				 limit_ibatt_flag = 1;
+			}
+
+		}	
+		else if((pmic_temperature<CHG_PMIC_TEMP_HIGH_RECOVER)||
+				((pmic_temperature -batt_temperature)<CHG_PMIC_BATT_TEMP_DIFF_RECOVER)){
+		
+			if(limit_ibatt_flag){
+			
+				 rc = qpnp_chg_ibatmax_set(g_chip,   g_chip->max_bat_chg_current );
+			
+				 rc |= qpnp_chg_ibatsafe_set(g_chip,   g_chip->safe_current);
+				 if (rc){
+				 
+					pr_err("Error setting ibatt  property %d\n", rc);
+				 }
+				 limit_ibatt_flag = 0;
+			}
+		}
+	}
+
+}
+
+
+
+
+/*
+* 
+*/
+#define CHG_TEMP_HIGH1   530
+#define CHG_TEMP_LOW1     -60
+
+#define CHG_TEMP_HIGH2   500
+#define CHG_TEMP_LOW2     -50
+
+#define CHG_MONITOR_PERIOD_MS	10000
+
+static void 
+batt_monitor_worker(struct work_struct *work)
+{
+    int batt_temperature;
+    int pmic_temperature = 0;
+    int batt_currtent;
+
+	struct delayed_work *dwork = to_delayed_work(work);
+	struct qpnp_chg_chip *chip = container_of(dwork,
+				struct qpnp_chg_chip, battery_monitor_work );
+
+	qpnp_print_debug_info(chip);
+
+	pmic_temperature = get_prop_pmic_temp(chip)/100;
+	batt_temperature = get_prop_batt_temp(chip);
+	set_batt_temp(batt_temperature); 
+
+	batt_currtent = get_prop_current_now(chip);
+
+	if( is_charger_online() == 0)
+		goto out_work;
+
+	/*wall charger
+	*  PMIC70pmic30
+	* (ibatt) 
+ 	*  PMIC67pmic25
+ 	*  
+	*/	
+	is_ibatt_limited_for_temp(pmic_temperature,batt_temperature);
+
+	/*
+	*   -5, 47
+	*   -6, 50,
+	*/
+	if( batt_temperature > CHG_TEMP_LOW2 && batt_temperature < CHG_TEMP_HIGH2 &&
+		         is_chg_batt_temp_abnormal() ){
+		 
+		DBG_CHARGE(" batt_temperature =%d &&  start charging! \n",batt_temperature);
+		set_chg_batt_temp_st(BATT_TEMP_GOOD);
+		qpnp_chg_charge_en(chip, 1);
+		power_supply_changed(&chip->batt_psy);
+
+	}else if( (batt_temperature > CHG_TEMP_HIGH1 || batt_temperature < CHG_TEMP_LOW1) &&
+	             !is_chg_batt_temp_abnormal() ){
+		DBG_CHARGE(" batt_temperature =%d && stop charging! \n",batt_temperature);
+		qpnp_chg_charge_en(chip, 0);
+		chip->chg_done = false;
+		set_chg_batt_temp_st(BATT_TEMP_ABNORMAL);
+		power_supply_changed(&chip->batt_psy);
+	}
+
+	schedule_delayed_work(&chip->battery_monitor_work,
+			  round_jiffies_relative(msecs_to_jiffies
+						(CHG_MONITOR_PERIOD_MS)));
+	return;
+	
+out_work:
+	set_chg_batt_temp_st(BATT_TEMP_GOOD);
+
+}
+
+/*
+* Charger Is Present
+*/
+static void  
+check_start_monitor_work(struct qpnp_chg_chip *chip)
+{
+//
+    if( chip->usb_present ||chip->dc_present ){
+		set_charger_status(1);
+    }else{
+		set_charger_status(0);
+	}
+	
+	if(is_charger_online()){
+		qpnp_chg_charge_en(chip, 1);
+        schedule_delayed_work(&chip->battery_monitor_work,
+				  round_jiffies_relative(msecs_to_jiffies
+							(CHG_MONITOR_PERIOD_MS)));
+	}
+}
+#endif
 static int __devinit
 qpnp_charger_probe(struct spmi_device *spmi)
 {
@@ -5454,6 +6101,10 @@ qpnp_charger_probe(struct spmi_device *spmi)
 	dev_set_drvdata(&spmi->dev, chip);
 	device_init_wakeup(&spmi->dev, 1);
 
+#ifdef CONFIG_ZTEMT_COMM_CHARGE_X
+ qpnp_chg_state_machine_reset(chip);
+#endif
+
 	chip->insertion_ocv_uv = -EINVAL;
 	chip->batt_present = qpnp_chg_is_batt_present(chip);
 	if (chip->bat_if_base) {
@@ -5490,6 +6141,10 @@ qpnp_charger_probe(struct spmi_device *spmi)
 	INIT_WORK(&chip->soc_check_work, qpnp_chg_soc_check_work);
 	INIT_DELAYED_WORK(&chip->aicl_check_work, qpnp_aicl_check_work);
 
+	#ifdef CONFIG_ZTEMT_COMM_CHARGE
+	INIT_DELAYED_WORK(&chip->battery_monitor_work, batt_monitor_worker);
+	#endif
+
 	if (chip->dc_chgpth_base) {
 		chip->dc_psy.name = "qpnp-dc";
 		chip->dc_psy.type = POWER_SUPPLY_TYPE_MAINS;
@@ -5579,16 +6234,32 @@ qpnp_charger_probe(struct spmi_device *spmi)
 	 * capacity is at zero and no chargers online. */
 	if (qpnp_chg_is_usb_chg_plugged_in(chip))
 		power_supply_set_online(chip->usb_psy, 1);
+   
+	#ifdef CONFIG_ZTEMT_COMM_CHARGE
+		check_start_monitor_work(chip);
+	#endif
 
 	schedule_delayed_work(&chip->aicl_check_work,
 		msecs_to_jiffies(EOC_CHECK_PERIOD_MS));
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+		g_chip = chip;
+#endif
+
 	pr_info("success chg_dis = %d, bpd = %d, usb = %d, dc = %d b_health = %d batt_present = %d\n",
 			chip->charging_disabled,
 			chip->bpd_detection,
 			qpnp_chg_is_usb_chg_plugged_in(chip),
 			qpnp_chg_is_dc_chg_plugged_in(chip),
-			get_prop_batt_present(chip),
-			get_prop_batt_health(chip));
+			get_prop_batt_health(chip),
+			get_prop_batt_present(chip)	);
+	#ifdef CONFIG_ZTEMT_POWER_DEBUG
+	power_debug_init(chip);
+	#endif
+
+#ifdef CONFIG_NX503A_ZTEMT_DEVICE_INFO
+  device_info_init(chip->vadc_dev);
+#endif
+
 	return 0;
 
 unregister_dc_psy:
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
old mode 100644
new mode 100755
index 7a559a6..0d1edf0
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -1144,4 +1144,9 @@ config RTC_DRV_QPNP
 	  To compile this driver as a module, choose M here: the
 	  module will be called qpnp-rtc.
 
+config ZTE_POWEROFF_ALARM
+    tristate "zte poweroff alarm macro"
+    depends on RTC_CLASS
+    help 
+       open poweroffalarm function when is "y"
 endif # RTC_CLASS
diff --git a/drivers/rtc/alarm.c b/drivers/rtc/alarm.c
old mode 100644
new mode 100755
index da8a634..e5bfe24
--- a/drivers/rtc/alarm.c
+++ b/drivers/rtc/alarm.c
@@ -25,7 +25,7 @@
 
 #include <asm/mach/time.h>
 
-#define ALARM_DELTA 120
+#define ALARM_DELTA 60
 #define ANDROID_ALARM_PRINT_ERROR (1U << 0)
 #define ANDROID_ALARM_PRINT_INIT_STATUS (1U << 1)
 #define ANDROID_ALARM_PRINT_TSET (1U << 2)
@@ -542,6 +542,27 @@ static int set_alarm_time_to_rtc(const long power_on_time)
 	rtc_read_time(alarm_rtc_dev, &rtc_time);
 	getnstimeofday(&wall_time);
 	rtc_tm_to_time(&rtc_time, &rtc_secs);
+    if((power_on_time-rtc_secs)<(2*365*8*24*3600L)&&power_on_time>rtc_secs)
+    	{
+		alarm_time = power_on_time - ALARM_DELTA;
+		if (alarm_time <= rtc_secs)
+				goto disable_alarm;
+		
+		rtc_time_to_tm(alarm_time, &alarm.time);
+		alarm.enabled = 1;
+		rc = rtc_set_alarm(alarm_rtc_dev, &alarm);
+		
+		if (rc){
+			pr_alarm(ERROR, "Unable to set power-on alarm\n");
+			goto disable_alarm;
+		}
+		else
+			pr_alarm(FLOW, "Power-on alarm set to %lu\n",
+					alarm_time);
+		
+		return 0;
+	}else
+		{
 	alarm_delta = wall_time.tv_sec - rtc_secs;
 	alarm_time = power_on_time - alarm_delta;
 
@@ -568,7 +589,7 @@ static int set_alarm_time_to_rtc(const long power_on_time)
 				alarm_time);
 
 	return 0;
-
+		}
 disable_alarm:
 	rtc_alarm_irq_enable(alarm_rtc_dev, 0);
 	return rc;
diff --git a/drivers/rtc/qpnp-rtc.c b/drivers/rtc/qpnp-rtc.c
index e0d5c1e..82acd1e 100644
--- a/drivers/rtc/qpnp-rtc.c
+++ b/drivers/rtc/qpnp-rtc.c
@@ -618,6 +618,58 @@ fail_rtc_enable:
 	return rc;
 }
 
+#ifdef CONFIG_ZTEMT_POWER_DEBUG
+static time_t rtc_suspend_sec = 0;
+static time_t rtc_resume_sec = 0;
+static unsigned long all_sleep_time = 0;
+static unsigned long all_wake_time = 0;
+
+static int print_suspend_time(struct device *dev)
+{
+	int rc, diff=0;
+	struct rtc_time tm;
+	unsigned long now;
+
+	rc = qpnp_rtc_read_time(dev,&tm);  
+ 	if(rc) {
+	  printk("%s: Unable to read from RTC\n", __func__);
+	}
+
+	rtc_tm_to_time(&tm, &now);
+	rtc_suspend_sec = now;
+	diff = rtc_suspend_sec - rtc_resume_sec;
+	all_wake_time += diff;
+	printk("I have work %d seconds all_wake_time %lu seconds\n",diff,all_wake_time);
+
+	return 0;
+}
+
+static int print_resume_time(struct device *dev)
+{
+	int rc, diff=0;
+	struct rtc_time tm;
+	unsigned long now;
+
+	rc = qpnp_rtc_read_time(dev,&tm);
+ 	if (rc) {
+	  printk("%s: Unable to read from RTC\n", __func__);
+	}
+
+	rtc_tm_to_time(&tm, &now);
+	rtc_resume_sec = now;
+	diff = rtc_resume_sec - rtc_suspend_sec;
+	all_sleep_time += diff;
+	printk("I have sleep %d seconds all_sleep_time %lu seconds\n",diff,all_sleep_time);
+
+	return 0;
+}
+
+static const struct dev_pm_ops qpnp_rtc_pm_ops = {
+	.suspend = print_suspend_time,
+	.resume = print_resume_time,
+};
+#endif
+
 static int __devexit qpnp_rtc_remove(struct spmi_device *spmi)
 {
 	struct qpnp_rtc *rtc_dd = dev_get_drvdata(&spmi->dev);
@@ -680,6 +732,9 @@ static struct spmi_driver qpnp_rtc_driver = {
 		.name   = "qcom,qpnp-rtc",
 		.owner  = THIS_MODULE,
 		.of_match_table = spmi_match_table,
+		#ifdef CONFIG_ZTEMT_POWER_DEBUG
+		.pm	= &qpnp_rtc_pm_ops,
+		#endif
 	},
 };
 
diff --git a/drivers/spmi/spmi.c b/drivers/spmi/spmi.c
old mode 100644
new mode 100755
index 43f2710..3cc0111
--- a/drivers/spmi/spmi.c
+++ b/drivers/spmi/spmi.c
@@ -251,8 +251,18 @@ int spmi_add_device(struct spmi_device *spmidev)
 		return -EINVAL;
 	}
 
+#ifdef CONFIG_NX503A_ZTEMT_DEVICE_INFO
+	if(strncmp(spmidev->name,"qpnp-ztemt_hw_version",strlen("qpnp-ztemt_hw_version"))==0)
+	{
+	   dev_set_name(dev, "%s", spmidev->name);
+    }else{	
+	   /* Set the device name */
+	   dev_set_name(dev, "%s-%p", spmidev->name, spmidev);
+	}
+#else
 	/* Set the device name */
 	dev_set_name(dev, "%s-%p", spmidev->name, spmidev);
+#endif
 
 	/* Device may be bound to an active driver when this returns */
 	rc = device_add(dev);
diff --git a/drivers/switch/switch_gpio.c b/drivers/switch/switch_gpio.c
old mode 100644
new mode 100755
index 7e9faa2..cb91ded
--- a/drivers/switch/switch_gpio.c
+++ b/drivers/switch/switch_gpio.c
@@ -24,6 +24,9 @@
 #include <linux/switch.h>
 #include <linux/workqueue.h>
 #include <linux/gpio.h>
+#ifdef CONFIG_OF
+#include <linux/of_gpio.h>
+#endif
 
 struct gpio_switch_data {
 	struct switch_dev sdev;
@@ -70,14 +73,44 @@ static ssize_t switch_gpio_print_state(struct switch_dev *sdev, char *buf)
 	return -1;
 }
 
+#ifdef CONFIG_OF
+static int gpio_switch_get_devtree_pdata(struct device *dev,
+			    struct gpio_switch_platform_data *pdata)
+{
+	struct device_node *node;
+	enum of_gpio_flags flags;
+
+	node = dev->of_node;
+	if (node == NULL)
+		return -ENODEV;
+
+	memset(pdata, 0, sizeof *pdata);
+
+	pdata->name = of_get_property(node, "input-name", NULL);
+	pdata->gpio = of_get_gpio_flags(node, 0, &flags);
+	return 0;
+}
+#endif
+
 static int gpio_switch_probe(struct platform_device *pdev)
 {
 	struct gpio_switch_platform_data *pdata = pdev->dev.platform_data;
 	struct gpio_switch_data *switch_data;
 	int ret = 0;
-
+#ifdef CONFIG_OF
+	struct device *dev = &pdev->dev;
+	struct gpio_switch_platform_data alt_pdata;
+	int error;
+	if (!pdata) {
+		error = gpio_switch_get_devtree_pdata(dev, &alt_pdata);
+		if (error)
+			return error;
+		pdata = &alt_pdata;
+	}
+#else
 	if (!pdata)
 		return -EBUSY;
+#endif
 
 	switch_data = kzalloc(sizeof(struct gpio_switch_data), GFP_KERNEL);
 	if (!switch_data)
@@ -111,8 +144,13 @@ static int gpio_switch_probe(struct platform_device *pdev)
 		goto err_detect_irq_num_failed;
 	}
 
+#ifdef CONFIG_SWITCH_GPIO
+	ret = request_irq(switch_data->irq, gpio_irq_handler,
+			  IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, pdev->name, switch_data);
+#else
 	ret = request_irq(switch_data->irq, gpio_irq_handler,
 			  IRQF_TRIGGER_LOW, pdev->name, switch_data);
+#endif
 	if (ret < 0)
 		goto err_request_irq;
 
@@ -133,6 +171,13 @@ err_switch_dev_register:
 	return ret;
 }
 
+#ifdef CONFIG_OF
+static const struct of_device_id gpio_switch_dt_match[] = {
+	{.compatible = "nubia,switch-gpio"},
+	{}
+};
+#endif
+
 static int __devexit gpio_switch_remove(struct platform_device *pdev)
 {
 	struct gpio_switch_data *switch_data = platform_get_drvdata(pdev);
@@ -151,6 +196,9 @@ static struct platform_driver gpio_switch_driver = {
 	.driver		= {
 		.name	= "switch-gpio",
 		.owner	= THIS_MODULE,
+		#ifdef CONFIG_OF
+		.of_match_table = gpio_switch_dt_match,
+		#endif
 	},
 };
 
diff --git a/drivers/tty/serial/msm_serial_hs_lite.c b/drivers/tty/serial/msm_serial_hs_lite.c
old mode 100644
new mode 100755
index 0ff8ad7..bb81c7a
--- a/drivers/tty/serial/msm_serial_hs_lite.c
+++ b/drivers/tty/serial/msm_serial_hs_lite.c
@@ -1840,6 +1840,10 @@ static int __devinit msm_serial_hsl_probe(struct platform_device *pdev)
 	if (msm_hsl_port->pclk)
 		clk_disable_unprepare(msm_hsl_port->pclk);
 
+#ifdef CONFIG_ZTEMT_HSL_UART_DMEN_PATCH
+    msm_hsl_write(port, 0, regmap[msm_hsl_port->ver_id][UARTDM_DMEN]);
+#endif
+
 err:
 	return ret;
 }
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
old mode 100644
new mode 100755
index fddb4fe..23dd600
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -122,6 +122,20 @@ config USB
 	  To compile this driver as a module, choose M here: the
 	  module will be called usbcore.
 
+config ZTEMT_USB
+	boolean "Support for ZTEMT USB Driver"
+	depends on USB
+	default y
+	help
+	  Say Y here if you need to modify USB related code for ZTEMT projects,
+	  and remember to use CONFIG_ZTEMT_USB to mark your code.
+
+config ZTEMT_USB_DEBUG
+	boolean "Support for ZTEMT USB DEBUG info"
+	depends on USB
+	default y
+	help
+	  Use ZTEMT USB driver debug info.
 source "drivers/usb/core/Kconfig"
 
 source "drivers/usb/dwc3/Kconfig"
diff --git a/drivers/usb/dwc3/dwc3-msm.c b/drivers/usb/dwc3/dwc3-msm.c
old mode 100644
new mode 100755
index 35334c0..51636ae
--- a/drivers/usb/dwc3/dwc3-msm.c
+++ b/drivers/usb/dwc3/dwc3-msm.c
@@ -74,7 +74,30 @@ module_param(ss_phy_override_deemphasis, int, S_IRUGO|S_IWUSR);
 MODULE_PARM_DESC(ss_phy_override_deemphasis, "Override SSPHY demphasis value");
 
 /* Enable Proprietary charger detection */
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+static bool prop_chg_detect = 1;
+#else
 static bool prop_chg_detect;
+#endif
+
+#ifdef CONFIG_ZTEMT_COMM_CHARGE_X
+#define zte_dev_dbg(dev, format, ...)		     \
+dev_printk(KERN_DEBUG, dev, format, ##__VA_ARGS__)
+#undef dev_dbg
+#define dev_dbg   zte_dev_dbg
+
+//
+#undef KERN_DEBUG
+#define KERN_DEBUG  KERN_ERR
+#undef KERN_INFO
+#define KERN_INFO KERN_ERR
+#endif
+
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+extern int qpnp_chg_is_chg_plugged_in(void);
+#endif
+
+
 module_param(prop_chg_detect, bool, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(prop_chg_detect, "Enable Proprietary charger detection");
 
@@ -1856,7 +1879,10 @@ static void dwc3_chg_detect_work(struct work_struct *w)
 			dwc3_msm_write_readback(mdwc->base,
 					CHARGING_DET_CTRL_REG, 0x1F, 0x10);
 			if (mdwc->ext_chg_opened) {
+				#ifdef CONFIG_ZTEMT_COMM_CHARGE
+				#else
 				init_completion(&mdwc->ext_chg_wait);
+				#endif
 				mdwc->ext_chg_active = true;
 			}
 		}
@@ -2386,12 +2412,19 @@ static int dwc3_msm_power_get_property_usb(struct power_supply *psy,
 	case POWER_SUPPLY_PROP_CURRENT_MAX:
 		val->intval = mdwc->current_max;
 		break;
+	#ifdef CONFIG_ZTEMT_COMM_CHARGE
+	case POWER_SUPPLY_PROP_PRESENT:
+  	case POWER_SUPPLY_PROP_ONLINE:
+  		val->intval = qpnp_chg_is_chg_plugged_in();
+		break;		
+	#else		
 	case POWER_SUPPLY_PROP_PRESENT:
 		val->intval = mdwc->vbus_active;
 		break;
 	case POWER_SUPPLY_PROP_ONLINE:
 		val->intval = mdwc->online;
 		break;
+	#endif	
 	case POWER_SUPPLY_PROP_TYPE:
 		val->intval = psy->type;
 		break;
@@ -2445,6 +2478,10 @@ static int dwc3_msm_power_set_property_usb(struct power_supply *psy,
 		break;
 	case POWER_SUPPLY_PROP_CURRENT_MAX:
 		mdwc->current_max = val->intval;
+		#ifdef CONFIG_ZTEMT_COMM_CHARGE
+		if(mdwc->dev)
+			dev_dbg(mdwc->dev, "%s: current_max = %d \n", __func__, mdwc->current_max);
+		#endif
 		break;
 	case POWER_SUPPLY_PROP_TYPE:
 		psy->type = val->intval;
diff --git a/drivers/usb/dwc3/dwc3_otg.c b/drivers/usb/dwc3/dwc3_otg.c
old mode 100644
new mode 100755
index e3d339c..09a25c2
--- a/drivers/usb/dwc3/dwc3_otg.c
+++ b/drivers/usb/dwc3/dwc3_otg.c
@@ -24,6 +24,23 @@
 #include "io.h"
 #include "xhci.h"
 
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+#include <linux/qpnp/qpnp-adc.h>
+#endif
+
+#ifdef CONFIG_ZTEMT_COMM_CHARGE_X
+#define zte_dev_dbg(dev, format, ...)		     \
+dev_printk(KERN_DEBUG, dev, format, ##__VA_ARGS__)
+#undef dev_dbg
+#define dev_dbg   zte_dev_dbg
+
+//
+#undef KERN_DEBUG
+#define KERN_DEBUG  KERN_ERR
+#undef KERN_INFO
+#define KERN_INFO KERN_ERR
+#endif
+
 #define VBUS_REG_CHECK_DELAY	(msecs_to_jiffies(1000))
 #define MAX_INVALID_CHRGR_RETRY 3
 static int max_chgr_retry_count = MAX_INVALID_CHRGR_RETRY;
@@ -399,6 +416,10 @@ static void dwc3_ext_chg_det_done(struct usb_otg *otg, struct dwc3_charger *chg)
 	 */
 	if (test_bit(B_SESS_VLD, &dotg->inputs))
 		queue_delayed_work(system_nrt_wq, &dotg->sm_work, 0);
+
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+	 qpnp_notify_charger_of_the_charger_type((int)chg->chg_type);
+#endif
 }
 
 /**
@@ -549,6 +570,9 @@ static int dwc3_otg_set_power(struct usb_phy *phy, unsigned mA)
 	else if (dotg->charger->chg_type == DWC3_CDP_CHARGER)
 		power_supply_type = POWER_SUPPLY_TYPE_USB_CDP;
 	else if (dotg->charger->chg_type == DWC3_DCP_CHARGER ||
+		#ifdef CONFIG_ZTEMT_COMM_CHARGE
+	          dotg->charger->chg_type == DWC3_FLOATED_CHARGER ||
+   #endif
 			dotg->charger->chg_type == DWC3_PROPRIETARY_CHARGER)
 		power_supply_type = POWER_SUPPLY_TYPE_USB_DCP;
 	else
@@ -782,6 +806,12 @@ static void dwc3_otg_sm_work(struct work_struct *w)
 					work = 1;
 					break;
 				case DWC3_FLOATED_CHARGER:
+				#ifdef CONFIG_ZTEMT_COMM_CHARGE
+					dev_dbg(phy->dev, "lpm, FLOATED charger\n");
+					dwc3_otg_set_power(phy,
+							DWC3_IDEV_CHG_MAX);
+					pm_runtime_put_sync(phy->dev);		
+				#else				
 					if (dotg->charger_retry_count <
 							max_chgr_retry_count)
 						dotg->charger_retry_count++;
@@ -802,6 +832,7 @@ static void dwc3_otg_sm_work(struct work_struct *w)
 					}
 					charger->start_detection(dotg->charger,
 									false);
+                                   #endif
 
 				default:
 					dev_dbg(phy->dev, "chg_det started\n");
diff --git a/drivers/usb/dwc3/dwc3_otg.h b/drivers/usb/dwc3/dwc3_otg.h
old mode 100644
new mode 100755
index 3a75b0a..26bad2c5
--- a/drivers/usb/dwc3/dwc3_otg.h
+++ b/drivers/usb/dwc3/dwc3_otg.h
@@ -22,7 +22,11 @@
 #include <linux/usb/otg.h>
 #include "power.h"
 
+#ifdef  CONFIG_ZTEMT_NX503A_CHARGE
+#define DWC3_IDEV_CHG_MAX 1000
+#else
 #define DWC3_IDEV_CHG_MAX 1500
+#endif
 
 struct dwc3_charger;
 
diff --git a/drivers/usb/gadget/android.c b/drivers/usb/gadget/android.c
old mode 100644
new mode 100755
index 4de97f56..655b9fc
--- a/drivers/usb/gadget/android.c
+++ b/drivers/usb/gadget/android.c
@@ -1790,7 +1790,12 @@ static int mass_storage_function_init(struct android_usb_function *f,
 		snprintf(name[config->fsg.nluns], MAX_LUN_NAME, "lun0");
 		config->fsg.nluns++;
 	}
+
+#ifdef CONFIG_ZTEMT_USB
+	if (dev->pdata && dev->pdata->external_ums) {
+#else
 	if (dev->pdata && dev->pdata->internal_ums) {
+#endif
 		config->fsg.luns[config->fsg.nluns].cdrom = 0;
 		config->fsg.luns[config->fsg.nluns].ro = 0;
 		config->fsg.luns[config->fsg.nluns].removable = 1;
@@ -1810,6 +1815,11 @@ static int mass_storage_function_init(struct android_usb_function *f,
 		config->fsg.nluns++;
 	}
 
+#ifdef CONFIG_ZTEMT_USB
+	config->fsg.vendor_name = "nubia";
+	config->fsg.product_name = "Android";
+#endif
+
 	common = fsg_common_init(NULL, cdev, &config->fsg);
 	if (IS_ERR(common)) {
 		kfree(config);
@@ -2564,6 +2574,9 @@ static DEVICE_ATTR(field, S_IRUGO | S_IWUSR, field ## _show, field ## _store);
 DESCRIPTOR_ATTR(idVendor, "%04x\n")
 DESCRIPTOR_ATTR(idProduct, "%04x\n")
 DESCRIPTOR_ATTR(bcdDevice, "%04x\n")
+#ifdef CONFIG_ZTEMT_USB
+DESCRIPTOR_ATTR(bcdUSB, "%04x\n")
+#endif
 DESCRIPTOR_ATTR(bDeviceClass, "%d\n")
 DESCRIPTOR_ATTR(bDeviceSubClass, "%d\n")
 DESCRIPTOR_ATTR(bDeviceProtocol, "%d\n")
@@ -2584,6 +2597,9 @@ static struct device_attribute *android_usb_attributes[] = {
 	&dev_attr_idVendor,
 	&dev_attr_idProduct,
 	&dev_attr_bcdDevice,
+#ifdef CONFIG_ZTEMT_USB
+	&dev_attr_bcdUSB,
+#endif
 	&dev_attr_bDeviceClass,
 	&dev_attr_bDeviceSubClass,
 	&dev_attr_bDeviceProtocol,
@@ -2968,8 +2984,13 @@ static int __devinit android_probe(struct platform_device *pdev)
 				&pdata->swfi_latency);
 		pdata->cdrom = of_property_read_bool(pdev->dev.of_node,
 				"qcom,android-usb-cdrom");
+#ifdef CONFIG_ZTEMT_USB
+		pdata->external_ums = of_property_read_bool(pdev->dev.of_node,
+				"qcom,android-usb-external-ums");
+#else
 		pdata->internal_ums = of_property_read_bool(pdev->dev.of_node,
 				"qcom,android-usb-internal-ums");
+#endif
 		len = of_property_count_strings(pdev->dev.of_node,
 				"qcom,streaming-func");
 		if (len > MAX_STREAMING_FUNCS) {
diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
old mode 100644
new mode 100755
index fe0b20f..fe8d892
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -1148,6 +1148,10 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 				cdev->desc.bcdUSB = cpu_to_le16(0x0210);
 				DBG(cdev, "Config HS device with LPM(L1)\n");
 			}
+#ifdef CONFIG_ZTEMT_USB
+			if(composite)
+				composite->dev->bcdUSB = cdev->desc.bcdUSB;
+#endif
 
 			value = min(w_length, (u16) sizeof cdev->desc);
 			memcpy(req->buf, &cdev->desc, value);
diff --git a/drivers/video/msm/mdss/Kconfig b/drivers/video/msm/mdss/Kconfig
old mode 100644
new mode 100755
index 01edf92..4378516
--- a/drivers/video/msm/mdss/Kconfig
+++ b/drivers/video/msm/mdss/Kconfig
@@ -35,3 +35,56 @@ config FB_MSM_MDSS_MDP3
 	---help---
 	The MDP3 provides support for an older version display controller
 	included in latest display sub-system, known as MDSS.
+#mayu 2012.12.19
+menu "ZTEMT lcd driver support"
+config ZTEMT_LCD_MIPI_COMMON
+	bool "ztemt lcd MIPI interface driver module"
+	default n
+config ZTEMT_QCOMM_I2C6
+       bool "qcomm i2c6"
+       default n
+       help
+         qcomm i2c6
+config ZTEMT_LCD_POWER_CONTRL
+	bool "ztemt lcd AVDD IOVDD contrl"
+	depends on ZTEMT_LCD_MIPI_COMMON
+	default n
+#luochangyang 2014/03/07
+
+choice
+	prompt "MIPI 1080P R63311 SHARP IPS 5P0"
+	depends on ZTEMT_MIPI_1080P_R63311_SHARP_IPS_5P0
+
+config ZTEMT_MIPI_1080P_R63311_SHARP_IPS_5P0_NX503A
+	bool "MIPI 1080P R63311 SHARP IPS 5.0 FOR NX503A"
+	help
+	  This option enables support 5.0 inch LCD for NX503A.
+
+endchoice
+
+config ZTEMT_LCD_AVDD_CONFIG_BY_TPS65132
+    bool "ztemt lcd AVDD config by tps65132"
+	depends on ZTEMT_LCD_MIPI_COMMON
+	default n
+	
+config ZTEMT_LCD_DISP_ENHANCE
+	bool "LCD disp color enhance"
+	depends on ZTEMT_LCD_MIPI_COMMON
+	default n
+	
+config ZTEMT_LCD_DEBUG_EN
+	bool "LCD debug log enable"
+	depends on ZTEMT_LCD_MIPI_COMMON
+	default n
+#luochangyang END
+config ZTEMT_LCD_BACKLIGHT
+	bool "ztemt lcd backlight"
+	depends on ZTEMT_LCD_MIPI_COMMON
+	default n
+
+config ZTEMT_LCD_BACKLIGHT_LINEAR_CONTROL_METHOLD
+	bool "ztemt lcd backlight linear control methold"
+	depends on ZTEMT_LCD_MIPI_COMMON
+	default n
+
+endmenu
diff --git a/drivers/video/msm/mdss/Makefile b/drivers/video/msm/mdss/Makefile
old mode 100644
new mode 100755
index 4eb1033..d92784d
--- a/drivers/video/msm/mdss/Makefile
+++ b/drivers/video/msm/mdss/Makefile
@@ -44,3 +44,20 @@ obj-$(CONFIG_FB_MSM_QPIC_ILI_QVGA_PANEL) += qpic_panel_ili_qvga.o
 obj-$(CONFIG_FB_MSM_MDSS) += mdss_fb.o
 
 obj-$(CONFIG_FB_MSM_MDSS_DSI_CTRL_STATUS) += mdss_dsi_status.o
+
+# luochangyang For LCD 2014/03/12
+obj-$(CONFIG_ZTEMT_LCD_AVDD_CONFIG_BY_TPS65132) += zte_tps65132.o
+obj-$(CONFIG_ZTEMT_LCD_DISP_ENHANCE) += zte_disp_enhance.o
+
+ifeq ($(CONFIG_ZTEMT_LCD_DEBUG_EN),y)
+CFLAGS_mdss_fb.o += -DDEBUG
+CFLAGS_mdss_dsi.o += -DDEBUG
+CFLAGS_mdss_dsi_host.o += -DDEBUG
+CFLAGS_mdss_dsi_cmd.o += -DDEBUG
+CFLAGS_mdss_dsi_panel.o += -DDEBUG
+CFLAGS_zte_tps65132.o += -DDEBUG
+CFLAGS_zte_disp_enhance.o += -DDEBUG
+endif
+# luochangyang END
+
+obj-$(CONFIG_ZTEMT_LCD_BACKLIGHT) +=zte_backlight.o
diff --git a/drivers/video/msm/mdss/mdss_dsi.c b/drivers/video/msm/mdss/mdss_dsi.c
old mode 100644
new mode 100755
index d9cce6a..c491391
--- a/drivers/video/msm/mdss/mdss_dsi.c
+++ b/drivers/video/msm/mdss/mdss_dsi.c
@@ -27,6 +27,8 @@
 #include "mdss_dsi.h"
 #include "mdss_debug.h"
 
+#include "zte_disp_enhance.h"
+
 static int mdss_dsi_regulator_init(struct platform_device *pdev)
 {
 	struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;
@@ -765,6 +767,14 @@ static int mdss_dsi_unblank(struct mdss_panel_data *pdata)
 		}
 		ctrl_pdata->ctrl_state |= CTRL_STATE_PANEL_INIT;
 	}
+	
+#ifdef CONFIG_ZTEMT_LCD_DISP_ENHANCE
+	/*add init code second part,mayu add 3.5*/
+	pr_debug("%s:\n", __func__);
+	if (ctrl_pdata->boot_enhance == 0) {
+		zte_boot_begin_enhance(ctrl_pdata);
+	}
+#endif
 
 	if (pdata->panel_info.type == MIPI_CMD_PANEL) {
 		if (mipi->vsync_enable && mipi->hw_vsync_mode
@@ -1530,6 +1540,24 @@ int dsi_panel_device_register(struct device_node *pan_node,
 		pr_err("%s:%d, reset gpio not specified\n",
 						__func__, __LINE__);
 
+#ifdef CONFIG_ZTEMT_LCD_POWER_CONTRL
+/*avdd neg ctl board2 add ,mayu 6.25*/
+	ctrl_pdata->avdd_neg_en_gpio = of_get_named_gpio(ctrl_pdev->dev.of_node,
+						     "qcom,platform-avddn-enable-gpio", 0);
+	if (!gpio_is_valid(ctrl_pdata->avdd_neg_en_gpio)) {
+		pr_err("%s:%d, avdd_neg_en_gpio gpio not specified\n",
+						__func__, __LINE__);
+	} else {
+		rc = gpio_request(ctrl_pdata->avdd_neg_en_gpio, "lcd_avdd_neg_enable");
+		if (rc) {
+			pr_err("request reset gpio failed, rc=%d\n",
+			       rc);
+			gpio_free(ctrl_pdata->avdd_neg_en_gpio);
+			return -ENODEV;
+		}
+	}
+#endif
+
 	if (pinfo->mode_gpio_state != MODE_GPIO_NOT_VALID) {
 
 		ctrl_pdata->mode_gpio = of_get_named_gpio(
diff --git a/drivers/video/msm/mdss/mdss_dsi.h b/drivers/video/msm/mdss/mdss_dsi.h
old mode 100644
new mode 100755
index 53ae680..f20d31f
--- a/drivers/video/msm/mdss/mdss_dsi.h
+++ b/drivers/video/msm/mdss/mdss_dsi.h
@@ -271,10 +271,15 @@ struct mdss_dsi_ctrl_pdata {
 	int irq_cnt;
 	int rst_gpio;
 	int disp_en_gpio;
+#ifdef CONFIG_ZTEMT_LCD_POWER_CONTRL
+/*avdd neg ctl board2 add ,mayu 6.25*/
+  int avdd_neg_en_gpio;
+#endif
 	int disp_te_gpio;
 	int mode_gpio;
 	int disp_te_gpio_requested;
 	int bklt_ctrl;	/* backlight ctrl */
+    u8  bklt_ctrl_dcs_reg;
 	int pwm_period;
 	int pwm_pmic_gpio;
 	int pwm_lpg_chan;
@@ -292,6 +297,13 @@ struct mdss_dsi_ctrl_pdata {
 	struct mdss_panel_recovery *recovery;
 
 	struct dsi_panel_cmds on_cmds;
+
+#ifdef CONFIG_ZTEMT_LCD_DISP_ENHANCE
+/*add init code second part,mayu add 3.5*/
+	struct dsi_panel_cmds on_second_cmds;
+	int boot_enhance;
+#endif
+
 	struct dsi_panel_cmds off_cmds;
 	struct dsi_panel_cmds status_cmds;
 	u32 status_value;
diff --git a/drivers/video/msm/mdss/mdss_dsi_panel.c b/drivers/video/msm/mdss/mdss_dsi_panel.c
old mode 100644
new mode 100755
index 871865f..d4bcec0
--- a/drivers/video/msm/mdss/mdss_dsi_panel.c
+++ b/drivers/video/msm/mdss/mdss_dsi_panel.c
@@ -23,6 +23,11 @@
 #include <linux/err.h>
 
 #include "mdss_dsi.h"
+#include "zte_disp_enhance.h"
+#include "zte_tps65132.h"
+#ifdef CONFIG_ZTEMT_LCD_BACKLIGHT
+#include "zte_backlight.h"
+#endif
 
 #define DT_CMD_HDR 6
 
@@ -145,19 +150,55 @@ static void mdss_dsi_panel_cmds_send(struct mdss_dsi_ctrl_pdata *ctrl,
 	mdss_dsi_cmdlist_put(ctrl, &cmdreq);
 }
 
-static char led_pwm1[2] = {0x51, 0x0};	/* DTYPE_DCS_WRITE1 */
+#if 0
+
+u32 mdss_dsi_panel_reg_read(struct mdss_dsi_ctrl_pdata *ctrl)
+{
+	u32 val = 0;
+	char rbuf[4];
+	char reg = 0x56;
+
+	mdss_dsi_panel_cmd_read(ctrl, reg, 0x00, NULL, rbuf, 1);
+	val = rbuf[0];
+
+	pr_info("%s: 0x%x,  val=0x%x, val=%d\n", __func__, reg, val, val);
+
+	return 0;
+}
+
+#endif
+
+static char led_pwm1[] = {0x51, 0x00, 0x00};	/* DTYPE_DCS_WRITE */
 static struct dsi_cmd_desc backlight_cmd = {
-	{DTYPE_DCS_WRITE1, 1, 0, 0, 1, sizeof(led_pwm1)},
-	led_pwm1
+	{DTYPE_DCS_LWRITE, 1, 0, 0, 1, sizeof(led_pwm1)}, led_pwm1
 };
 
 static void mdss_dsi_panel_bklt_dcs(struct mdss_dsi_ctrl_pdata *ctrl, int level)
 {
 	struct dcs_cmd_req cmdreq;
 
-	pr_debug("%s: level=%d\n", __func__, level);
-
-	led_pwm1[1] = (unsigned char)level;
+    led_pwm1[0] =  ctrl->bklt_ctrl_dcs_reg;
+
+    if (0 == level) 
+    {
+        led_pwm1[1] = 0x00;
+        led_pwm1[2] = 0x00;
+    }
+    else 
+    {
+        if (ctrl->panel_data.panel_info.bl_max <= 0xff) //bl_max <= 1Byte
+        {
+            led_pwm1[1] = level & 0xff;
+        }
+        else
+        {
+            if (ctrl->panel_data.panel_info.bl_max <= 0xffff)  //1Byte <= bl_max <= 2Bytes
+            {
+                led_pwm1[1] = (level & 0xf00) >> 8;
+                led_pwm1[2] = level & 0xff;
+            }
+        }
+    }
 
 	memset(&cmdreq, 0, sizeof(cmdreq));
 	cmdreq.cmds = &backlight_cmd;
@@ -207,6 +248,42 @@ disp_en_gpio_err:
 	return rc;
 }
 
+/*luochangyang for sequence 2014/06/09*/
+/*Power On by LCM spec*/
+
+void ztemt_poweron_avdd_neg(struct mdss_dsi_ctrl_pdata *ctrl_pdata)
+{
+	mdelay(1);
+
+	if (gpio_is_valid(ctrl_pdata->disp_en_gpio))
+		gpio_set_value((ctrl_pdata->disp_en_gpio), 1);
+
+	if (gpio_is_valid(ctrl_pdata->avdd_neg_en_gpio))
+		gpio_set_value((ctrl_pdata->avdd_neg_en_gpio), 1);
+
+	mdelay(1);
+}
+
+/*Power Off by LCM spec*/
+void ztemt_poweroff_avdd_neg(struct mdss_dsi_ctrl_pdata *ctrl_pdata)
+{
+	gpio_set_value((ctrl_pdata->rst_gpio), 0);
+	gpio_free(ctrl_pdata->rst_gpio);
+
+	if (gpio_is_valid(ctrl_pdata->avdd_neg_en_gpio)) {
+		gpio_set_value((ctrl_pdata->avdd_neg_en_gpio), 0);
+	}
+
+	if (gpio_is_valid(ctrl_pdata->disp_en_gpio)) {
+			gpio_set_value((ctrl_pdata->disp_en_gpio), 0);
+			gpio_free(ctrl_pdata->disp_en_gpio);
+		}
+
+	mdelay(100);
+}
+
+/*luochangyang END*/
+
 int mdss_dsi_panel_reset(struct mdss_panel_data *pdata, int enable)
 {
 	struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;
@@ -222,7 +299,7 @@ int mdss_dsi_panel_reset(struct mdss_panel_data *pdata, int enable)
 				panel_data);
 
 	if (!gpio_is_valid(ctrl_pdata->disp_en_gpio)) {
-		pr_debug("%s:%d, reset line not configured\n",
+		pr_debug("%s:%d, disp_en_gpio not configured\n",
 			   __func__, __LINE__);
 	}
 
@@ -241,15 +318,29 @@ int mdss_dsi_panel_reset(struct mdss_panel_data *pdata, int enable)
 			pr_err("gpio request failed\n");
 			return rc;
 		}
+		
+		pr_debug("%s: pinfo->panel_power_on = %d\n", __func__, pinfo->panel_power_on);
+
 		if (!pinfo->panel_power_on) {
+/*luochangyang for sequence 2014/06/09*/
+#ifdef CONFIG_ZTEMT_LCD_POWER_CONTRL
+			ztemt_poweron_avdd_neg(ctrl_pdata);
+#else
 			if (gpio_is_valid(ctrl_pdata->disp_en_gpio))
 				gpio_set_value((ctrl_pdata->disp_en_gpio), 1);
+#endif
+/*luochangyang END*/
 
 			for (i = 0; i < pdata->panel_info.rst_seq_len; ++i) {
 				gpio_set_value((ctrl_pdata->rst_gpio),
 					pdata->panel_info.rst_seq[i]);
 				if (pdata->panel_info.rst_seq[++i])
+        		//mayu modify for accelerate
+        		#if 1
+					mdelay(pinfo->rst_seq[i]);
+				#else
 					usleep(pinfo->rst_seq[i] * 1000);
+				#endif
 			}
 		}
 
@@ -266,12 +357,19 @@ int mdss_dsi_panel_reset(struct mdss_panel_data *pdata, int enable)
 			pr_debug("%s: Reset panel done\n", __func__);
 		}
 	} else {
+
+/*luochangyang for sequence 2014/06/09*/
+#ifdef CONFIG_ZTEMT_LCD_POWER_CONTRL
+		ztemt_poweroff_avdd_neg(ctrl_pdata);
+#else
 		if (gpio_is_valid(ctrl_pdata->disp_en_gpio)) {
 			gpio_set_value((ctrl_pdata->disp_en_gpio), 0);
 			gpio_free(ctrl_pdata->disp_en_gpio);
 		}
 		gpio_set_value((ctrl_pdata->rst_gpio), 0);
 		gpio_free(ctrl_pdata->rst_gpio);
+#endif
+
 		if (gpio_is_valid(ctrl_pdata->mode_gpio))
 			gpio_free(ctrl_pdata->mode_gpio);
 	}
@@ -366,6 +464,8 @@ static void mdss_dsi_panel_switch_mode(struct mdss_panel_data *pdata,
 static void mdss_dsi_panel_bl_ctrl(struct mdss_panel_data *pdata,
 							u32 bl_level)
 {
+    char *bklt_ctrl[] = {"pwm", "wled", "dcs"};
+
 	struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;
 
 	if (pdata == NULL) {
@@ -376,6 +476,10 @@ static void mdss_dsi_panel_bl_ctrl(struct mdss_panel_data *pdata,
 	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata,
 				panel_data);
 
+    printk(KERN_INFO "[LCD]: %s: %d: bl_from_user = %3d/[0,%3d], bl_to_%s = %4d/[%d,%d]\n",__func__,__LINE__,
+                      pdata->panel_info.bl_level, pdata->panel_info.brightness_max, 
+                      (ctrl_pdata->bklt_ctrl>=0&&ctrl_pdata->bklt_ctrl<=2)? bklt_ctrl[ctrl_pdata->bklt_ctrl] : "unknow",
+                      bl_level, pdata->panel_info.bl_min, pdata->panel_info.bl_max);
 	/*
 	 * Some backlight controllers specify a minimum duty cycle
 	 * for the backlight brightness. If the brightness is less
@@ -427,11 +531,33 @@ static int mdss_dsi_panel_on(struct mdss_panel_data *pdata)
 	mipi  = &pdata->panel_info.mipi;
 
 	pr_debug("%s: ctrl=%p ndx=%d\n", __func__, ctrl, ctrl->ndx);
+	
+	pr_info("lcd:%s start.\n",__func__);
 
 	if (ctrl->on_cmds.cmd_cnt)
 		mdss_dsi_panel_cmds_send(ctrl, &ctrl->on_cmds);
+	
+#ifdef CONFIG_ZTEMT_LCD_DISP_ENHANCE
+	ctrl->boot_enhance = 1;
+	zte_boot_begin_enhance(ctrl);
+#endif
 
-	pr_debug("%s:-\n", __func__);
+	if (ctrl->on_second_cmds.cmd_cnt)
+		mdss_dsi_panel_cmds_send(ctrl, &ctrl->on_second_cmds);
+
+#if 0
+
+	mdss_dsi_panel_reg_read(ctrl);
+
+	/*luochangyang for Read Registers 2014/06/16*/
+	for (i = 0; i < 0x5a0; i = i + 4) {
+		data = (u32)MIPI_INP((ctrl->ctrl_base) + i);
+	
+		printk("ctl_base(0x%x) + 0x%x = 0x%x.\n", *(ctrl->ctrl_base), i, data);
+	}
+	/*luochangyang END*/
+#endif
+	pr_info("lcd:%s done.\n",__func__);
 	return 0;
 }
 
@@ -455,7 +581,11 @@ static int mdss_dsi_panel_off(struct mdss_panel_data *pdata)
 	if (ctrl->off_cmds.cmd_cnt)
 		mdss_dsi_panel_cmds_send(ctrl, &ctrl->off_cmds);
 
-	pr_debug("%s:-\n", __func__);
+#ifdef CONFIG_ZTEMT_LCD_DISP_ENHANCE
+/*disp color enhance,mayu add*/
+  zte_set_ctrl_point(NULL);
+#endif
+	pr_info("%s.\n", __func__);
 	return 0;
 }
 
@@ -1082,6 +1212,11 @@ static int mdss_panel_parse_dt(struct device_node *np,
 			ctrl_pdata->pwm_pmic_gpio = tmp;
 		} else if (!strncmp(data, "bl_ctrl_dcs", 11)) {
 			ctrl_pdata->bklt_ctrl = BL_DCS_CMD;
+            rc = of_property_read_u32(np, "qcom,mdss-dsi-bl-pmic-control-reg", &tmp);
+	        ctrl_pdata->bklt_ctrl_dcs_reg = (!rc ? tmp : 0x51);
+            printk(KERN_INFO "%s: %d: bklt_ctrl_dcs_reg = 0x%x\n",__func__,__LINE__,ctrl_pdata->bklt_ctrl_dcs_reg);
+		}else if (!strncmp(data, "bl_ctrl_unknown", 15)) {
+          
 		}
 	}
 	rc = of_property_read_u32(np, "qcom,mdss-brightness-max-level", &tmp);
@@ -1092,6 +1227,29 @@ static int mdss_panel_parse_dt(struct device_node *np,
 	pinfo->bl_max = (!rc ? tmp : 255);
 	ctrl_pdata->bklt_max = pinfo->bl_max;
 
+    #ifdef CONFIG_ZTEMT_LCD_BACKLIGHT_LINEAR_CONTROL_METHOLD
+	rc = of_property_read_u32(np, "qcom,mdss-dsi-bright-to-bl-lvl-para-a1", &tmp);
+	pinfo->brig_to_bl_lvl_para_a1 = (!rc ? tmp : 0);
+
+    rc = of_property_read_u32(np, "qcom,mdss-dsi-bright-to-bl-lvl-para-a2", &tmp);
+	pinfo->brig_to_bl_lvl_para_a2 = (!rc ? tmp : 0);
+
+	rc = of_property_read_u32(np, "qcom,mdss-dsi-bright-to-bl-lvl-para-b1", &tmp);
+	pinfo->brig_to_bl_lvl_para_b1 = (!rc ? tmp : 0);
+
+	rc = of_property_read_u32(np, "qcom,mdss-dsi-bright-to-bl-lvl-para-b2", &tmp);
+	pinfo->brig_to_bl_lvl_para_b2 = (!rc ? tmp : 0);
+
+	rc = of_property_read_u32(np, "qcom,mdss-dsi-bright-to-bl-lvl-turn-point", &tmp);
+	pinfo->brig_to_bl_lvl_turn_point = (!rc ? tmp : 0);
+
+    printk(KERN_INFO "%s: %d: brig_to_bl_lvl_para_a1 = %d\n",__func__,__LINE__,pinfo->brig_to_bl_lvl_para_a1);
+    printk(KERN_INFO "%s: %d: brig_to_bl_lvl_para_a2 = %d\n",__func__,__LINE__,pinfo->brig_to_bl_lvl_para_a2);
+    printk(KERN_INFO "%s: %d: brig_to_bl_lvl_para_b1 = %d\n",__func__,__LINE__,pinfo->brig_to_bl_lvl_para_b1);
+    printk(KERN_INFO "%s: %d: brig_to_bl_lvl_para_b2 = %d\n",__func__,__LINE__,pinfo->brig_to_bl_lvl_para_b2);
+    printk(KERN_INFO "%s: %d: brig_to_bl_lvl_turn_point = %d\n",__func__,__LINE__,pinfo->brig_to_bl_lvl_turn_point);
+    #endif
+
 	rc = of_property_read_u32(np, "qcom,mdss-dsi-interleave-mode", &tmp);
 	pinfo->mipi.interleave_mode = (!rc ? tmp : 0);
 
@@ -1224,6 +1382,12 @@ static int mdss_panel_parse_dt(struct device_node *np,
 	mdss_dsi_parse_dcs_cmds(np, &ctrl_pdata->on_cmds,
 		"qcom,mdss-dsi-on-command", "qcom,mdss-dsi-on-command-state");
 
+#ifdef CONFIG_ZTEMT_LCD_DISP_ENHANCE
+/*add init code second part,mayu add 3.5*/
+  mdss_dsi_parse_dcs_cmds(np, &ctrl_pdata->on_second_cmds,
+		"qcom,mdss-dsi-on-second_command", "qcom,mdss-dsi-on-command-state");
+#endif
+
 	mdss_dsi_parse_dcs_cmds(np, &ctrl_pdata->off_cmds,
 		"qcom,mdss-dsi-off-command", "qcom,mdss-dsi-off-command-state");
 
diff --git a/drivers/video/msm/mdss/mdss_fb.c b/drivers/video/msm/mdss/mdss_fb.c
old mode 100644
new mode 100755
index d340207..e9fdac32
--- a/drivers/video/msm/mdss/mdss_fb.c
+++ b/drivers/video/msm/mdss/mdss_fb.c
@@ -229,15 +229,27 @@ static void mdss_fb_set_bl_brightness(struct led_classdev *led_cdev,
 				      enum led_brightness value)
 {
 	struct msm_fb_data_type *mfd = dev_get_drvdata(led_cdev->dev->parent);
-	int bl_lvl;
+	int bl_lvl = 0;
 
-	if (value > mfd->panel_info->brightness_max)
-		value = mfd->panel_info->brightness_max;
+    mfd->panel_info->bl_level = value;
 
-	/* This maps android backlight level 0 to 255 into
-	   driver backlight level 0 to bl_max with rounding */
-	MDSS_BRIGHT_TO_BL(bl_lvl, value, mfd->panel_info->bl_max,
-				mfd->panel_info->brightness_max);
+    if (value>0)
+    {
+    	if (value > mfd->panel_info->brightness_max)
+    		value = mfd->panel_info->brightness_max;
+
+        if (value < mfd->panel_info->brig_to_bl_lvl_turn_point)
+        {
+            bl_lvl = (mfd->panel_info->brig_to_bl_lvl_para_a1) * value + mfd->panel_info->brig_to_bl_lvl_para_b1;
+        }
+        else
+        {
+            bl_lvl = (mfd->panel_info->brig_to_bl_lvl_para_a2) * value + mfd->panel_info->brig_to_bl_lvl_para_b2;
+        }
+
+        bl_lvl = bl_lvl>0 ? bl_lvl/100 : 0;
+        bl_lvl = bl_lvl>mfd->panel_info->bl_max ? mfd->panel_info->bl_max : bl_lvl;
+    }
 
 	if (!bl_lvl && value)
 		bl_lvl = 1;
@@ -250,9 +262,12 @@ static void mdss_fb_set_bl_brightness(struct led_classdev *led_cdev,
 	}
 }
 
+#define MDSS_DEFAULT_BL_BRIGHTNESS 61
+
 static struct led_classdev backlight_led = {
 	.name           = "lcd-backlight",
-	.brightness     = MDSS_MAX_BL_BRIGHTNESS,
+	//.brightness     = MDSS_MAX_BL_BRIGHTNESS,//set default brightness as MDSS_DEFAULT_BL_BRIGHTNESS
+	.brightness     = MDSS_DEFAULT_BL_BRIGHTNESS,
 	.brightness_set = mdss_fb_set_bl_brightness,
 };
 
@@ -307,6 +322,10 @@ static void mdss_fb_parse_dt(struct msm_fb_data_type *mfd)
 
 	panel_xres = mfd->panel_info->xres;
 	if (data[0] && data[1]) {
+		
+		pr_info("mfd->split_display=%d, panel_xres = %d\n",
+				mfd->split_display, panel_xres);
+
 		if (mfd->split_display)
 			panel_xres *= 2;
 
@@ -630,8 +649,14 @@ static int mdss_fb_probe(struct platform_device *pdev)
 
 	/* android supports only one lcd-backlight/lcd for now */
 	if (!lcd_backlight_registered) {
-
+		
+/*Modify by luochangyang for backlight change in booting  2014/06/25*/
+#ifndef CONFIG_ZTEMT_LCD_MIPI_COMMON
 		backlight_led.brightness = mfd->panel_info->brightness_max;
+#else
+		backlight_led.brightness = MDSS_DEFAULT_BL_BRIGHTNESS;
+#endif
+/*luochangyang END*/
 		backlight_led.max_brightness = mfd->panel_info->brightness_max;
 		if (led_classdev_register(&pdev->dev, &backlight_led))
 			pr_err("led_classdev_register failed\n");
@@ -949,6 +974,7 @@ void mdss_fb_set_backlight(struct msm_fb_data_type *mfd, u32 bkl_lvl)
 		 */
 		if (mfd->bl_level_scaled == temp) {
 			mfd->bl_level = bkl_lvl;
+            printk(KERN_INFO "[LCD]: %s: %d: same bl_level(%d), just return\n",__func__,__LINE__,bkl_lvl);
 		} else {
 			pr_debug("backlight sent to panel :%d\n", temp);
 			pdata->set_backlight(pdata, temp);
@@ -1001,6 +1027,9 @@ static int mdss_fb_blank_sub(int blank_mode, struct fb_info *info,
 	case FB_BLANK_UNBLANK:
 		if (!mfd->panel_power_on && mfd->mdp.on_fnc) {
 			ret = mfd->mdp.on_fnc(mfd);
+			
+			pr_info("%s.\n", __func__);
+			
 			if (ret == 0) {
 				mfd->panel_power_on = true;
 				mfd->panel_info->panel_dead = false;
@@ -1422,6 +1451,9 @@ static int mdss_fb_alloc_fbmem_iommu(struct msm_fb_data_type *mfd, int dom)
 
 	pr_debug("%s frame buffer reserve_size=0x%zx\n", __func__, size);
 
+	pr_info("%s frame buffer size=0x%x\n", __func__, PAGE_ALIGN(mfd->fbi->fix.line_length *
+			      mfd->fbi->var.yres_virtual));
+
 	if (size < PAGE_ALIGN(mfd->fbi->fix.line_length *
 			      mfd->fbi->var.yres_virtual))
 		pr_warn("reserve size is smaller than framebuffer size\n");
diff --git a/drivers/video/msm/mdss/mdss_hdmi_edid.c b/drivers/video/msm/mdss/mdss_hdmi_edid.c
old mode 100644
new mode 100755
diff --git a/drivers/video/msm/mdss/mdss_hdmi_tx.c b/drivers/video/msm/mdss/mdss_hdmi_tx.c
old mode 100644
new mode 100755
index a9896f5..713a8b6
--- a/drivers/video/msm/mdss/mdss_hdmi_tx.c
+++ b/drivers/video/msm/mdss/mdss_hdmi_tx.c
@@ -59,8 +59,8 @@
 	((d & 0xff) + ((d >> 8) & 0xff) +	\
 	((d >> 16) & 0xff) + ((d >> 24) & 0xff))
 
-/* Enable HDCP by default */
-static bool hdcp_feature_on = true;
+/* Do not Enable HDCP by default */
+static bool hdcp_feature_on = false;
 
 /* Supported HDMI Audio channels */
 #define MSM_HDMI_AUDIO_CHANNEL_2	2
diff --git a/drivers/video/msm/mdss/mdss_io_util.c b/drivers/video/msm/mdss/mdss_io_util.c
old mode 100644
new mode 100755
diff --git a/drivers/video/msm/mdss/mdss_mdp.c b/drivers/video/msm/mdss/mdss_mdp.c
old mode 100644
new mode 100755
diff --git a/drivers/video/msm/mdss/mdss_mdp.h b/drivers/video/msm/mdss/mdss_mdp.h
old mode 100644
new mode 100755
index 76d9ffe..7f9bc16
--- a/drivers/video/msm/mdss/mdss_mdp.h
+++ b/drivers/video/msm/mdss/mdss_mdp.h
@@ -761,4 +761,8 @@ int mdss_mdp_pipe_program_pixel_extn(struct mdss_mdp_pipe *pipe);
 				(mfd->mdp.private1))->wb)
 
 int  mdss_mdp_ctl_reset(struct mdss_mdp_ctl *ctl);
+#ifdef CONFIG_ZTEMT_LCD_DISP_ENHANCE
+//lcd color tmp adjust,mayu add
+int zte_mdss_pcc_config(struct mdp_pcc_cfg_data *config);
+#endif
 #endif /* MDSS_MDP_H */
diff --git a/drivers/video/msm/mdss/mdss_mdp_ctl.c b/drivers/video/msm/mdss/mdss_mdp_ctl.c
old mode 100644
new mode 100755
diff --git a/drivers/video/msm/mdss/mdss_mdp_overlay.c b/drivers/video/msm/mdss/mdss_mdp_overlay.c
old mode 100644
new mode 100755
diff --git a/drivers/video/msm/mdss/mdss_mdp_pipe.c b/drivers/video/msm/mdss/mdss_mdp_pipe.c
old mode 100644
new mode 100755
diff --git a/drivers/video/msm/mdss/mdss_mdp_pp.c b/drivers/video/msm/mdss/mdss_mdp_pp.c
old mode 100644
new mode 100755
index f434a43..fe9c2d4
--- a/drivers/video/msm/mdss/mdss_mdp_pp.c
+++ b/drivers/video/msm/mdss/mdss_mdp_pp.c
@@ -2563,6 +2563,51 @@ static void pp_read_igc_lut_cached(struct mdp_igc_lut_data *cfg)
 			mdss_pp_res->igc_disp_cfg[disp_num].c2_data[i];
 	}
 }
+#ifdef CONFIG_ZTEMT_LCD_DISP_ENHANCE
+//lcd color tmp adjust,mayu add
+int zte_mdss_pcc_config(struct mdp_pcc_cfg_data *config)
+{
+	int ret = 0;
+	u32 disp_num=0;
+
+	if ((config->block < MDP_LOGICAL_BLOCK_DISP_0) ||
+		(config->block >= MDP_BLOCK_MAX))
+		return -EINVAL;
+
+	if ((config->ops & MDSS_PP_SPLIT_MASK) == MDSS_PP_SPLIT_MASK) {
+		pr_warn("Can't set both split bits\n");
+		return -EINVAL;
+	}
+
+#if 0
+printk("lcd:%s block=0x%x,ops=0x%x\n",__func__,config->block,config->ops);
+printk("lcd:r:c=0x%x,r=0x%x,g=0x%x,b=0x%x\n",config->r.c,config->r.r,config->r.g,config->r.b);
+printk("lcd:r:rr=0x%x,gg=0x%x,bb=0x%x\n",config->r.rr,config->r.gg,config->r.bb);
+printk("lcd:r:rg=0x%x,gb=0x%x,rb=0x%x\n",config->r.rg,config->r.gb,config->r.rb);
+printk("lcd:r:rgb_0=0x%x,rgb_1=0x%x\n",config->r.rgb_0,config->r.rgb_1);
+
+printk("lcd:g:c=0x%x,r=0x%x,g=0x%x,b=0x%x\n",config->g.c,config->g.r,config->g.g,config->g.b);
+printk("lcd:g:rr=0x%x,gg=0x%x,bb=0x%x\n",config->g.rr,config->g.gg,config->g.bb);
+printk("lcd:g:rg=0x%x,gb=0x%x,rb=0x%x\n",config->g.rg,config->g.gb,config->g.rb);
+printk("lcd:g:rgb_0=0x%x,rgb_1=0x%x\n",config->g.rgb_0,config->g.rgb_1);
+
+printk("lcd:b:c=0x%x,r=0x%x,g=0x%x,b=0x%x\n",config->b.c,config->b.r,config->b.g,config->b.b);
+printk("lcd:b:rr=0x%x,gg=0x%x,bb=0x%x\n",config->b.rr,config->b.gg,config->b.bb);
+printk("lcd:b:rg=0x%x,gb=0x%x,rb=0x%x\n",config->b.rg,config->b.gb,config->b.rb);
+printk("lcd:b:rgb_0=0x%x,rgb_1=0x%x\n",config->b.rgb_0,config->b.rgb_1);
+#endif
+
+	mutex_lock(&mdss_pp_mutex);
+	disp_num = config->block - MDP_LOGICAL_BLOCK_DISP_0;
+  if(mdss_pp_res)
+  {
+	  mdss_pp_res->pcc_disp_cfg[disp_num] = *config;
+	  mdss_pp_res->pp_disp_flags[disp_num] |= PP_FLAGS_DIRTY_PCC;
+  }
+	mutex_unlock(&mdss_pp_mutex);
+	return ret;
+}
+#endif
 
 static void pp_read_igc_lut(struct mdp_igc_lut_data *cfg,
 				char __iomem *addr, u32 blk_idx)
diff --git a/drivers/video/msm/mdss/mdss_panel.h b/drivers/video/msm/mdss/mdss_panel.h
old mode 100644
new mode 100755
index 80faf1b..90f4a27
--- a/drivers/video/msm/mdss/mdss_panel.h
+++ b/drivers/video/msm/mdss/mdss_panel.h
@@ -305,8 +305,14 @@ struct mdss_panel_info {
 	u32 wait_cycle;
 	u32 pdest;
 	u32 brightness_max;
+    u32 bl_level;
 	u32 bl_max;
 	u32 bl_min;
+    int brig_to_bl_lvl_para_a1;
+    int brig_to_bl_lvl_para_a2;
+    int brig_to_bl_lvl_para_b1;
+    int brig_to_bl_lvl_para_b2;
+    int brig_to_bl_lvl_turn_point;
 	u32 fb_num;
 	u32 clk_rate;
 	u32 clk_min;
diff --git a/drivers/video/msm/mdss/zte_backlight.c b/drivers/video/msm/mdss/zte_backlight.c
new file mode 100755
index 0000000..90fe701
--- /dev/null
+++ b/drivers/video/msm/mdss/zte_backlight.c
@@ -0,0 +1,250 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/err.h>
+
+#include "zte_backlight.h"
+#include "zte_disp_enhance.h"
+#include "zte_backlight_data.h"
+#include "mdss_dsi.h"
+
+
+
+static ssize_t pwm_setting_store(struct kobject *kobj, struct kobj_attribute *attr,
+		    const char *buf, size_t size);
+static ssize_t zte_backlight_show(struct kobject *kobj, struct kobj_attribute *attr,char *buf);
+static ssize_t zte_backlight_store(struct kobject *kobj, struct kobj_attribute *attr,
+		    const char *buf, size_t size);
+
+
+extern struct kobject *enhance__kobj;
+
+static struct mdss_dsi_ctrl_pdata *zte_mdss_dsi_ctrl = NULL;
+
+static int zte_backlight_enable = 1;
+
+static struct kobj_attribute pwm_attribute = __ATTR(pwm_setting,0664,NULL,pwm_setting_store);
+static struct kobj_attribute zte_backlight_attribute = __ATTR(zte_backlight_EnSetting,0664,zte_backlight_show,zte_backlight_store);
+static struct attribute *cali_attrs[] = {
+				&pwm_attribute.attr,
+				&zte_backlight_attribute.attr,
+				NULL,
+				};
+static struct attribute_group cali_attrs_groups = {
+				.attrs = cali_attrs,
+				};
+
+
+
+static bool IsPwmTableExit(void)
+{
+	if((sizeof(brightness2pwm_normal)/sizeof(struct BRIGHTNESS_PWM_TYPE) <2) ||\
+		(sizeof(bgvalue2brightness)/sizeof(struct BGVALUE_BRIGHTNESS_TYPE) < 2))
+	{
+		printk("any of the two pwm tables are null \n");
+		return false;
+	}
+
+	return true;
+}
+
+
+int ZteBgvalue2pwm(int bgvalue)
+{
+	int brightness = bgvalue2brightness[0].brightness;
+	int pwm = 0;
+	//int cnt = 0;
+	int i;
+	const struct BRIGHTNESS_PWM_TYPE *p_brightness2pwm = NULL;
+	int table_len = 0;
+
+	if(!IsPwmTableExit())
+	{
+		printk("%s:%s pwm table is not exit\n",__FILE__,__func__);
+		return -1;
+	}
+
+	if(0 == bgvalue)
+	{
+		return 0;
+	}
+//use bgvalue to get true brightness
+	table_len = sizeof(bgvalue2brightness)/sizeof(struct BGVALUE_BRIGHTNESS_TYPE);
+	for(i=0;i<table_len;i++)
+	{
+		if(bgvalue == bgvalue2brightness[i].bgvalue)
+		{
+			brightness = bgvalue2brightness[i].brightness;
+			break;
+		}
+		else if(bgvalue <  bgvalue2brightness[i].bgvalue)
+		{
+			if(0 == i)
+			{
+				brightness = bgvalue2brightness[i].brightness;
+				break;
+			}
+			brightness = bgvalue2brightness[i - 1].brightness + \
+					(bgvalue2brightness[i].brightness - bgvalue2brightness[i-1].brightness)*(bgvalue-bgvalue2brightness[i-1].bgvalue)\
+					/(bgvalue2brightness[i].bgvalue -bgvalue2brightness[i-1].bgvalue );
+			break;
+		}
+	}
+	if(i >= table_len)
+	{
+		brightness = bgvalue2brightness[table_len - 1].brightness;
+	}
+
+	ZTE_BACKLIGHT_DEBUG("%s %s: i: %d, brightness: %d, table_len: %d, bgvalue:%d\n",__FILE__,__func__,i,brightness,table_len,bgvalue);
+	
+	//use colortmp to choose brightness2pwm table
+	
+	p_brightness2pwm = brightness2pwm_normal;
+	table_len = sizeof(brightness2pwm_normal)/sizeof(struct BRIGHTNESS_PWM_TYPE);
+
+	ZTE_BACKLIGHT_DEBUG("zte_enhance.en_colortmp not enable : brightness2pwm_normal\n");
+
+
+
+//use true brightness to get pwm value
+	for (i = 0; i < table_len; i++)
+	{
+		if(brightness == p_brightness2pwm[i].brightness)
+		{
+			pwm = p_brightness2pwm[i].pwm;
+			break;
+		}
+		else if(brightness < p_brightness2pwm[i].brightness)
+		{
+			if(0 == i)
+			{
+				pwm = p_brightness2pwm[i].pwm;
+				break;
+			}
+			pwm = p_brightness2pwm[i - 1].pwm + \
+				(brightness - p_brightness2pwm[i-1].brightness)*(p_brightness2pwm[i].pwm - p_brightness2pwm[i-1].pwm)/\
+				  (p_brightness2pwm[i].brightness - p_brightness2pwm[i-1].brightness);
+			break;
+		}
+	}
+	if(i >= table_len)
+	{
+		pwm = p_brightness2pwm[table_len - 1].pwm;
+	}
+
+	if(pwm > ZTE_DEFALUT_MAX_BLLEVEL)
+	{
+		pwm = ZTE_DEFALUT_MAX_BLLEVEL;
+	}
+
+	ZTE_BACKLIGHT_DEBUG("%s %s: i: %d, brightness: %d, table_len: %d, pwm:%d\n",__FILE__,__func__,i,brightness,table_len,pwm);
+
+
+	return pwm;
+}
+
+void ztePwmBri_SetPoint(struct mdss_dsi_ctrl_pdata * ctrl)
+{
+	zte_mdss_dsi_ctrl = ctrl;
+}
+
+
+bool IsBgvalueTranEnable(void)
+{
+
+	ZTE_BACKLIGHT_DEBUG("zte_backlight_enable:%d\n",zte_backlight_enable);
+	if(zte_backlight_enable)
+	{
+		if(IsPwmTableExit())
+		{
+			return true;
+		}
+	}
+
+	return false;
+}
+
+static ssize_t zte_backlight_show(struct kobject *kobj, struct kobj_attribute *attr,char *buf)
+{
+	return sprintf(buf, "%d\n",zte_backlight_enable);
+}
+
+
+static ssize_t zte_backlight_store(struct kobject *kobj, struct kobj_attribute *attr,
+		    const char *buf, size_t size)
+{
+	int setvalue;
+
+	sscanf(buf,"%d",&setvalue);
+
+	ZTE_BACKLIGHT_DEBUG("zte_backlight_enable before set:%d,setvalue:%d,size:%d\n",zte_backlight_enable,setvalue,size);
+
+	if(setvalue > 1 || setvalue < 0)
+	{
+		return -EBUSY;
+	}
+
+	zte_backlight_enable = setvalue;
+	ZTE_BACKLIGHT_DEBUG("zte_backlight_enable after set:%d\n",zte_backlight_enable);
+
+	return size;
+}
+
+static ssize_t pwm_setting_store(struct kobject *kobj, struct kobj_attribute *attr,
+		    const char *buf, size_t size)
+{
+	int pwm_value;
+	struct mdss_panel_data *pdata;
+
+
+	sscanf(buf, "%d", &pwm_value);
+	
+	printk("%s:%s pwm_value = %d, size = %d\n",__FILE__,__func__,pwm_value,(int)size);
+
+	if(zte_mdss_dsi_ctrl)
+	{
+		pdata = &zte_mdss_dsi_ctrl->panel_data;
+		if(pdata && (pdata->set_backlight))
+		{
+			pdata->set_backlight(pdata,pwm_value);
+		}
+		else
+		{
+			printk("%s:%s zte_mdss_dsi_ctrl->panel_data or ->set_backlight is null\n",__FILE__,__func__);
+			return -EBUSY;
+		}
+	}
+	else
+	{
+		printk("%s:%s zte_mdss_dsi_ctrl is NULL.\n",__FILE__,__func__);
+		return -EBUSY;
+	}
+	return size;
+}
+
+static int __init pwm_brightness_cali_init(void)
+{
+	int ret;
+
+	if(!enhance__kobj)
+	{
+		printk("%s enhance_kobj is null now\n",__func__);
+		return -ENOMEM;
+	}
+
+	ret = sysfs_create_group(enhance__kobj,&cali_attrs_groups);
+
+
+	return ret;
+}
+
+static void __exit pwm_brightness_cali_exit(void)
+{
+
+}
+
+ module_init(pwm_brightness_cali_init);
+ module_exit(pwm_brightness_cali_exit);
+
diff --git a/drivers/video/msm/mdss/zte_backlight.h b/drivers/video/msm/mdss/zte_backlight.h
new file mode 100755
index 0000000..8a8deb3
--- /dev/null
+++ b/drivers/video/msm/mdss/zte_backlight.h
@@ -0,0 +1,30 @@
+#ifndef H_ZTE_BACKLIGHT
+#define H_ZTE_BACKLIGHT
+
+#include "mdss_dsi.h"
+
+//#define ZTE_BACKLIGHT_DEBUG_ENABLE
+
+#ifdef ZTE_BACKLIGHT_DEBUG_ENABLE
+#define ZTE_BACKLIGHT_DEBUG  printk
+#else
+#define ZTE_BACKLIGHT_DEBUG(fmt,...)
+#endif
+
+struct BGVALUE_BRIGHTNESS_TYPE{
+	int bgvalue;
+	int brightness;
+};
+
+struct BRIGHTNESS_PWM_TYPE{
+	int brightness;
+	int pwm;
+};
+
+void ztePwmBri_SetPoint(struct mdss_dsi_ctrl_pdata * ctrl);
+
+bool IsBgvalueTranEnable(void);
+
+int ZteBgvalue2pwm(int bgvalue);
+//#endif
+#endif
diff --git a/drivers/video/msm/mdss/zte_backlight_data.h b/drivers/video/msm/mdss/zte_backlight_data.h
new file mode 100755
index 0000000..6bb4cee
--- /dev/null
+++ b/drivers/video/msm/mdss/zte_backlight_data.h
@@ -0,0 +1,169 @@
+#ifndef H_ZTE_BACKLIGHT_DATA
+#define H_ZTE_BACKLIGHT_DATA
+
+#include "zte_backlight.h"
+
+//this table maped 0-255 bright set from use space to the true brightness show in machine, 
+#if defined(CONFIG_ZTEMT_MIPI_1080P_R63311_SHARP_IPS_6P4)
+const struct BGVALUE_BRIGHTNESS_TYPE bgvalue2brightness[] = \
+{
+	//{0,4},
+	//{1,4},
+	//{2,4},
+	//{4,8},
+	{0,20},
+	{4,20},
+	{5,20},
+	//{8,16},
+	{10,20},
+	{25,50},
+	{45,90},
+	{58,115},
+	{65,130},
+	{110,220},
+	{160,320},
+	{190,380},//modify for using 380 for the bigest brightness
+	//{255,380},
+	{210,420},
+	{223,446},
+	//{240,480},
+	{255,446}
+};
+
+const struct BRIGHTNESS_PWM_TYPE brightness2pwm_normal[] = \
+{
+	{4,51},
+	{8,87},
+	{16,158},
+	{50,452},
+	{90,800},
+	{115,1020},
+	{130,1153},
+	{220,1963},
+	{320,2885},
+	{380,3452},
+	{420,3840},
+	{446,4095}
+};
+#elif defined(CONFIG_ZTEMT_MIPI_1080P_R63311_SHARP_IPS_5P5)
+const struct BGVALUE_BRIGHTNESS_TYPE bgvalue2brightness[] = \
+{
+	{0,4},
+	{1,4},
+	{2,4},
+	{4,8},
+	//{0,10},
+	//{4,10},
+	//{5,10},
+	{8,16},
+	{25,50},
+	{45,90},
+	{58,115},
+	{65,130},
+	{110,220},
+	{160,320},
+	{190,380},//modify for using 380 for the bigest brightness
+	//{255,380},
+	{210,420},
+	{223,446},
+	//{240,480},
+	{255,446}
+};
+
+const struct BRIGHTNESS_PWM_TYPE brightness2pwm_normal[] = \
+{
+	{2,20},
+	{4,40},
+	{8,74},
+	{16,140},
+	{50,411},
+	{90,726},
+	{115,925},
+	{130,1045},
+	{220,1772},
+	{320,2608},
+	{380,3129},
+	{420,3486},
+	{450,3763},
+	{487,4095}
+};
+#elif defined(CONFIG_ZTEMT_MIPI_1080P_R63417_SHARP_IPS_5P5)
+const struct BGVALUE_BRIGHTNESS_TYPE bgvalue2brightness[] = \
+{
+    {0,20},
+    {1,20},
+    {2,20},
+    {4,20},
+    {8,20},
+    {25,50},
+    {45,90},
+    {58,115},
+    {65,130},
+    {110,220},
+    {160,320},
+    {190,380},//modify for using 380 for the bigest brightness
+    //{255,380},
+    {210,420},
+    {223,446},
+    //{240,480},
+    {255,446}
+};
+
+const struct BRIGHTNESS_PWM_TYPE brightness2pwm_normal[] = \
+{
+    {4,32},
+    {10,72},
+    {16,110},
+    {20,134},
+    {50,313},
+    {90,548},
+    {115,697},
+    {130,785},
+    {220,1330},
+    {320,1950},
+    {380,2320},
+    {420,2585},
+    {446,2754}
+};
+#elif defined(CONFIG_ZTEMT_MIPI_2K_R63419_SHARP_IPS_5P5)
+#if 0
+const struct BGVALUE_BRIGHTNESS_TYPE bgvalue2brightness[] = \
+{
+	{0,4},
+	{1,4},
+	{2,4},
+	{4,8},
+	{8,16},
+	{25,50},
+	{45,90},
+	{58,115},
+	{65,130},
+	{110,220},
+	{160,320},
+	{190,380},//modify for using 380 for the bigest brightness
+	{210,420},
+	{223,446},
+	{255,446}
+};
+
+const struct BRIGHTNESS_PWM_TYPE brightness2pwm_normal[] = \
+{
+	{2,20},
+	{4,40},
+	{8,74},
+	{16,140},
+	{50,411},
+	{90,726},
+	{115,925},
+	{130,1045},
+	{220,1772},
+	{320,2608},
+	{380,3129},
+	{420,3486},
+	{450,3763},
+	{487,4095}
+};
+#endif
+#endif
+
+#endif
diff --git a/drivers/video/msm/mdss/zte_disp_enhance.c b/drivers/video/msm/mdss/zte_disp_enhance.c
new file mode 100755
index 0000000..115d430
--- /dev/null
+++ b/drivers/video/msm/mdss/zte_disp_enhance.c
@@ -0,0 +1,593 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/timer.h>
+#include <linux/err.h>
+#include <linux/ctype.h>
+#include "mdss_mdp.h"
+
+#include "zte_disp_enhance.h"
+
+//#define ZTE_DISP_ENHANCE_DEBUG
+
+#define ZTE_SHARP_ENHANCE_CMD_COUNT 1
+
+static struct zte_enhance_type zte_enhance_val = {
+	.en_saturation =1,
+	.saturation = INTENSITY_01,
+	.colortmp =  INTENSITY_01,
+#if defined (CONFIG_ZTEMT_MIPI_1080P_R63417_SHARP_IPS_5P5) || \
+	defined (CONFIG_ZTEMT_MIPI_2K_R63419_SHARP_IPS_5P5) || \
+	defined (CONFIG_ZTEMT_MIPI_1080P_R63311_SHARP_IPS_5P0_NX507J) || \
+	defined (CONFIG_ZTEMT_MIPI_1080P_R63311_SHARP_IPS_6P4)
+	.en_colortmp = 1,
+#else
+	.en_colortmp = 0,
+#endif
+
+};
+
+static struct mdss_dsi_ctrl_pdata *zte_mdss_dsi_ctrl = NULL;
+
+/*mdp adjust mayu add*/
+
+struct mdp_pcc_cfg_data zte_pcc_cfg_warm = {
+	.block = 0x10,
+	.ops = 0x5,
+    {
+      .c = 0,
+      .r = 0x8800,
+      .g = 0,
+      .b = 0,
+      .rr = 0,
+      .gg = 0,
+      .bb = 0,
+      .rg = 0,
+      .gb = 0,
+      .rb = 0,
+      .rgb_0 = 0,
+      .rgb_1 = 0
+    },
+    {
+      .c = 0,
+      .r = 0,
+      .g = 0x8000,
+      .b = 0,
+      .rr = 0,
+      .gg = 0,
+      .bb = 0,
+      .rg = 0,
+      .gb = 0,
+      .rb = 0,
+      .rgb_0 = 0,
+      .rgb_1 = 0
+    },
+    {
+      .c = 0,
+      .r = 0,
+      .g = 0,
+      .b = 0x8000,
+      .rr = 0,
+      .gg = 0,
+      .bb = 0,
+      .rg = 0,
+      .gb = 0,
+      .rb = 0,
+      .rgb_0 = 0,
+      .rgb_1 = 0
+    },
+
+};
+
+struct mdp_pcc_cfg_data zte_pcc_cfg_normal = {
+	.block = 0x10,
+	.ops = 0x5,
+    {
+      .c = 0,
+      .r = 0x8000,
+      .g = 0,
+      .b = 0,
+      .rr = 0,
+      .gg = 0,
+      .bb = 0,
+      .rg = 0,
+      .gb = 0,
+      .rb = 0,
+      .rgb_0 = 0,
+      .rgb_1 = 0
+    },
+    {
+      .c = 0,
+      .r = 0,
+      .g = 0x8000,
+      .b = 0,
+      .rr = 0,
+      .gg = 0,
+      .bb = 0,
+      .rg = 0,
+      .gb = 0,
+      .rb = 0,
+      .rgb_0 = 0,
+      .rgb_1 = 0
+    },
+    {
+      .c = 0,
+      .r = 0,
+      .g = 0,
+      .b = 0x8000,
+      .rr = 0,
+      .gg = 0,
+      .bb = 0,
+      .rg = 0,
+      .gb = 0,
+      .rb = 0,
+      .rgb_0 = 0,
+      .rgb_1 = 0
+    },
+};
+struct mdp_pcc_cfg_data zte_pcc_cfg_cool = {
+	.block = 0x10,
+	.ops = 0x5,
+    {
+      .c = 0,
+      .r = 0x7800,
+      .g = 0,
+      .b = 0,
+    },
+    {
+      .c = 0,
+      .r = 0,
+      .g = 0x8000,
+      .b = 0,
+    },
+    {
+      .c = 0,
+      .r = 0,
+      .g = 0,
+      .b = 0x8000,
+    },
+};
+
+struct mdp_pcc_cfg_data zte_pcc_cfg_cool1 = {
+	.block = 0x10,
+	.ops = 0x5,
+    {
+      .c = 0,
+      .r = 0x7000, 
+      .g = 0,
+      .b = 0,
+    },
+    {
+      .c = 0,
+      .r = 0,
+      .g = 0x8000,
+      .b = 0,
+    },
+    {
+      .c = 0,
+      .r = 0,
+      .g = 0,
+      .b = 0x8000,
+    },
+};
+
+struct zte_enhance_type zte_get_lcd_enhance_param(void)
+{
+	return zte_enhance_val;
+}
+
+#if defined(CONFIG_ZTEMT_MIPI_1080P_R63311_SHARP_IPS_5P0)
+//NX503A NX507J
+static char sharpca_basic_9b[] = {0xca, 0x01,0x80, 0x98,0x98,0x9b,0x40,0xbe,0xbe,0x20,0x20,
+	0x80,0xfe,0x0a, 0x4a,0x37,0xa0,0x55,0xf8,0x0c,0x0c,0x20,0x10,0x3f,0x3f,0x00,
+	0x00,0x10,0x10,0x3f,0x3f,0x3f,0x3f,
+};
+static struct dsi_cmd_desc display_glow_cmd = {
+	{DTYPE_GEN_LWRITE, 1, 0, 0, 1, sizeof(sharpca_basic_9b)}, sharpca_basic_9b
+
+};
+
+static char sharpca_basic_92[] = {0xca, 0x01,0x80, 0x92,0x92,0x9b,0x75,0x9b,0x9b,0x20,0x20,
+	0x80,0xfe,0x0a, 0x4a,0x37,0xa0,0x55,0xf8,0x0c,0x0c,0x20,0x10,0x3f,0x3f,0x00,
+	0x00,0x10,0x10,0x3f,0x3f,0x3f,0x3f,
+};
+
+static struct dsi_cmd_desc display_std_cmd = {
+	{DTYPE_GEN_LWRITE, 1, 0, 0, 1, sizeof(sharpca_basic_92)}, sharpca_basic_92
+
+};
+static char sharpca_basic_norm[] = {0xca, 0x00,0x80, 0x80,0x80,0x80,0x80,0x80,0x80,0x08,0x20,
+	0x80,0x80,0x0a, 0x4a,0x37,0xa0,0x55,0xf8,0x0c,0x0c,0x20,0x10,0x3f,0x3f,0x00,
+	0x00,0x10,0x10,0x3f,0x3f,0x3f,0x3f,
+};
+
+static struct dsi_cmd_desc display_soft_cmd = {
+	{DTYPE_GEN_LWRITE, 1, 0, 0, 1, sizeof(sharpca_basic_norm)}, sharpca_basic_norm
+
+};
+	
+#elif defined(CONFIG_ZTEMT_MIPI_1080P_R63311_SHARP_IPS_5P5)
+//NX504J
+static char sharpca_basic_9b[] = {
+	0xca, 0x01, 0x80, 0x9c, 0x9b, 0x9b, 0x40, 0xbe, 0xbe, 0x20,
+	0x20, 0x80, 0xfe, 0x0a, 0x4a, 0x37, 0xa0, 0x55, 0xf8, 0x0c,
+	0x0c, 0x20, 0x10, 0x3f, 0x3f, 0x00, 0x00, 0x10, 0x10, 0x3f,
+	0x3f, 0x3f, 0x3f,
+};
+
+static struct dsi_cmd_desc display_glow_cmd = {
+	{DTYPE_GEN_LWRITE, 1, 0, 0, 1, sizeof(sharpca_basic_9b)}, sharpca_basic_9b
+
+};
+
+static char sharpca_basic_92[] = {
+	0xca, 0x01, 0x80, 0x92, 0x92, 0x9b, 0x75, 0x9b, 0x9b, 0x20,
+	0x20, 0x80, 0xfe, 0x0a, 0x4a, 0x37, 0xa0, 0x55, 0xf8, 0x0c,
+	0x0c, 0x20, 0x10, 0x3f, 0x3f, 0x00, 0x00, 0x10, 0x10, 0x3f,
+	0x3f, 0x3f, 0x3f,
+};
+
+static struct dsi_cmd_desc display_std_cmd = {
+	{DTYPE_GEN_LWRITE, 1, 0, 0, 1, sizeof(sharpca_basic_92)}, sharpca_basic_92
+
+};
+static char sharpca_basic_norm[] = {
+	0xca, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x08,
+	0x20, 0x80, 0x80, 0x0a, 0x4a, 0x37, 0xa0, 0x55, 0xf8, 0x0c,
+	0x0c, 0x20, 0x10, 0x3f, 0x3f, 0x00, 0x00, 0x10, 0x10, 0x3f,
+	0x3f, 0x3f, 0x3f,
+};
+
+static struct dsi_cmd_desc display_soft_cmd = {
+	{DTYPE_GEN_LWRITE, 1, 0, 0, 1, sizeof(sharpca_basic_norm)}, sharpca_basic_norm
+
+};
+
+#elif defined(CONFIG_ZTEMT_MIPI_1080P_R63311_SHARP_IPS_6P4)
+//NX601J
+static char sharpca_basic_9b[] = {
+  0xca,0x01,0x80,0x9c,0x9b,0x9b,0x40,0xbe,0xbe,0x20,
+  0x20,0x80,0xfe,0x0a,0x4a,0x37,0xa0,0x55,0xf8,0x0c,
+  0x0c,0x20,0x10,0x3f,0x3f,0x00,0x00,0x10,0x10,0x3f,
+  0x3f,0x3f,0x3f,
+};
+
+static struct dsi_cmd_desc display_glow_cmd = {
+	{DTYPE_GEN_LWRITE, 1, 0, 0, 1, sizeof(sharpca_basic_9b)}, sharpca_basic_9b
+
+};
+
+static char sharpca_basic_92[] = {
+  0xca,0x01,0x80,0x92,0x92,0x9b,0x75,0x9b,0x9b,0x20,
+  0x20,0x80,0xfe,0x0a,0x4a,0x37,0xa0,0x55,0xf8,0x0c,
+  0x0c,0x20,0x10,0x3f,0x3f,0x00,0x00,0x10,0x10,0x3f,
+  0x3f,0x3f,0x3f,
+};
+
+static struct dsi_cmd_desc display_std_cmd = {
+	{DTYPE_GEN_LWRITE, 1, 0, 0, 1, sizeof(sharpca_basic_92)}, sharpca_basic_92
+
+};
+static char sharpca_basic_norm[] = {
+  0xca,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x08,
+  0x20,0x80,0x80,0x0a,0x4a,0x37,0xa0,0x55,0xf8,0x0c,
+  0x0c,0x20,0x10,0x3f,0x3f,0x00,0x00,0x10,0x10,0x3f,
+  0x3f,0x3f,0x3f,
+};
+
+static struct dsi_cmd_desc display_soft_cmd = {
+	{DTYPE_GEN_LWRITE, 1, 0, 0, 1, sizeof(sharpca_basic_norm)}, sharpca_basic_norm
+
+};
+#elif defined(CONFIG_ZTEMT_MIPI_1080P_R63417_SHARP_IPS_5P5)
+//NX505J
+static char sharpca_basic_9b[] = {0xca, 0x01,0x80, 0x98,0x98,0x9b,0x40,0xbe,0xbe,0x20,0x20,
+	0x80,0xfe,0x0a, 0x4a,0x37,0xa0,0x55,0xf8,0x0c,0x0c,0x20,0x10,0x3f,0x3f,0x00,
+	0x00,0x10,0x10,0x3f,0x3f,0x3f,0x3f,
+};
+static struct dsi_cmd_desc display_glow_cmd = {
+	{DTYPE_GEN_LWRITE, 1, 0, 0, 1, sizeof(sharpca_basic_9b)}, sharpca_basic_9b
+
+};
+
+static char sharpca_basic_92[] = {0xca, 0x01,0x80, 0x92,0x92,0x9b,0x75,0x9b,0x9b,0x20,0x20,
+	0x80,0xfe,0x0a, 0x4a,0x37,0xa0,0x55,0xf8,0x0c,0x0c,0x20,0x10,0x3f,0x3f,0x00,
+	0x00,0x10,0x10,0x3f,0x3f,0x3f,0x3f,
+};
+
+static struct dsi_cmd_desc display_std_cmd = {
+	{DTYPE_GEN_LWRITE, 1, 0, 0, 1, sizeof(sharpca_basic_92)}, sharpca_basic_92
+
+};
+static char sharpca_basic_norm[] = {0xca, 0x00,0x80, 0x80,0x80,0x80,0x80,0x80,0x80,0x08,0x20,
+	0x80,0x80,0x0a, 0x4a,0x37,0xa0,0x55,0xf8,0x0c,0x0c,0x20,0x10,0x3f,0x3f,0x00,
+	0x00,0x10,0x10,0x3f,0x3f,0x3f,0x3f,
+};
+
+static struct dsi_cmd_desc display_soft_cmd = {
+	{DTYPE_GEN_LWRITE, 1, 0, 0, 1, sizeof(sharpca_basic_norm)}, sharpca_basic_norm
+
+};
+
+#elif defined(CONFIG_ZTEMT_MIPI_2K_R63419_SHARP_IPS_5P5)
+//NX506J
+static char sharpca_basic_9b[] = {
+	0xca, 0x81, 0x9f, 0x98, 0x9b, 0x40, 0xbe, 0xbe, 0x20, 0x20,
+	0x80, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
+	0x4a, 0x37, 0xa0, 0x55, 0xf8, 0x0c, 0x0c, 0x20, 0x10, 0x3f, 
+	0x3f, 0x10, 0x10, 0x3f, 0x3f, 0x3f, 0x3f, 0x00, 0xff, 0xff,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
+};
+static struct dsi_cmd_desc display_glow_cmd = {
+	{DTYPE_GEN_LWRITE, 1, 0, 0, 1, sizeof(sharpca_basic_9b)}, sharpca_basic_9b
+
+};
+
+static char sharpca_basic_92[] = {
+	0xca, 0x81, 0x96, 0x92, 0x9b, 0x75, 0x9b, 0x9b, 0x20, 0x20,
+	0x80, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
+	0x4a, 0x37, 0xa0, 0x55, 0xf8, 0x0c, 0x0c, 0x20, 0x10, 0x3f, 
+	0x3f, 0x10, 0x10, 0x3f, 0x3f, 0x3f, 0x3f, 0x00, 0xff, 0xff,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
+};
+
+static struct dsi_cmd_desc display_std_cmd = {
+	{DTYPE_GEN_LWRITE, 1, 0, 0, 1, sizeof(sharpca_basic_92)}, sharpca_basic_92
+
+};
+static char sharpca_basic_norm[] = {
+	0xca, 0x81, 0x8a, 0x80, 0x80, 0x80, 0x80, 0x80, 0x10, 0x20,
+	0x80, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
+	0x4a, 0x37, 0xa0, 0x55, 0xf8, 0x0c, 0x0c, 0x20, 0x10, 0x3f, 
+	0x3f, 0x10, 0x10, 0x3f, 0x3f, 0x3f, 0x3f, 0x00, 0xff, 0xff,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
+};
+
+static struct dsi_cmd_desc display_soft_cmd = {
+	{DTYPE_GEN_LWRITE, 1, 0, 0, 1, sizeof(sharpca_basic_norm)}, sharpca_basic_norm
+
+};
+
+#else
+static struct dsi_cmd_desc display_glow_cmd;
+static struct dsi_cmd_desc display_std_cmd;
+static struct dsi_cmd_desc display_soft_cmd;
+#endif
+
+void zte_send_cmd(struct dsi_cmd_desc *cmds,int cmdcount)
+{
+	struct dcs_cmd_req cmdreq;
+
+	if((!zte_mdss_dsi_ctrl) || (cmdcount < 1))	{
+		pr_err("lcd:faild:%s zte_mdss_dsi_ctrl is null\n",__func__);
+		return;
+	}
+
+	memset(&cmdreq, 0, sizeof(cmdreq));
+	cmdreq.cmds = cmds;
+	cmdreq.cmds_cnt = cmdcount;
+	cmdreq.flags = CMD_REQ_COMMIT;
+	cmdreq.rlen = 0;
+	cmdreq.cb = NULL;
+
+	mdss_dsi_cmdlist_put(zte_mdss_dsi_ctrl, &cmdreq);
+}
+
+void zte_mipi_saturation(void)
+{
+	unsigned int value;
+	value =zte_enhance_val.saturation;
+
+	if(!zte_enhance_val.en_saturation || ((NULL == display_std_cmd.payload) || \
+		(NULL == display_soft_cmd.payload) ||(NULL == display_glow_cmd.payload)) ||\
+		(NULL == zte_mdss_dsi_ctrl))
+		return;
+
+#ifdef ZTE_DISP_ENHANCE_DEBUG
+	printk("lcd:%s value=%d\n", __func__, value);
+#endif
+
+	switch (value) {
+	case INTENSITY_00:
+		zte_send_cmd(&display_soft_cmd,ZTE_SHARP_ENHANCE_CMD_COUNT);
+		break;
+	case INTENSITY_01:
+		zte_send_cmd(&display_std_cmd,ZTE_SHARP_ENHANCE_CMD_COUNT);
+		break;
+	case INTENSITY_02:
+		zte_send_cmd(&display_glow_cmd,ZTE_SHARP_ENHANCE_CMD_COUNT);
+		break;
+	default:
+		zte_send_cmd(&display_std_cmd,ZTE_SHARP_ENHANCE_CMD_COUNT);
+		break;
+	}
+}
+
+static ssize_t saturation_show(struct kobject *kobj, 
+	struct kobj_attribute *attr, char *buf)
+{	
+	return snprintf(buf, PAGE_SIZE, "%d\n",	zte_enhance_val.en_saturation);
+}
+
+static ssize_t saturation_store(struct kobject *kobj, struct kobj_attribute *attr,
+							const char *buf, size_t size)
+{
+	int val;
+
+	if(!zte_enhance_val.en_saturation)
+		return size;
+
+	sscanf(buf, "%d", &val);
+
+#ifdef ZTE_DISP_ENHANCE_DEBUG
+	printk("lcd:%s state=%d size=%d\n", __func__, (int)val, (int)size);
+#endif
+
+	zte_enhance_val.saturation =val;
+
+	zte_mipi_saturation();
+	return size;
+}
+
+
+void zte_mipi_colortmp(void)
+{
+	unsigned int value;
+	value =zte_enhance_val.colortmp;
+
+	if(!zte_enhance_val.en_colortmp || (NULL == zte_mdss_dsi_ctrl))
+		return ;
+	
+#ifdef ZTE_DISP_ENHANCE_DEBUG
+	printk("lcd:%s value=%d\n", __func__, value);
+#endif
+
+//#if defined(CONFIG_ZTEMT_MIPI_1080P_R63311_SHARP_IPS_6P4)
+#if 1
+	switch (value) {
+	case INTENSITY_00:
+		zte_mdss_pcc_config(&zte_pcc_cfg_normal);
+		break;
+	case INTENSITY_01:
+		zte_mdss_pcc_config(&zte_pcc_cfg_cool);
+		break;
+	case INTENSITY_02:
+		zte_mdss_pcc_config(&zte_pcc_cfg_cool1);
+		break;
+	default:
+		zte_mdss_pcc_config(&zte_pcc_cfg_normal);
+		break;
+	}
+#else
+	switch (value) {
+	case INTENSITY_00:
+		zte_mdss_pcc_config(&zte_pcc_cfg_warm);
+		break;
+	case INTENSITY_01:
+		zte_mdss_pcc_config(&zte_pcc_cfg_normal);
+		break;
+	case INTENSITY_02:
+		zte_mdss_pcc_config(&zte_pcc_cfg_cool);
+		break;
+	default:
+		zte_mdss_pcc_config(&zte_pcc_cfg_normal);
+		break;
+	}
+#endif
+}
+
+static ssize_t colortmp_show(struct kobject *kobj, 
+	struct kobj_attribute *attr, char *buf)
+{	
+	return snprintf(buf, PAGE_SIZE, "%d\n",	zte_enhance_val.colortmp);
+}
+
+static ssize_t colortmp_store(struct kobject *kobj, struct kobj_attribute *attr,
+    const char *buf, size_t size)
+{
+	int val;
+
+	if(!zte_enhance_val.en_colortmp)
+	     return size;
+
+	sscanf(buf, "%d", &val);
+
+#ifdef ZTE_DISP_ENHANCE_DEBUG
+	printk("lcd:%s state=%d size=%d\n", __func__, (int)val, (int)size);
+#endif
+
+	zte_enhance_val.colortmp = val;
+	
+	zte_mipi_colortmp();
+	return size;
+}
+
+
+void zte_set_ctrl_point(struct mdss_dsi_ctrl_pdata * ctrl)
+{
+#ifdef ZTE_DISP_ENHANCE_DEBUG
+	printk("lcd:%s \n", __func__);
+#endif
+
+	zte_mdss_dsi_ctrl = ctrl;
+}
+
+void zte_boot_begin_enhance(struct mdss_dsi_ctrl_pdata *ctrl)
+{
+#ifdef ZTE_DISP_ENHANCE_DEBUG
+	printk("lcd:%s \n", __func__);
+#endif
+	zte_set_ctrl_point(ctrl);
+
+	zte_mipi_saturation();
+	zte_mipi_colortmp();
+}
+
+static struct kobj_attribute attrs[] = {
+	__ATTR(saturation, 0664, saturation_show, saturation_store),
+	__ATTR(colortmp, 0664, colortmp_show, colortmp_store),
+};
+
+struct kobject *enhance__kobj;
+
+static int __init enhance_init(void)
+{
+	int retval;
+	int attr_count = 0;
+
+	enhance__kobj = kobject_create_and_add("lcd_enhance", kernel_kobj);
+
+	if (!enhance__kobj)
+		return -ENOMEM;
+
+	/* Create the files associated with this kobject */
+	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++) {
+		
+		if(!zte_enhance_val.en_colortmp && (attr_count == 1))
+			continue;
+	
+		retval = sysfs_create_file(enhance__kobj, &attrs[attr_count].attr);
+		if (retval < 0) {
+			pr_err("%s: Failed to create sysfs attributes\n", __func__);
+			goto err_sys;
+		}
+	}
+	
+	pr_info("lcd: %s Done.\n",__func__);
+
+	return retval;
+	
+err_sys:
+	for (attr_count--; attr_count >= 0; attr_count--) {
+		sysfs_remove_file(enhance__kobj, &attrs[attr_count].attr);
+	}
+	
+	kobject_put(enhance__kobj);
+	
+	pr_info("lcd: %s init ERR.\n",__func__);
+
+	return retval;
+}
+
+static void __exit enhance_exit(void)
+{
+	int attr_count = 0;
+	
+	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++) {
+		sysfs_remove_file(enhance__kobj, &attrs[attr_count].attr);
+	}
+	
+	kobject_put(enhance__kobj);
+	zte_mdss_dsi_ctrl = NULL;
+}
+
+module_init(enhance_init);
+module_exit(enhance_exit);
+
diff --git a/drivers/video/msm/mdss/zte_disp_enhance.h b/drivers/video/msm/mdss/zte_disp_enhance.h
new file mode 100755
index 0000000..ebf1164
--- /dev/null
+++ b/drivers/video/msm/mdss/zte_disp_enhance.h
@@ -0,0 +1,27 @@
+#ifndef _ZTE_DISP_ENHANCE_
+#define _ZTE_DISP_ENHANCE_
+
+#include "mdss_dsi.h"
+
+#define ZTE_DEFALUT_MAX_BLLEVEL 4095
+
+enum {
+	INTENSITY_00 = 24,
+	INTENSITY_01,
+	INTENSITY_02
+};
+struct zte_enhance_type{
+  int en_saturation;
+  int en_colortmp;
+  unsigned int saturation;
+  unsigned int colortmp;
+};
+
+struct zte_enhance_type zte_get_lcd_enhance_param(void);
+
+void zte_set_ctrl_point(struct mdss_dsi_ctrl_pdata * ctrl);
+void zte_mipi_saturation(void);
+void zte_mipi_colortmp(void);
+void zte_boot_begin_enhance(struct mdss_dsi_ctrl_pdata *ctrl);
+#endif 
+
diff --git a/drivers/video/msm/mdss/zte_tps65132.c b/drivers/video/msm/mdss/zte_tps65132.c
new file mode 100755
index 0000000..70fc69b8
--- /dev/null
+++ b/drivers/video/msm/mdss/zte_tps65132.c
@@ -0,0 +1,254 @@
+/*
+ * tps65312 driver
+ *
+ * Copyright (C) 2014 ZTEMT
+ *
+ * Create by mayu.
+ * Modify by luochangyang 2014.06.01
+ */
+
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/miscdevice.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/debugfs.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/string.h>
+#include <linux/of_gpio.h>
+#include <linux/pm_runtime.h>
+#include <linux/platform_device.h>
+#include <linux/device.h>
+
+#include "zte_tps65132.h"
+
+#define TPS65132_DRIVER_NAME	"tps65132"
+//#define NXP_TPS65132_DEBUG
+
+#if defined(CONFIG_ZTEMT_MIPI_1080P_R63311_SHARP_IPS_6P4)
+#define POSITIVE_VOLTAGE 5600
+#define NEGATIVE_VOLTAGE 5600
+#elif defined(CONFIG_ZTEMT_MIPI_1080P_R63311_SHARP_IPS_5P5)
+#define POSITIVE_VOLTAGE 5600
+#define NEGATIVE_VOLTAGE 5400
+#elif defined(CONFIG_ZTEMT_MIPI_2K_R63419_SHARP_IPS_5P5)
+#define POSITIVE_VOLTAGE 5800
+#define NEGATIVE_VOLTAGE 5800
+#else
+#define POSITIVE_VOLTAGE 5000
+#define NEGATIVE_VOLTAGE 5000
+#endif
+
+enum tps65132_irq {
+	TPS65132_NONE,
+	TPS65132_INT,
+};
+
+struct tps65132_data	{
+	wait_queue_head_t	read_wq;
+	struct mutex read_mutex;
+	struct i2c_client	*client;
+	struct miscdevice	miscdev;
+	bool irq_enabled;
+	spinlock_t irq_enabled_lock;
+	enum tps65132_irq read_irq;
+	
+	int updata_gpio;
+	int ven_gpio;
+	int irq_gpio;
+	int (*request_resources) (void);
+	void (*free_resources) (void);
+	void (*enable) (int fw);
+	int (*test) (void);
+	void (*disable) (void);
+	int (*irq_status) (void);
+};
+
+static struct tps65132_data * tps65132_dev;
+
+static int tps65132_write_reg_val(unsigned char reg, unsigned char val)
+{
+	int i = 0;
+	int err = 0;
+
+	while (i < 3)
+	{
+#ifdef NXP_TPS65132_DEBUG
+		printk("%s: 0x%x:0x%x \n", __FUNCTION__,reg, val);
+#endif
+		err = i2c_smbus_write_byte_data(tps65132_dev->client, reg, val);
+		if(err < 0){
+			printk(KERN_ERR"%s, err=%d\n", __FUNCTION__, err);
+			i++;
+		} else {
+			break;
+		}
+	}
+
+	return err;
+}
+
+static unsigned char tps65132_read_reg( unsigned char reg)
+{
+	return i2c_smbus_read_byte_data(tps65132_dev->client, reg);
+}
+
+void tps65132_set_output_voltage(int positive_voltage, int negative_voltage)
+{
+	int pos_val=0;
+	int neg_val=0;
+	int regff_val=0;
+	
+	pos_val= ( positive_voltage - 4000)/100;
+	neg_val= ( negative_voltage - 4000)/100;	
+
+#ifdef NXP_TPS65132_DEBUG
+	printk("%s:positive_voltage=%d,negative_voltage=%d, ",__func__,positive_voltage,negative_voltage);
+	printk("pos_val=0x%x , neg_val= 0x%x ~~~~~~~~~\n",pos_val,neg_val);
+#endif
+
+	tps65132_write_reg_val(0x00,pos_val);
+	tps65132_write_reg_val(0x01,neg_val);
+	regff_val=tps65132_read_reg(0xff)	;
+#ifdef NXP_TPS65132_DEBUG
+	printk("regff_val=0x%x~~~~~~~~~\n",regff_val);	
+#endif
+	regff_val |=(1<<8);
+#ifdef NXP_TPS65132_DEBUG
+	printk("regff_val=0x%x~~~~~~~~~\n",regff_val);
+#endif
+	tps65132_write_reg_val(0xff,regff_val);	
+
+}
+
+void  tps65132_show_reg(void )
+{
+	int val0,val1,regff_val;
+	val0=tps65132_read_reg(0x00);
+	val1=tps65132_read_reg(0x01);
+	regff_val=tps65132_read_reg(0xff);
+#ifdef NXP_TPS65132_DEBUG
+	printk("%s:reg00=0x%x, reg01=0x%x ,regff_val= 0x%x~~~~~~~~~~~~\n",__func__,val0,val1,regff_val);
+#endif	
+}
+
+void tps65132_set_output_avdd(void)
+{
+    pr_info("%s: +%d -%d\n", __func__, POSITIVE_VOLTAGE, NEGATIVE_VOLTAGE);
+	tps65132_set_output_voltage(POSITIVE_VOLTAGE, NEGATIVE_VOLTAGE);
+}
+
+static __devinit int tps65132_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	int irq_gpio = -1;
+	int updata_gpio = -1;
+	int ven_gpio = -1;
+	int ret;
+    struct regulator *vcc_i2c;
+  
+    dev_info(&client->dev, "%s : Start init.\n", __func__);
+
+#ifdef NXP_TPS65132_DEBUG
+	printk("[tps] %s:line%d +\n",__FUNCTION__,__LINE__);
+#endif
+	//I2C POWER
+	vcc_i2c = regulator_get(&client->dev, "vcc_i2c");
+	if (IS_ERR(vcc_i2c))
+	{
+		ret = PTR_ERR(vcc_i2c);
+		dev_err(&client->dev, "Regulator get failed rc=%d\n", ret);
+	}
+	ret = regulator_enable(vcc_i2c);
+
+	if (ret)
+		dev_err(&client->dev, "Regulator vcc_i2c enable failed rc=%d\n", ret);
+
+	if (tps65132_dev != NULL) {
+		dev_warn(&client->dev, "only one tps65132 supported.\n");
+		return -EBUSY;
+	}
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "%s : need I2C_FUNC_I2C\n", __func__);
+		return  -ENODEV;
+	}
+	
+	tps65132_dev = kzalloc(sizeof(struct tps65132_data), GFP_KERNEL);
+	if (tps65132_dev == NULL) {
+		dev_err(&client->dev, "failed to allocate memory for module data\n");
+		ret = -ENOMEM;
+		goto err_exit;
+	}
+	
+	tps65132_dev->client = client;
+	tps65132_dev->irq_gpio = irq_gpio;
+	tps65132_dev->updata_gpio = updata_gpio;
+	tps65132_dev->ven_gpio = ven_gpio;
+	
+	i2c_set_clientdata(client, tps65132_dev);
+	
+	tps65132_set_output_avdd();
+
+#ifdef NXP_TPS65132_DEBUG
+   printk("[tps] %s:line%d -\n",__FUNCTION__,__LINE__);
+#endif
+
+	return 0;
+
+err_exit:
+	return ret;
+	
+}
+
+static __devexit int tps65132_remove(struct i2c_client *client)
+{
+	struct tps65132_data *dev = i2c_get_clientdata(client);
+
+	dev_dbg(&client->dev, "%s\n", __func__);
+
+	if (dev->disable)
+		dev->disable();
+
+	mutex_destroy(&dev->read_mutex);
+	kfree(dev);
+
+	tps65132_dev = NULL;
+	
+	return 0;
+}
+
+static struct of_device_id tps_match_table[] = {
+	{ .compatible = "tps,tps65132_i2c_adapter",},
+	{ },
+};
+
+static const struct i2c_device_id tps65132_id_table[] = {
+	{ TPS65132_DRIVER_NAME, 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, tps65132_id_table);
+
+static struct i2c_driver tps65132_driver = {
+	.id_table	= tps65132_id_table,
+	.probe		= tps65132_probe,
+	.remove		= tps65132_remove,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= 	TPS65132_DRIVER_NAME,
+		.of_match_table = tps_match_table,
+	},
+};
+
+module_i2c_driver(tps65132_driver);
+
+MODULE_DESCRIPTION("I2C_TEST_TPS");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/video/msm/mdss/zte_tps65132.h b/drivers/video/msm/mdss/zte_tps65132.h
new file mode 100755
index 0000000..bccbb70
--- /dev/null
+++ b/drivers/video/msm/mdss/zte_tps65132.h
@@ -0,0 +1,10 @@
+#ifndef _ZTE_TPS65132_H_
+#define _ZTE_TPS65132_H_
+
+
+void tps65132_set_output_avdd(void);
+
+
+#endif /*_ZTE_TPS65132_H_*/
+
+
diff --git a/fs/Kconfig b/fs/Kconfig
old mode 100644
new mode 100755
diff --git a/fs/Makefile b/fs/Makefile
old mode 100644
new mode 100755
diff --git a/include/linux/batterydata-lib.h b/include/linux/batterydata-lib.h
old mode 100644
new mode 100755
index f556236..f39af78
--- a/include/linux/batterydata-lib.h
+++ b/include/linux/batterydata-lib.h
@@ -136,6 +136,10 @@ extern struct bms_battery_data  oem_batt_data;
 extern struct bms_battery_data QRD_4v35_2000mAh_data;
 extern struct bms_battery_data  qrd_4v2_1300mah_data;
 
+#ifdef CONFIG_ZTEMT_NX503A_CHARGE
+extern struct bms_battery_data  ztemt_NX503A_2300mAh_data;
+#endif
+
 int interpolate_fcc(struct single_row_lut *fcc_temp_lut, int batt_temp);
 int interpolate_scalingfactor(struct sf_lut *sf_lut, int row_entry, int pc);
 int interpolate_scalingfactor_fcc(struct single_row_lut *fcc_sf_lut,
diff --git a/include/linux/fs.h b/include/linux/fs.h
old mode 100644
new mode 100755
index 6181c690..fc9057f
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -23,7 +23,7 @@
 
 /* Fixed constants first: */
 #undef NR_OPEN
-#define INR_OPEN_CUR 1024	/* Initial setting for nfile rlimits */
+#define INR_OPEN_CUR 2048	/* Initial setting for nfile rlimits */
 #define INR_OPEN_MAX 4096	/* Hard limit for nfile rlimits */
 
 #define BLOCK_SIZE_BITS 10
diff --git a/include/linux/i2c/drv2605.h b/include/linux/i2c/drv2605.h
new file mode 100755
index 0000000..dd30bac
--- /dev/null
+++ b/include/linux/i2c/drv2605.h
@@ -0,0 +1,543 @@
+#ifndef __DRV2605_H__
+#define __DRV2605_H__
+/*
+** =============================================================================
+** Copyright (c)2012  Immersion Corporation.
+**
+** This program is free software; you can redistribute it and/or
+** modify it under the terms of the GNU General Public License
+** as published by the Free Software Foundation; either version 2
+** of the License, or (at your option) any later version.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU General Public License for more details.
+**
+** You should have received a copy of the GNU General Public License
+** along with this program; if not, write to the Free Software
+** Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+**
+** File:
+**     drv2605.h
+**
+** Description:
+**     Header file for drv2605.c
+**
+** =============================================================================
+*/
+
+/*
+  Drv2605
+
+  This file created by Immersion Corporation as an interim solution until
+  Texas Instruments provides an official header for the DRV2605 part.
+  Based on "DRV2605 Preliminary Datasheet 3-7-12 - Immersion.pdf"
+*/
+
+#include <linux/switch.h>
+
+//#define VIBRATOR_DEBUG
+#define VIBRATOR_MULTI_USERMODE
+//#define VIBRATOR_AUTO_CALIBRATE
+
+#define NUBIA_LRA_RATED_VOLTAGE              0X38
+#define NUBIA_LRA_OVERDRIVE_CLAMP_VOLTAGE    0X72
+#define NUBIA_LRA_EFFECT_LIBRARY             0X06
+#define NUBIA_LRA_Control3_REG               0X80
+
+#define NUBIA_LRA_AUTOCAL_COMPENSATION       0x08       //reference 0X07
+#define NUBIA_LRA_AUTOCAL_BACKEMF            0x96       //reference 0XE9
+#define NUBIA_LRA_FEEDBACK_CONTROL_REG       0xC6       //reference 0XC6
+
+#define HAPTICS_DEVICE_NAME "drv2605"
+#define DRIVER_VERSION "182"
+
+#define LIBRARY_A 0x01
+#define LIBRARY_B 0x02
+#define LIBRARY_C 0x03
+#define LIBRARY_D 0x04
+#define LIBRARY_E 0x05
+#define LIBRARY_F 0x06
+
+/*
+	DRV2605 built-in effect bank/library
+
+#if defined(CONFIG_HAPTICS_LRA)
+#define EFFECT_LIBRARY LIBRARY_F
+#elif defined(CONFIG_HAPTICS_ERM)
+#define EFFECT_LIBRARY LIBRARY_A
+#else
+#error "please define actuator type"
+#endif
+
+*/
+/*
+	GPIO port that enable power to the device
+*/
+//#define GPIO_PORT GPIO_VIBTONE_EN1
+
+/*
+  Rated Voltage:
+  Calculated using the formula r = v * 255 / 5.6
+  where r is what will be written to the register
+  and v is the rated voltage of the actuator
+
+  Overdrive Clamp Voltage:
+  Calculated using the formula o = oc * 255 / 5.6
+  where o is what will be written to the register
+  and oc is the overdrive clamp voltage of the actuator
+
+#if (EFFECT_LIBRARY == LIBRARY_A)
+#define ERM_RATED_VOLTAGE               0x3E
+#define ERM_OVERDRIVE_CLAMP_VOLTAGE     0x90
+
+#elif (EFFECT_LIBRARY == LIBRARY_B)
+#define ERM_RATED_VOLTAGE               0x90
+#define ERM_OVERDRIVE_CLAMP_VOLTAGE     0x90
+
+#elif (EFFECT_LIBRARY == LIBRARY_C)
+#define ERM_RATED_VOLTAGE               0x90
+#define ERM_OVERDRIVE_CLAMP_VOLTAGE     0x90
+
+#elif (EFFECT_LIBRARY == LIBRARY_D)
+#define ERM_RATED_VOLTAGE               0x90
+#define ERM_OVERDRIVE_CLAMP_VOLTAGE     0x90
+
+#elif (EFFECT_LIBRARY == LIBRARY_E)
+#define ERM_RATED_VOLTAGE               0x90
+#define ERM_OVERDRIVE_CLAMP_VOLTAGE     0x90
+
+#else
+#define ERM_RATED_VOLTAGE               0x90
+#define ERM_OVERDRIVE_CLAMP_VOLTAGE     0x90
+#endif
+
+#define LRA_SEMCO1036                   0
+#define LRA_SEMCO0934                   1
+#define LRA_SELECTION                   LRA_SEMCO1036
+
+#if (LRA_SELECTION == LRA_SEMCO1036)
+#define LRA_RATED_VOLTAGE               0x56
+#define LRA_OVERDRIVE_CLAMP_VOLTAGE     0x90
+#define LRA_RTP_STRENGTH                0x7F // 100% of rated voltage (closed loop)
+
+#elif (LRA_SELECTION == LRA_SEMCO0934)
+#define LRA_RATED_VOLTAGE               0x51
+#define LRA_OVERDRIVE_CLAMP_VOLTAGE     0x72
+#define LRA_RTP_STRENGTH                0x7F // 100% of rated voltage (closed loop)
+
+#elif (LRA_SELECTION == LRA_GIONEER)
+#define LRA_RATED_VOLTAGE               0x4E
+#define LRA_OVERDRIVE_CLAMP_VOLTAGE     0x72
+#define LRA_RTP_STRENGTH                0x7F // 100% of rated voltage (closed loop)
+#elif (LRA_SELECTION == LRA_RAGENTEK_SEMCO1030)
+#define LRA_RATED_VOLTAGE               0x50
+#define LRA_OVERDRIVE_CLAMP_VOLTAGE     0x81
+#define LRA_RTP_STRENGTH                0x7F // 100% of rated voltage (closed loop)
+#endif
+
+#if EFFECT_LIBRARY == LIBRARY_A
+#define REAL_TIME_PLAYBACK_STRENGTH 0x38 // ~44% of overdrive voltage (open loop)
+#elif EFFECT_LIBRARY == LIBRARY_F
+#define REAL_TIME_PLAYBACK_STRENGTH LRA_RTP_STRENGTH
+#else
+#define REAL_TIME_PLAYBACK_STRENGTH 0x7F // 100% of overdrive voltage (open loop)
+#endif
+*/
+#define GO_BIT_POLL_INTERVAL    15
+#define STANDBY_WAKE_DELAY      1
+
+#define REAL_TIME_PLAYBACK_STRENGTH 0x7F // 100% of overdrive voltage (open loop)
+
+/* Commands */
+#define HAPTIC_CMDID_PLAY_SINGLE_EFFECT     0x01
+#define HAPTIC_CMDID_PLAY_EFFECT_SEQUENCE   0x02
+#define HAPTIC_CMDID_PLAY_TIMED_EFFECT      0x03
+#define HAPTIC_CMDID_GET_DEV_ID             0x04
+#define HAPTIC_CMDID_RUN_DIAG               0x05
+#define HAPTIC_CMDID_AUDIOHAPTIC_ENABLE     0x06
+#define HAPTIC_CMDID_AUDIOHAPTIC_DISABLE    0x07
+#define HAPTIC_CMDID_AUDIOHAPTIC_GETSTATUS  0x08
+
+#define HAPTIC_CMDID_REG_WRITE  	0x09
+#define HAPTIC_CMDID_REG_READ   	0x0a
+#define HAPTIC_CMDID_REG_SETBIT  	0x0b
+
+#define HAPTIC_CMDID_PATTERN_RTP            0x0c
+#define HAPTIC_CMDID_RTP_SEQUENCE           0x0d
+#define HAPTIC_CMDID_STOP                   0xFF
+
+/* Command size */
+#define HAPTIC_CMDSZ_SINGLE_EFFECT     2
+#define HAPTIC_CMDSZ_EFFECT_SEQUENCE   9
+#define HAPTIC_CMDSZ_TIMED_EFFECT      3
+#define HAPTIC_CMDSZ_STOP              1
+
+/*
+** Go
+*/
+#define GO_REG 0x0C
+#define GO     0x01
+#define STOP   0x00
+
+/*
+** Gpio
+*/
+#define GPIO_LEVEL_HIGH 1
+#define GPIO_LEVEL_LOW  0
+
+/*
+** Status
+*/
+#define STATUS_REG          0x00
+#define STATUS_DEFAULT      0x00
+
+#define DIAG_RESULT_MASK    (1 << 3)
+#define AUTO_CAL_PASSED     (0 << 3)
+#define AUTO_CAL_FAILED     (1 << 3)
+#define DIAG_GOOD           (0 << 3)
+#define DIAG_BAD            (1 << 3)
+
+#define DEV_ID_MASK (7 << 5)
+
+#define DRV2605_VER_1DOT1 (3 << 5)
+#define DRV2605_VER_1DOT0 (5 << 5)
+
+#define DRV2604 (4 << 5)
+
+/*
+** Mode
+*/
+#define MODE_REG            0x01
+#define MODE_STANDBY        0x40
+
+#define DRV260X_MODE_MASK           0x07
+#define MODE_INTERNAL_TRIGGER       0
+#define MODE_EXTERNAL_TRIGGER_EDGE  1
+#define MODE_EXTERNAL_TRIGGER_LEVEL 2
+#define MODE_PWM_OR_ANALOG_INPUT    3
+#define MODE_AUDIOHAPTIC            4
+#define MODE_REAL_TIME_PLAYBACK     5
+#define MODE_DIAGNOSTICS            6
+#define AUTO_CALIBRATION            7
+
+#define MODE_STANDBY_MASK           0x40
+#define MODE_READY                  1 // default
+#define MODE_SOFT_STANDBY           0
+
+#define MODE_RESET                  0x80
+
+#define MODE_DIAGNOSTICS            6
+/*
+** Real Time Playback
+*/
+#define REAL_TIME_PLAYBACK_REG      0x02
+
+#define MODE_PATTERN_RTP_ON         0x08
+#define MODE_PATTERN_RTP_OFF        0x09
+#define MODE_SEQ_RTP_ON             0x0a
+#define MODE_SEQ_RTP_OFF            0x0b
+/*
+** Library Selection
+*/
+#define LIBRARY_SELECTION_REG       0x03
+#define LIBRARY_SELECTION_DEFAULT   0x00
+
+#define LIBRARY_SELECTION_MASK              0x07
+#define LIBRARY_SELECTION_LIBRARY_RAM       0 // default
+#define LIBRARY_SELECTION_LIBRARY_OVERDRIVE 1
+#define LIBRARY_SELECTION_LIBRARY_40_60     2
+#define LIBRARY_SELECTION_LIBRARY_60_80     3
+#define LIBRARY_SELECTION_LIBRARY_100_140   4
+#define LIBRARY_SELECTION_LIBRARY_140_PLUS  5
+
+#define LIBRARY_SELECTION_HIZ_MASK          0x10
+#define LIBRARY_SELECTION_HIZ_EN            1
+#define LIBRARY_SELECTION_HIZ_DIS           0
+
+/*
+** Waveform Sequencer
+*/
+#define WAVEFORM_SEQUENCER_REG      0x04
+#define WAVEFORM_SEQUENCER_REG2     0x05
+#define WAVEFORM_SEQUENCER_REG3     0x06
+#define WAVEFORM_SEQUENCER_REG4     0x07
+#define WAVEFORM_SEQUENCER_REG5     0x08
+#define WAVEFORM_SEQUENCER_REG6     0x09
+#define WAVEFORM_SEQUENCER_REG7     0x0A
+#define WAVEFORM_SEQUENCER_REG8     0x0B
+#define WAVEFORM_SEQUENCER_MAX      8
+#define WAVEFORM_SEQUENCER_DEFAULT  0x00
+
+/*
+** OverDrive Time Offset
+*/
+#define OVERDRIVE_TIME_OFFSET_REG  0x0D
+
+/*
+** Sustain Time Offset, postive
+*/
+#define SUSTAIN_TIME_OFFSET_POS_REG 0x0E
+
+/*
+** Sustain Time Offset, negative
+*/
+#define SUSTAIN_TIME_OFFSET_NEG_REG 0x0F
+
+/*
+** Brake Time Offset
+*/
+#define BRAKE_TIME_OFFSET_REG       0x10
+
+/*
+** Audio to Haptics Control
+*/
+#define AUDIO_HAPTICS_CONTROL_REG   0x11
+
+#define AUDIO_HAPTICS_RECT_10MS     (0 << 2)
+#define AUDIO_HAPTICS_RECT_20MS     (1 << 2)
+#define AUDIO_HAPTICS_RECT_30MS     (2 << 2)
+#define AUDIO_HAPTICS_RECT_40MS     (3 << 2)
+
+#define AUDIO_HAPTICS_FILTER_100HZ  0
+#define AUDIO_HAPTICS_FILTER_125HZ  1
+#define AUDIO_HAPTICS_FILTER_150HZ  2
+#define AUDIO_HAPTICS_FILTER_200HZ  3
+
+/*
+** Audio to Haptics Minimum Input Level
+*/
+#define AUDIO_HAPTICS_MIN_INPUT_REG 0x12
+
+/*
+** Audio to Haptics Maximum Input Level
+*/
+#define AUDIO_HAPTICS_MAX_INPUT_REG 0x13
+
+/*
+** Audio to Haptics Minimum Output Drive
+*/
+#define AUDIO_HAPTICS_MIN_OUTPUT_REG 0x14
+
+/*
+** Audio to Haptics Maximum Output Drive
+*/
+#define AUDIO_HAPTICS_MAX_OUTPUT_REG 0x15
+
+/*
+** Rated Voltage
+*/
+#define RATED_VOLTAGE_REG           0x16
+
+/*
+** Overdrive Clamp Voltage
+*/
+#define OVERDRIVE_CLAMP_VOLTAGE_REG 0x17
+
+/*
+** Auto Calibrationi Compensation Result
+*/
+#define AUTO_CALI_RESULT_REG        0x18
+
+/*
+** Auto Calibration Back-EMF Result
+*/
+#define AUTO_CALI_BACK_EMF_RESULT_REG 0x19
+
+/*
+** Feedback Control
+*/
+#define FEEDBACK_CONTROL_REG        0x1A
+#define FEEDBACK_CONTROL_DEVICE_TYPE_MASK        0x80
+#define FEEDBACK_CONTROL_BEMF_GAIN_MASK          0x03
+#define FEEDBACK_CONTROL_BEMF_ERM_GAIN0 0 // 0.33x
+#define FEEDBACK_CONTROL_BEMF_ERM_GAIN1 1 // 1.0x
+#define FEEDBACK_CONTROL_BEMF_ERM_GAIN2 2 // 1.8x
+#define FEEDBACK_CONTROL_BEMF_ERM_GAIN3 3 // 4.0x
+
+#define FEEDBACK_CONTROL_BEMF_LRA_GAIN0 0 // 5x
+#define FEEDBACK_CONTROL_BEMF_LRA_GAIN1 1 // 10x
+#define FEEDBACK_CONTROL_BEMF_LRA_GAIN2 2 // 20x
+#define FEEDBACK_CONTROL_BEMF_LRA_GAIN3 3 // 30x
+
+#define LOOP_RESPONSE_SLOW      (0 << 2)
+#define LOOP_RESPONSE_MEDIUM    (1 << 2) // default
+#define LOOP_RESPONSE_FAST      (2 << 2)
+#define LOOP_RESPONSE_VERY_FAST (3 << 2)
+
+#define FB_BRAKE_FACTOR_1X   (0 << 4) // 1x
+#define FB_BRAKE_FACTOR_2X   (1 << 4) // 2x
+#define FB_BRAKE_FACTOR_3X   (2 << 4) // 3x (default)
+#define FB_BRAKE_FACTOR_4X   (3 << 4) // 4x
+#define FB_BRAKE_FACTOR_6X   (4 << 4) // 6x
+#define FB_BRAKE_FACTOR_8X   (5 << 4) // 8x
+#define FB_BRAKE_FACTOR_16X  (6 << 4) // 16x
+#define FB_BRAKE_DISABLED    (7 << 4)
+
+#define FEEDBACK_CONTROL_MODE_ERM 0 // default
+#define FEEDBACK_CONTROL_MODE_LRA (1 << 7)
+
+/*
+** Control1
+*/
+#define Control1_REG            	0x1B
+#define Control1_REG_AC_COUPLE_MASK	0x20
+#define Control1_REG_DRIVE_TIME_MASK	0x1f
+
+#define STARTUP_BOOST_ENABLED   (1 << 7)
+#define STARTUP_BOOST_DISABLED  (0 << 7) // default
+#define AC_COUPLE_ENABLED       (1 << 5)
+#define AC_COUPLE_DISABLED      (0 << 5) // default
+
+#define DEFAULT_DRIVE_TIME      0x13
+#define AUDIOHAPTIC_DRIVE_TIME  0x13
+
+/*
+** Control2
+*/
+#define Control2_REG            0x1C
+
+#define IDISS_TIME_MASK         0x03
+#define IDISS_TIME_VERY_SHORT   0
+#define IDISS_TIME_SHORT        1
+#define IDISS_TIME_MEDIUM       2 // default
+#define IDISS_TIME_LONG         3
+
+#define BLANKING_TIME_MASK          0x0C
+#define BLANKING_TIME_VERY_SHORT    (0 << 2)
+#define BLANKING_TIME_SHORT         (1 << 2)
+#define BLANKING_TIME_MEDIUM        (2 << 2) // default
+#define BLANKING_TIME_VERY_LONG     (3 << 2)
+
+#define AUTO_RES_GAIN_MASK         0x30
+#define AUTO_RES_GAIN_VERY_LOW     (0 << 4)
+#define AUTO_RES_GAIN_LOW          (1 << 4)
+#define AUTO_RES_GAIN_MEDIUM       (2 << 4) // default
+#define AUTO_RES_GAIN_HIGH         (3 << 4)
+
+#define SOFT_BRAKE_MASK            0x40
+
+#define BIDIR_INPUT_MASK           0x80
+#define UNIDIRECT_INPUT            (0 << 7)
+#define BRAKE_STABLIZER   (1<<6)
+#define BIDIRECT_INPUT             (1 << 7) // default
+
+/*
+** Control3
+*/
+#define Control3_REG 0x1D
+#define Control3_REG_LOOP_MASK		0x21
+#define Control3_REG_PWMANALOG_MASK	0x02
+
+#define INPUT_PWM               (0 << 1) // default
+#define INPUT_ANALOG            (1 << 1)
+#define ERM_OpenLoop_Enabled    (1 << 5)
+#define NG_Thresh_DISABLED      (0 << 6)
+#define NG_Thresh_1             (1 << 6)
+#define NG_Thresh_2             (2 << 6)
+#define NG_Thresh_3             (3 << 6)
+
+/*
+** Auto Calibration Memory Interface
+*/
+#define AUTOCAL_MEM_INTERFACE_REG   0x1E
+#define AUTOCAL_MEM_INTERFACE_REG_OTP_MASK   0x04
+
+#define AUTOCAL_TIME_150MS          (0 << 4)
+#define AUTOCAL_TIME_250MS          (1 << 4)
+#define AUTOCAL_TIME_500MS          (2 << 4)
+#define AUTOCAL_TIME_1000MS         (3 << 4)
+
+#define SILICON_REVISION_REG        0x3B
+#define SILICON_REVISION_MASK       0x07
+
+//reset values
+#define AUDIO_HAPTICS_MIN_INPUT_VOLTAGE     0x19
+#define AUDIO_HAPTICS_MAX_INPUT_VOLTAGE     0xff
+#define AUDIO_HAPTICS_MIN_OUTPUT_VOLTAGE    0x19
+#define AUDIO_HAPTICS_MAX_OUTPUT_VOLTAGE    0xFF
+
+#define DEFAULT_ERM_AUTOCAL_COMPENSATION    0x14
+#define DEFAULT_ERM_AUTOCAL_BACKEMF         0x72
+
+#define DEFAULT_LRA_AUTOCAL_COMPENSATION    0x06
+#define DEFAULT_LRA_AUTOCAL_BACKEMF         0xDE
+
+#define MAX_TIMEOUT 10000 /* 10s */
+
+#define SW_STATE_IDLE				0x00
+#define SW_STATE_AUDIO2HAPTIC			0x01
+#define SW_STATE_SEQUENCE_PLAYBACK		0x02
+#define SW_STATE_RTP_PLAYBACK			0x04
+
+enum actuator_type {
+	ERM,
+	LRA
+};
+
+enum loop_type {
+	OPEN_LOOP,
+	CLOSE_LOOP
+};
+
+struct actuator_data {
+	enum actuator_type device_type;
+	unsigned char	g_effect_bank;
+	enum loop_type	loop;
+	unsigned char 	rated_vol;
+	unsigned char 	over_drive_vol;
+	unsigned char	drive_time;
+};
+
+struct audio2haptics_data {
+	unsigned char 	a2h_min_input;
+	unsigned char 	a2h_max_input;
+	unsigned char 	a2h_min_output;
+	unsigned char 	a2h_max_output;
+};
+
+struct drv2605_platform_data {
+	int				GpioEnable;
+	int 			GpioTrigger;
+	struct actuator_data actuator;
+	struct audio2haptics_data a2h;
+};
+
+struct RTP_Seq {
+	unsigned short RTPData[16]; //RTPTime<<8||RTPAmp
+	int RTPCounts;
+	int RTPindex;
+};
+
+struct drv2605_data {
+	struct drv2605_platform_data PlatData;
+	struct i2c_client *client;
+	int	device_id;
+
+	struct class* class;
+	struct device* device;
+	dev_t version;
+	struct semaphore sem;
+	struct cdev cdev;
+	struct switch_dev sw_dev;
+	int audio_haptics_enabled;
+	int vibrator_is_playing;
+#ifdef VIBRATOR_MULTI_USERMODE
+	int usermode;
+#endif
+	char read_val;
+	char *pReadValue;
+	int ReadLen;
+
+	int vibration_time;
+	int silience_time;
+	char repeat_times;
+	char mode;
+
+	struct RTP_Seq RTPSeq;
+
+	int OTP;
+};
+
+#endif
diff --git a/include/linux/i2c/maxq616.h b/include/linux/i2c/maxq616.h
new file mode 100755
index 0000000..844fdb3
--- /dev/null
+++ b/include/linux/i2c/maxq616.h
@@ -0,0 +1,64 @@
+#ifndef __MAXQ616_H
+#define __MAXQ616_H
+
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kobject.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/miscdevice.h>
+#include <linux/regulator/consumer.h>
+#include <linux/err.h>
+#include <linux/of_gpio.h>
+#include <linux/pm_runtime.h>
+#include <linux/wakelock.h>
+
+#ifdef CONFIG_BOARD_ZTEMT_NX504J
+#define HALL_DEVICE_INT_S    67
+#else
+#define HALL_DEVICE_INT_S    62
+#endif
+#define HALL_DEVICE_INT_N    68
+
+#define MAGNETIC_DEVICE_NEAR   1  //Near
+#define MAGNETIC_DEVICE_FAR    2  //Far
+
+struct akm8789_irq {
+    unsigned int irq_num;
+    unsigned int irq_pin;
+    bool enabled;
+};
+
+struct akm8789_wake_lock{
+    struct wake_lock lock;
+    bool   locked;
+    char   *name;
+};
+
+
+struct maxq616_chip {
+	struct i2c_client *client;
+    struct regulator  *power;
+    bool  power_on;
+};
+
+
+
+
+
+
+#endif /* __MAXQ616_H */
diff --git a/include/linux/i2c/sensor_common.h b/include/linux/i2c/sensor_common.h
new file mode 100755
index 0000000..2c91040
--- /dev/null
+++ b/include/linux/i2c/sensor_common.h
@@ -0,0 +1,37 @@
+
+#ifndef __SENSOR_COMMON_H_
+#define __SENSOR_COMMON_H_
+
+
+struct sensor_common_data {
+    struct i2c_client *client;
+    struct device *sensor_compass_dev;
+    struct device *sensor_temp_humidity_dev;
+
+    int compass_irq_gpio;
+
+};
+
+#define COMPASS_INT_PIN     64
+
+#define PATH_RAW_TEMP           "/sys/class/temperature/temperature/temperature_data"
+#define PATH_RAW_HUMIDITY       "/sys/class/humidity/humidity/humidity_data"
+#define PATH_TEMP_CPU_0         "/sys/class/thermal/thermal_zone5/temp"
+#define PATH_TEMP_CPU_1         "/sys/class/thermal/thermal_zone6/temp"
+#define PATH_TEMP_CPU_2         "/sys/class/thermal/thermal_zone7/temp"
+#define PATH_TEMP_CPU_3         "/sys/class/thermal/thermal_zone8/temp"
+#define PATH_TEMP_RF            "/sys/class/thermal/thermal_zone13/temp"
+#define PATH_TEMP_BATTERY       "/sys/class/power_supply/battery/temp"
+#define PATH_TEMP_CHARGING      "/sys/class/thermal/thermal_zone2/temp"
+#define PATH_TEMP_LCD           "/sys/class/thermal/thermal_zone3/temp"
+#define PATH_LCD_BRIGHTNESS     "/sys/class/leds/lcd-backlight/brightness"
+#define PATH_BATTERY_LEVEL      "/sys/class/power_supply/battery/capacity"
+#define PATH_BATTERY_STATE      "/sys/class/power_supply/battery/voltage_now"
+#define PATH_CHARGE_CURRENT     "/sys/class/power_supply/battery/current_now"
+#define PATH_CHARGE_STATE       "/sys/class/power_supply/battery/status"
+#define PATH_RF_STATE           "/sys/class/"
+
+
+static int __devinit sensor_common_probe(struct i2c_client *client, const struct i2c_device_id *id);
+static int __devexit sensor_common_remove(struct i2c_client *client);
+#endif
diff --git a/include/linux/i2c/taos_common.h b/include/linux/i2c/taos_common.h
new file mode 100755
index 0000000..90bff12
--- /dev/null
+++ b/include/linux/i2c/taos_common.h
@@ -0,0 +1,85 @@
+/*******************************************************************************
+*                                                                              *
+*       File Name:      taos_common.h                                          *
+*       Description:    Common file for ioctl and configuration definitions.   *
+*       		Used by kernel driver and driver access applications.  *
+*       		Please include this file, and <sys/ioctl.h> in your    * 
+*                       driver access application program source.	       *
+*       Author:         John Koshi                                             *
+*       History:        09/16/2009 - Initial creation                          *
+*       		02/07/2010 - Add proximity			       *
+*                                                                              *
+********************************************************************************
+*       Proprietary to Taos Inc., 1001 Klein Road #300, Plano, TX 75074        *
+*******************************************************************************/
+// ioctl numbers
+//#include <types.h>
+#include <linux/wakelock.h>
+
+#define TAOS_IOCTL_MAGIC        	0XCF
+#define TAOS_IOCTL_ALS_ON       	_IO(TAOS_IOCTL_MAGIC, 1)
+#define TAOS_IOCTL_ALS_OFF      	_IO(TAOS_IOCTL_MAGIC, 2)
+#define TAOS_IOCTL_ALS_DATA     	_IOR(TAOS_IOCTL_MAGIC, 3, short)
+#define TAOS_IOCTL_ALS_CALIBRATE	_IO(TAOS_IOCTL_MAGIC, 4)
+#define TAOS_IOCTL_CONFIG_GET   	_IOR(TAOS_IOCTL_MAGIC, 5, struct taos_cfg *)
+#define TAOS_IOCTL_CONFIG_SET		_IOW(TAOS_IOCTL_MAGIC, 6, struct taos_cfg)
+#define TAOS_IOCTL_PROX_ON		    _IO(TAOS_IOCTL_MAGIC, 7)
+#define TAOS_IOCTL_PROX_OFF		    _IO(TAOS_IOCTL_MAGIC, 8)
+#define TAOS_IOCTL_PROX_DATA		_IOR(TAOS_IOCTL_MAGIC, 9, struct taos_prox_info)
+#define TAOS_IOCTL_PROX_EVENT       _IO(TAOS_IOCTL_MAGIC, 10)
+#define TAOS_IOCTL_PROX_CALIBRATE	_IO(TAOS_IOCTL_MAGIC, 11)
+
+#define TAOS_IOCTL_SENSOR_ON	    (TAOS_IOCTL_MAGIC, 12)
+#define TAOS_IOCTL_SENSOR_OFF	    _IO(TAOS_IOCTL_MAGIC, 13)
+#define TAOS_IOCTL_SENSOR_CONFIG	_IOW(TAOS_IOCTL_MAGIC, 14, struct taos_cfg)
+#define TAOS_IOCTL_SENSOR_CHECK	    _IO(TAOS_IOCTL_MAGIC, 15)
+#define TAOS_IOCTL_SENSOR_test	    _IO(TAOS_IOCTL_MAGIC, 16)
+
+#define TAOS_IOCTL_ALS_SET_DELAY	_IO(TAOS_IOCTL_MAGIC, 17)
+
+// device configuration
+struct taos_cfg 
+{
+    u32 calibrate_target;
+    u16 als_time;
+    u16 scale_factor_als;
+	u16 scale_factor_prox;
+    u16 gain_trim;
+    u8  filter_history;
+    u8  filter_count;
+    u8  gain;
+	u16	prox_threshold_hi;
+	u16 prox_threshold_lo;
+	u16	als_threshold_hi;
+	u16 als_threshold_lo;
+	u8	prox_int_time;
+	u8	prox_adc_time;
+	u8	prox_wait_time;
+	u8	prox_intr_filter;
+	u8	prox_config;
+	u8	prox_pulse_cnt;
+	u8	prox_gain;
+	u8	prox_config_offset;
+};
+
+// proximity data
+struct taos_prox_info 
+{
+        u16 prox_clear;
+        u16 prox_data;
+        int prox_event;
+};
+
+struct taos_wake_lock{
+    struct wake_lock lock;
+    bool   locked;
+    char   *name;
+};
+
+// add by clli2 for proximity debug
+enum
+{
+	DEBUG_DEFAULT = 1U << 0,
+	DEBUG_CRITICAL = 1U << 2,
+	DEBUG_ABNORMAL = 1U << 3, //don't modify it
+};
diff --git a/include/linux/i2c/tmg399x.h b/include/linux/i2c/tmg399x.h
new file mode 100755
index 0000000..5d11b7c
--- /dev/null
+++ b/include/linux/i2c/tmg399x.h
@@ -0,0 +1,524 @@
+/*
+ * Device driver for monitoring ambient light intensity in (lux)
+ * proximity detection (prox), and Gesture functionality within the
+ * AMS-TAOS TMG399X family of devices.
+ *
+ * Copyright (c) 2013, AMS-TAOS USA, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __TMG399X_H
+#define __TMG399X_H
+
+#include <linux/types.h>
+#include <linux/wakelock.h>
+
+/* Max number of segments allowable in LUX table */
+#define TMG399X_MAX_LUX_TABLE_SIZE		9
+#define MAX_DEFAULT_TABLE_BYTES (sizeof(int) * TMG399X_MAX_LUX_TABLE_SIZE)
+
+/* Default LUX and Color coefficients */
+
+#define D_Factor	241
+#define R_Coef		144
+#define G_Coef		1000
+#define B_Coef		400
+#define CT_Coef		(3972)
+#define CT_Offset	(1672)
+
+#define D_Factor1	615*4
+#define R_Coef1		443
+#define G_Coef1		1000
+#define B_Coef1		180
+#define CT_Coef1	(2042)
+#define CT_Offset1	(2396)
+
+#define PATH_CAL_THRESHOLD       "/persist/proxdata/threshold"
+#define PATH_PROX_OFFSET_NE      "/persist/sensors/proximity/offset/ne"
+#define PATH_PROX_OFFSET_SW      "/persist/sensors/proximity/offset/sw"
+#define PATH_PROX_UNCOVER_DATA   "/persist/sensors/proximity/uncover_data"
+
+
+#define PATH_GESTURE_OFFSET_N    "/persist/sensors/gesture/offset/n"
+#define PATH_GESTURE_OFFSET_S    "/persist/sensors/gesture/offset/s"
+#define PATH_GESTURE_OFFSET_W    "/persist/sensors/gesture/offset/w"
+#define PATH_GESTURE_OFFSET_E    "/persist/sensors/gesture/offset/e"
+
+#define	AMS_ALS_POLL_DELAY_FAST	         500
+#define	AMS_ALS_POLL_DELAY_SLOW	         1000
+#define AMS_ALS_ATIME_LONG               0xEE
+#define AMS_ALS_ATIME_SHORT              0xF8
+
+#define PROX_FAR                     0
+#define PROX_NEAR                    1
+#define PROX_UNKNOW                 -1
+
+#define PROX_LED_PULSE_CNT                  4
+#define PROX_THRESHOLD_DISTANCE             30
+#define PROX_DATA_TARGET                    20
+#define PROX_DATA_MAX                       255
+#define PROX_OFFSET_CAL_BUFFER_SIZE         30
+#define PROX_OFFSET_CAL_THRESHOLD           75
+#define PROX_OFFSET_CAL_ABILITY_MAX         127
+#define PROX_DATA_SAFE_RANGE_MIN            (PROX_DATA_TARGET*2 - 10)
+#define PROX_DATA_SAFE_RANGE_MAX            (PROX_DATA_TARGET*2 + 40)
+#define PROX_OFFSET_CAL_GETDATA_DELAY       10
+#define PROX_OFFSET_CAL_PER_BIT             100 / (15 * PROX_LED_PULSE_CNT)
+#define PROX_DEFAULT_THRESHOLD_HIGH         150
+#define PROX_DEFAULT_THRESHOLD_LOW          PROX_DEFAULT_THRESHOLD_HIGH - PROX_THRESHOLD_DISTANCE
+#define PROX_THRESHOLD_HIGH_MAX             200
+#define PROX_THRESHOLD_SAFE_DISTANCE        PROX_THRESHOLD_DISTANCE / 2
+#define PROX_DEFAULT_OFFSET_NE              0
+#define PROX_DEFAULT_OFFSET_SW              0
+
+
+#define GESTURE_LED_PULSE_CNT               4
+#define GESTURE_DATA_TARGET                 20
+#define GESTURE_DATA_MAX                    255
+#define GESTURE_OFFSET_CAL_BUFFER_SIZE      60
+#define GESTURE_OFFSET_CAL_THRESHOLD        150
+#define GESTURE_OFFSET_CAL_ABILITY_MAX      127
+#define GESTURE_DATA_SAFE_RANGE_MIN         (GESTURE_DATA_TARGET - 10)
+#define GESTURE_DATA_SAFE_RANGE_MAX         (GESTURE_DATA_TARGET + 10)
+#define GESTURE_OFFSET_CAL_GETDATA_DELAY    10
+#define GESTURE_OFFSET_CAL_PER_BIT          100 / (30 * GESTURE_LED_PULSE_CNT)
+#define GESTURE_DEFAULT_OFFSET_N            30
+#define GESTURE_DEFAULT_OFFSET_S            0
+#define GESTURE_DEFAULT_OFFSET_W            0
+#define GESTURE_DEFAULT_OFFSET_E            0
+#define GESTURE_ENTER_THRESHOLD             0
+#define GESTURE_EXIT_THRESHOLD              0
+
+
+#define TMG399X_CMD_IRBEAM_INT_CLR	0xE3
+#define TMG399X_CMD_PROX_INT_CLR	0xE5
+#define TMG399X_CMD_ALS_INT_CLR		0xE6
+#define TMG399X_CMD_NON_GES_INT_CLR	0xE7
+
+#define PRX_PERSIST(p) (((p) & 0xf) << 4)
+#define ALS_PERSIST(p) (((p) & 0xf) << 0)
+#define PRX_PULSE_CNT(p) (((p-1) & 0x3f) << 0)
+#define GES_PULSE_CNT(p) (((p-1) & 0x3f) << 0)
+
+#define I2C_ADDR_OFFSET	0X80
+
+enum tmg399x_regs {
+	TMG399X_CONTROL,
+	TMG399X_ALS_TIME,
+	TMG399X_RESV_1,
+	TMG399X_WAIT_TIME,
+	TMG399X_ALS_MINTHRESHLO,
+	TMG399X_ALS_MINTHRESHHI,
+	TMG399X_ALS_MAXTHRESHLO,
+	TMG399X_ALS_MAXTHRESHHI,
+	TMG399X_RESV_2,
+	TMG399X_PRX_THRES_LOW,
+	TMG399X_RESV_3,
+	TMG399X_PRX_THRES_HIGH,
+	TMG399X_PERSISTENCE,
+	TMG399X_CONFIG_1,
+	TMG399X_PRX_PULSE,
+	TMG399X_GAIN,
+
+	TMG399X_CONFIG_2,
+	TMG399X_REVID,
+	TMG399X_CHIPID,
+	TMG399X_STATUS,
+	TMG399X_CLR_CHANLO,
+	TMG399X_CLR_CHANHI,
+	TMG399X_RED_CHANLO,
+	TMG399X_RED_CHANHI,
+	TMG399X_GRN_CHANLO,
+	TMG399X_GRN_CHANHI,
+	TMG399X_BLU_CHANLO,
+	TMG399X_BLU_CHANHI,
+	TMG399X_PRX_CHAN,
+	TMG399X_PRX_OFFSET_NE,
+	TMG399X_PRX_OFFSET_SW,
+	TMG399X_CONFIG_3,
+
+	TMG399X_GES_ENTH,
+	TMG399X_GES_EXTH,
+	TMG399X_GES_CFG_1,
+	TMG399X_GES_CFG_2,
+	TMG399X_GES_OFFSET_N,
+	TMG399X_GES_OFFSET_S,
+	TMG399X_GES_PULSE,
+	TMG399X_GES_OFFSET_W,
+	TMG399X_GES_RESV,
+	TMG399X_GES_OFFSET_E,
+	TMG399X_GES_CFG_3,
+	TMG399X_GES_CFG_4,
+	TMG399X_RESV_4,
+	TMG399X_RESV_5,
+	TMG399X_GES_FLVL,
+	TMG399X_GES_STAT,
+
+	TMG399X_REG_MAX,
+};
+
+enum tmg399x_irbeam_regs {
+	TMG399X_IRBEAM_CFG = 0x20,
+	TMG399X_IRBEAM_RESV,
+	TMG399X_IRBEAM_NS,
+	TMG399X_IRBEAM_ISD,
+	TMG399X_IRBEAM_NP,
+	TMG399X_IRBEAM_IPD,
+	TMG399X_IRBEAM_DIV,
+	TMG399X_IRBEAM_LEN,
+	TMG399X_IRBEAM_STAT,
+};
+
+enum tmg399x_gesfifo_regs {
+	TMG399X_GES_NFIFO = 0x7C,
+	TMG399X_GES_SFIFO,
+	TMG399X_GES_WFIFO,
+	TMG399X_GES_EFIFO,
+};
+
+enum tmg399x_remote_regs {
+	TMG399X_REMOTE_CFG = 0x20,
+	TMG399X_REMOTE_CARR,
+	TMG399X_REMOTE_NS,
+	TMG399X_REMOTE_DLY2T,
+	TMG399X_REMOTE_NCP,
+	TMG399X_REMOTE_CPOFF,
+	TMG399X_REMOTE_DIV,
+	TMG399X_REMOTE_LEN,
+	TMG399X_REMOTE_STAT,
+	TMG399X_REMOTE_SLEN,
+};
+
+enum tmg399x_pwr_state {
+	POWER_ON,
+	POWER_OFF,
+	POWER_STANDBY,
+};
+
+enum tmg399x_en_reg {
+	TMG399X_EN_PWR_ON   = (1 << 0),
+	TMG399X_EN_ALS      = (1 << 1),
+	TMG399X_EN_PRX      = (1 << 2),
+	TMG399X_EN_WAIT     = (1 << 3),
+	TMG399X_EN_ALS_IRQ  = (1 << 4),
+	TMG399X_EN_PRX_IRQ  = (1 << 5),
+	TMG399X_EN_GES      = (1 << 6),
+	TMG399X_EN_BEAM     = (1 << 7),
+};
+
+enum tmg399x_cfgl_reg {
+	WLONG          = (1 << 1),
+};
+
+enum tmg399x_ppulse_reg {
+	PPLEN_4US      = (0 << 6),
+	PPLEN_8US      = (1 << 6),
+	PPLEN_16US     = (2 << 6),
+	PPLEN_32US     = (3 << 6),
+};
+
+enum tmg399x_ctrl_reg {
+	AGAIN_1        = (0 << 0),
+	AGAIN_4        = (1 << 0),
+	AGAIN_16       = (2 << 0),
+	AGAIN_64       = (3 << 0),
+	PGAIN_1        = (0 << 2),
+	PGAIN_2        = (1 << 2),
+	PGAIN_4        = (2 << 2),
+	PGAIN_8        = (3 << 2),
+	PDRIVE_100MA   = (0 << 6),
+	PDRIVE_50MA    = (1 << 6),
+	PDRIVE_25MA    = (2 << 6),
+	PDRIVE_12MA    = (3 << 6),
+};
+
+
+enum tmg399x_cfg2_reg {
+	LEDBOOST_100   = (0 << 4),
+	LEDBOOST_150   = (1 << 4),
+	LEDBOOST_200   = (2 << 4),
+	LEDBOOST_300   = (3 << 4),
+	CPSIEN         = (1 << 6),
+	PSIEN          = (1 << 7),
+};
+
+enum tmg399x_status {
+	TMG399X_ST_ALS_VALID  = (1 << 0),
+	TMG399X_ST_PRX_VALID  = (1 << 1),
+	TMG399X_ST_GES_IRQ    = (1 << 2),
+	TMG399X_ST_BEAM_IRQ   = (1 << 3),
+	TMG399X_ST_ALS_IRQ    = (1 << 4),
+	TMG399X_ST_PRX_IRQ    = (1 << 5),
+	TMG399X_ST_PRX_SAT    = (1 << 6),
+	TMG399X_ST_CP_SAT     = (1 << 7),
+};
+
+enum tmg399x_cfg3_reg {
+	PMASK_E        = (1 << 0),
+	PMASK_W        = (1 << 1),
+	PMASK_S        = (1 << 2),
+	PMASK_N        = (1 << 3),
+	SAI            = (1 << 4),
+	PCMP           = (1 << 5),
+};
+
+enum tmg399x_ges_cfg1_reg {
+	GEXPERS_1      = (0 << 0),
+	GEXPERS_2      = (1 << 0),
+	GEXPERS_4      = (2 << 0),
+	GEXPERS_7      = (3 << 0),
+	GEXMSK_E       = (1 << 2),
+	GEXMSK_W       = (1 << 3),
+	GEXMSK_S       = (1 << 4),
+	GEXMSK_N       = (1 << 5),
+	FIFOTH_1       = (0 << 6),
+	FIFOTH_4       = (1 << 6),
+	FIFOTH_8       = (2 << 6),
+	FIFOTH_16      = (3 << 6),
+};
+
+enum tmg399x_ges_cfg2_reg {
+	GWTIME_0       = (0 << 0),
+	GWTIME_3       = (1 << 0),
+	GWTIME_6       = (2 << 0),
+	GWTIME_8       = (3 << 0),
+	GWTIME_14      = (4 << 0),
+	GWTIME_22      = (5 << 0),
+	GWTIME_30      = (6 << 0),
+	GWTIME_39      = (7 << 0),
+	GLDRIVE_100    = (0 << 3),
+	GLDRIVE_50     = (1 << 3),
+	GLDRIVE_25     = (2 << 3),
+	GLDRIVE_12     = (3 << 3),
+	GGAIN_1        = (0 << 5),
+	GGAIN_2        = (1 << 5),
+	GGAIN_4        = (2 << 5),
+	GGAIN_8        = (3 << 5),
+};
+
+enum tmg399x_gpulse_reg {
+	GPLEN_4US      = (0 << 6),
+	GPLEN_8US      = (1 << 6),
+	GPLEN_16US     = (2 << 6),
+	GPLEN_32US     = (3 << 6),
+};
+
+enum tmg399x_ges_cfg3_reg {
+	GBOTH_PAIR     = (0 << 0),
+	GONLY_NS       = (1 << 0),
+	GONLY_WE       = (2 << 0),
+};
+
+enum tmg399x_ges_cfg4 {
+	TMG399X_GES_MODE     = (1 << 0),
+	TMG399X_GES_EN_IRQ   = (1 << 1),
+	TMG399X_GES_INT_CLR  = (1 << 2),
+};
+
+enum tmg399x_ges_status {
+	TMG399X_GES_VALID     = (1 << 0),
+	TMG399X_GES_FOV       = (1 << 1),
+};
+
+enum {
+	TMG399X_ALS_GAIN_MASK = (3 << 0),
+	TMG399X_PRX_GAIN_MASK = (3 << 2),
+	TMG399X_LDRIVE_MASK   = (3 << 6),
+	TMG399X_ALS_AGL_MASK  = (1 << 2),
+	TMG399X_ALS_AGL_BOOST = 2,
+	TMG399X_ATIME_PER_100 = 278,
+	//TMG399X_ATIME_DEFAULT_MS = 50,
+	SCALE_SHIFT = 11,
+	RATIO_SHIFT = 10,
+	MAX_ALS_VALUE = 0xffff,
+	MIN_ALS_VALUE = 0,
+	GAIN_SWITCH_LEVEL = 100,
+	//GAIN_AUTO_INIT_VALUE = AGAIN_16,
+	TMG399X_GES_ST_MASK   = (3 << 0),
+    TMG399X_GES_GAIN_MASK = (3 << 5)
+};
+
+struct tmg399x_als_info {
+	u32 cpl;
+	u32 saturation;
+	u16 clear_raw;
+	u16 red_raw;
+	u16 green_raw;
+	u16 blue_raw;
+	u16 lux;
+	u16 cct;
+	s16 ir;
+};
+
+struct tmg399x_prox_info {
+	int raw;
+	int detected;
+};
+
+struct tmg399x_parameters {
+	u8 als_time;
+	u8 als_gain;
+	u16 als_deltaP;
+	u8 wait_time;
+	u8 prox_th_low;
+	u8 prox_th_high;
+	u8 persist;
+	u8 als_prox_cfg1;
+	u8 prox_pulse;
+	u8 prox_gain;
+	u8 ldrive;
+	u8 als_prox_cfg2;
+	u8 prox_offset_ne;
+	u8 prox_offset_sw;
+	u8 als_prox_cfg3;
+	
+	u8 ges_entry_th;
+	u8 ges_exit_th;
+	u8 ges_cfg1;
+	u8 ges_cfg2;
+	s8 ges_offset_n;
+	s8 ges_offset_s;
+	u8 ges_pulse;
+	s8 ges_offset_w;
+	s8 ges_offset_e;
+	u8 ges_dimension;
+};
+
+struct tmg399x_ges_raw_data {
+	int north;
+	int south;
+	int west;
+	int east;
+};
+
+struct sGesture_Result
+{
+    int  gesture_style;
+    long enter_time;
+    long exit_time;
+    int  enter_angle;
+    int  exit_angle;
+};
+
+struct tmg399x_wake_lock{
+    struct wake_lock lock;
+    bool   locked;
+    char   *name;
+};
+
+struct tmg399x_chip {
+	struct mutex lock;
+    struct tmg399x_wake_lock proximity_wakelock;
+    struct tmg399x_wake_lock display_power_controller;
+	struct i2c_client *client;
+	struct work_struct irq_work;
+	struct delayed_work als_poll_work;
+	struct delayed_work prox_thres_cal_work;
+    struct delayed_work prox_offset_cal_work;
+    struct delayed_work gesture_offset_cal_work;
+
+	struct hrtimer prox_unwakelock_timer;
+
+	struct tmg399x_prox_info prx_inf;
+	struct tmg399x_als_info als_inf;
+	struct tmg399x_parameters params;
+	struct tmg399x_i2c_platform_data *pdata;
+    struct tmg399x_ges_raw_data gesture_data[32];
+	struct lux_segment *segment;
+
+	struct input_dev *a_idev;
+	struct input_dev *p_idev;
+	struct input_dev *g_idev;
+
+    struct device *proximity_dev;
+    struct device *light_dev;
+    struct device *gesture_dev;
+
+	u8 shadow[48];
+	u8 device_index;
+
+	int  in_suspend;
+	int  wake_irq;
+	int  irq_pending;
+	int  segment_num;
+	int  seg_num_max;
+    int  light_poll_time;
+    int  irq_pin_num;
+
+    int  prox_calibrate_times;
+    int  prox_thres_hi_max;
+    int  prox_thres_hi_min;
+    int  prox_data_safe_range_max;
+    int  prox_data_safe_range_min;
+    int  prox_data_max;
+    int  gesture_data_max;
+    int  gesture_data_safe_range_max;
+    int  gesture_data_safe_range_min;
+    int  prox_manual_calibrate_threshold;
+    int  prox_uncover_data;
+
+	bool unpowered;
+	bool als_enabled;
+	bool wait_enabled;
+	bool prx_enabled;
+	bool ges_enabled;
+	bool ges_debug_enable;
+	bool light_debug_enable;
+	bool prox_debug_enable;
+	bool prox_calibrate_result;
+	bool prox_threshold_cal_start;
+    bool prox_offset_cal_result;
+	bool als_gain_auto;
+	bool wakeup_from_sleep;
+	bool wakelock_locked;
+	bool irq_enabled;
+	bool irq_work_status;
+	bool gesture_start; 
+	bool phone_is_sleep;
+    bool prox_offset_cal_start;
+    bool gesture_offset_cal_start;
+    bool gesture_offset_cal_result;
+
+    char *chip_name;
+
+};
+
+struct lux_segment {
+	int d_factor;
+	int r_coef;
+	int g_coef;
+	int b_coef;
+	int ct_coef;
+	int ct_offset;
+};
+
+struct tmg399x_i2c_platform_data {
+	/* The following callback for power events received and handled by
+	   the driver.  Currently only for SUSPEND and RESUME */
+	int (*platform_power)(struct device *dev, enum tmg399x_pwr_state state);
+	int (*platform_init)(void);
+	void (*platform_teardown)(struct device *dev);
+	char const *prox_name;
+	char const *als_name;
+	char const *ges_name;
+	struct tmg399x_parameters parameters;
+	bool proximity_can_wake;
+	bool als_can_wake;
+	struct lux_segment *segment;
+	int segment_num;
+};
+
+#endif /* __TMG399X_H */
diff --git a/include/linux/pn544.h b/include/linux/pn544.h
new file mode 100755
index 0000000..bb8d217
--- /dev/null
+++ b/include/linux/pn544.h
@@ -0,0 +1,34 @@
+/*
+* pn544.h
+* Copyright (C) 2011	NXP Semiconductors
+*/
+
+//ALERT:please relocate pn544.h under .\kernel\include\linux
+
+#define PN544_DRIVER_NAME	"pn544"
+
+#define HCI_MODE	0
+#define FW_MODE		1
+
+#define PN544_MAGIC	0xE9
+
+/*
+ * PN544 power control via ioctl
+ * PN544_SET_PWR(0): power off
+ * PN544_SET_PWR(1): power on
+ * PN544_SET_PWR(2): reset and power on with firmware download enabled
+ */
+#define PN544_SET_PWR	_IOW(PN544_MAGIC, 0x01, unsigned int)
+
+#ifdef __KERNEL__
+/* board config */
+struct pn544_nfc_platform_data {
+	int (*request_resources) (struct i2c_client *client);
+	void (*free_resources) (void);
+	void (*enable) (int fw);
+	int (*test) (void);
+	void (*disable) (void);
+	int (*irq_status) (void);
+};
+#endif /* __KERNEL__ */
+
diff --git a/include/linux/power_supply.h b/include/linux/power_supply.h
old mode 100644
new mode 100755
index 351fd1c..fc3d935
--- a/include/linux/power_supply.h
+++ b/include/linux/power_supply.h
@@ -110,6 +110,9 @@ enum power_supply_property {
 	POWER_SUPPLY_PROP_VCHG_LOOP_DBC_BYPASS,
 	POWER_SUPPLY_PROP_CURRENT_NOW,
 	POWER_SUPPLY_PROP_CURRENT_AVG,
+	#ifdef CONFIG_ZTEMT_COMM_CHARGE	
+	POWER_SUPPLY_PROP_CHARGER_ONLINE,
+	#endif	
 	POWER_SUPPLY_PROP_POWER_NOW,
 	POWER_SUPPLY_PROP_POWER_AVG,
 	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
diff --git a/include/linux/qpnp/qpnp-adc.h b/include/linux/qpnp/qpnp-adc.h
old mode 100644
new mode 100755
index 52195c1..5a51245
--- a/include/linux/qpnp/qpnp-adc.h
+++ b/include/linux/qpnp/qpnp-adc.h
@@ -141,6 +141,10 @@ enum qpnp_iadc_channels {
 #define QPNP_ADC_HWMON_NAME_LENGTH				64
 #define QPNP_MAX_PROP_NAME_LEN					32
 
+#ifdef CONFIG_NX503A_ZTEMT_DEVICE_INFO
+struct qpnp_chg_chip;
+#endif
+
 /* Structure device for qpnp vadc */
 struct qpnp_vadc_chip;
 
@@ -1704,4 +1708,7 @@ static inline struct qpnp_adc_tm_chip *qpnp_get_adc_tm(struct device *dev,
 { return ERR_PTR(-ENXIO); }
 #endif
 
+#ifdef CONFIG_ZTEMT_COMM_CHARGE
+void qpnp_notify_charger_of_the_charger_type(int i_chg_type);
+#endif
 #endif
diff --git a/include/linux/qpnp/qpnp-device-info.h b/include/linux/qpnp/qpnp-device-info.h
new file mode 100755
index 0000000..933dcfe
--- /dev/null
+++ b/include/linux/qpnp/qpnp-device-info.h
@@ -0,0 +1,91 @@
+/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef QPNP_DEVICE_INFO_H
+#define QPNP_DEVICE_INFO_H
+
+#include <linux/errno.h>
+#include <linux/qpnp/qpnp-adc.h>
+
+typedef enum
+{
+  Z5S_HW_INVALID=0,
+  	
+	Z5S_HW_01AMB_B=1,
+	Z5S_HW_01AMB_D,
+	Z5S_HW_01AMB_C,
+
+	Z5S_HW_01AMB_B_SIMPLIFY=1,
+	Z5S_HW_P3,
+	Z5S_HW_P2,
+
+	Z5S_HW_01AMBC_A=1,
+	Z5S_HW_01AMBC_C,
+	Z5S_HW_01AMBC_B,
+
+	Z5S_HW_MAX ,      // unknow, fail read
+}hw_version_type;
+
+typedef enum
+{
+	Z5S_PROJECT_INVALID=0,     
+	Z5S_PROJECT_AMB,
+	Z5S_PROJECT_NX503J_V4,
+	Z5S_PROJECT_AMB_SIMPLIFY,	 //0.9V
+	Z5S_PROJECT_AMBC,
+	Z5S_PROJECT_MAX,
+}project_version_type;
+
+/*
+ Notice:
+   Added From The Last Index
+*/
+typedef enum
+{
+	DEVICE_INDEX_INVALID=0,
+	DEVICE_01AMB_B_BCM4339, // Complete Version
+  DEVICE_01AMB_C,
+  DEVICE_01AMB_D,
+  DEVICE_01AMB_B_WTR1605_L_EMMC_16_32, //Simple Version
+  DEVICE_PCB2,
+  DEVICE_PCB3,
+  DEVICE_01AMBC_A_3680,
+  DEVICE_01AMBC_B,
+  DEVICE_01AMBC_C,   
+  DEVICE_INDEX_MAX,
+}device_index_type;
+
+struct hardware_id_map_st {
+	int low_mv;
+	int high_mv;
+	hw_version_type hw_type;
+	char hw_ver[50];
+	device_index_type device_index;
+	char names[10];
+};
+
+struct project_id_map_st {
+	int low_mv;
+	int high_mv;
+	project_version_type project_type;
+	char project_ver[50];
+};
+
+void 
+ztemt_get_hw_pcb_version(char* result);
+void 
+ztemt_get_project_version(char* result);
+int  
+ztemt_get_device_index(char* result);
+int   
+device_info_init(struct qpnp_vadc_chip* chip);
+#endif
diff --git a/include/linux/usb/android.h b/include/linux/usb/android.h
old mode 100644
new mode 100755
index 4accfa0..6c61912
--- a/include/linux/usb/android.h
+++ b/include/linux/usb/android.h
@@ -26,7 +26,11 @@ struct android_usb_platform_data {
 	u32 swfi_latency;
 	u8 usb_core_id;
 	bool cdrom;
+#ifdef CONFIG_ZTEMT_USB
+	bool external_ums;
+#else
 	bool internal_ums;
+#endif
 	char streaming_func[MAX_STREAMING_FUNCS][FUNC_NAME_LEN];
 	int  streaming_func_count;
 	u32 uicc_nluns;
diff --git a/include/linux/usb/composite.h b/include/linux/usb/composite.h
old mode 100644
new mode 100755
index 742b9e4..aa66146
--- a/include/linux/usb/composite.h
+++ b/include/linux/usb/composite.h
@@ -283,7 +283,11 @@ struct usb_composite_driver {
 	const char				*name;
 	const char				*iProduct;
 	const char				*iManufacturer;
+#ifdef CONFIG_ZTEMT_USB
+	struct usb_device_descriptor		*dev;
+#else
 	const struct usb_device_descriptor	*dev;
+#endif
 	struct usb_gadget_strings		**strings;
 	enum usb_device_speed			max_speed;
 	unsigned		needs_serial:1;
diff --git a/include/media/msm_cam_sensor.h b/include/media/msm_cam_sensor.h
old mode 100644
new mode 100755
index a140d4b..845c7b6
--- a/include/media/msm_cam_sensor.h
+++ b/include/media/msm_cam_sensor.h
@@ -128,6 +128,9 @@ enum msm_sensor_resolution_t {
 	MSM_SENSOR_RES_5,
 	MSM_SENSOR_RES_6,
 	MSM_SENSOR_RES_7,
+	MSM_SENSOR_RES_8,
+	MSM_SENSOR_RES_9,
+	MSM_SENSOR_RES_10,
 	MSM_SENSOR_INVALID_RES,
 };
 
@@ -486,6 +489,11 @@ enum msm_sensor_cfg_type_t {
 	CFG_SET_WHITE_BALANCE,
 	CFG_SET_AUTOFOCUS,
 	CFG_CANCEL_AUTOFOCUS,
+	CFG_SET_MANUAL_AF_ZTEMT,           //ZTEMT: Jinghongliang Add For Manual AF Mode
+	//	#ifdef CONFIG_ZTEMT_CAMERA_OIS     //ZTEMT CAMERA FOR OIS MENU ----START
+	CFG_ENABLE_OIS,
+	CFG_DISABLE_OIS,
+   //  #endif                             //ZTEMT CAMERA FOR OIS MENU ----END
 };
 
 enum msm_actuator_cfg_type_t {
@@ -597,6 +605,12 @@ enum af_camera_name {
 	ACTUATOR_MAIN_CAM_3,
 	ACTUATOR_MAIN_CAM_4,
 	ACTUATOR_MAIN_CAM_5,
+	ACTUATOR_MAIN_CAM_6,
+	ACTUATOR_MAIN_CAM_7,
+	ACTUATOR_MAIN_CAM_8,
+	ACTUATOR_MAIN_CAM_9,
+	ACTUATOR_MAIN_CAM_10,
+	ACTUATOR_MAIN_CAM_11,
 	ACTUATOR_WEB_CAM_0,
 	ACTUATOR_WEB_CAM_1,
 	ACTUATOR_WEB_CAM_2,
diff --git a/include/media/msm_camera.h b/include/media/msm_camera.h
old mode 100644
new mode 100755
index b4b3bfc..a7e9367
--- a/include/media/msm_camera.h
+++ b/include/media/msm_camera.h
@@ -1305,6 +1305,9 @@ enum msm_sensor_resolution_t {
 	MSM_SENSOR_RES_5,
 	MSM_SENSOR_RES_6,
 	MSM_SENSOR_RES_7,
+	MSM_SENSOR_RES_8,
+	MSM_SENSOR_RES_9,
+	MSM_SENSOR_RES_10,
 	MSM_SENSOR_INVALID_RES,
 };
 
diff --git a/kernel/power/suspend.c b/kernel/power/suspend.c
index 172e415..936e4e3 100644
--- a/kernel/power/suspend.c
+++ b/kernel/power/suspend.c
@@ -36,7 +36,9 @@ const char *const pm_states[PM_SUSPEND_MAX] = {
 	[PM_SUSPEND_STANDBY]	= "standby",
 	[PM_SUSPEND_MEM]	= "mem",
 };
-
+#ifdef CONFIG_ZTEMT_POWER_DEBUG
+bool wakeup_wake_lock_debug = false;
+#endif
 static const struct platform_suspend_ops *suspend_ops;
 
 /**
@@ -215,6 +217,9 @@ int suspend_devices_and_enter(suspend_state_t state)
 		if (error)
 			goto Close;
 	}
+	#ifdef CONFIG_ZTEMT_POWER_DEBUG
+	wakeup_wake_lock_debug = true;
+	#endif
 	suspend_console();
 	suspend_test_start();
 	error = dpm_suspend_start(PMSG_SUSPEND);
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
old mode 100644
new mode 100755
index 7eefa94..ae2bec5
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -788,6 +788,7 @@ bool is_cma_pageblock(struct page *page)
 {
 	return get_pageblock_migratetype(page) == MIGRATE_CMA;
 }
+EXPORT_SYMBOL(is_cma_pageblock);	//ZTEMT: For Tuxera exfat
 
 /* Free whole pageblock and set it's migration type to MIGRATE_CMA. */
 void __init init_cma_reserved_pageblock(struct page *page)
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index 4ff640a..f9865b6 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -1726,6 +1726,8 @@ static int nl80211_set_interface(struct sk_buff *skb, struct genl_info *info)
 
 	memset(&params, 0, sizeof(params));
 
+printk("sh %s \n", __func__);
+
 	otype = ntype = dev->ieee80211_ptr->iftype;
 
 	if (info->attrs[NL80211_ATTR_IFTYPE]) {
diff --git a/net/wireless/util.c b/net/wireless/util.c
index b83c5b2..6c1bda9 100644
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -811,6 +811,7 @@ int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
 	enum nl80211_iftype otype = dev->ieee80211_ptr->iftype;
 
 	ASSERT_RDEV_LOCK(rdev);
+printk("shaohua %s\n", __func__);
 
 	/* don't support changing VLANs, you just re-create them */
 	if (otype == NL80211_IFTYPE_AP_VLAN)
diff --git a/security/selinux/avc.c b/security/selinux/avc.c
old mode 100644
new mode 100755
diff --git a/sound/Kconfig b/sound/Kconfig
index 261a03c..08382e1 100644
--- a/sound/Kconfig
+++ b/sound/Kconfig
@@ -59,6 +59,19 @@ config SOUND_OSS_CORE_PRECLAIM
 
 source "sound/oss/dmasound/Kconfig"
 
+config ZTEMT_AUDIO_HEADSET_SW
+    bool "AUDIO MACRO for ZTEMT HEADSET SW"
+    default n
+    help
+        AUDIO MACRO for ZTEMT Z7
+ 
+config ZTEMT_AUDIO_MBHC_OPEN
+
+    bool "AUDIO MACRO for MBHC OPEN"
+    default n
+    help
+        AUDIO MACRO for ZTEMT Z7
+
 if !M68K && !UML
 
 menuconfig SND
diff --git a/sound/soc/codecs/wcd9xxx-mbhc.c b/sound/soc/codecs/wcd9xxx-mbhc.c
old mode 100644
new mode 100755
index 1cc809c..b14c5db
--- a/sound/soc/codecs/wcd9xxx-mbhc.c
+++ b/sound/soc/codecs/wcd9xxx-mbhc.c
@@ -100,7 +100,7 @@
  * Invalid voltage range for the detection
  * of plug type with current source
  */
-#define WCD9XXX_CS_MEAS_INVALD_RANGE_LOW_MV 160
+#define WCD9XXX_CS_MEAS_INVALD_RANGE_LOW_MV  266
 #define WCD9XXX_CS_MEAS_INVALD_RANGE_HIGH_MV 265
 
 /*
@@ -130,6 +130,14 @@ module_param(impedance_detect_en, int,
 			S_IRUGO | S_IWUSR | S_IWGRP);
 MODULE_PARM_DESC(impedance_detect_en, "enable/disable impedance detect");
 
+// add by wuzehui for headset impedance
+static int impedance;
+module_param(impedance, int,
+			S_IRUGO | S_IWUSR | S_IWGRP);
+MODULE_PARM_DESC(impedance, "enable/disable impedance detect");
+// end
+
+
 static bool detect_use_vddio_switch;
 
 struct wcd9xxx_mbhc_detect {
@@ -831,6 +839,14 @@ static void wcd9xxx_report_plug(struct wcd9xxx_mbhc *mbhc, int insertion,
 	pr_debug("%s: enter insertion %d hph_status %x\n",
 		 __func__, insertion, mbhc->hph_status);
 	if (!insertion) {
+        // add by wuzehui for headset impedance
+        impedance = 0;
+#ifdef CONFIG_ZTEMT_AUDIO_HEADSET_SW
+        if(mbhc->mbhc_cfg->sw_gpio){
+            gpio_direction_output(mbhc->mbhc_cfg->sw_gpio,0);
+            pr_debug("Get Gpio .......... %d\n",gpio_get_value_cansleep(mbhc->mbhc_cfg->sw_gpio));
+        }
+#endif
 		/* Report removal */
 		mbhc->hph_status &= ~jack_type;
 		/*
@@ -1419,6 +1435,9 @@ wcd9xxx_cs_find_plug_type(struct wcd9xxx_mbhc *mbhc,
 			hs_max = WCD9XXX_V_CS_HS_MAX;
 			no_mic = WCD9XXX_V_CS_NO_MIC;
 		}
+		
+		pr_debug("[ZTEMT]%s: dce_z #%04d, mb_mv #%04d, hs_max #%04d, no_mic #%04d\n",
+			 __func__, dce_z, mb_mv, hs_max, no_mic);
 
 		vdce = __wcd9xxx_codec_sta_dce_v(mbhc, true, d->dce,
 						 dce_z, (u32)mb_mv);
@@ -3233,6 +3252,18 @@ static void wcd9xxx_swch_irq_handler(struct wcd9xxx_mbhc *mbhc)
 		snd_soc_update_bits(codec, mbhc->mbhc_bias_regs.ctl_reg, 0x01,
 				    0x00);
 		snd_soc_update_bits(codec, WCD9XXX_A_MBHC_HPH, 0x01, 0x00);
+#ifdef CONFIG_ZTEMT_AUDIO_HEADSET_SW
+        if(mbhc->mbhc_cfg->sw_gpio){
+            pr_debug("GPIO start get value %d =====\n",gpio_get_value_cansleep(mbhc->mbhc_cfg->sw_gpio));
+            /* Close the NCP for enabling the earphone */
+            msleep(300);
+            gpio_direction_output(mbhc->mbhc_cfg->sw_gpio,0);
+            msleep(100);
+            gpio_direction_output(mbhc->mbhc_cfg->sw_gpio,1);
+            msleep(100);
+            pr_debug("GPIO end get value %d==== \n",gpio_get_value_cansleep(mbhc->mbhc_cfg->sw_gpio));
+        } 
+#endif
 		wcd9xxx_mbhc_detect_plug_type(mbhc);
 	} else if ((mbhc->current_plug != PLUG_TYPE_NONE) && !insert) {
 		mbhc->lpi_enabled = false;
@@ -4912,6 +4943,14 @@ static int wcd9xxx_detect_impedance(struct wcd9xxx_mbhc *mbhc, uint32_t *zl,
 	pr_debug("%s: RL %d milliohm, RR %d milliohm\n", __func__, *zl, *zr);
 	pr_debug("%s: Impedance detection completed\n", __func__);
 
+    // add by wuzehui for headset impedance
+    if(*zl<*zr) {
+        impedance = *zl/1000;
+    } else {
+        impedance = *zr/1000;
+    }
+    // end
+
 	return ret;
 }
 
diff --git a/sound/soc/codecs/wcd9xxx-mbhc.h b/sound/soc/codecs/wcd9xxx-mbhc.h
index 7eba649..e1eef8a 100644
--- a/sound/soc/codecs/wcd9xxx-mbhc.h
+++ b/sound/soc/codecs/wcd9xxx-mbhc.h
@@ -249,6 +249,10 @@ struct wcd9xxx_mbhc_config {
 	bool use_vddio_meas;
 	bool enable_anc_mic_detect;
 	enum hw_jack_type hw_jack_type;
+    //add by wuzehui for using the switch function
+#ifdef CONFIG_ZTEMT_AUDIO_HEADSET_SW
+    int sw_gpio;
+#endif
 };
 
 struct wcd9xxx_cfilt_mode {
diff --git a/sound/soc/msm/msm8974.c b/sound/soc/msm/msm8974.c
old mode 100644
new mode 100755
index 1a37e45..2c502c4
--- a/sound/soc/msm/msm8974.c
+++ b/sound/soc/msm/msm8974.c
@@ -62,7 +62,7 @@ static int msm8974_auxpcm_rate = 8000;
 #define I2S_PCM_SEL 1
 #define I2S_PCM_SEL_OFFSET 1
 
-#define WCD9XXX_MBHC_DEF_BUTTONS 8
+#define WCD9XXX_MBHC_DEF_BUTTONS 3
 #define WCD9XXX_MBHC_DEF_RLOADS 5
 #define TAIKO_EXT_CLK_RATE 9600000
 
@@ -114,6 +114,31 @@ void *def_taiko_mbhc_cal(void);
 static int msm_snd_enable_codec_ext_clk(struct snd_soc_codec *codec, int enable,
 					bool dapm);
 
+#ifdef CONFIG_ZTEMT_AUDIO_MBHC_OPEN
+static struct wcd9xxx_mbhc_config mbhc_cfg = {
+	.read_fw_bin = false,
+	.calibration = NULL,
+	.micbias = MBHC_MICBIAS2,
+	.anc_micbias = MBHC_MICBIAS2,
+	.mclk_cb_fn = msm_snd_enable_codec_ext_clk,
+	.mclk_rate = TAIKO_EXT_CLK_RATE,
+	.gpio = 0,
+	.gpio_irq = 0,
+	.gpio_level_insert = 0,
+	.detect_extn_cable = true,
+	.micbias_enable_flags = 1 << MBHC_MICBIAS_ENABLE_THRESHOLD_HEADSET,
+	.insert_detect = true,
+	.swap_gnd_mic = NULL,
+	.cs_enable_flags = (1 << MBHC_CS_ENABLE_POLLING |
+			    1 << MBHC_CS_ENABLE_INSERTION |
+			    1 << MBHC_CS_ENABLE_REMOVAL |
+			    1 << MBHC_CS_ENABLE_DET_ANC),
+	.do_recalibration = true,
+	.use_vddio_meas = true,
+	.enable_anc_mic_detect = false,
+	.hw_jack_type = SIX_POLE_JACK,
+};
+#else
 static struct wcd9xxx_mbhc_config mbhc_cfg = {
 	.read_fw_bin = false,
 	.calibration = NULL,
@@ -137,6 +162,7 @@ static struct wcd9xxx_mbhc_config mbhc_cfg = {
 	.enable_anc_mic_detect = false,
 	.hw_jack_type = SIX_POLE_JACK,
 };
+#endif
 
 struct msm_auxpcm_gpio {
 	unsigned gpio_no;
@@ -199,6 +225,11 @@ static struct regulator *ext_spk_amp_regulator;
 static int ext_spk_amp_gpio = -1;
 static int ext_ult_spk_amp_gpio = -1;
 static int ext_ult_lo_amp_gpio = -1;
+/*Add by wuzehui for ext_lineout amp gpio  */
+#ifdef CONFIG_ZTEMT_AUDIO_HEADSET_SW
+	int mbhc_switch_enable_gpio = -1;
+#endif
+//end
 static int msm8974_spk_control = 1;
 static int msm8974_ext_spk_pamp;
 static int msm_slim_0_rx_ch = 1;
@@ -1698,7 +1729,7 @@ void *def_taiko_mbhc_cal(void)
 #undef S
 #define S(X, Y) ((WCD9XXX_MBHC_CAL_PLUG_TYPE_PTR(taiko_cal)->X) = (Y))
 	S(v_no_mic, 30);
-	S(v_hs_max, 2400);
+	S(v_hs_max, 3000);
 #undef S
 #define S(X, Y) ((WCD9XXX_MBHC_CAL_BTN_DET_PTR(taiko_cal)->X) = (Y))
 	S(c[0], 62);
@@ -1717,11 +1748,12 @@ void *def_taiko_mbhc_cal(void)
 	btn_high = wcd9xxx_mbhc_cal_btn_det_mp(btn_cfg,
 					       MBHC_BTN_DET_V_BTN_HIGH);
 	btn_low[0] = -50;
-	btn_high[0] = 20;
-	btn_low[1] = 21;
-	btn_high[1] = 61;
-	btn_low[2] = 62;
-	btn_high[2] = 104;
+	btn_high[0] = 140;
+	btn_low[1] = 141;
+	btn_high[1] = 261;
+	btn_low[2] = 262;
+	btn_high[2] = 404;
+#if 0
 	btn_low[3] = 105;
 	btn_high[3] = 148;
 	btn_low[4] = 149;
@@ -1732,6 +1764,7 @@ void *def_taiko_mbhc_cal(void)
 	btn_high[6] = 269;
 	btn_low[7] = 270;
 	btn_high[7] = 500;
+#endif
 	n_ready = wcd9xxx_mbhc_cal_btn_det_mp(btn_cfg, MBHC_BTN_DET_N_READY);
 	n_ready[0] = 80;
 	n_ready[1] = 68;
@@ -2955,6 +2988,24 @@ static __devinit int msm8974_asoc_machine_probe(struct platform_device *pdev)
 			dev_dbg(&pdev->dev, "Unknown value, hence setting to default");
 		}
 	}
+
+// Add by wuzehui
+#ifdef CONFIG_ZTEMT_AUDIO_HEADSET_SW
+    if(mbhc_switch_enable_gpio == -1 ) {
+        mbhc_switch_enable_gpio = of_get_named_gpio(pdev->dev.of_node,
+                "qcom,mbhc-switch-enable-gpio", 0);
+        if(mbhc_switch_enable_gpio >= 0){
+            mbhc_cfg.sw_gpio = mbhc_switch_enable_gpio;
+            gpio_request(mbhc_cfg.sw_gpio, "headset");
+            gpio_direction_output(mbhc_cfg.sw_gpio,0);
+            pr_debug("headset switch gpio %d and set the value %d\n",
+                    mbhc_cfg.sw_gpio,gpio_get_value_cansleep(mbhc_cfg.sw_gpio));
+        } else
+            mbhc_cfg.sw_gpio = 0;
+        pr_debug("qcom,mbhc-switch-enable-gpio is %d\n",mbhc_cfg.sw_gpio);
+    }
+#endif
+// end by wuzehui
 	if (of_property_read_bool(pdev->dev.of_node, "qcom,hdmi-audio-rx")) {
 		dev_info(&pdev->dev, "%s(): hdmi audio support present\n",
 				__func__);
diff --git a/sound/soc/msm/qdsp6v2/msm-dolby-dap-config.c b/sound/soc/msm/qdsp6v2/msm-dolby-dap-config.c
old mode 100644
new mode 100755
index 161904c..24a279a
--- a/sound/soc/msm/qdsp6v2/msm-dolby-dap-config.c
+++ b/sound/soc/msm/qdsp6v2/msm-dolby-dap-config.c
@@ -44,196 +44,188 @@ struct dolby_dap_endp_params_s {
 const struct dolby_dap_endp_params_s
 			dolby_dap_endp_params[NUM_DOLBY_ENDP_DEVICE] = {
 	{EARPIECE, 2, DOLBY_ENDP_EXT_SPEAKERS,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-320, -320, 144}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-320, -320, 144, 0}
 	},
 	{SPEAKER, 2, DOLBY_ENDP_INT_SPEAKERS,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-320, -320, 144}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-320, -320, 96, 2}
 	},
 	{WIRED_HEADSET,	2, DOLBY_ENDP_HEADPHONES,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-320, -320, 144}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-320, -320, 144, 3}
 	},
 	{WIRED_HEADPHONE, 2, DOLBY_ENDP_HEADPHONES,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-320, -320, 144}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-320, -320, 48, 1}
 	},
 	{BLUETOOTH_SCO,	2, DOLBY_ENDP_EXT_SPEAKERS,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-320, -320, 144}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-320, -320, 144, 0}
 	},
 	{BLUETOOTH_SCO_HEADSET,	2, DOLBY_ENDP_EXT_SPEAKERS,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-320, -320, 144}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-320, -320, 144, 0}
 	},
 	{BLUETOOTH_SCO_CARKIT, 2, DOLBY_ENDP_EXT_SPEAKERS,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-320, -320, 144}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-320, -320, 144, 0}
 	},
 	{BLUETOOTH_A2DP, 2, DOLBY_ENDP_EXT_SPEAKERS,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-320, -320, 144}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-320, -320, 144, 0}
 	},
 	{BLUETOOTH_A2DP_HEADPHONES, 2, DOLBY_ENDP_HEADPHONES,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-320, -320, 144}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-320, -320, 144, 0}
 	},
 	{BLUETOOTH_A2DP_SPEAKER, 2, DOLBY_ENDP_EXT_SPEAKERS,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-320, -320, 144}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-320, -320, 144, 0}
 	},
 	{AUX_DIGITAL, 2, DOLBY_ENDP_HDMI,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-496, -496, 0}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-496, -496, 0, 0}
 	},
 	{AUX_DIGITAL, 6, DOLBY_ENDP_HDMI,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-496, -496, 0}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-496, -496, 0, 0}
 	},
 	{AUX_DIGITAL, 8, DOLBY_ENDP_HDMI,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-496, -496, 0}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-496, -496, 0, 0}
 	},
 	{ANLG_DOCK_HEADSET, 2, DOLBY_ENDP_HEADPHONES,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-320, -320, 144}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-320, -320, 144, 0}
 	},
 	{DGTL_DOCK_HEADSET, 2, DOLBY_ENDP_HEADPHONES,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-320, -320, 144}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-320, -320, 144, 0}
 	},
 	{USB_ACCESSORY,	2, DOLBY_ENDP_EXT_SPEAKERS,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-320, -320, 144}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-320, -320, 144, 0}
 	},
 	{USB_DEVICE, 2, DOLBY_ENDP_EXT_SPEAKERS,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-320, -320, 144}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-320, -320, 144, 0}
 	},
-	{REMOTE_SUBMIX,	2, DOLBY_ENDP_HDMI,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+	{REMOTE_SUBMIX,	2, DOLBY_ENDP_EXT_SPEAKERS,
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-496, -496, 0}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-320, -320, 144, 0}
 	},
 	{ANC_HEADSET, 2, DOLBY_ENDP_HEADPHONES,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-320, -320, 144}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-320, -320, 144, 0}
 	},
 	{ANC_HEADPHONE,	2, DOLBY_ENDP_HEADPHONES,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-320, -320, 144}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-320, -320, 144, 0}
 	},
 	{PROXY,	2, DOLBY_ENDP_EXT_SPEAKERS,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-320, -320, 144}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-320, -320, 144, 0}
 	},
-	{PROXY,	6, DOLBY_ENDP_EXT_SPEAKERS,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+	{FM, 2, DOLBY_ENDP_EXT_SPEAKERS,
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-320, -320, 144}
-	},
-	{FM, 2, DOLBY_ENDP_HDMI,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
-		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
-		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-496, -496, 0}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-320, -320, 144, 0}
 	},
 	{FM_TX,	2, DOLBY_ENDP_EXT_SPEAKERS,
-		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB, DOLBY_PARAM_ID_DVLA},
 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
-		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+		 DOLBY_ENDDEP_PARAM_VMB_LENGTH, DOLBY_ENDDEP_PARAM_DVLA_LENGTH},
 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
-		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
-		{-320, -320, 144}
+		 DOLBY_ENDDEP_PARAM_VMB_OFFSET, DOLBY_ENDDEP_PARAM_DVLA_OFFSET},
+		{-320, -320, 144, 0}
 	},
 };
 
@@ -417,8 +409,7 @@ static int dolby_dap_send_enddep_params(int port_id, int device_channels)
 	for (idx = 0; idx < NUM_DOLBY_ENDP_DEVICE; idx++) {
 		if (dolby_dap_endp_params[idx].device ==
 			dolby_dap_params_states.device) {
-			if (dolby_dap_params_states.device == AUX_DIGITAL ||
-			    dolby_dap_params_states.device == PROXY) {
+			if (dolby_dap_params_states.device == AUX_DIGITAL) {
 				if (dolby_dap_endp_params[idx].device_ch_caps ==
 					device_channels)
 					break;
diff --git a/sound/soc/msm/qdsp6v2/msm-dolby-dap-config.h b/sound/soc/msm/qdsp6v2/msm-dolby-dap-config.h
old mode 100644
new mode 100755
index 14586f4..1c87f6e
--- a/sound/soc/msm/qdsp6v2/msm-dolby-dap-config.h
+++ b/sound/soc/msm/qdsp6v2/msm-dolby-dap-config.h
@@ -226,7 +226,7 @@
 #define DOLBY_PARAM_PAYLOAD_SIZE		3
 #define DOLBY_MAX_LENGTH_INDIVIDUAL_PARAM	329
 
-#define DOLBY_NUM_ENDP_DEPENDENT_PARAMS	  3
+#define DOLBY_NUM_ENDP_DEPENDENT_PARAMS	  4
 #define DOLBY_ENDDEP_PARAM_DVLO_OFFSET	  0
 #define DOLBY_ENDDEP_PARAM_DVLO_LENGTH	  1
 #define DOLBY_ENDDEP_PARAM_DVLI_OFFSET    (DOLBY_ENDDEP_PARAM_DVLO_OFFSET + \
@@ -235,8 +235,12 @@
 #define DOLBY_ENDDEP_PARAM_VMB_OFFSET     (DOLBY_ENDDEP_PARAM_DVLI_OFFSET + \
 						DOLBY_ENDDEP_PARAM_DVLI_LENGTH)
 #define DOLBY_ENDDEP_PARAM_VMB_LENGTH     1
+#define DOLBY_ENDDEP_PARAM_DVLA_OFFSET    (DOLBY_ENDDEP_PARAM_VMB_OFFSET + \
+                        DOLBY_ENDDEP_PARAM_VMB_LENGTH)
+#define DOLBY_ENDDEP_PARAM_DVLA_LENGTH    1
 #define DOLBY_ENDDEP_PARAM_LENGTH         (DOLBY_ENDDEP_PARAM_DVLO_LENGTH + \
-		DOLBY_ENDDEP_PARAM_DVLI_LENGTH + DOLBY_ENDDEP_PARAM_VMB_LENGTH)
+		DOLBY_ENDDEP_PARAM_DVLI_LENGTH + DOLBY_ENDDEP_PARAM_VMB_LENGTH + \
+        DOLBY_ENDDEP_PARAM_DVLA_LENGTH)
 
 #define MAX_DOLBY_PARAMS			47
 #define MAX_DOLBY_CTRL_PARAMS			5
@@ -249,7 +253,7 @@
 #define DOLBY_AUTO_ENDDEP_IDX			(MAX_DOLBY_PARAMS+4)
 
 #define TOTAL_LENGTH_DOLBY_PARAM		745
-#define NUM_DOLBY_ENDP_DEVICE			24
+#define NUM_DOLBY_ENDP_DEVICE			23
 #define DOLBY_VIS_PARAM_HEADER_SIZE		 25
 
 #define DOLBY_INVALID_PORT_ID			-1
-- 
1.9.1

